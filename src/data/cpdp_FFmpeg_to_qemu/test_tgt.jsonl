{"project": "qemu", "commit_id": "c0c24b95542bc1a4dc3fc6ea71475ae04fa69189", "target": 1, "func": "static int xen_9pfs_connect(struct XenDevice *xendev)\n\n{\n\n    int i;\n\n    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);\n\n    V9fsState *s = &xen_9pdev->state;\n\n    QemuOpts *fsdev;\n\n\n\n    if (xenstore_read_fe_int(&xen_9pdev->xendev, \"num-rings\",\n\n                             &xen_9pdev->num_rings) == -1 ||\n\n        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n\n        return -1;\n\n    }\n\n\n\n    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));\n\n    for (i = 0; i < xen_9pdev->num_rings; i++) {\n\n        char *str;\n\n        int ring_order;\n\n\n\n        xen_9pdev->rings[i].priv = xen_9pdev;\n\n        xen_9pdev->rings[i].evtchn = -1;\n\n        xen_9pdev->rings[i].local_port = -1;\n\n\n\n        str = g_strdup_printf(\"ring-ref%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].ref) == -1) {\n\n\n            goto out;\n\n        }\n\n\n        str = g_strdup_printf(\"event-channel-%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].evtchn) == -1) {\n\n\n            goto out;\n\n        }\n\n\n\n\n        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].intf) {\n\n            goto out;\n\n        }\n\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n\n        if (ring_order > MAX_RING_ORDER) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring_order = ring_order;\n\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                (1 << ring_order),\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].intf->ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].data) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +\n\n                                       XEN_FLEX_RING_SIZE(ring_order);\n\n\n\n        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);\n\n        xen_9pdev->rings[i].out_cons = 0;\n\n        xen_9pdev->rings[i].out_size = 0;\n\n        xen_9pdev->rings[i].inprogress = false;\n\n\n\n\n\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);\n\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n\n            goto out;\n\n        }\n\n        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain\n\n                                            (xen_9pdev->rings[i].evtchndev,\n\n                                             xendev->dom,\n\n                                             xen_9pdev->rings[i].evtchn);\n\n        if (xen_9pdev->rings[i].local_port == -1) {\n\n            xen_pv_printf(xendev, 0,\n\n                          \"xenevtchn_bind_interdomain failed port=%d\\n\",\n\n                          xen_9pdev->rings[i].evtchn);\n\n            goto out;\n\n        }\n\n        xen_pv_printf(xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n\n        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),\n\n                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n\n    }\n\n\n\n    xen_9pdev->security_model = xenstore_read_be_str(xendev, \"security_model\");\n\n    xen_9pdev->path = xenstore_read_be_str(xendev, \"path\");\n\n    xen_9pdev->id = s->fsconf.fsdev_id =\n\n        g_strdup_printf(\"xen9p%d\", xendev->dev);\n\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, \"tag\");\n\n    v9fs_register_transport(s, &xen_9p_transport);\n\n    fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n\n            s->fsconf.tag,\n\n            1, NULL);\n\n    qemu_opt_set(fsdev, \"fsdriver\", \"local\", NULL);\n\n    qemu_opt_set(fsdev, \"path\", xen_9pdev->path, NULL);\n\n    qemu_opt_set(fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n\n    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);\n\n    qemu_fsdev_add(fsdev);\n\n    v9fs_device_realize_common(s, NULL);\n\n\n\n    return 0;\n\n\n\nout:\n\n    xen_9pfs_free(xendev);\n\n    return -1;\n\n}", "idx": 12, "_split": "test", "_hash": "3ec2b1c9f8380398b09dd57ab35d08ea"}
{"project": "qemu", "commit_id": "24408a7d2b459bed3697367b81ada76518ca96ef", "target": 0, "func": "static void ppc_spapr_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    const char *kernel_cmdline = args->kernel_cmdline;\n\n    const char *initrd_filename = args->initrd_filename;\n\n    const char *boot_device = args->boot_order;\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    PCIHostState *phb;\n\n    int i;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    hwaddr rma_alloc_size;\n\n    uint32_t initrd_base = 0;\n\n    long kernel_size = 0, initrd_size = 0;\n\n    long load_limit, rtas_limit, fw_size;\n\n    bool kernel_le = false;\n\n    char *filename;\n\n\n\n    msi_supported = true;\n\n\n\n    spapr = g_malloc0(sizeof(*spapr));\n\n    QLIST_INIT(&spapr->phbs);\n\n\n\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n\n\n\n    /* Allocate RMA if necessary */\n\n    rma_alloc_size = kvmppc_alloc_rma(\"ppc_spapr.rma\", sysmem);\n\n\n\n    if (rma_alloc_size == -1) {\n\n        hw_error(\"qemu: Unable to create RMA\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    if (rma_alloc_size && (rma_alloc_size < ram_size)) {\n\n        spapr->rma_size = rma_alloc_size;\n\n    } else {\n\n        spapr->rma_size = ram_size;\n\n\n\n        /* With KVM, we don't actually know whether KVM supports an\n\n         * unbounded RMA (PR KVM) or is limited by the hash table size\n\n         * (HV KVM using VRMA), so we always assume the latter\n\n         *\n\n         * In that case, we also limit the initial allocations for RTAS\n\n         * etc... to 256M since we have no way to know what the VRMA size\n\n         * is going to be as it depends on the size of the hash table\n\n         * isn't determined yet.\n\n         */\n\n        if (kvm_enabled()) {\n\n            spapr->vrma_adjust = 1;\n\n            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);\n\n        }\n\n    }\n\n\n\n    /* We place the device tree and RTAS just below either the top of the RMA,\n\n     * or just below 2GB, whichever is lowere, so that it can be\n\n     * processed with 32-bit real mode code if necessary */\n\n    rtas_limit = MIN(spapr->rma_size, 0x80000000);\n\n    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;\n\n    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;\n\n    load_limit = spapr->fdt_addr - FW_OVERHEAD;\n\n\n\n    /* We aim for a hash table of size 1/128 the size of RAM.  The\n\n     * normal rule of thumb is 1/64 the size of RAM, but that's much\n\n     * more than needed for the Linux guests we support. */\n\n    spapr->htab_shift = 18; /* Minimum architected size */\n\n    while (spapr->htab_shift <= 46) {\n\n        if ((1ULL << (spapr->htab_shift + 7)) >= ram_size) {\n\n            break;\n\n        }\n\n        spapr->htab_shift++;\n\n    }\n\n\n\n    /* Set up Interrupt Controller before we create the VCPUs */\n\n    spapr->icp = xics_system_init(smp_cpus * kvmppc_smt_threads() / smp_threads,\n\n                                  XICS_IRQS);\n\n    spapr->next_irq = XICS_IRQ_BASE;\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n        cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n\n    }\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n\n\n        xics_cpu_setup(spapr->icp, cpu);\n\n\n\n        /* Set time-base frequency to 512 MHz */\n\n        cpu_ppc_tb_init(env, TIMEBASE_FREQ);\n\n\n\n        /* PAPR always has exception vectors in RAM not ROM. To ensure this,\n\n         * MSR[IP] should never be set.\n\n         */\n\n        env->msr_mask &= ~(1 << 6);\n\n\n\n        /* Tell KVM that we're in PAPR mode */\n\n        if (kvm_enabled()) {\n\n            kvmppc_set_papr(cpu);\n\n        }\n\n\n\n        qemu_register_reset(spapr_cpu_reset, cpu);\n\n    }\n\n\n\n    /* allocate RAM */\n\n    spapr->ram_limit = ram_size;\n\n    if (spapr->ram_limit > rma_alloc_size) {\n\n        ram_addr_t nonrma_base = rma_alloc_size;\n\n        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;\n\n\n\n        memory_region_init_ram(ram, NULL, \"ppc_spapr.ram\", nonrma_size);\n\n        vmstate_register_ram_global(ram);\n\n        memory_region_add_subregion(sysmem, nonrma_base, ram);\n\n    }\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n\n    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\n\n                                           rtas_limit - spapr->rtas_addr);\n\n    if (spapr->rtas_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n\n        hw_error(\"RTAS too big ! 0x%lx bytes (max is 0x%x)\\n\",\n\n                 spapr->rtas_size, RTAS_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* Set up EPOW events infrastructure */\n\n    spapr_events_init(spapr);\n\n\n\n    /* Set up VIO bus */\n\n    spapr->vio_bus = spapr_vio_bus_init();\n\n\n\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    /* We always have at least the nvram device on VIO */\n\n    spapr_create_nvram(spapr);\n\n\n\n    /* Set up PCI */\n\n    spapr_pci_msi_init(spapr, SPAPR_PCI_MSI_WINDOW);\n\n    spapr_pci_rtas_init();\n\n\n\n    phb = spapr_create_phb(spapr, 0);\n\n\n\n    for (i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!nd->model) {\n\n            nd->model = g_strdup(\"ibmveth\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n\n            spapr_vlan_create(spapr->vio_bus, nd);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n\n        spapr_vscsi_create(spapr->vio_bus);\n\n    }\n\n\n\n    /* Graphics */\n\n    if (spapr_vga_init(phb->bus)) {\n\n        spapr->has_graphics = true;\n\n    }\n\n\n\n    if (usb_enabled(spapr->has_graphics)) {\n\n        pci_create_simple(phb->bus, -1, \"pci-ohci\");\n\n        if (spapr->has_graphics) {\n\n            usbdevice_create(\"keyboard\");\n\n            usbdevice_create(\"mouse\");\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n\n        fprintf(stderr, \"qemu: pSeries SLOF firmware requires >= \"\n\n                \"%ldM guest RMA (Real Mode Area memory)\\n\", MIN_RMA_SLOF);\n\n        exit(1);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t lowaddr = 0;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_elf(kernel_filename,\n\n                                   translate_kernel_address, NULL,\n\n                                   NULL, &lowaddr, NULL, 0, ELF_MACHINE, 0);\n\n            kernel_le = kernel_size > 0;\n\n        }\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              KERNEL_LOAD_ADDR,\n\n                                              load_limit - KERNEL_LOAD_ADDR);\n\n        }\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            /* Try to locate the initrd in the gap between the kernel\n\n             * and the firmware. Add a bit of space just in case\n\n             */\n\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    spapr->entry_point = 0x100;\n\n\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    /* Prepare the device tree */\n\n    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model,\n\n                                            initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            boot_device, kernel_cmdline,\n\n                                            spapr->epow_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n}\n", "idx": 43, "_split": "test", "_hash": "a179b325e4f3c848b7cd2871c777c367"}
{"project": "qemu", "commit_id": "f1c52354e5bdab6983d13a4c174759c585e834b3", "target": 0, "func": "static uint32_t drc_set_unusable(sPAPRDRConnector *drc)\n\n{\n\n    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;\n\n    if (drc->awaiting_release) {\n\n        uint32_t drc_index = spapr_drc_index(drc);\n\n        trace_spapr_drc_set_allocation_state_finalizing(drc_index);\n\n        spapr_drc_detach(drc);\n\n    }\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}\n", "idx": 70, "_split": "test", "_hash": "4888159ed598bc9f15b5cb3b9987e9b3"}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void scsi_read_request(SCSIDiskReq *r)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    if (r->sector_count == (uint32_t)-1) {\n\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n\n        r->sector_count = 0;\n\n        scsi_req_data(&r->req, r->iov.iov_len);\n\n        return;\n\n    }\n\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n\n    if (r->sector_count == 0) {\n\n        scsi_command_complete(r, GOOD, NO_SENSE);\n\n        return;\n\n    }\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    n = r->sector_count;\n\n    if (n > SCSI_DMA_BUF_SIZE / 512)\n\n        n = SCSI_DMA_BUF_SIZE / 512;\n\n\n\n    r->iov.iov_len = n * 512;\n\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n\n                              scsi_read_complete, r);\n\n    if (r->req.aiocb == NULL) {\n\n        scsi_read_complete(r, -EIO);\n\n    }\n\n}\n", "idx": 83, "_split": "test", "_hash": "24d6a0274c608d0cd80be9fb14f82073"}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void lm32_evr_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    LM32CPU *cpu;\n\n    CPULM32State *env;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *address_space_mem =  get_system_memory();\n\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n\n    qemu_irq irq[32];\n\n    ResetInfo *reset_info;\n\n    int i;\n\n\n\n    /* memory map */\n\n    hwaddr flash_base  = 0x04000000;\n\n    size_t flash_sector_size       = 256 * 1024;\n\n    size_t flash_size              = 32 * 1024 * 1024;\n\n    hwaddr ram_base    = 0x08000000;\n\n    size_t ram_size                = 64 * 1024 * 1024;\n\n    hwaddr timer0_base = 0x80002000;\n\n    hwaddr uart0_base  = 0x80006000;\n\n    hwaddr timer1_base = 0x8000a000;\n\n    int uart0_irq                  = 0;\n\n    int timer0_irq                 = 1;\n\n    int timer1_irq                 = 3;\n\n\n\n    reset_info = g_malloc0(sizeof(ResetInfo));\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"lm32-full\";\n\n    }\n\n    cpu = LM32_CPU(cpu_generic_init(TYPE_LM32_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"qemu: unable to find CPU '%s'\\n\", cpu_model);\n\n        exit(1);\n\n    }\n\n\n\n    env = &cpu->env;\n\n    reset_info->cpu = cpu;\n\n\n\n    reset_info->flash_base = flash_base;\n\n\n\n    memory_region_allocate_system_memory(phys_ram, NULL, \"lm32_evr.sdram\",\n\n                                         ram_size);\n\n    memory_region_add_subregion(address_space_mem, ram_base, phys_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    /* Spansion S29NS128P */\n\n    pflash_cfi02_register(flash_base, NULL, \"lm32_evr.flash\", flash_size,\n\n                          dinfo ? blk_by_legacy_dinfo(dinfo) : NULL,\n\n                          flash_sector_size, flash_size / flash_sector_size,\n\n                          1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1);\n\n\n\n    /* create irq lines */\n\n    env->pic_state = lm32_pic_init(qemu_allocate_irq(cpu_irq_handler, cpu, 0));\n\n    for (i = 0; i < 32; i++) {\n\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n\n    }\n\n\n\n    lm32_uart_create(uart0_base, irq[uart0_irq], serial_hds[0]);\n\n    sysbus_create_simple(\"lm32-timer\", timer0_base, irq[timer0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer1_base, irq[timer1_irq]);\n\n\n\n    /* make sure juart isn't the first chardev */\n\n    env->juart_state = lm32_juart_init(serial_hds[1]);\n\n\n\n    reset_info->bootstrap_pc = flash_base;\n\n\n\n    if (kernel_filename) {\n\n        uint64_t entry;\n\n        int kernel_size;\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n\n                               1, EM_LATTICEMICO32, 0, 0);\n\n        reset_info->bootstrap_pc = entry;\n\n\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename, ram_base,\n\n                                              ram_size);\n\n            reset_info->bootstrap_pc = ram_base;\n\n        }\n\n\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n}\n", "idx": 84, "_split": "test", "_hash": "07a8974e05d7a78d3769f0f4b4b60e2a"}
{"project": "qemu", "commit_id": "cf57298af5336df2aece47ef16c290a3a81457dd", "target": 0, "func": "aio_write_f(int argc, char **argv)\n\n{\n\n\tchar *p;\n\n\tint count = 0;\n\n\tint nr_iov, i, c;\n\n\tint pattern = 0xcd;\n\n\tstruct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));\n\n\tBlockDriverAIOCB *acb;\n\n\n\n\twhile ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n\t\tswitch (c) {\n\n\t\tcase 'C':\n\n\t\t\tctx->Cflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'q':\n\n\t\t\tctx->qflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'P':\n\n\t\t\tpattern = atoi(optarg);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\treturn command_usage(&aio_write_cmd);\n\n\t\t}\n\n\t}\n\n\n\n\tif (optind > argc - 2)\n\n\t\treturn command_usage(&aio_write_cmd);\n\n\n\n\tctx->offset = cvtnum(argv[optind]);\n\n\tif (ctx->offset < 0) {\n\n\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n\t\treturn 0;\n\n\t}\n\n\toptind++;\n\n\n\n\tif (ctx->offset & 0x1ff) {\n\n\t\tprintf(\"offset %lld is not sector aligned\\n\",\n\n\t\t\t(long long)ctx->offset);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tif (count & 0x1ff) {\n\n\t\tprintf(\"count %d is not sector aligned\\n\",\n\n\t\t\tcount);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tfor (i = optind; i < argc; i++) {\n\n\t        size_t len;\n\n\n\n\t\tlen = cvtnum(argv[optind]);\n\n\t\tif (len < 0) {\n\n\t\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[i]);\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tcount += len;\n\n\t}\n\n\n\n\tnr_iov = argc - optind;\n\n\tqemu_iovec_init(&ctx->qiov, nr_iov);\n\n\tctx->buf = p = qemu_io_alloc(count, pattern);\n\n\tfor (i = 0; i < nr_iov; i++) {\n\n\t        size_t len;\n\n\n\n\t\tlen = cvtnum(argv[optind]);\n\n\t\tif (len < 0) {\n\n\t\t\tprintf(\"non-numeric length argument -- %s\\n\",\n\n\t\t\t\targv[optind]);\n\n\t\t\treturn 0;\n\n\t\t}\n\n\n\n\t\tqemu_iovec_add(&ctx->qiov, p, len);\n\n\t\tp += len;\n\n\t\toptind++;\n\n\t}\n\n\n\n\tgettimeofday(&ctx->t1, NULL);\n\n\tacb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,\n\n\t\t\t      ctx->qiov.size >> 9, aio_write_done, ctx);\n\n\tif (!acb)\n\n\t\treturn -EIO;\n\n\n\n\treturn 0;\n\n}\n", "idx": 108, "_split": "test", "_hash": "c7d948b6a42292f9e2525ee864ab08d6"}
{"project": "qemu", "commit_id": "301c7d38a0c359b91526391d13617386f3d9bb29", "target": 1, "func": "static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,\n\n        const char *desc_file_path)\n\n{\n\n    int ret;\n\n    char access[11];\n\n    char type[11];\n\n    char fname[512];\n\n    const char *p = desc;\n\n    int64_t sectors = 0;\n\n    int64_t flat_offset;\n\n    char extent_path[PATH_MAX];\n\n    BlockDriverState *extent_file;\n\n    Error *local_err = NULL;\n\n\n\n    while (*p) {\n\n        /* parse extent line:\n\n         * RW [size in sectors] FLAT \"file-name.vmdk\" OFFSET\n\n         * or\n\n         * RW [size in sectors] SPARSE \"file-name.vmdk\"\n\n         */\n\n        flat_offset = -1;\n\n        ret = sscanf(p, \"%10s %\" SCNd64 \" %10s \\\"%511[^\\n\\r\\\"]\\\" %\" SCNd64,\n\n                access, &sectors, type, fname, &flat_offset);\n\n        if (ret < 4 || strcmp(access, \"RW\")) {\n\n            goto next_line;\n\n        } else if (!strcmp(type, \"FLAT\")) {\n\n            if (ret != 5 || flat_offset < 0) {\n\n                return -EINVAL;\n\n            }\n\n        } else if (ret != 4) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (sectors <= 0 ||\n\n            (strcmp(type, \"FLAT\") && strcmp(type, \"SPARSE\") &&\n\n             strcmp(type, \"VMFS\") && strcmp(type, \"VMFSSPARSE\")) ||\n\n            (strcmp(access, \"RW\"))) {\n\n            goto next_line;\n\n        }\n\n\n\n        path_combine(extent_path, sizeof(extent_path),\n\n                desc_file_path, fname);\n\n        ret = bdrv_file_open(&extent_file, extent_path, NULL, bs->open_flags,\n\n                             &local_err);\n\n        if (ret) {\n\n            qerror_report_err(local_err);\n\n            error_free(local_err);\n\n            return ret;\n\n        }\n\n\n\n        /* save to extents array */\n\n        if (!strcmp(type, \"FLAT\") || !strcmp(type, \"VMFS\")) {\n\n            /* FLAT extent */\n\n            VmdkExtent *extent;\n\n\n\n            ret = vmdk_add_extent(bs, extent_file, true, sectors,\n\n                            0, 0, 0, 0, sectors, &extent);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n            extent->flat_start_offset = flat_offset << 9;\n\n        } else if (!strcmp(type, \"SPARSE\") || !strcmp(type, \"VMFSSPARSE\")) {\n\n            /* SPARSE extent and VMFSSPARSE extent are both \"COWD\" sparse file*/\n\n            ret = vmdk_open_sparse(bs, extent_file, bs->open_flags);\n\n            if (ret) {\n\n                bdrv_unref(extent_file);\n\n                return ret;\n\n            }\n\n        } else {\n\n            fprintf(stderr,\n\n                \"VMDK: Not supported extent type \\\"%s\\\"\"\".\\n\", type);\n\n            return -ENOTSUP;\n\n        }\n\nnext_line:\n\n        /* move to next line */\n\n        while (*p && *p != '\\n') {\n\n            p++;\n\n        }\n\n        p++;\n\n    }\n\n    return 0;\n\n}\n", "idx": 122, "_split": "test", "_hash": "84d279d5e9a25a808eab1477e80261a9"}
{"project": "qemu", "commit_id": "9bb234b3b170299c39c9e88cfe7da5434a92d99d", "target": 1, "func": "void OPPROTO op_udiv_T1_T0(void)\n{\n    uint64_t x0;\n    uint32_t x1;\n    x0 = T0 | ((uint64_t) (env->y) << 32);\n    x1 = T1;\n    x0 = x0 / x1;\n    if (x0 > 0xffffffff) {\n\tT0 = 0xffffffff;\n\tT1 = 1;\n    } else {\n\tT0 = x0;\n\tT1 = 0;\n    FORCE_RET();", "idx": 164, "_split": "test", "_hash": "53961a2cccdbd9a051872a975eef9e95"}
{"project": "qemu", "commit_id": "1ac157da77c863b62b1d2f467626a440d57cf17d", "target": 0, "func": "void cpu_x86_init_mmu(CPUX86State *env)\n\n{\n\n    a20_enabled = 1;\n\n    a20_mask = 0xffffffff;\n\n\n\n    last_pg_state = -1;\n\n    cpu_x86_update_cr0(env);\n\n}\n", "idx": 176, "_split": "test", "_hash": "0f95daf4d6680fab89a5e6195f80b73f"}
{"project": "qemu", "commit_id": "b7680cb6078bd7294a3dd86473d3f2fdee991dd0", "target": 0, "func": "int qemu_cpu_self(void *env)\n\n{\n\n    return 1;\n\n}\n", "idx": 178, "_split": "test", "_hash": "195ce5bdb791de044dfcdf3627637e5f"}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static void net_vhost_link_down(VhostUserState *s, bool link_down)\n\n{\n\n    s->nc.link_down = link_down;\n\n\n\n    if (s->nc.peer) {\n\n        s->nc.peer->link_down = link_down;\n\n    }\n\n\n\n    if (s->nc.info->link_status_changed) {\n\n        s->nc.info->link_status_changed(&s->nc);\n\n    }\n\n\n\n    if (s->nc.peer && s->nc.peer->info->link_status_changed) {\n\n        s->nc.peer->info->link_status_changed(s->nc.peer);\n\n    }\n\n}\n", "idx": 179, "_split": "test", "_hash": "e467ae32f58c4c82e89cf92872538059"}
{"project": "qemu", "commit_id": "40365552c2fceacc9800ec9a87b9ead516a9a6ce", "target": 1, "func": "static void mirror_start_job(BlockDriverState *bs, BlockDriverState *target,\n\n                             const char *replaces,\n\n                             int64_t speed, uint32_t granularity,\n\n                             int64_t buf_size,\n\n                             BlockdevOnError on_source_error,\n\n                             BlockdevOnError on_target_error,\n\n                             bool unmap,\n\n                             BlockCompletionFunc *cb,\n\n                             void *opaque, Error **errp,\n\n                             const BlockJobDriver *driver,\n\n                             bool is_none_mode, BlockDriverState *base)\n\n{\n\n    MirrorBlockJob *s;\n\n\n\n\n    if (granularity == 0) {\n\n        granularity = bdrv_get_default_bitmap_granularity(target);\n\n    }\n\n\n\n    assert ((granularity & (granularity - 1)) == 0);\n\n\n\n    if ((on_source_error == BLOCKDEV_ON_ERROR_STOP ||\n\n         on_source_error == BLOCKDEV_ON_ERROR_ENOSPC) &&\n\n        (!bs->blk || !blk_iostatus_is_enabled(bs->blk))) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"on-source-error\");\n\n        return;\n\n    }\n\n\n\n    if (buf_size < 0) {\n\n        error_setg(errp, \"Invalid parameter 'buf-size'\");\n\n        return;\n\n    }\n\n\n\n    if (buf_size == 0) {\n\n        buf_size = DEFAULT_MIRROR_BUF_SIZE;\n\n    }\n\n\n\n    /* We can't support this case as long as the block layer can't handle\n\n     * multiple BlockBackends per BlockDriverState. */\n\n    if (replaces) {\n\n        replaced_bs = bdrv_lookup_bs(replaces, replaces, errp);\n\n        if (replaced_bs == NULL) {\n\n            return;\n\n        }\n\n    } else {\n\n        replaced_bs = bs;\n\n    }\n\n    if (replaced_bs->blk && target->blk) {\n\n        error_setg(errp, \"Can't create node with two BlockBackends\");\n\n        return;\n\n    }\n\n\n\n    s = block_job_create(driver, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->replaces = g_strdup(replaces);\n\n    s->on_source_error = on_source_error;\n\n    s->on_target_error = on_target_error;\n\n    s->target = target;\n\n    s->is_none_mode = is_none_mode;\n\n    s->base = base;\n\n    s->granularity = granularity;\n\n    s->buf_size = ROUND_UP(buf_size, granularity);\n\n    s->unmap = unmap;\n\n\n\n    s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp);\n\n    if (!s->dirty_bitmap) {\n\n        g_free(s->replaces);\n\n        block_job_unref(&s->common);\n\n        return;\n\n    }\n\n\n\n    bdrv_op_block_all(s->target, s->common.blocker);\n\n\n\n    bdrv_set_enable_write_cache(s->target, true);\n\n    if (s->target->blk) {\n\n        blk_set_on_error(s->target->blk, on_target_error, on_target_error);\n\n        blk_iostatus_enable(s->target->blk);\n\n    }\n\n    s->common.co = qemu_coroutine_create(mirror_run);\n\n    trace_mirror_start(bs, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}", "idx": 200, "_split": "test", "_hash": "fc916aa2ddc5abadd62c6096efbd05e0"}
{"project": "qemu", "commit_id": "65cdadd2e2de76f7db3bf6b7d8dd8c67abff9659", "target": 0, "func": "START_TEST(qint_get_int_test)\n\n{\n\n    QInt *qi;\n\n    const int value = 123456;\n\n\n\n    qi = qint_from_int(value);\n\n    fail_unless(qint_get_int(qi) == value);\n\n\n\n    QDECREF(qi);\n\n}\n", "idx": 218, "_split": "test", "_hash": "ee88860a6cbe0a3996c5ea51a91ea72f"}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static void qpa_audio_fini (void *opaque)\n\n{\n\n    (void) opaque;\n\n}\n", "idx": 246, "_split": "test", "_hash": "205d29d1ebe06defa6906ade908655a6"}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usbredir_bulk_packet(void *priv, uint32_t id,\n\n    struct usb_redir_bulk_packet_header *bulk_packet,\n\n    uint8_t *data, int data_len)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    uint8_t ep = bulk_packet->endpoint;\n\n    int len = bulk_packet->length;\n\n    AsyncURB *aurb;\n\n\n\n    DPRINTF(\"bulk-in status %d ep %02X len %d id %u\\n\", bulk_packet->status,\n\n            ep, len, id);\n\n\n\n    aurb = async_find(dev, id);\n\n    if (!aurb) {\n\n        free(data);\n\n        return;\n\n    }\n\n\n\n    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||\n\n            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {\n\n        ERROR(\"return bulk packet mismatch, please report this!\\n\");\n\n        len = USB_RET_NAK;\n\n    }\n\n\n\n    if (aurb->packet) {\n\n        len = usbredir_handle_status(dev, bulk_packet->status, len);\n\n        if (len > 0) {\n\n            usbredir_log_data(dev, \"bulk data in:\", data, data_len);\n\n            if (data_len <= aurb->packet->len) {\n\n                memcpy(aurb->packet->data, data, data_len);\n\n            } else {\n\n                ERROR(\"bulk buffer too small (%d > %d)\\n\", data_len,\n\n                      aurb->packet->len);\n\n                len = USB_RET_STALL;\n\n            }\n\n        }\n\n        aurb->packet->len = len;\n\n        usb_packet_complete(&dev->dev, aurb->packet);\n\n    }\n\n    async_free(dev, aurb);\n\n    free(data);\n\n}\n", "idx": 248, "_split": "test", "_hash": "b8b297e65e4f4c70480f3c2fc34fd2fd"}
{"project": "qemu", "commit_id": "09cd058a2cf77bb7a3b10ff93c1f80ed88bca364", "target": 1, "func": "static MemTxResult vtd_mem_ir_write(void *opaque, hwaddr addr,\n\n                                    uint64_t value, unsigned size,\n\n                                    MemTxAttrs attrs)\n\n{\n\n    int ret = 0;\n\n    MSIMessage from = {0}, to = {0};\n\n\n\n    from.address = (uint64_t) addr + VTD_INTERRUPT_ADDR_FIRST;\n\n    from.data = (uint32_t) value;\n\n\n\n    ret = vtd_interrupt_remap_msi(opaque, &from, &to);\n\n    if (ret) {\n\n        /* TODO: report error */\n\n        VTD_DPRINTF(GENERAL, \"int remap fail for addr 0x%\"PRIx64\n\n                    \" data 0x%\"PRIx32, from.address, from.data);\n\n        /* Drop this interrupt */\n\n        return MEMTX_ERROR;\n\n    }\n\n\n\n    VTD_DPRINTF(IR, \"delivering MSI 0x%\"PRIx64\":0x%\"PRIx32\n\n                \" for device sid 0x%04x\",\n\n                to.address, to.data, sid);\n\n\n\n    if (dma_memory_write(&address_space_memory, to.address,\n\n                         &to.data, size)) {\n\n        VTD_DPRINTF(GENERAL, \"error: fail to write 0x%\"PRIx64\n\n                    \" value 0x%\"PRIx32, to.address, to.data);\n\n    }\n\n\n\n    return MEMTX_OK;\n\n}\n", "idx": 272, "_split": "test", "_hash": "71cf3f4988da18ef971eebaa37a149ed"}
{"project": "qemu", "commit_id": "0b5538c300a56c3cfb33022840fe0b4968147e7a", "target": 1, "func": "void st_flush_trace_buffer(void)\n\n{\n\n    if (trace_file_enabled) {\n\n        flush_trace_file();\n\n    }\n\n\n\n    /* Discard written trace records */\n\n    trace_idx = 0;\n\n}\n", "idx": 280, "_split": "test", "_hash": "9b124beb53a35a1fc89e1b4b6c961935"}
{"project": "qemu", "commit_id": "6a84cb1f2822e494839b93dd8c7f7f8fa6c261a9", "target": 0, "func": "VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf,\n\n                              char **serial)\n\n{\n\n    VirtIOBlock *s;\n\n    int cylinders, heads, secs;\n\n    static int virtio_blk_id;\n\n    DriveInfo *dinfo;\n\n\n\n    if (!conf->bs) {\n\n        error_report(\"virtio-blk-pci: drive property not set\");\n\n        return NULL;\n\n    }\n\n    if (!bdrv_is_inserted(conf->bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return NULL;\n\n    }\n\n\n\n    if (!*serial) {\n\n        /* try to fall back to value set with legacy -drive serial=... */\n\n        dinfo = drive_get_by_blockdev(conf->bs);\n\n        if (*dinfo->serial) {\n\n            *serial = strdup(dinfo->serial);\n\n        }\n\n    }\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = conf->bs;\n\n    s->conf = conf;\n\n    s->serial = *serial;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    s->qdev = dev;\n\n    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n\n    bdrv_set_buffer_alignment(s->bs, conf->logical_block_size);\n\n\n\n    bdrv_iostatus_enable(s->bs);\n\n    add_boot_device_path(conf->bootindex, dev, \"/disk@0,0\");\n\n\n\n    return &s->vdev;\n\n}\n", "idx": 289, "_split": "test", "_hash": "357f6ded6bc6aa0a7f40ab0ddf5132f4"}
{"project": "qemu", "commit_id": "0647d47cc184da587c76743546b6af6dfdb8f1da", "target": 1, "func": "static size_t header_ext_add(char *buf, uint32_t magic, const void *s,\n\n    size_t len, size_t buflen)\n\n{\n\n    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;\n\n    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);\n\n\n\n    if (buflen < ext_len) {\n\n        return -ENOSPC;\n\n    }\n\n\n\n    *ext_backing_fmt = (QCowExtension) {\n\n        .magic  = cpu_to_be32(magic),\n\n        .len    = cpu_to_be32(len),\n\n    };\n\n    memcpy(buf + sizeof(QCowExtension), s, len);\n\n\n\n    return ext_len;\n\n}\n", "idx": 304, "_split": "test", "_hash": "4a4e8bab5b588de189de55a2359832cd"}
{"project": "qemu", "commit_id": "89ae337acbe4dba5b2481007aec1277252d2b86c", "target": 0, "func": "static void mem_begin(MemoryListener *listener)\n\n{\n\n    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);\n\n\n\n    d->phys_map.ptr = PHYS_MAP_NODE_NIL;\n\n}\n", "idx": 321, "_split": "test", "_hash": "90ef42a323bd45b5901dbf8f187b6d91"}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)\n\n{\n\n    uint32_t rgb = 0;\n\n\n\n    if (bpp == 32) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;\n\n        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;\n\n        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;\n\n        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;\n\n    }\n\n    if (bpp == 16) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;\n\n        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;\n\n    }\n\n    return rgb;\n\n}\n", "idx": 325, "_split": "test", "_hash": "a5c4c3245e76cba4b21f4249e566c7c4"}
{"project": "qemu", "commit_id": "fac7d7b1cdb21f921d7ac396365f5e920ef03096", "target": 1, "func": "int net_init_tap(const Netdev *netdev, const char *name,\n\n                 NetClientState *peer, Error **errp)\n\n{\n\n    const NetdevTapOptions *tap;\n\n    int fd, vnet_hdr = 0, i = 0, queues;\n\n    /* for the no-fd, no-helper case */\n\n    const char *script = NULL; /* suppress wrong \"uninit'd use\" gcc warning */\n\n    const char *downscript = NULL;\n\n    Error *err = NULL;\n\n    const char *vhostfdname;\n\n    char ifname[128];\n\n\n\n    assert(netdev->type == NET_CLIENT_DRIVER_TAP);\n\n    tap = &netdev->u.tap;\n\n    queues = tap->has_queues ? tap->queues : 1;\n\n    vhostfdname = tap->has_vhostfd ? tap->vhostfd : NULL;\n\n\n\n    /* QEMU vlans does not support multiqueue tap, in this case peer is set.\n\n     * For -netdev, peer is always NULL. */\n\n    if (peer && (tap->has_queues || tap->has_fds || tap->has_vhostfds)) {\n\n        error_setg(errp, \"Multiqueue tap cannot be used with QEMU vlans\");\n\n        return -1;\n\n    }\n\n\n\n    if (tap->has_fd) {\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n\n            tap->has_fds || tap->has_vhostfds) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"helper=, queues=, fds=, and vhostfds= \"\n\n                       \"are invalid with fd=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = monitor_fd_param(cur_mon, tap->fd, &err);\n\n        if (fd == -1) {\n\n            error_propagate(errp, err);\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"tap\", name, NULL,\n\n                         script, downscript,\n\n                         vhostfdname, vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return -1;\n\n        }\n\n    } else if (tap->has_fds) {\n\n        char **fds = g_new0(char *, MAX_TAP_QUEUES);\n\n        char **vhost_fds = g_new0(char *, MAX_TAP_QUEUES);\n\n        int nfds, nvhosts;\n\n\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n\n            tap->has_vhostfd) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"helper=, queues=, and vhostfd= \"\n\n                       \"are invalid with fds=\");\n\n            return -1;\n\n        }\n\n\n\n        nfds = get_fds(tap->fds, fds, MAX_TAP_QUEUES);\n\n        if (tap->has_vhostfds) {\n\n            nvhosts = get_fds(tap->vhostfds, vhost_fds, MAX_TAP_QUEUES);\n\n            if (nfds != nvhosts) {\n\n                error_setg(errp, \"The number of fds passed does not match \"\n\n                           \"the number of vhostfds passed\");\n\n                goto free_fail;\n\n            }\n\n        }\n\n\n\n        for (i = 0; i < nfds; i++) {\n\n            fd = monitor_fd_param(cur_mon, fds[i], &err);\n\n            if (fd == -1) {\n\n                error_propagate(errp, err);\n\n                goto free_fail;\n\n            }\n\n\n\n            fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n            if (i == 0) {\n\n                vnet_hdr = tap_probe_vnet_hdr(fd);\n\n            } else if (vnet_hdr != tap_probe_vnet_hdr(fd)) {\n\n                error_setg(errp,\n\n                           \"vnet_hdr not consistent across given tap fds\");\n\n                goto free_fail;\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             script, downscript,\n\n                             tap->has_vhostfds ? vhost_fds[i] : NULL,\n\n                             vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                goto free_fail;\n\n            }\n\n        }\n\n        g_free(fds);\n\n        g_free(vhost_fds);\n\n        return 0;\n\n\n\nfree_fail:\n\n        for (i = 0; i < nfds; i++) {\n\n            g_free(fds[i]);\n\n            g_free(vhost_fds[i]);\n\n        }\n\n        g_free(fds);\n\n        g_free(vhost_fds);\n\n        return -1;\n\n    } else if (tap->has_helper) {\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_queues || tap->has_vhostfds) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"queues=, and vhostfds= are invalid with helper=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = net_bridge_run_helper(tap->helper,\n\n                                   tap->has_br ?\n\n                                   tap->br : DEFAULT_BRIDGE_INTERFACE,\n\n                                   errp);\n\n        if (fd == -1) {\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"bridge\", name, ifname,\n\n                         script, downscript, vhostfdname,\n\n                         vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            close(fd);\n\n            return -1;\n\n        }\n\n    } else {\n\n        if (tap->has_vhostfds) {\n\n            error_setg(errp, \"vhostfds= is invalid if fds= wasn't specified\");\n\n            return -1;\n\n        }\n\n        script = tap->has_script ? tap->script : DEFAULT_NETWORK_SCRIPT;\n\n        downscript = tap->has_downscript ? tap->downscript :\n\n            DEFAULT_NETWORK_DOWN_SCRIPT;\n\n\n\n        if (tap->has_ifname) {\n\n            pstrcpy(ifname, sizeof ifname, tap->ifname);\n\n        } else {\n\n            ifname[0] = '\\0';\n\n        }\n\n\n\n        for (i = 0; i < queues; i++) {\n\n            fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? \"no\" : script,\n\n                              ifname, sizeof ifname, queues > 1, errp);\n\n            if (fd == -1) {\n\n                return -1;\n\n            }\n\n\n\n            if (queues > 1 && i == 0 && !tap->has_ifname) {\n\n                if (tap_fd_get_ifname(fd, ifname)) {\n\n                    error_setg(errp, \"Fail to get ifname\");\n\n                    close(fd);\n\n                    return -1;\n\n                }\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             i >= 1 ? \"no\" : script,\n\n                             i >= 1 ? \"no\" : downscript,\n\n                             vhostfdname, vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                close(fd);\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 338, "_split": "test", "_hash": "5e0e12d65e51cf6ad4d4ee9caa9e1a8f"}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "void stream_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, const char *backing_file_str,\n\n                  int64_t speed, BlockdevOnError on_error,\n\n                  BlockCompletionFunc *cb, void *opaque, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n\n\n    s = block_job_create(job_id, &stream_job_driver, bs, speed,\n\n                         cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->base = base;\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n\n\n    s->on_error = on_error;\n\n    s->common.co = qemu_coroutine_create(stream_run);\n\n    trace_stream_start(bs, base, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}\n", "idx": 369, "_split": "test", "_hash": "75607e0c663355675eddb4af6e069ddf"}
{"project": "qemu", "commit_id": "84a3a53cf61ef691478bd91afa455c801696053c", "target": 1, "func": "static int omap_gpio_init(SysBusDevice *sbd)\n\n{\n\n    DeviceState *dev = DEVICE(sbd);\n\n    struct omap_gpif_s *s = OMAP1_GPIO(dev);\n\n\n\n    if (!s->clk) {\n\n        hw_error(\"omap-gpio: clk not connected\\n\");\n\n    }\n\n    qdev_init_gpio_in(dev, omap_gpio_set, 16);\n\n    qdev_init_gpio_out(dev, s->omap1.handler, 16);\n\n    sysbus_init_irq(sbd, &s->omap1.irq);\n\n    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,\n\n                          \"omap.gpio\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n    return 0;\n\n}\n", "idx": 373, "_split": "test", "_hash": "f52d646bb2b8c44f07eda73e7bf673ca"}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)\n\n{\n\n    s->codec = slave;\n\n    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];\n\n    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];\n\n}\n", "idx": 391, "_split": "test", "_hash": "c59da50f1e6a8a78b8f0bc3bf9f2fa4c"}
{"project": "qemu", "commit_id": "d1eb8f2acba579830cf3798c3c15ce51be852c56", "target": 0, "func": "int floatx80_eq(floatx80 a, floatx80 b, float_status *status)\n\n{\n\n\n\n    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )\n\n         || (    ( extractFloatx80Exp( b ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )\n\n       ) {\n\n        float_raise(float_flag_invalid, status);\n\n        return 0;\n\n    }\n\n    return\n\n           ( a.low == b.low )\n\n        && (    ( a.high == b.high )\n\n             || (    ( a.low == 0 )\n\n                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )\n\n           );\n\n\n\n}\n", "idx": 399, "_split": "test", "_hash": "1fd07afb77b62aa876096c0cc931ace0"}
{"project": "qemu", "commit_id": "d2ca7c0b0d876cf0e219ae7a92252626b0913a28", "target": 0, "func": "void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)\n\n{\n\n    lexer->emit = func;\n\n    lexer->state = IN_START;\n\n    lexer->token = qstring_new();\n\n    lexer->x = lexer->y = 0;\n\n}\n", "idx": 402, "_split": "test", "_hash": "7e5fae21c281edea9b06d04cee66d110"}
{"project": "qemu", "commit_id": "384acbf46b70edf0d2c1648aa1a92a90bcf7057d", "target": 0, "func": "BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque, int type)\n\n{\n\n    struct qemu_paiocb *acb;\n\n\n\n    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    acb->aio_type = type;\n\n    acb->aio_fildes = fd;\n\n    acb->ev_signo = SIGUSR2;\n\n    acb->async_context_id = get_async_context_id();\n\n\n\n    if (qiov) {\n\n        acb->aio_iov = qiov->iov;\n\n        acb->aio_niov = qiov->niov;\n\n    }\n\n    acb->aio_nbytes = nb_sectors * 512;\n\n    acb->aio_offset = sector_num * 512;\n\n\n\n    acb->next = posix_aio_state->first_aio;\n\n    posix_aio_state->first_aio = acb;\n\n\n\n    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);\n\n    qemu_paio_submit(acb);\n\n    return &acb->common;\n\n}\n", "idx": 404, "_split": "test", "_hash": "f028d3e15d5416dc3b37bd299270948c"}
{"project": "qemu", "commit_id": "25d9747b6427de8253221d544b45e50888d4cef7", "target": 1, "func": "static int floppy_probe_device(const char *filename)\n\n{\n\n    int fd, ret;\n\n    int prio = 0;\n\n    struct floppy_struct fdparam;\n\n    struct stat st;\n\n\n\n    if (strstart(filename, \"/dev/fd\", NULL) &&\n\n        !strstart(filename, \"/dev/fdset/\", NULL)) {\n\n        prio = 50;\n\n    }\n\n\n\n    fd = qemu_open(filename, O_RDONLY | O_NONBLOCK);\n\n    if (fd < 0) {\n\n        goto out;\n\n    }\n\n    ret = fstat(fd, &st);\n\n    if (ret == -1 || !S_ISBLK(st.st_mode)) {\n\n        goto outc;\n\n    }\n\n\n\n    /* Attempt to detect via a floppy specific ioctl */\n\n    ret = ioctl(fd, FDGETPRM, &fdparam);\n\n    if (ret >= 0)\n\n        prio = 100;\n\n\n\noutc:\n\n    qemu_close(fd);\n\nout:\n\n    return prio;\n\n}\n", "idx": 444, "_split": "test", "_hash": "b2fcf925b4d58944090d4d664b8e299f"}
{"project": "qemu", "commit_id": "7d55273fcdc307399fc0e327a0c14c140cd439cf", "target": 0, "func": "static void sun4uv_init(ram_addr_t RAM_size,\n\n                        const char *boot_devices,\n\n                        const char *kernel_filename, const char *kernel_cmdline,\n\n                        const char *initrd_filename, const char *cpu_model,\n\n                        const struct hwdef *hwdef)\n\n{\n\n    CPUState *env;\n\n    char *filename;\n\n    m48t59_t *nvram;\n\n    int ret, linux_boot;\n\n    unsigned int i;\n\n    ram_addr_t ram_offset, prom_offset;\n\n    long initrd_size, kernel_size;\n\n    PCIBus *pci_bus, *pci_bus2, *pci_bus3;\n\n    QEMUBH *bh;\n\n    qemu_irq *irq;\n\n    int drive_index;\n\n    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BlockDriverState *fd[MAX_FD];\n\n    void *fw_cfg;\n\n    ResetData *reset_info;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (!cpu_model)\n\n        cpu_model = hwdef->default_cpu_model;\n\n\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find Sparc CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    bh = qemu_bh_new(tick_irq, env);\n\n    env->tick = ptimer_init(bh);\n\n    ptimer_set_period(env->tick, 1ULL);\n\n\n\n    bh = qemu_bh_new(stick_irq, env);\n\n    env->stick = ptimer_init(bh);\n\n    ptimer_set_period(env->stick, 1ULL);\n\n\n\n    bh = qemu_bh_new(hstick_irq, env);\n\n    env->hstick = ptimer_init(bh);\n\n    ptimer_set_period(env->hstick, 1ULL);\n\n\n\n    reset_info = qemu_mallocz(sizeof(ResetData));\n\n    reset_info->env = env;\n\n    reset_info->reset_addr = hwdef->prom_addr + 0x40ULL;\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n    main_cpu_reset(reset_info);\n\n    // Override warm reset address with cold start address\n\n    env->pc = hwdef->prom_addr + 0x20ULL;\n\n    env->npc = env->pc + 4;\n\n\n\n    /* allocate RAM */\n\n    ram_offset = qemu_ram_alloc(RAM_size);\n\n    cpu_register_physical_memory(0, RAM_size, ram_offset);\n\n\n\n    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);\n\n    cpu_register_physical_memory(hwdef->prom_addr,\n\n                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &\n\n                                 TARGET_PAGE_MASK,\n\n                                 prom_offset | IO_MEM_ROM);\n\n\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (filename) {\n\n        ret = load_elf(filename, hwdef->prom_addr - PROM_VADDR,\n\n                       NULL, NULL, NULL);\n\n        if (ret < 0) {\n\n            ret = load_image_targphys(filename, hwdef->prom_addr,\n\n                                      (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &\n\n                                  TARGET_PAGE_MASK);\n\n        }\n\n        qemu_free(filename);\n\n    } else {\n\n        ret = -1;\n\n    }\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"qemu: could not load prom '%s'\\n\",\n\n                bios_name);\n\n        exit(1);\n\n    }\n\n\n\n    kernel_size = 0;\n\n    initrd_size = 0;\n\n    if (linux_boot) {\n\n        /* XXX: put correct offset */\n\n        kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR,\n\n                                    ram_size - KERNEL_LOAD_ADDR);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              KERNEL_LOAD_ADDR,\n\n                                              ram_size - KERNEL_LOAD_ADDR);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_size = load_image_targphys(initrd_filename,\n\n                                              INITRD_LOAD_ADDR,\n\n                                              ram_size - INITRD_LOAD_ADDR);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        }\n\n        if (initrd_size > 0) {\n\n            for (i = 0; i < 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) {\n\n                if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) { // HdrS\n\n                    stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR);\n\n                    stl_phys(KERNEL_LOAD_ADDR + i + 20, initrd_size);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2,\n\n                           &pci_bus3);\n\n    isa_mem_base = VGA_BASE;\n\n    pci_vga_init(pci_bus, 0, 0);\n\n\n\n    // XXX Should be pci_bus3\n\n    pci_ebus_init(pci_bus, -1);\n\n\n\n    i = 0;\n\n    if (hwdef->console_serial_base) {\n\n        serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200,\n\n                       serial_hds[i], 1);\n\n        i++;\n\n    }\n\n    for(; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_init(serial_io[i], NULL/*serial_irq[i]*/, 115200,\n\n                        serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {\n\n        if (parallel_hds[i]) {\n\n            parallel_init(parallel_io[i], NULL/*parallel_irq[i]*/,\n\n                          parallel_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init(&nd_table[i], \"ne2k_pci\", NULL);\n\n\n\n    irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS);\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        drive_index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS,\n\n                                      i % MAX_IDE_DEVS);\n\n       if (drive_index != -1)\n\n           hd[i] = drives_table[drive_index].bdrv;\n\n       else\n\n           hd[i] = NULL;\n\n    }\n\n\n\n    pci_cmd646_ide_init(pci_bus, hd, 1);\n\n\n\n    /* FIXME: wire up interrupts.  */\n\n    i8042_init(NULL/*1*/, NULL/*12*/, 0x60);\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        drive_index = drive_get_index(IF_FLOPPY, 0, i);\n\n       if (drive_index != -1)\n\n           fd[i] = drives_table[drive_index].bdrv;\n\n       else\n\n           fd[i] = NULL;\n\n    }\n\n    floppy_controller = fdctrl_init(NULL/*6*/, 2, 0, 0x3f0, fd);\n\n    nvram = m48t59_init(NULL/*8*/, 0, 0x0074, NVRAM_SIZE, 59);\n\n    sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, \"Sun4u\", RAM_size, boot_devices,\n\n                           KERNEL_LOAD_ADDR, kernel_size,\n\n                           kernel_cmdline,\n\n                           INITRD_LOAD_ADDR, initrd_size,\n\n                           /* XXX: need an option to load a NVRAM image */\n\n                           0,\n\n                           graphic_width, graphic_height, graphic_depth,\n\n                           (uint8_t *)&nd_table[0].macaddr);\n\n\n\n    fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);\n\n        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]);\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}\n", "idx": 461, "_split": "test", "_hash": "0ab80681e75c4d6f047dc1fa12adf998"}
{"project": "qemu", "commit_id": "932e71cd57bab4e6206e1355c6425290721bbe34", "target": 0, "func": "static void fpu_init (CPUMIPSState *env, const mips_def_t *def)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < MIPS_FPU_MAX; i++)\n\n        env->fpus[i].fcr0 = def->CP1_fcr0;\n\n\n\n    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));\n\n    if (env->user_mode_only) {\n\n        if (env->CP0_Config1 & (1 << CP0C1_FP))\n\n            env->hflags |= MIPS_HFLAG_FPU;\n\n#ifdef TARGET_MIPS64\n\n        if (env->active_fpu.fcr0 & (1 << FCR0_F64))\n\n            env->hflags |= MIPS_HFLAG_F64;\n\n#endif\n\n    }\n\n}\n", "idx": 474, "_split": "test", "_hash": "867980d78bf2c6537a5c7e01f84486c7"}
{"project": "qemu", "commit_id": "7b0309490cb108d881a0c66d6b350b4db7b3b4ac", "target": 1, "func": "DeviceState *qdev_device_add(QemuOpts *opts)\n\n{\n\n    ObjectClass *oc;\n\n    DeviceClass *dc;\n\n    const char *driver, *path, *id;\n\n    DeviceState *dev;\n\n    BusState *bus = NULL;\n\n    Error *err = NULL;\n\n\n\n    driver = qemu_opt_get(opts, \"driver\");\n\n    if (!driver) {\n\n        qerror_report(QERR_MISSING_PARAMETER, \"driver\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find driver */\n\n    oc = object_class_by_name(driver);\n\n    if (!oc) {\n\n        const char *typename = find_typename_by_alias(driver);\n\n\n\n        if (typename) {\n\n            driver = typename;\n\n            oc = object_class_by_name(driver);\n\n        }\n\n    }\n\n\n\n    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {\n\n        qerror_report(ERROR_CLASS_GENERIC_ERROR,\n\n                      \"'%s' is not a valid device model name\", driver);\n\n        return NULL;\n\n    }\n\n\n\n    if (object_class_is_abstract(oc)) {\n\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"driver\",\n\n                      \"non-abstract device type\");\n\n        return NULL;\n\n    }\n\n\n\n    dc = DEVICE_CLASS(oc);\n\n    if (dc->cannot_instantiate_with_device_add_yet) {\n\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"driver\",\n\n                      \"pluggable device type\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find bus */\n\n    path = qemu_opt_get(opts, \"bus\");\n\n    if (path != NULL) {\n\n        bus = qbus_find(path);\n\n        if (!bus) {\n\n            return NULL;\n\n        }\n\n        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {\n\n            qerror_report(QERR_BAD_BUS_FOR_DEVICE,\n\n                          driver, object_get_typename(OBJECT(bus)));\n\n            return NULL;\n\n        }\n\n    } else if (dc->bus_type != NULL) {\n\n        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);\n\n        if (!bus) {\n\n            qerror_report(QERR_NO_BUS_FOR_DEVICE,\n\n                          dc->bus_type, driver);\n\n            return NULL;\n\n        }\n\n    }\n\n    if (qdev_hotplug && bus && !bus->allow_hotplug) {\n\n        qerror_report(QERR_BUS_NO_HOTPLUG, bus->name);\n\n        return NULL;\n\n    }\n\n\n\n    /* create device, set properties */\n\n    dev = DEVICE(object_new(driver));\n\n\n\n    if (bus) {\n\n        qdev_set_parent_bus(dev, bus);\n\n    }\n\n\n\n    id = qemu_opts_id(opts);\n\n    if (id) {\n\n        dev->id = id;\n\n    }\n\n    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {\n\n        object_unparent(OBJECT(dev));\n\n        object_unref(OBJECT(dev));\n\n        return NULL;\n\n    }\n\n    if (dev->id) {\n\n        object_property_add_child(qdev_get_peripheral(), dev->id,\n\n                                  OBJECT(dev), NULL);\n\n    } else {\n\n        static int anon_count;\n\n        gchar *name = g_strdup_printf(\"device[%d]\", anon_count++);\n\n        object_property_add_child(qdev_get_peripheral_anon(), name,\n\n                                  OBJECT(dev), NULL);\n\n        g_free(name);\n\n    }\n\n\n\n    dev->opts = opts;\n\n    object_property_set_bool(OBJECT(dev), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        qerror_report_err(err);\n\n        error_free(err);\n\n        dev->opts = NULL;\n\n        object_unparent(OBJECT(dev));\n\n        object_unref(OBJECT(dev));\n\n        qerror_report(QERR_DEVICE_INIT_FAILED, driver);\n\n        return NULL;\n\n    }\n\n    return dev;\n\n}\n", "idx": 491, "_split": "test", "_hash": "60422794692a8ef393e6b8a31d940249"}
{"project": "qemu", "commit_id": "c4d9d19645a484298a67e9021060bc7c2b081d0f", "target": 0, "func": "void thread_pool_submit(ThreadPoolFunc *func, void *arg)\n\n{\n\n    thread_pool_submit_aio(func, arg, NULL, NULL);\n\n}\n", "idx": 501, "_split": "test", "_hash": "71f825c3ff5bf5221caf5862a49056de"}
{"project": "qemu", "commit_id": "a35faa94c8e8d851a1d07e17c98f4ab2202b8a38", "target": 0, "func": "static void pl061_register_devices(void)\n\n{\n\n    sysbus_register_dev(\"pl061\", sizeof(pl061_state),\n\n                        pl061_init_arm);\n\n    sysbus_register_dev(\"pl061_luminary\", sizeof(pl061_state),\n\n                        pl061_init_luminary);\n\n}\n", "idx": 510, "_split": "test", "_hash": "8acf22b735692dc21a5b0b2782e5a5e8"}
{"project": "qemu", "commit_id": "372579427a5040a26dfee78464b50e2bdf27ef26", "target": 1, "func": "int cpu_exec(CPUState *cpu)\n\n{\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    int ret;\n\n    SyncClocks sc;\n\n\n\n    /* replay_interrupt may need current_cpu */\n\n    current_cpu = cpu;\n\n\n\n    if (cpu_handle_halt(cpu)) {\n\n        return EXCP_HALTED;\n\n    }\n\n\n\n    rcu_read_lock();\n\n\n\n    cc->cpu_exec_enter(cpu);\n\n\n\n    /* Calculate difference between guest clock and host clock.\n\n     * This delay includes the delay of the last cycle, so\n\n     * what we have to do is sleep until it is 0. As for the\n\n     * advance/delay we gain here, we try to fix it next time.\n\n     */\n\n    init_delay_params(&sc, cpu);\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    if (sigsetjmp(cpu->jmp_env, 0) != 0) {\n\n#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)\n\n        /* Some compilers wrongly smash all local variables after\n\n         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.\n\n         * Reload essential local variables here for those compilers.\n\n         * Newer versions of gcc would complain about this code (-Wclobbered). */\n\n        cpu = current_cpu;\n\n        cc = CPU_GET_CLASS(cpu);\n\n#else /* buggy compiler */\n\n        /* Assert that the compiler does not smash local variables. */\n\n        g_assert(cpu == current_cpu);\n\n        g_assert(cc == CPU_GET_CLASS(cpu));\n\n#endif /* buggy compiler */\n\n        cpu->can_do_io = 1;\n\n        tb_lock_reset();\n\n        if (qemu_mutex_iothread_locked()) {\n\n            qemu_mutex_unlock_iothread();\n\n        }\n\n    }\n\n\n\n    /* if an exception is pending, we execute it here */\n\n    while (!cpu_handle_exception(cpu, &ret)) {\n\n        TranslationBlock *last_tb = NULL;\n\n        int tb_exit = 0;\n\n\n\n        while (!cpu_handle_interrupt(cpu, &last_tb)) {\n\n            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);\n\n            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);\n\n            /* Try to align the host and virtual clocks\n\n               if the guest is in advance */\n\n            align_clocks(&sc, cpu);\n\n        }\n\n    }\n\n\n\n    cc->cpu_exec_exit(cpu);\n\n    rcu_read_unlock();\n\n\n\n    /* fail safe : never use current_cpu outside cpu_exec() */\n\n    current_cpu = NULL;\n\n\n\n    return ret;\n\n}\n", "idx": 539, "_split": "test", "_hash": "194029d84424fccedab662d07729e20f"}
{"project": "qemu", "commit_id": "b7b6348ab433519f16c1500e3ea04805428be91e", "target": 0, "func": "static void copy_irb_to_guest(IRB *dest, const IRB *src, PMCW *pmcw)\n\n{\n\n    int i;\n\n    uint16_t stctl = src->scsw.ctrl & SCSW_CTRL_MASK_STCTL;\n\n    uint16_t actl = src->scsw.ctrl & SCSW_CTRL_MASK_ACTL;\n\n\n\n    copy_scsw_to_guest(&dest->scsw, &src->scsw);\n\n\n\n    for (i = 0; i < ARRAY_SIZE(dest->esw); i++) {\n\n        dest->esw[i] = cpu_to_be32(src->esw[i]);\n\n    }\n\n    for (i = 0; i < ARRAY_SIZE(dest->ecw); i++) {\n\n        dest->ecw[i] = cpu_to_be32(src->ecw[i]);\n\n    }\n\n    /* extended measurements enabled? */\n\n    if ((src->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||\n\n        !(pmcw->flags & PMCW_FLAGS_MASK_TF) ||\n\n        !(pmcw->chars & PMCW_CHARS_MASK_XMWME)) {\n\n        return;\n\n    }\n\n    /* extended measurements pending? */\n\n    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {\n\n        return;\n\n    }\n\n    if ((stctl & SCSW_STCTL_PRIMARY) ||\n\n        (stctl == SCSW_STCTL_SECONDARY) ||\n\n        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {\n\n        for (i = 0; i < ARRAY_SIZE(dest->emw); i++) {\n\n            dest->emw[i] = cpu_to_be32(src->emw[i]);\n\n        }\n\n    }\n\n}\n", "idx": 547, "_split": "test", "_hash": "c9593fc2077bc060c2a5013b0f5d2497"}
{"project": "qemu", "commit_id": "c5a49c63fa26e8825ad101dfe86339ae4c216539", "target": 1, "func": "static target_ulong disas_insn(DisasContext *s, CPUState *cpu)\n\n{\n\n    CPUX86State *env = cpu->env_ptr;\n\n    int b, prefixes;\n\n    int shift;\n\n    TCGMemOp ot, aflag, dflag;\n\n    int modrm, reg, rm, mod, op, opreg, val;\n\n    target_ulong next_eip, tval;\n\n    int rex_w, rex_r;\n\n    target_ulong pc_start = s->base.pc_next;\n\n\n\n    s->pc_start = s->pc = pc_start;\n\n    prefixes = 0;\n\n    s->override = -1;\n\n    rex_w = -1;\n\n    rex_r = 0;\n\n#ifdef TARGET_X86_64\n\n    s->rex_x = 0;\n\n    s->rex_b = 0;\n\n    x86_64_hregs = 0;\n\n#endif\n\n    s->rip_offset = 0; /* for relative ip address */\n\n    s->vex_l = 0;\n\n    s->vex_v = 0;\n\n    if (sigsetjmp(s->jmpbuf, 0) != 0) {\n\n        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        return s->pc;\n\n    }\n\n\n\n next_byte:\n\n    b = x86_ldub_code(env, s);\n\n    /* Collect prefixes.  */\n\n    switch (b) {\n\n    case 0xf3:\n\n        prefixes |= PREFIX_REPZ;\n\n        goto next_byte;\n\n    case 0xf2:\n\n        prefixes |= PREFIX_REPNZ;\n\n        goto next_byte;\n\n    case 0xf0:\n\n        prefixes |= PREFIX_LOCK;\n\n        goto next_byte;\n\n    case 0x2e:\n\n        s->override = R_CS;\n\n        goto next_byte;\n\n    case 0x36:\n\n        s->override = R_SS;\n\n        goto next_byte;\n\n    case 0x3e:\n\n        s->override = R_DS;\n\n        goto next_byte;\n\n    case 0x26:\n\n        s->override = R_ES;\n\n        goto next_byte;\n\n    case 0x64:\n\n        s->override = R_FS;\n\n        goto next_byte;\n\n    case 0x65:\n\n        s->override = R_GS;\n\n        goto next_byte;\n\n    case 0x66:\n\n        prefixes |= PREFIX_DATA;\n\n        goto next_byte;\n\n    case 0x67:\n\n        prefixes |= PREFIX_ADR;\n\n        goto next_byte;\n\n#ifdef TARGET_X86_64\n\n    case 0x40 ... 0x4f:\n\n        if (CODE64(s)) {\n\n            /* REX prefix */\n\n            rex_w = (b >> 3) & 1;\n\n            rex_r = (b & 0x4) << 1;\n\n            s->rex_x = (b & 0x2) << 2;\n\n            REX_B(s) = (b & 0x1) << 3;\n\n            x86_64_hregs = 1; /* select uniform byte register addressing */\n\n            goto next_byte;\n\n        }\n\n        break;\n\n#endif\n\n    case 0xc5: /* 2-byte VEX */\n\n    case 0xc4: /* 3-byte VEX */\n\n        /* VEX prefixes cannot be used except in 32-bit mode.\n\n           Otherwise the instruction is LES or LDS.  */\n\n        if (s->code32 && !s->vm86) {\n\n            static const int pp_prefix[4] = {\n\n                0, PREFIX_DATA, PREFIX_REPZ, PREFIX_REPNZ\n\n            };\n\n            int vex3, vex2 = x86_ldub_code(env, s);\n\n\n\n            if (!CODE64(s) && (vex2 & 0xc0) != 0xc0) {\n\n                /* 4.1.4.6: In 32-bit mode, bits [7:6] must be 11b,\n\n                   otherwise the instruction is LES or LDS.  */\n\n                break;\n\n            }\n\n            s->pc++;\n\n\n\n            /* 4.1.1-4.1.3: No preceding lock, 66, f2, f3, or rex prefixes. */\n\n            if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ\n\n                            | PREFIX_LOCK | PREFIX_DATA)) {\n\n                goto illegal_op;\n\n            }\n\n#ifdef TARGET_X86_64\n\n            if (x86_64_hregs) {\n\n                goto illegal_op;\n\n            }\n\n#endif\n\n            rex_r = (~vex2 >> 4) & 8;\n\n            if (b == 0xc5) {\n\n                vex3 = vex2;\n\n                b = x86_ldub_code(env, s);\n\n            } else {\n\n#ifdef TARGET_X86_64\n\n                s->rex_x = (~vex2 >> 3) & 8;\n\n                s->rex_b = (~vex2 >> 2) & 8;\n\n#endif\n\n                vex3 = x86_ldub_code(env, s);\n\n                rex_w = (vex3 >> 7) & 1;\n\n                switch (vex2 & 0x1f) {\n\n                case 0x01: /* Implied 0f leading opcode bytes.  */\n\n                    b = x86_ldub_code(env, s) | 0x100;\n\n                    break;\n\n                case 0x02: /* Implied 0f 38 leading opcode bytes.  */\n\n                    b = 0x138;\n\n                    break;\n\n                case 0x03: /* Implied 0f 3a leading opcode bytes.  */\n\n                    b = 0x13a;\n\n                    break;\n\n                default:   /* Reserved for future use.  */\n\n                    goto unknown_op;\n\n                }\n\n            }\n\n            s->vex_v = (~vex3 >> 3) & 0xf;\n\n            s->vex_l = (vex3 >> 2) & 1;\n\n            prefixes |= pp_prefix[vex3 & 3] | PREFIX_VEX;\n\n        }\n\n        break;\n\n    }\n\n\n\n    /* Post-process prefixes.  */\n\n    if (CODE64(s)) {\n\n        /* In 64-bit mode, the default data size is 32-bit.  Select 64-bit\n\n           data with rex_w, and 16-bit data with 0x66; rex_w takes precedence\n\n           over 0x66 if both are present.  */\n\n        dflag = (rex_w > 0 ? MO_64 : prefixes & PREFIX_DATA ? MO_16 : MO_32);\n\n        /* In 64-bit mode, 0x67 selects 32-bit addressing.  */\n\n        aflag = (prefixes & PREFIX_ADR ? MO_32 : MO_64);\n\n    } else {\n\n        /* In 16/32-bit mode, 0x66 selects the opposite data size.  */\n\n        if (s->code32 ^ ((prefixes & PREFIX_DATA) != 0)) {\n\n            dflag = MO_32;\n\n        } else {\n\n            dflag = MO_16;\n\n        }\n\n        /* In 16/32-bit mode, 0x67 selects the opposite addressing.  */\n\n        if (s->code32 ^ ((prefixes & PREFIX_ADR) != 0)) {\n\n            aflag = MO_32;\n\n        }  else {\n\n            aflag = MO_16;\n\n        }\n\n    }\n\n\n\n    s->prefix = prefixes;\n\n    s->aflag = aflag;\n\n    s->dflag = dflag;\n\n\n\n    /* now check op code */\n\n reswitch:\n\n    switch(b) {\n\n    case 0x0f:\n\n        /**************************/\n\n        /* extended op code */\n\n        b = x86_ldub_code(env, s) | 0x100;\n\n        goto reswitch;\n\n\n\n        /**************************/\n\n        /* arith & logic */\n\n    case 0x00 ... 0x05:\n\n    case 0x08 ... 0x0d:\n\n    case 0x10 ... 0x15:\n\n    case 0x18 ... 0x1d:\n\n    case 0x20 ... 0x25:\n\n    case 0x28 ... 0x2d:\n\n    case 0x30 ... 0x35:\n\n    case 0x38 ... 0x3d:\n\n        {\n\n            int op, f, val;\n\n            op = (b >> 3) & 7;\n\n            f = (b >> 1) & 3;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n\n\n            switch(f) {\n\n            case 0: /* OP Ev, Gv */\n\n                modrm = x86_ldub_code(env, s);\n\n                reg = ((modrm >> 3) & 7) | rex_r;\n\n                mod = (modrm >> 6) & 3;\n\n                rm = (modrm & 7) | REX_B(s);\n\n                if (mod != 3) {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    opreg = OR_TMP0;\n\n                } else if (op == OP_XORL && rm == reg) {\n\n                xor_zero:\n\n                    /* xor reg, reg optimisation */\n\n                    set_cc_op(s, CC_OP_CLR);\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n                    gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n                    break;\n\n                } else {\n\n                    opreg = rm;\n\n                }\n\n                gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n                gen_op(s, op, ot, opreg);\n\n                break;\n\n            case 1: /* OP Gv, Ev */\n\n                modrm = x86_ldub_code(env, s);\n\n                mod = (modrm >> 6) & 3;\n\n                reg = ((modrm >> 3) & 7) | rex_r;\n\n                rm = (modrm & 7) | REX_B(s);\n\n                if (mod != 3) {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n                } else if (op == OP_XORL && rm == reg) {\n\n                    goto xor_zero;\n\n                } else {\n\n                    gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n                }\n\n                gen_op(s, op, ot, reg);\n\n                break;\n\n            case 2: /* OP A, Iv */\n\n                val = insn_get(env, s, ot);\n\n                tcg_gen_movi_tl(cpu_T1, val);\n\n                gen_op(s, op, ot, OR_EAX);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x82:\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n    case 0x80: /* GRP1 */\n\n    case 0x81:\n\n    case 0x83:\n\n        {\n\n            int val;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n\n\n            modrm = x86_ldub_code(env, s);\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n            op = (modrm >> 3) & 7;\n\n\n\n            if (mod != 3) {\n\n                if (b == 0x83)\n\n                    s->rip_offset = 1;\n\n                else\n\n                    s->rip_offset = insn_const_size(ot);\n\n                gen_lea_modrm(env, s, modrm);\n\n                opreg = OR_TMP0;\n\n            } else {\n\n                opreg = rm;\n\n            }\n\n\n\n            switch(b) {\n\n            default:\n\n            case 0x80:\n\n            case 0x81:\n\n            case 0x82:\n\n                val = insn_get(env, s, ot);\n\n                break;\n\n            case 0x83:\n\n                val = (int8_t)insn_get(env, s, MO_8);\n\n                break;\n\n            }\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n            gen_op(s, op, ot, opreg);\n\n        }\n\n        break;\n\n\n\n        /**************************/\n\n        /* inc, dec, and other misc arith */\n\n    case 0x40 ... 0x47: /* inc Gv */\n\n        ot = dflag;\n\n        gen_inc(s, ot, OR_EAX + (b & 7), 1);\n\n        break;\n\n    case 0x48 ... 0x4f: /* dec Gv */\n\n        ot = dflag;\n\n        gen_inc(s, ot, OR_EAX + (b & 7), -1);\n\n        break;\n\n    case 0xf6: /* GRP3 */\n\n    case 0xf7:\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        op = (modrm >> 3) & 7;\n\n        if (mod != 3) {\n\n            if (op == 0) {\n\n                s->rip_offset = insn_const_size(ot);\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            /* For those below that handle locked memory, don't load here.  */\n\n            if (!(s->prefix & PREFIX_LOCK)\n\n                || op != 2) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n\n\n        switch(op) {\n\n        case 0: /* test */\n\n            val = insn_get(env, s, ot);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n            gen_op_testl_T0_T1_cc();\n\n            set_cc_op(s, CC_OP_LOGICB + ot);\n\n            break;\n\n        case 2: /* not */\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n                }\n\n                tcg_gen_movi_tl(cpu_T0, ~0);\n\n                tcg_gen_atomic_xor_fetch_tl(cpu_T0, cpu_A0, cpu_T0,\n\n                                            s->mem_index, ot | MO_LE);\n\n            } else {\n\n                tcg_gen_not_tl(cpu_T0, cpu_T0);\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                }\n\n            }\n\n            break;\n\n        case 3: /* neg */\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                TCGLabel *label1;\n\n                TCGv a0, t0, t1, t2;\n\n\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n                }\n\n                a0 = tcg_temp_local_new();\n\n                t0 = tcg_temp_local_new();\n\n                label1 = gen_new_label();\n\n\n\n                tcg_gen_mov_tl(a0, cpu_A0);\n\n                tcg_gen_mov_tl(t0, cpu_T0);\n\n\n\n                gen_set_label(label1);\n\n                t1 = tcg_temp_new();\n\n                t2 = tcg_temp_new();\n\n                tcg_gen_mov_tl(t2, t0);\n\n                tcg_gen_neg_tl(t1, t0);\n\n                tcg_gen_atomic_cmpxchg_tl(t0, a0, t0, t1,\n\n                                          s->mem_index, ot | MO_LE);\n\n                tcg_temp_free(t1);\n\n                tcg_gen_brcond_tl(TCG_COND_NE, t0, t2, label1);\n\n\n\n                tcg_temp_free(t2);\n\n                tcg_temp_free(a0);\n\n                tcg_gen_mov_tl(cpu_T0, t0);\n\n                tcg_temp_free(t0);\n\n            } else {\n\n                tcg_gen_neg_tl(cpu_T0, cpu_T0);\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                }\n\n            }\n\n            gen_op_update_neg_cc();\n\n            set_cc_op(s, CC_OP_SUBB + ot);\n\n            break;\n\n        case 4: /* mul */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);\n\n                tcg_gen_ext8u_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext8u_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_andi_tl(cpu_cc_src, cpu_T0, 0xff00);\n\n                set_cc_op(s, CC_OP_MULB);\n\n                break;\n\n            case MO_16:\n\n                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext16u_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);\n\n                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n                set_cc_op(s, CC_OP_MULW);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);\n\n                tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                                  cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULL);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                tcg_gen_mulu2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],\n\n                                  cpu_T0, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULQ);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 5: /* imul */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);\n\n                tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext8s_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_ext8s_tl(cpu_tmp0, cpu_T0);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n                set_cc_op(s, CC_OP_MULB);\n\n                break;\n\n            case MO_16:\n\n                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);\n\n                tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext16s_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);\n\n                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n                set_cc_op(s, CC_OP_MULW);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);\n\n                tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                                  cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);\n\n                tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);\n\n                set_cc_op(s, CC_OP_MULL);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                tcg_gen_muls2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],\n\n                                  cpu_T0, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_sari_tl(cpu_cc_src, cpu_regs[R_EAX], 63);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULQ);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 6: /* div */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_helper_divb_AL(cpu_env, cpu_T0);\n\n                break;\n\n            case MO_16:\n\n                gen_helper_divw_AX(cpu_env, cpu_T0);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                gen_helper_divl_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                gen_helper_divq_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 7: /* idiv */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_helper_idivb_AL(cpu_env, cpu_T0);\n\n                break;\n\n            case MO_16:\n\n                gen_helper_idivw_AX(cpu_env, cpu_T0);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                gen_helper_idivl_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                gen_helper_idivq_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0xfe: /* GRP4 */\n\n    case 0xff: /* GRP5 */\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        op = (modrm >> 3) & 7;\n\n        if (op >= 2 && b == 0xfe) {\n\n            goto unknown_op;\n\n        }\n\n        if (CODE64(s)) {\n\n            if (op == 2 || op == 4) {\n\n                /* operand size for jumps is 64 bit */\n\n                ot = MO_64;\n\n            } else if (op == 3 || op == 5) {\n\n                ot = dflag != MO_16 ? MO_32 + (rex_w == 1) : MO_16;\n\n            } else if (op == 6) {\n\n                /* default push size is 64 bit */\n\n                ot = mo_pushpop(s, dflag);\n\n            }\n\n        }\n\n        if (mod != 3) {\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (op >= 2 && op != 3 && op != 5)\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n\n\n        switch(op) {\n\n        case 0: /* inc Ev */\n\n            if (mod != 3)\n\n                opreg = OR_TMP0;\n\n            else\n\n                opreg = rm;\n\n            gen_inc(s, ot, opreg, 1);\n\n            break;\n\n        case 1: /* dec Ev */\n\n            if (mod != 3)\n\n                opreg = OR_TMP0;\n\n            else\n\n                opreg = rm;\n\n            gen_inc(s, ot, opreg, -1);\n\n            break;\n\n        case 2: /* call Ev */\n\n            /* XXX: optimize if memory (no 'and' is necessary) */\n\n            if (dflag == MO_16) {\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n            }\n\n            next_eip = s->pc - s->cs_base;\n\n            tcg_gen_movi_tl(cpu_T1, next_eip);\n\n            gen_push_v(s, cpu_T1);\n\n            gen_op_jmp_v(cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jr(s, cpu_T0);\n\n            break;\n\n        case 3: /* lcall Ev */\n\n            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 1 << ot);\n\n            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        do_lcall:\n\n            if (s->pe && !s->vm86) {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lcall_protected(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                           tcg_const_i32(dflag - 1),\n\n                                           tcg_const_tl(s->pc - s->cs_base));\n\n            } else {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lcall_real(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                      tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(s->pc - s->cs_base));\n\n            }\n\n            tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip));\n\n            gen_jr(s, cpu_tmp4);\n\n            break;\n\n        case 4: /* jmp Ev */\n\n            if (dflag == MO_16) {\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n            }\n\n            gen_op_jmp_v(cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jr(s, cpu_T0);\n\n            break;\n\n        case 5: /* ljmp Ev */\n\n            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 1 << ot);\n\n            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        do_ljmp:\n\n            if (s->pe && !s->vm86) {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_ljmp_protected(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                          tcg_const_tl(s->pc - s->cs_base));\n\n            } else {\n\n                gen_op_movl_seg_T0_vm(R_CS);\n\n                gen_op_jmp_v(cpu_T1);\n\n            }\n\n            tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip));\n\n            gen_jr(s, cpu_tmp4);\n\n            break;\n\n        case 6: /* push Ev */\n\n            gen_push_v(s, cpu_T0);\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x84: /* test Ev, Gv */\n\n    case 0x85:\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n        gen_op_testl_T0_T1_cc();\n\n        set_cc_op(s, CC_OP_LOGICB + ot);\n\n        break;\n\n\n\n    case 0xa8: /* test eAX, Iv */\n\n    case 0xa9:\n\n        ot = mo_b_d(b, dflag);\n\n        val = insn_get(env, s, ot);\n\n\n\n        gen_op_mov_v_reg(ot, cpu_T0, OR_EAX);\n\n        tcg_gen_movi_tl(cpu_T1, val);\n\n        gen_op_testl_T0_T1_cc();\n\n        set_cc_op(s, CC_OP_LOGICB + ot);\n\n        break;\n\n\n\n    case 0x98: /* CWDE/CBW */\n\n        switch (dflag) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);\n\n            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_64, R_EAX, cpu_T0);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_32, R_EAX, cpu_T0);\n\n            break;\n\n        case MO_16:\n\n            gen_op_mov_v_reg(MO_8, cpu_T0, R_EAX);\n\n            tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n            break;\n\n        default:\n\n            tcg_abort();\n\n        }\n\n        break;\n\n    case 0x99: /* CDQ/CWD */\n\n        switch (dflag) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            gen_op_mov_v_reg(MO_64, cpu_T0, R_EAX);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 63);\n\n            gen_op_mov_reg_v(MO_64, R_EDX, cpu_T0);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);\n\n            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 31);\n\n            gen_op_mov_reg_v(MO_32, R_EDX, cpu_T0);\n\n            break;\n\n        case MO_16:\n\n            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 15);\n\n            gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n            break;\n\n        default:\n\n            tcg_abort();\n\n        }\n\n        break;\n\n    case 0x1af: /* imul Gv, Ev */\n\n    case 0x69: /* imul Gv, Ev, I */\n\n    case 0x6b:\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        if (b == 0x69)\n\n            s->rip_offset = insn_const_size(ot);\n\n        else if (b == 0x6b)\n\n            s->rip_offset = 1;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        if (b == 0x69) {\n\n            val = insn_get(env, s, ot);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n        } else if (b == 0x6b) {\n\n            val = (int8_t)insn_get(env, s, MO_8);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n        }\n\n        switch (ot) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            tcg_gen_muls2_i64(cpu_regs[reg], cpu_T1, cpu_T0, cpu_T1);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);\n\n            tcg_gen_sari_tl(cpu_cc_src, cpu_cc_dst, 63);\n\n            tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_T1);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n            tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                              cpu_tmp2_i32, cpu_tmp3_i32);\n\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n\n            tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);\n\n            tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n\n            tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);\n\n            break;\n\n        default:\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_ext16s_tl(cpu_T1, cpu_T1);\n\n            /* XXX: use 32 bit mul which could be faster */\n\n            tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n            tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);\n\n            tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n            break;\n\n        }\n\n        set_cc_op(s, CC_OP_MULB + ot);\n\n        break;\n\n    case 0x1c0:\n\n    case 0x1c1: /* xadd Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n        if (mod == 3) {\n\n            rm = (modrm & 7) | REX_B(s);\n\n            gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n            tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n        } else {\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                tcg_gen_atomic_fetch_add_tl(cpu_T1, cpu_A0, cpu_T0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            } else {\n\n                gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        }\n\n        gen_op_update2_cc();\n\n        set_cc_op(s, CC_OP_ADDB + ot);\n\n        break;\n\n    case 0x1b0:\n\n    case 0x1b1: /* cmpxchg Ev, Gv */\n\n        {\n\n            TCGv oldv, newv, cmpv;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            oldv = tcg_temp_new();\n\n            newv = tcg_temp_new();\n\n            cmpv = tcg_temp_new();\n\n            gen_op_mov_v_reg(ot, newv, reg);\n\n            tcg_gen_mov_tl(cmpv, cpu_regs[R_EAX]);\n\n\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_lea_modrm(env, s, modrm);\n\n                tcg_gen_atomic_cmpxchg_tl(oldv, cpu_A0, cmpv, newv,\n\n                                          s->mem_index, ot | MO_LE);\n\n                gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n            } else {\n\n                if (mod == 3) {\n\n                    rm = (modrm & 7) | REX_B(s);\n\n                    gen_op_mov_v_reg(ot, oldv, rm);\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    gen_op_ld_v(s, ot, oldv, cpu_A0);\n\n                    rm = 0; /* avoid warning */\n\n                }\n\n                gen_extu(ot, oldv);\n\n                gen_extu(ot, cmpv);\n\n                /* store value = (old == cmp ? new : old);  */\n\n                tcg_gen_movcond_tl(TCG_COND_EQ, newv, oldv, cmpv, newv, oldv);\n\n                if (mod == 3) {\n\n                    gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n                    gen_op_mov_reg_v(ot, rm, newv);\n\n                } else {\n\n                    /* Perform an unconditional store cycle like physical cpu;\n\n                       must be before changing accumulator to ensure\n\n                       idempotency if the store faults and the instruction\n\n                       is restarted */\n\n                    gen_op_st_v(s, ot, newv, cpu_A0);\n\n                    gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n                }\n\n            }\n\n            tcg_gen_mov_tl(cpu_cc_src, oldv);\n\n            tcg_gen_mov_tl(cpu_cc_srcT, cmpv);\n\n            tcg_gen_sub_tl(cpu_cc_dst, cmpv, oldv);\n\n            set_cc_op(s, CC_OP_SUBB + ot);\n\n            tcg_temp_free(oldv);\n\n            tcg_temp_free(newv);\n\n            tcg_temp_free(cmpv);\n\n        }\n\n        break;\n\n    case 0x1c7: /* cmpxchg8b */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if ((mod == 3) || ((modrm & 0x38) != 0x8))\n\n            goto illegal_op;\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_CX16))\n\n                goto illegal_op;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {\n\n                gen_helper_cmpxchg16b(cpu_env, cpu_A0);\n\n            } else {\n\n                gen_helper_cmpxchg16b_unlocked(cpu_env, cpu_A0);\n\n            }\n\n        } else\n\n#endif        \n\n        {\n\n            if (!(s->cpuid_features & CPUID_CX8))\n\n                goto illegal_op;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {\n\n                gen_helper_cmpxchg8b(cpu_env, cpu_A0);\n\n            } else {\n\n                gen_helper_cmpxchg8b_unlocked(cpu_env, cpu_A0);\n\n            }\n\n        }\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n\n\n        /**************************/\n\n        /* push/pop */\n\n    case 0x50 ... 0x57: /* push */\n\n        gen_op_mov_v_reg(MO_32, cpu_T0, (b & 7) | REX_B(s));\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x58 ... 0x5f: /* pop */\n\n        ot = gen_pop_T0(s);\n\n        /* NOTE: order is important for pop %sp */\n\n        gen_pop_update(s, ot);\n\n        gen_op_mov_reg_v(ot, (b & 7) | REX_B(s), cpu_T0);\n\n        break;\n\n    case 0x60: /* pusha */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_pusha(s);\n\n        break;\n\n    case 0x61: /* popa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_popa(s);\n\n        break;\n\n    case 0x68: /* push Iv */\n\n    case 0x6a:\n\n        ot = mo_pushpop(s, dflag);\n\n        if (b == 0x68)\n\n            val = insn_get(env, s, ot);\n\n        else\n\n            val = (int8_t)insn_get(env, s, MO_8);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x8f: /* pop Ev */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        ot = gen_pop_T0(s);\n\n        if (mod == 3) {\n\n            /* NOTE: order is important for pop %sp */\n\n            gen_pop_update(s, ot);\n\n            rm = (modrm & 7) | REX_B(s);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n        } else {\n\n            /* NOTE: order is important too for MMU exceptions */\n\n            s->popl_esp_hack = 1 << ot;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            s->popl_esp_hack = 0;\n\n            gen_pop_update(s, ot);\n\n        }\n\n        break;\n\n    case 0xc8: /* enter */\n\n        {\n\n            int level;\n\n            val = x86_lduw_code(env, s);\n\n            level = x86_ldub_code(env, s);\n\n            gen_enter(s, val, level);\n\n        }\n\n        break;\n\n    case 0xc9: /* leave */\n\n        gen_leave(s);\n\n        break;\n\n    case 0x06: /* push es */\n\n    case 0x0e: /* push cs */\n\n    case 0x16: /* push ss */\n\n    case 0x1e: /* push ds */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_op_movl_T0_seg(b >> 3);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x1a0: /* push fs */\n\n    case 0x1a8: /* push gs */\n\n        gen_op_movl_T0_seg((b >> 3) & 7);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x07: /* pop es */\n\n    case 0x17: /* pop ss */\n\n    case 0x1f: /* pop ds */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        reg = b >> 3;\n\n        ot = gen_pop_T0(s);\n\n        gen_movl_seg_T0(s, reg);\n\n        gen_pop_update(s, ot);\n\n        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            if (reg == R_SS) {\n\n                s->tf = 0;\n\n                gen_eob_inhibit_irq(s, true);\n\n            } else {\n\n                gen_eob(s);\n\n            }\n\n        }\n\n        break;\n\n    case 0x1a1: /* pop fs */\n\n    case 0x1a9: /* pop gs */\n\n        ot = gen_pop_T0(s);\n\n        gen_movl_seg_T0(s, (b >> 3) & 7);\n\n        gen_pop_update(s, ot);\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n\n\n        /**************************/\n\n        /* mov */\n\n    case 0x88:\n\n    case 0x89: /* mov Gv, Ev */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        /* generate a generic store */\n\n        gen_ldst_modrm(env, s, modrm, ot, reg, 1);\n\n        break;\n\n    case 0xc6:\n\n    case 0xc7: /* mov Ev, Iv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod != 3) {\n\n            s->rip_offset = insn_const_size(ot);\n\n            gen_lea_modrm(env, s, modrm);\n\n        }\n\n        val = insn_get(env, s, ot);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        if (mod != 3) {\n\n            gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n        } else {\n\n            gen_op_mov_reg_v(ot, (modrm & 7) | REX_B(s), cpu_T0);\n\n        }\n\n        break;\n\n    case 0x8a:\n\n    case 0x8b: /* mov Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        break;\n\n    case 0x8e: /* mov seg, Gv */\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = (modrm >> 3) & 7;\n\n        if (reg >= 6 || reg == R_CS)\n\n            goto illegal_op;\n\n        gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n        gen_movl_seg_T0(s, reg);\n\n        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            if (reg == R_SS) {\n\n                s->tf = 0;\n\n                gen_eob_inhibit_irq(s, true);\n\n            } else {\n\n                gen_eob(s);\n\n            }\n\n        }\n\n        break;\n\n    case 0x8c: /* mov Gv, seg */\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        if (reg >= 6)\n\n            goto illegal_op;\n\n        gen_op_movl_T0_seg(reg);\n\n        ot = mod == 3 ? dflag : MO_16;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n        break;\n\n\n\n    case 0x1b6: /* movzbS Gv, Eb */\n\n    case 0x1b7: /* movzwS Gv, Eb */\n\n    case 0x1be: /* movsbS Gv, Eb */\n\n    case 0x1bf: /* movswS Gv, Eb */\n\n        {\n\n            TCGMemOp d_ot;\n\n            TCGMemOp s_ot;\n\n\n\n            /* d_ot is the size of destination */\n\n            d_ot = dflag;\n\n            /* ot is the size of source */\n\n            ot = (b & 1) + MO_8;\n\n            /* s_ot is the sign+size of source */\n\n            s_ot = b & 8 ? MO_SIGN | ot : ot;\n\n\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n\n\n            if (mod == 3) {\n\n                if (s_ot == MO_SB && byte_reg_is_xH(rm)) {\n\n                    tcg_gen_sextract_tl(cpu_T0, cpu_regs[rm - 4], 8, 8);\n\n                } else {\n\n                    gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                    switch (s_ot) {\n\n                    case MO_UB:\n\n                        tcg_gen_ext8u_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    case MO_SB:\n\n                        tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    case MO_UW:\n\n                        tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    default:\n\n                    case MO_SW:\n\n                        tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    }\n\n                }\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            } else {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, s_ot, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x8d: /* lea */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        {\n\n            AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n            TCGv ea = gen_lea_modrm_1(a);\n\n            gen_lea_v_seg(s, s->aflag, ea, -1, -1);\n\n            gen_op_mov_reg_v(dflag, reg, cpu_A0);\n\n        }\n\n        break;\n\n\n\n    case 0xa0: /* mov EAX, Ov */\n\n    case 0xa1:\n\n    case 0xa2: /* mov Ov, EAX */\n\n    case 0xa3:\n\n        {\n\n            target_ulong offset_addr;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n            switch (s->aflag) {\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                offset_addr = x86_ldq_code(env, s);\n\n                break;\n\n#endif\n\n            default:\n\n                offset_addr = insn_get(env, s, s->aflag);\n\n                break;\n\n            }\n\n            tcg_gen_movi_tl(cpu_A0, offset_addr);\n\n            gen_add_A0_ds_seg(s);\n\n            if ((b & 2) == 0) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(ot, R_EAX, cpu_T0);\n\n            } else {\n\n                gen_op_mov_v_reg(ot, cpu_T0, R_EAX);\n\n                gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        }\n\n        break;\n\n    case 0xd7: /* xlat */\n\n        tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EBX]);\n\n        tcg_gen_ext8u_tl(cpu_T0, cpu_regs[R_EAX]);\n\n        tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T0);\n\n        gen_extu(s->aflag, cpu_A0);\n\n        gen_add_A0_ds_seg(s);\n\n        gen_op_ld_v(s, MO_8, cpu_T0, cpu_A0);\n\n        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);\n\n        break;\n\n    case 0xb0 ... 0xb7: /* mov R, Ib */\n\n        val = insn_get(env, s, MO_8);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_op_mov_reg_v(MO_8, (b & 7) | REX_B(s), cpu_T0);\n\n        break;\n\n    case 0xb8 ... 0xbf: /* mov R, Iv */\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            uint64_t tmp;\n\n            /* 64 bit case */\n\n            tmp = x86_ldq_code(env, s);\n\n            reg = (b & 7) | REX_B(s);\n\n            tcg_gen_movi_tl(cpu_T0, tmp);\n\n            gen_op_mov_reg_v(MO_64, reg, cpu_T0);\n\n        } else\n\n#endif\n\n        {\n\n            ot = dflag;\n\n            val = insn_get(env, s, ot);\n\n            reg = (b & 7) | REX_B(s);\n\n            tcg_gen_movi_tl(cpu_T0, val);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        }\n\n        break;\n\n\n\n    case 0x91 ... 0x97: /* xchg R, EAX */\n\n    do_xchg_reg_eax:\n\n        ot = dflag;\n\n        reg = (b & 7) | REX_B(s);\n\n        rm = R_EAX;\n\n        goto do_xchg_reg;\n\n    case 0x86:\n\n    case 0x87: /* xchg Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3) {\n\n            rm = (modrm & 7) | REX_B(s);\n\n        do_xchg_reg:\n\n            gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n            gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        } else {\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n            /* for xchg, lock is implicit */\n\n            tcg_gen_atomic_xchg_tl(cpu_T1, cpu_A0, cpu_T0,\n\n                                   s->mem_index, ot | MO_LE);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        }\n\n        break;\n\n    case 0xc4: /* les Gv */\n\n        /* In CODE64 this is VEX3; see above.  */\n\n        op = R_ES;\n\n        goto do_lxx;\n\n    case 0xc5: /* lds Gv */\n\n        /* In CODE64 this is VEX2; see above.  */\n\n        op = R_DS;\n\n        goto do_lxx;\n\n    case 0x1b2: /* lss Gv */\n\n        op = R_SS;\n\n        goto do_lxx;\n\n    case 0x1b4: /* lfs Gv */\n\n        op = R_FS;\n\n        goto do_lxx;\n\n    case 0x1b5: /* lgs Gv */\n\n        op = R_GS;\n\n    do_lxx:\n\n        ot = dflag != MO_16 ? MO_32 : MO_16;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_lea_modrm(env, s, modrm);\n\n        gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n        gen_add_A0_im(s, 1 << ot);\n\n        /* load the segment first to handle exceptions properly */\n\n        gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        gen_movl_seg_T0(s, op);\n\n        /* then put the data */\n\n        gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* shifts */\n\n    case 0xc0:\n\n    case 0xc1:\n\n        /* shift Ev,Ib */\n\n        shift = 2;\n\n    grp2:\n\n        {\n\n            ot = mo_b_d(b, dflag);\n\n            modrm = x86_ldub_code(env, s);\n\n            mod = (modrm >> 6) & 3;\n\n            op = (modrm >> 3) & 7;\n\n\n\n            if (mod != 3) {\n\n                if (shift == 2) {\n\n                    s->rip_offset = 1;\n\n                }\n\n                gen_lea_modrm(env, s, modrm);\n\n                opreg = OR_TMP0;\n\n            } else {\n\n                opreg = (modrm & 7) | REX_B(s);\n\n            }\n\n\n\n            /* simpler op */\n\n            if (shift == 0) {\n\n                gen_shift(s, op, ot, opreg, OR_ECX);\n\n            } else {\n\n                if (shift == 2) {\n\n                    shift = x86_ldub_code(env, s);\n\n                }\n\n                gen_shifti(s, op, ot, opreg, shift);\n\n            }\n\n        }\n\n        break;\n\n    case 0xd0:\n\n    case 0xd1:\n\n        /* shift Ev,1 */\n\n        shift = 1;\n\n        goto grp2;\n\n    case 0xd2:\n\n    case 0xd3:\n\n        /* shift Ev,cl */\n\n        shift = 0;\n\n        goto grp2;\n\n\n\n    case 0x1a4: /* shld imm */\n\n        op = 0;\n\n        shift = 1;\n\n        goto do_shiftd;\n\n    case 0x1a5: /* shld cl */\n\n        op = 0;\n\n        shift = 0;\n\n        goto do_shiftd;\n\n    case 0x1ac: /* shrd imm */\n\n        op = 1;\n\n        shift = 1;\n\n        goto do_shiftd;\n\n    case 0x1ad: /* shrd cl */\n\n        op = 1;\n\n        shift = 0;\n\n    do_shiftd:\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        if (mod != 3) {\n\n            gen_lea_modrm(env, s, modrm);\n\n            opreg = OR_TMP0;\n\n        } else {\n\n            opreg = rm;\n\n        }\n\n        gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n\n\n        if (shift) {\n\n            TCGv imm = tcg_const_tl(x86_ldub_code(env, s));\n\n            gen_shiftd_rm_T1(s, ot, opreg, op, imm);\n\n            tcg_temp_free(imm);\n\n        } else {\n\n            gen_shiftd_rm_T1(s, ot, opreg, op, cpu_regs[R_ECX]);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* floats */\n\n    case 0xd8 ... 0xdf:\n\n        if (s->flags & (HF_EM_MASK | HF_TS_MASK)) {\n\n            /* if CR0.EM or CR0.TS are set, generate an FPU exception */\n\n            /* XXX: what to do if illegal op ? */\n\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n            break;\n\n        }\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = modrm & 7;\n\n        op = ((b & 7) << 3) | ((modrm >> 3) & 7);\n\n        if (mod != 3) {\n\n            /* memory op */\n\n            gen_lea_modrm(env, s, modrm);\n\n            switch(op) {\n\n            case 0x00 ... 0x07: /* fxxxs */\n\n            case 0x10 ... 0x17: /* fixxxl */\n\n            case 0x20 ... 0x27: /* fxxxl */\n\n            case 0x30 ... 0x37: /* fixxx */\n\n                {\n\n                    int op1;\n\n                    op1 = op & 7;\n\n\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_flds_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 1:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 2:\n\n                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        gen_helper_fldl_FT0(cpu_env, cpu_tmp1_i64);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LESW);\n\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    }\n\n\n\n                    gen_helper_fp_arith_ST0_FT0(op1);\n\n                    if (op1 == 3) {\n\n                        /* fcomp needs pop */\n\n                        gen_helper_fpop(cpu_env);\n\n                    }\n\n                }\n\n                break;\n\n            case 0x08: /* flds */\n\n            case 0x0a: /* fsts */\n\n            case 0x0b: /* fstps */\n\n            case 0x18 ... 0x1b: /* fildl, fisttpl, fistl, fistpl */\n\n            case 0x28 ... 0x2b: /* fldl, fisttpll, fstl, fstpl */\n\n            case 0x38 ... 0x3b: /* filds, fisttps, fists, fistps */\n\n                switch(op & 7) {\n\n                case 0:\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_flds_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 1:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 2:\n\n                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        gen_helper_fldl_ST0(cpu_env, cpu_tmp1_i64);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LESW);\n\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    }\n\n                    break;\n\n                case 1:\n\n                    /* XXX: the corresponding CPUID bit must be tested ! */\n\n                    switch(op >> 4) {\n\n                    case 1:\n\n                        gen_helper_fisttl_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fisttll_ST0(cpu_tmp1_i64, cpu_env);\n\n                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_helper_fistt_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUW);\n\n                        break;\n\n                    }\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        gen_helper_fsts_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 1:\n\n                        gen_helper_fistl_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fstl_ST0(cpu_tmp1_i64, cpu_env);\n\n                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_helper_fist_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUW);\n\n                        break;\n\n                    }\n\n                    if ((op & 7) == 3)\n\n                        gen_helper_fpop(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x0c: /* fldenv mem */\n\n                gen_helper_fldenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x0d: /* fldcw mem */\n\n                tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                gen_helper_fldcw(cpu_env, cpu_tmp2_i32);\n\n                break;\n\n            case 0x0e: /* fnstenv mem */\n\n                gen_helper_fstenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x0f: /* fnstcw mem */\n\n                gen_helper_fnstcw(cpu_tmp2_i32, cpu_env);\n\n                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                break;\n\n            case 0x1d: /* fldt mem */\n\n                gen_helper_fldt_ST0(cpu_env, cpu_A0);\n\n                break;\n\n            case 0x1f: /* fstpt mem */\n\n                gen_helper_fstt_ST0(cpu_env, cpu_A0);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x2c: /* frstor mem */\n\n                gen_helper_frstor(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x2e: /* fnsave mem */\n\n                gen_helper_fsave(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x2f: /* fnstsw mem */\n\n                gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n\n                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                break;\n\n            case 0x3c: /* fbld */\n\n                gen_helper_fbld_ST0(cpu_env, cpu_A0);\n\n                break;\n\n            case 0x3e: /* fbstp */\n\n                gen_helper_fbst_ST0(cpu_env, cpu_A0);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x3d: /* fildll */\n\n                tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);\n\n                gen_helper_fildll_ST0(cpu_env, cpu_tmp1_i64);\n\n                break;\n\n            case 0x3f: /* fistpll */\n\n                gen_helper_fistll_ST0(cpu_tmp1_i64, cpu_env);\n\n                tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n            }\n\n        } else {\n\n            /* register float ops */\n\n            opreg = rm;\n\n\n\n            switch(op) {\n\n            case 0x08: /* fld sti */\n\n                gen_helper_fpush(cpu_env);\n\n                gen_helper_fmov_ST0_STN(cpu_env,\n\n                                        tcg_const_i32((opreg + 1) & 7));\n\n                break;\n\n            case 0x09: /* fxchg sti */\n\n            case 0x29: /* fxchg4 sti, undocumented op */\n\n            case 0x39: /* fxchg7 sti, undocumented op */\n\n                gen_helper_fxchg_ST0_STN(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x0a: /* grp d9/2 */\n\n                switch(rm) {\n\n                case 0: /* fnop */\n\n                    /* check exceptions (FreeBSD FPU probe) */\n\n                    gen_helper_fwait(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x0c: /* grp d9/4 */\n\n                switch(rm) {\n\n                case 0: /* fchs */\n\n                    gen_helper_fchs_ST0(cpu_env);\n\n                    break;\n\n                case 1: /* fabs */\n\n                    gen_helper_fabs_ST0(cpu_env);\n\n                    break;\n\n                case 4: /* ftst */\n\n                    gen_helper_fldz_FT0(cpu_env);\n\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n\n                    break;\n\n                case 5: /* fxam */\n\n                    gen_helper_fxam_ST0(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x0d: /* grp d9/5 */\n\n                {\n\n                    switch(rm) {\n\n                    case 0:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fld1_ST0(cpu_env);\n\n                        break;\n\n                    case 1:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldl2t_ST0(cpu_env);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldl2e_ST0(cpu_env);\n\n                        break;\n\n                    case 3:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldpi_ST0(cpu_env);\n\n                        break;\n\n                    case 4:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldlg2_ST0(cpu_env);\n\n                        break;\n\n                    case 5:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldln2_ST0(cpu_env);\n\n                        break;\n\n                    case 6:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldz_ST0(cpu_env);\n\n                        break;\n\n                    default:\n\n                        goto unknown_op;\n\n                    }\n\n                }\n\n                break;\n\n            case 0x0e: /* grp d9/6 */\n\n                switch(rm) {\n\n                case 0: /* f2xm1 */\n\n                    gen_helper_f2xm1(cpu_env);\n\n                    break;\n\n                case 1: /* fyl2x */\n\n                    gen_helper_fyl2x(cpu_env);\n\n                    break;\n\n                case 2: /* fptan */\n\n                    gen_helper_fptan(cpu_env);\n\n                    break;\n\n                case 3: /* fpatan */\n\n                    gen_helper_fpatan(cpu_env);\n\n                    break;\n\n                case 4: /* fxtract */\n\n                    gen_helper_fxtract(cpu_env);\n\n                    break;\n\n                case 5: /* fprem1 */\n\n                    gen_helper_fprem1(cpu_env);\n\n                    break;\n\n                case 6: /* fdecstp */\n\n                    gen_helper_fdecstp(cpu_env);\n\n                    break;\n\n                default:\n\n                case 7: /* fincstp */\n\n                    gen_helper_fincstp(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x0f: /* grp d9/7 */\n\n                switch(rm) {\n\n                case 0: /* fprem */\n\n                    gen_helper_fprem(cpu_env);\n\n                    break;\n\n                case 1: /* fyl2xp1 */\n\n                    gen_helper_fyl2xp1(cpu_env);\n\n                    break;\n\n                case 2: /* fsqrt */\n\n                    gen_helper_fsqrt(cpu_env);\n\n                    break;\n\n                case 3: /* fsincos */\n\n                    gen_helper_fsincos(cpu_env);\n\n                    break;\n\n                case 5: /* fscale */\n\n                    gen_helper_fscale(cpu_env);\n\n                    break;\n\n                case 4: /* frndint */\n\n                    gen_helper_frndint(cpu_env);\n\n                    break;\n\n                case 6: /* fsin */\n\n                    gen_helper_fsin(cpu_env);\n\n                    break;\n\n                default:\n\n                case 7: /* fcos */\n\n                    gen_helper_fcos(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x00: case 0x01: case 0x04 ... 0x07: /* fxxx st, sti */\n\n            case 0x20: case 0x21: case 0x24 ... 0x27: /* fxxx sti, st */\n\n            case 0x30: case 0x31: case 0x34 ... 0x37: /* fxxxp sti, st */\n\n                {\n\n                    int op1;\n\n\n\n                    op1 = op & 7;\n\n                    if (op >= 0x20) {\n\n                        gen_helper_fp_arith_STN_ST0(op1, opreg);\n\n                        if (op >= 0x30)\n\n                            gen_helper_fpop(cpu_env);\n\n                    } else {\n\n                        gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                        gen_helper_fp_arith_ST0_FT0(op1);\n\n                    }\n\n                }\n\n                break;\n\n            case 0x02: /* fcom */\n\n            case 0x22: /* fcom2, undocumented op */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcom_ST0_FT0(cpu_env);\n\n                break;\n\n            case 0x03: /* fcomp */\n\n            case 0x23: /* fcomp3, undocumented op */\n\n            case 0x32: /* fcomp5, undocumented op */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcom_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x15: /* da/5 */\n\n                switch(rm) {\n\n                case 1: /* fucompp */\n\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n\n                    gen_helper_fucom_ST0_FT0(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x1c:\n\n                switch(rm) {\n\n                case 0: /* feni (287 only, just do nop here) */\n\n                    break;\n\n                case 1: /* fdisi (287 only, just do nop here) */\n\n                    break;\n\n                case 2: /* fclex */\n\n                    gen_helper_fclex(cpu_env);\n\n                    break;\n\n                case 3: /* fninit */\n\n                    gen_helper_fninit(cpu_env);\n\n                    break;\n\n                case 4: /* fsetpm (287 only, just do nop here) */\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x1d: /* fucomi */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x1e: /* fcomi */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x28: /* ffree sti */\n\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x2a: /* fst sti */\n\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x2b: /* fstp sti */\n\n            case 0x0b: /* fstp1 sti, undocumented op */\n\n            case 0x3a: /* fstp8 sti, undocumented op */\n\n            case 0x3b: /* fstp9 sti, undocumented op */\n\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x2c: /* fucom st(i) */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucom_ST0_FT0(cpu_env);\n\n                break;\n\n            case 0x2d: /* fucomp st(i) */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucom_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x33: /* de/3 */\n\n                switch(rm) {\n\n                case 1: /* fcompp */\n\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x38: /* ffreep sti, undocumented op */\n\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x3c: /* df/4 */\n\n                switch(rm) {\n\n                case 0:\n\n                    gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n\n                    tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);\n\n                    gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x3d: /* fucomip */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x3e: /* fcomip */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x10 ... 0x13: /* fcmovxx */\n\n            case 0x18 ... 0x1b:\n\n                {\n\n                    int op1;\n\n                    TCGLabel *l1;\n\n                    static const uint8_t fcmov_cc[8] = {\n\n                        (JCC_B << 1),\n\n                        (JCC_Z << 1),\n\n                        (JCC_BE << 1),\n\n                        (JCC_P << 1),\n\n                    };\n\n\n\n                    if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                        goto illegal_op;\n\n                    }\n\n                    op1 = fcmov_cc[op & 3] | (((op >> 3) & 1) ^ 1);\n\n                    l1 = gen_new_label();\n\n                    gen_jcc1_noeob(s, op1, l1);\n\n                    gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32(opreg));\n\n                    gen_set_label(l1);\n\n                }\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n            }\n\n        }\n\n        break;\n\n        /************************/\n\n        /* string ops */\n\n\n\n    case 0xa4: /* movsS */\n\n    case 0xa5:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_movs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_movs(s, ot);\n\n        }\n\n        break;\n\n\n\n    case 0xaa: /* stosS */\n\n    case 0xab:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_stos(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_stos(s, ot);\n\n        }\n\n        break;\n\n    case 0xac: /* lodsS */\n\n    case 0xad:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_lods(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_lods(s, ot);\n\n        }\n\n        break;\n\n    case 0xae: /* scasS */\n\n    case 0xaf:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & PREFIX_REPNZ) {\n\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n\n        } else if (prefixes & PREFIX_REPZ) {\n\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n\n        } else {\n\n            gen_scas(s, ot);\n\n        }\n\n        break;\n\n\n\n    case 0xa6: /* cmpsS */\n\n    case 0xa7:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & PREFIX_REPNZ) {\n\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n\n        } else if (prefixes & PREFIX_REPZ) {\n\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n\n        } else {\n\n            gen_cmps(s, ot);\n\n        }\n\n        break;\n\n    case 0x6c: /* insS */\n\n    case 0x6d:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base, \n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes) | 4);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_ins(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_ins(s, ot);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n    case 0x6e: /* outsS */\n\n    case 0x6f:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes) | 4);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_outs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_outs(s, ot);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* port I/O */\n\n\n\n    case 0xe4:\n\n    case 0xe5:\n\n        ot = mo_b_d32(b, dflag);\n\n        val = x86_ldub_code(env, s);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, val);\n\n        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);\n\n        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xe6:\n\n    case 0xe7:\n\n        ot = mo_b_d32(b, dflag);\n\n        val = x86_ldub_code(env, s);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes));\n\n        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);\n\n\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, val);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xec:\n\n    case 0xed:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);\n\n        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xee:\n\n    case 0xef:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes));\n\n        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);\n\n\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* control */\n\n    case 0xc2: /* ret im */\n\n        val = x86_ldsw_code(env, s);\n\n        ot = gen_pop_T0(s);\n\n        gen_stack_update(s, val + (1 << ot));\n\n        /* Note that gen_pop_T0 uses a zero-extending load.  */\n\n        gen_op_jmp_v(cpu_T0);\n\n        gen_bnd_jmp(s);\n\n        gen_jr(s, cpu_T0);\n\n        break;\n\n    case 0xc3: /* ret */\n\n        ot = gen_pop_T0(s);\n\n        gen_pop_update(s, ot);\n\n        /* Note that gen_pop_T0 uses a zero-extending load.  */\n\n        gen_op_jmp_v(cpu_T0);\n\n        gen_bnd_jmp(s);\n\n        gen_jr(s, cpu_T0);\n\n        break;\n\n    case 0xca: /* lret im */\n\n        val = x86_ldsw_code(env, s);\n\n    do_lret:\n\n        if (s->pe && !s->vm86) {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_lret_protected(cpu_env, tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(val));\n\n        } else {\n\n            gen_stack_A0(s);\n\n            /* pop offset */\n\n            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);\n\n            /* NOTE: keeping EIP updated is not a problem in case of\n\n               exception */\n\n            gen_op_jmp_v(cpu_T0);\n\n            /* pop selector */\n\n            gen_add_A0_im(s, 1 << dflag);\n\n            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);\n\n            gen_op_movl_seg_T0_vm(R_CS);\n\n            /* add stack offset */\n\n            gen_stack_update(s, val + (2 << dflag));\n\n        }\n\n        gen_eob(s);\n\n        break;\n\n    case 0xcb: /* lret */\n\n        val = 0;\n\n        goto do_lret;\n\n    case 0xcf: /* iret */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET);\n\n        if (!s->pe) {\n\n            /* real mode */\n\n            gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n        } else if (s->vm86) {\n\n            if (s->iopl != 3) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n            }\n\n        } else {\n\n            gen_helper_iret_protected(cpu_env, tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(s->pc - s->cs_base));\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n        }\n\n        gen_eob(s);\n\n        break;\n\n    case 0xe8: /* call im */\n\n        {\n\n            if (dflag != MO_16) {\n\n                tval = (int32_t)insn_get(env, s, MO_32);\n\n            } else {\n\n                tval = (int16_t)insn_get(env, s, MO_16);\n\n            }\n\n            next_eip = s->pc - s->cs_base;\n\n            tval += next_eip;\n\n            if (dflag == MO_16) {\n\n                tval &= 0xffff;\n\n            } else if (!CODE64(s)) {\n\n                tval &= 0xffffffff;\n\n            }\n\n            tcg_gen_movi_tl(cpu_T0, next_eip);\n\n            gen_push_v(s, cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jmp(s, tval);\n\n        }\n\n        break;\n\n    case 0x9a: /* lcall im */\n\n        {\n\n            unsigned int selector, offset;\n\n\n\n            if (CODE64(s))\n\n                goto illegal_op;\n\n            ot = dflag;\n\n            offset = insn_get(env, s, ot);\n\n            selector = insn_get(env, s, MO_16);\n\n\n\n            tcg_gen_movi_tl(cpu_T0, selector);\n\n            tcg_gen_movi_tl(cpu_T1, offset);\n\n        }\n\n        goto do_lcall;\n\n    case 0xe9: /* jmp im */\n\n        if (dflag != MO_16) {\n\n            tval = (int32_t)insn_get(env, s, MO_32);\n\n        } else {\n\n            tval = (int16_t)insn_get(env, s, MO_16);\n\n        }\n\n        tval += s->pc - s->cs_base;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n        } else if (!CODE64(s)) {\n\n            tval &= 0xffffffff;\n\n        }\n\n        gen_bnd_jmp(s);\n\n        gen_jmp(s, tval);\n\n        break;\n\n    case 0xea: /* ljmp im */\n\n        {\n\n            unsigned int selector, offset;\n\n\n\n            if (CODE64(s))\n\n                goto illegal_op;\n\n            ot = dflag;\n\n            offset = insn_get(env, s, ot);\n\n            selector = insn_get(env, s, MO_16);\n\n\n\n            tcg_gen_movi_tl(cpu_T0, selector);\n\n            tcg_gen_movi_tl(cpu_T1, offset);\n\n        }\n\n        goto do_ljmp;\n\n    case 0xeb: /* jmp Jb */\n\n        tval = (int8_t)insn_get(env, s, MO_8);\n\n        tval += s->pc - s->cs_base;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n        }\n\n        gen_jmp(s, tval);\n\n        break;\n\n    case 0x70 ... 0x7f: /* jcc Jb */\n\n        tval = (int8_t)insn_get(env, s, MO_8);\n\n        goto do_jcc;\n\n    case 0x180 ... 0x18f: /* jcc Jv */\n\n        if (dflag != MO_16) {\n\n            tval = (int32_t)insn_get(env, s, MO_32);\n\n        } else {\n\n            tval = (int16_t)insn_get(env, s, MO_16);\n\n        }\n\n    do_jcc:\n\n        next_eip = s->pc - s->cs_base;\n\n        tval += next_eip;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n        }\n\n        gen_bnd_jmp(s);\n\n        gen_jcc(s, b, tval, next_eip);\n\n        break;\n\n\n\n    case 0x190 ... 0x19f: /* setcc Gv */\n\n        modrm = x86_ldub_code(env, s);\n\n        gen_setcc1(s, b, cpu_T0);\n\n        gen_ldst_modrm(env, s, modrm, MO_8, OR_TMP0, 1);\n\n        break;\n\n    case 0x140 ... 0x14f: /* cmov Gv, Ev */\n\n        if (!(s->cpuid_features & CPUID_CMOV)) {\n\n            goto illegal_op;\n\n        }\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        gen_cmovcc1(env, s, ot, b, modrm, reg);\n\n        break;\n\n\n\n        /************************/\n\n        /* flags */\n\n    case 0x9c: /* pushf */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_helper_read_eflags(cpu_T0, cpu_env);\n\n            gen_push_v(s, cpu_T0);\n\n        }\n\n        break;\n\n    case 0x9d: /* popf */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            ot = gen_pop_T0(s);\n\n            if (s->cpl == 0) {\n\n                if (dflag != MO_16) {\n\n                    gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                           ID_MASK | NT_MASK |\n\n                                                           IF_MASK |\n\n                                                           IOPL_MASK)));\n\n                } else {\n\n                    gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                           ID_MASK | NT_MASK |\n\n                                                           IF_MASK | IOPL_MASK)\n\n                                                          & 0xffff));\n\n                }\n\n            } else {\n\n                if (s->cpl <= s->iopl) {\n\n                    if (dflag != MO_16) {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                                tcg_const_i32((TF_MASK |\n\n                                                               AC_MASK |\n\n                                                               ID_MASK |\n\n                                                               NT_MASK |\n\n                                                               IF_MASK)));\n\n                    } else {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                                tcg_const_i32((TF_MASK |\n\n                                                               AC_MASK |\n\n                                                               ID_MASK |\n\n                                                               NT_MASK |\n\n                                                               IF_MASK)\n\n                                                              & 0xffff));\n\n                    }\n\n                } else {\n\n                    if (dflag != MO_16) {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                          ID_MASK | NT_MASK)));\n\n                    } else {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                          ID_MASK | NT_MASK)\n\n                                                         & 0xffff));\n\n                    }\n\n                }\n\n            }\n\n            gen_pop_update(s, ot);\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            /* abort translation because TF/AC flag may change */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x9e: /* sahf */\n\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n\n            goto illegal_op;\n\n        gen_op_mov_v_reg(MO_8, cpu_T0, R_AH);\n\n        gen_compute_eflags(s);\n\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O);\n\n        tcg_gen_andi_tl(cpu_T0, cpu_T0, CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n        tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T0);\n\n        break;\n\n    case 0x9f: /* lahf */\n\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n\n            goto illegal_op;\n\n        gen_compute_eflags(s);\n\n        /* Note: gen_compute_eflags() only gives the condition codes */\n\n        tcg_gen_ori_tl(cpu_T0, cpu_cc_src, 0x02);\n\n        gen_op_mov_reg_v(MO_8, R_AH, cpu_T0);\n\n        break;\n\n    case 0xf5: /* cmc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n\n        break;\n\n    case 0xf8: /* clc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C);\n\n        break;\n\n    case 0xf9: /* stc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n\n        break;\n\n    case 0xfc: /* cld */\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, 1);\n\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n\n        break;\n\n    case 0xfd: /* std */\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, -1);\n\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n\n        break;\n\n\n\n        /************************/\n\n        /* bit operations */\n\n    case 0x1ba: /* bt/bts/btr/btc Gv, im */\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        op = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        if (mod != 3) {\n\n            s->rip_offset = 1;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (!(s->prefix & PREFIX_LOCK)) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n        /* load shift */\n\n        val = x86_ldub_code(env, s);\n\n        tcg_gen_movi_tl(cpu_T1, val);\n\n        if (op < 4)\n\n            goto unknown_op;\n\n        op -= 4;\n\n        goto bt_op;\n\n    case 0x1a3: /* bt Gv, Ev */\n\n        op = 0;\n\n        goto do_btx;\n\n    case 0x1ab: /* bts */\n\n        op = 1;\n\n        goto do_btx;\n\n    case 0x1b3: /* btr */\n\n        op = 2;\n\n        goto do_btx;\n\n    case 0x1bb: /* btc */\n\n        op = 3;\n\n    do_btx:\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        gen_op_mov_v_reg(MO_32, cpu_T1, reg);\n\n        if (mod != 3) {\n\n            AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n            /* specific case: we need to add a displacement */\n\n            gen_exts(ot, cpu_T1);\n\n            tcg_gen_sari_tl(cpu_tmp0, cpu_T1, 3 + ot);\n\n            tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, ot);\n\n            tcg_gen_add_tl(cpu_A0, gen_lea_modrm_1(a), cpu_tmp0);\n\n            gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n            if (!(s->prefix & PREFIX_LOCK)) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n    bt_op:\n\n        tcg_gen_andi_tl(cpu_T1, cpu_T1, (1 << (3 + ot)) - 1);\n\n        tcg_gen_movi_tl(cpu_tmp0, 1);\n\n        tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T1);\n\n        if (s->prefix & PREFIX_LOCK) {\n\n            switch (op) {\n\n            case 0: /* bt */\n\n                /* Needs no atomic ops; we surpressed the normal\n\n                   memory load for LOCK above so do it now.  */\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n                break;\n\n            case 1: /* bts */\n\n                tcg_gen_atomic_fetch_or_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                           s->mem_index, ot | MO_LE);\n\n                break;\n\n            case 2: /* btr */\n\n                tcg_gen_not_tl(cpu_tmp0, cpu_tmp0);\n\n                tcg_gen_atomic_fetch_and_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                break;\n\n            default:\n\n            case 3: /* btc */\n\n                tcg_gen_atomic_fetch_xor_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                break;\n\n            }\n\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);\n\n        } else {\n\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);\n\n            switch (op) {\n\n            case 0: /* bt */\n\n                /* Data already loaded; nothing to do.  */\n\n                break;\n\n            case 1: /* bts */\n\n                tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n            case 2: /* btr */\n\n                tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n            default:\n\n            case 3: /* btc */\n\n                tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n            }\n\n            if (op != 0) {\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                }\n\n            }\n\n        }\n\n\n\n        /* Delay all CC updates until after the store above.  Note that\n\n           C is the result of the test, Z is unchanged, and the others\n\n           are all undefined.  */\n\n        switch (s->cc_op) {\n\n        case CC_OP_MULB ... CC_OP_MULQ:\n\n        case CC_OP_ADDB ... CC_OP_ADDQ:\n\n        case CC_OP_ADCB ... CC_OP_ADCQ:\n\n        case CC_OP_SUBB ... CC_OP_SUBQ:\n\n        case CC_OP_SBBB ... CC_OP_SBBQ:\n\n        case CC_OP_LOGICB ... CC_OP_LOGICQ:\n\n        case CC_OP_INCB ... CC_OP_INCQ:\n\n        case CC_OP_DECB ... CC_OP_DECQ:\n\n        case CC_OP_SHLB ... CC_OP_SHLQ:\n\n        case CC_OP_SARB ... CC_OP_SARQ:\n\n        case CC_OP_BMILGB ... CC_OP_BMILGQ:\n\n            /* Z was going to be computed from the non-zero status of CC_DST.\n\n               We can get that same Z value (and the new C value) by leaving\n\n               CC_DST alone, setting CC_SRC, and using a CC_OP_SAR of the\n\n               same width.  */\n\n            tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4);\n\n            set_cc_op(s, ((s->cc_op - CC_OP_MULB) & 3) + CC_OP_SARB);\n\n            break;\n\n        default:\n\n            /* Otherwise, generate EFLAGS and replace the C bit.  */\n\n            gen_compute_eflags(s);\n\n            tcg_gen_deposit_tl(cpu_cc_src, cpu_cc_src, cpu_tmp4,\n\n                               ctz32(CC_C), 1);\n\n            break;\n\n        }\n\n        break;\n\n    case 0x1bc: /* bsf / tzcnt */\n\n    case 0x1bd: /* bsr / lzcnt */\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_extu(ot, cpu_T0);\n\n\n\n        /* Note that lzcnt and tzcnt are in different extensions.  */\n\n        if ((prefixes & PREFIX_REPZ)\n\n            && (b & 1\n\n                ? s->cpuid_ext3_features & CPUID_EXT3_ABM\n\n                : s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)) {\n\n            int size = 8 << ot;\n\n            /* For lzcnt/tzcnt, C bit is defined related to the input. */\n\n            tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n            if (b & 1) {\n\n                /* For lzcnt, reduce the target_ulong result by the\n\n                   number of zeros that we expect to find at the top.  */\n\n                tcg_gen_clzi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS);\n\n                tcg_gen_subi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - size);\n\n            } else {\n\n                /* For tzcnt, a zero input must return the operand size.  */\n\n                tcg_gen_ctzi_tl(cpu_T0, cpu_T0, size);\n\n            }\n\n            /* For lzcnt/tzcnt, Z bit is defined related to the result.  */\n\n            gen_op_update1_cc();\n\n            set_cc_op(s, CC_OP_BMILGB + ot);\n\n        } else {\n\n            /* For bsr/bsf, only the Z bit is defined and it is related\n\n               to the input and not the result.  */\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n            set_cc_op(s, CC_OP_LOGICB + ot);\n\n\n\n            /* ??? The manual says that the output is undefined when the\n\n               input is zero, but real hardware leaves it unchanged, and\n\n               real programs appear to depend on that.  Accomplish this\n\n               by passing the output as the value to return upon zero.  */\n\n            if (b & 1) {\n\n                /* For bsr, return the bit index of the first 1 bit,\n\n                   not the count of leading zeros.  */\n\n                tcg_gen_xori_tl(cpu_T1, cpu_regs[reg], TARGET_LONG_BITS - 1);\n\n                tcg_gen_clz_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                tcg_gen_xori_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - 1);\n\n            } else {\n\n                tcg_gen_ctz_tl(cpu_T0, cpu_T0, cpu_regs[reg]);\n\n            }\n\n        }\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        break;\n\n        /************************/\n\n        /* bcd */\n\n    case 0x27: /* daa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_daa(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x2f: /* das */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_das(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x37: /* aaa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_aaa(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x3f: /* aas */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_aas(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0xd4: /* aam */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        val = x86_ldub_code(env, s);\n\n        if (val == 0) {\n\n            gen_exception(s, EXCP00_DIVZ, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_aam(cpu_env, tcg_const_i32(val));\n\n            set_cc_op(s, CC_OP_LOGICB);\n\n        }\n\n        break;\n\n    case 0xd5: /* aad */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        val = x86_ldub_code(env, s);\n\n        gen_helper_aad(cpu_env, tcg_const_i32(val));\n\n        set_cc_op(s, CC_OP_LOGICB);\n\n        break;\n\n        /************************/\n\n        /* misc */\n\n    case 0x90: /* nop */\n\n        /* XXX: correct lock test for all insn */\n\n        if (prefixes & PREFIX_LOCK) {\n\n            goto illegal_op;\n\n        }\n\n        /* If REX_B is set, then this is xchg eax, r8d, not a nop.  */\n\n        if (REX_B(s)) {\n\n            goto do_xchg_reg_eax;\n\n        }\n\n        if (prefixes & PREFIX_REPZ) {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_pause(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            s->base.is_jmp = DISAS_NORETURN;\n\n        }\n\n        break;\n\n    case 0x9b: /* fwait */\n\n        if ((s->flags & (HF_MP_MASK | HF_TS_MASK)) ==\n\n            (HF_MP_MASK | HF_TS_MASK)) {\n\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_fwait(cpu_env);\n\n        }\n\n        break;\n\n    case 0xcc: /* int3 */\n\n        gen_interrupt(s, EXCP03_INT3, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        break;\n\n    case 0xcd: /* int N */\n\n        val = x86_ldub_code(env, s);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_interrupt(s, val, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xce: /* into */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_into(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n        break;\n\n#ifdef WANT_ICEBP\n\n    case 0xf1: /* icebp (undocumented, exits to external debugger) */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_ICEBP);\n\n#if 1\n\n        gen_debug(s, pc_start - s->cs_base);\n\n#else\n\n        /* start debug */\n\n        tb_flush(CPU(x86_env_get_cpu(env)));\n\n        qemu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM);\n\n#endif\n\n        break;\n\n#endif\n\n    case 0xfa: /* cli */\n\n        if (!s->vm86) {\n\n            if (s->cpl <= s->iopl) {\n\n                gen_helper_cli(cpu_env);\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            }\n\n        } else {\n\n            if (s->iopl == 3) {\n\n                gen_helper_cli(cpu_env);\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n    case 0xfb: /* sti */\n\n        if (s->vm86 ? s->iopl == 3 : s->cpl <= s->iopl) {\n\n            gen_helper_sti(cpu_env);\n\n            /* interruptions are enabled only the first insn after sti */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob_inhibit_irq(s, true);\n\n        } else {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        }\n\n        break;\n\n    case 0x62: /* bound */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n        gen_lea_modrm(env, s, modrm);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        if (ot == MO_16) {\n\n            gen_helper_boundw(cpu_env, cpu_A0, cpu_tmp2_i32);\n\n        } else {\n\n            gen_helper_boundl(cpu_env, cpu_A0, cpu_tmp2_i32);\n\n        }\n\n        break;\n\n    case 0x1c8 ... 0x1cf: /* bswap reg */\n\n        reg = (b & 7) | REX_B(s);\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            gen_op_mov_v_reg(MO_64, cpu_T0, reg);\n\n            tcg_gen_bswap64_i64(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_64, reg, cpu_T0);\n\n        } else\n\n#endif\n\n        {\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, reg);\n\n            tcg_gen_ext32u_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_bswap32_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_32, reg, cpu_T0);\n\n        }\n\n        break;\n\n    case 0xd6: /* salc */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_compute_eflags_c(s, cpu_T0);\n\n        tcg_gen_neg_tl(cpu_T0, cpu_T0);\n\n        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);\n\n        break;\n\n    case 0xe0: /* loopnz */\n\n    case 0xe1: /* loopz */\n\n    case 0xe2: /* loop */\n\n    case 0xe3: /* jecxz */\n\n        {\n\n            TCGLabel *l1, *l2, *l3;\n\n\n\n            tval = (int8_t)insn_get(env, s, MO_8);\n\n            next_eip = s->pc - s->cs_base;\n\n            tval += next_eip;\n\n            if (dflag == MO_16) {\n\n                tval &= 0xffff;\n\n            }\n\n\n\n            l1 = gen_new_label();\n\n            l2 = gen_new_label();\n\n            l3 = gen_new_label();\n\n            b &= 3;\n\n            switch(b) {\n\n            case 0: /* loopnz */\n\n            case 1: /* loopz */\n\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n\n                gen_op_jz_ecx(s->aflag, l3);\n\n                gen_jcc1(s, (JCC_Z << 1) | (b ^ 1), l1);\n\n                break;\n\n            case 2: /* loop */\n\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n\n                gen_op_jnz_ecx(s->aflag, l1);\n\n                break;\n\n            default:\n\n            case 3: /* jcxz */\n\n                gen_op_jz_ecx(s->aflag, l1);\n\n                break;\n\n            }\n\n\n\n            gen_set_label(l3);\n\n            gen_jmp_im(next_eip);\n\n            tcg_gen_br(l2);\n\n\n\n            gen_set_label(l1);\n\n            gen_jmp_im(tval);\n\n            gen_set_label(l2);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x130: /* wrmsr */\n\n    case 0x132: /* rdmsr */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            if (b & 2) {\n\n                gen_helper_rdmsr(cpu_env);\n\n            } else {\n\n                gen_helper_wrmsr(cpu_env);\n\n            }\n\n        }\n\n        break;\n\n    case 0x131: /* rdtsc */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        gen_helper_rdtsc(cpu_env);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0x133: /* rdpmc */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_rdpmc(cpu_env);\n\n        break;\n\n    case 0x134: /* sysenter */\n\n        /* For Intel SYSENTER is valid on 64-bit */\n\n        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n\n            goto illegal_op;\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysenter(cpu_env);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x135: /* sysexit */\n\n        /* For Intel SYSEXIT is valid on 64-bit */\n\n        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n\n            goto illegal_op;\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysexit(cpu_env, tcg_const_i32(dflag - 1));\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n#ifdef TARGET_X86_64\n\n    case 0x105: /* syscall */\n\n        /* XXX: is it usable in real mode ? */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_syscall(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n        /* TF handling for the syscall insn is different. The TF bit is  checked\n\n           after the syscall insn completes. This allows #DB to not be\n\n           generated after one has entered CPL0 if TF is set in FMASK.  */\n\n        gen_eob_worker(s, false, true);\n\n        break;\n\n    case 0x107: /* sysret */\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysret(cpu_env, tcg_const_i32(dflag - 1));\n\n            /* condition codes are modified only in long mode */\n\n            if (s->lma) {\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n            }\n\n            /* TF handling for the sysret insn is different. The TF bit is\n\n               checked after the sysret insn completes. This allows #DB to be\n\n               generated \"as if\" the syscall insn in userspace has just\n\n               completed.  */\n\n            gen_eob_worker(s, false, true);\n\n        }\n\n        break;\n\n#endif\n\n    case 0x1a2: /* cpuid */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_cpuid(cpu_env);\n\n        break;\n\n    case 0xf4: /* hlt */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_hlt(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            s->base.is_jmp = DISAS_NORETURN;\n\n        }\n\n        break;\n\n    case 0x100:\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        switch(op) {\n\n        case 0: /* sldt */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_READ);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n\n                             offsetof(CPUX86State, ldt.selector));\n\n            ot = mod == 3 ? dflag : MO_16;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 2: /* lldt */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_WRITE);\n\n                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lldt(cpu_env, cpu_tmp2_i32);\n\n            }\n\n            break;\n\n        case 1: /* str */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_READ);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n\n                             offsetof(CPUX86State, tr.selector));\n\n            ot = mod == 3 ? dflag : MO_16;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 3: /* ltr */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_WRITE);\n\n                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_ltr(cpu_env, cpu_tmp2_i32);\n\n            }\n\n            break;\n\n        case 4: /* verr */\n\n        case 5: /* verw */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            gen_update_cc_op(s);\n\n            if (op == 4) {\n\n                gen_helper_verr(cpu_env, cpu_T0);\n\n            } else {\n\n                gen_helper_verw(cpu_env, cpu_T0);\n\n            }\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x101:\n\n        modrm = x86_ldub_code(env, s);\n\n        switch (modrm) {\n\n        CASE_MODRM_MEM_OP(0): /* sgdt */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_READ);\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0,\n\n                             cpu_env, offsetof(CPUX86State, gdt.limit));\n\n            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        case 0xc8: /* monitor */\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EAX]);\n\n            gen_extu(s->aflag, cpu_A0);\n\n            gen_add_A0_ds_seg(s);\n\n            gen_helper_monitor(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        case 0xc9: /* mwait */\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_mwait(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xca: /* clac */\n\n            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)\n\n                || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_helper_clac(cpu_env);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xcb: /* stac */\n\n            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)\n\n                || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_helper_stac(cpu_env);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(1): /* sidt */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_READ);\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.limit));\n\n            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        case 0xd0: /* xgetbv */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA\n\n                                 | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_xgetbv(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);\n\n            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);\n\n            break;\n\n\n\n        case 0xd1: /* xsetbv */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA\n\n                                 | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_xsetbv(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);\n\n            /* End TB because translation flags may change.  */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xd8: /* VMRUN */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmrun(cpu_env, tcg_const_i32(s->aflag - 1),\n\n                             tcg_const_i32(s->pc - pc_start));\n\n            tcg_gen_exit_tb(0);\n\n            s->base.is_jmp = DISAS_NORETURN;\n\n            break;\n\n\n\n        case 0xd9: /* VMMCALL */\n\n            if (!(s->flags & HF_SVME_MASK)) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmmcall(cpu_env);\n\n            break;\n\n\n\n        case 0xda: /* VMLOAD */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmload(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        case 0xdb: /* VMSAVE */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmsave(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        case 0xdc: /* STGI */\n\n            if ((!(s->flags & HF_SVME_MASK)\n\n                   && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))\n\n                || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_stgi(cpu_env);\n\n            break;\n\n\n\n        case 0xdd: /* CLGI */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_clgi(cpu_env);\n\n            break;\n\n\n\n        case 0xde: /* SKINIT */\n\n            if ((!(s->flags & HF_SVME_MASK)\n\n                 && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))\n\n                || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_skinit(cpu_env);\n\n            break;\n\n\n\n        case 0xdf: /* INVLPGA */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_invlpga(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(2): /* lgdt */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_WRITE);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));\n\n            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, gdt.limit));\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(3): /* lidt */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_WRITE);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));\n\n            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, idt.limit));\n\n            break;\n\n\n\n        CASE_MODRM_OP(4): /* smsw */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_CR0);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, cr[0]));\n\n            if (CODE64(s)) {\n\n                mod = (modrm >> 6) & 3;\n\n                ot = (mod != 3 ? MO_16 : s->dflag);\n\n            } else {\n\n                ot = MO_16;\n\n            }\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 0xee: /* rdpkru */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_rdpkru(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);\n\n            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);\n\n            break;\n\n        case 0xef: /* wrpkru */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_wrpkru(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);\n\n            break;\n\n        CASE_MODRM_OP(6): /* lmsw */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            gen_helper_lmsw(cpu_env, cpu_T0);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(7): /* invlpg */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_invlpg(cpu_env, cpu_A0);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xf8: /* swapgs */\n\n#ifdef TARGET_X86_64\n\n            if (CODE64(s)) {\n\n                if (s->cpl != 0) {\n\n                    gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                } else {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_seg_base[R_GS]);\n\n                    tcg_gen_ld_tl(cpu_seg_base[R_GS], cpu_env,\n\n                                  offsetof(CPUX86State, kernelgsbase));\n\n                    tcg_gen_st_tl(cpu_T0, cpu_env,\n\n                                  offsetof(CPUX86State, kernelgsbase));\n\n                }\n\n                break;\n\n            }\n\n#endif\n\n            goto illegal_op;\n\n\n\n        case 0xf9: /* rdtscp */\n\n            if (!(s->cpuid_ext2_features & CPUID_EXT2_RDTSCP)) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_io_start();\n\n            }\n\n            gen_helper_rdtscp(cpu_env);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_io_end();\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x108: /* invd */\n\n    case 0x109: /* wbinvd */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_svm_check_intercept(s, pc_start, (b & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD);\n\n            /* nothing to do */\n\n        }\n\n        break;\n\n    case 0x63: /* arpl or movslS (x86_64) */\n\n#ifdef TARGET_X86_64\n\n        if (CODE64(s)) {\n\n            int d_ot;\n\n            /* d_ot is the size of destination */\n\n            d_ot = dflag;\n\n\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n\n\n            if (mod == 3) {\n\n                gen_op_mov_v_reg(MO_32, cpu_T0, rm);\n\n                /* sign extend */\n\n                if (d_ot == MO_64) {\n\n                    tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n                }\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            } else {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, MO_32 | MO_SIGN, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            }\n\n        } else\n\n#endif\n\n        {\n\n            TCGLabel *label1;\n\n            TCGv t0, t1, t2, a0;\n\n\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            t0 = tcg_temp_local_new();\n\n            t1 = tcg_temp_local_new();\n\n            t2 = tcg_temp_local_new();\n\n            ot = MO_16;\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = (modrm >> 3) & 7;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = modrm & 7;\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, ot, t0, cpu_A0);\n\n                a0 = tcg_temp_local_new();\n\n                tcg_gen_mov_tl(a0, cpu_A0);\n\n            } else {\n\n                gen_op_mov_v_reg(ot, t0, rm);\n\n                TCGV_UNUSED(a0);\n\n            }\n\n            gen_op_mov_v_reg(ot, t1, reg);\n\n            tcg_gen_andi_tl(cpu_tmp0, t0, 3);\n\n            tcg_gen_andi_tl(t1, t1, 3);\n\n            tcg_gen_movi_tl(t2, 0);\n\n            label1 = gen_new_label();\n\n            tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, t1, label1);\n\n            tcg_gen_andi_tl(t0, t0, ~3);\n\n            tcg_gen_or_tl(t0, t0, t1);\n\n            tcg_gen_movi_tl(t2, CC_Z);\n\n            gen_set_label(label1);\n\n            if (mod != 3) {\n\n                gen_op_st_v(s, ot, t0, a0);\n\n                tcg_temp_free(a0);\n\n           } else {\n\n                gen_op_mov_reg_v(ot, rm, t0);\n\n            }\n\n            gen_compute_eflags(s);\n\n            tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z);\n\n            tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, t2);\n\n            tcg_temp_free(t0);\n\n            tcg_temp_free(t1);\n\n            tcg_temp_free(t2);\n\n        }\n\n        break;\n\n    case 0x102: /* lar */\n\n    case 0x103: /* lsl */\n\n        {\n\n            TCGLabel *label1;\n\n            TCGv t0;\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            ot = dflag != MO_16 ? MO_32 : MO_16;\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            t0 = tcg_temp_local_new();\n\n            gen_update_cc_op(s);\n\n            if (b == 0x102) {\n\n                gen_helper_lar(t0, cpu_env, cpu_T0);\n\n            } else {\n\n                gen_helper_lsl(t0, cpu_env, cpu_T0);\n\n            }\n\n            tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z);\n\n            label1 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1);\n\n            gen_op_mov_reg_v(ot, reg, t0);\n\n            gen_set_label(label1);\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            tcg_temp_free(t0);\n\n        }\n\n        break;\n\n    case 0x118:\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        switch(op) {\n\n        case 0: /* prefetchnta */\n\n        case 1: /* prefetchnt0 */\n\n        case 2: /* prefetchnt0 */\n\n        case 3: /* prefetchnt0 */\n\n            if (mod == 3)\n\n                goto illegal_op;\n\n            gen_nop_modrm(env, s, modrm);\n\n            /* nothing more to do */\n\n            break;\n\n        default: /* nop (multi byte) */\n\n            gen_nop_modrm(env, s, modrm);\n\n            break;\n\n        }\n\n        break;\n\n    case 0x11a:\n\n        modrm = x86_ldub_code(env, s);\n\n        if (s->flags & HF_MPX_EN_MASK) {\n\n            mod = (modrm >> 6) & 3;\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (prefixes & PREFIX_REPZ) {\n\n                /* bndcl */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_bndck(env, s, modrm, TCG_COND_LTU, cpu_bndl[reg]);\n\n            } else if (prefixes & PREFIX_REPNZ) {\n\n                /* bndcu */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                TCGv_i64 notu = tcg_temp_new_i64();\n\n                tcg_gen_not_i64(notu, cpu_bndu[reg]);\n\n                gen_bndck(env, s, modrm, TCG_COND_GTU, notu);\n\n                tcg_temp_free_i64(notu);\n\n            } else if (prefixes & PREFIX_DATA) {\n\n                /* bndmov -- from reg/mem */\n\n                if (reg >= 4 || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                if (mod == 3) {\n\n                    int reg2 = (modrm & 7) | REX_B(s);\n\n                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {\n\n                        goto illegal_op;\n\n                    }\n\n                    if (s->flags & HF_MPX_IU_MASK) {\n\n                        tcg_gen_mov_i64(cpu_bndl[reg], cpu_bndl[reg2]);\n\n                        tcg_gen_mov_i64(cpu_bndu[reg], cpu_bndu[reg2]);\n\n                    }\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    if (CODE64(s)) {\n\n                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);\n\n                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                    } else {\n\n                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);\n\n                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                    }\n\n                    /* bnd registers are now in-use */\n\n                    gen_set_hflag(s, HF_MPX_IU_MASK);\n\n                }\n\n            } else if (mod != 3) {\n\n                /* bndldx */\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16\n\n                    || a.base < -1) {\n\n                    goto illegal_op;\n\n                }\n\n                if (a.base >= 0) {\n\n                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_A0, 0);\n\n                }\n\n                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n                if (a.index >= 0) {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n                }\n\n                if (CODE64(s)) {\n\n                    gen_helper_bndldx64(cpu_bndl[reg], cpu_env, cpu_A0, cpu_T0);\n\n                    tcg_gen_ld_i64(cpu_bndu[reg], cpu_env,\n\n                                   offsetof(CPUX86State, mmx_t0.MMX_Q(0)));\n\n                } else {\n\n                    gen_helper_bndldx32(cpu_bndu[reg], cpu_env, cpu_A0, cpu_T0);\n\n                    tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndu[reg]);\n\n                    tcg_gen_shri_i64(cpu_bndu[reg], cpu_bndu[reg], 32);\n\n                }\n\n                gen_set_hflag(s, HF_MPX_IU_MASK);\n\n            }\n\n        }\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x11b:\n\n        modrm = x86_ldub_code(env, s);\n\n        if (s->flags & HF_MPX_EN_MASK) {\n\n            mod = (modrm >> 6) & 3;\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (mod != 3 && (prefixes & PREFIX_REPZ)) {\n\n                /* bndmk */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (a.base >= 0) {\n\n                    tcg_gen_extu_tl_i64(cpu_bndl[reg], cpu_regs[a.base]);\n\n                    if (!CODE64(s)) {\n\n                        tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndl[reg]);\n\n                    }\n\n                } else if (a.base == -1) {\n\n                    /* no base register has lower bound of 0 */\n\n                    tcg_gen_movi_i64(cpu_bndl[reg], 0);\n\n                } else {\n\n                    /* rip-relative generates #ud */\n\n                    goto illegal_op;\n\n                }\n\n                tcg_gen_not_tl(cpu_A0, gen_lea_modrm_1(a));\n\n                if (!CODE64(s)) {\n\n                    tcg_gen_ext32u_tl(cpu_A0, cpu_A0);\n\n                }\n\n                tcg_gen_extu_tl_i64(cpu_bndu[reg], cpu_A0);\n\n                /* bnd registers are now in-use */\n\n                gen_set_hflag(s, HF_MPX_IU_MASK);\n\n                break;\n\n            } else if (prefixes & PREFIX_REPNZ) {\n\n                /* bndcn */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_bndck(env, s, modrm, TCG_COND_GTU, cpu_bndu[reg]);\n\n            } else if (prefixes & PREFIX_DATA) {\n\n                /* bndmov -- to reg/mem */\n\n                if (reg >= 4 || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                if (mod == 3) {\n\n                    int reg2 = (modrm & 7) | REX_B(s);\n\n                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {\n\n                        goto illegal_op;\n\n                    }\n\n                    if (s->flags & HF_MPX_IU_MASK) {\n\n                        tcg_gen_mov_i64(cpu_bndl[reg2], cpu_bndl[reg]);\n\n                        tcg_gen_mov_i64(cpu_bndu[reg2], cpu_bndu[reg]);\n\n                    }\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    if (CODE64(s)) {\n\n                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);\n\n                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                    } else {\n\n                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);\n\n                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                    }\n\n                }\n\n            } else if (mod != 3) {\n\n                /* bndstx */\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16\n\n                    || a.base < -1) {\n\n                    goto illegal_op;\n\n                }\n\n                if (a.base >= 0) {\n\n                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_A0, 0);\n\n                }\n\n                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n                if (a.index >= 0) {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n                }\n\n                if (CODE64(s)) {\n\n                    gen_helper_bndstx64(cpu_env, cpu_A0, cpu_T0,\n\n                                        cpu_bndl[reg], cpu_bndu[reg]);\n\n                } else {\n\n                    gen_helper_bndstx32(cpu_env, cpu_A0, cpu_T0,\n\n                                        cpu_bndl[reg], cpu_bndu[reg]);\n\n                }\n\n            }\n\n        }\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x119: case 0x11c ... 0x11f: /* nop (multi byte) */\n\n        modrm = x86_ldub_code(env, s);\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x120: /* mov reg, crN */\n\n    case 0x122: /* mov crN, reg */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            modrm = x86_ldub_code(env, s);\n\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n\n             * AMD documentation (24594.pdf) and testing of\n\n             * intel 386 and 486 processors all show that the mod bits\n\n             * are assumed to be 1's, regardless of actual values.\n\n             */\n\n            rm = (modrm & 7) | REX_B(s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (CODE64(s))\n\n                ot = MO_64;\n\n            else\n\n                ot = MO_32;\n\n            if ((prefixes & PREFIX_LOCK) && (reg == 0) &&\n\n                (s->cpuid_ext3_features & CPUID_EXT3_CR8LEG)) {\n\n                reg = 8;\n\n            }\n\n            switch(reg) {\n\n            case 0:\n\n            case 2:\n\n            case 3:\n\n            case 4:\n\n            case 8:\n\n                gen_update_cc_op(s);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                if (b & 2) {\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_start();\n\n                    }\n\n                    gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                    gen_helper_write_crN(cpu_env, tcg_const_i32(reg),\n\n                                         cpu_T0);\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_end();\n\n                    }\n\n                    gen_jmp_im(s->pc - s->cs_base);\n\n                    gen_eob(s);\n\n                } else {\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_start();\n\n                    }\n\n                    gen_helper_read_crN(cpu_T0, cpu_env, tcg_const_i32(reg));\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_end();\n\n                    }\n\n                }\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n            }\n\n        }\n\n        break;\n\n    case 0x121: /* mov reg, drN */\n\n    case 0x123: /* mov drN, reg */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            modrm = x86_ldub_code(env, s);\n\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n\n             * AMD documentation (24594.pdf) and testing of\n\n             * intel 386 and 486 processors all show that the mod bits\n\n             * are assumed to be 1's, regardless of actual values.\n\n             */\n\n            rm = (modrm & 7) | REX_B(s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (CODE64(s))\n\n                ot = MO_64;\n\n            else\n\n                ot = MO_32;\n\n            if (reg >= 8) {\n\n                goto illegal_op;\n\n            }\n\n            if (b & 2) {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_DR0 + reg);\n\n                gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, reg);\n\n                gen_helper_set_dr(cpu_env, cpu_tmp2_i32, cpu_T0);\n\n                gen_jmp_im(s->pc - s->cs_base);\n\n                gen_eob(s);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_DR0 + reg);\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, reg);\n\n                gen_helper_get_dr(cpu_T0, cpu_env, cpu_tmp2_i32);\n\n                gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n            }\n\n        }\n\n        break;\n\n    case 0x106: /* clts */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n\n            gen_helper_clts(cpu_env);\n\n            /* abort block because static cpu state changed */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    /* MMX/3DNow!/SSE/SSE2/SSE3/SSSE3/SSE4 support */\n\n    case 0x1c3: /* MOVNTI reg, mem */\n\n        if (!(s->cpuid_features & CPUID_SSE2))\n\n            goto illegal_op;\n\n        ot = mo_64_32(dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        /* generate a generic store */\n\n        gen_ldst_modrm(env, s, modrm, ot, reg, 1);\n\n        break;\n\n    case 0x1ae:\n\n        modrm = x86_ldub_code(env, s);\n\n        switch (modrm) {\n\n        CASE_MODRM_MEM_OP(0): /* fxsave */\n\n            if (!(s->cpuid_features & CPUID_FXSR)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_fxsave(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(1): /* fxrstor */\n\n            if (!(s->cpuid_features & CPUID_FXSR)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_fxrstor(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(2): /* ldmxcsr */\n\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->flags & HF_TS_MASK) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL);\n\n            gen_helper_ldmxcsr(cpu_env, cpu_tmp2_i32);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(3): /* stmxcsr */\n\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->flags & HF_TS_MASK) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, mxcsr));\n\n            gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(4): /* xsave */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (prefixes & (PREFIX_LOCK | PREFIX_DATA\n\n                                | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            gen_helper_xsave(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(5): /* xrstor */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (prefixes & (PREFIX_LOCK | PREFIX_DATA\n\n                                | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            gen_helper_xrstor(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n            /* XRSTOR is how MPX is enabled, which changes how\n\n               we translate.  Thus we need to end the TB.  */\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(6): /* xsaveopt / clwb */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* clwb */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLWB)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_nop_modrm(env, s, modrm);\n\n            } else {\n\n                /* xsaveopt */\n\n                if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                    || (s->cpuid_xsave_features & CPUID_XSAVE_XSAVEOPT) == 0\n\n                    || (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_lea_modrm(env, s, modrm);\n\n                tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                      cpu_regs[R_EDX]);\n\n                gen_helper_xsaveopt(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n            }\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(7): /* clflush / clflushopt */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* clflushopt */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLFLUSHOPT)) {\n\n                    goto illegal_op;\n\n                }\n\n            } else {\n\n                /* clflush */\n\n                if ((s->prefix & (PREFIX_REPZ | PREFIX_REPNZ))\n\n                    || !(s->cpuid_features & CPUID_CLFLUSH)) {\n\n                    goto illegal_op;\n\n                }\n\n            }\n\n            gen_nop_modrm(env, s, modrm);\n\n            break;\n\n\n\n        case 0xc0 ... 0xc7: /* rdfsbase (f3 0f ae /0) */\n\n        case 0xc8 ... 0xcf: /* rdgsbase (f3 0f ae /1) */\n\n        case 0xd0 ... 0xd7: /* wrfsbase (f3 0f ae /2) */\n\n        case 0xd8 ... 0xdf: /* wrgsbase (f3 0f ae /3) */\n\n            if (CODE64(s)\n\n                && (prefixes & PREFIX_REPZ)\n\n                && !(prefixes & PREFIX_LOCK)\n\n                && (s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_FSGSBASE)) {\n\n                TCGv base, treg, src, dst;\n\n\n\n                /* Preserve hflags bits by testing CR4 at runtime.  */\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, CR4_FSGSBASE_MASK);\n\n                gen_helper_cr4_testbit(cpu_env, cpu_tmp2_i32);\n\n\n\n                base = cpu_seg_base[modrm & 8 ? R_GS : R_FS];\n\n                treg = cpu_regs[(modrm & 7) | REX_B(s)];\n\n\n\n                if (modrm & 0x10) {\n\n                    /* wr*base */\n\n                    dst = base, src = treg;\n\n                } else {\n\n                    /* rd*base */\n\n                    dst = treg, src = base;\n\n                }\n\n\n\n                if (s->dflag == MO_32) {\n\n                    tcg_gen_ext32u_tl(dst, src);\n\n                } else {\n\n                    tcg_gen_mov_tl(dst, src);\n\n                }\n\n                break;\n\n            }\n\n            goto unknown_op;\n\n\n\n        case 0xf8: /* sfence / pcommit */\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* pcommit */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_PCOMMIT)\n\n                    || (prefixes & PREFIX_LOCK)) {\n\n                    goto illegal_op;\n\n                }\n\n                break;\n\n            }\n\n            /* fallthru */\n\n        case 0xf9 ... 0xff: /* sfence */\n\n            if (!(s->cpuid_features & CPUID_SSE)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_mb(TCG_MO_ST_ST | TCG_BAR_SC);\n\n            break;\n\n        case 0xe8 ... 0xef: /* lfence */\n\n            if (!(s->cpuid_features & CPUID_SSE)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_mb(TCG_MO_LD_LD | TCG_BAR_SC);\n\n            break;\n\n        case 0xf0 ... 0xf7: /* mfence */\n\n            if (!(s->cpuid_features & CPUID_SSE2)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC);\n\n            break;\n\n\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x10d: /* 3DNow! prefetch(w) */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x1aa: /* rsm */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_RSM);\n\n        if (!(s->flags & HF_SMM_MASK))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(s->pc - s->cs_base);\n\n        gen_helper_rsm(cpu_env);\n\n        gen_eob(s);\n\n        break;\n\n    case 0x1b8: /* SSE4.2 popcnt */\n\n        if ((prefixes & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) !=\n\n             PREFIX_REPZ)\n\n            goto illegal_op;\n\n        if (!(s->cpuid_ext_features & CPUID_EXT_POPCNT))\n\n            goto illegal_op;\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        if (s->prefix & PREFIX_DATA) {\n\n            ot = MO_16;\n\n        } else {\n\n            ot = mo_64_32(dflag);\n\n        }\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_extu(ot, cpu_T0);\n\n        tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n        tcg_gen_ctpop_tl(cpu_T0, cpu_T0);\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n\n\n        set_cc_op(s, CC_OP_POPCNT);\n\n        break;\n\n    case 0x10e ... 0x10f:\n\n        /* 3DNow! instructions, ignore prefixes */\n\n        s->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA);\n\n    case 0x110 ... 0x117:\n\n    case 0x128 ... 0x12f:\n\n    case 0x138 ... 0x13a:\n\n    case 0x150 ... 0x179:\n\n    case 0x17c ... 0x17f:\n\n    case 0x1c2:\n\n    case 0x1c4 ... 0x1c6:\n\n    case 0x1d0 ... 0x1fe:\n\n        gen_sse(env, s, b, pc_start, rex_r);\n\n        break;\n\n    default:\n\n        goto unknown_op;\n\n    }\n\n    return s->pc;\n\n illegal_op:\n\n    gen_illegal_opcode(s);\n\n    return s->pc;\n\n unknown_op:\n\n    gen_unknown_opcode(env, s);\n\n    return s->pc;\n\n}\n", "idx": 569, "_split": "test", "_hash": "293f2cf994915f8e64cef67e18085b4f"}
{"project": "qemu", "commit_id": "b93c94f7ec74a577a0f74c724e8d251f01eaf65a", "target": 1, "func": "static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct iscsi_context *iscsi = NULL;\n\n    struct iscsi_url *iscsi_url = NULL;\n\n    struct IscsiTask task;\n\n    char *initiator_name = NULL;\n\n    int ret;\n\n\n\n    if ((BDRV_SECTOR_SIZE % 512) != 0) {\n\n        error_report(\"iSCSI: Invalid BDRV_SECTOR_SIZE. \"\n\n                     \"BDRV_SECTOR_SIZE(%lld) is not a multiple \"\n\n                     \"of 512\", BDRV_SECTOR_SIZE);\n\n        return -EINVAL;\n\n    }\n\n\n\n    iscsi_url = iscsi_parse_full_url(iscsi, filename);\n\n    if (iscsi_url == NULL) {\n\n        error_report(\"Failed to parse URL : %s %s\", filename,\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n\n\n    initiator_name = parse_initiator_name(iscsi_url->target);\n\n\n\n    iscsi = iscsi_create_context(initiator_name);\n\n    if (iscsi == NULL) {\n\n        error_report(\"iSCSI: Failed to create iSCSI context.\");\n\n        ret = -ENOMEM;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {\n\n        error_report(\"iSCSI: Failed to set target name.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_url->user != NULL) {\n\n        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,\n\n                                              iscsi_url->passwd);\n\n        if (ret != 0) {\n\n            error_report(\"Failed to set initiator username and password\");\n\n            ret = -EINVAL;\n\n            goto failed;\n\n        }\n\n    }\n\n\n\n    /* check if we got CHAP username/password via the options */\n\n    if (parse_chap(iscsi, iscsi_url->target) != 0) {\n\n        error_report(\"iSCSI: Failed to set CHAP user/password\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) {\n\n        error_report(\"iSCSI: Failed to set session type to normal.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n\n\n\n    /* check if we got HEADER_DIGEST via the options */\n\n    parse_header_digest(iscsi, iscsi_url->target);\n\n\n\n    task.iscsilun = iscsilun;\n\n    task.status = 0;\n\n    task.complete = 0;\n\n    task.bs = bs;\n\n\n\n    iscsilun->iscsi = iscsi;\n\n    iscsilun->lun   = iscsi_url->lun;\n\n\n\n    if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun,\n\n                                 iscsi_connect_cb, &task)\n\n        != 0) {\n\n        error_report(\"iSCSI: Failed to start async connect.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    while (!task.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_aio_wait();\n\n    }\n\n    if (task.status != 0) {\n\n        error_report(\"iSCSI: Failed to connect to LUN : %s\",\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n\n\n    /* Medium changer or tape. We dont have any emulation for this so this must\n\n     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try\n\n     * to read from the device to guess the image format.\n\n     */\n\n    if (iscsilun->type == TYPE_MEDIUM_CHANGER ||\n\n        iscsilun->type == TYPE_TAPE) {\n\n        bs->sg = 1;\n\n    }\n\n\n\n    return 0;\n\n\n\nfailed:\n\n    if (initiator_name != NULL) {\n\n        g_free(initiator_name);\n\n    }\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n    if (iscsi != NULL) {\n\n        iscsi_destroy_context(iscsi);\n\n    }\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n    return ret;\n\n}\n", "idx": 572, "_split": "test", "_hash": "fbd04c11f3349b9384e310098bbdc1dd"}
{"project": "qemu", "commit_id": "b9f7c377df4f04e9119cb0e917438dd37ef34029", "target": 1, "func": "static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,\n\n                                           const void *pkt_data,\n\n                                           size_t pkt_len)\n\n{\n\n    struct virtio_net_hdr *vhdr;\n\n    bool isip4, isip6, istcp, isudp;\n\n    uint8_t *data;\n\n    int len;\n\n\n\n    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {\n\n        return;\n\n    }\n\n\n\n    vhdr = vmxnet_rx_pkt_get_vhdr(pkt);\n\n    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);\n\n    if (!(isip4 || isip6) || !(istcp || isudp)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet3_dump_virt_hdr(vhdr);\n\n\n\n    /* Validate packet len: csum_start + scum_offset + length of csum field */\n\n    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {\n\n        VMW_PKPRN(\"packet len:%d < csum_start(%d) + csum_offset(%d) + 2, \"\n\n                  \"cannot calculate checksum\",\n\n                  len, vhdr->csum_start, vhdr->csum_offset);\n\n        return;\n\n    }\n\n\n\n    data = (uint8_t *)pkt_data + vhdr->csum_start;\n\n    len = pkt_len - vhdr->csum_start;\n\n    /* Put the checksum obtained into the packet */\n\n    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));\n\n\n\n    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\n    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;\n\n}\n", "idx": 573, "_split": "test", "_hash": "de54969f9ad44fcba927c08ed9a43447"}
{"project": "qemu", "commit_id": "635db18f68ded6abec11cd4cf64ebc15c1c6b190", "target": 1, "func": "CommandInfoList *qmp_query_commands(Error **errp)\n\n{\n\n    CommandInfoList *list = NULL;\n\n\n\n    qmp_for_each_command(&qmp_commands, query_commands_cb, &list);\n\n\n\n    return list;\n\n}\n", "idx": 574, "_split": "test", "_hash": "0b2574903dac116979901fd4cefe448a"}
{"project": "qemu", "commit_id": "71b58b82dac1e1dc5e08a005a14bbcafecbd9e2a", "target": 0, "func": "static int write_f(int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;\n\n    int c, cnt;\n\n    char *buf;\n\n    int64_t offset;\n\n    int count;\n\n    /* Some compilers get confused and warn if this is not initialized.  */\n\n    int total = 0;\n\n    int pattern = 0xcd;\n\n\n\n    while ((c = getopt(argc, argv, \"bCpP:q\")) != EOF) {\n\n        switch (c) {\n\n        case 'b':\n\n            bflag = 1;\n\n            break;\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'p':\n\n            pflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        default:\n\n            return command_usage(&write_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind != argc - 2) {\n\n        return command_usage(&write_cmd);\n\n    }\n\n\n\n    if (bflag && pflag) {\n\n        printf(\"-b and -p cannot be specified at the same time\\n\");\n\n        return 0;\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    optind++;\n\n    count = cvtnum(argv[optind]);\n\n    if (count < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    if (!pflag) {\n\n        if (offset & 0x1ff) {\n\n            printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n                   offset);\n\n            return 0;\n\n        }\n\n\n\n        if (count & 0x1ff) {\n\n            printf(\"count %d is not sector aligned\\n\",\n\n                   count);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    buf = qemu_io_alloc(count, pattern);\n\n\n\n    gettimeofday(&t1, NULL);\n\n    if (pflag) {\n\n        cnt = do_pwrite(buf, offset, count, &total);\n\n    } else if (bflag) {\n\n        cnt = do_save_vmstate(buf, offset, count, &total);\n\n    } else {\n\n        cnt = do_write(buf, offset, count, &total);\n\n    }\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"write failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"wrote\", &t2, offset, count, total, cnt, Cflag);\n\n\n\nout:\n\n    qemu_io_free(buf);\n\n\n\n    return 0;\n\n}\n", "idx": 599, "_split": "test", "_hash": "b1b227d90b33358155e169a11c38756d"}
{"project": "qemu", "commit_id": "e95e9b88ba5f4a6c17f4d0c3a3a6bf3f648bb328", "target": 1, "func": "static void do_interrupt64(CPUX86State *env, int intno, int is_int,\n\n                           int error_code, target_ulong next_eip, int is_hw)\n\n{\n\n    SegmentCache *dt;\n\n    target_ulong ptr;\n\n    int type, dpl, selector, cpl, ist;\n\n    int has_error_code, new_stack;\n\n    uint32_t e1, e2, e3, ss;\n\n    target_ulong old_eip, esp, offset;\n\n\n\n    has_error_code = 0;\n\n    if (!is_int && !is_hw) {\n\n        has_error_code = exception_has_error_code(intno);\n\n    }\n\n    if (is_int) {\n\n        old_eip = next_eip;\n\n    } else {\n\n        old_eip = env->eip;\n\n    }\n\n\n\n    dt = &env->idt;\n\n    if (intno * 16 + 15 > dt->limit) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n    }\n\n    ptr = dt->base + intno * 16;\n\n    e1 = cpu_ldl_kernel(env, ptr);\n\n    e2 = cpu_ldl_kernel(env, ptr + 4);\n\n    e3 = cpu_ldl_kernel(env, ptr + 8);\n\n    /* check gate type */\n\n    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;\n\n    switch (type) {\n\n    case 14: /* 386 interrupt gate */\n\n    case 15: /* 386 trap gate */\n\n        break;\n\n    default:\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n        break;\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    /* check privilege if software int */\n\n    if (is_int && dpl < cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n    }\n\n    /* check valid bit */\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, intno * 16 + 2);\n\n    }\n\n    selector = e1 >> 16;\n\n    offset = ((target_ulong)e3 << 32) | (e2 & 0xffff0000) | (e1 & 0x0000ffff);\n\n    ist = e2 & 7;\n\n    if ((selector & 0xfffc) == 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n\n\n    if (load_segment(env, &e1, &e2, selector) != 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    if (dpl > cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_L_MASK) || (e2 & DESC_B_MASK)) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if ((!(e2 & DESC_C_MASK) && dpl < cpl) || ist != 0) {\n\n        /* to inner privilege */\n\n        new_stack = 1;\n\n        esp = get_rsp_from_tss(env, ist != 0 ? ist + 3 : dpl);\n\n        ss = 0;\n\n    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {\n\n        /* to same privilege */\n\n        if (env->eflags & VM_MASK) {\n\n            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        }\n\n        new_stack = 0;\n\n        esp = env->regs[R_ESP];\n\n        dpl = cpl;\n\n    } else {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        new_stack = 0; /* avoid warning */\n\n        esp = 0; /* avoid warning */\n\n    }\n\n    esp &= ~0xfLL; /* align stack */\n\n\n\n    PUSHQ(esp, env->segs[R_SS].selector);\n\n    PUSHQ(esp, env->regs[R_ESP]);\n\n    PUSHQ(esp, cpu_compute_eflags(env));\n\n    PUSHQ(esp, env->segs[R_CS].selector);\n\n    PUSHQ(esp, old_eip);\n\n    if (has_error_code) {\n\n        PUSHQ(esp, error_code);\n\n    }\n\n\n\n    /* interrupt gate clear IF mask */\n\n    if ((type & 1) == 0) {\n\n        env->eflags &= ~IF_MASK;\n\n    }\n\n    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);\n\n\n\n    if (new_stack) {\n\n        ss = 0 | dpl;\n\n        cpu_x86_load_seg_cache(env, R_SS, ss, 0, 0, 0);\n\n    }\n\n    env->regs[R_ESP] = esp;\n\n\n\n    selector = (selector & ~3) | dpl;\n\n    cpu_x86_load_seg_cache(env, R_CS, selector,\n\n                   get_seg_base(e1, e2),\n\n                   get_seg_limit(e1, e2),\n\n                   e2);\n\n    env->eip = offset;\n\n}\n", "idx": 669, "_split": "test", "_hash": "b923508152c3b8e3869224a95606bcc0"}
{"project": "qemu", "commit_id": "6f2d8978728c48ca46f5c01835438508aace5c64", "target": 1, "func": "void do_POWER_maskg (void)\n\n{\n\n    uint32_t ret;\n\n\n\n    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {\n\n        ret = -1;\n\n    } else {\n\n        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^\n\n            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);\n\n        if ((uint32_t)T0 > (uint32_t)T1)\n\n            ret = ~ret;\n\n    }\n\n    T0 = ret;\n\n}\n", "idx": 686, "_split": "test", "_hash": "94b0552eb5ac38237c3d69d257c12373"}
{"project": "qemu", "commit_id": "f06ee3d4aa547df8d7d2317b2b6db7a88c1f3744", "target": 1, "func": "static void qed_aio_read_data(void *opaque, int ret,\n\n                              uint64_t offset, size_t len)\n\n{\n\n    QEDAIOCB *acb = opaque;\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n    BlockDriverState *bs = acb->common.bs;\n\n\n\n    /* Adjust offset into cluster */\n\n    offset += qed_offset_into_cluster(s, acb->cur_pos);\n\n\n\n    trace_qed_aio_read_data(s, acb, ret, offset, len);\n\n\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);\n\n\n\n    /* Handle zero cluster and backing file reads */\n\n    if (ret == QED_CLUSTER_ZERO) {\n\n        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);\n\n        qed_aio_next_io(acb, 0);\n\n        return;\n\n    } else if (ret != QED_CLUSTER_FOUND) {\n\n        qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,\n\n                              qed_aio_next_io, acb);\n\n        return;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,\n\n                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,\n\n                   qed_aio_next_io, acb);\n\n    return;\n\n\n\nerr:\n\n    qed_aio_complete(acb, ret);\n\n}\n", "idx": 707, "_split": "test", "_hash": "003a66d591032743da36ff22bb1ee472"}
{"project": "qemu", "commit_id": "b6c147622d31272f9728da9ec16d146bf8c45a74", "target": 1, "func": "int qcow2_update_header(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowHeader *header;\n\n    char *buf;\n\n    size_t buflen = s->cluster_size;\n\n    int ret;\n\n    uint64_t total_size;\n\n    uint32_t refcount_table_clusters;\n\n    size_t header_length;\n\n    Qcow2UnknownHeaderExtension *uext;\n\n\n\n    buf = qemu_blockalign(bs, buflen);\n\n\n\n    /* Header structure */\n\n    header = (QCowHeader*) buf;\n\n\n\n    if (buflen < sizeof(*header)) {\n\n        ret = -ENOSPC;\n\n        goto fail;\n\n    }\n\n\n\n    header_length = sizeof(*header) + s->unknown_header_fields_size;\n\n    total_size = bs->total_sectors * BDRV_SECTOR_SIZE;\n\n    refcount_table_clusters = s->refcount_table_size >> (s->cluster_bits - 3);\n\n\n\n    *header = (QCowHeader) {\n\n        /* Version 2 fields */\n\n        .magic                  = cpu_to_be32(QCOW_MAGIC),\n\n        .version                = cpu_to_be32(s->qcow_version),\n\n        .backing_file_offset    = 0,\n\n        .backing_file_size      = 0,\n\n        .cluster_bits           = cpu_to_be32(s->cluster_bits),\n\n        .size                   = cpu_to_be64(total_size),\n\n        .crypt_method           = cpu_to_be32(s->crypt_method_header),\n\n        .l1_size                = cpu_to_be32(s->l1_size),\n\n        .l1_table_offset        = cpu_to_be64(s->l1_table_offset),\n\n        .refcount_table_offset  = cpu_to_be64(s->refcount_table_offset),\n\n        .refcount_table_clusters = cpu_to_be32(refcount_table_clusters),\n\n        .nb_snapshots           = cpu_to_be32(s->nb_snapshots),\n\n        .snapshots_offset       = cpu_to_be64(s->snapshots_offset),\n\n\n\n        /* Version 3 fields */\n\n        .incompatible_features  = cpu_to_be64(s->incompatible_features),\n\n        .compatible_features    = cpu_to_be64(s->compatible_features),\n\n        .autoclear_features     = cpu_to_be64(s->autoclear_features),\n\n        .refcount_order         = cpu_to_be32(3 + REFCOUNT_SHIFT),\n\n        .header_length          = cpu_to_be32(header_length),\n\n    };\n\n\n\n    /* For older versions, write a shorter header */\n\n    switch (s->qcow_version) {\n\n    case 2:\n\n        ret = offsetof(QCowHeader, incompatible_features);\n\n        break;\n\n    case 3:\n\n        ret = sizeof(*header);\n\n        break;\n\n    default:\n\n        return -EINVAL;\n\n    }\n\n\n\n    buf += ret;\n\n    buflen -= ret;\n\n    memset(buf, 0, buflen);\n\n\n\n    /* Preserve any unknown field in the header */\n\n    if (s->unknown_header_fields_size) {\n\n        if (buflen < s->unknown_header_fields_size) {\n\n            ret = -ENOSPC;\n\n            goto fail;\n\n        }\n\n\n\n        memcpy(buf, s->unknown_header_fields, s->unknown_header_fields_size);\n\n        buf += s->unknown_header_fields_size;\n\n        buflen -= s->unknown_header_fields_size;\n\n    }\n\n\n\n    /* Backing file format header extension */\n\n    if (*bs->backing_format) {\n\n        ret = header_ext_add(buf, QCOW2_EXT_MAGIC_BACKING_FORMAT,\n\n                             bs->backing_format, strlen(bs->backing_format),\n\n                             buflen);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        buf += ret;\n\n        buflen -= ret;\n\n    }\n\n\n\n    /* Feature table */\n\n    Qcow2Feature features[] = {\n\n        /* no feature defined yet */\n\n    };\n\n\n\n    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE,\n\n                         features, sizeof(features), buflen);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    buf += ret;\n\n    buflen -= ret;\n\n\n\n    /* Keep unknown header extensions */\n\n    QLIST_FOREACH(uext, &s->unknown_header_ext, next) {\n\n        ret = header_ext_add(buf, uext->magic, uext->data, uext->len, buflen);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        buf += ret;\n\n        buflen -= ret;\n\n    }\n\n\n\n    /* End of header extensions */\n\n    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_END, NULL, 0, buflen);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    buf += ret;\n\n    buflen -= ret;\n\n\n\n    /* Backing file name */\n\n    if (*bs->backing_file) {\n\n        size_t backing_file_len = strlen(bs->backing_file);\n\n\n\n        if (buflen < backing_file_len) {\n\n            ret = -ENOSPC;\n\n            goto fail;\n\n        }\n\n\n\n        strncpy(buf, bs->backing_file, buflen);\n\n\n\n        header->backing_file_offset = cpu_to_be64(buf - ((char*) header));\n\n        header->backing_file_size   = cpu_to_be32(backing_file_len);\n\n    }\n\n\n\n    /* Write the new header */\n\n    ret = bdrv_pwrite(bs->file, 0, header, s->cluster_size);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n    qemu_vfree(header);\n\n    return ret;\n\n}\n", "idx": 710, "_split": "test", "_hash": "8a36c0210f7af4f8e9771927271d7463"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void tcp_start_incoming_migration(const char *host_port, Error **errp)\n\n{\n\n    int s;\n\n\n\n    s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp);\n\n    if (s < 0) {\n\n        return;\n\n    }\n\n\n\n    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,\n\n                         (void *)(intptr_t)s);\n\n}\n", "idx": 729, "_split": "test", "_hash": "ac9304cb34a389a7d211c9936463bdef"}
{"project": "qemu", "commit_id": "d049bde69d8ab3dfa4edeee48896088ae9feb693", "target": 1, "func": "static int spapr_populate_pci_child_dt(PCIDevice *dev, void *fdt, int offset,\n\n                                       sPAPRPHBState *sphb)\n\n{\n\n    ResourceProps rp;\n\n    bool is_bridge = false;\n\n    int pci_status, err;\n\n    char *buf = NULL;\n\n    uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev);\n\n    uint32_t ccode = pci_default_read_config(dev, PCI_CLASS_PROG, 3);\n\n    uint32_t max_msi, max_msix;\n\n\n\n    if (pci_default_read_config(dev, PCI_HEADER_TYPE, 1) ==\n\n        PCI_HEADER_TYPE_BRIDGE) {\n\n        is_bridge = true;\n\n    }\n\n\n\n    /* in accordance with PAPR+ v2.7 13.6.3, Table 181 */\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"vendor-id\",\n\n                          pci_default_read_config(dev, PCI_VENDOR_ID, 2)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"device-id\",\n\n                          pci_default_read_config(dev, PCI_DEVICE_ID, 2)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"revision-id\",\n\n                          pci_default_read_config(dev, PCI_REVISION_ID, 1)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"class-code\", ccode));\n\n    if (pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"interrupts\",\n\n                 pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)));\n\n    }\n\n\n\n    if (!is_bridge) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"min-grant\",\n\n            pci_default_read_config(dev, PCI_MIN_GNT, 1)));\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"max-latency\",\n\n            pci_default_read_config(dev, PCI_MAX_LAT, 1)));\n\n    }\n\n\n\n    if (pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"subsystem-id\",\n\n                 pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)));\n\n    }\n\n\n\n    if (pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"subsystem-vendor-id\",\n\n                 pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)));\n\n    }\n\n\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"cache-line-size\",\n\n        pci_default_read_config(dev, PCI_CACHE_LINE_SIZE, 1)));\n\n\n\n    /* the following fdt cells are masked off the pci status register */\n\n    pci_status = pci_default_read_config(dev, PCI_STATUS, 2);\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"devsel-speed\",\n\n                          PCI_STATUS_DEVSEL_MASK & pci_status));\n\n\n\n    if (pci_status & PCI_STATUS_FAST_BACK) {\n\n        _FDT(fdt_setprop(fdt, offset, \"fast-back-to-back\", NULL, 0));\n\n    }\n\n    if (pci_status & PCI_STATUS_66MHZ) {\n\n        _FDT(fdt_setprop(fdt, offset, \"66mhz-capable\", NULL, 0));\n\n    }\n\n    if (pci_status & PCI_STATUS_UDF) {\n\n        _FDT(fdt_setprop(fdt, offset, \"udf-supported\", NULL, 0));\n\n    }\n\n\n\n    _FDT(fdt_setprop_string(fdt, offset, \"name\",\n\n                            pci_find_device_name((ccode >> 16) & 0xff,\n\n                                                 (ccode >> 8) & 0xff,\n\n                                                 ccode & 0xff)));\n\n    buf = spapr_phb_get_loc_code(sphb, dev);\n\n    if (!buf) {\n\n        error_report(\"Failed setting the ibm,loc-code\");\n\n        return -1;\n\n    }\n\n\n\n    err = fdt_setprop_string(fdt, offset, \"ibm,loc-code\", buf);\n\n    g_free(buf);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n\n\n    if (drc_index) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index));\n\n    }\n\n\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"#address-cells\",\n\n                          RESOURCE_CELLS_ADDRESS));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"#size-cells\",\n\n                          RESOURCE_CELLS_SIZE));\n\n\n\n    max_msi = msi_nr_vectors_allocated(dev);\n\n    if (max_msi) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,req#msi\", max_msi));\n\n    }\n\n    max_msix = dev->msix_entries_nr;\n\n    if (max_msix) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,req#msi-x\", max_msix));\n\n    }\n\n\n\n    populate_resource_props(dev, &rp);\n\n    _FDT(fdt_setprop(fdt, offset, \"reg\", (uint8_t *)rp.reg, rp.reg_len));\n\n    _FDT(fdt_setprop(fdt, offset, \"assigned-addresses\",\n\n                     (uint8_t *)rp.assigned, rp.assigned_len));\n\n\n\n    if (sphb->pcie_ecs && pci_is_express(dev)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,pci-config-space-type\", 0x1));\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 740, "_split": "test", "_hash": "196ae62f2b8f12251d24f7a335385e37"}
{"project": "qemu", "commit_id": "e50d7607f1800c9f9c576229c6119e4c82f456d6", "target": 1, "func": "static coroutine_fn int sd_co_writev(BlockDriverState *bs, int64_t sector_num,\n\n                        int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    SheepdogAIOCB *acb;\n\n    int ret;\n\n\n\n    if (bs->growable && sector_num + nb_sectors > bs->total_sectors) {\n\n        ret = sd_truncate(bs, (sector_num + nb_sectors) * BDRV_SECTOR_SIZE);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        bs->total_sectors = sector_num + nb_sectors;\n\n    }\n\n\n\n    acb = sd_aio_setup(bs, qiov, sector_num, nb_sectors);\n\n    acb->aio_done_func = sd_write_done;\n\n    acb->aiocb_type = AIOCB_WRITE_UDATA;\n\n\n\n    ret = sd_co_rw_vector(acb);\n\n    if (ret <= 0) {\n\n        qemu_aio_release(acb);\n\n        return ret;\n\n    }\n\n\n\n    qemu_coroutine_yield();\n\n\n\n    return acb->ret;\n\n}\n", "idx": 781, "_split": "test", "_hash": "f52eb2c2c161d1b558b5f53c22663e69"}
{"project": "qemu", "commit_id": "d20a580bc0eac9d489884f6d2ed28105880532b6", "target": 0, "func": "static void sdl_send_mouse_event(int dx, int dy, int x, int y, int state)\n\n{\n\n    static uint32_t bmap[INPUT_BUTTON__MAX] = {\n\n        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),\n\n        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),\n\n        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),\n\n        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),\n\n        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),\n\n    };\n\n    static uint32_t prev_state;\n\n\n\n    if (prev_state != state) {\n\n        qemu_input_update_buttons(dcl->con, bmap, prev_state, state);\n\n        prev_state = state;\n\n    }\n\n\n\n    if (qemu_input_is_absolute()) {\n\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,\n\n                             real_screen->w);\n\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,\n\n                             real_screen->h);\n\n    } else {\n\n        if (guest_cursor) {\n\n            x -= guest_x;\n\n            y -= guest_y;\n\n            guest_x += x;\n\n            guest_y += y;\n\n            dx = x;\n\n            dy = y;\n\n        }\n\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);\n\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);\n\n    }\n\n    qemu_input_event_sync();\n\n}\n", "idx": 794, "_split": "test", "_hash": "27e3dc07b8e9b5039f3f643b7576adda"}
{"project": "qemu", "commit_id": "4f2d3d705c1ae7dce29254e2c4645c84e77a74d4", "target": 0, "func": "static void device_initfn(Object *obj)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop;\n\n\n\n    if (qdev_hotplug) {\n\n        dev->hotplugged = 1;\n\n        qdev_hot_added = true;\n\n    }\n\n\n\n    dev->instance_id_alias = -1;\n\n    dev->state = DEV_STATE_CREATED;\n\n\n\n    qdev_prop_set_defaults(dev, qdev_get_props(dev));\n\n    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {\n\n        qdev_property_add_legacy(dev, prop, NULL);\n\n        qdev_property_add_static(dev, prop, NULL);\n\n    }\n\n\n\n    object_property_add_str(OBJECT(dev), \"type\", qdev_get_type, NULL, NULL);\n\n}\n", "idx": 797, "_split": "test", "_hash": "74e971634ad4a74d449d6cfb485ef5a3"}
{"project": "qemu", "commit_id": "ef8489d45927a6d35b214365e4b39ab311b48f2a", "target": 1, "func": "static void scsi_write_data(SCSIRequest *req)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    /* The request is used as the AIO opaque value, so add a ref.  */\n\n    scsi_req_ref(&r->req);\n\n    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {\n\n        DPRINTF(\"Data transfer direction invalid\\n\");\n\n        scsi_write_complete(r, -EINVAL);\n\n        return;\n\n    }\n\n\n\n    if (!r->req.sg && !r->qiov.size) {\n\n        /* Called for the first time.  Ask the driver to send us more data.  */\n\n        r->started = true;\n\n        scsi_write_complete(r, 0);\n\n        return;\n\n    }\n\n    if (s->tray_open) {\n\n        scsi_write_complete(r, -ENOMEDIUM);\n\n        return;\n\n    }\n\n\n\n    if (r->req.cmd.buf[0] == VERIFY_10 || r->req.cmd.buf[0] == VERIFY_12 ||\n\n        r->req.cmd.buf[0] == VERIFY_16) {\n\n        if (r->req.sg) {\n\n            scsi_dma_complete(r, 0);\n\n        } else {\n\n            scsi_write_complete(r, 0);\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (r->req.sg) {\n\n        dma_acct_start(s->qdev.conf.bs, &r->acct, r->req.sg, BDRV_ACCT_WRITE);\n\n        r->req.resid -= r->req.sg->size;\n\n        r->req.aiocb = dma_bdrv_write(s->qdev.conf.bs, r->req.sg, r->sector,\n\n                                      scsi_dma_complete, r);\n\n    } else {\n\n        n = r->qiov.size / 512;\n\n        bdrv_acct_start(s->qdev.conf.bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n\n        r->req.aiocb = bdrv_aio_writev(s->qdev.conf.bs, r->sector, &r->qiov, n,\n\n                                       scsi_write_complete, r);\n\n    }\n\n}\n", "idx": 837, "_split": "test", "_hash": "f1f2a562d6971f4e30e765aaa497a0a9"}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)\n\n{\n\n    int sa, sb;\n\n    sa = ((int64_t)*phigh < 0);\n\n    if (sa)\n\n        neg128(plow, phigh);\n\n    sb = (b < 0);\n\n    if (sb)\n\n        b = -b;\n\n    div64(plow, phigh, b);\n\n    if (sa ^ sb)\n\n        *plow = - *plow;\n\n    if (sa)\n\n        *phigh = - *phigh;\n\n}\n", "idx": 848, "_split": "test", "_hash": "79aa6b5df6751c73eb56339a61823275"}
{"project": "qemu", "commit_id": "1dbfd7892b66c757fdf67f346be40233adbad80e", "target": 1, "func": "void bios_linker_loader_alloc(GArray *linker,\n\n                              const char *file,\n\n                              uint32_t alloc_align,\n\n                              bool alloc_fseg)\n\n{\n\n    BiosLinkerLoaderEntry entry;\n\n\n\n    assert(!(alloc_align & (alloc_align - 1)));\n\n\n\n    memset(&entry, 0, sizeof entry);\n\n    strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1);\n\n    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ALLOCATE);\n\n    entry.alloc.align = cpu_to_le32(alloc_align);\n\n    entry.alloc.zone = cpu_to_le32(alloc_fseg ?\n\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG :\n\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH);\n\n\n\n    /* Alloc entries must come first, so prepend them */\n\n    g_array_prepend_vals(linker, &entry, sizeof entry);\n\n}\n", "idx": 855, "_split": "test", "_hash": "6bcc5b59c04ef69068157ea31794fe4f"}
{"project": "qemu", "commit_id": "95eaa78537c734fa3cb3373d47ba8c0099a36ff0", "target": 1, "func": "static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    /* We don't actually refresh here, but just return data queried in\n\n     * iscsi_open(): iscsi targets don't change their limits. */\n\n\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;\n\n\n\n    bs->bl.request_alignment = iscsilun->block_size;\n\n\n\n    if (iscsilun->bl.max_xfer_len) {\n\n        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);\n\n    }\n\n\n\n    if (max_xfer_len * iscsilun->block_size < INT_MAX) {\n\n        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->lbp.lbpu) {\n\n        if (iscsilun->bl.max_unmap < 0xffffffff / iscsilun->block_size) {\n\n            bs->bl.max_pdiscard =\n\n                iscsilun->bl.max_unmap * iscsilun->block_size;\n\n        }\n\n        bs->bl.pdiscard_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pdiscard_alignment = iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {\n\n        bs->bl.max_pwrite_zeroes =\n\n            iscsilun->bl.max_ws_len * iscsilun->block_size;\n\n    }\n\n    if (iscsilun->lbp.lbpws) {\n\n        bs->bl.pwrite_zeroes_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;\n\n    }\n\n    if (iscsilun->bl.opt_xfer_len &&\n\n        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {\n\n        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *\n\n                                        iscsilun->block_size);\n\n    }\n\n}\n", "idx": 860, "_split": "test", "_hash": "c7b2064ce7e1e801c09be2bfd0e5611a"}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void tap_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    TAPState *s = opaque;\n\n    int ret;\n\n    for(;;) {\n\n        ret = write(s->fd, buf, size);\n\n        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 883, "_split": "test", "_hash": "fd085556a26ff8dfd0579501c6000feb"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void scsi_disk_realize(SCSIDevice *dev, Error **errp)\n\n{\n\n    DriveInfo *dinfo;\n\n    Error *local_err = NULL;\n\n\n\n    if (!dev->conf.bs) {\n\n        scsi_realize(dev, &local_err);\n\n        assert(local_err);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    dinfo = drive_get_by_blockdev(dev->conf.bs);\n\n    if (dinfo->media_cd) {\n\n        scsi_cd_realize(dev, errp);\n\n    } else {\n\n        scsi_hd_realize(dev, errp);\n\n    }\n\n}\n", "idx": 886, "_split": "test", "_hash": "081b5aa1b93fdd8d695a189d9d2002a7"}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)\n\n{\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    int ret, fd;\n\n    uint32_t new_vid;\n\n    SheepdogInode *inode;\n\n    unsigned int datalen;\n\n\n\n    dprintf(\"sn_info: name %s id_str %s s: name %s vm_state_size %\" PRId64 \" \"\n\n            \"is_snapshot %d\\n\", sn_info->name, sn_info->id_str,\n\n            s->name, sn_info->vm_state_size, s->is_snapshot);\n\n\n\n    if (s->is_snapshot) {\n\n        error_report(\"You can't create a snapshot of a snapshot VDI, \"\n\n                     \"%s (%\" PRIu32 \").\", s->name, s->inode.vdi_id);\n\n\n\n        return -EINVAL;\n\n    }\n\n\n\n    dprintf(\"%s %s\\n\", sn_info->name, sn_info->id_str);\n\n\n\n    s->inode.vm_state_size = sn_info->vm_state_size;\n\n    s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;\n\n    /* It appears that inode.tag does not require a NUL terminator,\n\n     * which means this use of strncpy is ok.\n\n     */\n\n    strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));\n\n    /* we don't need to update entire object */\n\n    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);\n\n\n\n    /* refresh inode. */\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        ret = fd;\n\n        goto cleanup;\n\n    }\n\n\n\n    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n\n                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);\n\n    if (ret < 0) {\n\n        error_report(\"failed to write snapshot's inode.\");\n\n        goto cleanup;\n\n    }\n\n\n\n    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1,\n\n                       s->addr, s->port);\n\n    if (ret < 0) {\n\n        error_report(\"failed to create inode for snapshot. %s\",\n\n                     strerror(errno));\n\n        goto cleanup;\n\n    }\n\n\n\n    inode = (SheepdogInode *)g_malloc(datalen);\n\n\n\n    ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),\n\n                      s->inode.nr_copies, datalen, 0, s->cache_enabled);\n\n\n\n    if (ret < 0) {\n\n        error_report(\"failed to read new inode info. %s\", strerror(errno));\n\n        goto cleanup;\n\n    }\n\n\n\n    memcpy(&s->inode, inode, datalen);\n\n    dprintf(\"s->inode: name %s snap_id %x oid %x\\n\",\n\n            s->inode.name, s->inode.snap_id, s->inode.vdi_id);\n\n\n\ncleanup:\n\n    closesocket(fd);\n\n    return ret;\n\n}\n", "idx": 899, "_split": "test", "_hash": "52fb8a0fdbc7bc91e872aa715ea76324"}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static int vnc_display_listen(VncDisplay *vd,\n\n                              SocketAddress **saddr,\n\n                              size_t nsaddr,\n\n                              SocketAddress **wsaddr,\n\n                              size_t nwsaddr,\n\n                              Error **errp)\n\n{\n\n    size_t i;\n\n\n\n    for (i = 0; i < nsaddr; i++) {\n\n        if (vnc_display_listen_addr(vd, saddr[i],\n\n                                    \"vnc-listen\",\n\n                                    &vd->lsock,\n\n                                    &vd->lsock_tag,\n\n                                    &vd->nlsock,\n\n                                    errp) < 0) {\n\n            return -1;\n\n        }\n\n    }\n\n    for (i = 0; i < nwsaddr; i++) {\n\n        if (vnc_display_listen_addr(vd, wsaddr[i],\n\n                                    \"vnc-ws-listen\",\n\n                                    &vd->lwebsock,\n\n                                    &vd->lwebsock_tag,\n\n                                    &vd->nlwebsock,\n\n                                    errp) < 0) {\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 906, "_split": "test", "_hash": "fbb48f2f132320805e2495213a9b067b"}
{"project": "qemu", "commit_id": "1171ae9a5b132dc631728ff17688d05ed4534181", "target": 0, "func": "static char *enumerate_cpus(unsigned long *cpus, int max_cpus)\n\n{\n\n    int cpu;\n\n    bool first = true;\n\n    GString *s = g_string_new(NULL);\n\n\n\n    for (cpu = find_first_bit(cpus, max_cpus);\n\n        cpu < max_cpus;\n\n        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {\n\n        g_string_append_printf(s, \"%s%d\", first ? \"\" : \" \", cpu);\n\n        first = false;\n\n    }\n\n    return g_string_free(s, FALSE);\n\n}\n", "idx": 913, "_split": "test", "_hash": "233dab8844d8f0e33563f8ff2a5cc705"}
{"project": "qemu", "commit_id": "8ad9fa5d8be7fd04e723020088eca664971eb363", "target": 1, "func": "MigrationState *exec_start_outgoing_migration(const char *command,\n\n                                             int64_t bandwidth_limit,\n\n                                             int async)\n\n{\n\n    FdMigrationState *s;\n\n    FILE *f;\n\n\n\n    s = qemu_mallocz(sizeof(*s));\n\n    if (s == NULL) {\n\n        dprintf(\"Unable to allocate FdMigrationState\\n\");\n\n        goto err;\n\n    }\n\n\n\n    f = popen(command, \"w\");\n\n    if (f == NULL) {\n\n        dprintf(\"Unable to popen exec target\\n\");\n\n        goto err_after_alloc;\n\n    }\n\n\n\n    s->fd = fileno(f);\n\n    if (s->fd == -1) {\n\n        dprintf(\"Unable to retrieve file descriptor for popen'd handle\\n\");\n\n        goto err_after_open;\n\n    }\n\n\n\n    if (fcntl(s->fd, F_SETFD, O_NONBLOCK) == -1) {\n\n        dprintf(\"Unable to set nonblocking mode on file descriptor\\n\");\n\n        goto err_after_open;\n\n    }\n\n\n\n    s->opaque = qemu_popen(f, \"w\");\n\n\n\n\n    s->get_error = file_errno;\n\n    s->write = file_write;\n\n    s->mig_state.cancel = migrate_fd_cancel;\n\n    s->mig_state.get_status = migrate_fd_get_status;\n\n    s->mig_state.release = migrate_fd_release;\n\n\n\n    s->state = MIG_STATE_ACTIVE;\n\n    s->detach = !async;\n\n    s->bandwidth_limit = bandwidth_limit;\n\n\n\n    if (s->detach == 1) {\n\n        dprintf(\"detaching from monitor\\n\");\n\n        monitor_suspend();\n\n        s->detach = 2;\n\n    }\n\n\n\n    migrate_fd_connect(s);\n\n    return &s->mig_state;\n\n\n\nerr_after_open:\n\n    pclose(f);\n\nerr_after_alloc:\n\n    qemu_free(s);\n\nerr:\n\n    return NULL;\n\n}", "idx": 921, "_split": "test", "_hash": "f11b715c83021ab492c7606b75e9236d"}
{"project": "qemu", "commit_id": "a9f8ad8f2acdb2398da5d32a5efc19cb0196d79f", "target": 1, "func": "static void register_core_rtas(void)\n\n{\n\n    spapr_rtas_register(\"display-character\", rtas_display_character);\n\n    spapr_rtas_register(\"get-time-of-day\", rtas_get_time_of_day);\n\n    spapr_rtas_register(\"power-off\", rtas_power_off);\n\n\n\n\n}", "idx": 924, "_split": "test", "_hash": "e79907c5dc46b9b76361a6808f0af3cd"}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,\n\n                              target_ulong opcode, target_ulong *args)\n\n{\n\n    target_ulong liobn = args[0];\n\n    target_ulong ioba = args[1];\n\n    target_ulong tce = args[2];\n\n    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);\n\n    VIOsPAPR_RTCE *rtce;\n\n\n\n    if (!dev) {\n\n        hcall_dprintf(\"LIOBN 0x\" TARGET_FMT_lx \" does not exist\\n\", liobn);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);\n\n\n\n#ifdef DEBUG_TCE\n\n    fprintf(stderr, \"spapr_vio_put_tce on %s  ioba 0x\" TARGET_FMT_lx\n\n            \"  TCE 0x\" TARGET_FMT_lx \"\\n\", dev->qdev.id, ioba, tce);\n\n#endif\n\n\n\n    if (ioba >= dev->rtce_window_size) {\n\n        hcall_dprintf(\"Out-of-bounds IOBA 0x\" TARGET_FMT_lx \"\\n\", ioba);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);\n\n    rtce->tce = tce;\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 937, "_split": "test", "_hash": "725050abd2276ade5abe0d274a7be0c2"}
{"project": "qemu", "commit_id": "a907ec52cc1aefc820768b6e341b56f8f3caaca7", "target": 1, "func": "static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,\n\n                                  const char *name, Error **errp)\n\n{\n\n    NvmeCtrl *s = NVME(obj);\n\n\n\n    visit_type_int32(v, &s->conf.bootindex, name, errp);\n\n}\n", "idx": 941, "_split": "test", "_hash": "d1118f69c6c4129708c13ccd1c8d77b3"}
{"project": "qemu", "commit_id": "92b3eeadd9bc72f1f4e5ba1f62a289dc0190e88f", "target": 1, "func": "Object *object_resolve_path_component(Object *parent, const gchar *part)\n\n{\n\n    ObjectProperty *prop = object_property_find(parent, part, NULL);\n\n    if (prop == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    if (object_property_is_link(prop)) {\n\n        return *(Object **)prop->opaque;\n\n    } else if (object_property_is_child(prop)) {\n\n        return prop->opaque;\n\n    } else {\n\n        return NULL;\n\n    }\n\n}\n", "idx": 946, "_split": "test", "_hash": "1ebf1e81813bae25ca2e0f28eb84ea2a"}
{"project": "qemu", "commit_id": "196fe23734ca8888ca0275ad203ccb0d20907e6d", "target": 1, "func": "static void vscsi_process_login(VSCSIState *s, vscsi_req *req)\n\n{\n\n    union viosrp_iu *iu = &req->iu;\n\n    struct srp_login_rsp *rsp = &iu->srp.login_rsp;\n\n    uint64_t tag = iu->srp.rsp.tag;\n\n\n\n    trace_spapr_vscsi__process_login();\n\n\n\n    /* TODO handle case that requested size is wrong and\n\n     * buffer format is wrong\n\n     */\n\n    memset(iu, 0, sizeof(struct srp_login_rsp));\n\n    rsp->opcode = SRP_LOGIN_RSP;\n\n    /* Don't advertise quite as many request as we support to\n\n     * keep room for management stuff etc...\n\n     */\n\n    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);\n\n    rsp->tag = tag;\n\n    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));\n\n    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));\n\n    /* direct and indirect */\n\n    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);\n\n\n\n    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);\n\n}\n", "idx": 961, "_split": "test", "_hash": "37def0e6edafb10b0105f2a7544d1ceb"}
{"project": "qemu", "commit_id": "bf43330aa418908f7a5e2acda28ac1a8ed0d8ad6", "target": 1, "func": "void cpu_tick_set_count(CPUTimer *timer, uint64_t count)\n\n{\n\n    uint64_t real_count = count & ~timer->disabled_mask;\n\n    uint64_t disabled_bit = count & timer->disabled_mask;\n\n\n\n    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -\n\n                    cpu_to_timer_ticks(real_count, timer->frequency);\n\n\n\n    TIMER_DPRINTF(\"%s set_count count=0x%016lx (%s) p=%p\\n\",\n\n                  timer->name, real_count,\n\n                  timer->disabled?\"disabled\":\"enabled\", timer);\n\n\n\n    timer->disabled = disabled_bit ? 1 : 0;\n\n    timer->clock_offset = vm_clock_offset;\n\n}\n", "idx": 963, "_split": "test", "_hash": "00fd85a1dad772bc0dca7284082c6fe3"}
{"project": "qemu", "commit_id": "d3c8c67469ee70fcae116d5abc277a7ebc8a19fd", "target": 1, "func": "void commit_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, BlockDriverState *top, int64_t speed,\n\n                  BlockdevOnError on_error, const char *backing_file_str,\n\n                  const char *filter_node_name, Error **errp)\n\n{\n\n    CommitBlockJob *s;\n\n    BlockReopenQueue *reopen_queue = NULL;\n\n    int orig_overlay_flags;\n\n    int orig_base_flags;\n\n    BlockDriverState *iter;\n\n    BlockDriverState *overlay_bs;\n\n    BlockDriverState *commit_top_bs = NULL;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    assert(top != bs);\n\n    if (top == base) {\n\n        error_setg(errp, \"Invalid files for merge: top and base are the same\");\n\n        return;\n\n\n\n\n    overlay_bs = bdrv_find_overlay(bs, top);\n\n\n\n    if (overlay_bs == NULL) {\n\n        error_setg(errp, \"Could not find overlay image for %s:\", top->filename);\n\n        return;\n\n\n\n\n    s = block_job_create(job_id, &commit_job_driver, bs, 0, BLK_PERM_ALL,\n\n                         speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp);\n\n    if (!s) {\n\n        return;\n\n\n\n\n    orig_base_flags    = bdrv_get_flags(base);\n\n    orig_overlay_flags = bdrv_get_flags(overlay_bs);\n\n\n\n    /* convert base & overlay_bs to r/w, if necessary */\n\n    if (!(orig_base_flags & BDRV_O_RDWR)) {\n\n        reopen_queue = bdrv_reopen_queue(reopen_queue, base, NULL,\n\n                                         orig_base_flags | BDRV_O_RDWR);\n\n\n    if (!(orig_overlay_flags & BDRV_O_RDWR)) {\n\n        reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL,\n\n                                         orig_overlay_flags | BDRV_O_RDWR);\n\n\n    if (reopen_queue) {\n\n        bdrv_reopen_multiple(bdrv_get_aio_context(bs), reopen_queue, &local_err);\n\n        if (local_err != NULL) {\n\n            error_propagate(errp, local_err);\n\n            goto fail;\n\n\n\n\n\n    /* Insert commit_top block node above top, so we can block consistent read\n\n     * on the backing chain below it */\n\n    commit_top_bs = bdrv_new_open_driver(&bdrv_commit_top, filter_node_name, 0,\n\n                                         errp);\n\n    if (commit_top_bs == NULL) {\n\n        goto fail;\n\n\n\n\n\n    commit_top_bs->total_sectors = top->total_sectors;\n\n    bdrv_set_aio_context(commit_top_bs, bdrv_get_aio_context(top));\n\n\n\n    bdrv_set_backing_hd(commit_top_bs, top, &local_err);\n\n    if (local_err) {\n\n        bdrv_unref(commit_top_bs);\n\n        commit_top_bs = NULL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n    bdrv_set_backing_hd(overlay_bs, commit_top_bs, &local_err);\n\n    if (local_err) {\n\n        bdrv_unref(commit_top_bs);\n\n        commit_top_bs = NULL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    s->commit_top_bs = commit_top_bs;\n\n    bdrv_unref(commit_top_bs);\n\n\n\n    /* Block all nodes between top and base, because they will\n\n     * disappear from the chain after this operation. */\n\n    assert(bdrv_chain_contains(top, base));\n\n    for (iter = top; iter != base; iter = backing_bs(iter)) {\n\n        /* XXX BLK_PERM_WRITE needs to be allowed so we don't block ourselves\n\n         * at s->base (if writes are blocked for a node, they are also blocked\n\n         * for its backing file). The other options would be a second filter\n\n         * driver above s->base. */\n\n        ret = block_job_add_bdrv(&s->common, \"intermediate node\", iter, 0,\n\n                                 BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE,\n\n                                 errp);\n\n        if (ret < 0) {\n\n            goto fail;\n\n\n\n\n\n    ret = block_job_add_bdrv(&s->common, \"base\", base, 0, BLK_PERM_ALL, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    /* overlay_bs must be blocked because it needs to be modified to\n\n     * update the backing image string. */\n\n    ret = block_job_add_bdrv(&s->common, \"overlay of top\", overlay_bs,\n\n                             BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    s->base = blk_new(BLK_PERM_CONSISTENT_READ\n\n                      | BLK_PERM_WRITE\n\n                      | BLK_PERM_RESIZE,\n\n                      BLK_PERM_CONSISTENT_READ\n\n                      | BLK_PERM_GRAPH_MOD\n\n                      | BLK_PERM_WRITE_UNCHANGED);\n\n    ret = blk_insert_bs(s->base, base, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    /* Required permissions are already taken with block_job_add_bdrv() */\n\n    s->top = blk_new(0, BLK_PERM_ALL);\n\n    ret = blk_insert_bs(s->top, top, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    s->active = bs;\n\n\n\n    s->base_flags          = orig_base_flags;\n\n    s->orig_overlay_flags  = orig_overlay_flags;\n\n\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n\n\n    s->on_error = on_error;\n\n\n\n    trace_commit_start(bs, base, top, s);\n\n    block_job_start(&s->common);\n\n    return;\n\n\n\nfail:\n\n    if (s->base) {\n\n        blk_unref(s->base);\n\n\n    if (s->top) {\n\n        blk_unref(s->top);\n\n\n    if (commit_top_bs) {\n\n        bdrv_set_backing_hd(overlay_bs, top, &error_abort);\n\n\n    block_job_early_fail(&s->common);\n", "idx": 971, "_split": "test", "_hash": "4c9f832c9eab938bedd0830e35040945"}
{"project": "qemu", "commit_id": "2c6942fa7b332a95286071b92d233853e1000948", "target": 0, "func": "int bdrv_is_removable(BlockDriverState *bs)\n\n{\n\n    return bs->removable;\n\n}\n", "idx": 982, "_split": "test", "_hash": "d23a11dbed2c4430db91408b9bef8399"}
{"project": "qemu", "commit_id": "8ae8e904fcba484ff7c3f8f31339b56ebd88fbad", "target": 1, "func": "void qmp_blockdev_add(BlockdevOptions *options, Error **errp)\n\n{\n\n    QmpOutputVisitor *ov = qmp_output_visitor_new();\n\n    QObject *obj;\n\n    QDict *qdict;\n\n    Error *local_err = NULL;\n\n\n\n    /* Require an ID in the top level */\n\n    if (!options->has_id) {\n\n        error_setg(errp, \"Block device needs an ID\");\n\n        goto fail;\n\n    }\n\n\n\n    /* TODO Sort it out in raw-posix and drive_init: Reject aio=native with\n\n     * cache.direct=false instead of silently switching to aio=threads, except\n\n     * if called from drive_init.\n\n     *\n\n     * For now, simply forbidding the combination for all drivers will do. */\n\n    if (options->has_aio && options->aio == BLOCKDEV_AIO_OPTIONS_NATIVE) {\n\n        bool direct = options->cache->has_direct && options->cache->direct;\n\n        if (!options->has_cache && !direct) {\n\n            error_setg(errp, \"aio=native requires cache.direct=true\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    visit_type_BlockdevOptions(qmp_output_get_visitor(ov),\n\n                               &options, NULL, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\n    obj = qmp_output_get_qobject(ov);\n\n    qdict = qobject_to_qdict(obj);\n\n\n\n    qdict_flatten(qdict);\n\n\n\n    blockdev_init(NULL, qdict, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\nfail:\n\n    qmp_output_visitor_cleanup(ov);\n\n}\n", "idx": 1038, "_split": "test", "_hash": "39a3e18640db8f10ed4930a319d013d9"}
{"project": "qemu", "commit_id": "966439a67830239a6c520c5df6c55627b8153c8b", "target": 1, "func": "void do_divwuo (void)\n\n{\n\n    if (likely((uint32_t)T1 != 0)) {\n\n        xer_ov = 0;\n\n        T0 = (uint32_t)T0 / (uint32_t)T1;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n        T0 = 0;\n\n    }\n\n}\n", "idx": 1040, "_split": "test", "_hash": "38f1355bd0d0e5ce34909662705f117e"}
{"project": "qemu", "commit_id": "00f4d64ee76e873be881a82d893a591487aa7950", "target": 1, "func": "static void kvmclock_pre_save(void *opaque)\n\n{\n\n    KVMClockState *s = opaque;\n\n    struct kvm_clock_data data;\n\n    int ret;\n\n\n\n    if (s->clock_valid) {\n\n        return;\n\n    }\n\n    ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"KVM_GET_CLOCK failed: %s\\n\", strerror(ret));\n\n        data.clock = 0;\n\n    }\n\n    s->clock = data.clock;\n\n    /*\n\n     * If the VM is stopped, declare the clock state valid to avoid re-reading\n\n     * it on next vmsave (which would return a different value). Will be reset\n\n     * when the VM is continued.\n\n     */\n\n    s->clock_valid = !runstate_is_running();\n\n}\n", "idx": 1046, "_split": "test", "_hash": "a0718b2192240d9be409452150c63556"}
{"project": "qemu", "commit_id": "6c1fef6b59563cc415f21e03f81539ed4b33ad90", "target": 1, "func": "static void handle_satn(ESPState *s)\n\n{\n\n    uint8_t buf[32];\n\n    int len;\n\n\n\n    if (s->dma && !s->dma_enabled) {\n\n        s->dma_cb = handle_satn;\n\n        return;\n\n    }\n\n    len = get_cmd(s, buf);\n\n    if (len)\n\n        do_cmd(s, buf);\n\n}\n", "idx": 1056, "_split": "test", "_hash": "bd0ff6e860548d93cc87d5ddb1f287ea"}
{"project": "qemu", "commit_id": "35c2c8dc8c0899882a8e0d349d93bd657772f1e7", "target": 0, "func": "int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind,\n\n                   const char *version, const char *serial, const char *model,\n\n                   uint64_t wwn,\n\n                   uint32_t cylinders, uint32_t heads, uint32_t secs,\n\n                   int chs_trans)\n\n{\n\n    uint64_t nb_sectors;\n\n\n\n    s->blk = blk;\n\n    s->drive_kind = kind;\n\n\n\n    blk_get_geometry(blk, &nb_sectors);\n\n    s->cylinders = cylinders;\n\n    s->heads = heads;\n\n    s->sectors = secs;\n\n    s->chs_trans = chs_trans;\n\n    s->nb_sectors = nb_sectors;\n\n    s->wwn = wwn;\n\n    /* The SMART values should be preserved across power cycles\n\n       but they aren't.  */\n\n    s->smart_enabled = 1;\n\n    s->smart_autosave = 1;\n\n    s->smart_errors = 0;\n\n    s->smart_selftest_count = 0;\n\n    if (kind == IDE_CD) {\n\n        blk_set_dev_ops(blk, &ide_cd_block_ops, s);\n\n        blk_set_guest_block_size(blk, 2048);\n\n    } else {\n\n        if (!blk_is_inserted(s->blk)) {\n\n            error_report(\"Device needs media, but drive is empty\");\n\n            return -1;\n\n        }\n\n        if (blk_is_read_only(blk)) {\n\n            error_report(\"Can't use a read-only drive\");\n\n            return -1;\n\n        }\n\n        blk_set_dev_ops(blk, &ide_hd_block_ops, s);\n\n    }\n\n    if (serial) {\n\n        pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial);\n\n    } else {\n\n        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),\n\n                 \"QM%05d\", s->drive_serial);\n\n    }\n\n    if (model) {\n\n        pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model);\n\n    } else {\n\n        switch (kind) {\n\n        case IDE_CD:\n\n            strcpy(s->drive_model_str, \"QEMU DVD-ROM\");\n\n            break;\n\n        case IDE_CFATA:\n\n            strcpy(s->drive_model_str, \"QEMU MICRODRIVE\");\n\n            break;\n\n        default:\n\n            strcpy(s->drive_model_str, \"QEMU HARDDISK\");\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (version) {\n\n        pstrcpy(s->version, sizeof(s->version), version);\n\n    } else {\n\n        pstrcpy(s->version, sizeof(s->version), qemu_get_version());\n\n    }\n\n\n\n    ide_reset(s);\n\n    blk_iostatus_enable(blk);\n\n    return 0;\n\n}\n", "idx": 1060, "_split": "test", "_hash": "fcf6557e93c55b52daaeee61348fcd7f"}
{"project": "qemu", "commit_id": "384b557da1a44ce260cd0328c06a250507348f73", "target": 1, "func": "int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,\n\n                                                 uint64_t iova, uint64_t len)\n\n{\n\n    struct vhost_iotlb_msg imsg;\n\n\n\n    imsg.iova = iova;\n\n    imsg.size = len;\n\n    imsg.type = VHOST_IOTLB_INVALIDATE;\n\n\n\n    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);\n\n}\n", "idx": 1089, "_split": "test", "_hash": "d3e30141b8f9507bde081732f855d34a"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)\n\n{\n\n    uint32_t val;\n\n    val = gic_dist_readb(opaque, offset);\n\n    val |= gic_dist_readb(opaque, offset + 1) << 8;\n\n    return val;\n\n}\n", "idx": 1107, "_split": "test", "_hash": "a9b9d193a691ce903bd723ccb6527a66"}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoull_overflow(void)\n\n{\n\n    const char *str = \"99999999999999999999999999999999999999999999\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, -ERANGE);\n\n    g_assert_cmpint(res, ==, ULLONG_MAX);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n", "idx": 1108, "_split": "test", "_hash": "e62e7c451d6c2a939f6337df8e067ff1"}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "PXA2xxState *pxa255_init(unsigned int sdram_size)\n\n{\n\n    PXA2xxState *s;\n\n    int iomemtype, i;\n\n    DriveInfo *dinfo;\n\n\n\n    s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState));\n\n\n\n    s->env = cpu_init(\"pxa255\");\n\n    if (!s->env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0];\n\n\n\n    /* SDRAM & Internal Memory Storage */\n\n    cpu_register_physical_memory(PXA2XX_SDRAM_BASE, sdram_size,\n\n                    qemu_ram_alloc(NULL, \"pxa255.sdram\",\n\n                                   sdram_size) | IO_MEM_RAM);\n\n    cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE,\n\n                    qemu_ram_alloc(NULL, \"pxa255.internal\",\n\n                                   PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM);\n\n\n\n    s->pic = pxa2xx_pic_init(0x40d00000, s->env);\n\n\n\n    s->dma = pxa255_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]);\n\n\n\n    pxa25x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0]);\n\n\n\n    s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 85);\n\n\n\n    dinfo = drive_get(IF_SD, 0, 0);\n\n    if (!dinfo) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n\n        exit(1);\n\n    }\n\n    s->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv,\n\n                              s->pic[PXA2XX_PIC_MMC], s->dma);\n\n\n\n    for (i = 0; pxa255_serial[i].io_base; i ++)\n\n        if (serial_hds[i]) {\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n            serial_mm_init(pxa255_serial[i].io_base, 2,\n\n                           s->pic[pxa255_serial[i].irqn], 14745600/16,\n\n                           serial_hds[i], 1, 1);\n\n#else\n\n            serial_mm_init(pxa255_serial[i].io_base, 2,\n\n                           s->pic[pxa255_serial[i].irqn], 14745600/16,\n\n                           serial_hds[i], 1, 0);\n\n#endif\n\n        } else {\n\n            break;\n\n        }\n\n    if (serial_hds[i])\n\n        s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP],\n\n                        s->dma, serial_hds[i]);\n\n\n\n    s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD]);\n\n\n\n    s->cm_base = 0x41300000;\n\n    s->cm_regs[CCCR >> 2] = 0x02000210;\t/* 416.0 MHz */\n\n    s->clkcfg = 0x00000009;\t\t/* Turbo mode active */\n\n    iomemtype = cpu_register_io_memory(pxa2xx_cm_readfn,\n\n                    pxa2xx_cm_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->cm_base, 0x1000, iomemtype);\n\n    register_savevm(NULL, \"pxa2xx_cm\", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s);\n\n\n\n    cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s);\n\n\n\n    s->mm_base = 0x48000000;\n\n    s->mm_regs[MDMRS >> 2] = 0x00020002;\n\n    s->mm_regs[MDREFR >> 2] = 0x03ca4000;\n\n    s->mm_regs[MECR >> 2] = 0x00000001;\t/* Two PC Card sockets */\n\n    iomemtype = cpu_register_io_memory(pxa2xx_mm_readfn,\n\n                    pxa2xx_mm_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->mm_base, 0x1000, iomemtype);\n\n    register_savevm(NULL, \"pxa2xx_mm\", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s);\n\n\n\n    s->pm_base = 0x40f00000;\n\n    iomemtype = cpu_register_io_memory(pxa2xx_pm_readfn,\n\n                    pxa2xx_pm_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->pm_base, 0x100, iomemtype);\n\n    register_savevm(NULL, \"pxa2xx_pm\", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s);\n\n\n\n    for (i = 0; pxa255_ssp[i].io_base; i ++);\n\n    s->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i);\n\n    for (i = 0; pxa255_ssp[i].io_base; i ++) {\n\n        DeviceState *dev;\n\n        dev = sysbus_create_simple(\"pxa2xx-ssp\", pxa255_ssp[i].io_base,\n\n                                   s->pic[pxa255_ssp[i].irqn]);\n\n        s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, \"ssi\");\n\n    }\n\n\n\n    if (usb_enabled) {\n\n        sysbus_create_simple(\"sysbus-ohci\", 0x4c000000,\n\n                             s->pic[PXA2XX_PIC_USBH1]);\n\n    }\n\n\n\n    s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);\n\n    s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);\n\n\n\n    s->rtc_base = 0x40900000;\n\n    iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn,\n\n                    pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype);\n\n    pxa2xx_rtc_init(s);\n\n    register_savevm(NULL, \"pxa2xx_rtc\", 0, 0, pxa2xx_rtc_save,\n\n                    pxa2xx_rtc_load, s);\n\n\n\n    s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff);\n\n    s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff);\n\n\n\n    s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma);\n\n\n\n    /* GPIO1 resets the processor */\n\n    /* The handler can be overridden by board-specific code */\n\n    qdev_connect_gpio_out(s->gpio, 1, s->reset);\n\n    return s;\n\n}\n", "idx": 1119, "_split": "test", "_hash": "699497071e7aa3ea44470d547c42a224"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int usb_device_delete_addr(int busnr, int addr)\n\n{\n\n    USBBus *bus;\n\n    USBPort *port;\n\n    USBDevice *dev;\n\n\n\n    bus = usb_bus_find(busnr);\n\n    if (!bus)\n\n        return -1;\n\n\n\n    TAILQ_FOREACH(port, &bus->used, next) {\n\n        if (port->dev->addr == addr)\n\n            break;\n\n    }\n\n    if (!port)\n\n        return -1;\n\n\n\n    dev = port->dev;\n\n    TAILQ_REMOVE(&bus->used, port, next);\n\n    bus->nused--;\n\n\n\n    usb_attach(port, NULL);\n\n    dev->info->handle_destroy(dev);\n\n\n\n    TAILQ_INSERT_TAIL(&bus->free, port, next);\n\n    bus->nfree++;\n\n    return 0;\n\n}\n", "idx": 1121, "_split": "test", "_hash": "80dad065713b295ba4e4e07cd49714de"}
{"project": "qemu", "commit_id": "7d5e199ade76c53ec316ab6779800581bb47c50a", "target": 0, "func": "static void qmp_output_type_number(Visitor *v, const char *name, double *obj,\n\n                                   Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    qmp_output_add(qov, name, qfloat_from_double(*obj));\n\n}\n", "idx": 1122, "_split": "test", "_hash": "517b9854f434c013c95b8fcc36be4dfd"}
{"project": "qemu", "commit_id": "0e01b76e7cc43068f6b8cc05297f61539ccd5279", "target": 1, "func": "static int aio_write_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    int nr_iov, c;\n\n    int pattern = 0xcd;\n\n    struct aio_ctx *ctx = g_new0(struct aio_ctx, 1);\n\n\n\n    ctx->blk = blk;\n\n    while ((c = getopt(argc, argv, \"CqP:z\")) != -1) {\n\n        switch (c) {\n\n        case 'C':\n\n            ctx->Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            ctx->qflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'z':\n\n            ctx->zflag = 1;\n\n            break;\n\n        default:\n\n\n            return qemuio_command_usage(&aio_write_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n\n        return qemuio_command_usage(&aio_write_cmd);\n\n    }\n\n\n\n    if (ctx->zflag && optind != argc - 2) {\n\n        printf(\"-z supports only a single length parameter\\n\");\n\n\n        return 0;\n\n    }\n\n\n\n    if (ctx->zflag && ctx->Pflag) {\n\n        printf(\"-z and -P cannot be specified at the same time\\n\");\n\n\n        return 0;\n\n    }\n\n\n\n    ctx->offset = cvtnum(argv[optind]);\n\n    if (ctx->offset < 0) {\n\n        print_cvtnum_err(ctx->offset, argv[optind]);\n\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (ctx->offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               ctx->offset);\n\n        block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE);\n\n\n        return 0;\n\n    }\n\n\n\n    if (ctx->zflag) {\n\n        int64_t count = cvtnum(argv[optind]);\n\n        if (count < 0) {\n\n            print_cvtnum_err(count, argv[optind]);\n\n\n            return 0;\n\n        }\n\n\n\n        ctx->qiov.size = count;\n\n        blk_aio_write_zeroes(blk, ctx->offset >> 9, count >> 9, 0,\n\n                             aio_write_done, ctx);\n\n    } else {\n\n        nr_iov = argc - optind;\n\n        ctx->buf = create_iovec(blk, &ctx->qiov, &argv[optind], nr_iov,\n\n                                pattern);\n\n        if (ctx->buf == NULL) {\n\n            block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE);\n\n\n            return 0;\n\n        }\n\n\n\n        gettimeofday(&ctx->t1, NULL);\n\n        block_acct_start(blk_get_stats(blk), &ctx->acct, ctx->qiov.size,\n\n                         BLOCK_ACCT_WRITE);\n\n\n\n        blk_aio_writev(blk, ctx->offset >> 9, &ctx->qiov,\n\n                       ctx->qiov.size >> 9, aio_write_done, ctx);\n\n    }\n\n    return 0;\n\n}", "idx": 1130, "_split": "test", "_hash": "4078a263b089d3030ff779e003de7945"}
{"project": "qemu", "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194", "target": 1, "func": "static int alloc_refcount_block(BlockDriverState *bs,\n\n    int64_t cluster_index, uint16_t **refcount_block)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    unsigned int refcount_table_index;\n\n    int ret;\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);\n\n\n\n    /* Find the refcount block for the given cluster */\n\n    refcount_table_index = cluster_index >> s->refcount_block_bits;\n\n\n\n    if (refcount_table_index < s->refcount_table_size) {\n\n\n\n        uint64_t refcount_block_offset =\n\n            s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n\n\n\n        /* If it's already there, we're done */\n\n        if (refcount_block_offset) {\n\n            if (offset_into_cluster(s, refcount_block_offset)) {\n\n                qcow2_signal_corruption(bs, true, -1, -1, \"Refblock offset %#\"\n\n                                        PRIx64 \" unaligned (reftable index: \"\n\n                                        \"%#x)\", refcount_block_offset,\n\n                                        refcount_table_index);\n\n                return -EIO;\n\n            }\n\n\n\n             return load_refcount_block(bs, refcount_block_offset,\n\n                 (void**) refcount_block);\n\n        }\n\n    }\n\n\n\n    /*\n\n     * If we came here, we need to allocate something. Something is at least\n\n     * a cluster for the new refcount block. It may also include a new refcount\n\n     * table if the old refcount table is too small.\n\n     *\n\n     * Note that allocating clusters here needs some special care:\n\n     *\n\n     * - We can't use the normal qcow2_alloc_clusters(), it would try to\n\n     *   increase the refcount and very likely we would end up with an endless\n\n     *   recursion. Instead we must place the refcount blocks in a way that\n\n     *   they can describe them themselves.\n\n     *\n\n     * - We need to consider that at this point we are inside update_refcounts\n\n     *   and potentially doing an initial refcount increase. This means that\n\n     *   some clusters have already been allocated by the caller, but their\n\n     *   refcount isn't accurate yet. If we allocate clusters for metadata, we\n\n     *   need to return -EAGAIN to signal the caller that it needs to restart\n\n     *   the search for free clusters.\n\n     *\n\n     * - alloc_clusters_noref and qcow2_free_clusters may load a different\n\n     *   refcount block into the cache\n\n     */\n\n\n\n    *refcount_block = NULL;\n\n\n\n    /* We write to the refcount table, so we might depend on L2 tables */\n\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Allocate the refcount block itself and mark it as used */\n\n    int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);\n\n    if (new_block < 0) {\n\n        return new_block;\n\n    }\n\n\n\n#ifdef DEBUG_ALLOC2\n\n    fprintf(stderr, \"qcow2: Allocate refcount block %d for %\" PRIx64\n\n        \" at %\" PRIx64 \"\\n\",\n\n        refcount_table_index, cluster_index << s->cluster_bits, new_block);\n\n#endif\n\n\n\n    if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {\n\n        /* Zero the new refcount block before updating it */\n\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n\n            (void**) refcount_block);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        memset(*refcount_block, 0, s->cluster_size);\n\n\n\n        /* The block describes itself, need to update the cache */\n\n        int block_index = (new_block >> s->cluster_bits) &\n\n            (s->refcount_block_size - 1);\n\n        (*refcount_block)[block_index] = cpu_to_be16(1);\n\n    } else {\n\n        /* Described somewhere else. This can recurse at most twice before we\n\n         * arrive at a block that describes itself. */\n\n        ret = update_refcount(bs, new_block, s->cluster_size, 1, false,\n\n                              QCOW2_DISCARD_NEVER);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        /* Initialize the new refcount block only after updating its refcount,\n\n         * update_refcount uses the refcount cache itself */\n\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n\n            (void**) refcount_block);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        memset(*refcount_block, 0, s->cluster_size);\n\n    }\n\n\n\n    /* Now the new refcount block needs to be written to disk */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);\n\n    qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block);\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n    if (ret < 0) {\n\n        goto fail_block;\n\n    }\n\n\n\n    /* If the refcount table is big enough, just hook the block up there */\n\n    if (refcount_table_index < s->refcount_table_size) {\n\n        uint64_t data64 = cpu_to_be64(new_block);\n\n        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);\n\n        ret = bdrv_pwrite_sync(bs->file,\n\n            s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),\n\n            &data64, sizeof(data64));\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        s->refcount_table[refcount_table_index] = new_block;\n\n\n\n        /* The new refcount block may be where the caller intended to put its\n\n         * data, so let it restart the search. */\n\n        return -EAGAIN;\n\n    }\n\n\n\n    ret = qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);\n\n    if (ret < 0) {\n\n        goto fail_block;\n\n    }\n\n\n\n    /*\n\n     * If we come here, we need to grow the refcount table. Again, a new\n\n     * refcount table needs some space and we can't simply allocate to avoid\n\n     * endless recursion.\n\n     *\n\n     * Therefore let's grab new refcount blocks at the end of the image, which\n\n     * will describe themselves and the new refcount table. This way we can\n\n     * reference them only in the new table and do the switch to the new\n\n     * refcount table at once without producing an inconsistent state in\n\n     * between.\n\n     */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);\n\n\n\n    /* Calculate the number of refcount blocks needed so far */\n\n    uint64_t blocks_used = DIV_ROUND_UP(cluster_index, s->refcount_block_size);\n\n\n\n    if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) {\n\n        return -EFBIG;\n\n    }\n\n\n\n    /* And now we need at least one block more for the new metadata */\n\n    uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);\n\n    uint64_t last_table_size;\n\n    uint64_t blocks_clusters;\n\n    do {\n\n        uint64_t table_clusters =\n\n            size_to_clusters(s, table_size * sizeof(uint64_t));\n\n        blocks_clusters = 1 +\n\n            ((table_clusters + s->refcount_block_size - 1)\n\n            / s->refcount_block_size);\n\n        uint64_t meta_clusters = table_clusters + blocks_clusters;\n\n\n\n        last_table_size = table_size;\n\n        table_size = next_refcount_table_size(s, blocks_used +\n\n            ((meta_clusters + s->refcount_block_size - 1)\n\n            / s->refcount_block_size));\n\n\n\n    } while (last_table_size != table_size);\n\n\n\n#ifdef DEBUG_ALLOC2\n\n    fprintf(stderr, \"qcow2: Grow refcount table %\" PRId32 \" => %\" PRId64 \"\\n\",\n\n        s->refcount_table_size, table_size);\n\n#endif\n\n\n\n    /* Create the new refcount table and blocks */\n\n    uint64_t meta_offset = (blocks_used * s->refcount_block_size) *\n\n        s->cluster_size;\n\n    uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size;\n\n    uint64_t *new_table = g_try_new0(uint64_t, table_size);\n\n    uint16_t *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size);\n\n\n\n    assert(table_size > 0 && blocks_clusters > 0);\n\n    if (new_table == NULL || new_blocks == NULL) {\n\n        ret = -ENOMEM;\n\n        goto fail_table;\n\n    }\n\n\n\n    /* Fill the new refcount table */\n\n    memcpy(new_table, s->refcount_table,\n\n        s->refcount_table_size * sizeof(uint64_t));\n\n    new_table[refcount_table_index] = new_block;\n\n\n\n    int i;\n\n    for (i = 0; i < blocks_clusters; i++) {\n\n        new_table[blocks_used + i] = meta_offset + (i * s->cluster_size);\n\n    }\n\n\n\n    /* Fill the refcount blocks */\n\n    uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));\n\n    int block = 0;\n\n    for (i = 0; i < table_clusters + blocks_clusters; i++) {\n\n        new_blocks[block++] = cpu_to_be16(1);\n\n    }\n\n\n\n    /* Write refcount blocks to disk */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);\n\n    ret = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks,\n\n        blocks_clusters * s->cluster_size);\n\n    g_free(new_blocks);\n\n    new_blocks = NULL;\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    /* Write refcount table to disk */\n\n    for(i = 0; i < table_size; i++) {\n\n        cpu_to_be64s(&new_table[i]);\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);\n\n    ret = bdrv_pwrite_sync(bs->file, table_offset, new_table,\n\n        table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    for(i = 0; i < table_size; i++) {\n\n        be64_to_cpus(&new_table[i]);\n\n    }\n\n\n\n    /* Hook up the new refcount table in the qcow2 header */\n\n    uint8_t data[12];\n\n    cpu_to_be64w((uint64_t*)data, table_offset);\n\n    cpu_to_be32w((uint32_t*)(data + 8), table_clusters);\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);\n\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset),\n\n        data, sizeof(data));\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    /* And switch it in memory */\n\n    uint64_t old_table_offset = s->refcount_table_offset;\n\n    uint64_t old_table_size = s->refcount_table_size;\n\n\n\n    g_free(s->refcount_table);\n\n    s->refcount_table = new_table;\n\n    s->refcount_table_size = table_size;\n\n    s->refcount_table_offset = table_offset;\n\n\n\n    /* Free old table. */\n\n    qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t),\n\n                        QCOW2_DISCARD_OTHER);\n\n\n\n    ret = load_refcount_block(bs, new_block, (void**) refcount_block);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* If we were trying to do the initial refcount update for some cluster\n\n     * allocation, we might have used the same clusters to store newly\n\n     * allocated metadata. Make the caller search some new space. */\n\n    return -EAGAIN;\n\n\n\nfail_table:\n\n    g_free(new_blocks);\n\n    g_free(new_table);\n\nfail_block:\n\n    if (*refcount_block != NULL) {\n\n        qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);\n\n    }\n\n    return ret;\n\n}\n", "idx": 1136, "_split": "test", "_hash": "013311eaa54b8674ac8320e900465279"}
{"project": "qemu", "commit_id": "6240d6467077a12c24878bab645d8e2983e4975a", "target": 0, "func": "static void slavio_timer_mem_writel(void *opaque, target_phys_addr_t addr,\n\n                                    uint32_t val)\n\n{\n\n    SLAVIO_TIMERState *s = opaque;\n\n    uint32_t saddr;\n\n    int reload = 0;\n\n\n\n    DPRINTF(\"write \" TARGET_FMT_plx \" %08x\\n\", addr, val);\n\n    saddr = (addr & TIMER_MAXADDR) >> 2;\n\n    switch (saddr) {\n\n    case TIMER_LIMIT:\n\n        if (slavio_timer_is_user(s)) {\n\n            // set user counter MSW, reset counter\n\n            qemu_irq_lower(s->irq);\n\n            s->limit = TIMER_MAX_COUNT64;\n\n            DPRINTF(\"processor %d user timer reset\\n\", s->slave_index);\n\n            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);\n\n        } else {\n\n            // set limit, reset counter\n\n            qemu_irq_lower(s->irq);\n\n            s->limit = val & TIMER_MAX_COUNT32;\n\n            if (!s->limit)\n\n                s->limit = TIMER_MAX_COUNT32;\n\n            ptimer_set_limit(s->timer, s->limit >> 9, 1);\n\n        }\n\n        break;\n\n    case TIMER_COUNTER:\n\n        if (slavio_timer_is_user(s)) {\n\n            // set user counter LSW, reset counter\n\n            qemu_irq_lower(s->irq);\n\n            s->limit = TIMER_MAX_COUNT64;\n\n            DPRINTF(\"processor %d user timer reset\\n\", s->slave_index);\n\n            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);\n\n        } else\n\n            DPRINTF(\"not user timer\\n\");\n\n        break;\n\n    case TIMER_COUNTER_NORST:\n\n        // set limit without resetting counter\n\n        s->limit = val & TIMER_MAX_COUNT32;\n\n        if (!s->limit)\n\n            s->limit = TIMER_MAX_COUNT32;\n\n        ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), reload);\n\n        break;\n\n    case TIMER_STATUS:\n\n        if (slavio_timer_is_user(s)) {\n\n            // start/stop user counter\n\n            if ((val & 1) && !s->running) {\n\n                DPRINTF(\"processor %d user timer started\\n\", s->slave_index);\n\n                ptimer_run(s->timer, 0);\n\n                s->running = 1;\n\n            } else if (!(val & 1) && s->running) {\n\n                DPRINTF(\"processor %d user timer stopped\\n\", s->slave_index);\n\n                ptimer_stop(s->timer);\n\n                s->running = 0;\n\n            }\n\n        }\n\n        break;\n\n    case TIMER_MODE:\n\n        if (s->master == NULL) {\n\n            unsigned int i;\n\n\n\n            for (i = 0; i < s->num_slaves; i++) {\n\n                if (val & (1 << i)) {\n\n                    qemu_irq_lower(s->slave[i]->irq);\n\n                    s->slave[i]->limit = -1ULL;\n\n                }\n\n                if ((val & (1 << i)) != (s->slave_mode & (1 << i))) {\n\n                    ptimer_stop(s->slave[i]->timer);\n\n                    ptimer_set_limit(s->slave[i]->timer,\n\n                                     LIMIT_TO_PERIODS(s->slave[i]->limit), 1);\n\n                    DPRINTF(\"processor %d timer changed\\n\",\n\n                            s->slave[i]->slave_index);\n\n                    ptimer_run(s->slave[i]->timer, 0);\n\n                }\n\n            }\n\n            s->slave_mode = val & ((1 << s->num_slaves) - 1);\n\n        } else\n\n            DPRINTF(\"not system timer\\n\");\n\n        break;\n\n    default:\n\n        DPRINTF(\"invalid write address \" TARGET_FMT_plx \"\\n\", addr);\n\n        break;\n\n    }\n\n}\n", "idx": 1167, "_split": "test", "_hash": "08ec402aeca884b438d6115d0a2aa666"}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "void qemu_cpu_kick(void *env)\n\n{\n\n    return;\n\n}\n", "idx": 1194, "_split": "test", "_hash": "7da12038c81b4829db9ebfdfdc5b665b"}
{"project": "qemu", "commit_id": "b591dc59bc98ee558db4ca512aa117748ebfdeef", "target": 0, "func": "static void temp_allocate_frame(TCGContext *s, int temp)\n\n{\n\n    TCGTemp *ts;\n\n    ts = &s->temps[temp];\n\n    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);\n\n    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)\n\n        tcg_abort();\n\n    ts->mem_offset = s->current_frame_offset;\n\n    ts->mem_reg = s->frame_reg;\n\n    ts->mem_allocated = 1;\n\n    s->current_frame_offset += sizeof(tcg_target_long);\n\n}\n", "idx": 1215, "_split": "test", "_hash": "125692e4ca248365c1c001e1e3dc9e02"}
{"project": "qemu", "commit_id": "c83c66c3b58893a4dc056e272822beb88fe9ec7f", "target": 0, "func": "void qmp_block_stream(const char *device, bool has_base,\n\n                      const char *base, Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *base_bs = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    if (base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n        if (base_bs == NULL) {\n\n            error_set(errp, QERR_BASE_NOT_FOUND, base);\n\n            return;\n\n        }\n\n    }\n\n\n\n    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    /* Grab a reference so hotplug does not delete the BlockDriverState from\n\n     * underneath us.\n\n     */\n\n    drive_get_ref(drive_get_by_blockdev(bs));\n\n\n\n    trace_qmp_block_stream(bs, bs->job);\n\n}\n", "idx": 1227, "_split": "test", "_hash": "14174858886013b10dc63a373bf3701a"}
{"project": "qemu", "commit_id": "1108b2f8a939fb5778d384149e2f1b99062a72da", "target": 1, "func": "static void mptsas_scsi_init(PCIDevice *dev, Error **errp)\n\n{\n\n    DeviceState *d = DEVICE(dev);\n\n    MPTSASState *s = MPT_SAS(dev);\n\n\n\n    dev->config[PCI_LATENCY_TIMER] = 0;\n\n    dev->config[PCI_INTERRUPT_PIN] = 0x01;\n\n\n\n    memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,\n\n                          \"mptsas-mmio\", 0x4000);\n\n    memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,\n\n                          \"mptsas-io\", 256);\n\n    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,\n\n                          \"mptsas-diag\", 0x10000);\n\n\n\n    if (s->msi != ON_OFF_AUTO_OFF &&\n\n        msi_init(dev, 0, 1, true, false) >= 0) {\n\n        /* TODO check for errors */\n\n        s->msi_in_use = true;\n\n    }\n\n\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);\n\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);\n\n    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);\n\n\n\n    if (!s->sas_addr) {\n\n        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |\n\n                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;\n\n        s->sas_addr |= (pci_bus_num(dev->bus) << 16);\n\n        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);\n\n        s->sas_addr |= PCI_FUNC(dev->devfn);\n\n    }\n\n    s->max_devices = MPTSAS_NUM_PORTS;\n\n\n\n    s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);\n\n\n\n    QTAILQ_INIT(&s->pending);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, errp);\n\n    }\n\n}\n", "idx": 1277, "_split": "test", "_hash": "7fd69e8bae15247230f9f0b568150199"}
{"project": "qemu", "commit_id": "e0891bd8bfd3349fc3fecde30e51900059f53f11", "target": 0, "func": "static inline int num_effective_busses(XilinxSPIPS *s)\n\n{\n\n    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&\n\n            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;\n\n}\n", "idx": 1290, "_split": "test", "_hash": "c7453c0623545820545b92d3765deddb"}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_set_CF_bit31(TCGv var)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_shri_i32(tmp, var, 31);\n\n    gen_set_CF(tmp);\n\n    dead_tmp(tmp);\n\n}\n", "idx": 1308, "_split": "test", "_hash": "c4e3892d00a7e96b8000caa9db0dcbae"}
{"project": "qemu", "commit_id": "f3e4ce4af336f2ea306fa0f40ec1a5149864ca8c", "target": 1, "func": "static void commit_set_speed(BlockJob *job, int64_t speed, Error **errp)\n\n{\n\n    CommitBlockJob *s = container_of(job, CommitBlockJob, common);\n\n\n\n    if (speed < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");\n\n        return;\n\n    }\n\n    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);\n\n}\n", "idx": 1335, "_split": "test", "_hash": "b30e2e982200d9096b4272f240900179"}
{"project": "qemu", "commit_id": "35b6e94ba50cd92600a85eef444bc31df8999de1", "target": 0, "func": "static uint32_t s390_pci_generate_fid(Error **errp)\n\n{\n\n    uint32_t fid = 0;\n\n\n\n    while (fid <= ZPCI_MAX_FID) {\n\n        if (!s390_pci_find_dev_by_fid(fid)) {\n\n            return fid;\n\n        }\n\n\n\n        if (fid == ZPCI_MAX_FID) {\n\n            break;\n\n        }\n\n\n\n        fid++;\n\n    }\n\n\n\n    error_setg(errp, \"no free fid could be found\");\n\n    return 0;\n\n}\n", "idx": 1351, "_split": "test", "_hash": "d069aa52fb8537137cd1a0b604e8923e"}
{"project": "qemu", "commit_id": "bd3be4dbbf0491d6db8bf326706747b4629ace4b", "target": 0, "func": "static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    V9fsVirtioState *v = VIRTIO_9P(dev);\n\n    V9fsState *s = &v->state;\n\n\n\n    virtio_cleanup(vdev);\n\n    v9fs_device_unrealize_common(s, errp);\n\n}\n", "idx": 1360, "_split": "test", "_hash": "28cbad50f8fd8395ad6d943686cdabbd"}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "bool qemu_co_enter_next(CoQueue *queue)\n\n{\n\n    Coroutine *next;\n\n\n\n    next = QSIMPLEQ_FIRST(&queue->entries);\n\n    if (!next) {\n\n        return false;\n\n    }\n\n\n\n    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);\n\n    qemu_coroutine_enter(next, NULL);\n\n    return true;\n\n}\n", "idx": 1381, "_split": "test", "_hash": "69b195a8c0d0762455ac076930a76933"}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_reg(const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return env->regwptr[val];\n\n}\n", "idx": 1420, "_split": "test", "_hash": "a22912646a35d4f8dc2b2c61d460b91c"}
{"project": "qemu", "commit_id": "b86160555f8d1fe11d6bcec393e08e645d7e1e8d", "target": 1, "func": "static void integratorcp_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    const char *kernel_cmdline = args->kernel_cmdline;\n\n    const char *initrd_filename = args->initrd_filename;\n\n    ARMCPU *cpu;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_alias = g_new(MemoryRegion, 1);\n\n    qemu_irq pic[32];\n\n    DeviceState *dev;\n\n    int i;\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"arm926\";\n\n    }\n\n    cpu = cpu_arm_init(cpu_model);\n\n    if (!cpu) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_init_ram(ram, NULL, \"integrator.ram\", ram_size);\n\n    vmstate_register_ram_global(ram);\n\n    /* ??? On a real system the first 1Mb is mapped as SSRAM or boot flash.  */\n\n    /* ??? RAM should repeat to fill physical memory space.  */\n\n    /* SDRAM at address zero*/\n\n    memory_region_add_subregion(address_space_mem, 0, ram);\n\n    /* And again at address 0x80000000 */\n\n    memory_region_init_alias(ram_alias, NULL, \"ram.alias\", ram, 0, ram_size);\n\n    memory_region_add_subregion(address_space_mem, 0x80000000, ram_alias);\n\n\n\n    dev = qdev_create(NULL, TYPE_INTEGRATOR_CM);\n\n    qdev_prop_set_uint32(dev, \"memsz\", ram_size >> 20);\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map((SysBusDevice *)dev, 0, 0x10000000);\n\n\n\n    dev = sysbus_create_varargs(TYPE_INTEGRATOR_PIC, 0x14000000,\n\n                                qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ),\n\n                                qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_FIQ),\n\n                                NULL);\n\n    for (i = 0; i < 32; i++) {\n\n        pic[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n    sysbus_create_simple(TYPE_INTEGRATOR_PIC, 0xca000000, pic[26]);\n\n    sysbus_create_varargs(\"integrator_pit\", 0x13000000,\n\n                          pic[5], pic[6], pic[7], NULL);\n\n    sysbus_create_simple(\"pl031\", 0x15000000, pic[8]);\n\n    sysbus_create_simple(\"pl011\", 0x16000000, pic[1]);\n\n    sysbus_create_simple(\"pl011\", 0x17000000, pic[2]);\n\n    icp_control_init(0xcb000000);\n\n    sysbus_create_simple(\"pl050_keyboard\", 0x18000000, pic[3]);\n\n    sysbus_create_simple(\"pl050_mouse\", 0x19000000, pic[4]);\n\n\n    sysbus_create_varargs(\"pl181\", 0x1c000000, pic[23], pic[24], NULL);\n\n    if (nd_table[0].used)\n\n        smc91c111_init(&nd_table[0], 0xc8000000, pic[27]);\n\n\n\n    sysbus_create_simple(\"pl110\", 0xc0000000, pic[22]);\n\n\n\n    integrator_binfo.ram_size = ram_size;\n\n    integrator_binfo.kernel_filename = kernel_filename;\n\n    integrator_binfo.kernel_cmdline = kernel_cmdline;\n\n    integrator_binfo.initrd_filename = initrd_filename;\n\n    arm_load_kernel(cpu, &integrator_binfo);\n\n}", "idx": 1434, "_split": "test", "_hash": "a9178618341c3fc36a8eed4b0eba8763"}
{"project": "qemu", "commit_id": "30c367ed446b6ea53245589a5cf373578ac075d7", "target": 1, "func": "static void set_vlan(Object *obj, Visitor *v, void *opaque,\n\n                     const char *name, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop = opaque;\n\n    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);\n\n    NetClientState **ptr = &peers_ptr->ncs[0];\n\n    Error *local_err = NULL;\n\n    int32_t id;\n\n    NetClientState *hubport;\n\n\n\n    if (dev->realized) {\n\n        qdev_prop_set_after_realize(dev, name, errp);\n\n\n\n\n\n    visit_type_int32(v, &id, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n\n\n    if (id == -1) {\n\n        *ptr = NULL;\n\n\n\n\n\n\n\n\n\n    hubport = net_hub_port_find(id);\n\n    if (!hubport) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE,\n\n                  name, prop->info->name);\n\n\n\n    *ptr = hubport;\n", "idx": 1435, "_split": "test", "_hash": "ac6de35f2029f4a0af0c0d03bb00e63c"}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void fd_chr_update_read_handler(CharDriverState *chr)\n\n{\n\n    FDCharDriver *s = chr->opaque;\n\n\n\n    if (s->fd_in_tag) {\n\n        g_source_remove(s->fd_in_tag);\n\n        s->fd_in_tag = 0;\n\n    }\n\n\n\n    if (s->fd_in) {\n\n        s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, chr);\n\n    }\n\n}\n", "idx": 1457, "_split": "test", "_hash": "79698d8f902fd26749a97c010952f5cd"}
{"project": "qemu", "commit_id": "51b0c6065aa6e47a47094d73e24be298a4a7f3a1", "target": 1, "func": "static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr,\n\n                                          target_phys_addr_t end_addr)\n\n{\n\n    KVMState *s = kvm_state;\n\n    unsigned long size, allocated_size = 0;\n\n    KVMDirtyLog d;\n\n    KVMSlot *mem;\n\n    int ret = 0;\n\n\n\n    d.dirty_bitmap = NULL;\n\n    while (start_addr < end_addr) {\n\n        mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);\n\n        if (mem == NULL) {\n\n            break;\n\n        }\n\n\n\n        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8;\n\n        if (!d.dirty_bitmap) {\n\n            d.dirty_bitmap = qemu_malloc(size);\n\n        } else if (size > allocated_size) {\n\n            d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);\n\n        }\n\n        allocated_size = size;\n\n        memset(d.dirty_bitmap, 0, allocated_size);\n\n\n\n        d.slot = mem->slot;\n\n\n\n        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {\n\n            DPRINTF(\"ioctl failed %d\\n\", errno);\n\n            ret = -1;\n\n            break;\n\n        }\n\n\n\n        kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,\n\n                                      mem->start_addr, mem->memory_size);\n\n        start_addr = mem->start_addr + mem->memory_size;\n\n    }\n\n    qemu_free(d.dirty_bitmap);\n\n\n\n    return ret;\n\n}\n", "idx": 1473, "_split": "test", "_hash": "f25877b0ca0ec99c7593fd3973d23f28"}
{"project": "qemu", "commit_id": "a9e1c28ddaae5a48415fec1f336b5560eb85d3e1", "target": 0, "func": "int main(void)\n\n{\n\n    int nf;\n\n    Suite *s;\n\n    SRunner *sr;\n\n\n\n    s = qfloat_suite();\n\n    sr = srunner_create(s);\n\n\n\n    srunner_run_all(sr, CK_NORMAL);\n\n    nf = srunner_ntests_failed(sr);\n\n    srunner_free(sr);\n\n\n\n    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n\n}\n", "idx": 1487, "_split": "test", "_hash": "123cb5f38a50a08d189c57a23c1f8289"}
{"project": "qemu", "commit_id": "d78c19b5cf4821d0c198f4132a085bdbf19dda4c", "target": 0, "func": "static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,\n\n                                target_ulong tce)\n\n{\n\n    IOMMUTLBEntry entry;\n\n    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);\n\n    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;\n\n\n\n    if (index >= tcet->nb_table) {\n\n        hcall_dprintf(\"spapr_vio_put_tce on out-of-bounds IOBA 0x\"\n\n                      TARGET_FMT_lx \"\\n\", ioba);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    tcet->table[index] = tce;\n\n\n\n    entry.target_as = &address_space_memory,\n\n    entry.iova = ioba & page_mask;\n\n    entry.translated_addr = tce & page_mask;\n\n    entry.addr_mask = ~page_mask;\n\n    entry.perm = spapr_tce_iommu_access_flags(tce);\n\n    memory_region_notify_iommu(&tcet->iommu, entry);\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 1497, "_split": "test", "_hash": "c135f4c94adc32abd7ec4130d1651be6"}
{"project": "qemu", "commit_id": "f73a2575a3bce8a3c487331c918d2c0f9b2e489d", "target": 0, "func": "static target_ulong h_enter(CPUState *env, sPAPREnvironment *spapr,\n\n                            target_ulong opcode, target_ulong *args)\n\n{\n\n    target_ulong flags = args[0];\n\n    target_ulong pte_index = args[1];\n\n    target_ulong pteh = args[2];\n\n    target_ulong ptel = args[3];\n\n    target_ulong i;\n\n    uint8_t *hpte;\n\n\n\n    /* only handle 4k and 16M pages for now */\n\n    if (pteh & HPTE_V_LARGE) {\n\n#if 0 /* We don't support 64k pages yet */\n\n        if ((ptel & 0xf000) == 0x1000) {\n\n            /* 64k page */\n\n        } else\n\n#endif\n\n        if ((ptel & 0xff000) == 0) {\n\n            /* 16M page */\n\n            /* lowest AVA bit must be 0 for 16M pages */\n\n            if (pteh & 0x80) {\n\n                return H_PARAMETER;\n\n            }\n\n        } else {\n\n            return H_PARAMETER;\n\n        }\n\n    }\n\n\n\n    /* FIXME: bounds check the pa? */\n\n\n\n    /* Check WIMG */\n\n    if ((ptel & HPTE_R_WIMG) != HPTE_R_M) {\n\n        return H_PARAMETER;\n\n    }\n\n    pteh &= ~0x60ULL;\n\n\n\n    if ((pte_index * HASH_PTE_SIZE_64) & ~env->htab_mask) {\n\n        return H_PARAMETER;\n\n    }\n\n    if (likely((flags & H_EXACT) == 0)) {\n\n        pte_index &= ~7ULL;\n\n        hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64);\n\n        for (i = 0; ; ++i) {\n\n            if (i == 8) {\n\n                return H_PTEG_FULL;\n\n            }\n\n            if (((ldq_p(hpte) & HPTE_V_VALID) == 0) &&\n\n                lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) {\n\n                break;\n\n            }\n\n            hpte += HASH_PTE_SIZE_64;\n\n        }\n\n    } else {\n\n        i = 0;\n\n        hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64);\n\n        if (!lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) {\n\n            return H_PTEG_FULL;\n\n        }\n\n    }\n\n    stq_p(hpte + (HASH_PTE_SIZE_64/2), ptel);\n\n    /* eieio();  FIXME: need some sort of barrier for smp? */\n\n    stq_p(hpte, pteh);\n\n\n\n    assert(!(ldq_p(hpte) & HPTE_V_HVLOCK));\n\n    args[0] = pte_index + i;\n\n    return H_SUCCESS;\n\n}\n", "idx": 1500, "_split": "test", "_hash": "e40b7721627e2b38f0f0fdf63b42fbbe"}
{"project": "qemu", "commit_id": "ffe30937c89dd67a53bf3f35b962701cd9d8f70e", "target": 1, "func": "static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,\n\n                                    TCGv arg2, int add_ca, int compute_ca,\n\n                                    int compute_ov)\n\n{\n\n    TCGv t0, t1;\n\n\n\n    if ((!compute_ca && !compute_ov) ||\n\n        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {\n\n        t0 = ret;\n\n    } else {\n\n        t0 = tcg_temp_local_new();\n\n    }\n\n\n\n    if (add_ca) {\n\n        t1 = tcg_temp_local_new();\n\n        tcg_gen_mov_tl(t1, cpu_ca);\n\n    } else {\n\n        TCGV_UNUSED(t1);\n\n    }\n\n\n\n    if (compute_ca) {\n\n        /* Start with XER CA disabled, the most likely case */\n\n        tcg_gen_movi_tl(cpu_ca, 0);\n\n    }\n\n    if (compute_ov) {\n\n        /* Start with XER OV disabled, the most likely case */\n\n        tcg_gen_movi_tl(cpu_ov, 0);\n\n    }\n\n\n\n    tcg_gen_add_tl(t0, arg1, arg2);\n\n\n\n    if (compute_ca) {\n\n        gen_op_arith_compute_ca(ctx, t0, arg1, 0);\n\n    }\n\n    if (add_ca) {\n\n        tcg_gen_add_tl(t0, t0, t1);\n\n        gen_op_arith_compute_ca(ctx, t0, t1, 0);\n\n        tcg_temp_free(t1);\n\n    }\n\n    if (compute_ov) {\n\n        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0);\n\n    }\n\n\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, t0);\n\n\n\n    if (!TCGV_EQUAL(t0, ret)) {\n\n        tcg_gen_mov_tl(ret, t0);\n\n        tcg_temp_free(t0);\n\n    }\n\n}\n", "idx": 1507, "_split": "test", "_hash": "8f6f4cfb72009782dda8986b297b1429"}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "int inet_dgram_opts(QemuOpts *opts)\n\n{\n\n    struct addrinfo ai, *peer = NULL, *local = NULL;\n\n    const char *addr;\n\n    const char *port;\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int sock = -1, rc;\n\n\n\n    /* lookup peer addr */\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;\n\n    ai.ai_family = PF_UNSPEC;\n\n    ai.ai_socktype = SOCK_DGRAM;\n\n\n\n    addr = qemu_opt_get(opts, \"host\");\n\n    port = qemu_opt_get(opts, \"port\");\n\n    if (addr == NULL || strlen(addr) == 0) {\n\n        addr = \"localhost\";\n\n    }\n\n    if (port == NULL || strlen(port) == 0) {\n\n        fprintf(stderr, \"inet_dgram: port not specified\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"ipv4\", 0))\n\n        ai.ai_family = PF_INET;\n\n    if (qemu_opt_get_bool(opts, \"ipv6\", 0))\n\n        ai.ai_family = PF_INET6;\n\n\n\n    if (0 != (rc = getaddrinfo(addr, port, &ai, &peer))) {\n\n        fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port,\n\n                gai_strerror(rc));\n\n\treturn -1;\n\n    }\n\n    if (sockets_debug) {\n\n        fprintf(stderr, \"%s: peer (%s:%s)\\n\", __FUNCTION__, addr, port);\n\n        inet_print_addrinfo(__FUNCTION__, peer);\n\n    }\n\n\n\n    /* lookup local addr */\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_PASSIVE;\n\n    ai.ai_family = peer->ai_family;\n\n    ai.ai_socktype = SOCK_DGRAM;\n\n\n\n    addr = qemu_opt_get(opts, \"localaddr\");\n\n    port = qemu_opt_get(opts, \"localport\");\n\n    if (addr == NULL || strlen(addr) == 0) {\n\n        addr = NULL;\n\n    }\n\n    if (!port || strlen(port) == 0)\n\n        port = \"0\";\n\n\n\n    if (0 != (rc = getaddrinfo(addr, port, &ai, &local))) {\n\n        fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port,\n\n                gai_strerror(rc));\n\n        return -1;\n\n    }\n\n    if (sockets_debug) {\n\n        fprintf(stderr, \"%s: local (%s:%s)\\n\", __FUNCTION__, addr, port);\n\n        inet_print_addrinfo(__FUNCTION__, local);\n\n    }\n\n\n\n    /* create socket */\n\n    sock = socket(peer->ai_family, peer->ai_socktype, peer->ai_protocol);\n\n    if (sock < 0) {\n\n        fprintf(stderr,\"%s: socket(%s): %s\\n\", __FUNCTION__,\n\n                inet_strfamily(peer->ai_family), strerror(errno));\n\n        goto err;\n\n    }\n\n    setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on));\n\n\n\n    /* bind socket */\n\n    if (getnameinfo((struct sockaddr*)local->ai_addr,local->ai_addrlen,\n\n                    uaddr,INET6_ADDRSTRLEN,uport,32,\n\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n        fprintf(stderr, \"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n        goto err;\n\n    }\n\n    if (bind(sock, local->ai_addr, local->ai_addrlen) < 0) {\n\n        fprintf(stderr,\"%s: bind(%s,%s,%d): OK\\n\", __FUNCTION__,\n\n                inet_strfamily(local->ai_family), uaddr, inet_getport(local));\n\n        goto err;\n\n    }\n\n\n\n    /* connect to peer */\n\n    if (getnameinfo((struct sockaddr*)peer->ai_addr, peer->ai_addrlen,\n\n                    uaddr, INET6_ADDRSTRLEN, uport, 32,\n\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n        fprintf(stderr, \"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n        goto err;\n\n    }\n\n    if (connect(sock,peer->ai_addr,peer->ai_addrlen) < 0) {\n\n        fprintf(stderr, \"%s: connect(%s,%s,%s,%s): %s\\n\", __FUNCTION__,\n\n                inet_strfamily(peer->ai_family),\n\n                peer->ai_canonname, uaddr, uport, strerror(errno));\n\n        goto err;\n\n    }\n\n\n\n    freeaddrinfo(local);\n\n    freeaddrinfo(peer);\n\n    return sock;\n\n\n\nerr:\n\n    if (-1 != sock)\n\n        closesocket(sock);\n\n    if (local)\n\n        freeaddrinfo(local);\n\n    if (peer)\n\n        freeaddrinfo(peer);\n\n    return -1;\n\n}\n", "idx": 1519, "_split": "test", "_hash": "2834dc55b7d6c9a68c45f2a517b06855"}
{"project": "qemu", "commit_id": "68d45bb61c5bbfb3999486f78cf026c1e79eb301", "target": 1, "func": "static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is_64)\n\n{\n\n    TCGReg datalo, datahi, addrlo, rbase;\n\n    TCGReg addrhi __attribute__((unused));\n\n    TCGMemOpIdx oi;\n\n    TCGMemOp opc, s_bits;\n\n#ifdef CONFIG_SOFTMMU\n\n    int mem_index;\n\n    tcg_insn_unit *label_ptr;\n\n#endif\n\n\n\n    datalo = *args++;\n\n    datahi = (TCG_TARGET_REG_BITS == 32 && is_64 ? *args++ : 0);\n\n    addrlo = *args++;\n\n    addrhi = (TCG_TARGET_REG_BITS < TARGET_LONG_BITS ? *args++ : 0);\n\n    oi = *args++;\n\n    opc = get_memop(oi);\n\n    s_bits = opc & MO_SIZE;\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n    mem_index = get_mmuidx(oi);\n\n    addrlo = tcg_out_tlb_read(s, s_bits, addrlo, addrhi, mem_index, true);\n\n\n\n    /* Load a pointer into the current opcode w/conditional branch-link. */\n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bc_noaddr(s, BC | BI(7, CR_EQ) | BO_COND_FALSE | LK);\n\n\n\n    rbase = TCG_REG_R3;\n\n#else  /* !CONFIG_SOFTMMU */\n\n    rbase = GUEST_BASE ? TCG_GUEST_BASE_REG : 0;\n\n    if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) {\n\n        tcg_out_ext32u(s, TCG_REG_TMP1, addrlo);\n\n        addrlo = TCG_REG_TMP1;\n\n    }\n\n#endif\n\n\n\n    if (TCG_TARGET_REG_BITS == 32 && s_bits == MO_64) {\n\n        if (opc & MO_BSWAP) {\n\n            tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));\n\n            tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo));\n\n            tcg_out32(s, LWBRX | TAB(datahi, rbase, TCG_REG_R0));\n\n        } else if (rbase != 0) {\n\n            tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));\n\n            tcg_out32(s, LWZX | TAB(datahi, rbase, addrlo));\n\n            tcg_out32(s, LWZX | TAB(datalo, rbase, TCG_REG_R0));\n\n        } else if (addrlo == datahi) {\n\n            tcg_out32(s, LWZ | TAI(datalo, addrlo, 4));\n\n            tcg_out32(s, LWZ | TAI(datahi, addrlo, 0));\n\n        } else {\n\n            tcg_out32(s, LWZ | TAI(datahi, addrlo, 0));\n\n            tcg_out32(s, LWZ | TAI(datalo, addrlo, 4));\n\n        }\n\n    } else {\n\n        uint32_t insn = qemu_ldx_opc[opc & (MO_BSWAP | MO_SSIZE)];\n\n        if (!HAVE_ISA_2_06 && insn == LDBRX) {\n\n            tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));\n\n            tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo));\n\n            tcg_out32(s, LWBRX | TAB(TCG_REG_R0, rbase, TCG_REG_R0));\n\n            tcg_out_rld(s, RLDIMI, datalo, TCG_REG_R0, 32, 0);\n\n        } else if (insn) {\n\n            tcg_out32(s, insn | TAB(datalo, rbase, addrlo));\n\n        } else {\n\n            insn = qemu_ldx_opc[opc & (MO_SIZE | MO_BSWAP)];\n\n            tcg_out32(s, insn | TAB(datalo, rbase, addrlo));\n\n            insn = qemu_exts_opc[s_bits];\n\n            tcg_out32(s, insn | RA(datalo) | RS(datalo));\n\n        }\n\n    }\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n    add_qemu_ldst_label(s, true, oi, datalo, datahi, addrlo, addrhi,\n\n                        s->code_ptr, label_ptr);\n\n#endif\n\n}\n", "idx": 1533, "_split": "test", "_hash": "4dcb6df2babf85bd514f48323f22bd8d"}
{"project": "qemu", "commit_id": "e40a67beeda6aa6e735546e9f08f3db41e23592a", "target": 0, "func": " void cpu_sh4_invalidate_tlb(CPUSH4State *s)\n\n{\n\n    int i;\n\n\n\n    /* UTLB */\n\n    for (i = 0; i < UTLB_SIZE; i++) {\n\n        tlb_t * entry = &s->utlb[i];\n\n        entry->v = 0;\n\n    }\n\n    /* ITLB */\n\n    for (i = 0; i < UTLB_SIZE; i++) {\n\n        tlb_t * entry = &s->utlb[i];\n\n        entry->v = 0;\n\n    }\n\n\n\n    tlb_flush(s, 1);\n\n}\n", "idx": 1557, "_split": "test", "_hash": "aadc23d4b2696e74918012ddd29d18d4"}
{"project": "qemu", "commit_id": "22156ab498acf5f8104801148732ae8e83f336a0", "target": 0, "func": "uint16_t net_checksum_finish(uint32_t sum)\n\n{\n\n    while (sum>>16)\n\n\tsum = (sum & 0xFFFF)+(sum >> 16);\n\n    return ~sum;\n\n}\n", "idx": 1573, "_split": "test", "_hash": "dc8e243f0508bf59369c767c9953ca07"}
{"project": "qemu", "commit_id": "45eb768c706d3a5fbe55224c589e8b4e252781d9", "target": 0, "func": "static void pci_init_mask_bridge(PCIDevice *d)\n\n{\n\n    /* PCI_PRIMARY_BUS, PCI_SECONDARY_BUS, PCI_SUBORDINATE_BUS and\n\n       PCI_SEC_LETENCY_TIMER */\n\n    memset(d->wmask + PCI_PRIMARY_BUS, 0xff, 4);\n\n\n\n    /* base and limit */\n\n    d->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff;\n\n    d->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff;\n\n    pci_set_word(d->wmask + PCI_MEMORY_BASE,\n\n                 PCI_MEMORY_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_MEMORY_LIMIT,\n\n                 PCI_MEMORY_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_PREF_MEMORY_BASE,\n\n                 PCI_PREF_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_PREF_MEMORY_LIMIT,\n\n                 PCI_PREF_RANGE_MASK & 0xffff);\n\n\n\n    /* PCI_PREF_BASE_UPPER32 and PCI_PREF_LIMIT_UPPER32 */\n\n    memset(d->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8);\n\n\n\n    /* Supported memory and i/o types */\n\n    d->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;\n\n    d->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16;\n\n    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_BASE,\n\n                               PCI_PREF_RANGE_TYPE_64);\n\n    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_LIMIT,\n\n                               PCI_PREF_RANGE_TYPE_64);\n\n\n\n/* TODO: add this define to pci_regs.h in linux and then in qemu. */\n\n#define  PCI_BRIDGE_CTL_VGA_16BIT\t0x10\t/* VGA 16-bit decode */\n\n#define  PCI_BRIDGE_CTL_DISCARD\t\t0x100\t/* Primary discard timer */\n\n#define  PCI_BRIDGE_CTL_SEC_DISCARD\t0x200\t/* Secondary discard timer */\n\n#define  PCI_BRIDGE_CTL_DISCARD_STATUS\t0x400\t/* Discard timer status */\n\n#define  PCI_BRIDGE_CTL_DISCARD_SERR\t0x800\t/* Discard timer SERR# enable */\n\n/*\n\n * TODO: Bridges default to 10-bit VGA decoding but we currently only\n\n * implement 16-bit decoding (no alias support).\n\n */\n\n    pci_set_word(d->wmask + PCI_BRIDGE_CONTROL,\n\n                 PCI_BRIDGE_CTL_PARITY |\n\n                 PCI_BRIDGE_CTL_SERR |\n\n                 PCI_BRIDGE_CTL_ISA |\n\n                 PCI_BRIDGE_CTL_VGA |\n\n                 PCI_BRIDGE_CTL_VGA_16BIT |\n\n                 PCI_BRIDGE_CTL_MASTER_ABORT |\n\n                 PCI_BRIDGE_CTL_BUS_RESET |\n\n                 PCI_BRIDGE_CTL_FAST_BACK |\n\n                 PCI_BRIDGE_CTL_DISCARD |\n\n                 PCI_BRIDGE_CTL_SEC_DISCARD |\n\n                 PCI_BRIDGE_CTL_DISCARD_SERR);\n\n    /* Below does not do anything as we never set this bit, put here for\n\n     * completeness. */\n\n    pci_set_word(d->w1cmask + PCI_BRIDGE_CONTROL,\n\n                 PCI_BRIDGE_CTL_DISCARD_STATUS);\n\n    d->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK;\n\n    d->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK;\n\n    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_BASE,\n\n                               PCI_PREF_RANGE_TYPE_MASK);\n\n    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_LIMIT,\n\n                               PCI_PREF_RANGE_TYPE_MASK);\n\n}\n", "idx": 1616, "_split": "test", "_hash": "e488482498e3d8060ccee12a339a2f01"}
{"project": "qemu", "commit_id": "2b48e10f888059a98043b4816769fa2a326a1d2c", "target": 0, "func": "static TranslationBlock *tb_alloc(target_ulong pc)\n\n{\n\n    TranslationBlock *tb;\n\n    TBContext *ctx;\n\n\n\n    assert_tb_locked();\n\n\n\n    tb = tcg_tb_alloc(&tcg_ctx);\n\n    if (unlikely(tb == NULL)) {\n\n        return NULL;\n\n    }\n\n    ctx = &tcg_ctx.tb_ctx;\n\n    if (unlikely(ctx->nb_tbs == ctx->tbs_size)) {\n\n        ctx->tbs_size *= 2;\n\n        ctx->tbs = g_renew(TranslationBlock *, ctx->tbs, ctx->tbs_size);\n\n    }\n\n    ctx->tbs[ctx->nb_tbs++] = tb;\n\n    tb->pc = pc;\n\n    tb->cflags = 0;\n\n    tb->invalid = false;\n\n    return tb;\n\n}\n", "idx": 1621, "_split": "test", "_hash": "a3dbbaa673a6691b1c50cdee4106c161"}
{"project": "qemu", "commit_id": "9cbaacf999b01b27dc3a22502705178057af66de", "target": 0, "func": "static void gpollfds_from_select(void)\n\n{\n\n    int fd;\n\n    for (fd = 0; fd <= nfds; fd++) {\n\n        int events = 0;\n\n        if (FD_ISSET(fd, &rfds)) {\n\n            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;\n\n        }\n\n        if (FD_ISSET(fd, &wfds)) {\n\n            events |= G_IO_OUT | G_IO_ERR;\n\n        }\n\n        if (FD_ISSET(fd, &xfds)) {\n\n            events |= G_IO_PRI;\n\n        }\n\n        if (events) {\n\n            GPollFD pfd = {\n\n                .fd = fd,\n\n                .events = events,\n\n            };\n\n            g_array_append_val(gpollfds, pfd);\n\n        }\n\n    }\n\n}\n", "idx": 1626, "_split": "test", "_hash": "5838fe6a936d65e20dd15f356c95d25e"}
{"project": "qemu", "commit_id": "87e459a810d7b1ec1638085b5a80ea3d9b43119a", "target": 1, "func": "static int megasas_pd_get_info_submit(SCSIDevice *sdev, int lun,\n\n                                      MegasasCmd *cmd)\n\n{\n\n    struct mfi_pd_info *info = cmd->iov_buf;\n\n    size_t dcmd_size = sizeof(struct mfi_pd_info);\n\n    uint64_t pd_size;\n\n    uint16_t pd_id = ((sdev->id & 0xFF) << 8) | (lun & 0xFF);\n\n    uint8_t cmdbuf[6];\n\n    SCSIRequest *req;\n\n    size_t len, resid;\n\n\n\n    if (!cmd->iov_buf) {\n\n        cmd->iov_buf = g_malloc0(dcmd_size);\n\n        info = cmd->iov_buf;\n\n        info->inquiry_data[0] = 0x7f; /* Force PQual 0x3, PType 0x1f */\n\n        info->vpd_page83[0] = 0x7f;\n\n        megasas_setup_inquiry(cmdbuf, 0, sizeof(info->inquiry_data));\n\n        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);\n\n        if (!req) {\n\n            trace_megasas_dcmd_req_alloc_failed(cmd->index,\n\n                                                \"PD get info std inquiry\");\n\n            g_free(cmd->iov_buf);\n\n            cmd->iov_buf = NULL;\n\n            return MFI_STAT_FLASH_ALLOC_FAIL;\n\n        }\n\n        trace_megasas_dcmd_internal_submit(cmd->index,\n\n                                           \"PD get info std inquiry\", lun);\n\n        len = scsi_req_enqueue(req);\n\n        if (len > 0) {\n\n            cmd->iov_size = len;\n\n            scsi_req_continue(req);\n\n        }\n\n        return MFI_STAT_INVALID_STATUS;\n\n    } else if (info->inquiry_data[0] != 0x7f && info->vpd_page83[0] == 0x7f) {\n\n        megasas_setup_inquiry(cmdbuf, 0x83, sizeof(info->vpd_page83));\n\n        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);\n\n        if (!req) {\n\n            trace_megasas_dcmd_req_alloc_failed(cmd->index,\n\n                                                \"PD get info vpd inquiry\");\n\n            return MFI_STAT_FLASH_ALLOC_FAIL;\n\n        }\n\n        trace_megasas_dcmd_internal_submit(cmd->index,\n\n                                           \"PD get info vpd inquiry\", lun);\n\n        len = scsi_req_enqueue(req);\n\n        if (len > 0) {\n\n            cmd->iov_size = len;\n\n            scsi_req_continue(req);\n\n        }\n\n        return MFI_STAT_INVALID_STATUS;\n\n    }\n\n    /* Finished, set FW state */\n\n    if ((info->inquiry_data[0] >> 5) == 0) {\n\n        if (megasas_is_jbod(cmd->state)) {\n\n            info->fw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM);\n\n        } else {\n\n            info->fw_state = cpu_to_le16(MFI_PD_STATE_ONLINE);\n\n        }\n\n    } else {\n\n        info->fw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE);\n\n    }\n\n\n\n    info->ref.v.device_id = cpu_to_le16(pd_id);\n\n    info->state.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD|\n\n                                          MFI_PD_DDF_TYPE_INTF_SAS);\n\n    blk_get_geometry(sdev->conf.blk, &pd_size);\n\n    info->raw_size = cpu_to_le64(pd_size);\n\n    info->non_coerced_size = cpu_to_le64(pd_size);\n\n    info->coerced_size = cpu_to_le64(pd_size);\n\n    info->encl_device_id = 0xFFFF;\n\n    info->slot_number = (sdev->id & 0xFF);\n\n    info->path_info.count = 1;\n\n    info->path_info.sas_addr[0] =\n\n        cpu_to_le64(megasas_get_sata_addr(pd_id));\n\n    info->connected_port_bitmap = 0x1;\n\n    info->device_speed = 1;\n\n    info->link_speed = 1;\n\n    resid = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg);\n\n    g_free(cmd->iov_buf);\n\n    cmd->iov_size = dcmd_size - resid;\n\n    cmd->iov_buf = NULL;\n\n    return MFI_STAT_OK;\n\n}\n", "idx": 1672, "_split": "test", "_hash": "d9b5a53cc8c1cfa0a25e802ac89921c9"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_isel(DisasContext *ctx)\n\n{\n\n    int l1, l2;\n\n    uint32_t bi = rC(ctx->opcode);\n\n    uint32_t mask;\n\n    TCGv_i32 t0;\n\n\n\n    l1 = gen_new_label();\n\n    l2 = gen_new_label();\n\n\n\n    mask = 0x08 >> (bi & 0x03);\n\n    t0 = tcg_temp_new_i32();\n\n    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);\n\n    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);\n\n    if (rA(ctx->opcode) == 0)\n\n        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);\n\n    else\n\n        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);\n\n    gen_set_label(l2);\n\n    tcg_temp_free_i32(t0);\n\n}\n", "idx": 1710, "_split": "test", "_hash": "40bc9171af26ee6a997ee4625668c697"}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "static void stream_process_mem2s(struct Stream *s,\n\n                                 StreamSlave *tx_dev)\n\n{\n\n    uint32_t prev_d;\n\n    unsigned char txbuf[16 * 1024];\n\n    unsigned int txlen;\n\n    uint32_t app[6];\n\n\n\n    if (!stream_running(s) || stream_idle(s)) {\n\n        return;\n\n    }\n\n\n\n    while (1) {\n\n        stream_desc_load(s, s->regs[R_CURDESC]);\n\n\n\n        if (s->desc.status & SDESC_STATUS_COMPLETE) {\n\n            s->regs[R_DMASR] |= DMASR_HALTED;\n\n            break;\n\n        }\n\n\n\n        if (stream_desc_sof(&s->desc)) {\n\n            s->pos = 0;\n\n            memcpy(app, s->desc.app, sizeof app);\n\n        }\n\n\n\n        txlen = s->desc.control & SDESC_CTRL_LEN_MASK;\n\n        if ((txlen + s->pos) > sizeof txbuf) {\n\n            hw_error(\"%s: too small internal txbuf! %d\\n\", __func__,\n\n                     txlen + s->pos);\n\n        }\n\n\n\n        cpu_physical_memory_read(s->desc.buffer_address,\n\n                                 txbuf + s->pos, txlen);\n\n        s->pos += txlen;\n\n\n\n        if (stream_desc_eof(&s->desc)) {\n\n            stream_push(tx_dev, txbuf, s->pos, app);\n\n            s->pos = 0;\n\n            stream_complete(s);\n\n        }\n\n\n\n        /* Update the descriptor.  */\n\n        s->desc.status = txlen | SDESC_STATUS_COMPLETE;\n\n        stream_desc_store(s, s->regs[R_CURDESC]);\n\n\n\n        /* Advance.  */\n\n        prev_d = s->regs[R_CURDESC];\n\n        s->regs[R_CURDESC] = s->desc.nxtdesc;\n\n        if (prev_d == s->regs[R_TAILDESC]) {\n\n            s->regs[R_DMASR] |= DMASR_IDLE;\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 1712, "_split": "test", "_hash": "0f499309a863750aa2e5348357403725"}
{"project": "qemu", "commit_id": "e5fda03839e3c61b01d6c60de5625501d01c69d0", "target": 1, "func": "static inline void bt_hci_event_complete_read_local_name(struct bt_hci_s *hci)\n\n{\n\n    read_local_name_rp params;\n\n    params.status = HCI_SUCCESS;\n\n    memset(params.name, 0, sizeof(params.name));\n\n    if (hci->device.lmp_name)\n\n        strncpy(params.name, hci->device.lmp_name, sizeof(params.name));\n\n\n\n    bt_hci_event_complete(hci, &params, READ_LOCAL_NAME_RP_SIZE);\n\n}\n", "idx": 1721, "_split": "test", "_hash": "ab56138587fb8eb7ca3c350c3ca611b2"}
{"project": "qemu", "commit_id": "e2b72cb6e0443d90d7ab037858cb6834b6cca852", "target": 1, "func": "static bool vnc_should_update(VncState *vs)\n\n{\n\n    switch (vs->update) {\n\n    case VNC_STATE_UPDATE_NONE:\n\n        break;\n\n    case VNC_STATE_UPDATE_INCREMENTAL:\n\n        /* Only allow incremental updates if the output buffer\n\n         * is empty, or if audio capture is enabled.\n\n         */\n\n        if (!vs->output.offset || vs->audio_cap) {\n\n            return true;\n\n        }\n\n        break;\n\n    case VNC_STATE_UPDATE_FORCE:\n\n        return true;\n\n    }\n\n    return false;\n\n}\n", "idx": 1726, "_split": "test", "_hash": "ac8f8d270150adb01d1ccfb36c306af7"}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtoll_whitespace(void)\n\n{\n\n    const char *str = \"  \\t  \";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    int64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoll(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 1736, "_split": "test", "_hash": "067d6b366e5bb7cc293114a836f2329d"}
{"project": "qemu", "commit_id": "aaf89c8a49a8c1259b6b181d701070c6df83f3d7", "target": 0, "func": "static void test_migrate(void)\n\n{\n\n    char *uri = g_strdup_printf(\"unix:%s/migsocket\", tmpfs);\n\n    QTestState *global = global_qtest, *from, *to;\n\n    unsigned char dest_byte_a, dest_byte_b, dest_byte_c, dest_byte_d;\n\n    gchar *cmd;\n\n    QDict *rsp;\n\n\n\n    char *bootpath = g_strdup_printf(\"%s/bootsect\", tmpfs);\n\n    FILE *bootfile = fopen(bootpath, \"wb\");\n\n\n\n    got_stop = false;\n\n    g_assert_cmpint(fwrite(bootsect, 512, 1, bootfile), ==, 1);\n\n    fclose(bootfile);\n\n\n\n    cmd = g_strdup_printf(\"-machine accel=kvm:tcg -m 150M\"\n\n                          \" -name pcsource,debug-threads=on\"\n\n                          \" -serial file:%s/src_serial\"\n\n                          \" -drive file=%s,format=raw\",\n\n                          tmpfs, bootpath);\n\n    from = qtest_start(cmd);\n\n    g_free(cmd);\n\n\n\n    cmd = g_strdup_printf(\"-machine accel=kvm:tcg -m 150M\"\n\n                          \" -name pcdest,debug-threads=on\"\n\n                          \" -serial file:%s/dest_serial\"\n\n                          \" -drive file=%s,format=raw\"\n\n                          \" -incoming %s\",\n\n                          tmpfs, bootpath, uri);\n\n    to = qtest_init(cmd);\n\n    g_free(cmd);\n\n\n\n    global_qtest = from;\n\n    rsp = qmp(\"{ 'execute': 'migrate-set-capabilities',\"\n\n                  \"'arguments': { \"\n\n                      \"'capabilities': [ {\"\n\n                          \"'capability': 'postcopy-ram',\"\n\n                          \"'state': true } ] } }\");\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    global_qtest = to;\n\n    rsp = qmp(\"{ 'execute': 'migrate-set-capabilities',\"\n\n                  \"'arguments': { \"\n\n                      \"'capabilities': [ {\"\n\n                          \"'capability': 'postcopy-ram',\"\n\n                          \"'state': true } ] } }\");\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    /* We want to pick a speed slow enough that the test completes\n\n     * quickly, but that it doesn't complete precopy even on a slow\n\n     * machine, so also set the downtime.\n\n     */\n\n    global_qtest = from;\n\n    rsp = qmp(\"{ 'execute': 'migrate_set_speed',\"\n\n              \"'arguments': { 'value': 100000000 } }\");\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    /* 1ms downtime - it should never finish precopy */\n\n    rsp = qmp(\"{ 'execute': 'migrate_set_downtime',\"\n\n              \"'arguments': { 'value': 0.001 } }\");\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n\n\n    /* Wait for the first serial output from the source */\n\n    wait_for_serial(\"src_serial\");\n\n\n\n    cmd = g_strdup_printf(\"{ 'execute': 'migrate',\"\n\n                          \"'arguments': { 'uri': '%s' } }\",\n\n                          uri);\n\n    rsp = qmp(cmd);\n\n    g_free(cmd);\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    wait_for_migration_pass();\n\n\n\n    rsp = return_or_event(qmp(\"{ 'execute': 'migrate-start-postcopy' }\"));\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    if (!got_stop) {\n\n        qmp_eventwait(\"STOP\");\n\n    }\n\n\n\n    global_qtest = to;\n\n    qmp_eventwait(\"RESUME\");\n\n\n\n    wait_for_serial(\"dest_serial\");\n\n    global_qtest = from;\n\n    wait_for_migration_complete();\n\n\n\n    qtest_quit(from);\n\n\n\n    global_qtest = to;\n\n\n\n    qtest_memread(to, start_address, &dest_byte_a, 1);\n\n\n\n    /* Destination still running, wait for a byte to change */\n\n    do {\n\n        qtest_memread(to, start_address, &dest_byte_b, 1);\n\n        usleep(10 * 1000);\n\n    } while (dest_byte_a == dest_byte_b);\n\n\n\n    qmp(\"{ 'execute' : 'stop'}\");\n\n    /* With it stopped, check nothing changes */\n\n    qtest_memread(to, start_address, &dest_byte_c, 1);\n\n    sleep(1);\n\n    qtest_memread(to, start_address, &dest_byte_d, 1);\n\n    g_assert_cmpint(dest_byte_c, ==, dest_byte_d);\n\n\n\n    check_guests_ram();\n\n\n\n    qtest_quit(to);\n\n    g_free(uri);\n\n\n\n    global_qtest = global;\n\n\n\n    cleanup(\"bootsect\");\n\n    cleanup(\"migsocket\");\n\n    cleanup(\"src_serial\");\n\n    cleanup(\"dest_serial\");\n\n}\n", "idx": 1760, "_split": "test", "_hash": "7ff48f4b1c3e27e6cf94236a6c3de6af"}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,\n\n                                          bool tso_enable)\n\n{\n\n    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;\n\n    uint16_t l3_proto;\n\n\n\n    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,\n\n        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);\n\n\n\n    if (!tso_enable) {\n\n        goto func_exit;\n\n    }\n\n\n\n    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,\n\n                          pkt->l4proto);\n\n\n\nfunc_exit:\n\n    return rc;\n\n}\n", "idx": 1770, "_split": "test", "_hash": "f814ad5a0f0e8badaa1d44c0479118e3"}
{"project": "qemu", "commit_id": "5e30a07d6d70d3073ff61e6db79d61c2b688502f", "target": 1, "func": "static int scsi_req_length(SCSIRequest *req, uint8_t *cmd)\n\n{\n\n    switch (cmd[0] >> 5) {\n\n    case 0:\n\n        req->cmd.xfer = cmd[4];\n\n        req->cmd.len = 6;\n\n        /* length 0 means 256 blocks */\n\n        if (req->cmd.xfer == 0)\n\n            req->cmd.xfer = 256;\n\n        break;\n\n    case 1:\n\n    case 2:\n\n        req->cmd.xfer = cmd[8] | (cmd[7] << 8);\n\n        req->cmd.len = 10;\n\n        break;\n\n    case 4:\n\n        req->cmd.xfer = cmd[13] | (cmd[12] << 8) | (cmd[11] << 16) | (cmd[10] << 24);\n\n        req->cmd.len = 16;\n\n        break;\n\n    case 5:\n\n        req->cmd.xfer = cmd[9] | (cmd[8] << 8) | (cmd[7] << 16) | (cmd[6] << 24);\n\n        req->cmd.len = 12;\n\n        break;\n\n    default:\n\n        trace_scsi_req_parse_bad(req->dev->id, req->lun, req->tag, cmd[0]);\n\n        return -1;\n\n    }\n\n\n\n    switch(cmd[0]) {\n\n    case TEST_UNIT_READY:\n\n    case START_STOP:\n\n    case SEEK_6:\n\n    case WRITE_FILEMARKS:\n\n    case SPACE:\n\n    case RESERVE:\n\n    case RELEASE:\n\n    case ERASE:\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n    case VERIFY:\n\n    case SEEK_10:\n\n    case SYNCHRONIZE_CACHE:\n\n    case LOCK_UNLOCK_CACHE:\n\n    case LOAD_UNLOAD:\n\n    case SET_CD_SPEED:\n\n    case SET_LIMITS:\n\n    case WRITE_LONG:\n\n    case MOVE_MEDIUM:\n\n    case UPDATE_BLOCK:\n\n        req->cmd.xfer = 0;\n\n        break;\n\n    case MODE_SENSE:\n\n        break;\n\n    case WRITE_SAME:\n\n        req->cmd.xfer = 1;\n\n        break;\n\n    case READ_CAPACITY:\n\n        req->cmd.xfer = 8;\n\n        break;\n\n    case READ_BLOCK_LIMITS:\n\n        req->cmd.xfer = 6;\n\n        break;\n\n    case READ_POSITION:\n\n        req->cmd.xfer = 20;\n\n        break;\n\n    case SEND_VOLUME_TAG:\n\n        req->cmd.xfer *= 40;\n\n        break;\n\n    case MEDIUM_SCAN:\n\n        req->cmd.xfer *= 8;\n\n        break;\n\n    case WRITE_10:\n\n    case WRITE_VERIFY:\n\n    case WRITE_6:\n\n    case WRITE_12:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_16:\n\n        req->cmd.xfer *= req->dev->blocksize;\n\n        break;\n\n    case READ_10:\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case READ_12:\n\n    case READ_16:\n\n        req->cmd.xfer *= req->dev->blocksize;\n\n        break;\n\n    case INQUIRY:\n\n        req->cmd.xfer = cmd[4] | (cmd[3] << 8);\n\n        break;\n\n    case MAINTENANCE_OUT:\n\n    case MAINTENANCE_IN:\n\n        if (req->dev->type == TYPE_ROM) {\n\n            /* GPCMD_REPORT_KEY and GPCMD_SEND_KEY from multi media commands */\n\n            req->cmd.xfer = cmd[9] | (cmd[8] << 8);\n\n        }\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 1783, "_split": "test", "_hash": "0fd7df3be4e12da1505f968118cc35af"}
{"project": "qemu", "commit_id": "6977afda16c1e09dfbce4bdd877459a287269b72", "target": 1, "func": "int kvmppc_reset_htab(int shift_hint)\n\n{\n\n    uint32_t shift = shift_hint;\n\n\n\n    if (!kvm_enabled()) {\n\n        /* Full emulation, tell caller to allocate htab itself */\n\n        return 0;\n\n    }\n\n    if (kvm_check_extension(kvm_state, KVM_CAP_PPC_ALLOC_HTAB)) {\n\n        int ret;\n\n        ret = kvm_vm_ioctl(kvm_state, KVM_PPC_ALLOCATE_HTAB, &shift);\n\n        if (ret == -ENOTTY) {\n\n            /* At least some versions of PR KVM advertise the\n\n             * capability, but don't implement the ioctl().  Oops.\n\n             * Return 0 so that we allocate the htab in qemu, as is\n\n             * correct for PR. */\n\n            return 0;\n\n        } else if (ret < 0) {\n\n            return ret;\n\n        }\n\n        return shift;\n\n    }\n\n\n\n    /* We have a kernel that predates the htab reset calls.  For PR\n\n     * KVM, we need to allocate the htab ourselves, for an HV KVM of\n\n     * this era, it has allocated a 16MB fixed size hash table already. */\n\n    if (kvmppc_is_pr(kvm_state)) {\n\n        /* PR - tell caller to allocate htab */\n\n        return 0;\n\n    } else {\n\n        /* HV - assume 16MB kernel allocated htab */\n\n        return 24;\n\n    }\n\n}\n", "idx": 1802, "_split": "test", "_hash": "067525273bb79740f991431f6c2417e6"}
{"project": "qemu", "commit_id": "97f1c45c6f456572e5b504b8614e4a69e23b8e3a", "target": 1, "func": "static void vpc_close(BlockDriverState *bs)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    g_free(s->pagetable);\n\n#ifdef CACHE\n\n    g_free(s->pageentry_u8);\n\n#endif\n\n\n\n    migrate_del_blocker(s->migration_blocker);\n\n    error_free(s->migration_blocker);\n\n}\n", "idx": 1817, "_split": "test", "_hash": "531a9dbcb61baf1435b56ffffbefbfae"}
{"project": "qemu", "commit_id": "c88305027d5a8dbeaacf04ad2ceba79a5c5fb91e", "target": 1, "func": "POWERPC_FAMILY(POWER9)(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n\n\n    dc->fw_name = \"PowerPC,POWER9\";\n\n    dc->desc = \"POWER9\";\n\n    dc->props = powerpc_servercpu_properties;\n\n    pcc->pvr_match = ppc_pvr_match_power9;\n\n    pcc->pcr_mask = PCR_COMPAT_2_05 | PCR_COMPAT_2_06 | PCR_COMPAT_2_07;\n\n    pcc->pcr_supported = PCR_COMPAT_3_00 | PCR_COMPAT_2_07 | PCR_COMPAT_2_06 |\n\n                         PCR_COMPAT_2_05;\n\n    pcc->init_proc = init_proc_POWER9;\n\n    pcc->check_pow = check_pow_nocheck;\n\n    cc->has_work = cpu_has_work_POWER9;\n\n    pcc->insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB |\n\n                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |\n\n                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |\n\n                       PPC_FLOAT_FRSQRTES |\n\n                       PPC_FLOAT_STFIWX |\n\n                       PPC_FLOAT_EXT |\n\n                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |\n\n                       PPC_MEM_SYNC | PPC_MEM_EIEIO |\n\n                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |\n\n                       PPC_64B | PPC_64BX | PPC_ALTIVEC |\n\n                       PPC_SEGMENT_64B | PPC_SLBI |\n\n                       PPC_POPCNTB | PPC_POPCNTWD |\n\n                       PPC_CILDST;\n\n    pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |\n\n                        PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |\n\n                        PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 |\n\n                        PPC2_FP_TST_ISA206 | PPC2_BCTAR_ISA207 |\n\n                        PPC2_LSQ_ISA207 | PPC2_ALTIVEC_207 |\n\n                        PPC2_ISA205 | PPC2_ISA207S | PPC2_FP_CVT_S64 |\n\n                        PPC2_TM | PPC2_PM_ISA206 | PPC2_ISA300;\n\n    pcc->msr_mask = (1ull << MSR_SF) |\n\n                    (1ull << MSR_TM) |\n\n                    (1ull << MSR_VR) |\n\n                    (1ull << MSR_VSX) |\n\n                    (1ull << MSR_EE) |\n\n                    (1ull << MSR_PR) |\n\n                    (1ull << MSR_FP) |\n\n                    (1ull << MSR_ME) |\n\n                    (1ull << MSR_FE0) |\n\n                    (1ull << MSR_SE) |\n\n                    (1ull << MSR_DE) |\n\n                    (1ull << MSR_FE1) |\n\n                    (1ull << MSR_IR) |\n\n                    (1ull << MSR_DR) |\n\n                    (1ull << MSR_PMM) |\n\n                    (1ull << MSR_RI) |\n\n                    (1ull << MSR_LE);\n\n    pcc->mmu_model = POWERPC_MMU_3_00;\n\n#if defined(CONFIG_SOFTMMU)\n\n    pcc->handle_mmu_fault = ppc64_v3_handle_mmu_fault;\n\n    /* segment page size remain the same */\n\n    pcc->sps = &POWER7_POWER8_sps;\n\n    pcc->radix_page_info = &POWER9_radix_page_info;\n\n#endif\n\n    pcc->excp_model = POWERPC_EXCP_POWER8;\n\n    pcc->bus_model = PPC_FLAGS_INPUT_POWER7;\n\n    pcc->bfd_mach = bfd_mach_ppc64;\n\n    pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |\n\n                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |\n\n                 POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR |\n\n                 POWERPC_FLAG_VSX | POWERPC_FLAG_TM;\n\n    pcc->l1_dcache_size = 0x8000;\n\n    pcc->l1_icache_size = 0x8000;\n\n    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_lpcr;\n\n}\n", "idx": 1822, "_split": "test", "_hash": "8d2deb0cde765cebe55e706a966264de"}
{"project": "qemu", "commit_id": "de00982e9e14e2d6ba3d148f02c5a1e94deaa985", "target": 0, "func": "static int xen_platform_initfn(PCIDevice *dev)\n\n{\n\n    PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);\n\n    uint8_t *pci_conf;\n\n\n\n    pci_conf = d->pci_dev.config;\n\n\n\n    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n\n\n\n    pci_config_set_prog_interface(pci_conf, 0);\n\n\n\n    pci_conf[PCI_INTERRUPT_PIN] = 1;\n\n\n\n    pci_register_bar(&d->pci_dev, 0, 0x100,\n\n            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);\n\n\n\n    /* reserve 16MB mmio address for share memory*/\n\n    pci_register_bar(&d->pci_dev, 1, 0x1000000,\n\n            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);\n\n\n\n    platform_fixed_ioport_init(d);\n\n\n\n    return 0;\n\n}\n", "idx": 1894, "_split": "test", "_hash": "6ec8e8d44a546819033bc71b8818204e"}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,\n\n                         V9fsPath *dir_path, const char *name, FsCred *credp)\n\n{\n\n    int retval;\n\n    V9fsString fullname, target;\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_init(&target);\n\n\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    v9fs_string_sprintf(&target, \"%s\", oldpath);\n\n\n\n    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, \"ssdd\",\n\n                          &target, &fullname, credp->fc_uid, credp->fc_gid);\n\n    v9fs_string_free(&fullname);\n\n    v9fs_string_free(&target);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n        retval = -1;\n\n    }\n\n    return retval;\n\n}\n", "idx": 1896, "_split": "test", "_hash": "64a49c9e854f5c55daf231ec1762b972"}
{"project": "qemu", "commit_id": "ea486926b07d2ebd73ef67315ebb1eecf39faf5a", "target": 0, "func": "static int vfio_enable_intx(VFIODevice *vdev)\n\n{\n\n    VFIOIRQSetFD irq_set_fd = {\n\n        .irq_set = {\n\n            .argsz = sizeof(irq_set_fd),\n\n            .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER,\n\n            .index = VFIO_PCI_INTX_IRQ_INDEX,\n\n            .start = 0,\n\n            .count = 1,\n\n        },\n\n    };\n\n    uint8_t pin = vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1);\n\n    int ret;\n\n\n\n    if (vdev->intx.disabled || !pin) {\n\n        return 0;\n\n    }\n\n\n\n    vfio_disable_interrupts(vdev);\n\n\n\n    vdev->intx.pin = pin - 1; /* Pin A (1) -> irq[0] */\n\n    ret = event_notifier_init(&vdev->intx.interrupt, 0);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: event_notifier_init failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    irq_set_fd.fd = event_notifier_get_fd(&vdev->intx.interrupt);\n\n    qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, vdev);\n\n\n\n    if (ioctl(vdev->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) {\n\n        error_report(\"vfio: Error: Failed to setup INTx fd: %m\\n\");\n\n        return -errno;\n\n    }\n\n\n\n    /*\n\n     * Disable mmaps so we can trap on BAR accesses.  We interpret any\n\n     * access as a response to an interrupt and unmask the physical\n\n     * device.  The device will re-assert if the interrupt is still\n\n     * pending.  We'll likely retrigger on the host multiple times per\n\n     * guest interrupt, but without EOI notification it's better than\n\n     * nothing.  Acceleration paths through KVM will avoid this.\n\n     */\n\n    vfio_mmap_set_enabled(vdev, false);\n\n\n\n    vdev->interrupt = VFIO_INT_INTx;\n\n\n\n    DPRINTF(\"%s(%04x:%02x:%02x.%x)\\n\", __func__, vdev->host.domain,\n\n            vdev->host.bus, vdev->host.slot, vdev->host.function);\n\n\n\n    return 0;\n\n}\n", "idx": 1900, "_split": "test", "_hash": "a944a993663871df759a5767a9adea17"}
{"project": "qemu", "commit_id": "fc89efe693278c79273f3bbf6b581e8a749c85b0", "target": 0, "func": "void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)\n\n{\n\n    int i = 0;\n\n    int x = 0;\n\n    uint32_t l_64 = (l + 1) / 8;\n\n\n\n    HELPER_LOG(\"%s l %d dest %\" PRIx64 \" src %\" PRIx64 \"\\n\",\n\n               __func__, l, dest, src);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if ((l > 32) &&\n\n        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&\n\n        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {\n\n        if (dest == (src + 1)) {\n\n            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));\n\n            return;\n\n        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {\n\n            mvc_fast_memmove(env, l + 1, dest, src);\n\n            return;\n\n        }\n\n    }\n\n#else\n\n    if (dest == (src + 1)) {\n\n        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);\n\n        return;\n\n    /* mvc and memmove do not behave the same when areas overlap! */\n\n    } else if ((dest < src) || (src + l < dest)) {\n\n        memmove(g2h(dest), g2h(src), l + 1);\n\n        return;\n\n    }\n\n#endif\n\n\n\n    /* handle the parts that fit into 8-byte loads/stores */\n\n    if ((dest + 8 <= src) || (src + 8 <= dest)) {\n\n        for (i = 0; i < l_64; i++) {\n\n            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));\n\n            x += 8;\n\n        }\n\n    }\n\n\n\n    /* slow version with byte accesses which always work */\n\n    for (i = x; i <= l; i++) {\n\n        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));\n\n    }\n\n}\n", "idx": 1902, "_split": "test", "_hash": "5ec8826d79fd101fa77e9ce9c021c082"}
{"project": "qemu", "commit_id": "ba0e276db4b51bd2255a5d5ff8902c70d32ade40", "target": 0, "func": "void helper_store_fpcr (uint64_t val)\n\n{\n\n#ifdef CONFIG_SOFTFLOAT\n\n    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);\n\n#endif\n\n    switch ((val >> 58) & 3) {\n\n    case 0:\n\n        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);\n\n        break;\n\n    case 1:\n\n        set_float_rounding_mode(float_round_down, &FP_STATUS);\n\n        break;\n\n    case 2:\n\n        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);\n\n        break;\n\n    case 3:\n\n        set_float_rounding_mode(float_round_up, &FP_STATUS);\n\n        break;\n\n    }\n\n}\n", "idx": 1905, "_split": "test", "_hash": "30e0c5715474d8f2cae23af4ed1ea09f"}
{"project": "qemu", "commit_id": "ee9a569ab88edd0755402aaf31ec0c69decf7756", "target": 0, "func": "void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)\n\n{\n\n    tcet->bypass = bypass;\n\n}\n", "idx": 1909, "_split": "test", "_hash": "eaede4e2c9680e08e8795f30cec7f1c1"}
{"project": "qemu", "commit_id": "9abc62f6445795522d1bf5bf17f642e44eaf032d", "target": 0, "func": "void qemu_system_wakeup_request(WakeupReason reason)\n\n{\n\n    if (!is_suspended) {\n\n        return;\n\n    }\n\n    if (!(wakeup_reason_mask & (1 << reason))) {\n\n        return;\n\n    }\n\n    runstate_set(RUN_STATE_RUNNING);\n\n    monitor_protocol_event(QEVENT_WAKEUP, NULL);\n\n    notifier_list_notify(&wakeup_notifiers, &reason);\n\n    reset_requested = 1;\n\n    qemu_notify_event();\n\n    is_suspended = false;\n\n}\n", "idx": 1917, "_split": "test", "_hash": "e27d20b2eb7c69fae10fbbc5669ae775"}
{"project": "qemu", "commit_id": "6b9b8758c15f3bc2875dbd6e2d03c5362b8d6902", "target": 0, "func": "static int virtio_net_device_exit(DeviceState *qdev)\n\n{\n\n    VirtIONet *n = VIRTIO_NET(qdev);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);\n\n    int i;\n\n\n\n    /* This will stop vhost backend if appropriate. */\n\n    virtio_net_set_status(vdev, 0);\n\n\n\n    unregister_savevm(qdev, \"virtio-net\", n);\n\n\n\n    if (n->netclient_name) {\n\n        g_free(n->netclient_name);\n\n        n->netclient_name = NULL;\n\n    }\n\n    if (n->netclient_type) {\n\n        g_free(n->netclient_type);\n\n        n->netclient_type = NULL;\n\n    }\n\n\n\n    g_free(n->mac_table.macs);\n\n    g_free(n->vlans);\n\n\n\n    for (i = 0; i < n->max_queues; i++) {\n\n        VirtIONetQueue *q = &n->vqs[i];\n\n        NetClientState *nc = qemu_get_subqueue(n->nic, i);\n\n\n\n        qemu_purge_queued_packets(nc);\n\n\n\n        if (q->tx_timer) {\n\n            timer_del(q->tx_timer);\n\n            timer_free(q->tx_timer);\n\n        } else {\n\n            qemu_bh_delete(q->tx_bh);\n\n        }\n\n    }\n\n\n\n    g_free(n->vqs);\n\n    qemu_del_nic(n->nic);\n\n    virtio_cleanup(vdev);\n\n\n\n    return 0;\n\n}\n", "idx": 1981, "_split": "test", "_hash": "647d5c89945379710300a84d629e0f99"}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void gen_neon_widen(TCGv dest, TCGv src, int size, int u)\n\n{\n\n    if (u) {\n\n        switch (size) {\n\n        case 0: gen_helper_neon_widen_u8(dest, src); break;\n\n        case 1: gen_helper_neon_widen_u16(dest, src); break;\n\n        case 2: tcg_gen_extu_i32_i64(dest, src); break;\n\n        default: abort();\n\n        }\n\n    } else {\n\n        switch (size) {\n\n        case 0: gen_helper_neon_widen_s8(dest, src); break;\n\n        case 1: gen_helper_neon_widen_s16(dest, src); break;\n\n        case 2: tcg_gen_ext_i32_i64(dest, src); break;\n\n        default: abort();\n\n        }\n\n    }\n\n    dead_tmp(src);\n\n}\n", "idx": 1983, "_split": "test", "_hash": "40e0c43d0e0a9fc25a6f0e0babba57fd"}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int sd_create_branch(BDRVSheepdogState *s)\n\n{\n\n    int ret, fd;\n\n    uint32_t vid;\n\n    char *buf;\n\n\n\n    dprintf(\"%\" PRIx32 \" is snapshot.\\n\", s->inode.vdi_id);\n\n\n\n    buf = g_malloc(SD_INODE_SIZE);\n\n\n\n    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,\n\n                       s->addr, s->port);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    dprintf(\"%\" PRIx32 \" is created.\\n\", vid);\n\n\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        error_report(\"failed to connect\");\n\n        ret = fd;\n\n        goto out;\n\n    }\n\n\n\n    ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,\n\n                      SD_INODE_SIZE, 0, s->cache_enabled);\n\n\n\n    closesocket(fd);\n\n\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    memcpy(&s->inode, buf, sizeof(s->inode));\n\n\n\n    s->is_snapshot = false;\n\n    ret = 0;\n\n    dprintf(\"%\" PRIx32 \" was newly created.\\n\", s->inode.vdi_id);\n\n\n\nout:\n\n    g_free(buf);\n\n\n\n    return ret;\n\n}\n", "idx": 1990, "_split": "test", "_hash": "ecebaf8c97d384ff14ae3eac553d5814"}
{"project": "qemu", "commit_id": "449041d4db1f82f281fe097e832f07cd9ee1e864", "target": 1, "func": "static int parse_uint8(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    /* accept both hex and decimal */\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx8 : \"%\" PRIu8;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n", "idx": 1994, "_split": "test", "_hash": "be8c09689695fdebb505615d25349e2c"}
{"project": "qemu", "commit_id": "1a0e4c8b02ea510508970c333ee610a90b921cbb", "target": 1, "func": "void s390_machine_reset(void)\n\n{\n\n    S390CPU *ipl_cpu = S390_CPU(qemu_get_cpu(0));\n\n\n\n    qemu_devices_reset();\n\n    s390_cmma_reset();\n\n    s390_crypto_reset();\n\n\n\n    /* all cpus are stopped - configure and start the ipl cpu only */\n\n    s390_ipl_prepare_cpu(ipl_cpu);\n\n    s390_cpu_set_state(CPU_STATE_OPERATING, ipl_cpu);\n\n}\n", "idx": 2009, "_split": "test", "_hash": "ecfe46f36efa5288235ca5d8ed5633bd"}
{"project": "qemu", "commit_id": "64c9bc181fc78275596649f591302d72df2d3071", "target": 0, "func": "static void do_token_in(USBDevice *s, USBPacket *p)\n\n{\n\n    int request, value, index;\n\n\n\n    assert(p->ep->nr == 0);\n\n\n\n    request = (s->setup_buf[0] << 8) | s->setup_buf[1];\n\n    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];\n\n    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];\n\n \n\n    switch(s->setup_state) {\n\n    case SETUP_STATE_ACK:\n\n        if (!(s->setup_buf[0] & USB_DIR_IN)) {\n\n            usb_device_handle_control(s, p, request, value, index,\n\n                                      s->setup_len, s->data_buf);\n\n            if (p->status == USB_RET_ASYNC) {\n\n                return;\n\n            }\n\n            s->setup_state = SETUP_STATE_IDLE;\n\n            p->actual_length = 0;\n\n        }\n\n        break;\n\n\n\n    case SETUP_STATE_DATA:\n\n        if (s->setup_buf[0] & USB_DIR_IN) {\n\n            int len = s->setup_len - s->setup_index;\n\n            if (len > p->iov.size) {\n\n                len = p->iov.size;\n\n            }\n\n            usb_packet_copy(p, s->data_buf + s->setup_index, len);\n\n            s->setup_index += len;\n\n            if (s->setup_index >= s->setup_len) {\n\n                s->setup_state = SETUP_STATE_ACK;\n\n            }\n\n            return;\n\n        }\n\n        s->setup_state = SETUP_STATE_IDLE;\n\n        p->status = USB_RET_STALL;\n\n        break;\n\n\n\n    default:\n\n        p->status = USB_RET_STALL;\n\n    }\n\n}\n", "idx": 2047, "_split": "test", "_hash": "3ac533163324ccdb592bd46fdc1c12bf"}
{"project": "qemu", "commit_id": "1eabfce6d53cb02066dbb0ac8471f8593ff24a24", "target": 0, "func": "static int kvm_get_msrs(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;\n\n    int ret, i;\n\n    uint64_t mtrr_top_bits;\n\n\n\n    kvm_msr_buf_reset(cpu);\n\n\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0);\n\n    kvm_msr_entry_add(cpu, MSR_PAT, 0);\n\n    if (has_msr_star) {\n\n        kvm_msr_entry_add(cpu, MSR_STAR, 0);\n\n    }\n\n    if (has_msr_hsave_pa) {\n\n        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0);\n\n    }\n\n    if (has_msr_tsc_aux) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0);\n\n    }\n\n    if (has_msr_tsc_adjust) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0);\n\n    }\n\n    if (has_msr_tsc_deadline) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0);\n\n    }\n\n    if (has_msr_misc_enable) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0);\n\n    }\n\n    if (has_msr_smbase) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, 0);\n\n    }\n\n    if (has_msr_feature_control) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_FEATURE_CONTROL, 0);\n\n    }\n\n    if (has_msr_bndcfgs) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, 0);\n\n    }\n\n    if (has_msr_xss) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_XSS, 0);\n\n    }\n\n\n\n\n\n    if (!env->tsc_valid) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);\n\n        env->tsc_valid = !runstate_is_running();\n\n    }\n\n\n\n#ifdef TARGET_X86_64\n\n    if (lm_capable_kernel) {\n\n        kvm_msr_entry_add(cpu, MSR_CSTAR, 0);\n\n        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, 0);\n\n        kvm_msr_entry_add(cpu, MSR_FMASK, 0);\n\n        kvm_msr_entry_add(cpu, MSR_LSTAR, 0);\n\n    }\n\n#endif\n\n    kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0);\n\n    kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, 0);\n\n    if (has_msr_async_pf_en) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, 0);\n\n    }\n\n    if (has_msr_pv_eoi_en) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, 0);\n\n    }\n\n    if (has_msr_kvm_steal_time) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, 0);\n\n    }\n\n    if (has_msr_architectural_pmu) {\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);\n\n        for (i = 0; i < MAX_FIXED_COUNTERS; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0);\n\n        }\n\n        for (i = 0; i < num_architectural_pmu_counters; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0);\n\n            kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);\n\n        }\n\n    }\n\n\n\n    if (env->mcg_cap) {\n\n        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MCG_CTL, 0);\n\n        if (has_msr_mcg_ext_ctl) {\n\n            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, 0);\n\n        }\n\n        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, 0);\n\n        }\n\n    }\n\n\n\n    if (has_msr_hv_hypercall) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID, 0);\n\n    }\n\n    if (has_msr_hv_vapic) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE, 0);\n\n    }\n\n    if (has_msr_hv_tsc) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC, 0);\n\n    }\n\n    if (has_msr_hv_crash) {\n\n        int j;\n\n\n\n        for (j = 0; j < HV_X64_MSR_CRASH_PARAMS; j++) {\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j, 0);\n\n        }\n\n    }\n\n    if (has_msr_hv_runtime) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, 0);\n\n    }\n\n    if (cpu->hyperv_synic) {\n\n        uint32_t msr;\n\n\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP, 0);\n\n        for (msr = HV_X64_MSR_SINT0; msr <= HV_X64_MSR_SINT15; msr++) {\n\n            kvm_msr_entry_add(cpu, msr, 0);\n\n        }\n\n    }\n\n    if (has_msr_hv_stimer) {\n\n        uint32_t msr;\n\n\n\n        for (msr = HV_X64_MSR_STIMER0_CONFIG; msr <= HV_X64_MSR_STIMER3_COUNT;\n\n             msr++) {\n\n            kvm_msr_entry_add(cpu, msr, 0);\n\n        }\n\n    }\n\n    if (has_msr_mtrr) {\n\n        kvm_msr_entry_add(cpu, MSR_MTRRdefType, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, 0);\n\n        for (i = 0; i < MSR_MTRRcap_VCNT; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i), 0);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), 0);\n\n        }\n\n    }\n\n\n\n    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    assert(ret == cpu->kvm_msr_buf->nmsrs);\n\n    /*\n\n     * MTRR masks: Each mask consists of 5 parts\n\n     * a  10..0: must be zero\n\n     * b  11   : valid bit\n\n     * c n-1.12: actual mask bits\n\n     * d  51..n: reserved must be zero\n\n     * e  63.52: reserved must be zero\n\n     *\n\n     * 'n' is the number of physical bits supported by the CPU and is\n\n     * apparently always <= 52.   We know our 'n' but don't know what\n\n     * the destinations 'n' is; it might be smaller, in which case\n\n     * it masks (c) on loading. It might be larger, in which case\n\n     * we fill 'd' so that d..c is consistent irrespetive of the 'n'\n\n     * we're migrating to.\n\n     */\n\n\n\n    if (cpu->fill_mtrr_mask) {\n\n        QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52);\n\n        assert(cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS);\n\n        mtrr_top_bits = MAKE_64BIT_MASK(cpu->phys_bits, 52 - cpu->phys_bits);\n\n    } else {\n\n        mtrr_top_bits = 0;\n\n    }\n\n\n\n    for (i = 0; i < ret; i++) {\n\n        uint32_t index = msrs[i].index;\n\n        switch (index) {\n\n        case MSR_IA32_SYSENTER_CS:\n\n            env->sysenter_cs = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SYSENTER_ESP:\n\n            env->sysenter_esp = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SYSENTER_EIP:\n\n            env->sysenter_eip = msrs[i].data;\n\n            break;\n\n        case MSR_PAT:\n\n            env->pat = msrs[i].data;\n\n            break;\n\n        case MSR_STAR:\n\n            env->star = msrs[i].data;\n\n            break;\n\n#ifdef TARGET_X86_64\n\n        case MSR_CSTAR:\n\n            env->cstar = msrs[i].data;\n\n            break;\n\n        case MSR_KERNELGSBASE:\n\n            env->kernelgsbase = msrs[i].data;\n\n            break;\n\n        case MSR_FMASK:\n\n            env->fmask = msrs[i].data;\n\n            break;\n\n        case MSR_LSTAR:\n\n            env->lstar = msrs[i].data;\n\n            break;\n\n#endif\n\n        case MSR_IA32_TSC:\n\n            env->tsc = msrs[i].data;\n\n            break;\n\n        case MSR_TSC_AUX:\n\n            env->tsc_aux = msrs[i].data;\n\n            break;\n\n        case MSR_TSC_ADJUST:\n\n            env->tsc_adjust = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_TSCDEADLINE:\n\n            env->tsc_deadline = msrs[i].data;\n\n            break;\n\n        case MSR_VM_HSAVE_PA:\n\n            env->vm_hsave = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_SYSTEM_TIME:\n\n            env->system_time_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_WALL_CLOCK:\n\n            env->wall_clock_msr = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_STATUS:\n\n            env->mcg_status = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_CTL:\n\n            env->mcg_ctl = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_EXT_CTL:\n\n            env->mcg_ext_ctl = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_MISC_ENABLE:\n\n            env->msr_ia32_misc_enable = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SMBASE:\n\n            env->smbase = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_FEATURE_CONTROL:\n\n            env->msr_ia32_feature_control = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_BNDCFGS:\n\n            env->msr_bndcfgs = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_XSS:\n\n            env->xss = msrs[i].data;\n\n            break;\n\n        default:\n\n            if (msrs[i].index >= MSR_MC0_CTL &&\n\n                msrs[i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) {\n\n                env->mce_banks[msrs[i].index - MSR_MC0_CTL] = msrs[i].data;\n\n            }\n\n            break;\n\n        case MSR_KVM_ASYNC_PF_EN:\n\n            env->async_pf_en_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_PV_EOI_EN:\n\n            env->pv_eoi_en_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_STEAL_TIME:\n\n            env->steal_time_msr = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_FIXED_CTR_CTRL:\n\n            env->msr_fixed_ctr_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_CTRL:\n\n            env->msr_global_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_STATUS:\n\n            env->msr_global_status = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\n            env->msr_global_ovf_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:\n\n            env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;\n\n            break;\n\n        case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:\n\n            env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;\n\n            break;\n\n        case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:\n\n            env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_HYPERCALL:\n\n            env->msr_hv_hypercall = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_GUEST_OS_ID:\n\n            env->msr_hv_guest_os_id = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_APIC_ASSIST_PAGE:\n\n            env->msr_hv_vapic = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_REFERENCE_TSC:\n\n            env->msr_hv_tsc = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\n            env->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_VP_RUNTIME:\n\n            env->msr_hv_runtime = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SCONTROL:\n\n            env->msr_hv_synic_control = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SVERSION:\n\n            env->msr_hv_synic_version = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SIEFP:\n\n            env->msr_hv_synic_evt_page = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SIMP:\n\n            env->msr_hv_synic_msg_page = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\n            env->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_STIMER0_CONFIG:\n\n        case HV_X64_MSR_STIMER1_CONFIG:\n\n        case HV_X64_MSR_STIMER2_CONFIG:\n\n        case HV_X64_MSR_STIMER3_CONFIG:\n\n            env->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] =\n\n                                msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_STIMER0_COUNT:\n\n        case HV_X64_MSR_STIMER1_COUNT:\n\n        case HV_X64_MSR_STIMER2_COUNT:\n\n        case HV_X64_MSR_STIMER3_COUNT:\n\n            env->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] =\n\n                                msrs[i].data;\n\n            break;\n\n        case MSR_MTRRdefType:\n\n            env->mtrr_deftype = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix64K_00000:\n\n            env->mtrr_fixed[0] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix16K_80000:\n\n            env->mtrr_fixed[1] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix16K_A0000:\n\n            env->mtrr_fixed[2] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_C0000:\n\n            env->mtrr_fixed[3] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_C8000:\n\n            env->mtrr_fixed[4] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_D0000:\n\n            env->mtrr_fixed[5] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_D8000:\n\n            env->mtrr_fixed[6] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_E0000:\n\n            env->mtrr_fixed[7] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_E8000:\n\n            env->mtrr_fixed[8] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_F0000:\n\n            env->mtrr_fixed[9] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_F8000:\n\n            env->mtrr_fixed[10] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1):\n\n            if (index & 1) {\n\n                env->mtrr_var[MSR_MTRRphysIndex(index)].mask = msrs[i].data |\n\n                                                               mtrr_top_bits;\n\n            } else {\n\n                env->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2053, "_split": "test", "_hash": "d26e4bb13f73c6b3fac691165001e31b"}
{"project": "qemu", "commit_id": "2aece63c8a9d2c3a8ff41d2febc4cdeff2633331", "target": 0, "func": "host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)\n\n{\n\n    MemoryRegion *mr;\n\n\n\n    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);\n\n    if (memory_region_is_mapped(mr)) {\n\n        return false;\n\n    } else {\n\n        return true;\n\n    }\n\n}\n", "idx": 2063, "_split": "test", "_hash": "b35561d6ca866cdc1a8da081551a0bfa"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_pwt_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t value, unsigned size)\n\n{\n\n    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n\n\n    if (size != 1) {\n\n        return omap_badwidth_write8(opaque, addr, value);\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* FRC */\n\n        s->frc = value & 0x3f;\n\n        break;\n\n    case 0x04:\t/* VRC */\n\n        if ((value ^ s->vrc) & 1) {\n\n            if (value & 1)\n\n                printf(\"%s: %iHz buzz on\\n\", __FUNCTION__, (int)\n\n                                /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */\n\n                                ((omap_clk_getrate(s->clk) >> 3) /\n\n                                 /* Pre-multiplexer divider */\n\n                                 ((s->gcr & 2) ? 1 : 154) /\n\n                                 /* Octave multiplexer */\n\n                                 (2 << (value & 3)) *\n\n                                 /* 101/107 divider */\n\n                                 ((value & (1 << 2)) ? 101 : 107) *\n\n                                 /*  49/55 divider */\n\n                                 ((value & (1 << 3)) ?  49 : 55) *\n\n                                 /*  50/63 divider */\n\n                                 ((value & (1 << 4)) ?  50 : 63) *\n\n                                 /*  80/127 divider */\n\n                                 ((value & (1 << 5)) ?  80 : 127) /\n\n                                 (107 * 55 * 63 * 127)));\n\n            else\n\n                printf(\"%s: silence!\\n\", __FUNCTION__);\n\n        }\n\n        s->vrc = value & 0x7f;\n\n        break;\n\n    case 0x08:\t/* GCR */\n\n        s->gcr = value & 3;\n\n        break;\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n        return;\n\n    }\n\n}\n", "idx": 2084, "_split": "test", "_hash": "259693086d4901c1d1291402c3fc63ba"}
{"project": "qemu", "commit_id": "03fcbd9dc5084ff4676c153fbe04fb0fcf939d09", "target": 1, "func": "DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)\n\n{\n\n    DeviceClass *dc;\n\n    const char *driver, *path;\n\n    DeviceState *dev;\n\n    BusState *bus = NULL;\n\n    Error *err = NULL;\n\n\n\n    driver = qemu_opt_get(opts, \"driver\");\n\n    if (!driver) {\n\n        error_setg(errp, QERR_MISSING_PARAMETER, \"driver\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find driver */\n\n    dc = qdev_get_device_class(&driver, errp);\n\n    if (!dc) {\n\n        return NULL;\n\n    }\n\n\n\n    /* find bus */\n\n    path = qemu_opt_get(opts, \"bus\");\n\n    if (path != NULL) {\n\n        bus = qbus_find(path, errp);\n\n        if (!bus) {\n\n            return NULL;\n\n        }\n\n        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {\n\n            error_setg(errp, \"Device '%s' can't go on %s bus\",\n\n                       driver, object_get_typename(OBJECT(bus)));\n\n            return NULL;\n\n        }\n\n    } else if (dc->bus_type != NULL) {\n\n        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);\n\n        if (!bus || qbus_is_full(bus)) {\n\n            error_setg(errp, \"No '%s' bus found for device '%s'\",\n\n                       dc->bus_type, driver);\n\n            return NULL;\n\n        }\n\n    }\n\n    if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) {\n\n        error_setg(errp, QERR_BUS_NO_HOTPLUG, bus->name);\n\n        return NULL;\n\n    }\n\n\n\n    if (!migration_is_idle()) {\n\n        error_setg(errp, \"device_add not allowed while migrating\");\n\n        return NULL;\n\n    }\n\n\n\n    /* create device */\n\n    dev = DEVICE(object_new(driver));\n\n\n\n    if (bus) {\n\n        qdev_set_parent_bus(dev, bus);\n\n\n\n\n\n\n    }\n\n\n\n    qdev_set_id(dev, qemu_opts_id(opts));\n\n\n\n    /* set properties */\n\n    if (qemu_opt_foreach(opts, set_property, dev, &err)) {\n\n\n    }\n\n\n\n    dev->opts = opts;\n\n    object_property_set_bool(OBJECT(dev), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        dev->opts = NULL;\n\n\n    }\n\n    return dev;\n\n\n\nerr_del_dev:\n\n    error_propagate(errp, err);\n\n    object_unparent(OBJECT(dev));\n\n    object_unref(OBJECT(dev));\n\n    return NULL;\n\n}", "idx": 2124, "_split": "test", "_hash": "998ea3491c26c69f9dbcd43b29d08e4d"}
{"project": "qemu", "commit_id": "bd88c780e6a17188f7fd676f3a056e5db21500e0", "target": 1, "func": "static inline int cpu_gdb_index(CPUState *cpu)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    return cpu->host_tid;\n\n#else\n\n    return cpu->cpu_index + 1;\n\n#endif\n\n}\n", "idx": 2133, "_split": "test", "_hash": "5c0b0733b34141cb60915f7aad1e45a5"}
{"project": "qemu", "commit_id": "93bb1315250dd010e65dc067af103cbaf0de03ae", "target": 1, "func": "void hmp_info_block_jobs(Monitor *mon, const QDict *qdict)\n{\n    BlockJobInfoList *list;\n    Error *err = NULL;\n    list = qmp_query_block_jobs(&err);\n    assert(!err);\n    if (!list) {\n        monitor_printf(mon, \"No active jobs\\n\");\n        return;\n    }\n    while (list) {\n        if (strcmp(list->value->type, \"stream\") == 0) {\n            monitor_printf(mon, \"Streaming device %s: Completed %\" PRId64\n                           \" of %\" PRId64 \" bytes, speed limit %\" PRId64\n                           \" bytes/s\\n\",\n                           list->value->device,\n                           list->value->offset,\n                           list->value->len,\n                           list->value->speed);\n        } else {\n            monitor_printf(mon, \"Type %s, device %s: Completed %\" PRId64\n                           \" of %\" PRId64 \" bytes, speed limit %\" PRId64\n                           \" bytes/s\\n\",\n                           list->value->type,\n                           list->value->device,\n                           list->value->offset,\n                           list->value->len,\n                           list->value->speed);\n        }\n        list = list->next;\n    }\n}", "idx": 2148, "_split": "test", "_hash": "eebc2495d08dedc635bc39cdd81ba0e9"}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_reg_alloc_call(TCGContext *s, int nb_oargs, int nb_iargs,\n\n                               const TCGArg * const args, uint16_t dead_args,\n\n                               uint8_t sync_args)\n\n{\n\n    int flags, nb_regs, i;\n\n    TCGReg reg;\n\n    TCGArg arg;\n\n    TCGTemp *ts;\n\n    intptr_t stack_offset;\n\n    size_t call_stack_size;\n\n    tcg_insn_unit *func_addr;\n\n    int allocate_args;\n\n    TCGRegSet allocated_regs;\n\n\n\n    func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];\n\n    flags = args[nb_oargs + nb_iargs + 1];\n\n\n\n    nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);\n\n    if (nb_regs > nb_iargs) {\n\n        nb_regs = nb_iargs;\n\n    }\n\n\n\n    /* assign stack slots first */\n\n    call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long);\n\n    call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & \n\n        ~(TCG_TARGET_STACK_ALIGN - 1);\n\n    allocate_args = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE);\n\n    if (allocate_args) {\n\n        /* XXX: if more than TCG_STATIC_CALL_ARGS_SIZE is needed,\n\n           preallocate call stack */\n\n        tcg_abort();\n\n    }\n\n\n\n    stack_offset = TCG_TARGET_CALL_STACK_OFFSET;\n\n    for(i = nb_regs; i < nb_iargs; i++) {\n\n        arg = args[nb_oargs + i];\n\n#ifdef TCG_TARGET_STACK_GROWSUP\n\n        stack_offset -= sizeof(tcg_target_long);\n\n#endif\n\n        if (arg != TCG_CALL_DUMMY_ARG) {\n\n            ts = &s->temps[arg];\n\n            temp_load(s, ts, tcg_target_available_regs[ts->type],\n\n                      s->reserved_regs);\n\n            tcg_out_st(s, ts->type, ts->reg, TCG_REG_CALL_STACK, stack_offset);\n\n        }\n\n#ifndef TCG_TARGET_STACK_GROWSUP\n\n        stack_offset += sizeof(tcg_target_long);\n\n#endif\n\n    }\n\n    \n\n    /* assign input registers */\n\n    tcg_regset_set(allocated_regs, s->reserved_regs);\n\n    for(i = 0; i < nb_regs; i++) {\n\n        arg = args[nb_oargs + i];\n\n        if (arg != TCG_CALL_DUMMY_ARG) {\n\n            ts = &s->temps[arg];\n\n            reg = tcg_target_call_iarg_regs[i];\n\n            tcg_reg_free(s, reg, allocated_regs);\n\n\n\n            if (ts->val_type == TEMP_VAL_REG) {\n\n                if (ts->reg != reg) {\n\n                    tcg_out_mov(s, ts->type, reg, ts->reg);\n\n                }\n\n            } else {\n\n                TCGRegSet arg_set;\n\n\n\n                tcg_regset_clear(arg_set);\n\n                tcg_regset_set_reg(arg_set, reg);\n\n                temp_load(s, ts, arg_set, allocated_regs);\n\n            }\n\n\n\n            tcg_regset_set_reg(allocated_regs, reg);\n\n        }\n\n    }\n\n    \n\n    /* mark dead temporaries and free the associated registers */\n\n    for(i = nb_oargs; i < nb_iargs + nb_oargs; i++) {\n\n        if (IS_DEAD_ARG(i)) {\n\n            temp_dead(s, &s->temps[args[i]]);\n\n        }\n\n    }\n\n    \n\n    /* clobber call registers */\n\n    for (i = 0; i < TCG_TARGET_NB_REGS; i++) {\n\n        if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) {\n\n            tcg_reg_free(s, i, allocated_regs);\n\n        }\n\n    }\n\n\n\n    /* Save globals if they might be written by the helper, sync them if\n\n       they might be read. */\n\n    if (flags & TCG_CALL_NO_READ_GLOBALS) {\n\n        /* Nothing to do */\n\n    } else if (flags & TCG_CALL_NO_WRITE_GLOBALS) {\n\n        sync_globals(s, allocated_regs);\n\n    } else {\n\n        save_globals(s, allocated_regs);\n\n    }\n\n\n\n    tcg_out_call(s, func_addr);\n\n\n\n    /* assign output registers and emit moves if needed */\n\n    for(i = 0; i < nb_oargs; i++) {\n\n        arg = args[i];\n\n        ts = &s->temps[arg];\n\n        reg = tcg_target_call_oarg_regs[i];\n\n        assert(s->reg_to_temp[reg] == NULL);\n\n\n\n        if (ts->fixed_reg) {\n\n            if (ts->reg != reg) {\n\n                tcg_out_mov(s, ts->type, ts->reg, reg);\n\n            }\n\n        } else {\n\n            if (ts->val_type == TEMP_VAL_REG) {\n\n                s->reg_to_temp[ts->reg] = NULL;\n\n            }\n\n            ts->val_type = TEMP_VAL_REG;\n\n            ts->reg = reg;\n\n            ts->mem_coherent = 0;\n\n            s->reg_to_temp[reg] = ts;\n\n            if (NEED_SYNC_ARG(i)) {\n\n                tcg_reg_sync(s, reg, allocated_regs);\n\n            }\n\n            if (IS_DEAD_ARG(i)) {\n\n                temp_dead(s, ts);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 2182, "_split": "test", "_hash": "cf6fe1be0dbb6bc4ab2038f1f9734f2f"}
{"project": "qemu", "commit_id": "838ef602498b8d1985a231a06f5e328e2946a81d", "target": 0, "func": "static void curl_multi_do(void *arg)\n\n{\n\n    BDRVCURLState *s = (BDRVCURLState *)arg;\n\n    int running;\n\n    int r;\n\n\n\n    if (!s->multi) {\n\n        return;\n\n    }\n\n\n\n    do {\n\n        r = curl_multi_socket_all(s->multi, &running);\n\n    } while(r == CURLM_CALL_MULTI_PERFORM);\n\n\n\n    curl_multi_read(s);\n\n}\n", "idx": 2187, "_split": "test", "_hash": "6d47977a2e5367bf500b6706cc68d897"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static int decode_opc(MoxieCPU *cpu, DisasContext *ctx)\n\n{\n\n    CPUMoxieState *env = &cpu->env;\n\n\n\n    /* Local cache for the instruction opcode.  */\n\n    int opcode;\n\n    /* Set the default instruction length.  */\n\n    int length = 2;\n\n\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n        tcg_gen_debug_insn_start(ctx->pc);\n\n    }\n\n\n\n    /* Examine the 16-bit opcode.  */\n\n    opcode = ctx->opcode;\n\n\n\n    /* Decode instruction.  */\n\n    if (opcode & (1 << 15)) {\n\n        if (opcode & (1 << 14)) {\n\n            /* This is a Form 3 instruction.  */\n\n            int inst = (opcode >> 10 & 0xf);\n\n\n\n#define BRANCH(cond)                                                         \\\n\n    do {                                                                     \\\n\n        int l1 = gen_new_label();                                            \\\n\n        tcg_gen_brcond_i32(cond, cc_a, cc_b, l1);                            \\\n\n        gen_goto_tb(env, ctx, 1, ctx->pc+2);                                 \\\n\n        gen_set_label(l1);                                                   \\\n\n        gen_goto_tb(env, ctx, 0, extract_branch_offset(opcode) + ctx->pc+2); \\\n\n        ctx->bstate = BS_BRANCH;                                             \\\n\n    } while (0)\n\n\n\n            switch (inst) {\n\n            case 0x00: /* beq */\n\n                BRANCH(TCG_COND_EQ);\n\n                break;\n\n            case 0x01: /* bne */\n\n                BRANCH(TCG_COND_NE);\n\n                break;\n\n            case 0x02: /* blt */\n\n                BRANCH(TCG_COND_LT);\n\n                break;\n\n            case 0x03: /* bgt */\n\n                BRANCH(TCG_COND_GT);\n\n                break;\n\n            case 0x04: /* bltu */\n\n                BRANCH(TCG_COND_LTU);\n\n                break;\n\n            case 0x05: /* bgtu */\n\n                BRANCH(TCG_COND_GTU);\n\n                break;\n\n            case 0x06: /* bge */\n\n                BRANCH(TCG_COND_GE);\n\n                break;\n\n            case 0x07: /* ble */\n\n                BRANCH(TCG_COND_LE);\n\n                break;\n\n            case 0x08: /* bgeu */\n\n                BRANCH(TCG_COND_GEU);\n\n                break;\n\n            case 0x09: /* bleu */\n\n                BRANCH(TCG_COND_LEU);\n\n                break;\n\n            default:\n\n                {\n\n                    TCGv temp = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                    tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n\n                    gen_helper_raise_exception(cpu_env, temp);\n\n                    tcg_temp_free_i32(temp);\n\n                }\n\n                break;\n\n            }\n\n        } else {\n\n            /* This is a Form 2 instruction.  */\n\n            int inst = (opcode >> 12 & 0x3);\n\n            switch (inst) {\n\n            case 0x00: /* inc */\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned int v = (opcode & 0xff);\n\n                    tcg_gen_addi_i32(REG(a), REG(a), v);\n\n                }\n\n                break;\n\n            case 0x01: /* dec */\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned int v = (opcode & 0xff);\n\n                    tcg_gen_subi_i32(REG(a), REG(a), v);\n\n                }\n\n                break;\n\n            case 0x02: /* gsr */\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned v = (opcode & 0xff);\n\n                    tcg_gen_ld_i32(REG(a), cpu_env,\n\n                                   offsetof(CPUMoxieState, sregs[v]));\n\n                }\n\n                break;\n\n            case 0x03: /* ssr */\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned v = (opcode & 0xff);\n\n                    tcg_gen_st_i32(REG(a), cpu_env,\n\n                                   offsetof(CPUMoxieState, sregs[v]));\n\n                }\n\n                break;\n\n            default:\n\n                {\n\n                    TCGv temp = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                    tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n\n                    gen_helper_raise_exception(cpu_env, temp);\n\n                    tcg_temp_free_i32(temp);\n\n                }\n\n                break;\n\n            }\n\n        }\n\n    } else {\n\n        /* This is a Form 1 instruction.  */\n\n        int inst = opcode >> 8;\n\n        switch (inst) {\n\n        case 0x00: /* nop */\n\n            break;\n\n        case 0x01: /* ldi.l (immediate) */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n                tcg_gen_movi_i32(REG(reg), val);\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x02: /* mov (register-to-register) */\n\n            {\n\n                int dest  = (opcode >> 4) & 0xf;\n\n                int src = opcode & 0xf;\n\n                tcg_gen_mov_i32(REG(dest), REG(src));\n\n            }\n\n            break;\n\n        case 0x03: /* jsra */\n\n            {\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_movi_i32(t1, ctx->pc + 6);\n\n\n\n                /* Make space for the static chain and return address.  */\n\n                tcg_gen_subi_i32(t2, REG(1), 8);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(t1, REG(1), ctx->memidx);\n\n\n\n                /* Push the current frame pointer.  */\n\n                tcg_gen_subi_i32(t2, REG(1), 4);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx);\n\n\n\n                /* Set the pc and $fp.  */\n\n                tcg_gen_mov_i32(REG(0), REG(1));\n\n\n\n                gen_goto_tb(env, ctx, 0, cpu_ldl_code(env, ctx->pc+2));\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                ctx->bstate = BS_BRANCH;\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x04: /* ret */\n\n            {\n\n                TCGv t1 = tcg_temp_new_i32();\n\n\n\n                /* The new $sp is the old $fp.  */\n\n                tcg_gen_mov_i32(REG(1), REG(0));\n\n\n\n                /* Pop the frame pointer.  */\n\n                tcg_gen_qemu_ld32u(REG(0), REG(1), ctx->memidx);\n\n                tcg_gen_addi_i32(t1, REG(1), 4);\n\n                tcg_gen_mov_i32(REG(1), t1);\n\n\n\n\n\n                /* Pop the return address and skip over the static chain\n\n                   slot.  */\n\n                tcg_gen_qemu_ld32u(cpu_pc, REG(1), ctx->memidx);\n\n                tcg_gen_addi_i32(t1, REG(1), 8);\n\n                tcg_gen_mov_i32(REG(1), t1);\n\n\n\n                tcg_temp_free_i32(t1);\n\n\n\n                /* Jump... */\n\n                tcg_gen_exit_tb(0);\n\n\n\n                ctx->bstate = BS_BRANCH;\n\n            }\n\n            break;\n\n        case 0x05: /* add.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_add_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x06: /* push */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                tcg_gen_subi_i32(t1, REG(a), 4);\n\n                tcg_gen_mov_i32(REG(a), t1);\n\n                tcg_gen_qemu_st32(REG(b), REG(a), ctx->memidx);\n\n                tcg_temp_free_i32(t1);\n\n            }\n\n            break;\n\n        case 0x07: /* pop */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                TCGv t1 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_qemu_ld32u(REG(b), REG(a), ctx->memidx);\n\n                tcg_gen_addi_i32(t1, REG(a), 4);\n\n                tcg_gen_mov_i32(REG(a), t1);\n\n                tcg_temp_free_i32(t1);\n\n            }\n\n            break;\n\n        case 0x08: /* lda.l */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld32u(REG(reg), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x09: /* sta.l */\n\n            {\n\n                int val = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st32(REG(val), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x0a: /* ld.l (register indirect) */\n\n            {\n\n                int src  = opcode & 0xf;\n\n                int dest = (opcode >> 4) & 0xf;\n\n\n\n                tcg_gen_qemu_ld32u(REG(dest), REG(src), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x0b: /* st.l */\n\n            {\n\n                int dest = (opcode >> 4) & 0xf;\n\n                int val  = opcode & 0xf;\n\n\n\n                tcg_gen_qemu_st32(REG(val), REG(dest), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x0c: /* ldo.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld32u(t2, t1, ctx->memidx);\n\n                tcg_gen_mov_i32(REG(a), t2);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x0d: /* sto.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st32(REG(b), t1, ctx->memidx);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x0e: /* cmp */\n\n            {\n\n                int a  = (opcode >> 4) & 0xf;\n\n                int b  = opcode & 0xf;\n\n\n\n                tcg_gen_mov_i32(cc_a, REG(a));\n\n                tcg_gen_mov_i32(cc_b, REG(b));\n\n            }\n\n            break;\n\n        case 0x19: /* jsr */\n\n            {\n\n                int fnreg = (opcode >> 4) & 0xf;\n\n\n\n                /* Load the stack pointer into T0.  */\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_movi_i32(t1, ctx->pc+2);\n\n\n\n                /* Make space for the static chain and return address.  */\n\n                tcg_gen_subi_i32(t2, REG(1), 8);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(t1, REG(1), ctx->memidx);\n\n\n\n                /* Push the current frame pointer.  */\n\n                tcg_gen_subi_i32(t2, REG(1), 4);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx);\n\n\n\n                /* Set the pc and $fp.  */\n\n                tcg_gen_mov_i32(REG(0), REG(1));\n\n                tcg_gen_mov_i32(cpu_pc, REG(fnreg));\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n                tcg_gen_exit_tb(0);\n\n                ctx->bstate = BS_BRANCH;\n\n            }\n\n            break;\n\n        case 0x1a: /* jmpa */\n\n            {\n\n                tcg_gen_movi_i32(cpu_pc, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_exit_tb(0);\n\n                ctx->bstate = BS_BRANCH;\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x1b: /* ldi.b (immediate) */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n                tcg_gen_movi_i32(REG(reg), val);\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x1c: /* ld.b (register indirect) */\n\n            {\n\n                int src  = opcode & 0xf;\n\n                int dest = (opcode >> 4) & 0xf;\n\n\n\n                tcg_gen_qemu_ld8u(REG(dest), REG(src), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x1d: /* lda.b */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld8u(REG(reg), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x1e: /* st.b */\n\n            {\n\n                int dest = (opcode >> 4) & 0xf;\n\n                int val  = opcode & 0xf;\n\n\n\n                tcg_gen_qemu_st8(REG(val), REG(dest), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x1f: /* sta.b */\n\n            {\n\n                int val = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st8(REG(val), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x20: /* ldi.s (immediate) */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n                tcg_gen_movi_i32(REG(reg), val);\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x21: /* ld.s (register indirect) */\n\n            {\n\n                int src  = opcode & 0xf;\n\n                int dest = (opcode >> 4) & 0xf;\n\n\n\n                tcg_gen_qemu_ld16u(REG(dest), REG(src), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x22: /* lda.s */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld16u(REG(reg), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x23: /* st.s */\n\n            {\n\n                int dest = (opcode >> 4) & 0xf;\n\n                int val  = opcode & 0xf;\n\n\n\n                tcg_gen_qemu_st16(REG(val), REG(dest), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x24: /* sta.s */\n\n            {\n\n                int val = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st16(REG(val), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x25: /* jmp */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                tcg_gen_mov_i32(cpu_pc, REG(reg));\n\n                tcg_gen_exit_tb(0);\n\n                ctx->bstate = BS_BRANCH;\n\n            }\n\n            break;\n\n        case 0x26: /* and */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_and_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x27: /* lshr */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv sv = tcg_temp_new_i32();\n\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n\n                tcg_gen_shr_i32(REG(a), REG(a), sv);\n\n                tcg_temp_free_i32(sv);\n\n            }\n\n            break;\n\n        case 0x28: /* ashl */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv sv = tcg_temp_new_i32();\n\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n\n                tcg_gen_shl_i32(REG(a), REG(a), sv);\n\n                tcg_temp_free_i32(sv);\n\n            }\n\n            break;\n\n        case 0x29: /* sub.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_sub_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2a: /* neg */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_neg_i32(REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2b: /* or */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_or_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2c: /* not */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_not_i32(REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2d: /* ashr */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv sv = tcg_temp_new_i32();\n\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n\n                tcg_gen_sar_i32(REG(a), REG(a), sv);\n\n                tcg_temp_free_i32(sv);\n\n            }\n\n            break;\n\n        case 0x2e: /* xor */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_xor_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2f: /* mul.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_mul_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x30: /* swi */\n\n            {\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n\n\n                TCGv temp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(temp, val);\n\n                tcg_gen_st_i32(temp, cpu_env,\n\n                               offsetof(CPUMoxieState, sregs[3]));\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                tcg_gen_movi_i32(temp, MOXIE_EX_SWI);\n\n                gen_helper_raise_exception(cpu_env, temp);\n\n                tcg_temp_free_i32(temp);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x31: /* div.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                gen_helper_div(REG(a), cpu_env, REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x32: /* udiv.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                gen_helper_udiv(REG(a), cpu_env, REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x33: /* mod.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_rem_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x34: /* umod.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_remu_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x35: /* brk */\n\n            {\n\n                TCGv temp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                tcg_gen_movi_i32(temp, MOXIE_EX_BREAK);\n\n                gen_helper_raise_exception(cpu_env, temp);\n\n                tcg_temp_free_i32(temp);\n\n            }\n\n            break;\n\n        case 0x36: /* ldo.b */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld8u(t2, t1, ctx->memidx);\n\n                tcg_gen_mov_i32(REG(a), t2);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x37: /* sto.b */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st8(REG(b), t1, ctx->memidx);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x38: /* ldo.s */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld16u(t2, t1, ctx->memidx);\n\n                tcg_gen_mov_i32(REG(a), t2);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x39: /* sto.s */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st16(REG(b), t1, ctx->memidx);\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        default:\n\n            {\n\n                TCGv temp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n\n                gen_helper_raise_exception(cpu_env, temp);\n\n                tcg_temp_free_i32(temp);\n\n             }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return length;\n\n}\n", "idx": 2190, "_split": "test", "_hash": "e33b8d2c09b979beba3d290a65afa253"}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_opc(TCGContext *s, int opc, int r, int rm, int x)\n\n{\n\n    int rex;\n\n\n\n    if (opc & P_GS) {\n\n        tcg_out8(s, 0x65);\n\n    }\n\n    if (opc & P_DATA16) {\n\n        /* We should never be asking for both 16 and 64-bit operation.  */\n\n        assert((opc & P_REXW) == 0);\n\n        tcg_out8(s, 0x66);\n\n    }\n\n    if (opc & P_ADDR32) {\n\n        tcg_out8(s, 0x67);\n\n    }\n\n\n\n    rex = 0;\n\n    rex |= (opc & P_REXW) ? 0x8 : 0x0;  /* REX.W */\n\n    rex |= (r & 8) >> 1;                /* REX.R */\n\n    rex |= (x & 8) >> 2;                /* REX.X */\n\n    rex |= (rm & 8) >> 3;               /* REX.B */\n\n\n\n    /* P_REXB_{R,RM} indicates that the given register is the low byte.\n\n       For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,\n\n       as otherwise the encoding indicates %[abcd]h.  Note that the values\n\n       that are ORed in merely indicate that the REX byte must be present;\n\n       those bits get discarded in output.  */\n\n    rex |= opc & (r >= 4 ? P_REXB_R : 0);\n\n    rex |= opc & (rm >= 4 ? P_REXB_RM : 0);\n\n\n\n    if (rex) {\n\n        tcg_out8(s, (uint8_t)(rex | 0x40));\n\n    }\n\n\n\n    if (opc & (P_EXT | P_EXT38)) {\n\n        tcg_out8(s, 0x0f);\n\n        if (opc & P_EXT38) {\n\n            tcg_out8(s, 0x38);\n\n        }\n\n    }\n\n\n\n    tcg_out8(s, opc);\n\n}\n", "idx": 2195, "_split": "test", "_hash": "e44149e25c46b531b2cb25fcd9952f21"}
{"project": "qemu", "commit_id": "d0d5d0e31a874d592741a088c2c5071bae164dbf", "target": 1, "func": "qcow2_co_pwritev_compressed(BlockDriverState *bs, uint64_t offset,\n\n                            uint64_t bytes, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    QEMUIOVector hd_qiov;\n\n    struct iovec iov;\n\n    z_stream strm;\n\n    int ret, out_len;\n\n    uint8_t *buf, *out_buf;\n\n    uint64_t cluster_offset;\n\n\n\n    if (bytes == 0) {\n\n        /* align end of file to a sector boundary to ease reading with\n\n           sector based I/Os */\n\n        cluster_offset = bdrv_getlength(bs->file->bs);\n\n        return bdrv_truncate(bs->file, cluster_offset, PREALLOC_MODE_OFF, NULL);\n\n    }\n\n\n\n    buf = qemu_blockalign(bs, s->cluster_size);\n\n    if (bytes != s->cluster_size) {\n\n        if (bytes > s->cluster_size ||\n\n            offset + bytes != bs->total_sectors << BDRV_SECTOR_BITS)\n\n        {\n\n            qemu_vfree(buf);\n\n            return -EINVAL;\n\n        }\n\n        /* Zero-pad last write if image size is not cluster aligned */\n\n        memset(buf + bytes, 0, s->cluster_size - bytes);\n\n    }\n\n    qemu_iovec_to_buf(qiov, 0, buf, bytes);\n\n\n\n    out_buf = g_malloc(s->cluster_size);\n\n\n\n    /* best compression, small window, no zlib header */\n\n    memset(&strm, 0, sizeof(strm));\n\n    ret = deflateInit2(&strm, Z_DEFAULT_COMPRESSION,\n\n                       Z_DEFLATED, -12,\n\n                       9, Z_DEFAULT_STRATEGY);\n\n    if (ret != 0) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    strm.avail_in = s->cluster_size;\n\n    strm.next_in = (uint8_t *)buf;\n\n    strm.avail_out = s->cluster_size;\n\n    strm.next_out = out_buf;\n\n\n\n    ret = deflate(&strm, Z_FINISH);\n\n    if (ret != Z_STREAM_END && ret != Z_OK) {\n\n        deflateEnd(&strm);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    out_len = strm.next_out - out_buf;\n\n\n\n    deflateEnd(&strm);\n\n\n\n    if (ret != Z_STREAM_END || out_len >= s->cluster_size) {\n\n        /* could not compress: write normal cluster */\n\n        ret = qcow2_co_pwritev(bs, offset, bytes, qiov, 0);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        goto success;\n\n    }\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    cluster_offset =\n\n        qcow2_alloc_compressed_cluster_offset(bs, offset, out_len);\n\n    if (!cluster_offset) {\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        ret = -EIO;\n\n        goto fail;\n\n    }\n\n    cluster_offset &= s->cluster_offset_mask;\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs, 0, cluster_offset, out_len);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    iov = (struct iovec) {\n\n        .iov_base   = out_buf,\n\n        .iov_len    = out_len,\n\n    };\n\n    qemu_iovec_init_external(&hd_qiov, &iov, 1);\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_WRITE_COMPRESSED);\n\n    ret = bdrv_co_pwritev(bs->file, cluster_offset, out_len, &hd_qiov, 0);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\nsuccess:\n\n    ret = 0;\n\nfail:\n\n    qemu_vfree(buf);\n\n    g_free(out_buf);\n\n    return ret;\n\n}\n", "idx": 2213, "_split": "test", "_hash": "b09d57e322676cb5b86fd659fef6edce"}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mfrom(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n#endif\n\n}\n", "idx": 2229, "_split": "test", "_hash": "050d182dfe77b5bbb47c0f2066e428f1"}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static gboolean ga_channel_open(GAChannel *c, const gchar *path,\n\n                                GAChannelMethod method, int fd)\n\n{\n\n    int ret;\n\n    c->method = method;\n\n\n\n    switch (c->method) {\n\n    case GA_CHANNEL_VIRTIO_SERIAL: {\n\n        assert(fd < 0);\n\n        fd = qemu_open(path, O_RDWR | O_NONBLOCK\n\n#ifndef CONFIG_SOLARIS\n\n                           | O_ASYNC\n\n#endif\n\n                           );\n\n        if (fd == -1) {\n\n            g_critical(\"error opening channel: %s\", strerror(errno));\n\n            return false;\n\n        }\n\n#ifdef CONFIG_SOLARIS\n\n        ret = ioctl(fd, I_SETSIG, S_OUTPUT | S_INPUT | S_HIPRI);\n\n        if (ret == -1) {\n\n            g_critical(\"error setting event mask for channel: %s\",\n\n                       strerror(errno));\n\n            close(fd);\n\n            return false;\n\n        }\n\n#endif\n\n        ret = ga_channel_client_add(c, fd);\n\n        if (ret) {\n\n            g_critical(\"error adding channel to main loop\");\n\n            close(fd);\n\n            return false;\n\n        }\n\n        break;\n\n    }\n\n    case GA_CHANNEL_ISA_SERIAL: {\n\n        struct termios tio;\n\n\n\n        assert(fd < 0);\n\n        fd = qemu_open(path, O_RDWR | O_NOCTTY | O_NONBLOCK);\n\n        if (fd == -1) {\n\n            g_critical(\"error opening channel: %s\", strerror(errno));\n\n            return false;\n\n        }\n\n        tcgetattr(fd, &tio);\n\n        /* set up serial port for non-canonical, dumb byte streaming */\n\n        tio.c_iflag &= ~(IGNBRK | BRKINT | IGNPAR | PARMRK | INPCK | ISTRIP |\n\n                         INLCR | IGNCR | ICRNL | IXON | IXOFF | IXANY |\n\n                         IMAXBEL);\n\n        tio.c_oflag = 0;\n\n        tio.c_lflag = 0;\n\n        tio.c_cflag |= GA_CHANNEL_BAUDRATE_DEFAULT;\n\n        /* 1 available byte min or reads will block (we'll set non-blocking\n\n         * elsewhere, else we have to deal with read()=0 instead)\n\n         */\n\n        tio.c_cc[VMIN] = 1;\n\n        tio.c_cc[VTIME] = 0;\n\n        /* flush everything waiting for read/xmit, it's garbage at this point */\n\n        tcflush(fd, TCIFLUSH);\n\n        tcsetattr(fd, TCSANOW, &tio);\n\n        ret = ga_channel_client_add(c, fd);\n\n        if (ret) {\n\n            g_critical(\"error adding channel to main loop\");\n\n            close(fd);\n\n            return false;\n\n        }\n\n        break;\n\n    }\n\n    case GA_CHANNEL_UNIX_LISTEN: {\n\n        if (fd < 0) {\n\n            Error *local_err = NULL;\n\n\n\n            fd = unix_listen(path, NULL, strlen(path), &local_err);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n        }\n\n        ga_channel_listen_add(c, fd, true);\n\n        break;\n\n    }\n\n    case GA_CHANNEL_VSOCK_LISTEN: {\n\n        if (fd < 0) {\n\n            Error *local_err = NULL;\n\n            SocketAddress *addr;\n\n            char *addr_str;\n\n\n\n            addr_str = g_strdup_printf(\"vsock:%s\", path);\n\n            addr = socket_parse(addr_str, &local_err);\n\n            g_free(addr_str);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n\n\n            fd = socket_listen(addr, &local_err);\n\n            qapi_free_SocketAddress(addr);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n        }\n\n        ga_channel_listen_add(c, fd, true);\n\n        break;\n\n    }\n\n    default:\n\n        g_critical(\"error binding/listening to specified socket\");\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 2265, "_split": "test", "_hash": "8474daeb692828fbdbc18266c58ba192"}
{"project": "qemu", "commit_id": "17ad9b358bceba78ae80f2963c6036eab726010c", "target": 0, "func": "static int ram_save_block(QEMUFile *f)\n\n{\n\n    RAMBlock *block = last_block;\n\n    ram_addr_t offset = last_offset;\n\n    int bytes_sent = -1;\n\n    MemoryRegion *mr;\n\n\n\n    if (!block)\n\n        block = QLIST_FIRST(&ram_list.blocks);\n\n\n\n    do {\n\n        mr = block->mr;\n\n        if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE,\n\n                                    DIRTY_MEMORY_MIGRATION)) {\n\n            uint8_t *p;\n\n            int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;\n\n\n\n            memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE,\n\n                                      DIRTY_MEMORY_MIGRATION);\n\n\n\n            p = memory_region_get_ram_ptr(mr) + offset;\n\n\n\n            if (is_dup_page(p)) {\n\n                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);\n\n                qemu_put_byte(f, *p);\n\n                bytes_sent = 1;\n\n            } else {\n\n                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);\n\n                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);\n\n                bytes_sent = TARGET_PAGE_SIZE;\n\n            }\n\n\n\n            break;\n\n        }\n\n\n\n        offset += TARGET_PAGE_SIZE;\n\n        if (offset >= block->length) {\n\n            offset = 0;\n\n            block = QLIST_NEXT(block, next);\n\n            if (!block)\n\n                block = QLIST_FIRST(&ram_list.blocks);\n\n        }\n\n    } while (block != last_block || offset != last_offset);\n\n\n\n    last_block = block;\n\n    last_offset = offset;\n\n\n\n    return bytes_sent;\n\n}\n", "idx": 2280, "_split": "test", "_hash": "58b53ffd29d3850efdbb9f362268435f"}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,\n\n    size_t len)\n\n{\n\n    hwaddr mapped_len = 0;\n\n    struct iovec *ventry;\n\n    assert(pkt);\n\n    assert(pkt->max_raw_frags > pkt->raw_frags);\n\n\n\n    if (!len) {\n\n        return true;\n\n     }\n\n\n\n    ventry = &pkt->raw[pkt->raw_frags];\n\n    mapped_len = len;\n\n\n\n    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);\n\n    ventry->iov_len = mapped_len;\n\n    pkt->raw_frags += !!ventry->iov_base;\n\n\n\n    if ((ventry->iov_base == NULL) || (len != mapped_len)) {\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 2297, "_split": "test", "_hash": "2560f0143b8026054142c8af5937ec73"}
{"project": "qemu", "commit_id": "cf29a570a7aa7abab66bf256fdf9540873590811", "target": 1, "func": "static void quorum_vote(QuorumAIOCB *acb)\n\n{\n\n    bool quorum = true;\n\n    int i, j, ret;\n\n    QuorumVoteValue hash;\n\n    BDRVQuorumState *s = acb->common.bs->opaque;\n\n    QuorumVoteVersion *winner;\n\n\n\n    if (quorum_has_too_much_io_failed(acb)) {\n\n        return;\n\n    }\n\n\n\n    /* get the index of the first successful read */\n\n    for (i = 0; i < s->num_children; i++) {\n\n        if (!acb->qcrs[i].ret) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    assert(i < s->num_children);\n\n\n\n    /* compare this read with all other successful reads stopping at quorum\n\n     * failure\n\n     */\n\n    for (j = i + 1; j < s->num_children; j++) {\n\n        if (acb->qcrs[j].ret) {\n\n            continue;\n\n        }\n\n        quorum = quorum_compare(acb, &acb->qcrs[i].qiov, &acb->qcrs[j].qiov);\n\n        if (!quorum) {\n\n            break;\n\n       }\n\n    }\n\n\n\n    /* Every successful read agrees */\n\n    if (quorum) {\n\n        quorum_copy_qiov(acb->qiov, &acb->qcrs[i].qiov);\n\n        return;\n\n    }\n\n\n\n    /* compute hashes for each successful read, also store indexes */\n\n    for (i = 0; i < s->num_children; i++) {\n\n        if (acb->qcrs[i].ret) {\n\n            continue;\n\n        }\n\n        ret = quorum_compute_hash(acb, i, &hash);\n\n        /* if ever the hash computation failed */\n\n        if (ret < 0) {\n\n            acb->vote_ret = ret;\n\n            goto free_exit;\n\n        }\n\n        quorum_count_vote(&acb->votes, &hash, i);\n\n    }\n\n\n\n    /* vote to select the most represented version */\n\n    winner = quorum_get_vote_winner(&acb->votes);\n\n\n\n    /* if the winner count is smaller than threshold the read fails */\n\n    if (winner->vote_count < s->threshold) {\n\n        quorum_report_failure(acb);\n\n        acb->vote_ret = -EIO;\n\n        goto free_exit;\n\n    }\n\n\n\n    /* we have a winner: copy it */\n\n    quorum_copy_qiov(acb->qiov, &acb->qcrs[winner->index].qiov);\n\n\n\n    /* some versions are bad print them */\n\n    quorum_report_bad_versions(s, acb, &winner->value);\n\n\n\nfree_exit:\n\n    /* free lists */\n\n    quorum_free_vote_list(&acb->votes);\n\n}\n", "idx": 2328, "_split": "test", "_hash": "87712dc9a2b6ec5cbf9efbfa88ae2955"}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void stellaris_init(const char *kernel_filename, const char *cpu_model,\n\n                           stellaris_board_info *board)\n\n{\n\n    static const int uart_irq[] = {5, 6, 33, 34};\n\n    static const int timer_irq[] = {19, 21, 23, 35};\n\n    static const uint32_t gpio_addr[7] =\n\n      { 0x40004000, 0x40005000, 0x40006000, 0x40007000,\n\n        0x40024000, 0x40025000, 0x40026000};\n\n    static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31};\n\n\n\n    qemu_irq *pic;\n\n    DeviceState *gpio_dev[7];\n\n    qemu_irq gpio_in[7][8];\n\n    qemu_irq gpio_out[7][8];\n\n    qemu_irq adc;\n\n    int sram_size;\n\n    int flash_size;\n\n    I2CBus *i2c;\n\n    DeviceState *dev;\n\n    int i;\n\n    int j;\n\n\n\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *flash = g_new(MemoryRegion, 1);\n\n    MemoryRegion *system_memory = get_system_memory();\n\n\n\n    flash_size = (((board->dc0 & 0xffff) + 1) << 1) * 1024;\n\n    sram_size = ((board->dc0 >> 18) + 1) * 1024;\n\n\n\n    /* Flash programming is done via the SCU, so pretend it is ROM.  */\n\n    memory_region_init_ram(flash, NULL, \"stellaris.flash\", flash_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(flash);\n\n    memory_region_set_readonly(flash, true);\n\n    memory_region_add_subregion(system_memory, 0, flash);\n\n\n\n    memory_region_init_ram(sram, NULL, \"stellaris.sram\", sram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(sram);\n\n    memory_region_add_subregion(system_memory, 0x20000000, sram);\n\n\n\n    pic = armv7m_init(system_memory, flash_size, NUM_IRQ_LINES,\n\n                      kernel_filename, cpu_model);\n\n\n\n    if (board->dc1 & (1 << 16)) {\n\n        dev = sysbus_create_varargs(TYPE_STELLARIS_ADC, 0x40038000,\n\n                                    pic[14], pic[15], pic[16], pic[17], NULL);\n\n        adc = qdev_get_gpio_in(dev, 0);\n\n    } else {\n\n        adc = NULL;\n\n    }\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (0x10000 << i)) {\n\n            dev = sysbus_create_simple(TYPE_STELLARIS_GPTM,\n\n                                       0x40030000 + i * 0x1000,\n\n                                       pic[timer_irq[i]]);\n\n            /* TODO: This is incorrect, but we get away with it because\n\n               the ADC output is only ever pulsed.  */\n\n            qdev_connect_gpio_out(dev, 0, adc);\n\n        }\n\n    }\n\n\n\n    stellaris_sys_init(0x400fe000, pic[28], board, nd_table[0].macaddr.a);\n\n\n\n    for (i = 0; i < 7; i++) {\n\n        if (board->dc4 & (1 << i)) {\n\n            gpio_dev[i] = sysbus_create_simple(\"pl061_luminary\", gpio_addr[i],\n\n                                               pic[gpio_irq[i]]);\n\n            for (j = 0; j < 8; j++) {\n\n                gpio_in[i][j] = qdev_get_gpio_in(gpio_dev[i], j);\n\n                gpio_out[i][j] = NULL;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (board->dc2 & (1 << 12)) {\n\n        dev = sysbus_create_simple(TYPE_STELLARIS_I2C, 0x40020000, pic[8]);\n\n        i2c = (I2CBus *)qdev_get_child_bus(dev, \"i2c\");\n\n        if (board->peripherals & BP_OLED_I2C) {\n\n            i2c_create_slave(i2c, \"ssd0303\", 0x3d);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (1 << i)) {\n\n            sysbus_create_simple(\"pl011_luminary\", 0x4000c000 + i * 0x1000,\n\n                                 pic[uart_irq[i]]);\n\n        }\n\n    }\n\n    if (board->dc2 & (1 << 4)) {\n\n        dev = sysbus_create_simple(\"pl022\", 0x40008000, pic[7]);\n\n        if (board->peripherals & BP_OLED_SSI) {\n\n            void *bus;\n\n            DeviceState *sddev;\n\n            DeviceState *ssddev;\n\n\n\n            /* Some boards have both an OLED controller and SD card connected to\n\n             * the same SSI port, with the SD card chip select connected to a\n\n             * GPIO pin.  Technically the OLED chip select is connected to the\n\n             * SSI Fss pin.  We do not bother emulating that as both devices\n\n             * should never be selected simultaneously, and our OLED controller\n\n             * ignores stray 0xff commands that occur when deselecting the SD\n\n             * card.\n\n             */\n\n            bus = qdev_get_child_bus(dev, \"ssi\");\n\n\n\n            sddev = ssi_create_slave(bus, \"ssi-sd\");\n\n            ssddev = ssi_create_slave(bus, \"ssd0323\");\n\n            gpio_out[GPIO_D][0] = qemu_irq_split(\n\n                    qdev_get_gpio_in_named(sddev, SSI_GPIO_CS, 0),\n\n                    qdev_get_gpio_in_named(ssddev, SSI_GPIO_CS, 0));\n\n            gpio_out[GPIO_C][7] = qdev_get_gpio_in(ssddev, 0);\n\n\n\n            /* Make sure the select pin is high.  */\n\n            qemu_irq_raise(gpio_out[GPIO_D][0]);\n\n        }\n\n    }\n\n    if (board->dc4 & (1 << 28)) {\n\n        DeviceState *enet;\n\n\n\n        qemu_check_nic_model(&nd_table[0], \"stellaris\");\n\n\n\n        enet = qdev_create(NULL, \"stellaris_enet\");\n\n        qdev_set_nic_properties(enet, &nd_table[0]);\n\n        qdev_init_nofail(enet);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(enet), 0, 0x40048000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(enet), 0, pic[42]);\n\n    }\n\n    if (board->peripherals & BP_GAMEPAD) {\n\n        qemu_irq gpad_irq[5];\n\n        static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d };\n\n\n\n        gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); /* up */\n\n        gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); /* down */\n\n        gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); /* left */\n\n        gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); /* right */\n\n        gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); /* select */\n\n\n\n        stellaris_gamepad_init(5, gpad_irq, gpad_keycode);\n\n    }\n\n    for (i = 0; i < 7; i++) {\n\n        if (board->dc4 & (1 << i)) {\n\n            for (j = 0; j < 8; j++) {\n\n                if (gpio_out[i][j]) {\n\n                    qdev_connect_gpio_out(gpio_dev[i], j, gpio_out[i][j]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 2329, "_split": "test", "_hash": "3df982bbc9566662f7984dff40f67b4d"}
{"project": "qemu", "commit_id": "6658ffb81ee56a510d7d77025872a508a9adce3a", "target": 1, "func": "void cpu_exec_init(CPUState *env)\n\n{\n\n    CPUState **penv;\n\n    int cpu_index;\n\n\n\n    if (!code_gen_ptr) {\n\n        code_gen_ptr = code_gen_buffer;\n\n        page_init();\n\n        io_mem_init();\n\n    }\n\n    env->next_cpu = NULL;\n\n    penv = &first_cpu;\n\n    cpu_index = 0;\n\n    while (*penv != NULL) {\n\n        penv = (CPUState **)&(*penv)->next_cpu;\n\n        cpu_index++;\n\n    }\n\n    env->cpu_index = cpu_index;\n\n\n    *penv = env;\n\n}", "idx": 2334, "_split": "test", "_hash": "16d14270aeed2678bc238231d2121451"}
{"project": "qemu", "commit_id": "65207c59d99f2260c5f1d3b9c491146616a522aa", "target": 1, "func": "static inline bool handler_is_async(const mon_cmd_t *cmd)\n\n{\n\n    return cmd->flags & MONITOR_CMD_ASYNC;\n\n}\n", "idx": 2349, "_split": "test", "_hash": "fa94469bec21b7e8baf889ad4d30aa27"}
{"project": "qemu", "commit_id": "e167adc9d9f5df4f8109aecd4552c407fdce094a", "target": 1, "func": "static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,\n\n                                   unsigned int imms, unsigned int immr)\n\n{\n\n    uint64_t mask;\n\n    unsigned e, levels, s, r;\n\n    int len;\n\n\n\n    assert(immn < 2 && imms < 64 && immr < 64);\n\n\n\n    /* The bit patterns we create here are 64 bit patterns which\n\n     * are vectors of identical elements of size e = 2, 4, 8, 16, 32 or\n\n     * 64 bits each. Each element contains the same value: a run\n\n     * of between 1 and e-1 non-zero bits, rotated within the\n\n     * element by between 0 and e-1 bits.\n\n     *\n\n     * The element size and run length are encoded into immn (1 bit)\n\n     * and imms (6 bits) as follows:\n\n     * 64 bit elements: immn = 1, imms = <length of run - 1>\n\n     * 32 bit elements: immn = 0, imms = 0 : <length of run - 1>\n\n     * 16 bit elements: immn = 0, imms = 10 : <length of run - 1>\n\n     *  8 bit elements: immn = 0, imms = 110 : <length of run - 1>\n\n     *  4 bit elements: immn = 0, imms = 1110 : <length of run - 1>\n\n     *  2 bit elements: immn = 0, imms = 11110 : <length of run - 1>\n\n     * Notice that immn = 0, imms = 11111x is the only combination\n\n     * not covered by one of the above options; this is reserved.\n\n     * Further, <length of run - 1> all-ones is a reserved pattern.\n\n     *\n\n     * In all cases the rotation is by immr % e (and immr is 6 bits).\n\n     */\n\n\n\n    /* First determine the element size */\n\n    len = 31 - clz32((immn << 6) | (~imms & 0x3f));\n\n    if (len < 1) {\n\n        /* This is the immn == 0, imms == 0x11111x case */\n\n        return false;\n\n    }\n\n    e = 1 << len;\n\n\n\n    levels = e - 1;\n\n    s = imms & levels;\n\n    r = immr & levels;\n\n\n\n    if (s == levels) {\n\n        /* <length of run - 1> mustn't be all-ones. */\n\n        return false;\n\n    }\n\n\n\n    /* Create the value of one element: s+1 set bits rotated\n\n     * by r within the element (which is e bits wide)...\n\n     */\n\n    mask = bitmask64(s + 1);\n\n    mask = (mask >> r) | (mask << (e - r));\n\n    /* ...then replicate the element over the whole 64 bit value */\n\n    mask = bitfield_replicate(mask, e);\n\n    *result = mask;\n\n    return true;\n\n}\n", "idx": 2395, "_split": "test", "_hash": "e55a0c1136cf3daecd71ccac08f74c7f"}
{"project": "qemu", "commit_id": "fae38221e78fc9f847965f6d18b359b8044df348", "target": 1, "func": "static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)\n\n{\n\n    if (r < 0 || r > 15) {\n\n        fprintf(stderr, \"wrong register write $p%d\\n\", r);\n\n    }\n\n    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {\n\n        return;\n\n    } else if (r == PR_SRS) {\n\n        tcg_gen_andi_tl(cpu_PR[r], tn, 3);\n\n    } else {\n\n        if (r == PR_PID) {\n\n            gen_helper_tlb_flush_pid(cpu_env, tn);\n\n        }\n\n        if (dc->tb_flags & S_FLAG && r == PR_SPC) {\n\n            gen_helper_spc_write(cpu_env, tn);\n\n        } else if (r == PR_CCS) {\n\n            dc->cpustate_changed = 1;\n\n        }\n\n        tcg_gen_mov_tl(cpu_PR[r], tn);\n\n    }\n\n}\n", "idx": 2415, "_split": "test", "_hash": "9513e589b10260e3cf1d063a7d1c020c"}
{"project": "qemu", "commit_id": "c1bf3531aecf4a0ba25bb150dd5fe21edf406c88", "target": 1, "func": "static int net_vhost_user_init(NetClientState *peer, const char *device,\n\n                               const char *name, CharDriverState *chr,\n\n                               int queues)\n\n{\n\n    NetClientState *nc;\n\n    VhostUserState *s;\n\n    int i;\n\n\n\n    for (i = 0; i < queues; i++) {\n\n        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);\n\n\n\n        snprintf(nc->info_str, sizeof(nc->info_str), \"vhost-user%d to %s\",\n\n                 i, chr->label);\n\n\n\n        nc->queue_index = i;\n\n\n\n        s = DO_UPCAST(VhostUserState, nc, nc);\n\n        s->chr = chr;\n\n    }\n\n\n\n    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name);\n\n\n\n    return 0;\n\n}\n", "idx": 2451, "_split": "test", "_hash": "a82e907eb84ac6525847c7261e289aa3"}
{"project": "qemu", "commit_id": "6fa2c95f279dda62aa7e3292cc424ff3fab6a602", "target": 0, "func": "static void scsi_read_data(SCSIDevice *d, uint32_t tag)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n\n    SCSIDiskReq *r;\n\n\n\n    r = scsi_find_request(s, tag);\n\n    if (!r) {\n\n        BADF(\"Bad read tag 0x%x\\n\", tag);\n\n        /* ??? This is the wrong error.  */\n\n        scsi_command_complete(r, CHECK_CONDITION, HARDWARE_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    scsi_read_request(r);\n\n}\n", "idx": 2471, "_split": "test", "_hash": "e801943cfcd7a03a9c0a3743ccc10e06"}
{"project": "qemu", "commit_id": "8653c0158c23ec592f0041ab48b83d6cc6d152fe", "target": 0, "func": "static int spawn_thread(void)\n\n{\n\n    pthread_attr_t attr;\n\n    int ret;\n\n\n\n    cur_threads++;\n\n    idle_threads++;\n\n\n\n    pthread_attr_init(&attr);\n\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);\n\n    pthread_attr_destroy(&attr);\n\n\n\n    return ret;\n\n}\n", "idx": 2523, "_split": "test", "_hash": "fffc51feef11985de3edd917226dd9e8"}
{"project": "qemu", "commit_id": "1f8431f42d833e8914f2d16ce4a49b7b72b90db0", "target": 0, "func": "bool machine_iommu(MachineState *machine)\n\n{\n\n    return machine->iommu;\n\n}\n", "idx": 2535, "_split": "test", "_hash": "b92c9c07e17bc0b1e178ee5f37680958"}
{"project": "qemu", "commit_id": "cc68890166c2c1c5003e3eeb8535e1872e239a95", "target": 0, "func": "static int disas_cp15_insn(CPUState *env, DisasContext *s, uint32_t insn)\n\n{\n\n    uint32_t rd;\n\n    TCGv tmp, tmp2;\n\n\n\n    /* M profile cores use memory mapped registers instead of cp15.  */\n\n    if (arm_feature(env, ARM_FEATURE_M))\n\n\treturn 1;\n\n\n\n    if ((insn & (1 << 25)) == 0) {\n\n        if (insn & (1 << 20)) {\n\n            /* mrrc */\n\n            return 1;\n\n        }\n\n        /* mcrr.  Used for block cache operations, so implement as no-op.  */\n\n        return 0;\n\n    }\n\n    if ((insn & (1 << 4)) == 0) {\n\n        /* cdp */\n\n        return 1;\n\n    }\n\n    if (IS_USER(s) && !cp15_user_ok(insn)) {\n\n        return 1;\n\n    }\n\n    if ((insn & 0x0fff0fff) == 0x0e070f90\n\n        || (insn & 0x0fff0fff) == 0x0e070f58) {\n\n        /* Wait for interrupt.  */\n\n        gen_set_pc_im(s->pc);\n\n        s->is_jmp = DISAS_WFI;\n\n        return 0;\n\n    }\n\n    rd = (insn >> 12) & 0xf;\n\n\n\n    if (cp15_tls_load_store(env, s, insn, rd))\n\n        return 0;\n\n\n\n    tmp2 = tcg_const_i32(insn);\n\n    if (insn & ARM_CP_RW_BIT) {\n\n        tmp = new_tmp();\n\n        gen_helper_get_cp15(tmp, cpu_env, tmp2);\n\n        /* If the destination register is r15 then sets condition codes.  */\n\n        if (rd != 15)\n\n            store_reg(s, rd, tmp);\n\n        else\n\n            dead_tmp(tmp);\n\n    } else {\n\n        tmp = load_reg(s, rd);\n\n        gen_helper_set_cp15(cpu_env, tmp2, tmp);\n\n        dead_tmp(tmp);\n\n        /* Normally we would always end the TB here, but Linux\n\n         * arch/arm/mach-pxa/sleep.S expects two instructions following\n\n         * an MMU enable to execute from cache.  Imitate this behaviour.  */\n\n        if (!arm_feature(env, ARM_FEATURE_XSCALE) ||\n\n                (insn & 0x0fff0fff) != 0x0e010f10)\n\n            gen_lookup_tb(s);\n\n    }\n\n    tcg_temp_free_i32(tmp2);\n\n    return 0;\n\n}\n", "idx": 2538, "_split": "test", "_hash": "ec62b5aa0e955deb0aca4cfbfd908da8"}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static CharDriverState *vc_init(const char *id, ChardevBackend *backend,\n\n                                ChardevReturn *ret, Error **errp)\n\n{\n\n    return vc_handler(backend->u.vc, errp);\n\n}\n", "idx": 2564, "_split": "test", "_hash": "fe11c37b5cba65e0f4373af980d9a30d"}
{"project": "qemu", "commit_id": "1f3870ab242018b724b845957f7f928a2d7c1f5b", "target": 0, "func": "USBDevice *usb_host_device_open(const char *devname)\n\n{\n\n    int fd = -1, ret;\n\n    USBHostDevice *dev = NULL;\n\n    struct usbdevfs_connectinfo ci;\n\n    char buf[1024];\n\n    int bus_num, addr;\n\n    char product_name[PRODUCT_NAME_SZ];\n\n\n\n    dev = qemu_mallocz(sizeof(USBHostDevice));\n\n    if (!dev)\n\n        goto fail;\n\n\n\n#ifdef DEBUG_ISOCH\n\n    printf(\"usb_host_device_open %s\\n\", devname);\n\n#endif\n\n    if (usb_host_find_device(&bus_num, &addr,\n\n                             product_name, sizeof(product_name),\n\n                             devname) < 0)\n\n        return NULL;\n\n\n\n    snprintf(buf, sizeof(buf), USBDEVFS_PATH \"/%03d/%03d\",\n\n             bus_num, addr);\n\n    fd = open(buf, O_RDWR | O_NONBLOCK);\n\n    if (fd < 0) {\n\n        perror(buf);\n\n        return NULL;\n\n    }\n\n\n\n    /* read the device description */\n\n    dev->descr_len = read(fd, dev->descr, sizeof(dev->descr));\n\n    if (dev->descr_len <= 0) {\n\n        perror(\"usb_host_device_open: reading device data failed\");\n\n        goto fail;\n\n    }\n\n\n\n#ifdef DEBUG\n\n    {\n\n        int x;\n\n        printf(\"=== begin dumping device descriptor data ===\\n\");\n\n        for (x = 0; x < dev->descr_len; x++)\n\n            printf(\"%02x \", dev->descr[x]);\n\n        printf(\"\\n=== end dumping device descriptor data ===\\n\");\n\n    }\n\n#endif\n\n\n\n    dev->fd = fd;\n\n    dev->configuration = 1;\n\n\n\n    /* XXX - do something about initial configuration */\n\n    if (!usb_host_update_interfaces(dev, 1))\n\n        goto fail;\n\n\n\n    ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci);\n\n    if (ret < 0) {\n\n        perror(\"usb_host_device_open: USBDEVFS_CONNECTINFO\");\n\n        goto fail;\n\n    }\n\n\n\n#ifdef DEBUG\n\n    printf(\"host USB device %d.%d grabbed\\n\", bus_num, addr);\n\n#endif\n\n\n\n    ret = usb_linux_update_endp_table(dev);\n\n    if (ret)\n\n        goto fail;\n\n\n\n    if (ci.slow)\n\n        dev->dev.speed = USB_SPEED_LOW;\n\n    else\n\n        dev->dev.speed = USB_SPEED_HIGH;\n\n    dev->dev.handle_packet = usb_generic_handle_packet;\n\n\n\n    dev->dev.handle_reset = usb_host_handle_reset;\n\n    dev->dev.handle_control = usb_host_handle_control;\n\n    dev->dev.handle_data = usb_host_handle_data;\n\n    dev->dev.handle_destroy = usb_host_handle_destroy;\n\n\n\n    if (product_name[0] == '\\0')\n\n        snprintf(dev->dev.devname, sizeof(dev->dev.devname),\n\n                 \"host:%s\", devname);\n\n    else\n\n        pstrcpy(dev->dev.devname, sizeof(dev->dev.devname),\n\n                product_name);\n\n\n\n#ifdef USE_ASYNCIO\n\n    /* set up the signal handlers */\n\n    sigemptyset(&sigact.sa_mask);\n\n    sigact.sa_sigaction = isoch_done;\n\n    sigact.sa_flags = SA_SIGINFO;\n\n    sigact.sa_restorer = 0;\n\n    ret = sigaction(SIG_ISOCOMPLETE, &sigact, NULL);\n\n    if (ret < 0) {\n\n        perror(\"usb_host_device_open: sigaction failed\");\n\n        goto fail;\n\n    }\n\n\n\n    if (pipe(dev->pipe_fds) < 0) {\n\n        perror(\"usb_host_device_open: pipe creation failed\");\n\n        goto fail;\n\n    }\n\n    fcntl(dev->pipe_fds[0], F_SETFL, O_NONBLOCK | O_ASYNC);\n\n    fcntl(dev->pipe_fds[1], F_SETFL, O_NONBLOCK);\n\n    qemu_set_fd_handler(dev->pipe_fds[0], urb_completion_pipe_read, NULL, dev);\n\n#endif\n\n    dev->urbs_ready = 0;\n\n    return (USBDevice *)dev;\n\nfail:\n\n    if (dev)\n\n        qemu_free(dev);\n\n    close(fd);\n\n    return NULL;\n\n}\n", "idx": 2583, "_split": "test", "_hash": "f13f489790cd28a90aadd0b6a205f9f5"}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)\n\n{\n\n    CPU_DoubleU farg;\n\n    float32 f32;\n\n\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN square root */\n\n        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n    }\n\n    f32 = float64_to_float32(farg.d, &env->fp_status);\n\n    farg.d = float32_to_float64(f32, &env->fp_status);\n\n\n\n    return farg.ll;\n\n}\n", "idx": 2594, "_split": "test", "_hash": "423744f0643bd74a2205679248808a8e"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "int gen_new_label(void)\n\n{\n\n    TCGContext *s = &tcg_ctx;\n\n    int idx;\n\n    TCGLabel *l;\n\n\n\n    if (s->nb_labels >= TCG_MAX_LABELS)\n\n        tcg_abort();\n\n    idx = s->nb_labels++;\n\n    l = &s->labels[idx];\n\n    l->has_value = 0;\n\n    l->u.first_reloc = NULL;\n\n    return idx;\n\n}\n", "idx": 2602, "_split": "test", "_hash": "7c27992d9904ed0f7fed776eace4a825"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_round_to_clusters(BlockDriverState *bs,\n\n                            int64_t sector_num, int nb_sectors,\n\n                            int64_t *cluster_sector_num,\n\n                            int *cluster_nb_sectors)\n\n{\n\n    BlockDriverInfo bdi;\n\n\n\n    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {\n\n        *cluster_sector_num = sector_num;\n\n        *cluster_nb_sectors = nb_sectors;\n\n    } else {\n\n        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;\n\n        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);\n\n        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +\n\n                                            nb_sectors, c);\n\n    }\n\n}\n", "idx": 2604, "_split": "test", "_hash": "a7cd4f505100459ff56dae66acf9aeef"}
{"project": "qemu", "commit_id": "b0706b716769494f321a0d2bfd9fa9893992f995", "target": 1, "func": "void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length)\n\n{\n\n    CPUArchState *env;\n\n\n\n    int mmu_idx;\n\n\n\n    assert_cpu_is_self(cpu);\n\n\n\n    env = cpu->env_ptr;\n\n    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {\n\n        unsigned int i;\n\n\n\n        for (i = 0; i < CPU_TLB_SIZE; i++) {\n\n            tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i],\n\n                                  start1, length);\n\n        }\n\n\n\n        for (i = 0; i < CPU_VTLB_SIZE; i++) {\n\n            tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i],\n\n                                  start1, length);\n\n        }\n\n    }\n\n}\n", "idx": 2620, "_split": "test", "_hash": "b48749afaad52cb41e90ff1a4f62d18b"}
{"project": "qemu", "commit_id": "e0ef439588ce1ede747f82b77d893190c1cc9f4d", "target": 1, "func": "blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,\n                   QEMUIOVector *qiov, int flags)\n{\n    BDRVBlkdebugState *s = bs->opaque;\n    BlkdebugRule *rule = NULL;\n    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {\n        uint64_t inject_offset = rule->options.inject.offset;\n        if (inject_offset == -1 ||\n            (inject_offset >= offset && inject_offset < offset + bytes))\n        {\n            break;\n    if (rule && rule->options.inject.error) {\n        return inject_error(bs, rule);\n    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);", "idx": 2622, "_split": "test", "_hash": "02605ff34099ac145acf4ae203195fd4"}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int idreg_init1(SysBusDevice *dev)\n\n{\n\n    IDRegState *s = MACIO_ID_REGISTER(dev);\n\n\n\n    memory_region_init_ram(&s->mem, OBJECT(s),\n\n                           \"sun4m.idreg\", sizeof(idreg_data), &error_abort);\n\n    vmstate_register_ram_global(&s->mem);\n\n    memory_region_set_readonly(&s->mem, true);\n\n    sysbus_init_mmio(dev, &s->mem);\n\n    return 0;\n\n}\n", "idx": 2624, "_split": "test", "_hash": "431d4e6ac71f23d245511dcaae76addb"}
{"project": "qemu", "commit_id": "f02ca5cbeaf86038834c1953247a1579d7921927", "target": 0, "func": "static inline void tcg_out_ld_ptr(TCGContext *s, int ret,\n\n                                  tcg_target_long arg)\n\n{\n\n#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)\n\n    if (arg != (arg & 0xffffffff))\n\n        fprintf(stderr, \"unimplemented %s with offset %ld\\n\", __func__, arg);\n\n    if (arg != (arg & 0xfff))\n\n        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));\n\n    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |\n\n              INSN_IMM13(arg & 0x3ff));\n\n#else\n\n    tcg_out_ld_raw(s, ret, arg);\n\n#endif\n\n}\n", "idx": 2628, "_split": "test", "_hash": "d1d60cd6417941f358a3efd1a1c15bfb"}
{"project": "qemu", "commit_id": "95b5edcd92d64c7b8fe9f2e3e0725fdf84be0dfa", "target": 0, "func": "int xen_config_dev_blk(DriveInfo *disk)\n\n{\n\n    char fe[256], be[256];\n\n    int vdev = 202 * 256 + 16 * disk->unit;\n\n    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;\n\n    const char *devtype = cdrom ? \"cdrom\" : \"disk\";\n\n    const char *mode    = cdrom ? \"r\"     : \"w\";\n\n\n\n    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),\n\n\t     \"xvd%c\", 'a' + disk->unit);\n\n    xen_be_printf(NULL, 1, \"config disk %d [%s]: %s\\n\",\n\n                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);\n\n    xen_config_dev_dirs(\"vbd\", \"qdisk\", vdev, fe, be, sizeof(fe));\n\n\n\n    /* frontend */\n\n    xenstore_write_int(fe, \"virtual-device\",  vdev);\n\n    xenstore_write_str(fe, \"device-type\",     devtype);\n\n\n\n    /* backend */\n\n    xenstore_write_str(be, \"dev\",             disk->bdrv->device_name);\n\n    xenstore_write_str(be, \"type\",            \"file\");\n\n    xenstore_write_str(be, \"params\",          disk->bdrv->filename);\n\n    xenstore_write_str(be, \"mode\",            mode);\n\n\n\n    /* common stuff */\n\n    return xen_config_dev_all(fe, be);\n\n}\n", "idx": 2632, "_split": "test", "_hash": "245f33ab8d566921572b6209b43225c9"}
{"project": "qemu", "commit_id": "cd42d5b23691ad73edfd6dbcfc935a960a9c5a65", "target": 0, "func": "static inline void gen_intermediate_code_internal(OpenRISCCPU *cpu,\n\n                                                  TranslationBlock *tb,\n\n                                                  int search_pc)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    struct DisasContext ctx, *dc = &ctx;\n\n    uint16_t *gen_opc_end;\n\n    uint32_t pc_start;\n\n    int j, k;\n\n    uint32_t next_page_start;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n    dc->tb = tb;\n\n\n\n    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->ppc = pc_start;\n\n    dc->pc = pc_start;\n\n    dc->flags = cpu->env.cpucfgr;\n\n    dc->mem_idx = cpu_mmu_index(&cpu->env);\n\n    dc->synced_flags = dc->tb_flags = tb->flags;\n\n    dc->delayed_branch = !!(dc->tb_flags & D_FLAG);\n\n    dc->singlestep_enabled = cs->singlestep_enabled;\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"-----------------------------------------\\n\");\n\n        log_cpu_state(CPU(cpu), 0);\n\n    }\n\n\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    k = -1;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n\n\n    if (max_insns == 0) {\n\n        max_insns = CF_COUNT_MASK;\n\n    }\n\n\n\n    gen_tb_start();\n\n\n\n    do {\n\n        check_breakpoint(cpu, dc);\n\n        if (search_pc) {\n\n            j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n            if (k < j) {\n\n                k++;\n\n                while (k < j) {\n\n                    tcg_ctx.gen_opc_instr_start[k++] = 0;\n\n                }\n\n            }\n\n            tcg_ctx.gen_opc_pc[k] = dc->pc;\n\n            tcg_ctx.gen_opc_instr_start[k] = 1;\n\n            tcg_ctx.gen_opc_icount[k] = num_insns;\n\n        }\n\n\n\n        if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n            tcg_gen_debug_insn_start(dc->pc);\n\n        }\n\n\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO)) {\n\n            gen_io_start();\n\n        }\n\n        dc->ppc = dc->pc - 4;\n\n        dc->npc = dc->pc + 4;\n\n        tcg_gen_movi_tl(cpu_ppc, dc->ppc);\n\n        tcg_gen_movi_tl(cpu_npc, dc->npc);\n\n        disas_openrisc_insn(dc, cpu);\n\n        dc->pc = dc->npc;\n\n        num_insns++;\n\n        /* delay slot */\n\n        if (dc->delayed_branch) {\n\n            dc->delayed_branch--;\n\n            if (!dc->delayed_branch) {\n\n                dc->tb_flags &= ~D_FLAG;\n\n                gen_sync_flags(dc);\n\n                tcg_gen_mov_tl(cpu_pc, jmp_pc);\n\n                tcg_gen_mov_tl(cpu_npc, jmp_pc);\n\n                tcg_gen_movi_tl(jmp_pc, 0);\n\n                tcg_gen_exit_tb(0);\n\n                dc->is_jmp = DISAS_JUMP;\n\n                break;\n\n            }\n\n        }\n\n    } while (!dc->is_jmp\n\n             && tcg_ctx.gen_opc_ptr < gen_opc_end\n\n             && !cs->singlestep_enabled\n\n             && !singlestep\n\n             && (dc->pc < next_page_start)\n\n             && num_insns < max_insns);\n\n\n\n    if (tb->cflags & CF_LAST_IO) {\n\n        gen_io_end();\n\n    }\n\n    if (dc->is_jmp == DISAS_NEXT) {\n\n        dc->is_jmp = DISAS_UPDATE;\n\n        tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n    }\n\n    if (unlikely(cs->singlestep_enabled)) {\n\n        if (dc->is_jmp == DISAS_NEXT) {\n\n            tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n        }\n\n        gen_exception(dc, EXCP_DEBUG);\n\n    } else {\n\n        switch (dc->is_jmp) {\n\n        case DISAS_NEXT:\n\n            gen_goto_tb(dc, 0, dc->pc);\n\n            break;\n\n        default:\n\n        case DISAS_JUMP:\n\n            break;\n\n        case DISAS_UPDATE:\n\n            /* indicate that the hash table must be used\n\n               to find the next TB */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case DISAS_TB_JUMP:\n\n            /* nothing more to generate */\n\n            break;\n\n        }\n\n    }\n\n\n\n    gen_tb_end(tb, num_insns);\n\n    *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n        k++;\n\n        while (k <= j) {\n\n            tcg_ctx.gen_opc_instr_start[k++] = 0;\n\n        }\n\n    } else {\n\n        tb->size = dc->pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"\\n\");\n\n        log_target_disas(&cpu->env, pc_start, dc->pc - pc_start, 0);\n\n        qemu_log(\"\\nisize=%d osize=%td\\n\",\n\n            dc->pc - pc_start, tcg_ctx.gen_opc_ptr -\n\n            tcg_ctx.gen_opc_buf);\n\n    }\n\n#endif\n\n}\n", "idx": 2634, "_split": "test", "_hash": "42b3f228e699326aa0025016d20a66b5"}
{"project": "qemu", "commit_id": "3a55fc0f243104998bee5106b121cff257df5d33", "target": 1, "func": "static void pci_ivshmem_realize(PCIDevice *dev, Error **errp)\n\n{\n\n    IVShmemState *s = IVSHMEM(dev);\n\n    Error *err = NULL;\n\n    uint8_t *pci_conf;\n\n    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n        PCI_BASE_ADDRESS_MEM_PREFETCH;\n\n\n\n    if (!!s->server_chr + !!s->shmobj + !!s->hostmem != 1) {\n\n        error_setg(errp,\n\n                   \"You must specify either 'shm', 'chardev' or 'x-memdev'\");\n\n        return;\n\n    }\n\n\n\n    if (s->hostmem) {\n\n        MemoryRegion *mr;\n\n\n\n        if (s->sizearg) {\n\n            g_warning(\"size argument ignored with hostmem\");\n\n        }\n\n\n\n        mr = host_memory_backend_get_memory(s->hostmem, &error_abort);\n\n        s->ivshmem_size = memory_region_size(mr);\n\n    } else if (s->sizearg == NULL) {\n\n        s->ivshmem_size = 4 << 20; /* 4 MB default */\n\n    } else {\n\n        char *end;\n\n        int64_t size = qemu_strtosz(s->sizearg, &end);\n\n        if (size < 0 || *end != '\\0' || !is_power_of_2(size)) {\n\n            error_setg(errp, \"Invalid size %s\", s->sizearg);\n\n            return;\n\n        }\n\n        s->ivshmem_size = size;\n\n    }\n\n\n\n    /* IRQFD requires MSI */\n\n    if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) &&\n\n        !ivshmem_has_feature(s, IVSHMEM_MSI)) {\n\n        error_setg(errp, \"ioeventfd/irqfd requires MSI\");\n\n        return;\n\n    }\n\n\n\n    /* check that role is reasonable */\n\n    if (s->role) {\n\n        if (strncmp(s->role, \"peer\", 5) == 0) {\n\n            s->role_val = IVSHMEM_PEER;\n\n        } else if (strncmp(s->role, \"master\", 7) == 0) {\n\n            s->role_val = IVSHMEM_MASTER;\n\n        } else {\n\n            error_setg(errp, \"'role' must be 'peer' or 'master'\");\n\n            return;\n\n        }\n\n    } else {\n\n        s->role_val = IVSHMEM_MASTER; /* default */\n\n    }\n\n\n\n    pci_conf = dev->config;\n\n    pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;\n\n\n\n    /*\n\n     * Note: we don't use INTx with IVSHMEM_MSI at all, so this is a\n\n     * bald-faced lie then.  But it's a backwards compatible lie.\n\n     */\n\n    pci_config_set_interrupt_pin(pci_conf, 1);\n\n\n\n    memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s,\n\n                          \"ivshmem-mmio\", IVSHMEM_REG_BAR_SIZE);\n\n\n\n    /* region for registers*/\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                     &s->ivshmem_mmio);\n\n\n\n    memory_region_init(&s->bar, OBJECT(s), \"ivshmem-bar2-container\", s->ivshmem_size);\n\n    if (s->ivshmem_64bit) {\n\n        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;\n\n    }\n\n\n\n    if (s->hostmem != NULL) {\n\n        MemoryRegion *mr;\n\n\n\n        IVSHMEM_DPRINTF(\"using hostmem\\n\");\n\n\n\n        mr = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem),\n\n                                            &error_abort);\n\n        vmstate_register_ram(mr, DEVICE(s));\n\n        memory_region_add_subregion(&s->bar, 0, mr);\n\n        pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar);\n\n    } else if (s->server_chr != NULL) {\n\n        /* FIXME do not rely on what chr drivers put into filename */\n\n        if (strncmp(s->server_chr->filename, \"unix:\", 5)) {\n\n            error_setg(errp, \"chardev is not a unix client socket\");\n\n            return;\n\n        }\n\n\n\n        /* if we get a UNIX socket as the parameter we will talk\n\n         * to the ivshmem server to receive the memory region */\n\n\n\n        IVSHMEM_DPRINTF(\"using shared memory server (socket = %s)\\n\",\n\n                        s->server_chr->filename);\n\n\n\n        if (ivshmem_setup_interrupts(s) < 0) {\n\n            error_setg(errp, \"failed to initialize interrupts\");\n\n            return;\n\n        }\n\n\n\n        /* we allocate enough space for 16 peers and grow as needed */\n\n        resize_peers(s, 16);\n\n        s->vm_id = -1;\n\n\n\n        pci_register_bar(dev, 2, attr, &s->bar);\n\n\n\n        qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive,\n\n                              ivshmem_check_version, NULL, s);\n\n    } else {\n\n        /* just map the file immediately, we're not using a server */\n\n        int fd;\n\n\n\n        IVSHMEM_DPRINTF(\"using shm_open (shm object = %s)\\n\", s->shmobj);\n\n\n\n        /* try opening with O_EXCL and if it succeeds zero the memory\n\n         * by truncating to 0 */\n\n        if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL,\n\n                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {\n\n           /* truncate file to length PCI device's memory */\n\n            if (ftruncate(fd, s->ivshmem_size) != 0) {\n\n                error_report(\"could not truncate shared file\");\n\n            }\n\n\n\n        } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR,\n\n                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {\n\n            error_setg(errp, \"could not open shared file\");\n\n            return;\n\n        }\n\n\n\n        if (check_shm_size(s, fd, errp) == -1) {\n\n            return;\n\n        }\n\n\n\n        create_shared_memory_BAR(s, fd, attr, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n    }\n\n\n\n    fifo8_create(&s->incoming_fifo, sizeof(int64_t));\n\n\n\n    if (s->role_val == IVSHMEM_PEER) {\n\n        error_setg(&s->migration_blocker,\n\n                   \"Migration is disabled when using feature 'peer mode' in device 'ivshmem'\");\n\n        migrate_add_blocker(s->migration_blocker);\n\n    }\n\n}\n", "idx": 2649, "_split": "test", "_hash": "302b243e78fe28f5f9f2d897ff93ed26"}
{"project": "qemu", "commit_id": "ab2b9f174db088633922eaa82c2bcffd84e6bb94", "target": 1, "func": "int print_insn_lm32(bfd_vma memaddr, struct disassemble_info *info)\n\n{\n\n    fprintf_function fprintf_fn = info->fprintf_func;\n\n    void *stream = info->stream;\n\n    int rc;\n\n    uint8_t insn[4];\n\n    const Lm32OpcodeInfo *opc_info;\n\n    uint32_t op;\n\n    const char *args_fmt;\n\n\n\n    rc = info->read_memory_func(memaddr, insn, 4, info);\n\n    if (rc != 0) {\n\n        info->memory_error_func(rc, memaddr, info);\n\n        return -1;\n\n    }\n\n\n\n    fprintf_fn(stream, \"%02x %02x %02x %02x    \",\n\n            insn[0], insn[1], insn[2], insn[3]);\n\n\n\n    op = bfd_getb32(insn);\n\n    opc_info = find_opcode_info(op);\n\n    if (opc_info) {\n\n        fprintf_fn(stream, \"%-8s \", opc_info->name);\n\n        args_fmt = opc_info->args_fmt;\n\n        while (args_fmt && *args_fmt) {\n\n            if (*args_fmt == '%') {\n\n                switch (*(++args_fmt)) {\n\n                case '0': {\n\n                    uint8_t r0;\n\n                    const char *r0_name;\n\n                    r0 = (op >> 21) & 0x1f;\n\n                    r0_name = find_reg_info(r0)->name;\n\n                    fprintf_fn(stream, \"%s\", r0_name);\n\n                    break;\n\n                }\n\n                case '1': {\n\n                    uint8_t r1;\n\n                    const char *r1_name;\n\n                    r1 = (op >> 16) & 0x1f;\n\n                    r1_name = find_reg_info(r1)->name;\n\n                    fprintf_fn(stream, \"%s\", r1_name);\n\n                    break;\n\n                }\n\n                case '2': {\n\n                    uint8_t r2;\n\n                    const char *r2_name;\n\n                    r2 = (op >> 11) & 0x1f;\n\n                    r2_name = find_reg_info(r2)->name;\n\n                    fprintf_fn(stream, \"%s\", r2_name);\n\n                    break;\n\n                }\n\n                case 'c': {\n\n                    uint8_t csr;\n\n                    const char *csr_name;\n\n                    csr = (op >> 21) & 0x1f;\n\n                    csr_name = find_csr_info(csr)->name;\n\n                    if (csr_name) {\n\n                        fprintf_fn(stream, \"%s\", csr_name);\n\n                    } else {\n\n                        fprintf_fn(stream, \"0x%x\", csr);\n\n                    }\n\n                    break;\n\n                }\n\n                case 'u': {\n\n                    uint16_t u16;\n\n                    u16 = op & 0xffff;\n\n                    fprintf_fn(stream, \"0x%x\", u16);\n\n                    break;\n\n                }\n\n                case 's': {\n\n                    int16_t s16;\n\n                    s16 = (int16_t)(op & 0xffff);\n\n                    fprintf_fn(stream, \"%d\", s16);\n\n                    break;\n\n                }\n\n                case 'r': {\n\n                    uint32_t rela;\n\n                    rela = memaddr + (((int16_t)(op & 0xffff)) << 2);\n\n                    fprintf_fn(stream, \"%x\", rela);\n\n                    break;\n\n                }\n\n                case 'R': {\n\n                    uint32_t rela;\n\n                    int32_t imm26;\n\n                    imm26 = (int32_t)((op & 0x3ffffff) << 6) >> 4;\n\n                    rela = memaddr + imm26;\n\n                    fprintf_fn(stream, \"%x\", rela);\n\n                    break;\n\n                }\n\n                case 'h': {\n\n                    uint8_t u5;\n\n                    u5 = (op & 0x1f);\n\n                    fprintf_fn(stream, \"%d\", u5);\n\n                    break;\n\n                }\n\n                default:\n\n                    break;\n\n                }\n\n            } else {\n\n                fprintf_fn(stream, \"%c\", *args_fmt);\n\n            }\n\n            args_fmt++;\n\n        }\n\n    } else {\n\n        fprintf_fn(stream, \".word 0x%x\", op);\n\n    }\n\n\n\n    return 4;\n\n}\n", "idx": 2656, "_split": "test", "_hash": "6a6d28d9bdb8f91c11cd03d3f224b4b2"}
{"project": "qemu", "commit_id": "615220ddaf23db4c5686053257c568b46967e4b5", "target": 1, "func": "static void curses_setup(void)\n\n{\n\n    int i, colour_default[8] = {\n\n        COLOR_BLACK, COLOR_BLUE, COLOR_GREEN, COLOR_CYAN,\n\n        COLOR_RED, COLOR_MAGENTA, COLOR_YELLOW, COLOR_WHITE,\n\n    };\n\n\n\n    /* input as raw as possible, let everything be interpreted\n\n     * by the guest system */\n\n    initscr(); noecho(); intrflush(stdscr, FALSE);\n\n    nodelay(stdscr, TRUE); nonl(); keypad(stdscr, TRUE);\n\n    start_color(); raw(); scrollok(stdscr, FALSE);\n\n\n\n    for (i = 0; i < 64; i ++)\n\n        init_pair(i, colour_default[i & 7], colour_default[i >> 3]);\n\n}\n", "idx": 2673, "_split": "test", "_hash": "b8fe8681e605d08053eee0f9b475004b"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint16_t *v = pv;\n\n    uint16_t v2;\n\n    qemu_get_be16s(f, &v2);\n\n\n\n    if (*v == v2) {\n\n        return 0;\n\n    }\n\n    return -EINVAL;\n\n}\n", "idx": 2680, "_split": "test", "_hash": "87aae11722a5d388649d87c5958f5ba1"}
{"project": "qemu", "commit_id": "4cdd01d32ee6fe04f8d909bfd3708be6864873a2", "target": 0, "func": "void bdrv_refresh_filename(BlockDriverState *bs)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    QDict *opts;\n\n\n\n    if (!drv) {\n\n        return;\n\n    }\n\n\n\n    /* This BDS's file name will most probably depend on its file's name, so\n\n     * refresh that first */\n\n    if (bs->file) {\n\n        bdrv_refresh_filename(bs->file->bs);\n\n    }\n\n\n\n    if (drv->bdrv_refresh_filename) {\n\n        /* Obsolete information is of no use here, so drop the old file name\n\n         * information before refreshing it */\n\n        bs->exact_filename[0] = '\\0';\n\n        if (bs->full_open_options) {\n\n            QDECREF(bs->full_open_options);\n\n            bs->full_open_options = NULL;\n\n        }\n\n\n\n        drv->bdrv_refresh_filename(bs);\n\n    } else if (bs->file) {\n\n        /* Try to reconstruct valid information from the underlying file */\n\n        bool has_open_options;\n\n\n\n        bs->exact_filename[0] = '\\0';\n\n        if (bs->full_open_options) {\n\n            QDECREF(bs->full_open_options);\n\n            bs->full_open_options = NULL;\n\n        }\n\n\n\n        opts = qdict_new();\n\n        has_open_options = append_open_options(opts, bs);\n\n\n\n        /* If no specific options have been given for this BDS, the filename of\n\n         * the underlying file should suffice for this one as well */\n\n        if (bs->file->bs->exact_filename[0] && !has_open_options) {\n\n            strcpy(bs->exact_filename, bs->file->bs->exact_filename);\n\n        }\n\n        /* Reconstructing the full options QDict is simple for most format block\n\n         * drivers, as long as the full options are known for the underlying\n\n         * file BDS. The full options QDict of that file BDS should somehow\n\n         * contain a representation of the filename, therefore the following\n\n         * suffices without querying the (exact_)filename of this BDS. */\n\n        if (bs->file->bs->full_open_options) {\n\n            qdict_put_obj(opts, \"driver\",\n\n                          QOBJECT(qstring_from_str(drv->format_name)));\n\n            QINCREF(bs->file->bs->full_open_options);\n\n            qdict_put_obj(opts, \"file\",\n\n                          QOBJECT(bs->file->bs->full_open_options));\n\n\n\n            bs->full_open_options = opts;\n\n        } else {\n\n            QDECREF(opts);\n\n        }\n\n    } else if (!bs->full_open_options && qdict_size(bs->options)) {\n\n        /* There is no underlying file BDS (at least referenced by BDS.file),\n\n         * so the full options QDict should be equal to the options given\n\n         * specifically for this block device when it was opened (plus the\n\n         * driver specification).\n\n         * Because those options don't change, there is no need to update\n\n         * full_open_options when it's already set. */\n\n\n\n        opts = qdict_new();\n\n        append_open_options(opts, bs);\n\n        qdict_put_obj(opts, \"driver\",\n\n                      QOBJECT(qstring_from_str(drv->format_name)));\n\n\n\n        if (bs->exact_filename[0]) {\n\n            /* This may not work for all block protocol drivers (some may\n\n             * require this filename to be parsed), but we have to find some\n\n             * default solution here, so just include it. If some block driver\n\n             * does not support pure options without any filename at all or\n\n             * needs some special format of the options QDict, it needs to\n\n             * implement the driver-specific bdrv_refresh_filename() function.\n\n             */\n\n            qdict_put_obj(opts, \"filename\",\n\n                          QOBJECT(qstring_from_str(bs->exact_filename)));\n\n        }\n\n\n\n        bs->full_open_options = opts;\n\n    }\n\n\n\n    if (bs->exact_filename[0]) {\n\n        pstrcpy(bs->filename, sizeof(bs->filename), bs->exact_filename);\n\n    } else if (bs->full_open_options) {\n\n        QString *json = qobject_to_json(QOBJECT(bs->full_open_options));\n\n        snprintf(bs->filename, sizeof(bs->filename), \"json:%s\",\n\n                 qstring_get_str(json));\n\n        QDECREF(json);\n\n    }\n\n}\n", "idx": 2737, "_split": "test", "_hash": "53ce93d4a732b9138a0eced5ac07fff9"}
{"project": "qemu", "commit_id": "9b990ee5a3cc6aa38f81266fb0c6ef37a36c45b9", "target": 0, "func": "static inline bool cpu_handle_exception(CPUState *cpu, int *ret)\n\n{\n\n    if (cpu->exception_index >= 0) {\n\n        if (cpu->exception_index >= EXCP_INTERRUPT) {\n\n            /* exit request from the cpu execution loop */\n\n            *ret = cpu->exception_index;\n\n            if (*ret == EXCP_DEBUG) {\n\n                cpu_handle_debug_exception(cpu);\n\n            }\n\n            cpu->exception_index = -1;\n\n            return true;\n\n        } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n            /* if user mode only, we simulate a fake exception\n\n               which will be handled outside the cpu execution\n\n               loop */\n\n#if defined(TARGET_I386)\n\n            CPUClass *cc = CPU_GET_CLASS(cpu);\n\n            cc->do_interrupt(cpu);\n\n#endif\n\n            *ret = cpu->exception_index;\n\n            cpu->exception_index = -1;\n\n            return true;\n\n#else\n\n            if (replay_exception()) {\n\n                CPUClass *cc = CPU_GET_CLASS(cpu);\n\n                qemu_mutex_lock_iothread();\n\n                cc->do_interrupt(cpu);\n\n                qemu_mutex_unlock_iothread();\n\n                cpu->exception_index = -1;\n\n            } else if (!replay_has_interrupt()) {\n\n                /* give a chance to iothread in replay mode */\n\n                *ret = EXCP_INTERRUPT;\n\n                return true;\n\n            }\n\n#endif\n\n        }\n\n#ifndef CONFIG_USER_ONLY\n\n    } else if (replay_has_exception()\n\n               && cpu->icount_decr.u16.low + cpu->icount_extra == 0) {\n\n        /* try to cause an exception pending in the log */\n\n        cpu_exec_nocache(cpu, 1, tb_find(cpu, NULL, 0), true);\n\n        *ret = -1;\n\n        return true;\n\n#endif\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 2762, "_split": "test", "_hash": "9d3bd97ca88957647394b5d259eafe9b"}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)\n\n{\n\n    CPU_DoubleU farg1, farg2;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n\n\n    if (unlikely(float64_is_infinity(farg1.d) &&\n\n                 float64_is_infinity(farg2.d))) {\n\n        /* Division of infinity by infinity */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);\n\n    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {\n\n        /* Division of zero by zero */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d))) {\n\n            /* sNaN division */\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);\n\n    }\n\n\n\n    return farg1.ll;\n\n}\n", "idx": 2806, "_split": "test", "_hash": "bdac84bcb54512f6bf2d9b4e59bd7cbd"}
{"project": "qemu", "commit_id": "e4d2edc9d0c58de421eb349871e90b67edec0b9c", "target": 0, "func": "static void test_io_channel_ipv4(bool async)\n\n{\n\n    SocketAddress *listen_addr = g_new0(SocketAddress, 1);\n\n    SocketAddress *connect_addr = g_new0(SocketAddress, 1);\n\n\n\n    listen_addr->type = SOCKET_ADDRESS_KIND_INET;\n\n    listen_addr->u.inet = g_new0(InetSocketAddress, 1);\n\n    listen_addr->u.inet->host = g_strdup(\"0.0.0.0\");\n\n    listen_addr->u.inet->port = NULL; /* Auto-select */\n\n\n\n    connect_addr->type = SOCKET_ADDRESS_KIND_INET;\n\n    connect_addr->u.inet = g_new0(InetSocketAddress, 1);\n\n    connect_addr->u.inet->host = g_strdup(\"127.0.0.1\");\n\n    connect_addr->u.inet->port = NULL; /* Filled in later */\n\n\n\n    test_io_channel(async, listen_addr, connect_addr);\n\n\n\n    qapi_free_SocketAddress(listen_addr);\n\n    qapi_free_SocketAddress(connect_addr);\n\n}\n", "idx": 2817, "_split": "test", "_hash": "bfa284236d84523268efe1e9968d1bab"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_loongson_multimedia(DisasContext *ctx, int rd, int rs, int rt)\n\n{\n\n    const char *opn = \"loongson_cp2\";\n\n    uint32_t opc, shift_max;\n\n    TCGv_i64 t0, t1;\n\n\n\n    opc = MASK_LMI(ctx->opcode);\n\n    switch (opc) {\n\n    case OPC_ADD_CP2:\n\n    case OPC_SUB_CP2:\n\n    case OPC_DADD_CP2:\n\n    case OPC_DSUB_CP2:\n\n        t0 = tcg_temp_local_new_i64();\n\n        t1 = tcg_temp_local_new_i64();\n\n        break;\n\n    default:\n\n        t0 = tcg_temp_new_i64();\n\n        t1 = tcg_temp_new_i64();\n\n        break;\n\n    }\n\n\n\n    gen_load_fpr64(ctx, t0, rs);\n\n    gen_load_fpr64(ctx, t1, rt);\n\n\n\n#define LMI_HELPER(UP, LO) \\\n\n    case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break\n\n#define LMI_HELPER_1(UP, LO) \\\n\n    case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break\n\n#define LMI_DIRECT(UP, LO, OP) \\\n\n    case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break\n\n\n\n    switch (opc) {\n\n    LMI_HELPER(PADDSH, paddsh);\n\n    LMI_HELPER(PADDUSH, paddush);\n\n    LMI_HELPER(PADDH, paddh);\n\n    LMI_HELPER(PADDW, paddw);\n\n    LMI_HELPER(PADDSB, paddsb);\n\n    LMI_HELPER(PADDUSB, paddusb);\n\n    LMI_HELPER(PADDB, paddb);\n\n\n\n    LMI_HELPER(PSUBSH, psubsh);\n\n    LMI_HELPER(PSUBUSH, psubush);\n\n    LMI_HELPER(PSUBH, psubh);\n\n    LMI_HELPER(PSUBW, psubw);\n\n    LMI_HELPER(PSUBSB, psubsb);\n\n    LMI_HELPER(PSUBUSB, psubusb);\n\n    LMI_HELPER(PSUBB, psubb);\n\n\n\n    LMI_HELPER(PSHUFH, pshufh);\n\n    LMI_HELPER(PACKSSWH, packsswh);\n\n    LMI_HELPER(PACKSSHB, packsshb);\n\n    LMI_HELPER(PACKUSHB, packushb);\n\n\n\n    LMI_HELPER(PUNPCKLHW, punpcklhw);\n\n    LMI_HELPER(PUNPCKHHW, punpckhhw);\n\n    LMI_HELPER(PUNPCKLBH, punpcklbh);\n\n    LMI_HELPER(PUNPCKHBH, punpckhbh);\n\n    LMI_HELPER(PUNPCKLWD, punpcklwd);\n\n    LMI_HELPER(PUNPCKHWD, punpckhwd);\n\n\n\n    LMI_HELPER(PAVGH, pavgh);\n\n    LMI_HELPER(PAVGB, pavgb);\n\n    LMI_HELPER(PMAXSH, pmaxsh);\n\n    LMI_HELPER(PMINSH, pminsh);\n\n    LMI_HELPER(PMAXUB, pmaxub);\n\n    LMI_HELPER(PMINUB, pminub);\n\n\n\n    LMI_HELPER(PCMPEQW, pcmpeqw);\n\n    LMI_HELPER(PCMPGTW, pcmpgtw);\n\n    LMI_HELPER(PCMPEQH, pcmpeqh);\n\n    LMI_HELPER(PCMPGTH, pcmpgth);\n\n    LMI_HELPER(PCMPEQB, pcmpeqb);\n\n    LMI_HELPER(PCMPGTB, pcmpgtb);\n\n\n\n    LMI_HELPER(PSLLW, psllw);\n\n    LMI_HELPER(PSLLH, psllh);\n\n    LMI_HELPER(PSRLW, psrlw);\n\n    LMI_HELPER(PSRLH, psrlh);\n\n    LMI_HELPER(PSRAW, psraw);\n\n    LMI_HELPER(PSRAH, psrah);\n\n\n\n    LMI_HELPER(PMULLH, pmullh);\n\n    LMI_HELPER(PMULHH, pmulhh);\n\n    LMI_HELPER(PMULHUH, pmulhuh);\n\n    LMI_HELPER(PMADDHW, pmaddhw);\n\n\n\n    LMI_HELPER(PASUBUB, pasubub);\n\n    LMI_HELPER_1(BIADD, biadd);\n\n    LMI_HELPER_1(PMOVMSKB, pmovmskb);\n\n\n\n    LMI_DIRECT(PADDD, paddd, add);\n\n    LMI_DIRECT(PSUBD, psubd, sub);\n\n    LMI_DIRECT(XOR_CP2, xor, xor);\n\n    LMI_DIRECT(NOR_CP2, nor, nor);\n\n    LMI_DIRECT(AND_CP2, and, and);\n\n    LMI_DIRECT(PANDN, pandn, andc);\n\n    LMI_DIRECT(OR, or, or);\n\n\n\n    case OPC_PINSRH_0:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 0, 16);\n\n        opn = \"pinsrh_0\";\n\n        break;\n\n    case OPC_PINSRH_1:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 16, 16);\n\n        opn = \"pinsrh_1\";\n\n        break;\n\n    case OPC_PINSRH_2:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 32, 16);\n\n        opn = \"pinsrh_2\";\n\n        break;\n\n    case OPC_PINSRH_3:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 48, 16);\n\n        opn = \"pinsrh_3\";\n\n        break;\n\n\n\n    case OPC_PEXTRH:\n\n        tcg_gen_andi_i64(t1, t1, 3);\n\n        tcg_gen_shli_i64(t1, t1, 4);\n\n        tcg_gen_shr_i64(t0, t0, t1);\n\n        tcg_gen_ext16u_i64(t0, t0);\n\n        opn = \"pextrh\";\n\n        break;\n\n\n\n    case OPC_ADDU_CP2:\n\n        tcg_gen_add_i64(t0, t0, t1);\n\n        tcg_gen_ext32s_i64(t0, t0);\n\n        opn = \"addu\";\n\n        break;\n\n    case OPC_SUBU_CP2:\n\n        tcg_gen_sub_i64(t0, t0, t1);\n\n        tcg_gen_ext32s_i64(t0, t0);\n\n        opn = \"addu\";\n\n        break;\n\n\n\n    case OPC_SLL_CP2:\n\n        opn = \"sll\";\n\n        shift_max = 32;\n\n        goto do_shift;\n\n    case OPC_SRL_CP2:\n\n        opn = \"srl\";\n\n        shift_max = 32;\n\n        goto do_shift;\n\n    case OPC_SRA_CP2:\n\n        opn = \"sra\";\n\n        shift_max = 32;\n\n        goto do_shift;\n\n    case OPC_DSLL_CP2:\n\n        opn = \"dsll\";\n\n        shift_max = 64;\n\n        goto do_shift;\n\n    case OPC_DSRL_CP2:\n\n        opn = \"dsrl\";\n\n        shift_max = 64;\n\n        goto do_shift;\n\n    case OPC_DSRA_CP2:\n\n        opn = \"dsra\";\n\n        shift_max = 64;\n\n        goto do_shift;\n\n    do_shift:\n\n        /* Make sure shift count isn't TCG undefined behaviour.  */\n\n        tcg_gen_andi_i64(t1, t1, shift_max - 1);\n\n\n\n        switch (opc) {\n\n        case OPC_SLL_CP2:\n\n        case OPC_DSLL_CP2:\n\n            tcg_gen_shl_i64(t0, t0, t1);\n\n            break;\n\n        case OPC_SRA_CP2:\n\n        case OPC_DSRA_CP2:\n\n            /* Since SRA is UndefinedResult without sign-extended inputs,\n\n               we can treat SRA and DSRA the same.  */\n\n            tcg_gen_sar_i64(t0, t0, t1);\n\n            break;\n\n        case OPC_SRL_CP2:\n\n            /* We want to shift in zeros for SRL; zero-extend first.  */\n\n            tcg_gen_ext32u_i64(t0, t0);\n\n            /* FALLTHRU */\n\n        case OPC_DSRL_CP2:\n\n            tcg_gen_shr_i64(t0, t0, t1);\n\n            break;\n\n        }\n\n\n\n        if (shift_max == 32) {\n\n            tcg_gen_ext32s_i64(t0, t0);\n\n        }\n\n\n\n        /* Shifts larger than MAX produce zero.  */\n\n        tcg_gen_setcondi_i64(TCG_COND_LTU, t1, t1, shift_max);\n\n        tcg_gen_neg_i64(t1, t1);\n\n        tcg_gen_and_i64(t0, t0, t1);\n\n        break;\n\n\n\n    case OPC_ADD_CP2:\n\n    case OPC_DADD_CP2:\n\n        {\n\n            TCGv_i64 t2 = tcg_temp_new_i64();\n\n            int lab = gen_new_label();\n\n\n\n            tcg_gen_mov_i64(t2, t0);\n\n            tcg_gen_add_i64(t0, t1, t2);\n\n            if (opc == OPC_ADD_CP2) {\n\n                tcg_gen_ext32s_i64(t0, t0);\n\n            }\n\n            tcg_gen_xor_i64(t1, t1, t2);\n\n            tcg_gen_xor_i64(t2, t2, t0);\n\n            tcg_gen_andc_i64(t1, t2, t1);\n\n            tcg_temp_free_i64(t2);\n\n            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);\n\n            generate_exception(ctx, EXCP_OVERFLOW);\n\n            gen_set_label(lab);\n\n\n\n            opn = (opc == OPC_ADD_CP2 ? \"add\" : \"dadd\");\n\n            break;\n\n        }\n\n\n\n    case OPC_SUB_CP2:\n\n    case OPC_DSUB_CP2:\n\n        {\n\n            TCGv_i64 t2 = tcg_temp_new_i64();\n\n            int lab = gen_new_label();\n\n\n\n            tcg_gen_mov_i64(t2, t0);\n\n            tcg_gen_sub_i64(t0, t1, t2);\n\n            if (opc == OPC_SUB_CP2) {\n\n                tcg_gen_ext32s_i64(t0, t0);\n\n            }\n\n            tcg_gen_xor_i64(t1, t1, t2);\n\n            tcg_gen_xor_i64(t2, t2, t0);\n\n            tcg_gen_and_i64(t1, t1, t2);\n\n            tcg_temp_free_i64(t2);\n\n            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);\n\n            generate_exception(ctx, EXCP_OVERFLOW);\n\n            gen_set_label(lab);\n\n\n\n            opn = (opc == OPC_SUB_CP2 ? \"sub\" : \"dsub\");\n\n            break;\n\n        }\n\n\n\n    case OPC_PMULUW:\n\n        tcg_gen_ext32u_i64(t0, t0);\n\n        tcg_gen_ext32u_i64(t1, t1);\n\n        tcg_gen_mul_i64(t0, t0, t1);\n\n        opn = \"pmuluw\";\n\n        break;\n\n\n\n    case OPC_SEQU_CP2:\n\n    case OPC_SEQ_CP2:\n\n    case OPC_SLTU_CP2:\n\n    case OPC_SLT_CP2:\n\n    case OPC_SLEU_CP2:\n\n    case OPC_SLE_CP2:\n\n        /* ??? Document is unclear: Set FCC[CC].  Does that mean the\n\n           FD field is the CC field?  */\n\n    default:\n\n        MIPS_INVAL(opn);\n\n        generate_exception(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n\n\n#undef LMI_HELPER\n\n#undef LMI_DIRECT\n\n\n\n    gen_store_fpr64(ctx, t0, rd);\n\n\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %s, %s\", opn,\n\n               fregnames[rd], fregnames[rs], fregnames[rt]);\n\n    tcg_temp_free_i64(t0);\n\n    tcg_temp_free_i64(t1);\n\n}\n", "idx": 2818, "_split": "test", "_hash": "d8ae934a29d28bdcf7e1f67ee29aaa7d"}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_stat(void *opaque)\n\n{\n\n    int32_t fid;\n\n    V9fsStat v9stat;\n\n    ssize_t err = 0;\n\n    size_t offset = 7;\n\n    struct stat stbuf;\n\n    V9fsFidState *fidp;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"d\", &fid);\n\n    trace_v9fs_stat(pdu->tag, pdu->id, fid);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    offset += pdu_marshal(pdu, offset, \"wS\", 0, &v9stat);\n\n    err = offset;\n\n    trace_v9fs_stat_return(pdu->tag, pdu->id, v9stat.mode,\n\n                           v9stat.atime, v9stat.mtime, v9stat.length);\n\n    v9fs_stat_free(&v9stat);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(s, pdu, err);\n\n}\n", "idx": 2820, "_split": "test", "_hash": "d9c39cd9997cb336b2a681f0ecc033e9"}
{"project": "qemu", "commit_id": "2958620f67dcfd11476e62b4ca704dae0b978ea3", "target": 1, "func": "uint64_t helper_addlv (uint64_t op1, uint64_t op2)\n\n{\n\n    uint64_t tmp = op1;\n\n    op1 = (uint32_t)(op1 + op2);\n\n    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {\n\n        arith_excp(env, GETPC(), EXC_M_IOV, 0);\n\n    }\n\n    return op1;\n\n}\n", "idx": 2832, "_split": "test", "_hash": "efd0a8459b83f9501a635ba7a9304c09"}
{"project": "qemu", "commit_id": "778358d0a8f74a76488daea3c1b6fb327d8135b4", "target": 1, "func": "static int of_dpa_cmd_add_l2_flood(OfDpa *of_dpa, OfDpaGroup *group,\n\n                                   RockerTlv **group_tlvs)\n\n{\n\n    OfDpaGroup *l2_group;\n\n    RockerTlv **tlvs;\n\n    int err;\n\n    int i;\n\n\n\n    if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] ||\n\n        !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) {\n\n        return -ROCKER_EINVAL;\n\n    }\n\n\n\n    group->l2_flood.group_count =\n\n        rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]);\n\n\n\n    tlvs = g_malloc0((group->l2_flood.group_count + 1) *\n\n                     sizeof(RockerTlv *));\n\n    if (!tlvs) {\n\n        return -ROCKER_ENOMEM;\n\n    }\n\n\n\n    g_free(group->l2_flood.group_ids);\n\n    group->l2_flood.group_ids =\n\n        g_malloc0(group->l2_flood.group_count * sizeof(uint32_t));\n\n    if (!group->l2_flood.group_ids) {\n\n        err = -ROCKER_ENOMEM;\n\n        goto err_out;\n\n    }\n\n\n\n    rocker_tlv_parse_nested(tlvs, group->l2_flood.group_count,\n\n                            group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]);\n\n\n\n    for (i = 0; i < group->l2_flood.group_count; i++) {\n\n        group->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]);\n\n    }\n\n\n\n    /* All of the L2 interface groups referenced by the L2 flood\n\n     * must have same VLAN\n\n     */\n\n\n\n    for (i = 0; i < group->l2_flood.group_count; i++) {\n\n        l2_group = of_dpa_group_find(of_dpa, group->l2_flood.group_ids[i]);\n\n        if (!l2_group) {\n\n            continue;\n\n        }\n\n        if ((ROCKER_GROUP_TYPE_GET(l2_group->id) ==\n\n             ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) &&\n\n            (ROCKER_GROUP_VLAN_GET(l2_group->id) !=\n\n             ROCKER_GROUP_VLAN_GET(group->id))) {\n\n            DPRINTF(\"l2 interface group 0x%08x VLAN doesn't match l2 \"\n\n                    \"flood group 0x%08x\\n\",\n\n                    group->l2_flood.group_ids[i], group->id);\n\n            err = -ROCKER_EINVAL;\n\n            goto err_out;\n\n        }\n\n    }\n\n\n\n    g_free(tlvs);\n\n    return ROCKER_OK;\n\n\n\nerr_out:\n\n    group->l2_flood.group_count = 0;\n\n    g_free(group->l2_flood.group_ids);\n\n    g_free(tlvs);\n\n\n\n    return err;\n\n}\n", "idx": 2846, "_split": "test", "_hash": "3972ca6fabda94cb3994519d178da8d7"}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void op_cp1_64bitmode(void)\n\n{\n\n    if (!(env->CP0_Status & (1 << CP0St_FR))) {\n\n        CALL_FROM_TB1(do_raise_exception, EXCP_RI);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 2880, "_split": "test", "_hash": "935051314022d933af3862d47f6f684e"}
{"project": "qemu", "commit_id": "40f860cd6c1aa0d3399e3f8158f20bdc5b2bfbfe", "target": 0, "func": "void disas_a64_insn(CPUARMState *env, DisasContext *s)\n\n{\n\n    uint32_t insn;\n\n\n\n    insn = arm_ldl_code(env, s->pc, s->bswap_code);\n\n    s->insn = insn;\n\n    s->pc += 4;\n\n\n\n    switch ((insn >> 24) & 0x1f) {\n\n    default:\n\n        unallocated_encoding(s);\n\n        break;\n\n    }\n\n\n\n    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {\n\n        /* go through the main loop for single step */\n\n        s->is_jmp = DISAS_JUMP;\n\n    }\n\n}\n", "idx": 2884, "_split": "test", "_hash": "fe1b6829a98e9c8b560395d15e5d0841"}
{"project": "qemu", "commit_id": "96d7073fb058e6f05257cd9041ffbbd736f6ccec", "target": 0, "func": "static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)\n\n{\n\n    switch(ot) {\n\n    case OT_BYTE:\n\n        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {\n\n            goto std_case;\n\n        } else {\n\n            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);\n\n            tcg_gen_ext8u_tl(t0, t0);\n\n        }\n\n        break;\n\n    default:\n\n    std_case:\n\n        tcg_gen_mov_tl(t0, cpu_regs[reg]);\n\n        break;\n\n    }\n\n}\n", "idx": 2895, "_split": "test", "_hash": "1c78c685d266f92f54dc8ca669d31072"}
{"project": "qemu", "commit_id": "54421cb17bc744bad15f2b1adb4adefdaea83c10", "target": 0, "func": "static int hdev_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    int access_flags, create_flags;\n\n    DWORD overlapped;\n\n    char device_name[64];\n\n\n\n    if (strstart(filename, \"/dev/cdrom\", NULL)) {\n\n        if (find_cdrom(device_name, sizeof(device_name)) < 0)\n\n            return -ENOENT;\n\n        filename = device_name;\n\n    } else {\n\n        /* transform drive letters into device name */\n\n        if (((filename[0] >= 'a' && filename[0] <= 'z') ||\n\n             (filename[0] >= 'A' && filename[0] <= 'Z')) &&\n\n            filename[1] == ':' && filename[2] == '\\0') {\n\n            snprintf(device_name, sizeof(device_name), \"\\\\\\\\.\\\\%c:\", filename[0]);\n\n            filename = device_name;\n\n        }\n\n    }\n\n    s->type = find_device_type(bs, filename);\n\n    \n\n    if ((flags & BDRV_O_ACCESS) == O_RDWR) {\n\n        access_flags = GENERIC_READ | GENERIC_WRITE;\n\n    } else {\n\n        access_flags = GENERIC_READ;\n\n    }\n\n    create_flags = OPEN_EXISTING;\n\n\n\n#ifdef QEMU_TOOL\n\n    overlapped = FILE_ATTRIBUTE_NORMAL;\n\n#else\n\n    overlapped = FILE_FLAG_OVERLAPPED;\n\n#endif\n\n    s->hfile = CreateFile(filename, access_flags, \n\n                          FILE_SHARE_READ, NULL,\n\n                          create_flags, overlapped, NULL);\n\n    if (s->hfile == INVALID_HANDLE_VALUE) \n\n        return -1;\n\n    return 0;\n\n}\n", "idx": 2903, "_split": "test", "_hash": "fa93d48d492a528d4f18d32c93b8a35e"}
{"project": "qemu", "commit_id": "62deb62d999cf9e2be61272c6b720104f764bd6a", "target": 0, "func": "static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    SigpInfo *si = arg.host_ptr;\n\n\n\n    if (!s390_has_feat(S390_FEAT_VECTOR)) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_ORDER);\n\n        return;\n\n    }\n\n\n\n    /* cpu has to be stopped */\n\n    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {\n\n        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);\n\n        return;\n\n    }\n\n\n\n    /* parameter must be aligned to 1024-byte boundary */\n\n    if (si->param & 0x3ff) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);\n\n        return;\n\n    }\n\n\n\n    cpu_synchronize_state(cs);\n\n\n\n    if (kvm_s390_store_adtl_status(cpu, si->param)) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);\n\n        return;\n\n    }\n\n    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n}\n", "idx": 2911, "_split": "test", "_hash": "526d08af982ef1b87f29b8b475f894a6"}
{"project": "qemu", "commit_id": "ff1d1977ffe1c276f5937a6ad4b6a5b6d2b1c6ae", "target": 0, "func": "static int cpu_gdb_write_register(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    target_ulong tmp;\n\n\n\n    tmp = ldtul_p(mem_buf);\n\n\n\n    if (n < 32) {\n\n        env->active_tc.gpr[n] = tmp;\n\n        return sizeof(target_ulong);\n\n    }\n\n    if (env->CP0_Config1 & (1 << CP0C1_FP)\n\n            && n >= 38 && n < 73) {\n\n        if (n < 70) {\n\n            if (env->CP0_Status & (1 << CP0St_FR))\n\n              env->active_fpu.fpr[n - 38].d = tmp;\n\n            else\n\n              env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX] = tmp;\n\n        }\n\n        switch (n) {\n\n        case 70:\n\n            env->active_fpu.fcr31 = tmp & 0xFF83FFFF;\n\n            /* set rounding mode */\n\n            RESTORE_ROUNDING_MODE;\n\n#ifndef CONFIG_SOFTFLOAT\n\n            /* no floating point exception for native float */\n\n            SET_FP_ENABLE(env->active_fpu.fcr31, 0);\n\n#endif\n\n            break;\n\n        case 71: env->active_fpu.fcr0 = tmp; break;\n\n        }\n\n        return sizeof(target_ulong);\n\n    }\n\n    switch (n) {\n\n    case 32: env->CP0_Status = tmp; break;\n\n    case 33: env->active_tc.LO[0] = tmp; break;\n\n    case 34: env->active_tc.HI[0] = tmp; break;\n\n    case 35: env->CP0_BadVAddr = tmp; break;\n\n    case 36: env->CP0_Cause = tmp; break;\n\n    case 37: env->active_tc.PC = tmp; break;\n\n    case 72: /* fp, ignored */ break;\n\n    default: \n\n\tif (n > 89)\n\n\t    return 0;\n\n\t/* Other registers are readonly.  Ignore writes.  */\n\n\tbreak;\n\n    }\n\n\n\n    return sizeof(target_ulong);\n\n}\n", "idx": 2913, "_split": "test", "_hash": "50a96624399a3955b8204b3d5c0d851e"}
{"project": "qemu", "commit_id": "3ba235a02284c39b34a68a2a588508ffb52a7b55", "target": 0, "func": "QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *opaque)\n\n{\n\n    QEMUBH *bh;\n\n    bh = g_malloc0(sizeof(QEMUBH));\n\n    bh->ctx = ctx;\n\n    bh->cb = cb;\n\n    bh->opaque = opaque;\n\n    qemu_mutex_lock(&ctx->bh_lock);\n\n    bh->next = ctx->first_bh;\n\n    /* Make sure that the members are ready before putting bh into list */\n\n    smp_wmb();\n\n    ctx->first_bh = bh;\n\n    qemu_mutex_unlock(&ctx->bh_lock);\n\n    return bh;\n\n}\n", "idx": 2914, "_split": "test", "_hash": "58e48534fa490bd229ab6151c9df1167"}
{"project": "qemu", "commit_id": "75cc7f018328e708d94cca23c3a77e85363f25dc", "target": 1, "func": "static void machine_initfn(Object *obj)\n\n{\n\n    MachineState *ms = MACHINE(obj);\n\n\n\n    ms->kernel_irqchip_allowed = true;\n\n    ms->kvm_shadow_mem = -1;\n\n    ms->dump_guest_core = true;\n\n\n\n\n    object_property_add_str(obj, \"accel\",\n\n                            machine_get_accel, machine_set_accel, NULL);\n\n    object_property_set_description(obj, \"accel\",\n\n                                    \"Accelerator list\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"kernel-irqchip\",\n\n                             NULL,\n\n                             machine_set_kernel_irqchip,\n\n                             NULL);\n\n    object_property_set_description(obj, \"kernel-irqchip\",\n\n                                    \"Use KVM in-kernel irqchip\",\n\n                                    NULL);\n\n    object_property_add(obj, \"kvm-shadow-mem\", \"int\",\n\n                        machine_get_kvm_shadow_mem,\n\n                        machine_set_kvm_shadow_mem,\n\n                        NULL, NULL, NULL);\n\n    object_property_set_description(obj, \"kvm-shadow-mem\",\n\n                                    \"KVM shadow MMU size\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"kernel\",\n\n                            machine_get_kernel, machine_set_kernel, NULL);\n\n    object_property_set_description(obj, \"kernel\",\n\n                                    \"Linux kernel image file\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"initrd\",\n\n                            machine_get_initrd, machine_set_initrd, NULL);\n\n    object_property_set_description(obj, \"initrd\",\n\n                                    \"Linux initial ramdisk file\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"append\",\n\n                            machine_get_append, machine_set_append, NULL);\n\n    object_property_set_description(obj, \"append\",\n\n                                    \"Linux kernel command line\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"dtb\",\n\n                            machine_get_dtb, machine_set_dtb, NULL);\n\n    object_property_set_description(obj, \"dtb\",\n\n                                    \"Linux kernel device tree file\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"dumpdtb\",\n\n                            machine_get_dumpdtb, machine_set_dumpdtb, NULL);\n\n    object_property_set_description(obj, \"dumpdtb\",\n\n                                    \"Dump current dtb to a file and quit\",\n\n                                    NULL);\n\n    object_property_add(obj, \"phandle-start\", \"int\",\n\n                        machine_get_phandle_start,\n\n                        machine_set_phandle_start,\n\n                        NULL, NULL, NULL);\n\n    object_property_set_description(obj, \"phandle-start\",\n\n                                    \"The first phandle ID we may generate dynamically\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"dt-compatible\",\n\n                            machine_get_dt_compatible,\n\n                            machine_set_dt_compatible,\n\n                            NULL);\n\n    object_property_set_description(obj, \"dt-compatible\",\n\n                                    \"Overrides the \\\"compatible\\\" property of the dt root node\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"dump-guest-core\",\n\n                             machine_get_dump_guest_core,\n\n                             machine_set_dump_guest_core,\n\n                             NULL);\n\n    object_property_set_description(obj, \"dump-guest-core\",\n\n                                    \"Include guest memory in  a core dump\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"mem-merge\",\n\n                             machine_get_mem_merge,\n\n                             machine_set_mem_merge, NULL);\n\n    object_property_set_description(obj, \"mem-merge\",\n\n                                    \"Enable/disable memory merge support\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"usb\",\n\n                             machine_get_usb,\n\n                             machine_set_usb, NULL);\n\n    object_property_set_description(obj, \"usb\",\n\n                                    \"Set on/off to enable/disable usb\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"firmware\",\n\n                            machine_get_firmware,\n\n                            machine_set_firmware, NULL);\n\n    object_property_set_description(obj, \"firmware\",\n\n                                    \"Firmware image\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"iommu\",\n\n                             machine_get_iommu,\n\n                             machine_set_iommu, NULL);\n\n    object_property_set_description(obj, \"iommu\",\n\n                                    \"Set on/off to enable/disable Intel IOMMU (VT-d)\",\n\n                                    NULL);\n\n\n\n    /* Register notifier when init is done for sysbus sanity checks */\n\n    ms->sysbus_notifier.notify = machine_init_notify;\n\n    qemu_add_machine_init_done_notifier(&ms->sysbus_notifier);\n\n}", "idx": 2950, "_split": "test", "_hash": "c8ab71ea292807e384b28ee7ed2086f7"}
{"project": "qemu", "commit_id": "d22b2f41c470067758b3636a01b452dfeda7069f", "target": 1, "func": "void bdrv_delete(BlockDriverState *bs)\n\n{\n\n    assert(!bs->peer);\n\n\n\n    /* remove from list, if necessary */\n\n    if (bs->device_name[0] != '\\0') {\n\n        QTAILQ_REMOVE(&bdrv_states, bs, list);\n\n    }\n\n\n\n    bdrv_close(bs);\n\n    if (bs->file != NULL) {\n\n        bdrv_delete(bs->file);\n\n    }\n\n\n\n    assert(bs != bs_snapshots);\n\n    qemu_free(bs);\n\n}\n", "idx": 2958, "_split": "test", "_hash": "0bea065065490eb730703d5d7b993fb1"}
{"project": "qemu", "commit_id": "dde3a2184074f5c4279fd7fbfc597b5dc5859fb8", "target": 1, "func": "static void hmp_migrate_status_cb(void *opaque)\n\n{\n\n    MigrationStatus *status = opaque;\n\n    MigrationInfo *info;\n\n\n\n    info = qmp_query_migrate(NULL);\n\n    if (!info->has_status || strcmp(info->status, \"active\") == 0) {\n\n        if (info->has_disk) {\n\n            int progress;\n\n\n\n            if (info->disk->remaining) {\n\n                progress = info->disk->transferred * 100 / info->disk->total;\n\n            } else {\n\n                progress = 100;\n\n            }\n\n\n\n            monitor_printf(status->mon, \"Completed %d %%\\r\", progress);\n\n            monitor_flush(status->mon);\n\n        }\n\n\n\n        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);\n\n    } else {\n\n        if (status->is_block_migration) {\n\n            monitor_printf(status->mon, \"\\n\");\n\n        }\n\n        monitor_resume(status->mon);\n\n        timer_del(status->timer);\n\n        g_free(status);\n\n    }\n\n\n\n    qapi_free_MigrationInfo(info);\n\n}\n", "idx": 2967, "_split": "test", "_hash": "c3b1f04c89b760fd3c39d26d7bfd28a8"}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "int kvm_arch_on_sigbus(int code, void *addr)\n\n{\n\n#ifdef KVM_CAP_MCE\n\n    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {\n\n        void *vaddr;\n\n        ram_addr_t ram_addr;\n\n        target_phys_addr_t paddr;\n\n\n\n        /* Hope we are lucky for AO MCE */\n\n        vaddr = addr;\n\n        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||\n\n            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,\n\n                                               &paddr)) {\n\n            fprintf(stderr, \"Hardware memory error for memory used by \"\n\n                    \"QEMU itself instead of guest system!: %p\\n\", addr);\n\n            return 0;\n\n        }\n\n        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);\n\n    } else\n\n#endif /* KVM_CAP_MCE */\n\n    {\n\n        if (code == BUS_MCEERR_AO) {\n\n            return 0;\n\n        } else if (code == BUS_MCEERR_AR) {\n\n            hardware_memory_error();\n\n        } else {\n\n            return 1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 2996, "_split": "test", "_hash": "9d43f7bcee141dff834303de457aaebb"}
{"project": "qemu", "commit_id": "aef172ffdc2f9c41d9cc043a55f1259e7c07e587", "target": 1, "func": "coroutine_fn iscsi_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct IscsiTask iTask;\n\n    struct unmap_list list;\n\n    int r = 0;\n\n\n\n    if (!is_byte_request_lun_aligned(offset, bytes, iscsilun)) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    if (!iscsilun->lbp.lbpu) {\n\n        /* UNMAP is not supported by the target */\n\n        return 0;\n\n    }\n\n\n\n    list.lba = offset / iscsilun->block_size;\n\n    list.num = bytes / iscsilun->block_size;\n\n\n\n    iscsi_co_init_iscsitask(iscsilun, &iTask);\n\n    qemu_mutex_lock(&iscsilun->mutex);\n\nretry:\n\n    if (iscsi_unmap_task(iscsilun->iscsi, iscsilun->lun, 0, 0, &list, 1,\n\n                         iscsi_co_generic_cb, &iTask) == NULL) {\n\n        r = -ENOMEM;\n\n        goto out_unlock;\n\n    }\n\n\n\n    while (!iTask.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_mutex_unlock(&iscsilun->mutex);\n\n        qemu_coroutine_yield();\n\n        qemu_mutex_lock(&iscsilun->mutex);\n\n    }\n\n\n\n    if (iTask.task != NULL) {\n\n        scsi_free_scsi_task(iTask.task);\n\n        iTask.task = NULL;\n\n    }\n\n\n\n    if (iTask.do_retry) {\n\n        iTask.complete = 0;\n\n        goto retry;\n\n    }\n\n\n\n    if (iTask.status == SCSI_STATUS_CHECK_CONDITION) {\n\n        /* the target might fail with a check condition if it\n\n           is not happy with the alignment of the UNMAP request\n\n           we silently fail in this case */\n\n        goto out_unlock;\n\n    }\n\n\n\n    if (iTask.status != SCSI_STATUS_GOOD) {\n\n        r = iTask.err_code;\n\n        goto out_unlock;\n\n    }\n\n\n\n    iscsi_allocmap_set_invalid(iscsilun, offset >> BDRV_SECTOR_BITS,\n\n                               bytes >> BDRV_SECTOR_BITS);\n\n\n\nout_unlock:\n\n    qemu_mutex_unlock(&iscsilun->mutex);\n\n    return r;\n\n}\n", "idx": 3001, "_split": "test", "_hash": "fe9eccb2bb174b9d2427fffec8a1d99d"}
{"project": "qemu", "commit_id": "def74c0cf05722b2e502d4b4f1219966c5b0cbd3", "target": 1, "func": "int mips_cpu_handle_mmu_fault(CPUState *cs, vaddr address, int rw,\n\n                              int mmu_idx)\n\n{\n\n    MIPSCPU *cpu = MIPS_CPU(cs);\n\n    CPUMIPSState *env = &cpu->env;\n\n#if !defined(CONFIG_USER_ONLY)\n\n    hwaddr physical;\n\n    int prot;\n\n    int access_type;\n\n#endif\n\n    int ret = 0;\n\n\n\n#if 0\n\n    log_cpu_state(cs, 0);\n\n#endif\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n              \"%s pc \" TARGET_FMT_lx \" ad %\" VADDR_PRIx \" rw %d mmu_idx %d\\n\",\n\n              __func__, env->active_tc.PC, address, rw, mmu_idx);\n\n\n\n    /* data access */\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* XXX: put correct access by using cpu_restore_state()\n\n       correctly */\n\n    access_type = ACCESS_INT;\n\n    ret = get_physical_address(env, &physical, &prot,\n\n                               address, rw, access_type);\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n             \"%s address=%\" VADDR_PRIx \" ret %d physical \" TARGET_FMT_plx\n\n             \" prot %d\\n\",\n\n             __func__, address, ret, physical, prot);\n\n    if (ret == TLBRET_MATCH) {\n\n        tlb_set_page(cs, address & TARGET_PAGE_MASK,\n\n                     physical & TARGET_PAGE_MASK, prot | PAGE_EXEC,\n\n                     mmu_idx, TARGET_PAGE_SIZE);\n\n        ret = 0;\n\n    } else if (ret < 0)\n\n#endif\n\n    {\n\n        raise_mmu_exception(env, address, rw, ret);\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 3003, "_split": "test", "_hash": "bb051840945db46cd6ce99c4a79c9ca4"}
{"project": "qemu", "commit_id": "e26110cfc67d48331a76e9b1e6f7fed7569e1ab3", "target": 0, "func": "static ModuleTypeList *find_type(module_init_type type)\n\n{\n\n    ModuleTypeList *l;\n\n\n\n    init_types();\n\n\n\n    l = &init_type_list[type];\n\n\n\n    return l;\n\n}\n", "idx": 3020, "_split": "test", "_hash": "724496978b0b3ac8dc9e6249b40ea3b9"}
{"project": "qemu", "commit_id": "8bd7f71d794b93ce027b856f5b79a98f4f82e44c", "target": 0, "func": "static int qemu_suspend_requested(void)\n\n{\n\n    int r = suspend_requested;\n\n    suspend_requested = 0;\n\n    return r;\n\n}\n", "idx": 3040, "_split": "test", "_hash": "0ad50c5cee7a611d5da884e1de65dfc0"}
{"project": "qemu", "commit_id": "81174dae3f9189519cd60c7b79e91c291b021bbe", "target": 1, "func": "static void serial_tx_done(void *opaque)\n\n{\n\n    SerialState *s = opaque;\n\n\n\n    if (s->tx_burst < 0) {\n\n        uint16_t divider;\n\n\n\n        if (s->divider)\n\n          divider = s->divider;\n\n        else\n\n          divider = 1;\n\n\n\n        /* We assume 10 bits/char, OK for this purpose. */\n\n        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /\n\n            (1000000 * 10 / (s->baudbase / divider));\n\n    }\n\n    s->thr_ipending = 1;\n\n    s->lsr |= UART_LSR_THRE;\n\n    s->lsr |= UART_LSR_TEMT;\n\n    serial_update_irq(s);\n\n}\n", "idx": 3070, "_split": "test", "_hash": "7006763728ee9890243f06dc0a06de92"}
{"project": "qemu", "commit_id": "ab9509cceabef28071e41bdfa073083859c949a7", "target": 1, "func": "void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd)\n\n{\n\n    QXLDevSurfaceCreate surface;\n\n\n\n    memset(&surface, 0, sizeof(surface));\n\n\n\n    dprint(1, \"%s/%d: %dx%d\\n\", __func__, ssd->qxl.id,\n\n           surface_width(ssd->ds), surface_height(ssd->ds));\n\n\n\n    surface.format     = SPICE_SURFACE_FMT_32_xRGB;\n\n    surface.width      = surface_width(ssd->ds);\n\n    surface.height     = surface_height(ssd->ds);\n\n    surface.stride     = -surface.width * 4;\n\n    surface.mouse_mode = true;\n\n    surface.flags      = 0;\n\n    surface.type       = 0;\n\n    surface.mem        = (uintptr_t)ssd->buf;\n\n    surface.group_id   = MEMSLOT_GROUP_HOST;\n\n\n\n    qemu_spice_create_primary_surface(ssd, 0, &surface, QXL_SYNC);\n\n}\n", "idx": 3076, "_split": "test", "_hash": "ad0e49fce227176e3e39e2b83c912ebe"}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void init_proc_750fx (CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_7xx(env);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_L2CR, \"L2CR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, NULL,\n\n                 0x00000000);\n\n    /* Time base */\n\n    gen_tbl(env);\n\n    /* Thermal management */\n\n    gen_spr_thrm(env);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_750_THRM4, \"THRM4\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_750FX_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Memory management */\n\n    gen_low_BATs(env);\n\n    /* PowerPC 750fx & 750gx has 8 DBATs and 8 IBATs */\n\n    gen_high_BATs(env);\n\n    init_excp_7x0(env);\n\n    env->dcache_line_size = 32;\n\n    env->icache_line_size = 32;\n\n    /* Allocate hardware IRQ controller */\n\n    ppc6xx_irq_init(env);\n\n}\n", "idx": 3082, "_split": "test", "_hash": "8c5561aeb2ac01bf7bc46307889bdf6d"}
{"project": "qemu", "commit_id": "0b5538c300a56c3cfb33022840fe0b4968147e7a", "target": 1, "func": "void st_print_trace_file_status(FILE *stream, int (*stream_printf)(FILE *stream, const char *fmt, ...))\n\n{\n\n    stream_printf(stream, \"Trace file \\\"%s\\\" %s.\\n\",\n\n                  trace_file_name, trace_file_enabled ? \"on\" : \"off\");\n\n}\n", "idx": 3098, "_split": "test", "_hash": "ddf440bbdf2a7dba9edf81153163e7c5"}
{"project": "qemu", "commit_id": "4105de6732f771ea64113851a2ee7172c34d3a7a", "target": 1, "func": "e1000_can_receive(void *opaque)\n\n{\n\n    E1000State *s = opaque;\n\n\n\n    return (!(s->mac_reg[RCTL] & E1000_RCTL_EN) ||\n\n            s->mac_reg[RDH] != s->mac_reg[RDT]);\n\n}\n", "idx": 3130, "_split": "test", "_hash": "ac27b3ff136796a0d789bb72121b96c1"}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)\n\n{\n\n    *q_ptr = num / den;\n\n    return num % den;\n\n}\n", "idx": 3162, "_split": "test", "_hash": "c4b45d00788dc07df5ca4191a169a491"}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void simple_whitespace(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        LiteralQObject decoded;\n\n    } test_cases[] = {\n\n        {\n\n            .encoded = \" [ 43 , 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \" [ 43 , { 'h' : 'b' }, [ ], 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    { \"h\", QLIT_QSTR(\"b\") },\n\n                                    { }})),\n\n                        QLIT_QLIST(((LiteralQObject[]){\n\n                                    { }})),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    { \"h\", QLIT_QSTR(\"b\") },\n\n                                    { \"a\", QLIT_QINT(32) },\n\n                                    { }})),\n\n                        QLIT_QLIST(((LiteralQObject[]){\n\n                                    { }})),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        { }\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded, NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        str = qobject_to_json(obj);\n\n        qobject_decref(obj);\n\n\n\n        obj = qobject_from_json(qstring_get_str(str), NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        qobject_decref(obj);\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 3179, "_split": "test", "_hash": "389230a83cccedd67abef955c65292c6"}
{"project": "qemu", "commit_id": "0857a06ef784783887e756d4b7b5f874512c506c", "target": 1, "func": "static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)\n\n{\n\n    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {\n\n        if (sregnames[sr].name) {\n\n            qemu_log(\"SR %s is not configured\\n\", sregnames[sr].name);\n\n        } else {\n\n            qemu_log(\"SR %d is not implemented\\n\", sr);\n\n        }\n\n        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n    } else if (!(sregnames[sr].access & access)) {\n\n        static const char * const access_text[] = {\n\n            [SR_R] = \"rsr\",\n\n            [SR_W] = \"wsr\",\n\n            [SR_X] = \"xsr\",\n\n        };\n\n        assert(access < ARRAY_SIZE(access_text) && access_text[access]);\n\n        qemu_log(\"SR %s is not available for %s\\n\", sregnames[sr].name,\n\n                access_text[access]);\n\n        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n    }\n\n}\n", "idx": 3180, "_split": "test", "_hash": "1c5292f6743f7cc51b01aac0a78b49f0"}
{"project": "qemu", "commit_id": "e41029b378b4a65a0b89b5a8dc087aca6b5d012d", "target": 1, "func": "static void gen_lswi(DisasContext *ctx)\n\n{\n\n    TCGv t0;\n\n    TCGv_i32 t1, t2;\n\n    int nb = NB(ctx->opcode);\n\n    int start = rD(ctx->opcode);\n\n    int ra = rA(ctx->opcode);\n\n    int nr;\n\n\n\n    if (nb == 0)\n\n        nb = 32;\n\n    nr = (nb + 3) / 4;\n\n    if (unlikely(lsw_reg_in_range(start, nr, ra))) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);\n\n        return;\n\n    }\n\n    gen_set_access_type(ctx, ACCESS_INT);\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    t0 = tcg_temp_new();\n\n    gen_addr_register(ctx, t0);\n\n    t1 = tcg_const_i32(nb);\n\n    t2 = tcg_const_i32(start);\n\n    gen_helper_lsw(cpu_env, t0, t1, t2);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free_i32(t1);\n\n    tcg_temp_free_i32(t2);\n\n}\n", "idx": 3182, "_split": "test", "_hash": "5ba33eef875f611d5ca51279ec1fe8a1"}
{"project": "qemu", "commit_id": "367790cce8e14131426f5190dfd7d1bdbf656e4d", "target": 1, "func": "uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)\n\n{\n\n    uint64_t temp;\n\n    uint32_t result;\n\n\n\n    shift &= 63;\n\n    temp = (uint64_t)val << 32 >> shift;\n\n    result = temp >> 32;\n\n\n\n    env->cc_c = (temp >> 31) & 1;\n\n    env->cc_n = result;\n\n    env->cc_z = result;\n\n    env->cc_v = 0;\n\n    env->cc_x = shift ? env->cc_c : env->cc_x;\n\n\n\n    return result;\n\n}\n", "idx": 3184, "_split": "test", "_hash": "24226680cb6eeb59bd84c3fd43b1578d"}
{"project": "qemu", "commit_id": "95ce326e5b47b4b841849f8a2ac7b96d6e204dfb", "target": 1, "func": "static void term_down_char(void)\n\n{\n\n    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)\n\n\treturn;\n\n    if (term_history[++term_hist_entry] != NULL) {\n\n\tstrcpy(term_cmd_buf, term_history[term_hist_entry]);\n\n    } else {\n\n\tterm_hist_entry = -1;\n\n    }\n\n    term_printf(\"\\n\");\n\n    term_print_cmdline(term_cmd_buf);\n\n    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);\n\n}\n", "idx": 3205, "_split": "test", "_hash": "6f92dee9362f5bc86cdd275f06b0e8b1"}
{"project": "qemu", "commit_id": "0fcec41eec0432c77645b4a407d3a3e030c4abc4", "target": 1, "func": "target_ulong helper_sdiv(target_ulong a, target_ulong b)\n\n{\n\n    int64_t x0;\n\n    int32_t x1;\n\n\n\n    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);\n\n    x1 = (b & 0xffffffff);\n\n\n\n    if (x1 == 0) {\n\n        raise_exception(TT_DIV_ZERO);\n\n    }\n\n\n\n    x0 = x0 / x1;\n\n    if ((int32_t) x0 != x0) {\n\n        env->cc_src2 = 1;\n\n        return x0 < 0? 0x80000000: 0x7fffffff;\n\n    } else {\n\n        env->cc_src2 = 0;\n\n        return x0;\n\n    }\n\n}\n", "idx": 3228, "_split": "test", "_hash": "53c965283b0fc57889048a3a0484ddcd"}
{"project": "qemu", "commit_id": "898248a32915024a4f01ce4f0c3519509fb703cb", "target": 1, "func": "static void xhci_reset(DeviceState *dev)\n\n{\n\n    XHCIState *xhci = XHCI(dev);\n\n    int i;\n\n\n\n    trace_usb_xhci_reset();\n\n    if (!(xhci->usbsts & USBSTS_HCH)) {\n\n        DPRINTF(\"xhci: reset while running!\\n\");\n\n    }\n\n\n\n    xhci->usbcmd = 0;\n\n    xhci->usbsts = USBSTS_HCH;\n\n    xhci->dnctrl = 0;\n\n    xhci->crcr_low = 0;\n\n    xhci->crcr_high = 0;\n\n    xhci->dcbaap_low = 0;\n\n    xhci->dcbaap_high = 0;\n\n    xhci->config = 0;\n\n\n\n    for (i = 0; i < xhci->numslots; i++) {\n\n        xhci_disable_slot(xhci, i+1);\n\n    }\n\n\n\n    for (i = 0; i < xhci->numports; i++) {\n\n        xhci_port_update(xhci->ports + i, 0);\n\n    }\n\n\n\n    for (i = 0; i < xhci->numintrs; i++) {\n\n        xhci->intr[i].iman = 0;\n\n        xhci->intr[i].imod = 0;\n\n        xhci->intr[i].erstsz = 0;\n\n        xhci->intr[i].erstba_low = 0;\n\n        xhci->intr[i].erstba_high = 0;\n\n        xhci->intr[i].erdp_low = 0;\n\n        xhci->intr[i].erdp_high = 0;\n\n        xhci->intr[i].msix_used = 0;\n\n\n\n        xhci->intr[i].er_ep_idx = 0;\n\n        xhci->intr[i].er_pcs = 1;\n\n        xhci->intr[i].er_full = 0;\n\n        xhci->intr[i].ev_buffer_put = 0;\n\n        xhci->intr[i].ev_buffer_get = 0;\n\n    }\n\n\n\n    xhci->mfindex_start = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n    xhci_mfwrap_update(xhci);\n\n}\n", "idx": 3236, "_split": "test", "_hash": "d18be58320f94a2154ce124ae98c4502"}
{"project": "qemu", "commit_id": "068abdc8a57023eeafe1025b964a50f8a39929b4", "target": 1, "func": "int ppc_find_by_pvr (uint32_t pvr, ppc_def_t **def)\n\n{\n\n    int i, ret;\n\n\n\n    ret = -1;\n\n    *def = NULL;\n\n    for (i = 0; ppc_defs[i].name != NULL; i++) {\n\n        if ((pvr & ppc_defs[i].pvr_mask) ==\n\n            (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) {\n\n            *def = &ppc_defs[i];\n\n            ret = 0;\n\n            break;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 3237, "_split": "test", "_hash": "d45b3742b4b64079c0d73b84b27b0de4"}
{"project": "qemu", "commit_id": "ef29a70d18c2d551cf4bb74b8aa9638caac3391b", "target": 0, "func": "void helper_tlb_update(uint32_t T0)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n\tuint32_t vaddr;\n\n\tuint32_t srs = env->pregs[PR_SRS];\n\n\n\n\tif (srs != 1 && srs != 2)\n\n\t\treturn;\n\n\n\n\tvaddr = cris_mmu_tlb_latest_update(env, T0);\n\n\tD(printf(\"flush old_vaddr=%x vaddr=%x T0=%x\\n\", vaddr, \n\n\t\t env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));\n\n\ttlb_flush_page(env, vaddr);\n\n#endif\n\n}\n", "idx": 3256, "_split": "test", "_hash": "4a4be01370c4c6cf92172ecf46c2d060"}
{"project": "qemu", "commit_id": "99fd437dee468609de8218f0eb3b16621fb6a9c9", "target": 0, "func": "static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)\n\n{\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;\n\n\n\n    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,\n\n     * replace the method name: _EJ0 by ACPI_EJ0_.\n\n     */\n\n    /* Sanity check */\n\n    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, \"_EJ0\", 4));\n\n\n\n    if (!eject) {\n\n        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, \"EJ0_\", 4);\n\n    }\n\n}\n", "idx": 3266, "_split": "test", "_hash": "85bd2d78f14a6a188294787431b7c37f"}
{"project": "qemu", "commit_id": "a907ec52cc1aefc820768b6e341b56f8f3caaca7", "target": 1, "func": "static void nvme_instance_init(Object *obj)\n\n{\n\n    object_property_add(obj, \"bootindex\", \"int32\",\n\n                        nvme_get_bootindex,\n\n                        nvme_set_bootindex, NULL, NULL, NULL);\n\n    object_property_set_int(obj, -1, \"bootindex\", NULL);\n\n}\n", "idx": 3278, "_split": "test", "_hash": "14f876b7cc66ce9881070d4222faca9e"}
{"project": "qemu", "commit_id": "7e39d3a2dd34a84900e10b4ea1567f3b352659af", "target": 1, "func": "static int blkverify_open(BlockDriverState *bs, QDict *options, int flags,\n\n                          Error **errp)\n\n{\n\n    BDRVBlkverifyState *s = bs->opaque;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n\n\n\n    /* Open the raw file */\n\n    bs->file = bdrv_open_child(qemu_opt_get(opts, \"x-raw\"), options, \"raw\",\n\n                               bs, &child_file, false, &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    /* Open the test file */\n\n    s->test_file = bdrv_open_child(qemu_opt_get(opts, \"x-image\"), options,\n\n                                   \"test\", bs, &child_format, false,\n\n                                   &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    ret = 0;\n\nfail:\n\n\n\n\n    qemu_opts_del(opts);\n\n    return ret;\n", "idx": 3279, "_split": "test", "_hash": "a45ccd1bfc421101449711a13911132b"}
{"project": "qemu", "commit_id": "f2488736371ae902f345cf9270d141f0a6797731", "target": 1, "func": "static void tcg_out_tlb_read(TCGContext *s, TCGReg addrlo, TCGReg addrhi,\n\n                             int s_bits, int tlb_offset)\n\n{\n\n    TCGReg base = TCG_AREG0;\n\n\n\n    /* Should generate something like the following:\n\n     * pre-v7:\n\n     *   shr    tmp, addr_reg, #TARGET_PAGE_BITS                  (1)\n\n     *   add    r2, env, #off & 0xff00\n\n     *   and    r0, tmp, #(CPU_TLB_SIZE - 1)                      (2)\n\n     *   add    r2, r2, r0, lsl #CPU_TLB_ENTRY_BITS               (3)\n\n     *   ldr    r0, [r2, #off & 0xff]!                            (4)\n\n     *   tst    addr_reg, #s_mask\n\n     *   cmpeq  r0, tmp, lsl #TARGET_PAGE_BITS                    (5)\n\n     *\n\n     * v7 (not implemented yet):\n\n     *   ubfx   r2, addr_reg, #TARGET_PAGE_BITS, #CPU_TLB_BITS    (1)\n\n     *   movw   tmp, #~TARGET_PAGE_MASK & ~s_mask\n\n     *   movw   r0, #off\n\n     *   add    r2, env, r2, lsl #CPU_TLB_ENTRY_BITS              (2)\n\n     *   bic    tmp, addr_reg, tmp\n\n     *   ldr    r0, [r2, r0]!                                     (3)\n\n     *   cmp    r0, tmp                                           (4)\n\n     */\n\n#  if CPU_TLB_BITS > 8\n\n#   error\n\n#  endif\n\n    tcg_out_dat_reg(s, COND_AL, ARITH_MOV, TCG_REG_TMP,\n\n                    0, addrlo, SHIFT_IMM_LSR(TARGET_PAGE_BITS));\n\n\n\n    /* We assume that the offset is contained within 16 bits.  */\n\n    assert((tlb_offset & ~0xffff) == 0);\n\n    if (tlb_offset > 0xff) {\n\n        tcg_out_dat_imm(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,\n\n                        (24 << 7) | (tlb_offset >> 8));\n\n        tlb_offset &= 0xff;\n\n        base = TCG_REG_R2;\n\n    }\n\n\n\n    tcg_out_dat_imm(s, COND_AL, ARITH_AND,\n\n                    TCG_REG_R0, TCG_REG_TMP, CPU_TLB_SIZE - 1);\n\n    tcg_out_dat_reg(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,\n\n                    TCG_REG_R0, SHIFT_IMM_LSL(CPU_TLB_ENTRY_BITS));\n\n\n\n    /* Load the tlb comparator.  Use ldrd if needed and available,\n\n       but due to how the pointer needs setting up, ldm isn't useful.\n\n       Base arm5 doesn't have ldrd, but armv5te does.  */\n\n    if (use_armv6_instructions && TARGET_LONG_BITS == 64) {\n\n        tcg_out_memop_8(s, COND_AL, INSN_LDRD_IMM, TCG_REG_R0,\n\n                        TCG_REG_R2, tlb_offset, 1, 1);\n\n    } else {\n\n        tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R0,\n\n                         TCG_REG_R2, tlb_offset, 1, 1);\n\n        if (TARGET_LONG_BITS == 64) {\n\n            tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R1,\n\n                             TCG_REG_R2, 4, 1, 0);\n\n        }\n\n    }\n\n\n\n    /* Check alignment.  */\n\n    if (s_bits) {\n\n        tcg_out_dat_imm(s, COND_AL, ARITH_TST,\n\n                        0, addrlo, (1 << s_bits) - 1);\n\n    }\n\n\n\n    tcg_out_dat_reg(s, (s_bits ? COND_EQ : COND_AL), ARITH_CMP, 0,\n\n                    TCG_REG_R0, TCG_REG_TMP, SHIFT_IMM_LSL(TARGET_PAGE_BITS));\n\n\n\n    if (TARGET_LONG_BITS == 64) {\n\n        tcg_out_dat_reg(s, COND_EQ, ARITH_CMP, 0,\n\n                        TCG_REG_R1, addrhi, SHIFT_IMM_LSL(0));\n\n    }\n\n}\n", "idx": 3288, "_split": "test", "_hash": "82b1a762649e9a477691085d2dbfd897"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "MigrationState *migrate_get_current(void)\n\n{\n\n    static MigrationState current_migration = {\n\n        .state = MIG_STATE_NONE,\n\n        .bandwidth_limit = MAX_THROTTLE,\n\n        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,\n\n        .mbps = -1,\n\n    };\n\n\n\n    return &current_migration;\n\n}\n", "idx": 3320, "_split": "test", "_hash": "51bbea83e154e96684784f05b09c9989"}
{"project": "qemu", "commit_id": "25e5e4c7e9d5ec3e95c9526d1abaca40ada50ab0", "target": 1, "func": "qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,\n\n                    size_t offset, size_t bytes, bool do_send)\n\n{\n\n    size_t done = 0;\n\n    ssize_t ret;\n\n    while (done < bytes) {\n\n        ret = iov_send_recv(sockfd, iov,\n\n                            offset + done, bytes - done, do_send);\n\n        if (ret > 0) {\n\n            done += ret;\n\n        } else if (ret < 0) {\n\n            if (errno == EAGAIN) {\n\n                qemu_coroutine_yield();\n\n            } else if (done == 0) {\n\n                return -1;\n\n            } else {\n\n                break;\n\n            }\n\n        } else if (ret == 0 && !do_send) {\n\n            /* write (send) should never return 0.\n\n             * read (recv) returns 0 for end-of-file (-data).\n\n             * In both cases there's little point retrying,\n\n             * but we do for write anyway, just in case */\n\n            break;\n\n        }\n\n    }\n\n    return done;\n\n}\n", "idx": 3322, "_split": "test", "_hash": "4037105e01e4124cbc255094a8a77b08"}
{"project": "qemu", "commit_id": "e24e49e6194626e4ec9f1aecce6d6a6847320bce", "target": 1, "func": "static int qcow2_change_backing_file(BlockDriverState *bs,\n\n    const char *backing_file, const char *backing_fmt)\n\n{\n\n    return qcow2_update_ext_header(bs, backing_file, backing_fmt);\n\n}\n", "idx": 3327, "_split": "test", "_hash": "3d1df285b0f189430e286b9e956a756c"}
{"project": "qemu", "commit_id": "0ae18ceeaaa2c1749e742c4b112f6c3bf0896408", "target": 0, "func": "static void sun4d_hw_init(const struct sun4d_hwdef *hwdef, ram_addr_t RAM_size,\n\n                          const char *boot_device,\n\n                          DisplayState *ds, const char *kernel_filename,\n\n                          const char *kernel_cmdline,\n\n                          const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env, *envs[MAX_CPUS];\n\n    unsigned int i;\n\n    void *iounits[MAX_IOUNITS], *espdma, *ledma, *main_esp, *nvram, *sbi;\n\n    qemu_irq *cpu_irqs[MAX_CPUS], *sbi_irq, *sbi_cpu_irq,\n\n        *espdma_irq, *ledma_irq;\n\n    qemu_irq *esp_reset, *le_reset;\n\n    ram_addr_t ram_offset, prom_offset, tcx_offset;\n\n    unsigned long kernel_size;\n\n    int ret;\n\n    char buf[1024];\n\n    int drive_index;\n\n    void *fw_cfg;\n\n\n\n    /* init CPUs */\n\n    if (!cpu_model)\n\n        cpu_model = hwdef->default_cpu_model;\n\n\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"qemu: Unable to find Sparc CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        cpu_sparc_set_id(env, i);\n\n        envs[i] = env;\n\n        if (i == 0) {\n\n            qemu_register_reset(main_cpu_reset, env);\n\n        } else {\n\n            qemu_register_reset(secondary_cpu_reset, env);\n\n            env->halted = 1;\n\n        }\n\n        cpu_irqs[i] = qemu_allocate_irqs(cpu_set_irq, envs[i], MAX_PILS);\n\n        env->prom_addr = hwdef->slavio_base;\n\n    }\n\n\n\n    for (i = smp_cpus; i < MAX_CPUS; i++)\n\n        cpu_irqs[i] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS);\n\n\n\n    /* allocate RAM */\n\n    if ((uint64_t)RAM_size > hwdef->max_mem) {\n\n        fprintf(stderr,\n\n                \"qemu: Too much memory for this machine: %d, maximum %d\\n\",\n\n                (unsigned int)(RAM_size / (1024 * 1024)),\n\n                (unsigned int)(hwdef->max_mem / (1024 * 1024)));\n\n        exit(1);\n\n    }\n\n    ram_offset = qemu_ram_alloc(RAM_size);\n\n    cpu_register_physical_memory(0, RAM_size, ram_offset);\n\n\n\n    /* load boot prom */\n\n    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);\n\n    cpu_register_physical_memory(hwdef->slavio_base,\n\n                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &\n\n                                 TARGET_PAGE_MASK,\n\n                                 prom_offset | IO_MEM_ROM);\n\n\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, bios_name);\n\n    ret = load_elf(buf, hwdef->slavio_base - PROM_VADDR, NULL, NULL, NULL);\n\n    if (ret < 0 || ret > PROM_SIZE_MAX)\n\n        ret = load_image_targphys(buf, hwdef->slavio_base, PROM_SIZE_MAX);\n\n    if (ret < 0 || ret > PROM_SIZE_MAX) {\n\n        fprintf(stderr, \"qemu: could not load prom '%s'\\n\",\n\n                buf);\n\n        exit(1);\n\n    }\n\n\n\n    /* set up devices */\n\n    sbi = sbi_init(hwdef->sbi_base, &sbi_irq, &sbi_cpu_irq, cpu_irqs);\n\n\n\n    for (i = 0; i < MAX_IOUNITS; i++)\n\n        if (hwdef->iounit_bases[i] != (target_phys_addr_t)-1)\n\n            iounits[i] = iommu_init(hwdef->iounit_bases[i],\n\n                                    hwdef->iounit_version,\n\n                                    sbi_irq[hwdef->me_irq]);\n\n\n\n    espdma = sparc32_dma_init(hwdef->espdma_base, sbi_irq[hwdef->esp_irq],\n\n                              iounits[0], &espdma_irq, &esp_reset);\n\n\n\n    ledma = sparc32_dma_init(hwdef->ledma_base, sbi_irq[hwdef->le_irq],\n\n                             iounits[0], &ledma_irq, &le_reset);\n\n\n\n    if (graphic_depth != 8 && graphic_depth != 24) {\n\n        fprintf(stderr, \"qemu: Unsupported depth: %d\\n\", graphic_depth);\n\n        exit (1);\n\n    }\n\n    tcx_offset = qemu_ram_alloc(hwdef->vram_size);\n\n    tcx_init(ds, hwdef->tcx_base, phys_ram_base + tcx_offset, tcx_offset,\n\n             hwdef->vram_size, graphic_width, graphic_height, graphic_depth);\n\n\n\n    if (nd_table[0].model == NULL)\n\n        nd_table[0].model = \"lance\";\n\n    if (strcmp(nd_table[0].model, \"lance\") == 0) {\n\n        lance_init(&nd_table[0], hwdef->le_base, ledma, *ledma_irq, le_reset);\n\n    } else if (strcmp(nd_table[0].model, \"?\") == 0) {\n\n        fprintf(stderr, \"qemu: Supported NICs: lance\\n\");\n\n        exit (1);\n\n    } else {\n\n        fprintf(stderr, \"qemu: Unsupported NIC: %s\\n\", nd_table[0].model);\n\n        exit (1);\n\n    }\n\n\n\n    nvram = m48t59_init(sbi_irq[0], hwdef->nvram_base, 0,\n\n                        hwdef->nvram_size, 8);\n\n\n\n    slavio_timer_init_all(hwdef->counter_base, sbi_irq[hwdef->clock1_irq],\n\n                          sbi_cpu_irq, smp_cpus);\n\n\n\n    slavio_serial_ms_kbd_init(hwdef->ms_kb_base, sbi_irq[hwdef->ms_kb_irq],\n\n                              nographic, ESCC_CLOCK, 1);\n\n    // Slavio TTYA (base+4, Linux ttyS0) is the first Qemu serial device\n\n    // Slavio TTYB (base+0, Linux ttyS1) is the second Qemu serial device\n\n    escc_init(hwdef->serial_base, sbi_irq[hwdef->ser_irq], serial_hds[1],\n\n              serial_hds[0], ESCC_CLOCK, 1);\n\n\n\n    if (drive_get_max_bus(IF_SCSI) > 0) {\n\n        fprintf(stderr, \"qemu: too many SCSI bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    main_esp = esp_init(hwdef->esp_base, 2,\n\n                        espdma_memory_read, espdma_memory_write,\n\n                        espdma, *espdma_irq, esp_reset);\n\n\n\n    for (i = 0; i < ESP_MAX_DEVS; i++) {\n\n        drive_index = drive_get_index(IF_SCSI, 0, i);\n\n        if (drive_index == -1)\n\n            continue;\n\n        esp_scsi_attach(main_esp, drives_table[drive_index].bdrv, i);\n\n    }\n\n\n\n    kernel_size = sun4m_load_kernel(kernel_filename, initrd_filename,\n\n                                    RAM_size);\n\n\n\n    nvram_init(nvram, (uint8_t *)&nd_table[0].macaddr, kernel_cmdline,\n\n               boot_device, RAM_size, kernel_size, graphic_width,\n\n               graphic_height, graphic_depth, hwdef->nvram_machine_id,\n\n               \"Sun4d\");\n\n\n\n    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);\n\n}\n", "idx": 3333, "_split": "test", "_hash": "e8c103dab6287760f82eeb9719fa67ae"}
{"project": "qemu", "commit_id": "88571882516a7cb4291a329c537eb79fd126e1f2", "target": 0, "func": "static int qemu_rdma_block_for_wrid(RDMAContext *rdma, int wrid_requested)\n\n{\n\n    int num_cq_events = 0, ret = 0;\n\n    struct ibv_cq *cq;\n\n    void *cq_ctx;\n\n    uint64_t wr_id = RDMA_WRID_NONE, wr_id_in;\n\n\n\n    if (ibv_req_notify_cq(rdma->cq, 0)) {\n\n        return -1;\n\n    }\n\n    /* poll cq first */\n\n    while (wr_id != wrid_requested) {\n\n        ret = qemu_rdma_poll(rdma, &wr_id_in);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        wr_id = wr_id_in & RDMA_WRID_TYPE_MASK;\n\n\n\n        if (wr_id == RDMA_WRID_NONE) {\n\n            break;\n\n        }\n\n        if (wr_id != wrid_requested) {\n\n            DDDPRINTF(\"A Wanted wrid %s (%d) but got %s (%\" PRIu64 \")\\n\",\n\n                print_wrid(wrid_requested),\n\n                wrid_requested, print_wrid(wr_id), wr_id);\n\n        }\n\n    }\n\n\n\n    if (wr_id == wrid_requested) {\n\n        return 0;\n\n    }\n\n\n\n    while (1) {\n\n        /*\n\n         * Coroutine doesn't start until process_incoming_migration()\n\n         * so don't yield unless we know we're running inside of a coroutine.\n\n         */\n\n        if (rdma->migration_started_on_destination) {\n\n            yield_until_fd_readable(rdma->comp_channel->fd);\n\n        }\n\n\n\n        if (ibv_get_cq_event(rdma->comp_channel, &cq, &cq_ctx)) {\n\n            perror(\"ibv_get_cq_event\");\n\n            goto err_block_for_wrid;\n\n        }\n\n\n\n        num_cq_events++;\n\n\n\n        if (ibv_req_notify_cq(cq, 0)) {\n\n            goto err_block_for_wrid;\n\n        }\n\n\n\n        while (wr_id != wrid_requested) {\n\n            ret = qemu_rdma_poll(rdma, &wr_id_in);\n\n            if (ret < 0) {\n\n                goto err_block_for_wrid;\n\n            }\n\n\n\n            wr_id = wr_id_in & RDMA_WRID_TYPE_MASK;\n\n\n\n            if (wr_id == RDMA_WRID_NONE) {\n\n                break;\n\n            }\n\n            if (wr_id != wrid_requested) {\n\n                DDDPRINTF(\"B Wanted wrid %s (%d) but got %s (%\" PRIu64 \")\\n\",\n\n                    print_wrid(wrid_requested), wrid_requested,\n\n                    print_wrid(wr_id), wr_id);\n\n            }\n\n        }\n\n\n\n        if (wr_id == wrid_requested) {\n\n            goto success_block_for_wrid;\n\n        }\n\n    }\n\n\n\nsuccess_block_for_wrid:\n\n    if (num_cq_events) {\n\n        ibv_ack_cq_events(cq, num_cq_events);\n\n    }\n\n    return 0;\n\n\n\nerr_block_for_wrid:\n\n    if (num_cq_events) {\n\n        ibv_ack_cq_events(cq, num_cq_events);\n\n    }\n\n    return ret;\n\n}\n", "idx": 3348, "_split": "test", "_hash": "ded86cb744e7e5a5830e772b28641959"}
{"project": "qemu", "commit_id": "a80bf99fa3dd829ecea88b9bfb4f7cf146208f07", "target": 1, "func": "static int mux_chr_can_read(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    MuxDriver *d = chr->opaque;\n\n\n\n    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)\n\n        return 1;\n\n    if (d->chr_can_read[chr->focus])\n\n        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);\n\n    return 0;\n\n}\n", "idx": 3392, "_split": "test", "_hash": "6b6776c3663c27148b91631d22552da1"}
{"project": "qemu", "commit_id": "8991c460be5a0811194fd4d2b49ba7146a23526b", "target": 1, "func": "static inline bool vtd_queued_inv_enable_check(IntelIOMMUState *s)\n\n{\n\n    return s->iq_tail == 0;\n\n}\n", "idx": 3394, "_split": "test", "_hash": "88c1e9e1009b3cedb08523815b639499"}
{"project": "qemu", "commit_id": "d470ad42acfc73c45d3e8ed5311a491160b4c100", "target": 1, "func": "static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child,\n        int64_t offset, unsigned int bytes, QEMUIOVector *qiov)\n{\n    BlockDriverState *bs = child->bs;\n    /* Perform I/O through a temporary buffer so that users who scribble over\n     * their read buffer while the operation is in progress do not end up\n     * modifying the image file.  This is critical for zero-copy guest I/O\n     * where anything might happen inside guest memory.\n     */\n    void *bounce_buffer;\n    BlockDriver *drv = bs->drv;\n    struct iovec iov;\n    QEMUIOVector local_qiov;\n    int64_t cluster_offset;\n    int64_t cluster_bytes;\n    size_t skip_bytes;\n    int ret;\n    int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,\n                                    BDRV_REQUEST_MAX_BYTES);\n    unsigned int progress = 0;\n    /* FIXME We cannot require callers to have write permissions when all they\n     * are doing is a read request. If we did things right, write permissions\n     * would be obtained anyway, but internally by the copy-on-read code. As\n     * long as it is implemented here rather than in a separate filter driver,\n     * the copy-on-read code doesn't have its own BdrvChild, however, for which\n     * it could request permissions. Therefore we have to bypass the permission\n     * system for the moment. */\n    // assert(child->perm & (BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE));\n    /* Cover entire cluster so no additional backing file I/O is required when\n     * allocating cluster in the image file.  Note that this value may exceed\n     * BDRV_REQUEST_MAX_BYTES (even when the original read did not), which\n     * is one reason we loop rather than doing it all at once.\n     */\n    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);\n    skip_bytes = offset - cluster_offset;\n    trace_bdrv_co_do_copy_on_readv(bs, offset, bytes,\n                                   cluster_offset, cluster_bytes);\n    bounce_buffer = qemu_try_blockalign(bs,\n                                        MIN(MIN(max_transfer, cluster_bytes),\n                                            MAX_BOUNCE_BUFFER));\n    if (bounce_buffer == NULL) {\n        ret = -ENOMEM;\n        goto err;\n    while (cluster_bytes) {\n        int64_t pnum;\n        ret = bdrv_is_allocated(bs, cluster_offset,\n                                MIN(cluster_bytes, max_transfer), &pnum);\n        if (ret < 0) {\n            /* Safe to treat errors in querying allocation as if\n             * unallocated; we'll probably fail again soon on the\n             * read, but at least that will set a decent errno.\n             */\n            pnum = MIN(cluster_bytes, max_transfer);\n        assert(skip_bytes < pnum);\n        if (ret <= 0) {\n            /* Must copy-on-read; use the bounce buffer */\n            iov.iov_base = bounce_buffer;\n            iov.iov_len = pnum = MIN(pnum, MAX_BOUNCE_BUFFER);\n            qemu_iovec_init_external(&local_qiov, &iov, 1);\n            ret = bdrv_driver_preadv(bs, cluster_offset, pnum,\n                                     &local_qiov, 0);\n            if (ret < 0) {\n                goto err;\n            bdrv_debug_event(bs, BLKDBG_COR_WRITE);\n            if (drv->bdrv_co_pwrite_zeroes &&\n                buffer_is_zero(bounce_buffer, pnum)) {\n                /* FIXME: Should we (perhaps conditionally) be setting\n                 * BDRV_REQ_MAY_UNMAP, if it will allow for a sparser copy\n                 * that still correctly reads as zero? */\n                ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, pnum, 0);\n            } else {\n                /* This does not change the data on the disk, it is not\n                 * necessary to flush even in cache=writethrough mode.\n                 */\n                ret = bdrv_driver_pwritev(bs, cluster_offset, pnum,\n                                          &local_qiov, 0);\n            if (ret < 0) {\n                /* It might be okay to ignore write errors for guest\n                 * requests.  If this is a deliberate copy-on-read\n                 * then we don't want to ignore the error.  Simply\n                 * report it in all cases.\n                 */\n                goto err;\n            qemu_iovec_from_buf(qiov, progress, bounce_buffer + skip_bytes,\n                                pnum - skip_bytes);\n        } else {\n            /* Read directly into the destination */\n            qemu_iovec_init(&local_qiov, qiov->niov);\n            qemu_iovec_concat(&local_qiov, qiov, progress, pnum - skip_bytes);\n            ret = bdrv_driver_preadv(bs, offset + progress, local_qiov.size,\n                                     &local_qiov, 0);\n            qemu_iovec_destroy(&local_qiov);\n            if (ret < 0) {\n                goto err;\n        cluster_offset += pnum;\n        cluster_bytes -= pnum;\n        progress += pnum - skip_bytes;\n        skip_bytes = 0;\n    ret = 0;\nerr:\n    qemu_vfree(bounce_buffer);\n    return ret;", "idx": 3398, "_split": "test", "_hash": "7e4d850561f4e5083150a32bf1add067"}
{"project": "qemu", "commit_id": "2cbe2de5454cf9af44b620b2b40d56361a12a45f", "target": 1, "func": "static void virtio_scsi_device_unrealize(DeviceState *dev, Error **errp)\n{\n    virtio_scsi_common_unrealize(dev, errp);\n}", "idx": 3399, "_split": "test", "_hash": "1d873ff66a986a77b4809b3c5589c050"}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static int protocol_client_init(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    char buf[1024];\n\n    VncShareMode mode;\n\n    int size;\n\n\n\n    mode = data[0] ? VNC_SHARE_MODE_SHARED : VNC_SHARE_MODE_EXCLUSIVE;\n\n    switch (vs->vd->share_policy) {\n\n    case VNC_SHARE_POLICY_IGNORE:\n\n        /*\n\n         * Ignore the shared flag.  Nothing to do here.\n\n         *\n\n         * Doesn't conform to the rfb spec but is traditional qemu\n\n         * behavior, thus left here as option for compatibility\n\n         * reasons.\n\n         */\n\n        break;\n\n    case VNC_SHARE_POLICY_ALLOW_EXCLUSIVE:\n\n        /*\n\n         * Policy: Allow clients ask for exclusive access.\n\n         *\n\n         * Implementation: When a client asks for exclusive access,\n\n         * disconnect all others. Shared connects are allowed as long\n\n         * as no exclusive connection exists.\n\n         *\n\n         * This is how the rfb spec suggests to handle the shared flag.\n\n         */\n\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n            VncState *client;\n\n            QTAILQ_FOREACH(client, &vs->vd->clients, next) {\n\n                if (vs == client) {\n\n                    continue;\n\n                }\n\n                if (client->share_mode != VNC_SHARE_MODE_EXCLUSIVE &&\n\n                    client->share_mode != VNC_SHARE_MODE_SHARED) {\n\n                    continue;\n\n                }\n\n                vnc_disconnect_start(client);\n\n            }\n\n        }\n\n        if (mode == VNC_SHARE_MODE_SHARED) {\n\n            if (vs->vd->num_exclusive > 0) {\n\n                vnc_disconnect_start(vs);\n\n                return 0;\n\n            }\n\n        }\n\n        break;\n\n    case VNC_SHARE_POLICY_FORCE_SHARED:\n\n        /*\n\n         * Policy: Shared connects only.\n\n         * Implementation: Disallow clients asking for exclusive access.\n\n         *\n\n         * Useful for shared desktop sessions where you don't want\n\n         * someone forgetting to say -shared when running the vnc\n\n         * client disconnect everybody else.\n\n         */\n\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n            vnc_disconnect_start(vs);\n\n            return 0;\n\n        }\n\n        break;\n\n    }\n\n    vnc_set_share_mode(vs, mode);\n\n\n\n    vs->client_width = surface_width(vs->vd->ds);\n\n    vs->client_height = surface_height(vs->vd->ds);\n\n    vnc_write_u16(vs, vs->client_width);\n\n    vnc_write_u16(vs, vs->client_height);\n\n\n\n    pixel_format_message(vs);\n\n\n\n    if (qemu_name)\n\n        size = snprintf(buf, sizeof(buf), \"QEMU (%s)\", qemu_name);\n\n    else\n\n        size = snprintf(buf, sizeof(buf), \"QEMU\");\n\n\n\n    vnc_write_u32(vs, size);\n\n    vnc_write(vs, buf, size);\n\n    vnc_flush(vs);\n\n\n\n    vnc_client_cache_auth(vs);\n\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_INITIALIZED);\n\n\n\n    vnc_read_when(vs, protocol_client_msg, 1);\n\n\n\n    return 0;\n\n}\n", "idx": 3401, "_split": "test", "_hash": "c45134227fadc96f08789aa06a4dfd04"}
{"project": "qemu", "commit_id": "a27365265cc2fed1178bf25a205e8ee02a9c0caf", "target": 0, "func": "static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,\n\n                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n                         BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,\n\n                       cb, opaque, QEMU_AIO_READ);\n\n}\n", "idx": 3440, "_split": "test", "_hash": "2fdca6449535567d02e3cbd28a9ba1b5"}
{"project": "qemu", "commit_id": "973945804d95878375b487c0c5c9b2556c5e4543", "target": 0, "func": "static void tcx_blit_writel(void *opaque, hwaddr addr,\n\n                            uint64_t val, unsigned size)\n\n{\n\n    TCXState *s = opaque;\n\n    uint32_t adsr, len;\n\n    int i;\n\n\n\n    if (!(addr & 4)) {\n\n        s->tmpblit = val;\n\n    } else {\n\n        addr = (addr >> 3) & 0xfffff;\n\n        adsr = val & 0xffffff;\n\n        len = ((val >> 24) & 0x1f) + 1;\n\n        if (adsr == 0xffffff) {\n\n            memset(&s->vram[addr], s->tmpblit, len);\n\n            if (s->depth == 24) {\n\n                val = s->tmpblit & 0xffffff;\n\n                val = cpu_to_be32(val);\n\n                for (i = 0; i < len; i++) {\n\n                    s->vram24[addr + i] = val;\n\n                }\n\n            }\n\n        } else {\n\n            memcpy(&s->vram[addr], &s->vram[adsr], len);\n\n            if (s->depth == 24) {\n\n                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);\n\n            }\n\n        }\n\n        memory_region_set_dirty(&s->vram_mem, addr, len);\n\n    }\n\n}\n", "idx": 3449, "_split": "test", "_hash": "1efc756289e079199f0210a128f56c1d"}
{"project": "qemu", "commit_id": "ee71c984342408a357a74f65915bf66484ba445a", "target": 1, "func": "static uint64_t icp_pit_read(void *opaque, target_phys_addr_t offset,\n\n                             unsigned size)\n\n{\n\n    icp_pit_state *s = (icp_pit_state *)opaque;\n\n    int n;\n\n\n\n    /* ??? Don't know the PrimeCell ID for this device.  */\n\n    n = offset >> 8;\n\n    if (n > 3) {\n\n        hw_error(\"sp804_read: Bad timer %d\\n\", n);\n\n    }\n\n\n\n    return arm_timer_read(s->timer[n], offset & 0xff);\n\n}\n", "idx": 3484, "_split": "test", "_hash": "59ec4f868074fe90071c9472f6ed852f"}
{"project": "qemu", "commit_id": "bec93d7283b635aabaf0bbff67b6da7fc99e020a", "target": 0, "func": "static void gen_compute_eflags_o(DisasContext *s, TCGv reg)\n\n{\n\n    gen_compute_eflags(s);\n\n    tcg_gen_shri_tl(reg, cpu_cc_src, 11);\n\n    tcg_gen_andi_tl(reg, reg, 1);\n\n}\n", "idx": 3513, "_split": "test", "_hash": "98a3930a23e9af3f867b0384e07310ec"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void gem_write(void *opaque, target_phys_addr_t offset, uint64_t val,\n\n        unsigned size)\n\n{\n\n    GemState *s = (GemState *)opaque;\n\n    uint32_t readonly;\n\n\n\n    DB_PRINT(\"offset: 0x%04x write: 0x%08x \", offset, (unsigned)val);\n\n    offset >>= 2;\n\n\n\n    /* Squash bits which are read only in write value */\n\n    val &= ~(s->regs_ro[offset]);\n\n    /* Preserve (only) bits which are read only in register */\n\n    readonly = s->regs[offset];\n\n    readonly &= s->regs_ro[offset];\n\n\n\n    /* Squash bits which are write 1 to clear */\n\n    val &= ~(s->regs_w1c[offset] & val);\n\n\n\n    /* Copy register write to backing store */\n\n    s->regs[offset] = val | readonly;\n\n\n\n    /* Handle register write side effects */\n\n    switch (offset) {\n\n    case GEM_NWCTRL:\n\n        if (val & GEM_NWCTRL_TXSTART) {\n\n            gem_transmit(s);\n\n        }\n\n        if (!(val & GEM_NWCTRL_TXENA)) {\n\n            /* Reset to start of Q when transmit disabled. */\n\n            s->tx_desc_addr = s->regs[GEM_TXQBASE];\n\n        }\n\n        if (!(val & GEM_NWCTRL_RXENA)) {\n\n            /* Reset to start of Q when receive disabled. */\n\n            s->rx_desc_addr = s->regs[GEM_RXQBASE];\n\n        }\n\n        break;\n\n\n\n    case GEM_TXSTATUS:\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_RXQBASE:\n\n        s->rx_desc_addr = val;\n\n        break;\n\n    case GEM_TXQBASE:\n\n        s->tx_desc_addr = val;\n\n        break;\n\n    case GEM_RXSTATUS:\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_IER:\n\n        s->regs[GEM_IMR] &= ~val;\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_IDR:\n\n        s->regs[GEM_IMR] |= val;\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_PHYMNTNC:\n\n        if (val & GEM_PHYMNTNC_OP_W) {\n\n            uint32_t phy_addr, reg_num;\n\n\n\n            phy_addr = (val & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT;\n\n            if (phy_addr == BOARD_PHY_ADDRESS) {\n\n                reg_num = (val & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT;\n\n                gem_phy_write(s, reg_num, val);\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\n    DB_PRINT(\"newval: 0x%08x\\n\", s->regs[offset]);\n\n}\n", "idx": 3521, "_split": "test", "_hash": "caecc9d27c48e1c3100bc96207741582"}
{"project": "qemu", "commit_id": "0b1bcb00fb2baf5f3227dd9cd849fa69bf50d7a8", "target": 1, "func": "void cpu_loop(CPUMIPSState *env)\n\n{\n\n    target_siginfo_t info;\n\n    int trapnr, ret;\n\n    unsigned int syscall_num;\n\n\n\n    for(;;) {\n\n        trapnr = cpu_mips_exec(env);\n\n        switch(trapnr) {\n\n        case EXCP_SYSCALL:\n\n            syscall_num = env->active_tc.gpr[2] - 4000;\n\n            env->active_tc.PC += 4;\n\n            if (syscall_num >= sizeof(mips_syscall_args)) {\n\n                ret = -ENOSYS;\n\n            } else {\n\n                int nb_args;\n\n                abi_ulong sp_reg;\n\n                abi_ulong arg5 = 0, arg6 = 0, arg7 = 0, arg8 = 0;\n\n\n\n                nb_args = mips_syscall_args[syscall_num];\n\n                sp_reg = env->active_tc.gpr[29];\n\n                switch (nb_args) {\n\n                /* these arguments are taken from the stack */\n\n                /* FIXME - what to do if get_user() fails? */\n\n                case 8: get_user_ual(arg8, sp_reg + 28);\n\n                case 7: get_user_ual(arg7, sp_reg + 24);\n\n                case 6: get_user_ual(arg6, sp_reg + 20);\n\n                case 5: get_user_ual(arg5, sp_reg + 16);\n\n                default:\n\n\n\n                ret = do_syscall(env, env->active_tc.gpr[2],\n\n                                 env->active_tc.gpr[4],\n\n                                 env->active_tc.gpr[5],\n\n                                 env->active_tc.gpr[6],\n\n                                 env->active_tc.gpr[7],\n\n                                 arg5, arg6/*, arg7, arg8*/);\n\n\n\n\n\n\n\n            if ((unsigned int)ret >= (unsigned int)(-1133)) {\n\n                env->active_tc.gpr[7] = 1; /* error flag */\n\n                ret = -ret;\n\n            } else {\n\n                env->active_tc.gpr[7] = 0; /* error flag */\n\n\n            env->active_tc.gpr[2] = ret;\n\n\n        case EXCP_TLBL:\n\n        case EXCP_TLBS:\n\n            info.si_signo = TARGET_SIGSEGV;\n\n            info.si_errno = 0;\n\n            /* XXX: check env->error_code */\n\n            info.si_code = TARGET_SEGV_MAPERR;\n\n            info._sifields._sigfault._addr = env->CP0_BadVAddr;\n\n            queue_signal(env, info.si_signo, &info);\n\n\n        case EXCP_CpU:\n\n        case EXCP_RI:\n\n            info.si_signo = TARGET_SIGILL;\n\n            info.si_errno = 0;\n\n            info.si_code = 0;\n\n            queue_signal(env, info.si_signo, &info);\n\n\n        case EXCP_INTERRUPT:\n\n            /* just indicate that signals should be handled asap */\n\n\n        case EXCP_DEBUG:\n\n            {\n\n                int sig;\n\n\n\n                sig = gdb_handlesig (env, TARGET_SIGTRAP);\n\n                if (sig)\n\n                  {\n\n                    info.si_signo = sig;\n\n                    info.si_errno = 0;\n\n                    info.si_code = TARGET_TRAP_BRKPT;\n\n                    queue_signal(env, info.si_signo, &info);\n\n\n\n\n        default:\n\n            //        error:\n\n            fprintf(stderr, \"qemu: unhandled CPU exception 0x%x - aborting\\n\",\n\n                    trapnr);\n\n            cpu_dump_state(env, stderr, fprintf, 0);\n\n            abort();\n\n\n        process_pending_signals(env);\n\n", "idx": 3540, "_split": "test", "_hash": "76d92e05c0b8069a6c264885ba71b660"}
{"project": "qemu", "commit_id": "58d479786b11a7e982419c1e0905b8490ef9a787", "target": 1, "func": "static void bonito_ldma_writel(void *opaque, hwaddr addr,\n                               uint64_t val, unsigned size)\n{\n    PCIBonitoState *s = opaque;\n    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;", "idx": 3555, "_split": "test", "_hash": "4f8b11eb642c94a5b3cea1f2d9b599ea"}
{"project": "qemu", "commit_id": "bba4e1b591531c087fce4ae501dc1ca299d8fb42", "target": 1, "func": "static void curses_refresh(DisplayChangeListener *dcl)\n\n{\n\n    int chr, nextchr, keysym, keycode, keycode_alt;\n\n\n\n    curses_winch_check();\n\n\n\n    if (invalidate) {\n\n        clear();\n\n        refresh();\n\n        curses_calc_pad();\n\n        graphic_hw_invalidate(NULL);\n\n        invalidate = 0;\n\n    }\n\n\n\n    graphic_hw_text_update(NULL, screen);\n\n\n\n    nextchr = ERR;\n\n    while (1) {\n\n        /* while there are any pending key strokes to process */\n\n        if (nextchr == ERR)\n\n            chr = getch();\n\n        else {\n\n            chr = nextchr;\n\n            nextchr = ERR;\n\n        }\n\n\n\n        if (chr == ERR)\n\n            break;\n\n\n\n#ifdef KEY_RESIZE\n\n        /* this shouldn't occur when we use a custom SIGWINCH handler */\n\n        if (chr == KEY_RESIZE) {\n\n            clear();\n\n            refresh();\n\n            curses_calc_pad();\n\n            curses_update(dcl, 0, 0, width, height);\n\n            continue;\n\n        }\n\n#endif\n\n\n\n        keycode = curses2keycode[chr];\n\n        keycode_alt = 0;\n\n\n\n        /* alt key */\n\n        if (keycode == 1) {\n\n            nextchr = getch();\n\n\n\n            if (nextchr != ERR) {\n\n                chr = nextchr;\n\n                keycode_alt = ALT;\n\n                keycode = curses2keycode[nextchr];\n\n                nextchr = ERR;\n\n\n\n                if (keycode != -1) {\n\n                    keycode |= ALT;\n\n\n\n                    /* process keys reserved for qemu */\n\n                    if (keycode >= QEMU_KEY_CONSOLE0 &&\n\n                            keycode < QEMU_KEY_CONSOLE0 + 9) {\n\n                        erase();\n\n                        wnoutrefresh(stdscr);\n\n                        console_select(keycode - QEMU_KEY_CONSOLE0);\n\n\n\n                        invalidate = 1;\n\n                        continue;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        if (kbd_layout) {\n\n            keysym = -1;\n\n            if (chr < CURSES_KEYS)\n\n                keysym = curses2keysym[chr];\n\n\n\n            if (keysym == -1) {\n\n                if (chr < ' ') {\n\n                    keysym = chr + '@';\n\n                    if (keysym >= 'A' && keysym <= 'Z')\n\n                        keysym += 'a' - 'A';\n\n                    keysym |= KEYSYM_CNTRL;\n\n                } else\n\n                    keysym = chr;\n\n            }\n\n\n\n            keycode = keysym2scancode(kbd_layout, keysym & KEYSYM_MASK);\n\n            if (keycode == 0)\n\n                continue;\n\n\n\n            keycode |= (keysym & ~KEYSYM_MASK) >> 16;\n\n            keycode |= keycode_alt;\n\n        }\n\n\n\n        if (keycode == -1)\n\n            continue;\n\n\n\n        if (qemu_console_is_graphic(NULL)) {\n\n            /* since terminals don't know about key press and release\n\n             * events, we need to emit both for each key received */\n\n            if (keycode & SHIFT) {\n\n                qemu_input_event_send_key_number(NULL, SHIFT_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & CNTRL) {\n\n                qemu_input_event_send_key_number(NULL, CNTRL_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALT) {\n\n                qemu_input_event_send_key_number(NULL, ALT_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALTGR) {\n\n                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n\n\n            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, true);\n\n            qemu_input_event_send_key_delay(0);\n\n            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, false);\n\n            qemu_input_event_send_key_delay(0);\n\n\n\n            if (keycode & ALTGR) {\n\n                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALT) {\n\n                qemu_input_event_send_key_number(NULL, ALT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & CNTRL) {\n\n                qemu_input_event_send_key_number(NULL, CNTRL_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & SHIFT) {\n\n                qemu_input_event_send_key_number(NULL, SHIFT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n        } else {\n\n            keysym = curses2qemu[chr];\n\n            if (keysym == -1)\n\n                keysym = chr;\n\n\n\n            kbd_put_keysym(keysym);\n\n        }\n\n    }\n\n}\n", "idx": 3582, "_split": "test", "_hash": "61cfcab81022c8631d717e547c8f0fd8"}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void raven_class_init(ObjectClass *klass, void *data)\n\n{\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    k->init = raven_init;\n\n    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;\n\n    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;\n\n    k->revision = 0x00;\n\n    k->class_id = PCI_CLASS_BRIDGE_HOST;\n\n    dc->desc = \"PReP Host Bridge - Motorola Raven\";\n\n    dc->vmsd = &vmstate_raven;\n\n    dc->no_user = 1;\n\n}\n", "idx": 3598, "_split": "test", "_hash": "ac4ab84f84c0a9d900c6a5e7aa41ad6c"}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void pci_add_option_rom(PCIDevice *pdev, bool is_default_rom,\n\n                               Error **errp)\n\n{\n\n    int size;\n\n    char *path;\n\n    void *ptr;\n\n    char name[32];\n\n    const VMStateDescription *vmsd;\n\n\n\n    if (!pdev->romfile)\n\n        return;\n\n    if (strlen(pdev->romfile) == 0)\n\n        return;\n\n\n\n    if (!pdev->rom_bar) {\n\n        /*\n\n         * Load rom via fw_cfg instead of creating a rom bar,\n\n         * for 0.11 compatibility.\n\n         */\n\n        int class = pci_get_word(pdev->config + PCI_CLASS_DEVICE);\n\n\n\n        /*\n\n         * Hot-plugged devices can't use the option ROM\n\n         * if the rom bar is disabled.\n\n         */\n\n        if (DEVICE(pdev)->hotplugged) {\n\n            error_setg(errp, \"Hot-plugged device without ROM bar\"\n\n                       \" can't have an option ROM\");\n\n            return;\n\n        }\n\n\n\n        if (class == 0x0300) {\n\n            rom_add_vga(pdev->romfile);\n\n        } else {\n\n            rom_add_option(pdev->romfile, -1);\n\n        }\n\n        return;\n\n    }\n\n\n\n    path = qemu_find_file(QEMU_FILE_TYPE_BIOS, pdev->romfile);\n\n    if (path == NULL) {\n\n        path = g_strdup(pdev->romfile);\n\n    }\n\n\n\n    size = get_image_size(path);\n\n    if (size < 0) {\n\n        error_setg(errp, \"failed to find romfile \\\"%s\\\"\", pdev->romfile);\n\n        g_free(path);\n\n        return;\n\n    } else if (size == 0) {\n\n        error_setg(errp, \"romfile \\\"%s\\\" is empty\", pdev->romfile);\n\n        g_free(path);\n\n        return;\n\n    }\n\n    size = pow2ceil(size);\n\n\n\n    vmsd = qdev_get_vmsd(DEVICE(pdev));\n\n\n\n    if (vmsd) {\n\n        snprintf(name, sizeof(name), \"%s.rom\", vmsd->name);\n\n    } else {\n\n        snprintf(name, sizeof(name), \"%s.rom\", object_get_typename(OBJECT(pdev)));\n\n    }\n\n    pdev->has_rom = true;\n\n    memory_region_init_ram(&pdev->rom, OBJECT(pdev), name, size, &error_abort);\n\n    vmstate_register_ram(&pdev->rom, &pdev->qdev);\n\n    ptr = memory_region_get_ram_ptr(&pdev->rom);\n\n    load_image(path, ptr);\n\n    g_free(path);\n\n\n\n    if (is_default_rom) {\n\n        /* Only the default rom images will be patched (if needed). */\n\n        pci_patch_ids(pdev, ptr, size);\n\n    }\n\n\n\n    pci_register_bar(pdev, PCI_ROM_SLOT, 0, &pdev->rom);\n\n}\n", "idx": 3602, "_split": "test", "_hash": "a1f25987e1c611a5fd25dc28052d2fd8"}
{"project": "qemu", "commit_id": "8f68760561abf90156456fec6ad55c3b2a066d46", "target": 1, "func": "static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *pdev)\n\n{\n\n    char *path = NULL, *buf = NULL, *host = NULL;\n\n\n\n    /* Get the PCI VFIO host id */\n\n    host = object_property_get_str(OBJECT(pdev), \"host\", NULL);\n\n    if (!host) {\n\n        goto err_out;\n\n    }\n\n\n\n    /* Construct the path of the file that will give us the DT location */\n\n    path = g_strdup_printf(\"/sys/bus/pci/devices/%s/devspec\", host);\n\n    g_free(host);\n\n    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {\n\n        goto err_out;\n\n    }\n\n    g_free(path);\n\n\n\n    /* Construct and read from host device tree the loc-code */\n\n    path = g_strdup_printf(\"/proc/device-tree%s/ibm,loc-code\", buf);\n\n    g_free(buf);\n\n    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {\n\n        goto err_out;\n\n    }\n\n    return buf;\n\n\n\nerr_out:\n\n    g_free(path);\n\n    return NULL;\n\n}\n", "idx": 3611, "_split": "test", "_hash": "97d34b618f4b4ed12670821fd4eb6a02"}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val)\n\n{\n\n    uint32_t qid;\n\n\n\n    if (addr & ((1 << 2) - 1)) {\n\n        return;\n\n    }\n\n\n\n    if (((addr - 0x1000) >> 2) & 1) {\n\n        uint16_t new_head = val & 0xffff;\n\n        int start_sqs;\n\n        NvmeCQueue *cq;\n\n\n\n        qid = (addr - (0x1000 + (1 << 2))) >> 3;\n\n        if (nvme_check_cqid(n, qid)) {\n\n            return;\n\n        }\n\n\n\n        cq = n->cq[qid];\n\n        if (new_head >= cq->size) {\n\n            return;\n\n        }\n\n\n\n        start_sqs = nvme_cq_full(cq) ? 1 : 0;\n\n        cq->head = new_head;\n\n        if (start_sqs) {\n\n            NvmeSQueue *sq;\n\n            QTAILQ_FOREACH(sq, &cq->sq_list, entry) {\n\n                timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n            }\n\n            timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n        }\n\n\n\n        if (cq->tail != cq->head) {\n\n            nvme_isr_notify(n, cq);\n\n        }\n\n    } else {\n\n        uint16_t new_tail = val & 0xffff;\n\n        NvmeSQueue *sq;\n\n\n\n        qid = (addr - 0x1000) >> 3;\n\n        if (nvme_check_sqid(n, qid)) {\n\n            return;\n\n        }\n\n\n\n        sq = n->sq[qid];\n\n        if (new_tail >= sq->size) {\n\n            return;\n\n        }\n\n\n\n        sq->tail = new_tail;\n\n        timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n    }\n\n}\n", "idx": 3634, "_split": "test", "_hash": "9d5f6b3937486d4b22aee1963c5cab41"}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n", "idx": 3681, "_split": "test", "_hash": "b1d89ff457cb802cd5fcd949d1d415e4"}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)\n\n{\n\n    int ret = 0;\n\n\n\n    assert(len > 0);\n\n    ccid_bulk_in_get(s);\n\n    if (s->current_bulk_in != NULL) {\n\n        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);\n\n        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);\n\n        s->current_bulk_in->pos += ret;\n\n        if (s->current_bulk_in->pos == s->current_bulk_in->len) {\n\n            ccid_bulk_in_release(s);\n\n        }\n\n    } else {\n\n        /* return when device has no data - usb 2.0 spec Table 8-4 */\n\n        ret = USB_RET_NAK;\n\n    }\n\n    if (ret > 0) {\n\n        DPRINTF(s, D_MORE_INFO,\n\n                \"%s: %d/%d req/act to guest (BULK_IN)\\n\", __func__, len, ret);\n\n    }\n\n    if (ret != USB_RET_NAK && ret < len) {\n\n        DPRINTF(s, 1,\n\n            \"%s: returning short (EREMOTEIO) %d < %d\\n\", __func__, ret, len);\n\n    }\n\n    return ret;\n\n}\n", "idx": 3691, "_split": "test", "_hash": "f621ed41b3941b2fba413cd4297d1be8"}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static void ppc_spapr_init(ram_addr_t ram_size,\n                           const char *boot_device,\n                           const char *kernel_filename,\n                           const char *kernel_cmdline,\n                           const char *initrd_filename,\n                           const char *cpu_model)\n{\n    PowerPCCPU *cpu;\n    CPUPPCState *env;\n    int i;\n    MemoryRegion *sysmem = get_system_memory();\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n    target_phys_addr_t rma_alloc_size, rma_size;\n    uint32_t initrd_base = 0;\n    long kernel_size = 0, initrd_size = 0;\n    long load_limit, rtas_limit, fw_size;\n    long pteg_shift = 17;\n    char *filename;\n    spapr = g_malloc0(sizeof(*spapr));\n    QLIST_INIT(&spapr->phbs);\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n    /* Allocate RMA if necessary */\n    rma_alloc_size = kvmppc_alloc_rma(\"ppc_spapr.rma\", sysmem);\n    if (rma_alloc_size == -1) {\n        hw_error(\"qemu: Unable to create RMA\\n\");\n        exit(1);\n    }\n    if (rma_alloc_size && (rma_alloc_size < ram_size)) {\n        rma_size = rma_alloc_size;\n    } else {\n        rma_size = ram_size;\n    }\n    /* We place the device tree and RTAS just below either the top of the RMA,\n     * or just below 2GB, whichever is lowere, so that it can be\n     * processed with 32-bit real mode code if necessary */\n    rtas_limit = MIN(rma_size, 0x80000000);\n    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;\n    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;\n    load_limit = spapr->fdt_addr - FW_OVERHEAD;\n    /* init CPUs */\n    if (cpu_model == NULL) {\n        cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n    }\n    for (i = 0; i < smp_cpus; i++) {\n        cpu = cpu_ppc_init(cpu_model);\n        if (cpu == NULL) {\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n            exit(1);\n        }\n        env = &cpu->env;\n        /* Set time-base frequency to 512 MHz */\n        cpu_ppc_tb_init(env, TIMEBASE_FREQ);\n        qemu_register_reset(spapr_cpu_reset, cpu);\n        env->hreset_vector = 0x60;\n        env->hreset_excp_prefix = 0;\n        env->gpr[3] = env->cpu_index;\n    }\n    /* allocate RAM */\n    spapr->ram_limit = ram_size;\n    if (spapr->ram_limit > rma_alloc_size) {\n        ram_addr_t nonrma_base = rma_alloc_size;\n        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;\n        memory_region_init_ram(ram, \"ppc_spapr.ram\", nonrma_size);\n        vmstate_register_ram_global(ram);\n        memory_region_add_subregion(sysmem, nonrma_base, ram);\n    }\n    /* allocate hash page table.  For now we always make this 16mb,\n     * later we should probably make it scale to the size of guest\n     * RAM */\n    spapr->htab_size = 1ULL << (pteg_shift + 7);\n    spapr->htab = qemu_memalign(spapr->htab_size, spapr->htab_size);\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n        env->external_htab = spapr->htab;\n        env->htab_base = -1;\n        env->htab_mask = spapr->htab_size - 1;\n        /* Tell KVM that we're in PAPR mode */\n        env->spr[SPR_SDR1] = (unsigned long)spapr->htab |\n                             ((pteg_shift + 7) - 18);\n        env->spr[SPR_HIOR] = 0;\n        if (kvm_enabled()) {\n            kvmppc_set_papr(env);\n        }\n    }\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\n                                           rtas_limit - spapr->rtas_addr);\n    if (spapr->rtas_size < 0) {\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n        exit(1);\n    }\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n        hw_error(\"RTAS too big ! 0x%lx bytes (max is 0x%x)\\n\",\n                 spapr->rtas_size, RTAS_MAX_SIZE);\n        exit(1);\n    }\n    g_free(filename);\n    /* Set up Interrupt Controller */\n    spapr->icp = xics_system_init(XICS_IRQS);\n    spapr->next_irq = 16;\n    /* Set up VIO bus */\n    spapr->vio_bus = spapr_vio_bus_init();\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n        if (serial_hds[i]) {\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n        }\n    }\n    /* Set up PCI */\n    spapr_create_phb(spapr, \"pci\", SPAPR_PCI_BUID,\n                     SPAPR_PCI_MEM_WIN_ADDR,\n                     SPAPR_PCI_MEM_WIN_SIZE,\n                     SPAPR_PCI_IO_WIN_ADDR);\n    for (i = 0; i < nb_nics; i++) {\n        NICInfo *nd = &nd_table[i];\n        if (!nd->model) {\n            nd->model = g_strdup(\"ibmveth\");\n        }\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n            spapr_vlan_create(spapr->vio_bus, nd);\n        } else {\n            pci_nic_init_nofail(&nd_table[i], nd->model, NULL);\n        }\n    }\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n        spapr_vscsi_create(spapr->vio_bus);\n    }\n    if (rma_size < (MIN_RMA_SLOF << 20)) {\n        fprintf(stderr, \"qemu: pSeries SLOF firmware requires >= \"\n                \"%ldM guest RMA (Real Mode Area memory)\\n\", MIN_RMA_SLOF);\n        exit(1);\n    }\n    fprintf(stderr, \"sPAPR memory map:\\n\");\n    fprintf(stderr, \"RTAS                 : 0x%08lx..%08lx\\n\",\n            (unsigned long)spapr->rtas_addr,\n            (unsigned long)(spapr->rtas_addr + spapr->rtas_size - 1));\n    fprintf(stderr, \"FDT                  : 0x%08lx..%08lx\\n\",\n            (unsigned long)spapr->fdt_addr,\n            (unsigned long)(spapr->fdt_addr + FDT_MAX_SIZE - 1));\n    if (kernel_filename) {\n        uint64_t lowaddr = 0;\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n        if (kernel_size < 0) {\n            kernel_size = load_image_targphys(kernel_filename,\n                                              KERNEL_LOAD_ADDR,\n                                              load_limit - KERNEL_LOAD_ADDR);\n        }\n        if (kernel_size < 0) {\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n                    kernel_filename);\n            exit(1);\n        }\n        fprintf(stderr, \"Kernel               : 0x%08x..%08lx\\n\",\n                KERNEL_LOAD_ADDR, KERNEL_LOAD_ADDR + kernel_size - 1);\n        /* load initrd */\n        if (initrd_filename) {\n            /* Try to locate the initrd in the gap between the kernel\n             * and the firmware. Add a bit of space just in case\n             */\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n                                              load_limit - initrd_base);\n            if (initrd_size < 0) {\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n                        initrd_filename);\n                exit(1);\n            }\n            fprintf(stderr, \"Ramdisk              : 0x%08lx..%08lx\\n\",\n                    (long)initrd_base, (long)(initrd_base + initrd_size - 1));\n        } else {\n            initrd_base = 0;\n            initrd_size = 0;\n        }\n    }\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, FW_FILE_NAME);\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n    if (fw_size < 0) {\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n        exit(1);\n    }\n    g_free(filename);\n    fprintf(stderr, \"Firmware load        : 0x%08x..%08lx\\n\",\n            0, fw_size);\n    fprintf(stderr, \"Firmware runtime     : 0x%08lx..%08lx\\n\",\n            load_limit, (unsigned long)spapr->fdt_addr);\n    spapr->entry_point = 0x100;\n    /* SLOF will startup the secondary CPUs using RTAS */\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n        env->halted = 1;\n    }\n    /* Prepare the device tree */\n    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, rma_size,\n                                            initrd_base, initrd_size,\n                                            kernel_size,\n                                            boot_device, kernel_cmdline,\n                                            pteg_shift + 7);\n    assert(spapr->fdt_skel != NULL);\n    qemu_register_reset(spapr_reset, spapr);\n}", "idx": 3731, "_split": "test", "_hash": "70aa1ec96ef2ef886d6e0936ea40ecdb"}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)\n\n{\n\n    int bits = 8, sign = 0, shift = 0;\n\n\n\n    switch (as->fmt) {\n\n    case AUD_FMT_S8:\n\n        sign = 1;\n\n    case AUD_FMT_U8:\n\n        break;\n\n\n\n    case AUD_FMT_S16:\n\n        sign = 1;\n\n    case AUD_FMT_U16:\n\n        bits = 16;\n\n        shift = 1;\n\n        break;\n\n\n\n    case AUD_FMT_S32:\n\n        sign = 1;\n\n    case AUD_FMT_U32:\n\n        bits = 32;\n\n        shift = 2;\n\n        break;\n\n    }\n\n\n\n    info->freq = as->freq;\n\n    info->bits = bits;\n\n    info->sign = sign;\n\n    info->nchannels = as->nchannels;\n\n    info->shift = (as->nchannels == 2) + shift;\n\n    info->align = (1 << info->shift) - 1;\n\n    info->bytes_per_second = info->freq << info->shift;\n\n    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);\n\n}\n", "idx": 3755, "_split": "test", "_hash": "4db18eb2a6cd31b2b8e8a50ac51ac103"}
{"project": "qemu", "commit_id": "4fb588e95bacb770746cc794ef165fd71a4d27ea", "target": 0, "func": "static void block_job_completed_txn_abort(BlockJob *job)\n\n{\n\n    AioContext *ctx;\n\n    BlockJobTxn *txn = job->txn;\n\n    BlockJob *other_job, *next;\n\n\n\n    if (txn->aborting) {\n\n        /*\n\n         * We are cancelled by another job, which will handle everything.\n\n         */\n\n        return;\n\n    }\n\n    txn->aborting = true;\n\n    /* We are the first failed job. Cancel other jobs. */\n\n    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {\n\n        ctx = blk_get_aio_context(other_job->blk);\n\n        aio_context_acquire(ctx);\n\n    }\n\n    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {\n\n        if (other_job == job || other_job->completed) {\n\n            /* Other jobs are \"effectively\" cancelled by us, set the status for\n\n             * them; this job, however, may or may not be cancelled, depending\n\n             * on the caller, so leave it. */\n\n            if (other_job != job) {\n\n                block_job_cancel_async(other_job);\n\n            }\n\n            continue;\n\n        }\n\n        block_job_cancel_sync(other_job);\n\n        assert(other_job->completed);\n\n    }\n\n    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {\n\n        ctx = blk_get_aio_context(other_job->blk);\n\n        block_job_completed_single(other_job);\n\n        aio_context_release(ctx);\n\n    }\n\n}\n", "idx": 3763, "_split": "test", "_hash": "5ceb1bc4733d438d12644a4d58fcc636"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)\n\n{\n\n    memory_region_init_io(mr, &isa_mmio_ops, NULL, \"isa-mmio\", size);\n\n}\n", "idx": 3766, "_split": "test", "_hash": "201963774bde5992146f8f91013bbda9"}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,\n\n                                  SocketAddressLegacy *localAddr,\n\n                                  SocketAddressLegacy *remoteAddr,\n\n                                  Error **errp)\n\n{\n\n    int fd;\n\n\n\n    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);\n\n    fd = socket_dgram(remoteAddr, localAddr, errp);\n\n    if (fd < 0) {\n\n        trace_qio_channel_socket_dgram_fail(ioc);\n\n        return -1;\n\n    }\n\n\n\n    trace_qio_channel_socket_dgram_complete(ioc, fd);\n\n    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3770, "_split": "test", "_hash": "e30d2be5568e9509ce62efe56403e5c9"}
{"project": "qemu", "commit_id": "bb3cb951ef530da7d248051347c974e4d20e6ea0", "target": 0, "func": "static void dec_bit(DisasContext *dc)\n\n{\n\n    TCGv t0, t1;\n\n    unsigned int op;\n\n    int mem_index = cpu_mmu_index(dc->env);\n\n\n\n    op = dc->ir & ((1 << 9) - 1);\n\n    switch (op) {\n\n        case 0x21:\n\n            /* src.  */\n\n            t0 = tcg_temp_new();\n\n\n\n            LOG_DIS(\"src r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);\n\n            if (dc->rd) {\n\n                t1 = tcg_temp_new();\n\n                read_carry(dc, t1);\n\n                tcg_gen_shli_tl(t1, t1, 31);\n\n\n\n                tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);\n\n                tcg_gen_or_tl(cpu_R[dc->rd], cpu_R[dc->rd], t1);\n\n                tcg_temp_free(t1);\n\n            }\n\n\n\n            /* Update carry.  */\n\n            write_carry(dc, t0);\n\n            tcg_temp_free(t0);\n\n            break;\n\n\n\n        case 0x1:\n\n        case 0x41:\n\n            /* srl.  */\n\n            t0 = tcg_temp_new();\n\n            LOG_DIS(\"srl r%d r%d\\n\", dc->rd, dc->ra);\n\n\n\n            /* Update carry.  */\n\n            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);\n\n            write_carry(dc, t0);\n\n            tcg_temp_free(t0);\n\n            if (dc->rd) {\n\n                if (op == 0x41)\n\n                    tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);\n\n                else\n\n                    tcg_gen_sari_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);\n\n            }\n\n            break;\n\n        case 0x60:\n\n            LOG_DIS(\"ext8s r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_ext8s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            break;\n\n        case 0x61:\n\n            LOG_DIS(\"ext16s r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_ext16s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            break;\n\n        case 0x64:\n\n        case 0x66:\n\n        case 0x74:\n\n        case 0x76:\n\n            /* wdc.  */\n\n            LOG_DIS(\"wdc r%d\\n\", dc->ra);\n\n            if ((dc->tb_flags & MSR_EE_FLAG)\n\n                 && mem_index == MMU_USER_IDX) {\n\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);\n\n                t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n                return;\n\n            }\n\n            break;\n\n        case 0x68:\n\n            /* wic.  */\n\n            LOG_DIS(\"wic r%d\\n\", dc->ra);\n\n            if ((dc->tb_flags & MSR_EE_FLAG)\n\n                 && mem_index == MMU_USER_IDX) {\n\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);\n\n                t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n                return;\n\n            }\n\n            break;\n\n        case 0xe0:\n\n            if ((dc->tb_flags & MSR_EE_FLAG)\n\n                && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)\n\n                && !((dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) {\n\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);\n\n                t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n            }\n\n            if (dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR) {\n\n                gen_helper_clz(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            }\n\n            break;\n\n        case 0x1e0:\n\n            /* swapb */\n\n            LOG_DIS(\"swapb r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_bswap32_i32(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            break;\n\n        case 0x1e2:\n\n            /*swaph */\n\n            LOG_DIS(\"swaph r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_rotri_i32(cpu_R[dc->rd], cpu_R[dc->ra], 16);\n\n            break;\n\n        default:\n\n            cpu_abort(dc->env, \"unknown bit oc=%x op=%x rd=%d ra=%d rb=%d\\n\",\n\n                     dc->pc, op, dc->rd, dc->ra, dc->rb);\n\n            break;\n\n    }\n\n}\n", "idx": 3778, "_split": "test", "_hash": "aec42cb7899e39506a227b12f887c7f1"}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "int memory_region_get_fd(MemoryRegion *mr)\n\n{\n\n    if (mr->alias) {\n\n        return memory_region_get_fd(mr->alias);\n\n    }\n\n\n\n    assert(mr->terminates);\n\n\n\n    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);\n\n}\n", "idx": 3795, "_split": "test", "_hash": "7766e1f21e2b215ad4b3a2fc46d28037"}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,\n\n                              TCGReg r1, TCGReg r2, TCGReg rn,\n\n                              tcg_target_long ofs, bool pre, bool w)\n\n{\n\n    insn |= 1u << 31; /* ext */\n\n    insn |= pre << 24;\n\n    insn |= w << 23;\n\n\n\n    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);\n\n    insn |= (ofs & (0x7f << 3)) << (15 - 3);\n\n\n\n    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);\n\n}\n", "idx": 3811, "_split": "test", "_hash": "b87a6d5fb52fd3a2e42ef3b461a54537"}
{"project": "qemu", "commit_id": "2e84849aa2cc7f220d3b3668f5f7e3c57bb1b590", "target": 0, "func": "static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,\n\n                                   const char *name, Error **errp)\n\n{\n\n    X86CPU *cpu = X86_CPU(obj);\n\n    const int64_t min = 0;\n\n    const int64_t max = INT_MAX;\n\n    int64_t value;\n\n\n\n    visit_type_int(v, &value, name, errp);\n\n    if (error_is_set(errp)) {\n\n        return;\n\n    }\n\n    if (value < min || value > max) {\n\n        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, \"\",\n\n                  name ? name : \"null\", value, min, max);\n\n        return;\n\n    }\n\n\n\n    cpu->env.tsc_khz = value / 1000;\n\n}\n", "idx": 3815, "_split": "test", "_hash": "5a6cc94b7999dfaab9e7945324860782"}
{"project": "qemu", "commit_id": "6764579f894950afe87d8ec3b323adde8925d4fd", "target": 1, "func": "static int cow_create(const char *filename, QemuOpts *opts, Error **errp)\n\n{\n\n    struct cow_header_v2 cow_header;\n\n    struct stat st;\n\n    int64_t image_sectors = 0;\n\n    char *image_filename = NULL;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n    BlockDriverState *cow_bs;\n\n\n\n    /* Read out options */\n\n    image_sectors = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0) / 512;\n\n    image_filename = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);\n\n\n\n    ret = bdrv_create_file(filename, opts, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto exit;\n\n    }\n\n\n\n    cow_bs = NULL;\n\n    ret = bdrv_open(&cow_bs, filename, NULL, NULL,\n\n                    BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto exit;\n\n    }\n\n\n\n    memset(&cow_header, 0, sizeof(cow_header));\n\n    cow_header.magic = cpu_to_be32(COW_MAGIC);\n\n    cow_header.version = cpu_to_be32(COW_VERSION);\n\n    if (image_filename) {\n\n        /* Note: if no file, we put a dummy mtime */\n\n        cow_header.mtime = cpu_to_be32(0);\n\n\n\n        if (stat(image_filename, &st) != 0) {\n\n            goto mtime_fail;\n\n        }\n\n        cow_header.mtime = cpu_to_be32(st.st_mtime);\n\n    mtime_fail:\n\n        pstrcpy(cow_header.backing_file, sizeof(cow_header.backing_file),\n\n                image_filename);\n\n    }\n\n    cow_header.sectorsize = cpu_to_be32(512);\n\n    cow_header.size = cpu_to_be64(image_sectors * 512);\n\n    ret = bdrv_pwrite(cow_bs, 0, &cow_header, sizeof(cow_header));\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\n    /* resize to include at least all the bitmap */\n\n    ret = bdrv_truncate(cow_bs,\n\n        sizeof(cow_header) + ((image_sectors + 7) >> 3));\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\nexit:\n\n    g_free(image_filename);\n\n    bdrv_unref(cow_bs);\n\n    return ret;\n\n}\n", "idx": 3824, "_split": "test", "_hash": "ce71a4203d44ec1c27a7e7851c51fa89"}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_move_mr(DisasContext *dc)\n\n{\n\n\tint memsize = memsize_zz(dc);\n\n\tint insn_len;\n\n\tDIS(fprintf (logfile, \"move.%c [$r%u%s, $r%u\\n\",\n\n\t\t    memsize_char(memsize),\n\n\t\t    dc->op1, dc->postinc ? \"+]\" : \"]\",\n\n\t\t    dc->op2));\n\n\n\n\tif (memsize == 4) {\n\n\t\tinsn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);\n\n\t\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\t\tcris_update_cc_op(dc, CC_OP_MOVE, 4);\n\n\t\tcris_update_cc_x(dc);\n\n\t\tcris_update_result(dc, cpu_R[dc->op2]);\n\n\t}\n\n\telse {\n\n\t\tTCGv t0;\n\n\n\n\t\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tinsn_len = dec_prep_move_m(dc, 0, memsize, t0);\n\n\t\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\t\tcris_alu(dc, CC_OP_MOVE,\n\n\t\t\t    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);\n\n\t\ttcg_temp_free(t0);\n\n\t}\n\n\tdo_postinc(dc, memsize);\n\n\treturn insn_len;\n\n}\n", "idx": 3834, "_split": "test", "_hash": "2fce83277e18ac6313436dbb5f661af7"}
{"project": "qemu", "commit_id": "048c74c4379789d03c857cea038ec00d95b68eaf", "target": 0, "func": "static int rtc_initfn(ISADevice *dev)\n\n{\n\n    RTCState *s = DO_UPCAST(RTCState, dev, dev);\n\n    int base = 0x70;\n\n    int isairq = 8;\n\n\n\n    isa_init_irq(dev, &s->irq, isairq);\n\n\n\n    s->cmos_data[RTC_REG_A] = 0x26;\n\n    s->cmos_data[RTC_REG_B] = 0x02;\n\n    s->cmos_data[RTC_REG_C] = 0x00;\n\n    s->cmos_data[RTC_REG_D] = 0x80;\n\n\n\n    rtc_set_date_from_host(s);\n\n\n\n    s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s);\n\n#ifdef TARGET_I386\n\n    if (rtc_td_hack)\n\n        s->coalesced_timer =\n\n            qemu_new_timer(rtc_clock, rtc_coalesced_timer, s);\n\n#endif\n\n    s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s);\n\n    s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s);\n\n\n\n    s->next_second_time =\n\n        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;\n\n    qemu_mod_timer(s->second_timer2, s->next_second_time);\n\n\n\n    register_ioport_write(base, 2, 1, cmos_ioport_write, s);\n\n    register_ioport_read(base, 2, 1, cmos_ioport_read, s);\n\n\n\n    register_savevm(\"mc146818rtc\", base, 1, rtc_save, rtc_load, s);\n\n#ifdef TARGET_I386\n\n    if (rtc_td_hack)\n\n        register_savevm(\"mc146818rtc-td\", base, 1, rtc_save_td, rtc_load_td, s);\n\n#endif\n\n    qemu_register_reset(rtc_reset, s);\n\n    return 0;\n\n}\n", "idx": 3838, "_split": "test", "_hash": "fcff18bd18e50958775c7b8d57712868"}
{"project": "qemu", "commit_id": "1f8828ef573c83365b4a87a776daf8bcef1caa21", "target": 0, "func": "static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    VirtIONet *n = opaque;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n\n\n    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)\n\n        return -EINVAL;\n\n\n\n    return virtio_load(vdev, f, version_id);\n\n}\n", "idx": 3845, "_split": "test", "_hash": "c3533fe29f941f747dcf88e8640ab181"}
{"project": "qemu", "commit_id": "9f1963b3f72521f75a549f8afd61b19e7da63c6f", "target": 0, "func": "static int coroutine_fn raw_co_discard(BlockDriverState *bs,\n\n                                       int64_t sector_num, int nb_sectors)\n\n{\n\n    return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);\n\n}\n", "idx": 3920, "_split": "test", "_hash": "411dcc26448a741a3a38889f12b1e4da"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,\n\n        BlockCompletionFunc *cb, void *opaque)\n\n{\n\n    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);\n\n\n\n    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,\n\n                                 BDRV_REQ_ZERO_WRITE | flags,\n\n                                 cb, opaque, true);\n\n}\n", "idx": 3924, "_split": "test", "_hash": "c78d8f2a1e9eec4121105870d6d7efb6"}
{"project": "qemu", "commit_id": "25db9ebe15125deb32958c6df74996f745edf1f9", "target": 0, "func": "static void virtio_pci_reset(DeviceState *d)\n\n{\n\n    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);\n\n    virtio_reset(proxy->vdev);\n\n    msix_reset(&proxy->pci_dev);\n\n    proxy->flags = 0;\n\n}\n", "idx": 3926, "_split": "test", "_hash": "2c9d487e46bcf0fb8f119997be4cf9dc"}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,\n\n                            TCGReg dst, TCGReg lhs, TCGArg rhs,\n\n                            bool rhs_is_const)\n\n{\n\n    /* Emit either the reg,imm or reg,reg form of a data-processing insn.\n\n     * rhs must satisfy the \"rIK\" constraint.\n\n     */\n\n    if (rhs_is_const) {\n\n        int rot = encode_imm(rhs);\n\n        if (rot < 0) {\n\n            rhs = ~rhs;\n\n            rot = encode_imm(rhs);\n\n            assert(rot >= 0);\n\n            opc = opinv;\n\n        }\n\n        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));\n\n    } else {\n\n        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));\n\n    }\n\n}\n", "idx": 3933, "_split": "test", "_hash": "1351fca14e85adf12b412ba2965a21b5"}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static int twl92230_init(i2c_slave *i2c)\n\n{\n\n    MenelausState *s = FROM_I2C_SLAVE(MenelausState, i2c);\n\n\n\n    s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s);\n\n    /* Three output pins plus one interrupt pin.  */\n\n    qdev_init_gpio_out(&i2c->qdev, s->out, 4);\n\n    qdev_init_gpio_in(&i2c->qdev, menelaus_gpio_set, 3);\n\n    s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0];\n\n\n\n    menelaus_reset(&s->i2c);\n\n\n\n    return 0;\n\n}\n", "idx": 3946, "_split": "test", "_hash": "53c583a39a99bfc2fd913d5d4364df8f"}
{"project": "qemu", "commit_id": "b835e919f022d768abdf00e8dc94f1a23fdcab15", "target": 1, "func": "static void gen_st_cond (DisasContext *ctx, uint32_t opc, int rt,\n\n                         int base, int16_t offset)\n\n{\n\n    const char *opn = \"st_cond\";\n\n    TCGv t0, t1;\n\n\n\n    t0 = tcg_temp_local_new();\n\n\n\n    gen_base_offset_addr(ctx, t0, base, offset);\n\n    /* Don't do NOP if destination is zero: we must perform the actual\n\n       memory access. */\n\n\n\n    t1 = tcg_temp_local_new();\n\n    gen_load_gpr(t1, rt);\n\n    switch (opc) {\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_SCD:\n\n        save_cpu_state(ctx, 0);\n\n        op_st_scd(t1, t0, rt, ctx);\n\n        opn = \"scd\";\n\n        break;\n\n#endif\n\n    case OPC_SC:\n\n        save_cpu_state(ctx, 1);\n\n        op_st_sc(t1, t0, rt, ctx);\n\n        opn = \"sc\";\n\n        break;\n\n    }\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %d(%s)\", opn, regnames[rt], offset, regnames[base]);\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(t0);\n\n}\n", "idx": 3960, "_split": "test", "_hash": "a9de81cbe67d847ed3dc6dee677f8821"}
{"project": "qemu", "commit_id": "a718978ed58abc1ad92567a9c17525136be02a71", "target": 1, "func": "static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write)\n\n{\n\n    BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);\n\n    IDEState *s = bmdma_active_if(bm);\n\n    PCIDevice *pci_dev = PCI_DEVICE(bm->pci_dev);\n\n    struct {\n\n        uint32_t addr;\n\n        uint32_t size;\n\n    } prd;\n\n    int l, len;\n\n\n\n    pci_dma_sglist_init(&s->sg, pci_dev,\n\n                        s->nsector / (BMDMA_PAGE_SIZE / 512) + 1);\n\n    s->io_buffer_size = 0;\n\n    for(;;) {\n\n        if (bm->cur_prd_len == 0) {\n\n            /* end of table (with a fail safe of one page) */\n\n            if (bm->cur_prd_last ||\n\n                (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE) {\n\n                return s->io_buffer_size;\n\n            }\n\n            pci_dma_read(pci_dev, bm->cur_addr, &prd, 8);\n\n            bm->cur_addr += 8;\n\n            prd.addr = le32_to_cpu(prd.addr);\n\n            prd.size = le32_to_cpu(prd.size);\n\n            len = prd.size & 0xfffe;\n\n            if (len == 0)\n\n                len = 0x10000;\n\n            bm->cur_prd_len = len;\n\n            bm->cur_prd_addr = prd.addr;\n\n            bm->cur_prd_last = (prd.size & 0x80000000);\n\n        }\n\n        l = bm->cur_prd_len;\n\n        if (l > 0) {\n\n            qemu_sglist_add(&s->sg, bm->cur_prd_addr, l);\n\n\n\n            /* Note: We limit the max transfer to be 2GiB.\n\n             * This should accommodate the largest ATA transaction\n\n             * for LBA48 (65,536 sectors) and 32K sector sizes. */\n\n            if (s->sg.size > INT32_MAX) {\n\n                error_report(\"IDE: sglist describes more than 2GiB.\");\n\n                break;\n\n            }\n\n            bm->cur_prd_addr += l;\n\n            bm->cur_prd_len -= l;\n\n            s->io_buffer_size += l;\n\n        }\n\n    }\n\n\n\n    qemu_sglist_destroy(&s->sg);\n\n    s->io_buffer_size = 0;\n\n    return -1;\n\n}\n", "idx": 3970, "_split": "test", "_hash": "e6b3927288354fd4cb23d8d50750f420"}
{"project": "qemu", "commit_id": "591b320ad046b2780c1b2841b836b50ba8192f02", "target": 1, "func": "static inline int popcountl(unsigned long l)\n\n{\n\n    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);\n\n}\n", "idx": 3977, "_split": "test", "_hash": "1037688a49aff8dc1db84b4fb433db1a"}
{"project": "qemu", "commit_id": "c641483fbe0aa08cd7c0580d019dc2d5a7e71138", "target": 1, "func": "static inline void ide_dma_submit_check(IDEState *s,\n\n          BlockDriverCompletionFunc *dma_cb)\n\n{\n\n    if (s->bus->dma->aiocb)\n\n\treturn;\n\n    dma_cb(s, -1);\n\n}\n", "idx": 3988, "_split": "test", "_hash": "a4d1eaec0b544a428beeae1a6730732a"}
{"project": "qemu", "commit_id": "d3c8c67469ee70fcae116d5abc277a7ebc8a19fd", "target": 1, "func": "static BlockStats *bdrv_query_bds_stats(const BlockDriverState *bs,\n\n                                 bool query_backing)\n\n{\n\n    BlockStats *s = NULL;\n\n\n\n    s = g_malloc0(sizeof(*s));\n\n    s->stats = g_malloc0(sizeof(*s->stats));\n\n\n\n    if (!bs) {\n\n        return s;\n\n    }\n\n\n\n    if (bdrv_get_node_name(bs)[0]) {\n\n        s->has_node_name = true;\n\n        s->node_name = g_strdup(bdrv_get_node_name(bs));\n\n    }\n\n\n\n    s->stats->wr_highest_offset = stat64_get(&bs->wr_highest_offset);\n\n\n\n    if (bs->file) {\n\n        s->has_parent = true;\n\n        s->parent = bdrv_query_bds_stats(bs->file->bs, query_backing);\n\n    }\n\n\n\n    if (query_backing && bs->backing) {\n\n        s->has_backing = true;\n\n        s->backing = bdrv_query_bds_stats(bs->backing->bs, query_backing);\n\n    }\n\n\n\n    return s;\n\n}\n", "idx": 4006, "_split": "test", "_hash": "184aee6d6fd1ab8073f0d4ab30bd43af"}
{"project": "qemu", "commit_id": "84593a0807004d852132eaa56edf24d55793d480", "target": 1, "func": "static int ram_init_all(RAMState **rsp)\n\n{\n\n    Error *local_err = NULL;\n\n\n\n    if (ram_state_init(rsp)) {\n\n        return -1;\n\n    }\n\n\n\n    if (migrate_use_xbzrle()) {\n\n        XBZRLE_cache_lock();\n\n        XBZRLE.zero_target_page = g_malloc0(TARGET_PAGE_SIZE);\n\n        XBZRLE.cache = cache_init(migrate_xbzrle_cache_size(),\n\n                                  TARGET_PAGE_SIZE, &local_err);\n\n        if (!XBZRLE.cache) {\n\n            XBZRLE_cache_unlock();\n\n            error_report_err(local_err);\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n        XBZRLE_cache_unlock();\n\n\n\n        /* We prefer not to abort if there is no memory */\n\n        XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE);\n\n        if (!XBZRLE.encoded_buf) {\n\n            error_report(\"Error allocating encoded_buf\");\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n\n\n        XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE);\n\n        if (!XBZRLE.current_buf) {\n\n            error_report(\"Error allocating current_buf\");\n\n            g_free(XBZRLE.encoded_buf);\n\n            XBZRLE.encoded_buf = NULL;\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* For memory_global_dirty_log_start below.  */\n\n    qemu_mutex_lock_iothread();\n\n\n\n    qemu_mutex_lock_ramlist();\n\n    rcu_read_lock();\n\n\n\n    /* Skip setting bitmap if there is no RAM */\n\n    if (ram_bytes_total()) {\n\n        RAMBlock *block;\n\n\n\n        QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n\n            unsigned long pages = block->max_length >> TARGET_PAGE_BITS;\n\n\n\n            block->bmap = bitmap_new(pages);\n\n            bitmap_set(block->bmap, 0, pages);\n\n            if (migrate_postcopy_ram()) {\n\n                block->unsentmap = bitmap_new(pages);\n\n                bitmap_set(block->unsentmap, 0, pages);\n\n            }\n\n        }\n\n    }\n\n\n\n    memory_global_dirty_log_start();\n\n    migration_bitmap_sync(*rsp);\n\n    qemu_mutex_unlock_ramlist();\n\n    qemu_mutex_unlock_iothread();\n\n    rcu_read_unlock();\n\n\n\n    return 0;\n\n}\n", "idx": 4017, "_split": "test", "_hash": "5651569b2b406a512ab93841c6ad08c5"}
{"project": "qemu", "commit_id": "14fe292d86da90b79e2fb56a4986d27346339a00", "target": 1, "func": "void qed_commit_l2_cache_entry(L2TableCache *l2_cache, CachedL2Table *l2_table)\n\n{\n\n    CachedL2Table *entry;\n\n\n\n    entry = qed_find_l2_cache_entry(l2_cache, l2_table->offset);\n\n    if (entry) {\n\n        qed_unref_l2_cache_entry(entry);\n\n        qed_unref_l2_cache_entry(l2_table);\n\n        return;\n\n    }\n\n\n\n    if (l2_cache->n_entries >= MAX_L2_CACHE_SIZE) {\n\n        entry = QTAILQ_FIRST(&l2_cache->entries);\n\n        QTAILQ_REMOVE(&l2_cache->entries, entry, node);\n\n        l2_cache->n_entries--;\n\n        qed_unref_l2_cache_entry(entry);\n\n    }\n\n\n\n    l2_cache->n_entries++;\n\n    QTAILQ_INSERT_TAIL(&l2_cache->entries, l2_table, node);\n\n}\n", "idx": 4080, "_split": "test", "_hash": "e2fb0d004a6841857b30e9d847fbe657"}
{"project": "qemu", "commit_id": "d44168fffa07fc57e61a37da65e9348661dec887", "target": 1, "func": "static USBDevice *usb_net_init(const char *cmdline)\n\n{\n\n    USBDevice *dev;\n\n    QemuOpts *opts;\n\n    int idx;\n\n\n\n    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);\n\n    if (!opts) {\n\n\n\n    qemu_opt_set(opts, \"type\", \"nic\");\n\n    qemu_opt_set(opts, \"model\", \"usb\");\n\n\n\n    idx = net_client_init(NULL, opts, 0);\n\n    if (idx == -1) {\n\n\n\n\n\n    dev = usb_create(NULL /* FIXME */, \"usb-net\");\n\n\n\n\n    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);\n\n    qdev_init_nofail(&dev->qdev);\n\n    return dev;\n", "idx": 4093, "_split": "test", "_hash": "8b62f5b31c4cf7c26f4fd11ef52986c3"}
{"project": "qemu", "commit_id": "d20a580bc0eac9d489884f6d2ed28105880532b6", "target": 0, "func": "static void handle_mousewheel(SDL_Event *ev)\n\n{\n\n    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);\n\n    SDL_MouseWheelEvent *wev = &ev->wheel;\n\n    InputButton btn;\n\n\n\n    if (wev->y > 0) {\n\n        btn = INPUT_BUTTON_WHEEL_UP;\n\n    } else if (wev->y < 0) {\n\n        btn = INPUT_BUTTON_WHEEL_DOWN;\n\n    } else {\n\n        return;\n\n    }\n\n\n\n    qemu_input_queue_btn(scon->dcl.con, btn, true);\n\n    qemu_input_event_sync();\n\n    qemu_input_queue_btn(scon->dcl.con, btn, false);\n\n    qemu_input_event_sync();\n\n}\n", "idx": 4104, "_split": "test", "_hash": "3a7f845582af42b5ef4dadd1711538dc"}
{"project": "qemu", "commit_id": "0c0eb30260b424d2a68603b89f1d829db18772c2", "target": 1, "func": "static void init_virtio_dev(TestServer *s)\n\n{\n\n    QPCIBus *bus;\n\n    QVirtioPCIDevice *dev;\n\n    uint32_t features;\n\n\n\n    bus = qpci_init_pc(NULL);\n\n    g_assert_nonnull(bus);\n\n\n\n    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);\n\n    g_assert_nonnull(dev);\n\n\n\n    qvirtio_pci_device_enable(dev);\n\n    qvirtio_reset(&dev->vdev);\n\n    qvirtio_set_acknowledge(&dev->vdev);\n\n    qvirtio_set_driver(&dev->vdev);\n\n\n\n    features = qvirtio_get_features(&dev->vdev);\n\n    features = features & VIRTIO_NET_F_MAC;\n\n    qvirtio_set_features(&dev->vdev, features);\n\n\n\n    qvirtio_set_driver_ok(&dev->vdev);\n\n}\n", "idx": 4141, "_split": "test", "_hash": "55a2b7d5bd67596e7fc63e071d098cd3"}
{"project": "qemu", "commit_id": "d3ac1a87b228bcd231d19acf1ebe9844b7639237", "target": 1, "func": "static void usb_msd_cancel_io(USBDevice *dev, USBPacket *p)\n\n{\n\n    MSDState *s = DO_UPCAST(MSDState, dev, dev);\n\n    scsi_req_cancel(s->req);\n\n}\n", "idx": 4165, "_split": "test", "_hash": "2fe40523b5ad979fa2f5e6ac14243874"}
{"project": "qemu", "commit_id": "4508d81a788f451c83604e1d0033243e191d71a7", "target": 1, "func": "ram_addr_t ppc405_set_bootinfo (CPUState *env, ppc4xx_bd_info_t *bd,\n\n                                uint32_t flags)\n\n{\n\n    ram_addr_t bdloc;\n\n    int i, n;\n\n\n\n    /* We put the bd structure at the top of memory */\n\n    if (bd->bi_memsize >= 0x01000000UL)\n\n        bdloc = 0x01000000UL - sizeof(struct ppc4xx_bd_info_t);\n\n    else\n\n        bdloc = bd->bi_memsize - sizeof(struct ppc4xx_bd_info_t);\n\n    stl_phys(bdloc + 0x00, bd->bi_memstart);\n\n    stl_phys(bdloc + 0x04, bd->bi_memsize);\n\n    stl_phys(bdloc + 0x08, bd->bi_flashstart);\n\n    stl_phys(bdloc + 0x0C, bd->bi_flashsize);\n\n    stl_phys(bdloc + 0x10, bd->bi_flashoffset);\n\n    stl_phys(bdloc + 0x14, bd->bi_sramstart);\n\n    stl_phys(bdloc + 0x18, bd->bi_sramsize);\n\n    stl_phys(bdloc + 0x1C, bd->bi_bootflags);\n\n    stl_phys(bdloc + 0x20, bd->bi_ipaddr);\n\n    for (i = 0; i < 6; i++)\n\n        stb_phys(bdloc + 0x24 + i, bd->bi_enetaddr[i]);\n\n    stw_phys(bdloc + 0x2A, bd->bi_ethspeed);\n\n    stl_phys(bdloc + 0x2C, bd->bi_intfreq);\n\n    stl_phys(bdloc + 0x30, bd->bi_busfreq);\n\n    stl_phys(bdloc + 0x34, bd->bi_baudrate);\n\n    for (i = 0; i < 4; i++)\n\n        stb_phys(bdloc + 0x38 + i, bd->bi_s_version[i]);\n\n    for (i = 0; i < 32; i++)\n\n        stb_phys(bdloc + 0x3C + i, bd->bi_s_version[i]);\n\n    stl_phys(bdloc + 0x5C, bd->bi_plb_busfreq);\n\n    stl_phys(bdloc + 0x60, bd->bi_pci_busfreq);\n\n    for (i = 0; i < 6; i++)\n\n        stb_phys(bdloc + 0x64 + i, bd->bi_pci_enetaddr[i]);\n\n    n = 0x6A;\n\n    if (flags & 0x00000001) {\n\n        for (i = 0; i < 6; i++)\n\n            stb_phys(bdloc + n++, bd->bi_pci_enetaddr2[i]);\n\n    }\n\n    stl_phys(bdloc + n, bd->bi_opbfreq);\n\n    n += 4;\n\n    for (i = 0; i < 2; i++) {\n\n        stl_phys(bdloc + n, bd->bi_iic_fast[i]);\n\n        n += 4;\n\n    }\n\n\n\n    return bdloc;\n\n}\n", "idx": 4166, "_split": "test", "_hash": "c0c8da6dae70b7b892d6776804960d10"}
{"project": "qemu", "commit_id": "92cb05574b7bd489be81f9c58497dc7dfe5d8859", "target": 0, "func": "bool virtio_ipl_disk_is_valid(void)\n\n{\n\n    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());\n\n}\n", "idx": 4173, "_split": "test", "_hash": "820ec99b309f2a41e6cf005b14e6e60f"}
{"project": "qemu", "commit_id": "c60bf3391bf4cb79b7adc6650094e21671ddaabd", "target": 0, "func": "static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)\n\n{\n\n    BlockDriverState *bs = opaque;\n\n    int ret = 0;\n\n\n\n    if (bdrv_set_key(bs, password) != 0) {\n\n        monitor_printf(mon, \"invalid password\\n\");\n\n        ret = -EPERM;\n\n    }\n\n    if (mon->password_completion_cb)\n\n        mon->password_completion_cb(mon->password_opaque, ret);\n\n\n\n    monitor_read_command(mon, 1);\n\n}\n", "idx": 4178, "_split": "test", "_hash": "c1d43c6a8609fb26313e963a5336665b"}
{"project": "qemu", "commit_id": "e8f1f9db8787be08e0ae3ed5a94da68966dbfff1", "target": 0, "func": "void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)\n\n{\n\n    VLANState *vlan;\n\n    VLANClientState *vc;\n\n\n\n    vlan = qemu_find_vlan(vlan_id);\n\n\n\n   for(vc = vlan->first_client; vc != NULL; vc = vc->next)\n\n        if (!strcmp(vc->name, device))\n\n            break;\n\n\n\n    if (!vc) {\n\n        monitor_printf(mon, \"can't find device %s\\n\", device);\n\n        return;\n\n    }\n\n    qemu_del_vlan_client(vc);\n\n}\n", "idx": 4209, "_split": "test", "_hash": "9b2de62932b1573f1668db4a9c039899"}
{"project": "qemu", "commit_id": "82ca891283a08cddd659b534592fe00f2159bc74", "target": 0, "func": "static void vfio_bar_write(void *opaque, hwaddr addr,\n\n                           uint64_t data, unsigned size)\n\n{\n\n    VFIOBAR *bar = opaque;\n\n    union {\n\n        uint8_t byte;\n\n        uint16_t word;\n\n        uint32_t dword;\n\n        uint64_t qword;\n\n    } buf;\n\n\n\n    switch (size) {\n\n    case 1:\n\n        buf.byte = data;\n\n        break;\n\n    case 2:\n\n        buf.word = cpu_to_le16(data);\n\n        break;\n\n    case 4:\n\n        buf.dword = cpu_to_le32(data);\n\n        break;\n\n    default:\n\n        hw_error(\"vfio: unsupported write size, %d bytes\\n\", size);\n\n        break;\n\n    }\n\n\n\n    if (pwrite(bar->fd, &buf, size, bar->fd_offset + addr) != size) {\n\n        error_report(\"%s(,0x%\"HWADDR_PRIx\", 0x%\"PRIx64\", %d) failed: %m\",\n\n                     __func__, addr, data, size);\n\n    }\n\n\n\n    DPRINTF(\"%s(BAR%d+0x%\"HWADDR_PRIx\", 0x%\"PRIx64\", %d)\\n\",\n\n            __func__, bar->nr, addr, data, size);\n\n\n\n    /*\n\n     * A read or write to a BAR always signals an INTx EOI.  This will\n\n     * do nothing if not pending (including not in INTx mode).  We assume\n\n     * that a BAR access is in response to an interrupt and that BAR\n\n     * accesses will service the interrupt.  Unfortunately, we don't know\n\n     * which access will service the interrupt, so we're potentially\n\n     * getting quite a few host interrupts per guest interrupt.\n\n     */\n\n    vfio_eoi(container_of(bar, VFIODevice, bars[bar->nr]));\n\n}\n", "idx": 4211, "_split": "test", "_hash": "1e48310b9c7aa83bc164f7a650d51c38"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void mcf5208evb_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    CPUM68KState *env;\n\n    int kernel_size;\n\n    uint64_t elf_entry;\n\n    target_phys_addr_t entry;\n\n    qemu_irq *pic;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"m5208\";\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find m68k CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Initialize CPU registers.  */\n\n    env->vbr = 0;\n\n    /* TODO: Configure BARs.  */\n\n\n\n    /* DRAM at 0x40000000 */\n\n    memory_region_init_ram(ram, \"mcf5208.ram\", ram_size);\n\n    vmstate_register_ram_global(ram);\n\n    memory_region_add_subregion(address_space_mem, 0x40000000, ram);\n\n\n\n    /* Internal SRAM.  */\n\n    memory_region_init_ram(sram, \"mcf5208.sram\", 16384);\n\n    vmstate_register_ram_global(sram);\n\n    memory_region_add_subregion(address_space_mem, 0x80000000, sram);\n\n\n\n    /* Internal peripherals.  */\n\n    pic = mcf_intc_init(address_space_mem, 0xfc048000, env);\n\n\n\n    mcf_uart_mm_init(address_space_mem, 0xfc060000, pic[26], serial_hds[0]);\n\n    mcf_uart_mm_init(address_space_mem, 0xfc064000, pic[27], serial_hds[1]);\n\n    mcf_uart_mm_init(address_space_mem, 0xfc068000, pic[28], serial_hds[2]);\n\n\n\n    mcf5208_sys_init(address_space_mem, pic);\n\n\n\n    if (nb_nics > 1) {\n\n        fprintf(stderr, \"Too many NICs\\n\");\n\n        exit(1);\n\n    }\n\n    if (nd_table[0].used)\n\n        mcf_fec_init(address_space_mem, &nd_table[0],\n\n                     0xfc030000, pic + 36);\n\n\n\n    /*  0xfc000000 SCM.  */\n\n    /*  0xfc004000 XBS.  */\n\n    /*  0xfc008000 FlexBus CS.  */\n\n    /* 0xfc030000 FEC.  */\n\n    /*  0xfc040000 SCM + Power management.  */\n\n    /*  0xfc044000 eDMA.  */\n\n    /* 0xfc048000 INTC.  */\n\n    /*  0xfc058000 I2C.  */\n\n    /*  0xfc05c000 QSPI.  */\n\n    /* 0xfc060000 UART0.  */\n\n    /* 0xfc064000 UART0.  */\n\n    /* 0xfc068000 UART0.  */\n\n    /*  0xfc070000 DMA timers.  */\n\n    /* 0xfc080000 PIT0.  */\n\n    /* 0xfc084000 PIT1.  */\n\n    /*  0xfc088000 EPORT.  */\n\n    /*  0xfc08c000 Watchdog.  */\n\n    /*  0xfc090000 clock module.  */\n\n    /*  0xfc0a0000 CCM + reset.  */\n\n    /*  0xfc0a4000 GPIO.  */\n\n    /* 0xfc0a8000 SDRAM controller.  */\n\n\n\n    /* Load kernel.  */\n\n    if (!kernel_filename) {\n\n        fprintf(stderr, \"Kernel image must be specified\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                           NULL, NULL, 1, ELF_MACHINE, 0);\n\n    entry = elf_entry;\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL);\n\n    }\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_image_targphys(kernel_filename, 0x40000000,\n\n                                          ram_size);\n\n        entry = 0x40000000;\n\n    }\n\n    if (kernel_size < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    env->pc = entry;\n\n}\n", "idx": 4213, "_split": "test", "_hash": "ddb7fac39393b84b7d8bb206efb53305"}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)\n\n{\n\n    QObject *token;\n\n    const char *val;\n\n\n\n    if (ap == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    token = parser_context_pop_token(ctxt);\n\n    assert(token && token_get_type(token) == JSON_ESCAPE);\n\n    val = token_get_value(token);\n\n\n\n    if (!strcmp(val, \"%p\")) {\n\n        return va_arg(*ap, QObject *);\n\n    } else if (!strcmp(val, \"%i\")) {\n\n        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));\n\n    } else if (!strcmp(val, \"%d\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, int)));\n\n    } else if (!strcmp(val, \"%ld\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, long)));\n\n    } else if (!strcmp(val, \"%lld\") ||\n\n               !strcmp(val, \"%I64d\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, long long)));\n\n    } else if (!strcmp(val, \"%s\")) {\n\n        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));\n\n    } else if (!strcmp(val, \"%f\")) {\n\n        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));\n\n    }\n\n    return NULL;\n\n}\n", "idx": 4217, "_split": "test", "_hash": "1f864ca85d58a079934b276bd4e98f25"}
{"project": "qemu", "commit_id": "149f54b53b7666a3facd45e86eece60ce7d3b114", "target": 0, "func": "static inline uint64_t ldq_phys_internal(hwaddr addr,\n\n                                         enum device_endian endian)\n\n{\n\n    uint8_t *ptr;\n\n    uint64_t val;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!(memory_region_is_ram(section->mr) ||\n\n          memory_region_is_romd(section->mr))) {\n\n        /* I/O case */\n\n        addr = memory_region_section_addr(section, addr);\n\n\n\n        /* XXX This is broken when device endian != cpu endian.\n\n               Fix and add \"endian\" variable check */\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n        val = io_mem_read(section->mr, addr, 4) << 32;\n\n        val |= io_mem_read(section->mr, addr + 4, 4);\n\n#else\n\n        val = io_mem_read(section->mr, addr, 4);\n\n        val |= io_mem_read(section->mr, addr + 4, 4) << 32;\n\n#endif\n\n    } else {\n\n        /* RAM case */\n\n        ptr = qemu_get_ram_ptr((memory_region_get_ram_addr(section->mr)\n\n                                & TARGET_PAGE_MASK)\n\n                               + memory_region_section_addr(section, addr));\n\n        switch (endian) {\n\n        case DEVICE_LITTLE_ENDIAN:\n\n            val = ldq_le_p(ptr);\n\n            break;\n\n        case DEVICE_BIG_ENDIAN:\n\n            val = ldq_be_p(ptr);\n\n            break;\n\n        default:\n\n            val = ldq_p(ptr);\n\n            break;\n\n        }\n\n    }\n\n    return val;\n\n}\n", "idx": 4218, "_split": "test", "_hash": "aaadefabe43c02cb83d938fd7fc9077f"}
{"project": "qemu", "commit_id": "200668ba0839e664f0e4d0bcdc55ab5a163a418a", "target": 0, "func": "void main_loop_wait(int nonblocking)\n\n{\n\n    fd_set rfds, wfds, xfds;\n\n    int ret, nfds;\n\n    struct timeval tv;\n\n    int timeout;\n\n\n\n    if (nonblocking)\n\n        timeout = 0;\n\n    else {\n\n        timeout = qemu_calculate_timeout();\n\n        qemu_bh_update_timeout(&timeout);\n\n    }\n\n\n\n    os_host_main_loop_wait(&timeout);\n\n\n\n    tv.tv_sec = timeout / 1000;\n\n    tv.tv_usec = (timeout % 1000) * 1000;\n\n\n\n    /* poll any events */\n\n    /* XXX: separate device handlers from system ones */\n\n    nfds = -1;\n\n    FD_ZERO(&rfds);\n\n    FD_ZERO(&wfds);\n\n    FD_ZERO(&xfds);\n\n    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);\n\n    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);\n\n\n\n    qemu_mutex_unlock_iothread();\n\n    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);\n\n    qemu_mutex_lock_iothread();\n\n\n\n    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);\n\n    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));\n\n\n\n    qemu_run_all_timers();\n\n\n\n    /* Check bottom-halves last in case any of the earlier events triggered\n\n       them.  */\n\n    qemu_bh_poll();\n\n\n\n}\n", "idx": 4221, "_split": "test", "_hash": "24aba48d5bb9ddc94c98f94f86a81f07"}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "void bdrv_invalidate_cache_all(Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    Error *local_err = NULL;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    while ((it = bdrv_next(it, &bs)) != NULL) {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        aio_context_acquire(aio_context);\n\n        bdrv_invalidate_cache(bs, &local_err);\n\n        aio_context_release(aio_context);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 4253, "_split": "test", "_hash": "139820edc0572a6bc4d00fc3dd5296da"}
{"project": "qemu", "commit_id": "e549e7161f37416ff66971d77d021d30057045ca", "target": 1, "func": "static QObject *parse_keyword(JSONParserContext *ctxt)\n\n{\n\n    QObject *token, *ret;\n\n    JSONParserContext saved_ctxt = parser_context_save(ctxt);\n\n\n\n    token = parser_context_pop_token(ctxt);\n\n    if (token == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_get_type(token) != JSON_KEYWORD) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_is_keyword(token, \"true\")) {\n\n        ret = QOBJECT(qbool_from_int(true));\n\n    } else if (token_is_keyword(token, \"false\")) {\n\n        ret = QOBJECT(qbool_from_int(false));\n\n\n\n    } else {\n\n        parse_error(ctxt, token, \"invalid keyword `%s'\", token_get_value(token));\n\n        goto out;\n\n    }\n\n\n\n    return ret;\n\n\n\nout: \n\n    parser_context_restore(ctxt, saved_ctxt);\n\n\n\n    return NULL;\n\n}", "idx": 4256, "_split": "test", "_hash": "bf1d302dc790ef40293b2c5b906e65ae"}
{"project": "qemu", "commit_id": "45b339b18c660eb85af2ba25bfcaed5469660d77", "target": 0, "func": "static int uhci_complete_td(UHCIState *s, UHCI_TD *td, UHCIAsync *async, uint32_t *int_mask)\n\n{\n\n    int len = 0, max_len, err, ret;\n\n    uint8_t pid;\n\n\n\n    max_len = ((td->token >> 21) + 1) & 0x7ff;\n\n    pid = td->token & 0xff;\n\n\n\n    ret = async->packet.result;\n\n\n\n    if (td->ctrl & TD_CTRL_IOS)\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n\n\n    if (ret < 0)\n\n        goto out;\n\n\n\n    len = async->packet.result;\n\n    td->ctrl = (td->ctrl & ~0x7ff) | ((len - 1) & 0x7ff);\n\n\n\n    /* The NAK bit may have been set by a previous frame, so clear it\n\n       here.  The docs are somewhat unclear, but win2k relies on this\n\n       behavior.  */\n\n    td->ctrl &= ~(TD_CTRL_ACTIVE | TD_CTRL_NAK);\n\n    if (td->ctrl & TD_CTRL_IOC)\n\n        *int_mask |= 0x01;\n\n\n\n    if (pid == USB_TOKEN_IN) {\n\n        if (len > max_len) {\n\n            ret = USB_RET_BABBLE;\n\n            goto out;\n\n        }\n\n\n\n        if ((td->ctrl & TD_CTRL_SPD) && len < max_len) {\n\n            *int_mask |= 0x02;\n\n            /* short packet: do not update QH */\n\n            trace_usb_uhci_packet_complete_shortxfer(async->queue->token,\n\n                                                    async->td);\n\n            return TD_RESULT_NEXT_QH;\n\n        }\n\n    }\n\n\n\n    /* success */\n\n    trace_usb_uhci_packet_complete_success(async->queue->token, async->td);\n\n    return TD_RESULT_COMPLETE;\n\n\n\nout:\n\n    /*\n\n     * We should not do any further processing on a queue with errors!\n\n     * This is esp. important for bulk endpoints with pipelining enabled\n\n     * (redirection to a real USB device), where we must cancel all the\n\n     * transfers after this one so that:\n\n     * 1) If they've completed already, they are not processed further\n\n     *    causing more stalls, originating from the same failed transfer\n\n     * 2) If still in flight, they are cancelled before the guest does\n\n     *    a clear stall, otherwise the guest and device can loose sync!\n\n     */\n\n    while (!QTAILQ_EMPTY(&async->queue->asyncs)) {\n\n        UHCIAsync *as = QTAILQ_FIRST(&async->queue->asyncs);\n\n        uhci_async_unlink(as);\n\n        uhci_async_cancel(as);\n\n    }\n\n\n\n    switch(ret) {\n\n    case USB_RET_STALL:\n\n        td->ctrl |= TD_CTRL_STALL;\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n        s->status |= UHCI_STS_USBERR;\n\n        if (td->ctrl & TD_CTRL_IOC) {\n\n            *int_mask |= 0x01;\n\n        }\n\n        uhci_update_irq(s);\n\n        trace_usb_uhci_packet_complete_stall(async->queue->token, async->td);\n\n        return TD_RESULT_NEXT_QH;\n\n\n\n    case USB_RET_BABBLE:\n\n        td->ctrl |= TD_CTRL_BABBLE | TD_CTRL_STALL;\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n        s->status |= UHCI_STS_USBERR;\n\n        if (td->ctrl & TD_CTRL_IOC) {\n\n            *int_mask |= 0x01;\n\n        }\n\n        uhci_update_irq(s);\n\n        /* frame interrupted */\n\n        trace_usb_uhci_packet_complete_babble(async->queue->token, async->td);\n\n        return TD_RESULT_STOP_FRAME;\n\n\n\n    case USB_RET_NAK:\n\n        td->ctrl |= TD_CTRL_NAK;\n\n        if (pid == USB_TOKEN_SETUP)\n\n            break;\n\n        return TD_RESULT_NEXT_QH;\n\n\n\n    case USB_RET_IOERROR:\n\n    case USB_RET_NODEV:\n\n    default:\n\n\tbreak;\n\n    }\n\n\n\n    /* Retry the TD if error count is not zero */\n\n\n\n    td->ctrl |= TD_CTRL_TIMEOUT;\n\n    err = (td->ctrl >> TD_CTRL_ERROR_SHIFT) & 3;\n\n    if (err != 0) {\n\n        err--;\n\n        if (err == 0) {\n\n            td->ctrl &= ~TD_CTRL_ACTIVE;\n\n            s->status |= UHCI_STS_USBERR;\n\n            if (td->ctrl & TD_CTRL_IOC)\n\n                *int_mask |= 0x01;\n\n            uhci_update_irq(s);\n\n            trace_usb_uhci_packet_complete_error(async->queue->token,\n\n                                                 async->td);\n\n        }\n\n    }\n\n    td->ctrl = (td->ctrl & ~(3 << TD_CTRL_ERROR_SHIFT)) |\n\n        (err << TD_CTRL_ERROR_SHIFT);\n\n    return TD_RESULT_NEXT_QH;\n\n}\n", "idx": 4315, "_split": "test", "_hash": "3f2d21be8632d1de94634aed00b400cc"}
{"project": "qemu", "commit_id": "9d27abd94fe2c48281a77112d58422b392a80f7b", "target": 0, "func": "static void cpu_x86_dump_state(FILE *f)\n\n{\n\n    int eflags;\n\n    char cc_op_name[32];\n\n    eflags = cc_table[CC_OP].compute_all();\n\n    eflags |= (DF & DF_MASK);\n\n    if ((unsigned)env->cc_op < CC_OP_NB)\n\n        strcpy(cc_op_name, cc_op_str[env->cc_op]);\n\n    else\n\n        snprintf(cc_op_name, sizeof(cc_op_name), \"[%d]\", env->cc_op);\n\n    fprintf(f, \n\n            \"EAX=%08x EBX=%08X ECX=%08x EDX=%08x\\n\"\n\n            \"ESI=%08x EDI=%08X EBP=%08x ESP=%08x\\n\"\n\n            \"CCS=%08x CCD=%08x CCO=%-8s EFL=%c%c%c%c%c%c%c\\n\"\n\n            \"EIP=%08x\\n\",\n\n            env->regs[R_EAX], env->regs[R_EBX], env->regs[R_ECX], env->regs[R_EDX], \n\n            env->regs[R_ESI], env->regs[R_EDI], env->regs[R_EBP], env->regs[R_ESP], \n\n            env->cc_src, env->cc_dst, cc_op_name,\n\n            eflags & DF_MASK ? 'D' : '-',\n\n            eflags & CC_O ? 'O' : '-',\n\n            eflags & CC_S ? 'S' : '-',\n\n            eflags & CC_Z ? 'Z' : '-',\n\n            eflags & CC_A ? 'A' : '-',\n\n            eflags & CC_P ? 'P' : '-',\n\n            eflags & CC_C ? 'C' : '-',\n\n            env->eip);\n\n#if 1\n\n    fprintf(f, \"ST0=%f ST1=%f ST2=%f ST3=%f\\n\", \n\n            (double)ST0, (double)ST1, (double)ST(2), (double)ST(3));\n\n#endif\n\n}\n", "idx": 4337, "_split": "test", "_hash": "0cd0c903d6f51b2981d66f8dba7701c5"}
{"project": "qemu", "commit_id": "2725aec70114cf1bee00443aeb47a305f9b0c665", "target": 1, "func": "static void i440fx_update_memory_mappings(PCII440FXState *d)\n\n{\n\n    int i, r;\n\n    uint32_t smram;\n\n    bool smram_enabled;\n\n\n\n    memory_region_transaction_begin();\n\n    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,\n\n               &d->pam_regions[0]);\n\n    for(i = 0; i < 12; i++) {\n\n        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;\n\n        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,\n\n                   &d->pam_regions[i+1]);\n\n    }\n\n    smram = d->dev.config[I440FX_SMRAM];\n\n    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);\n\n    memory_region_set_enabled(&d->smram_region, !smram_enabled);\n\n    memory_region_transaction_commit();\n\n}\n", "idx": 4360, "_split": "test", "_hash": "347098bd6fb3e84f62640459e27c70b2"}
{"project": "qemu", "commit_id": "e98768d43799cd3f00b358bfbe455fdae793d3e8", "target": 1, "func": "static int vmdk_open_vmdk4(BlockDriverState *bs,\n\n                           BlockDriverState *file,\n\n                           int flags)\n\n{\n\n    int ret;\n\n    uint32_t magic;\n\n    uint32_t l1_size, l1_entry_sectors;\n\n    VMDK4Header header;\n\n    VmdkExtent *extent;\n\n    int64_t l1_backup_offset = 0;\n\n\n\n    ret = bdrv_pread(file, sizeof(magic), &header, sizeof(header));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    if (header.capacity == 0) {\n\n        int64_t desc_offset = le64_to_cpu(header.desc_offset);\n\n        if (desc_offset) {\n\n            return vmdk_open_desc_file(bs, flags, desc_offset << 9);\n\n        }\n\n    }\n\n\n\n    if (le64_to_cpu(header.gd_offset) == VMDK4_GD_AT_END) {\n\n        /*\n\n         * The footer takes precedence over the header, so read it in. The\n\n         * footer starts at offset -1024 from the end: One sector for the\n\n         * footer, and another one for the end-of-stream marker.\n\n         */\n\n        struct {\n\n            struct {\n\n                uint64_t val;\n\n                uint32_t size;\n\n                uint32_t type;\n\n                uint8_t pad[512 - 16];\n\n            } QEMU_PACKED footer_marker;\n\n\n\n            uint32_t magic;\n\n            VMDK4Header header;\n\n            uint8_t pad[512 - 4 - sizeof(VMDK4Header)];\n\n\n\n            struct {\n\n                uint64_t val;\n\n                uint32_t size;\n\n                uint32_t type;\n\n                uint8_t pad[512 - 16];\n\n            } QEMU_PACKED eos_marker;\n\n        } QEMU_PACKED footer;\n\n\n\n        ret = bdrv_pread(file,\n\n            bs->file->total_sectors * 512 - 1536,\n\n            &footer, sizeof(footer));\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        /* Some sanity checks for the footer */\n\n        if (be32_to_cpu(footer.magic) != VMDK4_MAGIC ||\n\n            le32_to_cpu(footer.footer_marker.size) != 0  ||\n\n            le32_to_cpu(footer.footer_marker.type) != MARKER_FOOTER ||\n\n            le64_to_cpu(footer.eos_marker.val) != 0  ||\n\n            le32_to_cpu(footer.eos_marker.size) != 0  ||\n\n            le32_to_cpu(footer.eos_marker.type) != MARKER_END_OF_STREAM)\n\n        {\n\n            return -EINVAL;\n\n        }\n\n\n\n        header = footer.header;\n\n    }\n\n\n\n    if (le32_to_cpu(header.version) >= 3) {\n\n        char buf[64];\n\n        snprintf(buf, sizeof(buf), \"VMDK version %d\",\n\n                 le32_to_cpu(header.version));\n\n        qerror_report(QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,\n\n                bs->device_name, \"vmdk\", buf);\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    l1_entry_sectors = le32_to_cpu(header.num_gtes_per_gte)\n\n                        * le64_to_cpu(header.granularity);\n\n    if (l1_entry_sectors == 0) {\n\n        return -EINVAL;\n\n    }\n\n    l1_size = (le64_to_cpu(header.capacity) + l1_entry_sectors - 1)\n\n                / l1_entry_sectors;\n\n    if (le32_to_cpu(header.flags) & VMDK4_FLAG_RGD) {\n\n        l1_backup_offset = le64_to_cpu(header.rgd_offset) << 9;\n\n    }\n\n    extent = vmdk_add_extent(bs, file, false,\n\n                          le64_to_cpu(header.capacity),\n\n                          le64_to_cpu(header.gd_offset) << 9,\n\n                          l1_backup_offset,\n\n                          l1_size,\n\n                          le32_to_cpu(header.num_gtes_per_gte),\n\n                          le64_to_cpu(header.granularity));\n\n    extent->compressed =\n\n        le16_to_cpu(header.compressAlgorithm) == VMDK4_COMPRESSION_DEFLATE;\n\n    extent->has_marker = le32_to_cpu(header.flags) & VMDK4_FLAG_MARKER;\n\n    extent->version = le32_to_cpu(header.version);\n\n    extent->has_zero_grain = le32_to_cpu(header.flags) & VMDK4_FLAG_ZERO_GRAIN;\n\n    ret = vmdk_init_tables(bs, extent);\n\n    if (ret) {\n\n        /* free extent allocated by vmdk_add_extent */\n\n        vmdk_free_last_extent(bs);\n\n    }\n\n    return ret;\n\n}\n", "idx": 4362, "_split": "test", "_hash": "13e69896b8e8af663dbccb97c4e978b8"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void control_to_network(RDMAControlHeader *control)\n\n{\n\n    control->type = htonl(control->type);\n\n    control->len = htonl(control->len);\n\n    control->repeat = htonl(control->repeat);\n\n}\n", "idx": 4385, "_split": "test", "_hash": "ffa14a4141e230fb493c75aa1d81467a"}
{"project": "qemu", "commit_id": "95129d6fc9ead97155627a4ca0cfd37282883658", "target": 0, "func": "static bool use_multiport(VirtIOSerial *vser)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(vser);\n\n    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);\n\n}\n", "idx": 4389, "_split": "test", "_hash": "eb7e7a8b2bd7d13d99270182a25a35d6"}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "void *memory_region_get_ram_ptr(MemoryRegion *mr)\n\n{\n\n    if (mr->alias) {\n\n        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;\n\n    }\n\n\n\n    assert(mr->terminates);\n\n\n\n    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);\n\n}\n", "idx": 4440, "_split": "test", "_hash": "65ae517950e83631a695e9617e52cecb"}
{"project": "qemu", "commit_id": "de13d2161473d02ae97ec0f8e4503147554892dd", "target": 0, "func": "void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)\n\n{\n\n    kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);\n\n}\n", "idx": 4488, "_split": "test", "_hash": "6bfb5ccef88fd8e2968b4bf07576dbac"}
{"project": "qemu", "commit_id": "e61031cdd81826c433a8bbfa3aca2bae4ffaf845", "target": 1, "func": "static gboolean gd_motion_event(GtkWidget *widget, GdkEventMotion *motion,\n\n                                void *opaque)\n\n{\n\n    GtkDisplayState *s = opaque;\n\n    int x, y;\n\n    int mx, my;\n\n    int fbh, fbw;\n\n    int ww, wh;\n\n\n\n    fbw = surface_width(s->ds) * s->scale_x;\n\n    fbh = surface_height(s->ds) * s->scale_y;\n\n\n\n    gdk_drawable_get_size(gtk_widget_get_window(s->drawing_area), &ww, &wh);\n\n\n\n    mx = my = 0;\n\n    if (ww > fbw) {\n\n        mx = (ww - fbw) / 2;\n\n    }\n\n    if (wh > fbh) {\n\n        my = (wh - fbh) / 2;\n\n    }\n\n\n\n    x = (motion->x - mx) / s->scale_x;\n\n    y = (motion->y - my) / s->scale_y;\n\n\n\n    if (x < 0 || y < 0 ||\n\n        x >= surface_width(s->ds) ||\n\n        y >= surface_height(s->ds)) {\n\n        return TRUE;\n\n    }\n\n\n\n    if (qemu_input_is_absolute()) {\n\n        qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_X, x,\n\n                             surface_width(s->ds));\n\n        qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_Y, y,\n\n                             surface_height(s->ds));\n\n        qemu_input_event_sync();\n\n    } else if (s->last_x != -1 && s->last_y != -1 && gd_is_grab_active(s)) {\n\n        qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_X, x - s->last_x);\n\n        qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_Y, y - s->last_y);\n\n        qemu_input_event_sync();\n\n    }\n\n    s->last_x = x;\n\n    s->last_y = y;\n\n\n\n    if (!qemu_input_is_absolute() && gd_is_grab_active(s)) {\n\n        GdkScreen *screen = gtk_widget_get_screen(s->drawing_area);\n\n        int x = (int)motion->x_root;\n\n        int y = (int)motion->y_root;\n\n\n\n        /* In relative mode check to see if client pointer hit\n\n         * one of the screen edges, and if so move it back by\n\n         * 200 pixels. This is important because the pointer\n\n         * in the server doesn't correspond 1-for-1, and so\n\n         * may still be only half way across the screen. Without\n\n         * this warp, the server pointer would thus appear to hit\n\n         * an invisible wall */\n\n        if (x == 0) {\n\n            x += 200;\n\n        }\n\n        if (y == 0) {\n\n            y += 200;\n\n        }\n\n        if (x == (gdk_screen_get_width(screen) - 1)) {\n\n            x -= 200;\n\n        }\n\n        if (y == (gdk_screen_get_height(screen) - 1)) {\n\n            y -= 200;\n\n        }\n\n\n\n        if (x != (int)motion->x_root || y != (int)motion->y_root) {\n\n#if GTK_CHECK_VERSION(3, 0, 0)\n\n            GdkDevice *dev = gdk_event_get_device((GdkEvent *)motion);\n\n            gdk_device_warp(dev, screen, x, y);\n\n#else\n\n            GdkDisplay *display = gtk_widget_get_display(widget);\n\n            gdk_display_warp_pointer(display, screen, x, y);\n\n#endif\n\n            s->last_x = -1;\n\n            s->last_y = -1;\n\n            return FALSE;\n\n        }\n\n    }\n\n    return TRUE;\n\n}\n", "idx": 4521, "_split": "test", "_hash": "b8d0260e49eb7eece751d98db8db09ea"}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)\n\n{\n\n    if (use_icount) {\n\n        gen_io_start();\n\n    }\n\n    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);\n\n    if (use_icount) {\n\n        gen_io_end();\n\n        gen_stop_exception(ctx);\n\n    }\n\n}\n", "idx": 4540, "_split": "test", "_hash": "bfc762a9781c2a9aa6d39c682592364a"}
{"project": "qemu", "commit_id": "46746dbaa8c2c421b9bda78193caad57d7fb1136", "target": 0, "func": "static void vfio_intx_enable_kvm(VFIOPCIDevice *vdev)\n\n{\n\n#ifdef CONFIG_KVM\n\n    struct kvm_irqfd irqfd = {\n\n        .fd = event_notifier_get_fd(&vdev->intx.interrupt),\n\n        .gsi = vdev->intx.route.irq,\n\n        .flags = KVM_IRQFD_FLAG_RESAMPLE,\n\n    };\n\n    struct vfio_irq_set *irq_set;\n\n    int ret, argsz;\n\n    int32_t *pfd;\n\n\n\n    if (!VFIO_ALLOW_KVM_INTX || !kvm_irqfds_enabled() ||\n\n        vdev->intx.route.mode != PCI_INTX_ENABLED ||\n\n        !kvm_resamplefds_enabled()) {\n\n        return;\n\n    }\n\n\n\n    /* Get to a known interrupt state */\n\n    qemu_set_fd_handler(irqfd.fd, NULL, NULL, vdev);\n\n    vfio_mask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);\n\n    vdev->intx.pending = false;\n\n    pci_irq_deassert(&vdev->pdev);\n\n\n\n    /* Get an eventfd for resample/unmask */\n\n    if (event_notifier_init(&vdev->intx.unmask, 0)) {\n\n        error_report(\"vfio: Error: event_notifier_init failed eoi\");\n\n        goto fail;\n\n    }\n\n\n\n    /* KVM triggers it, VFIO listens for it */\n\n    irqfd.resamplefd = event_notifier_get_fd(&vdev->intx.unmask);\n\n\n\n    if (kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd)) {\n\n        error_report(\"vfio: Error: Failed to setup resample irqfd: %m\");\n\n        goto fail_irqfd;\n\n    }\n\n\n\n    argsz = sizeof(*irq_set) + sizeof(*pfd);\n\n\n\n    irq_set = g_malloc0(argsz);\n\n    irq_set->argsz = argsz;\n\n    irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_UNMASK;\n\n    irq_set->index = VFIO_PCI_INTX_IRQ_INDEX;\n\n    irq_set->start = 0;\n\n    irq_set->count = 1;\n\n    pfd = (int32_t *)&irq_set->data;\n\n\n\n    *pfd = irqfd.resamplefd;\n\n\n\n    ret = ioctl(vdev->vbasedev.fd, VFIO_DEVICE_SET_IRQS, irq_set);\n\n    g_free(irq_set);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: Failed to setup INTx unmask fd: %m\");\n\n        goto fail_vfio;\n\n    }\n\n\n\n    /* Let'em rip */\n\n    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);\n\n\n\n    vdev->intx.kvm_accel = true;\n\n\n\n    trace_vfio_intx_enable_kvm(vdev->vbasedev.name);\n\n\n\n    return;\n\n\n\nfail_vfio:\n\n    irqfd.flags = KVM_IRQFD_FLAG_DEASSIGN;\n\n    kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd);\n\nfail_irqfd:\n\n    event_notifier_cleanup(&vdev->intx.unmask);\n\nfail:\n\n    qemu_set_fd_handler(irqfd.fd, vfio_intx_interrupt, NULL, vdev);\n\n    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);\n\n#endif\n\n}\n", "idx": 4551, "_split": "test", "_hash": "4d00c11b2490e15ac8db4fb8ac68239e"}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_evfsnabs(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);\n\n#else\n\n    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);\n\n    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);\n\n#endif\n\n}\n", "idx": 4555, "_split": "test", "_hash": "918a7ae10065742bcf870e367b0f24a1"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset,\n\n                                unsigned size)\n\n{\n\n    IMXTimerGState *s = (IMXTimerGState *)opaque;\n\n\n\n    DPRINTF(\"g-read(offset=%x)\", offset >> 2);\n\n    switch (offset >> 2) {\n\n    case 0: /* Control Register */\n\n        DPRINTF(\" cr = %x\\n\", s->cr);\n\n        return s->cr;\n\n\n\n    case 1: /* prescaler */\n\n        DPRINTF(\" pr = %x\\n\", s->pr);\n\n        return s->pr;\n\n\n\n    case 2: /* Status Register */\n\n        DPRINTF(\" sr = %x\\n\", s->sr);\n\n        return s->sr;\n\n\n\n    case 3: /* Interrupt Register */\n\n        DPRINTF(\" ir = %x\\n\", s->ir);\n\n        return s->ir;\n\n\n\n    case 4: /* Output Compare Register 1 */\n\n        DPRINTF(\" ocr1 = %x\\n\", s->ocr1);\n\n        return s->ocr1;\n\n\n\n\n\n    case 9: /* cnt */\n\n        imx_timerg_update_counts(s);\n\n        DPRINTF(\" cnt = %x\\n\", s->cnt);\n\n        return s->cnt;\n\n    }\n\n\n\n    IPRINTF(\"imx_timerg_read: Bad offset %x\\n\",\n\n            (int)offset >> 2);\n\n    return 0;\n\n}\n", "idx": 4556, "_split": "test", "_hash": "0f68c9b6fd65675b74e313306ea8cacf"}
{"project": "qemu", "commit_id": "430b26a82da61876c4eaf559ae02332582968043", "target": 0, "func": "static int blkdebug_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    /* Read rules from config file or command line options */\n\n    s->config_file = g_strdup(qemu_opt_get(opts, \"config\"));\n\n    ret = read_config(s, s->config_file, options, errp);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    /* Set initial state */\n\n    s->state = 1;\n\n\n\n    /* Open the image file */\n\n    bs->file = bdrv_open_child(qemu_opt_get(opts, \"x-image\"), options, \"image\",\n\n                               bs, &child_file, false, &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto out;\n\n    }\n\n\n\n    bs->supported_write_flags = BDRV_REQ_FUA &\n\n        bs->file->bs->supported_write_flags;\n\n    bs->supported_zero_flags = (BDRV_REQ_FUA | BDRV_REQ_MAY_UNMAP) &\n\n        bs->file->bs->supported_zero_flags;\n\n    ret = -EINVAL;\n\n\n\n    /* Set request alignment */\n\n    s->align = qemu_opt_get_size(opts, \"align\", 0);\n\n    if (s->align && (s->align >= INT_MAX || !is_power_of_2(s->align))) {\n\n        error_setg(errp, \"Cannot meet constraints with align %\" PRIu64,\n\n                   s->align);\n\n        goto out;\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    if (ret < 0) {\n\n        g_free(s->config_file);\n\n    }\n\n    qemu_opts_del(opts);\n\n    return ret;\n\n}\n", "idx": 4563, "_split": "test", "_hash": "ef58b9a6b5ee39b7a99d819dd0c49475"}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoull_full_negative(void)\n\n{\n\n    const char *str = \" \\t -321\";\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, NULL, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 18446744073709551295LLU);\n\n}\n", "idx": 4569, "_split": "test", "_hash": "4ee3b722aea19c01268af215cc122f0f"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t exynos4210_fimd_read(void *opaque, target_phys_addr_t offset,\n\n                                  unsigned size)\n\n{\n\n    Exynos4210fimdState *s = (Exynos4210fimdState *)opaque;\n\n    int w, i;\n\n    uint32_t ret = 0;\n\n\n\n    DPRINT_L2(\"read offset 0x%08x\\n\", offset);\n\n\n\n    switch (offset) {\n\n    case FIMD_VIDCON0 ... FIMD_VIDCON3:\n\n        return s->vidcon[(offset - FIMD_VIDCON0) >> 2];\n\n    case FIMD_VIDTCON_START ... FIMD_VIDTCON_END:\n\n        return s->vidtcon[(offset - FIMD_VIDTCON_START) >> 2];\n\n    case FIMD_WINCON_START ... FIMD_WINCON_END:\n\n        return s->window[(offset - FIMD_WINCON_START) >> 2].wincon;\n\n    case FIMD_SHADOWCON:\n\n        return s->shadowcon;\n\n    case FIMD_WINCHMAP:\n\n        return s->winchmap;\n\n    case FIMD_VIDOSD_START ... FIMD_VIDOSD_END:\n\n        w = (offset - FIMD_VIDOSD_START) >> 4;\n\n        i = ((offset - FIMD_VIDOSD_START) & 0xF) >> 2;\n\n        switch (i) {\n\n        case 0:\n\n            ret = ((s->window[w].lefttop_x & FIMD_VIDOSD_COORD_MASK) <<\n\n            FIMD_VIDOSD_HOR_SHIFT) |\n\n            (s->window[w].lefttop_y & FIMD_VIDOSD_COORD_MASK);\n\n            break;\n\n        case 1:\n\n            ret = ((s->window[w].rightbot_x & FIMD_VIDOSD_COORD_MASK) <<\n\n                FIMD_VIDOSD_HOR_SHIFT) |\n\n                (s->window[w].rightbot_y & FIMD_VIDOSD_COORD_MASK);\n\n            break;\n\n        case 2:\n\n            if (w == 0) {\n\n                ret = s->window[w].osdsize;\n\n            } else {\n\n                ret = (pack_upper_4(s->window[w].alpha_val[0]) <<\n\n                    FIMD_VIDOSD_AEN0_SHIFT) |\n\n                    pack_upper_4(s->window[w].alpha_val[1]);\n\n            }\n\n            break;\n\n        case 3:\n\n            if (w != 1 && w != 2) {\n\n                DPRINT_ERROR(\"bad read offset 0x%08x\\n\", offset);\n\n                return 0xBAADBAAD;\n\n            }\n\n            ret = s->window[w].osdsize;\n\n            break;\n\n        }\n\n        return ret;\n\n    case FIMD_VIDWADD0_START ... FIMD_VIDWADD0_END:\n\n        w = (offset - FIMD_VIDWADD0_START) >> 3;\n\n        i = ((offset - FIMD_VIDWADD0_START) >> 2) & 1;\n\n        return s->window[w].buf_start[i];\n\n    case FIMD_VIDWADD1_START ... FIMD_VIDWADD1_END:\n\n        w = (offset - FIMD_VIDWADD1_START) >> 3;\n\n        i = ((offset - FIMD_VIDWADD1_START) >> 2) & 1;\n\n        return s->window[w].buf_end[i];\n\n    case FIMD_VIDWADD2_START ... FIMD_VIDWADD2_END:\n\n        w = (offset - FIMD_VIDWADD2_START) >> 2;\n\n        return s->window[w].virtpage_width | (s->window[w].virtpage_offsize <<\n\n            FIMD_VIDWADD2_OFFSIZE_SHIFT);\n\n    case FIMD_VIDINTCON0 ... FIMD_VIDINTCON1:\n\n        return s->vidintcon[(offset - FIMD_VIDINTCON0) >> 2];\n\n    case FIMD_WKEYCON_START ... FIMD_WKEYCON_END:\n\n        w = ((offset - FIMD_WKEYCON_START) >> 3) + 1;\n\n        i = ((offset - FIMD_WKEYCON_START) >> 2) & 1;\n\n        return s->window[w].keycon[i];\n\n    case FIMD_WKEYALPHA_START ... FIMD_WKEYALPHA_END:\n\n        w = ((offset - FIMD_WKEYALPHA_START) >> 2) + 1;\n\n        return s->window[w].keyalpha;\n\n    case FIMD_DITHMODE:\n\n        return s->dithmode;\n\n    case FIMD_WINMAP_START ... FIMD_WINMAP_END:\n\n        return s->window[(offset - FIMD_WINMAP_START) >> 2].winmap;\n\n    case FIMD_WPALCON_HIGH ... FIMD_WPALCON_LOW:\n\n        return s->wpalcon[(offset - FIMD_WPALCON_HIGH) >> 2];\n\n    case FIMD_TRIGCON:\n\n        return s->trigcon;\n\n    case FIMD_I80IFCON_START ... FIMD_I80IFCON_END:\n\n        return s->i80ifcon[(offset - FIMD_I80IFCON_START) >> 2];\n\n    case FIMD_COLORGAINCON:\n\n        return s->colorgaincon;\n\n    case FIMD_LDI_CMDCON0 ... FIMD_LDI_CMDCON1:\n\n        return s->ldi_cmdcon[(offset - FIMD_LDI_CMDCON0) >> 2];\n\n    case FIMD_SIFCCON0 ... FIMD_SIFCCON2:\n\n        i = (offset - FIMD_SIFCCON0) >> 2;\n\n        return s->sifccon[i];\n\n    case FIMD_HUECOEFCR_START ... FIMD_HUECOEFCR_END:\n\n        i = (offset - FIMD_HUECOEFCR_START) >> 2;\n\n        return s->huecoef_cr[i];\n\n    case FIMD_HUECOEFCB_START ... FIMD_HUECOEFCB_END:\n\n        i = (offset - FIMD_HUECOEFCB_START) >> 2;\n\n        return s->huecoef_cb[i];\n\n    case FIMD_HUEOFFSET:\n\n        return s->hueoffset;\n\n    case FIMD_VIDWALPHA_START ... FIMD_VIDWALPHA_END:\n\n        w = ((offset - FIMD_VIDWALPHA_START) >> 3);\n\n        i = ((offset - FIMD_VIDWALPHA_START) >> 2) & 1;\n\n        return s->window[w].alpha_val[i] &\n\n                (w == 0 ? 0xFFFFFF : FIMD_VIDALPHA_ALPHA_LOWER);\n\n    case FIMD_BLENDEQ_START ... FIMD_BLENDEQ_END:\n\n        return s->window[(offset - FIMD_BLENDEQ_START) >> 2].blendeq;\n\n    case FIMD_BLENDCON:\n\n        return s->blendcon;\n\n    case FIMD_WRTQOSCON_START ... FIMD_WRTQOSCON_END:\n\n        return s->window[(offset - FIMD_WRTQOSCON_START) >> 2].rtqoscon;\n\n    case FIMD_I80IFCMD_START ... FIMD_I80IFCMD_END:\n\n        return s->i80ifcmd[(offset - FIMD_I80IFCMD_START) >> 2];\n\n    case FIMD_VIDW0ADD0_B2 ... FIMD_VIDW4ADD0_B2:\n\n        if (offset & 0x0004) {\n\n            break;\n\n        }\n\n        return s->window[(offset - FIMD_VIDW0ADD0_B2) >> 3].buf_start[2];\n\n    case FIMD_SHD_ADD0_START ... FIMD_SHD_ADD0_END:\n\n        if (offset & 0x0004) {\n\n            break;\n\n        }\n\n        return s->window[(offset - FIMD_SHD_ADD0_START) >> 3].shadow_buf_start;\n\n    case FIMD_SHD_ADD1_START ... FIMD_SHD_ADD1_END:\n\n        if (offset & 0x0004) {\n\n            break;\n\n        }\n\n        return s->window[(offset - FIMD_SHD_ADD1_START) >> 3].shadow_buf_end;\n\n    case FIMD_SHD_ADD2_START ... FIMD_SHD_ADD2_END:\n\n        return s->window[(offset - FIMD_SHD_ADD2_START) >> 2].shadow_buf_size;\n\n    case FIMD_PAL_MEM_START ... FIMD_PAL_MEM_END:\n\n        w = (offset - FIMD_PAL_MEM_START) >> 10;\n\n        i = ((offset - FIMD_PAL_MEM_START) >> 2) & 0xFF;\n\n        return s->window[w].palette[i];\n\n    case FIMD_PALMEM_AL_START ... FIMD_PALMEM_AL_END:\n\n        /* Palette aliases for win 0,1 */\n\n        w = (offset - FIMD_PALMEM_AL_START) >> 10;\n\n        i = ((offset - FIMD_PALMEM_AL_START) >> 2) & 0xFF;\n\n        return s->window[w].palette[i];\n\n    }\n\n\n\n    DPRINT_ERROR(\"bad read offset 0x%08x\\n\", offset);\n\n    return 0xBAADBAAD;\n\n}\n", "idx": 4570, "_split": "test", "_hash": "b2f4b7c72782c6267231caa15047829e"}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float64 HELPER(ucf64_absd)(float64 a)\n\n{\n\n    return float64_abs(a);\n\n}\n", "idx": 4571, "_split": "test", "_hash": "85edf1dc6694473ae113029e129389e0"}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static CharDriverState *qemu_chr_open_null(const char *id,\n\n                                           ChardevBackend *backend,\n\n                                           ChardevReturn *ret,\n\n                                           Error **errp)\n\n{\n\n    CharDriverState *chr;\n\n    ChardevCommon *common = backend->u.null;\n\n\n\n    chr = qemu_chr_alloc(common, errp);\n\n    if (!chr) {\n\n        return NULL;\n\n    }\n\n    chr->chr_write = null_chr_write;\n\n    chr->explicit_be_open = true;\n\n    return chr;\n\n}\n", "idx": 4607, "_split": "test", "_hash": "57bf85a01a2f0e04b55e4027248ecc37"}
{"project": "qemu", "commit_id": "8ec14402029d783720f4312ed8a925548e1dad61", "target": 0, "func": "static int packet_enqueue(CompareState *s, int mode)\n\n{\n\n    ConnectionKey key;\n\n    Packet *pkt = NULL;\n\n    Connection *conn;\n\n\n\n    if (mode == PRIMARY_IN) {\n\n        pkt = packet_new(s->pri_rs.buf,\n\n                         s->pri_rs.packet_len,\n\n                         s->pri_rs.vnet_hdr_len);\n\n    } else {\n\n        pkt = packet_new(s->sec_rs.buf,\n\n                         s->sec_rs.packet_len,\n\n                         s->sec_rs.vnet_hdr_len);\n\n    }\n\n\n\n    if (parse_packet_early(pkt)) {\n\n        packet_destroy(pkt, NULL);\n\n        pkt = NULL;\n\n        return -1;\n\n    }\n\n    fill_connection_key(pkt, &key);\n\n\n\n    conn = connection_get(s->connection_track_table,\n\n                          &key,\n\n                          &s->conn_list);\n\n\n\n    if (!conn->processing) {\n\n        g_queue_push_tail(&s->conn_list, conn);\n\n        conn->processing = true;\n\n    }\n\n\n\n    if (mode == PRIMARY_IN) {\n\n        if (!colo_insert_packet(&conn->primary_list, pkt)) {\n\n            error_report(\"colo compare primary queue size too big,\"\n\n                         \"drop packet\");\n\n        }\n\n    } else {\n\n        if (!colo_insert_packet(&conn->secondary_list, pkt)) {\n\n            error_report(\"colo compare secondary queue size too big,\"\n\n                         \"drop packet\");\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4609, "_split": "test", "_hash": "d8b8d2937386978fa2971ba48fa154c3"}
{"project": "qemu", "commit_id": "27e0c9a1bbd166a67c16291016fba298a8e47140", "target": 0, "func": "static void ide_atapi_identify(IDEState *s)\n\n{\n\n    uint16_t *p;\n\n\n\n    if (s->identify_set) {\n\n\tmemcpy(s->io_buffer, s->identify_data, sizeof(s->identify_data));\n\n\treturn;\n\n    }\n\n\n\n    memset(s->io_buffer, 0, 512);\n\n    p = (uint16_t *)s->io_buffer;\n\n    /* Removable CDROM, 50us response, 12 byte packets */\n\n    put_le16(p + 0, (2 << 14) | (5 << 8) | (1 << 7) | (2 << 5) | (0 << 0));\n\n    padstr((char *)(p + 10), s->drive_serial_str, 20); /* serial number */\n\n    put_le16(p + 20, 3); /* buffer type */\n\n    put_le16(p + 21, 512); /* cache size in sectors */\n\n    put_le16(p + 22, 4); /* ecc bytes */\n\n    padstr((char *)(p + 23), s->version, 8); /* firmware version */\n\n    padstr((char *)(p + 27), \"QEMU DVD-ROM\", 40); /* model */\n\n    put_le16(p + 48, 1); /* dword I/O (XXX: should not be set on CDROM) */\n\n#ifdef USE_DMA_CDROM\n\n    put_le16(p + 49, 1 << 9 | 1 << 8); /* DMA and LBA supported */\n\n    put_le16(p + 53, 7); /* words 64-70, 54-58, 88 valid */\n\n    put_le16(p + 62, 7);  /* single word dma0-2 supported */\n\n    put_le16(p + 63, 7);  /* mdma0-2 supported */\n\n#else\n\n    put_le16(p + 49, 1 << 9); /* LBA supported, no DMA */\n\n    put_le16(p + 53, 3); /* words 64-70, 54-58 valid */\n\n    put_le16(p + 63, 0x103); /* DMA modes XXX: may be incorrect */\n\n#endif\n\n    put_le16(p + 64, 3); /* pio3-4 supported */\n\n    put_le16(p + 65, 0xb4); /* minimum DMA multiword tx cycle time */\n\n    put_le16(p + 66, 0xb4); /* recommended DMA multiword tx cycle time */\n\n    put_le16(p + 67, 0x12c); /* minimum PIO cycle time without flow control */\n\n    put_le16(p + 68, 0xb4); /* minimum PIO cycle time with IORDY flow control */\n\n\n\n    put_le16(p + 71, 30); /* in ns */\n\n    put_le16(p + 72, 30); /* in ns */\n\n\n\n    if (s->ncq_queues) {\n\n        put_le16(p + 75, s->ncq_queues - 1);\n\n        /* NCQ supported */\n\n        put_le16(p + 76, (1 << 8));\n\n    }\n\n\n\n    put_le16(p + 80, 0x1e); /* support up to ATA/ATAPI-4 */\n\n#ifdef USE_DMA_CDROM\n\n    put_le16(p + 88, 0x3f | (1 << 13)); /* udma5 set and supported */\n\n#endif\n\n    memcpy(s->identify_data, p, sizeof(s->identify_data));\n\n    s->identify_set = 1;\n\n}\n", "idx": 4611, "_split": "test", "_hash": "6aa0960af3f4de6c4f131304e45e1abf"}
{"project": "qemu", "commit_id": "b9bec74bcb16519a876ec21cd5277c526a9b512d", "target": 0, "func": "static int kvm_put_xsave(CPUState *env)\n\n{\n\n#ifdef KVM_CAP_XSAVE\n\n    int i, r;\n\n    struct kvm_xsave* xsave;\n\n    uint16_t cwd, swd, twd, fop;\n\n\n\n    if (!kvm_has_xsave())\n\n        return kvm_put_fpu(env);\n\n\n\n    xsave = qemu_memalign(4096, sizeof(struct kvm_xsave));\n\n    memset(xsave, 0, sizeof(struct kvm_xsave));\n\n    cwd = swd = twd = fop = 0;\n\n    swd = env->fpus & ~(7 << 11);\n\n    swd |= (env->fpstt & 7) << 11;\n\n    cwd = env->fpuc;\n\n    for (i = 0; i < 8; ++i)\n\n        twd |= (!env->fptags[i]) << i;\n\n    xsave->region[0] = (uint32_t)(swd << 16) + cwd;\n\n    xsave->region[1] = (uint32_t)(fop << 16) + twd;\n\n    memcpy(&xsave->region[XSAVE_ST_SPACE], env->fpregs,\n\n            sizeof env->fpregs);\n\n    memcpy(&xsave->region[XSAVE_XMM_SPACE], env->xmm_regs,\n\n            sizeof env->xmm_regs);\n\n    xsave->region[XSAVE_MXCSR] = env->mxcsr;\n\n    *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV] = env->xstate_bv;\n\n    memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,\n\n            sizeof env->ymmh_regs);\n\n    r = kvm_vcpu_ioctl(env, KVM_SET_XSAVE, xsave);\n\n    qemu_free(xsave);\n\n    return r;\n\n#else\n\n    return kvm_put_fpu(env);\n\n#endif\n\n}\n", "idx": 4615, "_split": "test", "_hash": "ad341bfe86920c7269ec1924bfb2bae6"}
{"project": "qemu", "commit_id": "ff5ce21e1b959206f257967d6de2efa6f4e3d188", "target": 1, "func": "build_tpm2(GArray *table_data, BIOSLinker *linker)\n\n{\n\n    Acpi20TPM2 *tpm2_ptr;\n\n\n\n    tpm2_ptr = acpi_data_push(table_data, sizeof *tpm2_ptr);\n\n\n\n    tpm2_ptr->platform_class = cpu_to_le16(TPM2_ACPI_CLASS_CLIENT);\n\n    tpm2_ptr->control_area_address = cpu_to_le64(0);\n\n    tpm2_ptr->start_method = cpu_to_le32(TPM2_START_METHOD_MMIO);\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)tpm2_ptr, \"TPM2\", sizeof(*tpm2_ptr), 4, NULL, NULL);\n\n}\n", "idx": 4645, "_split": "test", "_hash": "86da2fb6bb4b022b1bada7e57da4cdda"}
{"project": "qemu", "commit_id": "4652b8f3e1ec91bb9d6f00e40df7f96d1f1aafee", "target": 1, "func": "static int perform_cow(BlockDriverState *bs, QCowL2Meta *m)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    Qcow2COWRegion *start = &m->cow_start;\n\n    Qcow2COWRegion *end = &m->cow_end;\n\n    unsigned buffer_size;\n\n    unsigned data_bytes = end->offset - (start->offset + start->nb_bytes);\n\n    bool merge_reads;\n\n    uint8_t *start_buffer, *end_buffer;\n\n    QEMUIOVector qiov;\n\n    int ret;\n\n\n\n    assert(start->nb_bytes <= UINT_MAX - end->nb_bytes);\n\n    assert(start->nb_bytes + end->nb_bytes <= UINT_MAX - data_bytes);\n\n    assert(start->offset + start->nb_bytes <= end->offset);\n\n    assert(!m->data_qiov || m->data_qiov->size == data_bytes);\n\n\n\n    if (start->nb_bytes == 0 && end->nb_bytes == 0) {\n\n        return 0;\n\n    }\n\n\n\n    /* If we have to read both the start and end COW regions and the\n\n     * middle region is not too large then perform just one read\n\n     * operation */\n\n    merge_reads = start->nb_bytes && end->nb_bytes && data_bytes <= 16384;\n\n    if (merge_reads) {\n\n        buffer_size = start->nb_bytes + data_bytes + end->nb_bytes;\n\n    } else {\n\n        /* If we have to do two reads, add some padding in the middle\n\n         * if necessary to make sure that the end region is optimally\n\n         * aligned. */\n\n        size_t align = bdrv_opt_mem_align(bs);\n\n        assert(align > 0 && align <= UINT_MAX);\n\n        assert(QEMU_ALIGN_UP(start->nb_bytes, align) <=\n\n               UINT_MAX - end->nb_bytes);\n\n        buffer_size = QEMU_ALIGN_UP(start->nb_bytes, align) + end->nb_bytes;\n\n    }\n\n\n\n    /* Reserve a buffer large enough to store all the data that we're\n\n     * going to read */\n\n    start_buffer = qemu_try_blockalign(bs, buffer_size);\n\n    if (start_buffer == NULL) {\n\n        return -ENOMEM;\n\n    }\n\n    /* The part of the buffer where the end region is located */\n\n    end_buffer = start_buffer + buffer_size - end->nb_bytes;\n\n\n\n    qemu_iovec_init(&qiov, 2 + (m->data_qiov ? m->data_qiov->niov : 0));\n\n\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    /* First we read the existing data from both COW regions. We\n\n     * either read the whole region in one go, or the start and end\n\n     * regions separately. */\n\n    if (merge_reads) {\n\n        qemu_iovec_add(&qiov, start_buffer, buffer_size);\n\n        ret = do_perform_cow_read(bs, m->offset, start->offset, &qiov);\n\n    } else {\n\n        qemu_iovec_add(&qiov, start_buffer, start->nb_bytes);\n\n        ret = do_perform_cow_read(bs, m->offset, start->offset, &qiov);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        qemu_iovec_reset(&qiov);\n\n        qemu_iovec_add(&qiov, end_buffer, end->nb_bytes);\n\n        ret = do_perform_cow_read(bs, m->offset, end->offset, &qiov);\n\n    }\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Encrypt the data if necessary before writing it */\n\n    if (bs->encrypted) {\n\n        if (!do_perform_cow_encrypt(bs, m->offset, start->offset,\n\n                                    start_buffer, start->nb_bytes) ||\n\n            !do_perform_cow_encrypt(bs, m->offset, end->offset,\n\n                                    end_buffer, end->nb_bytes)) {\n\n            ret = -EIO;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* And now we can write everything. If we have the guest data we\n\n     * can write everything in one single operation */\n\n    if (m->data_qiov) {\n\n        qemu_iovec_reset(&qiov);\n\n        if (start->nb_bytes) {\n\n            qemu_iovec_add(&qiov, start_buffer, start->nb_bytes);\n\n        }\n\n        qemu_iovec_concat(&qiov, m->data_qiov, 0, data_bytes);\n\n        if (end->nb_bytes) {\n\n            qemu_iovec_add(&qiov, end_buffer, end->nb_bytes);\n\n        }\n\n        /* NOTE: we have a write_aio blkdebug event here followed by\n\n         * a cow_write one in do_perform_cow_write(), but there's only\n\n         * one single I/O operation */\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n        ret = do_perform_cow_write(bs, m->alloc_offset, start->offset, &qiov);\n\n    } else {\n\n        /* If there's no guest data then write both COW regions separately */\n\n        qemu_iovec_reset(&qiov);\n\n        qemu_iovec_add(&qiov, start_buffer, start->nb_bytes);\n\n        ret = do_perform_cow_write(bs, m->alloc_offset, start->offset, &qiov);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        qemu_iovec_reset(&qiov);\n\n        qemu_iovec_add(&qiov, end_buffer, end->nb_bytes);\n\n        ret = do_perform_cow_write(bs, m->alloc_offset, end->offset, &qiov);\n\n    }\n\n\n\nfail:\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    /*\n\n     * Before we update the L2 table to actually point to the new cluster, we\n\n     * need to be sure that the refcounts have been increased and COW was\n\n     * handled.\n\n     */\n\n    if (ret == 0) {\n\n        qcow2_cache_depends_on_flush(s->l2_table_cache);\n\n    }\n\n\n\n    qemu_vfree(start_buffer);\n\n    qemu_iovec_destroy(&qiov);\n\n    return ret;\n\n}\n", "idx": 4697, "_split": "test", "_hash": "2bb843b8bd166e665da7fbabc1154da7"}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void init_proc_power5plus(CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_7xx(env);\n\n    /* Time base */\n\n    gen_tbl(env);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_clear,\n\n                 0x60000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_750FX_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_970_HID5, \"HID5\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 POWERPC970_HID5_INIT);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_L2CR, \"L2CR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, NULL,\n\n                 0x00000000);\n\n    /* Memory management */\n\n    /* XXX: not correct */\n\n    gen_low_BATs(env);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_MMUCFG, \"MMUCFG\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, SPR_NOACCESS,\n\n                 0x00000000); /* TOFIX */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_MMUCSR0, \"MMUCSR0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000); /* TOFIX */\n\n    spr_register(env, SPR_HIOR, \"SPR_HIOR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_hior, &spr_write_hior,\n\n                 0x00000000);\n\n    spr_register(env, SPR_CTRL, \"SPR_CTRL\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    spr_register(env, SPR_UCTRL, \"SPR_UCTRL\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    spr_register(env, SPR_VRSAVE, \"SPR_VRSAVE\",\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->slb_nr = 64;\n\n#endif\n\n    init_excp_970(env);\n\n    env->dcache_line_size = 128;\n\n    env->icache_line_size = 128;\n\n    /* Allocate hardware IRQ controller */\n\n    ppc970_irq_init(env);\n\n    /* Can't find information on what this should be on reset.  This\n\n     * value is the one used by 74xx processors. */\n\n    vscr_init(env, 0x00010000);\n\n}\n", "idx": 4760, "_split": "test", "_hash": "8ebe377f59e8bc60bc5f2538f8c13d38"}
{"project": "qemu", "commit_id": "a01aedc8d32e6f5b08a4041b62be3c5fab7a3382", "target": 1, "func": "void object_property_add_bool(Object *obj, const char *name,\n\n                              bool (*get)(Object *, Error **),\n\n                              void (*set)(Object *, bool, Error **),\n\n                              Error **errp)\n\n{\n\n    BoolProperty *prop = g_malloc0(sizeof(*prop));\n\n\n\n    prop->get = get;\n\n    prop->set = set;\n\n\n\n    object_property_add(obj, name, \"bool\",\n\n                        get ? property_get_bool : NULL,\n\n                        set ? property_set_bool : NULL,\n\n                        property_release_bool,\n\n                        prop, errp);\n\n}\n", "idx": 4768, "_split": "test", "_hash": "95eab13e99b0633db2fa4bc319773456"}
{"project": "qemu", "commit_id": "cd7fdfe59f4f965665dcd9868fe3764f5256d6aa", "target": 1, "func": "void virtio_blk_data_plane_stop(VirtIOBlockDataPlane *s)\n\n{\n\n    if (!s->started) {\n\n        return;\n\n    }\n\n    s->started = false;\n\n    trace_virtio_blk_data_plane_stop(s);\n\n\n\n    /* Stop thread or cancel pending thread creation BH */\n\n    if (s->start_bh) {\n\n        qemu_bh_delete(s->start_bh);\n\n        s->start_bh = NULL;\n\n    } else {\n\n        event_poll_notify(&s->event_poll);\n\n        qemu_thread_join(&s->thread);\n\n    }\n\n\n\n    ioq_cleanup(&s->ioqueue);\n\n\n\n    s->vdev->binding->set_host_notifier(s->vdev->binding_opaque, 0, false);\n\n\n\n    event_poll_cleanup(&s->event_poll);\n\n\n\n    /* Clean up guest notifier (irq) */\n\n    s->vdev->binding->set_guest_notifiers(s->vdev->binding_opaque, 1, false);\n\n\n\n    vring_teardown(&s->vring);\n\n}\n", "idx": 4770, "_split": "test", "_hash": "4250df750ec83131ff3912738c93f99f"}
{"project": "qemu", "commit_id": "b3f7f0c5e6449be7275f1762bccbfa2177395a3b", "target": 1, "func": "static void colo_process_checkpoint(MigrationState *s)\n{\n    QIOChannelBuffer *bioc;\n    QEMUFile *fb = NULL;\n    int64_t current_time, checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n    Error *local_err = NULL;\n    int ret;\n    failover_init_state();\n    s->rp_state.from_dst_file = qemu_file_get_return_path(s->to_dst_file);\n    if (!s->rp_state.from_dst_file) {\n        error_report(\"Open QEMUFile from_dst_file failed\");\n    /*\n     * Wait for Secondary finish loading VM states and enter COLO\n     * restore.\n     */\n    colo_receive_check_message(s->rp_state.from_dst_file,\n                       COLO_MESSAGE_CHECKPOINT_READY, &local_err);\n    if (local_err) {\n    bioc = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE);\n    fb = qemu_fopen_channel_output(QIO_CHANNEL(bioc));\n    object_unref(OBJECT(bioc));\n    qemu_mutex_lock_iothread();\n    vm_start();\n    qemu_mutex_unlock_iothread();\n    trace_colo_vm_state_change(\"stop\", \"run\");\n    while (s->state == MIGRATION_STATUS_COLO) {\n        current_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n        if (current_time - checkpoint_time <\n            s->parameters.x_checkpoint_delay) {\n            int64_t delay_ms;\n            delay_ms = s->parameters.x_checkpoint_delay -\n                       (current_time - checkpoint_time);\n            g_usleep(delay_ms * 1000);\n        ret = colo_do_checkpoint_transaction(s, bioc, fb);\n        if (ret < 0) {\n        checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\nout:\n    /* Throw the unreported error message after exited from loop */\n    if (local_err) {\n        error_report_err(local_err);\n    if (fb) {\n        qemu_fclose(fb);\n    if (s->rp_state.from_dst_file) {\n        qemu_fclose(s->rp_state.from_dst_file);", "idx": 4815, "_split": "test", "_hash": "62a0c930a1290b29a612480fc2a34e78"}
{"project": "qemu", "commit_id": "c97294ec1b9e36887e119589d456557d72ab37b5", "target": 0, "func": "static void pc_init1(QEMUMachineInitArgs *args,\n\n                     int pci_enabled,\n\n                     int kvmclock_enabled)\n\n{\n\n    MemoryRegion *system_memory = get_system_memory();\n\n    MemoryRegion *system_io = get_system_io();\n\n    int i;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size;\n\n    PCIBus *pci_bus;\n\n    ISABus *isa_bus;\n\n    PCII440FXState *i440fx_state;\n\n    int piix3_devfn = -1;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *gsi;\n\n    qemu_irq *i8259;\n\n    qemu_irq *smi_irq;\n\n    GSIState *gsi_state;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BusState *idebus[MAX_IDE_BUS];\n\n    ISADevice *rtc_state;\n\n    ISADevice *floppy;\n\n    MemoryRegion *ram_memory;\n\n    MemoryRegion *pci_memory;\n\n    MemoryRegion *rom_memory;\n\n    DeviceState *icc_bridge;\n\n    FWCfgState *fw_cfg = NULL;\n\n    PcGuestInfo *guest_info;\n\n\n\n    if (xen_enabled() && xen_hvm_init(&ram_memory) != 0) {\n\n        fprintf(stderr, \"xen hardware virtual machine initialisation failed\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    icc_bridge = qdev_create(NULL, TYPE_ICC_BRIDGE);\n\n    object_property_add_child(qdev_get_machine(), \"icc-bridge\",\n\n                              OBJECT(icc_bridge), NULL);\n\n\n\n    pc_cpus_init(args->cpu_model, icc_bridge);\n\n\n\n    if (kvm_enabled() && kvmclock_enabled) {\n\n        kvmclock_create();\n\n    }\n\n\n\n    /* Check whether RAM fits below 4G (leaving 1/2 GByte for IO memory).\n\n     * If it doesn't, we need to split it in chunks below and above 4G.\n\n     * In any case, try to make sure that guest addresses aligned at\n\n     * 1G boundaries get mapped to host addresses aligned at 1G boundaries.\n\n     * For old machine types, use whatever split we used historically to avoid\n\n     * breaking migration.\n\n     */\n\n    if (args->ram_size >= 0xe0000000) {\n\n        ram_addr_t lowmem = gigabyte_align ? 0xc0000000 : 0xe0000000;\n\n        above_4g_mem_size = args->ram_size - lowmem;\n\n        below_4g_mem_size = lowmem;\n\n    } else {\n\n        above_4g_mem_size = 0;\n\n        below_4g_mem_size = args->ram_size;\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_memory = g_new(MemoryRegion, 1);\n\n        memory_region_init(pci_memory, NULL, \"pci\", UINT64_MAX);\n\n        rom_memory = pci_memory;\n\n    } else {\n\n        pci_memory = NULL;\n\n        rom_memory = system_memory;\n\n    }\n\n\n\n    guest_info = pc_guest_info_init(below_4g_mem_size, above_4g_mem_size);\n\n\n\n    guest_info->has_acpi_build = has_acpi_build;\n\n\n\n    guest_info->has_pci_info = has_pci_info;\n\n    guest_info->isapc_ram_fw = !pci_enabled;\n\n\n\n    if (smbios_defaults) {\n\n        /* These values are guest ABI, do not change */\n\n        smbios_set_defaults(\"QEMU\", \"Standard PC (i440FX + PIIX, 1996)\",\n\n                            args->machine->name);\n\n    }\n\n\n\n    /* allocate ram and load rom/bios */\n\n    if (!xen_enabled()) {\n\n        fw_cfg = pc_memory_init(system_memory,\n\n                       args->kernel_filename, args->kernel_cmdline,\n\n                       args->initrd_filename,\n\n                       below_4g_mem_size, above_4g_mem_size,\n\n                       rom_memory, &ram_memory, guest_info);\n\n    }\n\n\n\n    gsi_state = g_malloc0(sizeof(*gsi_state));\n\n    if (kvm_irqchip_in_kernel()) {\n\n        kvm_pc_setup_irq_routing(pci_enabled);\n\n        gsi = qemu_allocate_irqs(kvm_pc_gsi_handler, gsi_state,\n\n                                 GSI_NUM_PINS);\n\n    } else {\n\n        gsi = qemu_allocate_irqs(gsi_handler, gsi_state, GSI_NUM_PINS);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, &isa_bus, gsi,\n\n                              system_memory, system_io, args->ram_size,\n\n                              below_4g_mem_size,\n\n                              above_4g_mem_size,\n\n                              pci_memory, ram_memory);\n\n    } else {\n\n        pci_bus = NULL;\n\n        i440fx_state = NULL;\n\n        isa_bus = isa_bus_new(NULL, system_io);\n\n        no_hpet = 1;\n\n    }\n\n    isa_bus_irqs(isa_bus, gsi);\n\n\n\n    if (kvm_irqchip_in_kernel()) {\n\n        i8259 = kvm_i8259_init(isa_bus);\n\n    } else if (xen_enabled()) {\n\n        i8259 = xen_interrupt_controller_init();\n\n    } else {\n\n        cpu_irq = pc_allocate_cpu_irq();\n\n        i8259 = i8259_init(isa_bus, cpu_irq[0]);\n\n    }\n\n\n\n    for (i = 0; i < ISA_NUM_IRQS; i++) {\n\n        gsi_state->i8259_irq[i] = i8259[i];\n\n    }\n\n    if (pci_enabled) {\n\n        ioapic_init_gsi(gsi_state, \"i440fx\");\n\n    }\n\n    qdev_init_nofail(icc_bridge);\n\n\n\n    pc_register_ferr_irq(gsi[13]);\n\n\n\n    pc_vga_init(isa_bus, pci_enabled ? pci_bus : NULL);\n\n\n\n    /* init basic PC hardware */\n\n    pc_basic_device_init(isa_bus, gsi, &rtc_state, &floppy, xen_enabled(),\n\n        0x4);\n\n\n\n    pc_nic_init(isa_bus, pci_bus);\n\n\n\n    ide_drive_get(hd, MAX_IDE_BUS);\n\n    if (pci_enabled) {\n\n        PCIDevice *dev;\n\n        if (xen_enabled()) {\n\n            dev = pci_piix3_xen_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        } else {\n\n            dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        }\n\n        idebus[0] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\");\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            ISADevice *dev;\n\n            char busname[] = \"ide.0\";\n\n            dev = isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i],\n\n                               ide_irq[i],\n\n                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n            /*\n\n             * The ide bus name is ide.0 for the first bus and ide.1 for the\n\n             * second one.\n\n             */\n\n            busname[4] = '0' + i;\n\n            idebus[i] = qdev_get_child_bus(DEVICE(dev), busname);\n\n        }\n\n    }\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, args->boot_order,\n\n                 floppy, idebus[0], idebus[1], rtc_state);\n\n\n\n    if (pci_enabled && usb_enabled(false)) {\n\n        pci_create_simple(pci_bus, piix3_devfn + 2, \"piix3-usb-uhci\");\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        I2CBus *smbus;\n\n\n\n        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              gsi[9], *smi_irq,\n\n                              kvm_enabled(), fw_cfg);\n\n        smbus_eeprom_init(smbus, 8, NULL, 0);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n}\n", "idx": 4835, "_split": "test", "_hash": "322c75439fbd2be009f16ab5c3b63402"}
{"project": "qemu", "commit_id": "4bb3893908385836410346725dd9e584dcd24836", "target": 0, "func": "uint32_t wm8750_adc_dat(void *opaque)\n\n{\n\n    WM8750State *s = (WM8750State *) opaque;\n\n    uint32_t *data;\n\n\n\n    if (s->idx_in >= sizeof(s->data_in))\n\n        wm8750_in_load(s);\n\n\n\n    data = (uint32_t *) &s->data_in[s->idx_in];\n\n    s->req_in -= 4;\n\n    s->idx_in += 4;\n\n    return *data;\n\n}\n", "idx": 4842, "_split": "test", "_hash": "940d7f622ddd92bcfd2263c24e730ad6"}
{"project": "qemu", "commit_id": "09e68369a88d7de0f988972bf28eec1b80cc47f9", "target": 0, "func": "static QmpInputVisitor *to_qiv(Visitor *v)\n\n{\n\n    return container_of(v, QmpInputVisitor, visitor);\n\n}\n", "idx": 4849, "_split": "test", "_hash": "c4014e77a3206d04285c03d5ecf3c622"}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void bonito_pcihost_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    k->init = bonito_pcihost_initfn;\n\n    dc->no_user = 1;\n\n}\n", "idx": 4874, "_split": "test", "_hash": "eb98259d747a92231116dfbd89ac0fe4"}
{"project": "qemu", "commit_id": "ad523590f62cf5d44e97388de370d27b95b25aff", "target": 0, "func": "void memory_region_iommu_replay_all(MemoryRegion *mr)\n\n{\n\n    IOMMUNotifier *notifier;\n\n\n\n    IOMMU_NOTIFIER_FOREACH(notifier, mr) {\n\n        memory_region_iommu_replay(mr, notifier, false);\n\n    }\n\n}\n", "idx": 4892, "_split": "test", "_hash": "d1a34fac5f66a17003a11d073a782341"}
{"project": "qemu", "commit_id": "dc638fadb54c911019227ae37656560c49a209b9", "target": 0, "func": "static int usb_uhci_piix3_initfn(PCIDevice *dev)\n\n{\n\n    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);\n\n    uint8_t *pci_conf = s->dev.config;\n\n\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);\n\n    return usb_uhci_common_initfn(s);\n\n}\n", "idx": 4893, "_split": "test", "_hash": "521c9d6d5f739e769e1a930307ff1dbf"}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_addi_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tDIS(fprintf (logfile, \"addi.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));\n\n\tcris_cc_mask(dc, 0);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\ttcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));\n\n\ttcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n", "idx": 4899, "_split": "test", "_hash": "71cdc292108753868f74723de159011e"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_trap (DisasContext *ctx, uint32_t opc,\n\n                      int rs, int rt, int16_t imm)\n\n{\n\n    int cond;\n\n    TCGv t0 = tcg_temp_new();\n\n    TCGv t1 = tcg_temp_new();\n\n\n\n    cond = 0;\n\n    /* Load needed operands */\n\n    switch (opc) {\n\n    case OPC_TEQ:\n\n    case OPC_TGE:\n\n    case OPC_TGEU:\n\n    case OPC_TLT:\n\n    case OPC_TLTU:\n\n    case OPC_TNE:\n\n        /* Compare two registers */\n\n        if (rs != rt) {\n\n            gen_load_gpr(t0, rs);\n\n            gen_load_gpr(t1, rt);\n\n            cond = 1;\n\n        }\n\n        break;\n\n    case OPC_TEQI:\n\n    case OPC_TGEI:\n\n    case OPC_TGEIU:\n\n    case OPC_TLTI:\n\n    case OPC_TLTIU:\n\n    case OPC_TNEI:\n\n        /* Compare register to immediate */\n\n        if (rs != 0 || imm != 0) {\n\n            gen_load_gpr(t0, rs);\n\n            tcg_gen_movi_tl(t1, (int32_t)imm);\n\n            cond = 1;\n\n        }\n\n        break;\n\n    }\n\n    if (cond == 0) {\n\n        switch (opc) {\n\n        case OPC_TEQ:   /* rs == rs */\n\n        case OPC_TEQI:  /* r0 == 0  */\n\n        case OPC_TGE:   /* rs >= rs */\n\n        case OPC_TGEI:  /* r0 >= 0  */\n\n        case OPC_TGEU:  /* rs >= rs unsigned */\n\n        case OPC_TGEIU: /* r0 >= 0  unsigned */\n\n            /* Always trap */\n\n            generate_exception(ctx, EXCP_TRAP);\n\n            break;\n\n        case OPC_TLT:   /* rs < rs           */\n\n        case OPC_TLTI:  /* r0 < 0            */\n\n        case OPC_TLTU:  /* rs < rs unsigned  */\n\n        case OPC_TLTIU: /* r0 < 0  unsigned  */\n\n        case OPC_TNE:   /* rs != rs          */\n\n        case OPC_TNEI:  /* r0 != 0           */\n\n            /* Never trap: treat as NOP. */\n\n            break;\n\n        }\n\n    } else {\n\n        int l1 = gen_new_label();\n\n\n\n        switch (opc) {\n\n        case OPC_TEQ:\n\n        case OPC_TEQI:\n\n            tcg_gen_brcond_tl(TCG_COND_NE, t0, t1, l1);\n\n            break;\n\n        case OPC_TGE:\n\n        case OPC_TGEI:\n\n            tcg_gen_brcond_tl(TCG_COND_LT, t0, t1, l1);\n\n            break;\n\n        case OPC_TGEU:\n\n        case OPC_TGEIU:\n\n            tcg_gen_brcond_tl(TCG_COND_LTU, t0, t1, l1);\n\n            break;\n\n        case OPC_TLT:\n\n        case OPC_TLTI:\n\n            tcg_gen_brcond_tl(TCG_COND_GE, t0, t1, l1);\n\n            break;\n\n        case OPC_TLTU:\n\n        case OPC_TLTIU:\n\n            tcg_gen_brcond_tl(TCG_COND_GEU, t0, t1, l1);\n\n            break;\n\n        case OPC_TNE:\n\n        case OPC_TNEI:\n\n            tcg_gen_brcond_tl(TCG_COND_EQ, t0, t1, l1);\n\n            break;\n\n        }\n\n        generate_exception(ctx, EXCP_TRAP);\n\n        gen_set_label(l1);\n\n    }\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n", "idx": 4924, "_split": "test", "_hash": "3d84259c4fd1576264fb1fc87707ab77"}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static uint64_t pxa2xx_gpio_read(void *opaque, hwaddr offset,\n\n                                 unsigned size)\n\n{\n\n    PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque;\n\n    uint32_t ret;\n\n    int bank;\n\n    if (offset >= 0x200)\n\n        return 0;\n\n\n\n    bank = pxa2xx_gpio_regs[offset].bank;\n\n    switch (pxa2xx_gpio_regs[offset].reg) {\n\n    case GPDR:\t\t/* GPIO Pin-Direction registers */\n\n        return s->dir[bank];\n\n\n\n    case GPSR:\t\t/* GPIO Pin-Output Set registers */\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"pxa2xx GPIO: read from write only register GPSR\\n\");\n\n        return 0;\n\n\n\n    case GPCR:\t\t/* GPIO Pin-Output Clear registers */\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"pxa2xx GPIO: read from write only register GPCR\\n\");\n\n        return 0;\n\n\n\n    case GRER:\t\t/* GPIO Rising-Edge Detect Enable registers */\n\n        return s->rising[bank];\n\n\n\n    case GFER:\t\t/* GPIO Falling-Edge Detect Enable registers */\n\n        return s->falling[bank];\n\n\n\n    case GAFR_L:\t/* GPIO Alternate Function registers */\n\n        return s->gafr[bank * 2];\n\n\n\n    case GAFR_U:\t/* GPIO Alternate Function registers */\n\n        return s->gafr[bank * 2 + 1];\n\n\n\n    case GPLR:\t\t/* GPIO Pin-Level registers */\n\n        ret = (s->olevel[bank] & s->dir[bank]) |\n\n                (s->ilevel[bank] & ~s->dir[bank]);\n\n        qemu_irq_raise(s->read_notify);\n\n        return ret;\n\n\n\n    case GEDR:\t\t/* GPIO Edge Detect Status registers */\n\n        return s->status[bank];\n\n\n\n    default:\n\n        hw_error(\"%s: Bad offset \" REG_FMT \"\\n\", __FUNCTION__, offset);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4961, "_split": "test", "_hash": "c7d31abc4f80ecf62e4e16fb18fe68a6"}
{"project": "qemu", "commit_id": "1964a397063967acc5ce71a2a24ed26e74824ee1", "target": 0, "func": "static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)\n\n{\n\n    MigrationState *s = opaque;\n\n    if (qemu_file_get_error(s->file)) {\n\n        goto out;\n\n    }\n\n\n\n    s->xfer_limit = new_rate;\n\n\n\nout:\n\n    return s->xfer_limit;\n\n}\n", "idx": 5035, "_split": "test", "_hash": "a56f99822d0ed5ee84850ccfbdc32e87"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void scsi_disk_reset(DeviceState *dev)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);\n\n    uint64_t nb_sectors;\n\n\n\n    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));\n\n\n\n    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n    nb_sectors /= s->qdev.blocksize / 512;\n\n    if (nb_sectors) {\n\n        nb_sectors--;\n\n    }\n\n    s->qdev.max_lba = nb_sectors;\n\n    /* reset tray statuses */\n\n    s->tray_locked = 0;\n\n    s->tray_open = 0;\n\n}\n", "idx": 5054, "_split": "test", "_hash": "86b8dc741c9855d278b7c6d5174639da"}
{"project": "qemu", "commit_id": "955cc8c9541779e09895a9c5ccbf8ace15d884f5", "target": 0, "func": "static int virtio_ccw_set_vqs(SubchDev *sch, uint64_t addr, uint32_t align,\n\n                              uint16_t index, uint16_t num)\n\n{\n\n    VirtIODevice *vdev = virtio_ccw_get_vdev(sch);\n\n\n\n    if (index >= VIRTIO_PCI_QUEUE_MAX) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Current code in virtio.c relies on 4K alignment. */\n\n    if (addr && (align != 4096)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (!vdev) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    virtio_queue_set_addr(vdev, index, addr);\n\n    if (!addr) {\n\n        virtio_queue_set_vector(vdev, index, 0);\n\n    } else {\n\n        /* Fail if we don't have a big enough queue. */\n\n        /* TODO: Add interface to handle vring.num changing */\n\n        if (virtio_queue_get_num(vdev, index) > num) {\n\n            return -EINVAL;\n\n        }\n\n        virtio_queue_set_vector(vdev, index, index);\n\n    }\n\n    /* tell notify handler in case of config change */\n\n    vdev->config_vector = VIRTIO_PCI_QUEUE_MAX;\n\n    return 0;\n\n}\n", "idx": 5093, "_split": "test", "_hash": "eefd4a3617c446a9c4c81f9c94c3bc45"}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void rtl8139_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    rtl8139_do_receive(opaque, buf, size, 1);\n\n}\n", "idx": 5099, "_split": "test", "_hash": "d197423f19cebd1cb0fa2166e0c77e86"}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)\n\n{\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||\n\n        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||\n\n        (fs_ctx->export_flags & V9FS_SM_NONE)) {\n\n        return lchown(rpath(fs_ctx, path, buffer),\n\n                      credp->fc_uid, credp->fc_gid);\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {\n\n        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        return local_set_mapped_file_attr(fs_ctx, path, credp);\n\n    }\n\n    return -1;\n\n}\n", "idx": 5102, "_split": "test", "_hash": "f1857e5efca7098405d178bf926547d4"}
{"project": "qemu", "commit_id": "ff9d38963e55598b40237735426225c35de6c7e5", "target": 0, "func": "static void qdict_crumple_test_recursive(void)\n\n{\n\n    QDict *src, *dst, *rule, *vnc, *acl, *listen;\n\n    QObject *child, *res;\n\n    QList *rules;\n\n\n\n    src = qdict_new();\n\n    qdict_put(src, \"vnc.listen.addr\", qstring_from_str(\"127.0.0.1\"));\n\n    qdict_put(src, \"vnc.listen.port\", qstring_from_str(\"5901\"));\n\n    qdict_put(src, \"vnc.acl.rules.0.match\", qstring_from_str(\"fred\"));\n\n    qdict_put(src, \"vnc.acl.rules.0.policy\", qstring_from_str(\"allow\"));\n\n    qdict_put(src, \"vnc.acl.rules.1.match\", qstring_from_str(\"bob\"));\n\n    qdict_put(src, \"vnc.acl.rules.1.policy\", qstring_from_str(\"deny\"));\n\n    qdict_put(src, \"vnc.acl.default\", qstring_from_str(\"deny\"));\n\n    qdict_put(src, \"vnc.acl..name\", qstring_from_str(\"acl0\"));\n\n    qdict_put(src, \"vnc.acl.rule..name\", qstring_from_str(\"acl0\"));\n\n\n\n    res = qdict_crumple(src, &error_abort);\n\n\n\n    g_assert_cmpint(qobject_type(res), ==, QTYPE_QDICT);\n\n\n\n    dst = qobject_to_qdict(res);\n\n\n\n    g_assert_cmpint(qdict_size(dst), ==, 1);\n\n\n\n    child = qdict_get(dst, \"vnc\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    vnc = qobject_to_qdict(child);\n\n\n\n    child = qdict_get(vnc, \"listen\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    listen = qobject_to_qdict(child);\n\n    g_assert_cmpstr(\"127.0.0.1\", ==, qdict_get_str(listen, \"addr\"));\n\n    g_assert_cmpstr(\"5901\", ==, qdict_get_str(listen, \"port\"));\n\n\n\n    child = qdict_get(vnc, \"acl\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    acl = qobject_to_qdict(child);\n\n\n\n    child = qdict_get(acl, \"rules\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QLIST);\n\n    rules = qobject_to_qlist(child);\n\n    g_assert_cmpint(qlist_size(rules), ==, 2);\n\n\n\n    rule = qobject_to_qdict(qlist_pop(rules));\n\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n\n    g_assert_cmpstr(\"fred\", ==, qdict_get_str(rule, \"match\"));\n\n    g_assert_cmpstr(\"allow\", ==, qdict_get_str(rule, \"policy\"));\n\n    QDECREF(rule);\n\n\n\n    rule = qobject_to_qdict(qlist_pop(rules));\n\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n\n    g_assert_cmpstr(\"bob\", ==, qdict_get_str(rule, \"match\"));\n\n    g_assert_cmpstr(\"deny\", ==, qdict_get_str(rule, \"policy\"));\n\n    QDECREF(rule);\n\n\n\n    /* With recursive crumpling, we should see all names unescaped */\n\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(vnc, \"acl.name\"));\n\n    child = qdict_get(vnc, \"acl\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    acl = qdict_get_qdict(vnc, \"acl\");\n\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(acl, \"rule.name\"));\n\n\n\n    QDECREF(src);\n\n    QDECREF(dst);\n\n}\n", "idx": 5104, "_split": "test", "_hash": "881ce01ed67fa2d52331aa5fa72d9657"}
{"project": "qemu", "commit_id": "68ab47e4b4ecc1c4649362b8cc1e49794d1a6537", "target": 1, "func": "static void test_validate_fail_alternate(TestInputVisitorData *data,\n\n                                         const void *unused)\n\n{\n\n    UserDefAlternate *tmp;\n\n    Visitor *v;\n\n    Error *err = NULL;\n\n\n\n    v = validate_test_init(data, \"3.14\");\n\n\n\n    visit_type_UserDefAlternate(v, NULL, &tmp, &err);\n\n    error_free_or_abort(&err);\n\n    qapi_free_UserDefAlternate(tmp);\n\n}\n", "idx": 5121, "_split": "test", "_hash": "77c1b0259ff1623b0338ec477e0541db"}
{"project": "qemu", "commit_id": "c95de7e2c40da4235ceda6d134ae069dae80157e", "target": 1, "func": "static int qcow2_co_flush(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int ret;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n\n        return ret;\n\n    }\n\n\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n    if (ret < 0) {\n\n\n        return ret;\n\n    }\n\n\n\n\n    return bdrv_co_flush(bs->file);\n\n}", "idx": 5129, "_split": "test", "_hash": "ca0f537c925ceb1e34dc434d82dd8093"}
{"project": "qemu", "commit_id": "df8ad9f128c15aa0a0ebc7b24e9a22c9775b67af", "target": 1, "func": "static int nbd_can_accept(void)\n\n{\n\n    return nb_fds < shared;\n\n}\n", "idx": 5171, "_split": "test", "_hash": "f5aba9a8e872da0f85f21cbd64c4d572"}
{"project": "qemu", "commit_id": "b4f72e31b924bec2c18fe0b2a8c6462dbed9dcb2", "target": 1, "func": "static int net_connect(struct XenDevice *xendev)\n\n{\n\n    struct XenNetDev *netdev = container_of(xendev, struct XenNetDev, xendev);\n\n    int rx_copy;\n\n\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"tx-ring-ref\",\n\n                             &netdev->tx_ring_ref) == -1) {\n\n        return -1;\n\n    }\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"rx-ring-ref\",\n\n                             &netdev->rx_ring_ref) == -1) {\n\n        return 1;\n\n    }\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"event-channel\",\n\n                             &netdev->xendev.remote_port) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"request-rx-copy\", &rx_copy) == -1) {\n\n        rx_copy = 0;\n\n    }\n\n    if (rx_copy == 0) {\n\n        xen_be_printf(&netdev->xendev, 0, \"frontend doesn't support rx-copy.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    netdev->txs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,\n\n                                          netdev->xendev.dom,\n\n                                          netdev->tx_ring_ref,\n\n                                          PROT_READ | PROT_WRITE);\n\n    netdev->rxs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,\n\n                                          netdev->xendev.dom,\n\n                                          netdev->rx_ring_ref,\n\n                                          PROT_READ | PROT_WRITE);\n\n    if (!netdev->txs || !netdev->rxs) {\n\n        return -1;\n\n    }\n\n    BACK_RING_INIT(&netdev->tx_ring, netdev->txs, XC_PAGE_SIZE);\n\n    BACK_RING_INIT(&netdev->rx_ring, netdev->rxs, XC_PAGE_SIZE);\n\n\n\n    xen_be_bind_evtchn(&netdev->xendev);\n\n\n\n    xen_be_printf(&netdev->xendev, 1, \"ok: tx-ring-ref %d, rx-ring-ref %d, \"\n\n                  \"remote port %d, local port %d\\n\",\n\n                  netdev->tx_ring_ref, netdev->rx_ring_ref,\n\n                  netdev->xendev.remote_port, netdev->xendev.local_port);\n\n\n\n    net_tx_packets(netdev);\n\n    return 0;\n\n}\n", "idx": 5172, "_split": "test", "_hash": "af2d450a7c72cd68c1c1fe16056c3932"}
{"project": "qemu", "commit_id": "5ee5993001cf32addb86a92e2ae8cb090fbc1462", "target": 1, "func": "static bool do_modify_softint(CPUSPARCState *env, uint32_t value)\n\n{\n\n    if (env->softint != value) {\n\n        env->softint = value;\n\n#if !defined(CONFIG_USER_ONLY)\n\n        if (cpu_interrupts_enabled(env)) {\n\n\n            cpu_check_irqs(env);\n\n\n        }\n\n#endif\n\n        return true;\n\n    }\n\n    return false;\n\n}", "idx": 5174, "_split": "test", "_hash": "7583287fc4fbad30929529a357527df7"}
{"project": "qemu", "commit_id": "3401c0d95ffb9a9a57093ee002d24d014ffed4f8", "target": 1, "func": "static void do_send_key(const char *string)\n\n{\n\n    char keybuf[16], *q;\n\n    uint8_t keycodes[16];\n\n    const char *p;\n\n    int nb_keycodes, keycode, i;\n\n\n\n    nb_keycodes = 0;\n\n    p = string;\n\n    while (*p != '\\0') {\n\n        q = keybuf;\n\n        while (*p != '\\0' && *p != '-') {\n\n            if ((q - keybuf) < sizeof(keybuf) - 1) {\n\n                *q++ = *p;\n\n            }\n\n            p++;\n\n        }\n\n        *q = '\\0';\n\n        keycode = get_keycode(keybuf);\n\n        if (keycode < 0) {\n\n            term_printf(\"unknown key: '%s'\\n\", keybuf);\n\n            return;\n\n        }\n\n        keycodes[nb_keycodes++] = keycode;\n\n        if (*p == '\\0')\n\n            break;\n\n        p++;\n\n    }\n\n    /* key down events */\n\n    for(i = 0; i < nb_keycodes; i++) {\n\n        keycode = keycodes[i];\n\n        if (keycode & 0x80)\n\n            kbd_put_keycode(0xe0);\n\n        kbd_put_keycode(keycode & 0x7f);\n\n    }\n\n    /* key up events */\n\n    for(i = nb_keycodes - 1; i >= 0; i--) {\n\n        keycode = keycodes[i];\n\n        if (keycode & 0x80)\n\n            kbd_put_keycode(0xe0);\n\n        kbd_put_keycode(keycode | 0x80);\n\n    }\n\n}\n", "idx": 5191, "_split": "test", "_hash": "2da6082d0c9322973913bdf85964c040"}
{"project": "qemu", "commit_id": "5d39c799c3245244ebb1e89da0177dbc089962b2", "target": 0, "func": "void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    double d;\n\n    char *ptr;\n\n    FdMigrationState *s;\n\n    const char *value = qdict_get_str(qdict, \"value\");\n\n\n\n    d = strtod(value, &ptr);\n\n    switch (*ptr) {\n\n    case 'G': case 'g':\n\n        d *= 1024;\n\n    case 'M': case 'm':\n\n        d *= 1024;\n\n    case 'K': case 'k':\n\n        d *= 1024;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    max_throttle = (uint32_t)d;\n\n    s = migrate_to_fms(current_migration);\n\n\n\n    if (s) {\n\n        qemu_file_set_rate_limit(s->file, max_throttle);\n\n    }\n\n    \n\n}\n", "idx": 5198, "_split": "test", "_hash": "c1cc4bc27a1ed9a756ccd4faf4a0dd87"}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_efdneg(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);\n\n#else\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);\n\n#endif\n\n}\n", "idx": 5201, "_split": "test", "_hash": "1950db3ce1b5548f1ab1b5ddd7909abd"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_srlq(DisasContext *ctx)\n\n{\n\n    int l1 = gen_new_label();\n\n    int l2 = gen_new_label();\n\n    TCGv t0 = tcg_temp_local_new();\n\n    TCGv t1 = tcg_temp_local_new();\n\n    TCGv t2 = tcg_temp_local_new();\n\n    tcg_gen_andi_tl(t2, cpu_gpr[rB(ctx->opcode)], 0x1F);\n\n    tcg_gen_movi_tl(t1, 0xFFFFFFFF);\n\n    tcg_gen_shr_tl(t2, t1, t2);\n\n    tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20);\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);\n\n    gen_load_spr(t0, SPR_MQ);\n\n    tcg_gen_and_tl(cpu_gpr[rA(ctx->opcode)], t0, t2);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], t2);\n\n    tcg_gen_and_tl(t0, t0, t2);\n\n    gen_load_spr(t1, SPR_MQ);\n\n    tcg_gen_andc_tl(t1, t1, t2);\n\n    tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1);\n\n    gen_set_label(l2);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(t2);\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);\n\n}\n", "idx": 5219, "_split": "test", "_hash": "a3947807b00169d83475f48ee93fdbbb"}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n\n{\n\n    VirtQueueElement elem;\n\n    VirtQueue *vq;\n\n\n\n    vq = vser->c_ivq;\n\n    if (!virtio_queue_ready(vq)) {\n\n        return 0;\n\n    }\n\n    if (!virtqueue_pop(vq, &elem)) {\n\n        return 0;\n\n    }\n\n\n\n    /* TODO: detect a buffer that's too short, set NEEDS_RESET */\n\n    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);\n\n\n\n    virtqueue_push(vq, &elem, len);\n\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n\n    return len;\n\n}\n", "idx": 5222, "_split": "test", "_hash": "2e664dd67c784861f42bae5ca084c1e9"}
{"project": "qemu", "commit_id": "9a10bbb4e83b184faef6fa744396a6775283c0aa", "target": 0, "func": "void ich9_pm_init(PCIDevice *lpc_pci, ICH9LPCPMRegs *pm,\n\n                  qemu_irq sci_irq)\n\n{\n\n    memory_region_init(&pm->io, OBJECT(lpc_pci), \"ich9-pm\", ICH9_PMIO_SIZE);\n\n    memory_region_set_enabled(&pm->io, false);\n\n    memory_region_add_subregion(pci_address_space_io(lpc_pci),\n\n                                0, &pm->io);\n\n\n\n    acpi_pm_tmr_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_evt_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_cnt_init(&pm->acpi_regs, &pm->io, pm->s4_val);\n\n\n\n    acpi_gpe_init(&pm->acpi_regs, ICH9_PMIO_GPE0_LEN);\n\n    memory_region_init_io(&pm->io_gpe, OBJECT(lpc_pci), &ich9_gpe_ops, pm,\n\n                          \"acpi-gpe0\", ICH9_PMIO_GPE0_LEN);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_GPE0_STS, &pm->io_gpe);\n\n\n\n    memory_region_init_io(&pm->io_smi, OBJECT(lpc_pci), &ich9_smi_ops, pm,\n\n                          \"acpi-smi\", 8);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_SMI_EN, &pm->io_smi);\n\n\n\n    pm->irq = sci_irq;\n\n    qemu_register_reset(pm_reset, pm);\n\n    pm->powerdown_notifier.notify = pm_powerdown_req;\n\n    qemu_register_powerdown_notifier(&pm->powerdown_notifier);\n\n\n\n    acpi_cpu_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),\n\n                          &pm->gpe_cpu, ICH9_CPU_HOTPLUG_IO_BASE);\n\n\n\n    if (pm->acpi_memory_hotplug.is_enabled) {\n\n        acpi_memory_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),\n\n                                 &pm->acpi_memory_hotplug);\n\n    }\n\n}\n", "idx": 5229, "_split": "test", "_hash": "4e9927b20c6c6d7b1b64a46bd4bc8196"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)\n\n{\n\n    uint8_t ret;\n\n\n\n    OMAP_8B_REG(addr);\n\n    cpu_physical_memory_read(addr, (void *) &ret, 1);\n\n    return ret;\n\n}\n", "idx": 5250, "_split": "test", "_hash": "8efac6068a4d62a88173aed20a6f8ce7"}
{"project": "qemu", "commit_id": "af7e9e74c6a62a5bcd911726a9e88d28b61490e0", "target": 1, "func": "static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)\n\n{\n\n    q->pending++;\n\n    set_bit(q->queue, n_IRQ);\n\n}\n", "idx": 5263, "_split": "test", "_hash": "d5d36eef7e255d48413b8885b0f869bf"}
{"project": "qemu", "commit_id": "b2dfd71c4843a762f2befe702adb249cf55baf66", "target": 0, "func": "static void vhost_log_stop(MemoryListener *listener,\n\n                           MemoryRegionSection *section)\n\n{\n\n    /* FIXME: implement */\n\n}\n", "idx": 5283, "_split": "test", "_hash": "2e8c70fe5013061b6041f9febfe00ed5"}
{"project": "qemu", "commit_id": "79853e18d904b0a4bcef62701d48559688007c93", "target": 0, "func": "static void spapr_hotplug_req_event(sPAPRDRConnector *drc, uint8_t hp_action)\n\n{\n\n    struct hp_log_full *new_hp;\n\n    struct rtas_error_log *hdr;\n\n    struct rtas_event_log_v6 *v6hdr;\n\n    struct rtas_event_log_v6_maina *maina;\n\n    struct rtas_event_log_v6_mainb *mainb;\n\n    struct rtas_event_log_v6_hp *hp;\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n    sPAPRDRConnectorType drc_type = drck->get_type(drc);\n\n\n\n    new_hp = g_malloc0(sizeof(struct hp_log_full));\n\n    hdr = &new_hp->hdr;\n\n    v6hdr = &new_hp->v6hdr;\n\n    maina = &new_hp->maina;\n\n    mainb = &new_hp->mainb;\n\n    hp = &new_hp->hp;\n\n\n\n    hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6\n\n                               | RTAS_LOG_SEVERITY_EVENT\n\n                               | RTAS_LOG_DISPOSITION_NOT_RECOVERED\n\n                               | RTAS_LOG_OPTIONAL_PART_PRESENT\n\n                               | RTAS_LOG_INITIATOR_HOTPLUG\n\n                               | RTAS_LOG_TYPE_HOTPLUG);\n\n    hdr->extended_length = cpu_to_be32(sizeof(*new_hp)\n\n                                       - sizeof(new_hp->hdr));\n\n\n\n    spapr_init_v6hdr(v6hdr);\n\n    spapr_init_maina(maina, 3 /* Main-A, Main-B, HP */);\n\n\n\n    mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB);\n\n    mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb));\n\n    mainb->subsystem_id = 0x80; /* External environment */\n\n    mainb->event_severity = 0x00; /* Informational / non-error */\n\n    mainb->event_subtype = 0x00; /* Normal shutdown */\n\n\n\n    hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG);\n\n    hp->hdr.section_length = cpu_to_be16(sizeof(*hp));\n\n    hp->hdr.section_version = 1; /* includes extended modifier */\n\n    hp->hotplug_action = hp_action;\n\n\n\n\n\n    switch (drc_type) {\n\n    case SPAPR_DR_CONNECTOR_TYPE_PCI:\n\n        hp->drc.index = cpu_to_be32(drck->get_index(drc));\n\n        hp->hotplug_identifier = RTAS_LOG_V6_HP_ID_DRC_INDEX;\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI;\n\n        break;\n\n    default:\n\n        /* we shouldn't be signaling hotplug events for resources\n\n         * that don't support them\n\n         */\n\n        g_assert(false);\n\n        return;\n\n    }\n\n\n\n    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp);\n\n\n\n    qemu_irq_pulse(xics_get_qirq(spapr->icp, spapr->check_exception_irq));\n\n}\n", "idx": 5298, "_split": "test", "_hash": "345e11ea415a42910ac17c5f7ce606dd"}
{"project": "qemu", "commit_id": "425532d71d5d295cc9c649500e4969ac621ce51d", "target": 0, "func": "static TCGReg tcg_out_tlb_load(TCGContext *s, TCGReg addr, int mem_index,\n\n                               TCGMemOp s_bits, int which)\n\n{\n\n    const TCGReg r0 = TCG_REG_O0;\n\n    const TCGReg r1 = TCG_REG_O1;\n\n    const TCGReg r2 = TCG_REG_O2;\n\n    int tlb_ofs;\n\n\n\n    /* Shift the page number down.  */\n\n    tcg_out_arithi(s, r1, addr, TARGET_PAGE_BITS, SHIFT_SRL);\n\n\n\n    /* Mask out the page offset, except for the required alignment.  */\n\n    tcg_out_movi(s, TCG_TYPE_TL, TCG_REG_T1,\n\n                 TARGET_PAGE_MASK | ((1 << s_bits) - 1));\n\n\n\n    /* Mask the tlb index.  */\n\n    tcg_out_arithi(s, r1, r1, CPU_TLB_SIZE - 1, ARITH_AND);\n\n    \n\n    /* Mask page, part 2.  */\n\n    tcg_out_arith(s, r0, addr, TCG_REG_T1, ARITH_AND);\n\n\n\n    /* Shift the tlb index into place.  */\n\n    tcg_out_arithi(s, r1, r1, CPU_TLB_ENTRY_BITS, SHIFT_SLL);\n\n\n\n    /* Relative to the current ENV.  */\n\n    tcg_out_arith(s, r1, TCG_AREG0, r1, ARITH_ADD);\n\n\n\n    /* Find a base address that can load both tlb comparator and addend.  */\n\n    tlb_ofs = offsetof(CPUArchState, tlb_table[mem_index][0]);\n\n    if (!check_fit_tl(tlb_ofs + sizeof(CPUTLBEntry), 13)) {\n\n        tcg_out_addi(s, r1, tlb_ofs & ~0x3ff);\n\n        tlb_ofs &= 0x3ff;\n\n    }\n\n\n\n    /* Load the tlb comparator and the addend.  */\n\n    tcg_out_ld(s, TCG_TYPE_TL, r2, r1, tlb_ofs + which);\n\n    tcg_out_ld(s, TCG_TYPE_PTR, r1, r1, tlb_ofs+offsetof(CPUTLBEntry, addend));\n\n\n\n    /* subcc arg0, arg2, %g0 */\n\n    tcg_out_cmp(s, r0, r2, 0);\n\n\n\n    /* If the guest address must be zero-extended, do so now.  */\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, r0, addr, 0, SHIFT_SRL);\n\n        return r0;\n\n    }\n\n    return addr;\n\n}\n", "idx": 5304, "_split": "test", "_hash": "0f868a71fd7da3937c64b26bb6215638"}
{"project": "qemu", "commit_id": "838ef602498b8d1985a231a06f5e328e2946a81d", "target": 0, "func": "static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,\n\n                        void *s, void *sp)\n\n{\n\n    DPRINTF(\"CURL (AIO): Sock action %d on fd %d\\n\", action, fd);\n\n    switch (action) {\n\n        case CURL_POLL_IN:\n\n            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);\n\n            break;\n\n        case CURL_POLL_OUT:\n\n            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);\n\n            break;\n\n        case CURL_POLL_INOUT:\n\n            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);\n\n            break;\n\n        case CURL_POLL_REMOVE:\n\n            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);\n\n            break;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 5306, "_split": "test", "_hash": "a69dbb0275f047e6440a6cb297fe6fab"}
{"project": "qemu", "commit_id": "e5f34cdd2da54f28d90889a3afd15fad2d6105ff", "target": 1, "func": "static void vnc_set_share_mode(VncState *vs, VncShareMode mode)\n\n{\n\n#ifdef _VNC_DEBUG\n\n    static const char *mn[] = {\n\n        [0]                           = \"undefined\",\n\n        [VNC_SHARE_MODE_CONNECTING]   = \"connecting\",\n\n        [VNC_SHARE_MODE_SHARED]       = \"shared\",\n\n        [VNC_SHARE_MODE_EXCLUSIVE]    = \"exclusive\",\n\n        [VNC_SHARE_MODE_DISCONNECTED] = \"disconnected\",\n\n    };\n\n    fprintf(stderr, \"%s/%d: %s -> %s\\n\", __func__,\n\n            vs->csock, mn[vs->share_mode], mn[mode]);\n\n#endif\n\n\n\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n        vs->vd->num_exclusive--;\n\n    }\n\n    vs->share_mode = mode;\n\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n        vs->vd->num_exclusive++;\n\n    }\n\n}\n", "idx": 5314, "_split": "test", "_hash": "49b1246bc1aca95665d9c1646b5a7a30"}
{"project": "qemu", "commit_id": "0752706de257b38763006ff5bb6b39a97e669ba2", "target": 1, "func": "static void slirp_smb(SlirpState* s, Monitor *mon, const char *exported_dir,\n\n                      struct in_addr vserver_addr)\n\n{\n\n    static int instance;\n\n    char smb_conf[128];\n\n    char smb_cmdline[128];\n\n    FILE *f;\n\n\n\n    snprintf(s->smb_dir, sizeof(s->smb_dir), \"/tmp/qemu-smb.%ld-%d\",\n\n             (long)getpid(), instance++);\n\n    if (mkdir(s->smb_dir, 0700) < 0) {\n\n        config_error(mon, \"could not create samba server dir '%s'\\n\",\n\n                     s->smb_dir);\n\n        return;\n\n    }\n\n    snprintf(smb_conf, sizeof(smb_conf), \"%s/%s\", s->smb_dir, \"smb.conf\");\n\n\n\n    f = fopen(smb_conf, \"w\");\n\n    if (!f) {\n\n        slirp_smb_cleanup(s);\n\n        config_error(mon, \"could not create samba server \"\n\n                     \"configuration file '%s'\\n\", smb_conf);\n\n        return;\n\n    }\n\n    fprintf(f,\n\n            \"[global]\\n\"\n\n            \"private dir=%s\\n\"\n\n            \"smb ports=0\\n\"\n\n            \"socket address=127.0.0.1\\n\"\n\n            \"pid directory=%s\\n\"\n\n            \"lock directory=%s\\n\"\n\n            \"log file=%s/log.smbd\\n\"\n\n            \"smb passwd file=%s/smbpasswd\\n\"\n\n            \"security = share\\n\"\n\n            \"[qemu]\\n\"\n\n            \"path=%s\\n\"\n\n            \"read only=no\\n\"\n\n            \"guest ok=yes\\n\",\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            exported_dir\n\n            );\n\n    fclose(f);\n\n\n\n    snprintf(smb_cmdline, sizeof(smb_cmdline), \"%s -s %s\",\n\n             SMBD_COMMAND, smb_conf);\n\n\n\n    if (slirp_add_exec(s->slirp, 0, smb_cmdline, &vserver_addr, 139) < 0) {\n\n        slirp_smb_cleanup(s);\n\n        config_error(mon, \"conflicting/invalid smbserver address\\n\");\n\n    }\n\n}\n", "idx": 5361, "_split": "test", "_hash": "b08836dcd7198cf6ddd7f16f7cf82868"}
{"project": "qemu", "commit_id": "bf298f83c35da854632c5be75733a4aa95a780bf", "target": 0, "func": "void tlb_set_page(CPUState *env, target_ulong vaddr,\n\n                  target_phys_addr_t paddr, int prot,\n\n                  int mmu_idx, target_ulong size)\n\n{\n\n    PhysPageDesc *p;\n\n    unsigned long pd;\n\n    unsigned int index;\n\n    target_ulong address;\n\n    target_ulong code_address;\n\n    unsigned long addend;\n\n    CPUTLBEntry *te;\n\n    CPUWatchpoint *wp;\n\n    target_phys_addr_t iotlb;\n\n\n\n    assert(size >= TARGET_PAGE_SIZE);\n\n    if (size != TARGET_PAGE_SIZE) {\n\n        tlb_add_large_page(env, vaddr, size);\n\n    }\n\n    p = phys_page_find(paddr >> TARGET_PAGE_BITS);\n\n    if (!p) {\n\n        pd = IO_MEM_UNASSIGNED;\n\n    } else {\n\n        pd = p->phys_offset;\n\n    }\n\n#if defined(DEBUG_TLB)\n\n    printf(\"tlb_set_page: vaddr=\" TARGET_FMT_lx \" paddr=0x%08x prot=%x idx=%d smmu=%d pd=0x%08lx\\n\",\n\n           vaddr, (int)paddr, prot, mmu_idx, is_softmmu, pd);\n\n#endif\n\n\n\n    address = vaddr;\n\n    if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {\n\n        /* IO memory case (romd handled later) */\n\n        address |= TLB_MMIO;\n\n    }\n\n    addend = (unsigned long)qemu_get_ram_ptr(pd & TARGET_PAGE_MASK);\n\n    if ((pd & ~TARGET_PAGE_MASK) <= IO_MEM_ROM) {\n\n        /* Normal RAM.  */\n\n        iotlb = pd & TARGET_PAGE_MASK;\n\n        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM)\n\n            iotlb |= IO_MEM_NOTDIRTY;\n\n        else\n\n            iotlb |= IO_MEM_ROM;\n\n    } else {\n\n        /* IO handlers are currently passed a physical address.\n\n           It would be nice to pass an offset from the base address\n\n           of that region.  This would avoid having to special case RAM,\n\n           and avoid full address decoding in every device.\n\n           We can't use the high bits of pd for this because\n\n           IO_MEM_ROMD uses these as a ram address.  */\n\n        iotlb = (pd & ~TARGET_PAGE_MASK);\n\n        if (p) {\n\n            iotlb += p->region_offset;\n\n        } else {\n\n            iotlb += paddr;\n\n        }\n\n    }\n\n\n\n    code_address = address;\n\n    /* Make accesses to pages with watchpoints go via the\n\n       watchpoint trap routines.  */\n\n    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {\n\n        if (vaddr == (wp->vaddr & TARGET_PAGE_MASK)) {\n\n            iotlb = io_mem_watch + paddr;\n\n            /* TODO: The memory case can be optimized by not trapping\n\n               reads of pages with a write breakpoint.  */\n\n            address |= TLB_MMIO;\n\n        }\n\n    }\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    env->iotlb[mmu_idx][index] = iotlb - vaddr;\n\n    te = &env->tlb_table[mmu_idx][index];\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_ROM ||\n\n            (pd & IO_MEM_ROMD)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM &&\n\n                   !cpu_physical_memory_is_dirty(pd)) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n", "idx": 5381, "_split": "test", "_hash": "30c47e7afd95c31e6018c50c34311f93"}
{"project": "qemu", "commit_id": "b3a2319792ad5c0f0f8c3d2f4d02b95fd7efbc69", "target": 0, "func": "void *slavio_intctl_init(target_phys_addr_t addr, target_phys_addr_t addrg,\n\n                         const uint32_t *intbit_to_level,\n\n                         qemu_irq **irq, qemu_irq **cpu_irq,\n\n                         unsigned int cputimer)\n\n\n\n{\n\n    int slavio_intctl_io_memory, slavio_intctlm_io_memory, i;\n\n    SLAVIO_INTCTLState *s;\n\n\n\n    s = qemu_mallocz(sizeof(SLAVIO_INTCTLState));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->intbit_to_level = intbit_to_level;\n\n    for (i = 0; i < MAX_CPUS; i++) {\n\n\tslavio_intctl_io_memory = cpu_register_io_memory(0, slavio_intctl_mem_read, slavio_intctl_mem_write, s);\n\n\tcpu_register_physical_memory(addr + i * TARGET_PAGE_SIZE, INTCTL_SIZE,\n\n                                     slavio_intctl_io_memory);\n\n    }\n\n\n\n    slavio_intctlm_io_memory = cpu_register_io_memory(0, slavio_intctlm_mem_read, slavio_intctlm_mem_write, s);\n\n    cpu_register_physical_memory(addrg, INTCTLM_SIZE, slavio_intctlm_io_memory);\n\n\n\n    register_savevm(\"slavio_intctl\", addr, 1, slavio_intctl_save, slavio_intctl_load, s);\n\n    qemu_register_reset(slavio_intctl_reset, s);\n\n    *irq = qemu_allocate_irqs(slavio_set_irq, s, 32);\n\n\n\n    *cpu_irq = qemu_allocate_irqs(slavio_set_timer_irq_cpu, s, MAX_CPUS);\n\n    s->cputimer_bit = 1 << s->intbit_to_level[cputimer];\n\n    slavio_intctl_reset(s);\n\n    return s;\n\n}\n", "idx": 5386, "_split": "test", "_hash": "3ff96b13bd5f03c65ddf32036025fb2d"}
{"project": "qemu", "commit_id": "1e5ffbedded7ded797f5042d82b70109a712b4c0", "target": 1, "func": "void helper_frndint(void)\n\n{\n\n    ST0 = rint(ST0);\n\n}\n", "idx": 5408, "_split": "test", "_hash": "b4c3467acd701f29f68f68636347b242"}
{"project": "qemu", "commit_id": "64a31d5c3d73396a88563d7a504654edc85aa854", "target": 0, "func": "static int dmg_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVDMGState *s = bs->opaque;\n\n    off_t info_begin,info_end,last_in_offset,last_out_offset;\n\n    uint32_t count;\n\n    uint32_t max_compressed_size=1,max_sectors_per_chunk=1,i;\n\n    int64_t offset;\n\n\n\n    s->fd = open(filename, O_RDONLY | O_BINARY);\n\n    if (s->fd < 0)\n\n        return -errno;\n\n    bs->read_only = 1;\n\n    s->n_chunks = 0;\n\n    s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL;\n\n\n\n    /* read offset of info blocks */\n\n    offset = lseek(s->fd, -0x1d8, SEEK_END);\n\n    if (offset < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    info_begin = read_off(s->fd, offset);\n\n    if (info_begin == 0) {\n\n\tgoto fail;\n\n    }\n\n\n\n    if (read_uint32(s->fd, info_begin) != 0x100) {\n\n        goto fail;\n\n    }\n\n\n\n    count = read_uint32(s->fd, info_begin + 4);\n\n    if (count == 0) {\n\n        goto fail;\n\n    }\n\n    info_end = info_begin + count;\n\n\n\n    offset = info_begin + 0x100;\n\n\n\n    /* read offsets */\n\n    last_in_offset = last_out_offset = 0;\n\n    while (offset < info_end) {\n\n        uint32_t type;\n\n\n\n\tcount = read_uint32(s->fd, offset);\n\n\tif(count==0)\n\n\t    goto fail;\n\n        offset += 4;\n\n\n\n\ttype = read_uint32(s->fd, offset);\n\n\tif (type == 0x6d697368 && count >= 244) {\n\n\t    int new_size, chunk_count;\n\n\n\n            offset += 4;\n\n            offset += 200;\n\n\n\n\t    chunk_count = (count-204)/40;\n\n\t    new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count);\n\n\t    s->types = qemu_realloc(s->types, new_size/2);\n\n\t    s->offsets = qemu_realloc(s->offsets, new_size);\n\n\t    s->lengths = qemu_realloc(s->lengths, new_size);\n\n\t    s->sectors = qemu_realloc(s->sectors, new_size);\n\n\t    s->sectorcounts = qemu_realloc(s->sectorcounts, new_size);\n\n\n\n\t    for(i=s->n_chunks;i<s->n_chunks+chunk_count;i++) {\n\n\t\ts->types[i] = read_uint32(s->fd, offset);\n\n\t\toffset += 4;\n\n\t\tif(s->types[i]!=0x80000005 && s->types[i]!=1 && s->types[i]!=2) {\n\n\t\t    if(s->types[i]==0xffffffff) {\n\n\t\t\tlast_in_offset = s->offsets[i-1]+s->lengths[i-1];\n\n\t\t\tlast_out_offset = s->sectors[i-1]+s->sectorcounts[i-1];\n\n\t\t    }\n\n\t\t    chunk_count--;\n\n\t\t    i--;\n\n\t\t    offset += 36;\n\n\t\t    continue;\n\n\t\t}\n\n\t\toffset += 4;\n\n\n\n\t\ts->sectors[i] = last_out_offset+read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->sectorcounts[i] = read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->offsets[i] = last_in_offset+read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->lengths[i] = read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\tif(s->lengths[i]>max_compressed_size)\n\n\t\t    max_compressed_size = s->lengths[i];\n\n\t\tif(s->sectorcounts[i]>max_sectors_per_chunk)\n\n\t\t    max_sectors_per_chunk = s->sectorcounts[i];\n\n\t    }\n\n\t    s->n_chunks+=chunk_count;\n\n\t}\n\n    }\n\n\n\n    /* initialize zlib engine */\n\n    s->compressed_chunk = qemu_malloc(max_compressed_size+1);\n\n    s->uncompressed_chunk = qemu_malloc(512*max_sectors_per_chunk);\n\n    if(inflateInit(&s->zstream) != Z_OK)\n\n\tgoto fail;\n\n\n\n    s->current_chunk = s->n_chunks;\n\n\n\n    return 0;\n\nfail:\n\n    close(s->fd);\n\n    return -1;\n\n}\n", "idx": 5482, "_split": "test", "_hash": "411f71a177e9d63b3e2bb077f87667aa"}
{"project": "qemu", "commit_id": "df8bf7a7fe75eb5d5caffa55f5cd4292b757aea6", "target": 1, "func": "bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt)\n\n{\n\n    assert(pkt);\n\n\n\n    return pkt->vlan_stripped;\n\n}\n", "idx": 5490, "_split": "test", "_hash": "a2364cc169f3cc915a926cc09490af34"}
{"project": "qemu", "commit_id": "0920a17199d23b3def3a60fa1fbbdeadcdda452d", "target": 1, "func": "static Visitor *validate_test_init_raw(TestInputVisitorData *data,\n\n                                       const char *json_string)\n\n{\n\n    Visitor *v;\n\n\n\n    data->obj = qobject_from_json(json_string);\n\n    g_assert(data->obj != NULL);\n\n\n\n    data->qiv = qmp_input_visitor_new_strict(data->obj);\n\n    g_assert(data->qiv != NULL);\n\n\n\n    v = qmp_input_get_visitor(data->qiv);\n\n    g_assert(v != NULL);\n\n\n\n    return v;\n\n}\n", "idx": 5500, "_split": "test", "_hash": "8962cf6058f1ade8b2573217aaff32d9"}
{"project": "qemu", "commit_id": "660edd4eda903e32811a4929d1434cceda3284aa", "target": 1, "func": "static int connect_namedsocket(const char *path)\n\n{\n\n    int sockfd, size;\n\n    struct sockaddr_un helper;\n\n\n\n    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\n    if (sockfd < 0) {\n\n        fprintf(stderr, \"socket %s\\n\", strerror(errno));\n\n        return -1;\n\n    }\n\n    strcpy(helper.sun_path, path);\n\n    helper.sun_family = AF_UNIX;\n\n    size = strlen(helper.sun_path) + sizeof(helper.sun_family);\n\n    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {\n\n        fprintf(stderr, \"socket error\\n\");\n\n\n        return -1;\n\n    }\n\n\n\n    /* remove the socket for security reasons */\n\n    unlink(path);\n\n    return sockfd;\n\n}", "idx": 5508, "_split": "test", "_hash": "e511558f42fc3219ffc0a2ad2c61d23d"}
{"project": "qemu", "commit_id": "a1c3e4b839f8e7ec7f1792b8a11c63ca845aa021", "target": 1, "func": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val)\n{\n    EHCIState *s = ptr;\n    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);\n    uint32_t old = *mmio;\n    int i;\n    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);\n    /* Only aligned reads are allowed on OHCI */\n    if (addr & 3) {\n        fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\"\n                TARGET_FMT_plx \"\\n\", addr);\n        return;\n    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {\n        handle_port_status_write(s, (addr-PORTSC)/4, val);\n        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);\n        return;\n    if (addr < OPREGBASE) {\n        fprintf(stderr, \"usb-ehci: write attempt to read-only register\"\n                TARGET_FMT_plx \"\\n\", addr);\n        return;\n    /* Do any register specific pre-write processing here.  */\n    switch(addr) {\n    case USBCMD:\n        if (val & USBCMD_HCRESET) {\n            ehci_reset(s);\n            val = s->usbcmd;\n            break;\n        /* not supporting dynamic frame list size at the moment */\n        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {\n            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",\n                    val & USBCMD_FLS);\n            val &= ~USBCMD_FLS;\n        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=\n            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {\n            if (s->pstate == EST_INACTIVE) {\n                SET_LAST_RUN_CLOCK(s);\n            s->usbcmd = val; /* Set usbcmd for ehci_update_halt() */\n            ehci_update_halt(s);\n            qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));\n        break;\n    case USBSTS:\n        val &= USBSTS_RO_MASK;              // bits 6 through 31 are RO\n        ehci_clear_usbsts(s, val);          // bits 0 through 5 are R/WC\n        val = s->usbsts;\n        ehci_update_irq(s);\n        break;\n    case USBINTR:\n        val &= USBINTR_MASK;\n        break;\n    case FRINDEX:\n        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */\n        break;\n    case CONFIGFLAG:\n        val &= 0x1;\n        if (val) {\n            for(i = 0; i < NB_PORTS; i++)\n                handle_port_owner_write(s, i, 0);\n        break;\n    case PERIODICLISTBASE:\n        if (ehci_periodic_enabled(s)) {\n            fprintf(stderr,\n              \"ehci: PERIODIC list base register set while periodic schedule\\n\"\n              \"      is enabled and HC is enabled\\n\");\n        break;\n    case ASYNCLISTADDR:\n        if (ehci_async_enabled(s)) {\n            fprintf(stderr,\n              \"ehci: ASYNC list address register set while async schedule\\n\"\n              \"      is enabled and HC is enabled\\n\");\n        break;\n    *mmio = val;\n    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);", "idx": 5509, "_split": "test", "_hash": "8de8b676c6e1cd4ba76a3f67b6a35287"}
{"project": "qemu", "commit_id": "b85114f8cfbede8b153db68875973ef0790bf296", "target": 0, "func": "void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)\n\n{\n\n    bs->detect_zeroes = blk->root_state.detect_zeroes;\n\n}\n", "idx": 5581, "_split": "test", "_hash": "edce4fa73b4d129354c55fe8ac1cad2e"}
{"project": "qemu", "commit_id": "42119fa3568dc7e8c82447c861678a5987d06d91", "target": 0, "func": "vcard_emul_mirror_card(VReader *vreader)\n\n{\n\n    /*\n\n     * lookup certs using the C_FindObjects. The Stan Cert handle won't give\n\n     * us the real certs until we log in.\n\n     */\n\n    PK11GenericObject *firstObj, *thisObj;\n\n    int cert_count;\n\n    unsigned char **certs;\n\n    int *cert_len;\n\n    VCardKey **keys;\n\n    PK11SlotInfo *slot;\n\n    VCard *card;\n\n\n\n    slot = vcard_emul_reader_get_slot(vreader);\n\n    if (slot == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    firstObj = PK11_FindGenericObjects(slot, CKO_CERTIFICATE);\n\n    if (firstObj == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    /* count the certs */\n\n    cert_count = 0;\n\n    for (thisObj = firstObj; thisObj;\n\n                             thisObj = PK11_GetNextGenericObject(thisObj)) {\n\n        cert_count++;\n\n    }\n\n\n\n    if (cert_count == 0) {\n\n        PK11_DestroyGenericObjects(firstObj);\n\n        return NULL;\n\n    }\n\n\n\n    /* allocate the arrays */\n\n    vcard_emul_alloc_arrays(&certs, &cert_len, &keys, cert_count);\n\n\n\n    /* fill in the arrays */\n\n    cert_count = 0;\n\n    for (thisObj = firstObj; thisObj;\n\n                             thisObj = PK11_GetNextGenericObject(thisObj)) {\n\n        SECItem derCert;\n\n        CERTCertificate *cert;\n\n        SECStatus rv;\n\n\n\n        rv = PK11_ReadRawAttribute(PK11_TypeGeneric, thisObj,\n\n                                   CKA_VALUE, &derCert);\n\n        if (rv != SECSuccess) {\n\n            continue;\n\n        }\n\n        /* create floating temp cert. This gives us a cert structure even if\n\n         * the token isn't logged in */\n\n        cert = CERT_NewTempCertificate(CERT_GetDefaultCertDB(), &derCert,\n\n                                       NULL, PR_FALSE, PR_TRUE);\n\n        SECITEM_FreeItem(&derCert, PR_FALSE);\n\n        if (cert == NULL) {\n\n            continue;\n\n        }\n\n\n\n        certs[cert_count] = cert->derCert.data;\n\n        cert_len[cert_count] = cert->derCert.len;\n\n        keys[cert_count] = vcard_emul_make_key(slot, cert);\n\n        cert_count++;\n\n        CERT_DestroyCertificate(cert); /* key obj still has a reference */\n\n    }\n\n\n\n    /* now create the card */\n\n    card = vcard_emul_make_card(vreader, certs, cert_len, keys, cert_count);\n\n    g_free(certs);\n\n    g_free(cert_len);\n\n    g_free(keys);\n\n\n\n    return card;\n\n}\n", "idx": 5582, "_split": "test", "_hash": "c21675e1a59b360920e116a698a61b31"}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static uint64_t megasas_fw_time(void)\n\n{\n\n    struct tm curtime;\n\n    uint64_t bcd_time;\n\n\n\n    qemu_get_timedate(&curtime, 0);\n\n    bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 |\n\n        ((uint64_t)curtime.tm_min & 0xff)  << 40 |\n\n        ((uint64_t)curtime.tm_hour & 0xff) << 32 |\n\n        ((uint64_t)curtime.tm_mday & 0xff) << 24 |\n\n        ((uint64_t)curtime.tm_mon & 0xff)  << 16 |\n\n        ((uint64_t)(curtime.tm_year + 1900) & 0xffff);\n\n\n\n    return bcd_time;\n\n}\n", "idx": 5587, "_split": "test", "_hash": "8e01a17ec88e78175cea0fd1b2a4a5e3"}
{"project": "qemu", "commit_id": "107e4b352cc309f9bd7588ef1a44549200620078", "target": 1, "func": "static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie)\n\n{\n\n    OfDpaFlow *flow;\n\n    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;\n\n\n\n    flow = g_new0(OfDpaFlow, 1);\n\n    if (!flow) {\n\n        return NULL;\n\n    }\n\n\n\n    flow->cookie = cookie;\n\n    flow->mask.tbl_id = 0xffffffff;\n\n\n\n    flow->stats.install_time = flow->stats.refresh_time = now;\n\n\n\n    return flow;\n\n}\n", "idx": 5607, "_split": "test", "_hash": "0d0694fd20c0201aaf23cca6db3bc82e"}
{"project": "qemu", "commit_id": "c1990ebfa11265d3aa9b6a4d5d1a02bd3f9ac5c6", "target": 1, "func": "QObject *json_parser_parse_err(QList *tokens, va_list *ap, Error **errp)\n\n{\n\n    JSONParserContext ctxt = {};\n\n    QList *working = qlist_copy(tokens);\n\n    QObject *result;\n\n\n\n    result = parse_value(&ctxt, &working, ap);\n\n\n\n    QDECREF(working);\n\n\n\n    error_propagate(errp, ctxt.err);\n\n\n\n    return result;\n\n}\n", "idx": 5624, "_split": "test", "_hash": "7ae4f533528a28e6b396d44c02a094dc"}
{"project": "qemu", "commit_id": "6817efea3a0d1bf87be815970cdb014c5a64b628", "target": 1, "func": "static int init_directories(BDRVVVFATState* s,\n\n                            const char *dirname, int heads, int secs,\n\n                            Error **errp)\n\n{\n\n    bootsector_t* bootsector;\n\n    mapping_t* mapping;\n\n    unsigned int i;\n\n    unsigned int cluster;\n\n\n\n    memset(&(s->first_sectors[0]),0,0x40*0x200);\n\n\n\n    s->cluster_size=s->sectors_per_cluster*0x200;\n\n    s->cluster_buffer=g_malloc(s->cluster_size);\n\n\n\n    /*\n\n     * The formula: sc = spf+1+spf*spc*(512*8/fat_type),\n\n     * where sc is sector_count,\n\n     * spf is sectors_per_fat,\n\n     * spc is sectors_per_clusters, and\n\n     * fat_type = 12, 16 or 32.\n\n     */\n\n    i = 1+s->sectors_per_cluster*0x200*8/s->fat_type;\n\n    s->sectors_per_fat=(s->sector_count+i)/i; /* round up */\n\n\n\n    s->offset_to_fat = s->offset_to_bootsector + 1;\n\n    s->offset_to_root_dir = s->offset_to_fat + s->sectors_per_fat * 2;\n\n\n\n    array_init(&(s->mapping),sizeof(mapping_t));\n\n    array_init(&(s->directory),sizeof(direntry_t));\n\n\n\n    /* add volume label */\n\n    {\n\n        direntry_t* entry=array_get_next(&(s->directory));\n\n        entry->attributes=0x28; /* archive | volume label */\n\n        memcpy(entry->name, s->volume_label, sizeof(entry->name));\n\n    }\n\n\n\n    /* Now build FAT, and write back information into directory */\n\n    init_fat(s);\n\n\n\n    s->cluster_count=sector2cluster(s, s->sector_count);\n\n\n\n    mapping = array_get_next(&(s->mapping));\n\n    mapping->begin = 0;\n\n    mapping->dir_index = 0;\n\n    mapping->info.dir.parent_mapping_index = -1;\n\n    mapping->first_mapping_index = -1;\n\n    mapping->path = g_strdup(dirname);\n\n    i = strlen(mapping->path);\n\n    if (i > 0 && mapping->path[i - 1] == '/')\n\n        mapping->path[i - 1] = '\\0';\n\n    mapping->mode = MODE_DIRECTORY;\n\n    mapping->read_only = 0;\n\n    s->path = mapping->path;\n\n\n\n    for (i = 0, cluster = 0; i < s->mapping.next; i++) {\n\n        /* MS-DOS expects the FAT to be 0 for the root directory\n\n         * (except for the media byte). */\n\n        /* LATER TODO: still true for FAT32? */\n\n        int fix_fat = (i != 0);\n\n        mapping = array_get(&(s->mapping), i);\n\n\n\n        if (mapping->mode & MODE_DIRECTORY) {\n\n            mapping->begin = cluster;\n\n            if(read_directory(s, i)) {\n\n                error_setg(errp, \"Could not read directory %s\",\n\n                           mapping->path);\n\n                return -1;\n\n            }\n\n            mapping = array_get(&(s->mapping), i);\n\n        } else {\n\n            assert(mapping->mode == MODE_UNDEFINED);\n\n            mapping->mode=MODE_NORMAL;\n\n            mapping->begin = cluster;\n\n            if (mapping->end > 0) {\n\n                direntry_t* direntry = array_get(&(s->directory),\n\n                        mapping->dir_index);\n\n\n\n                mapping->end = cluster + 1 + (mapping->end-1)/s->cluster_size;\n\n                set_begin_of_direntry(direntry, mapping->begin);\n\n            } else {\n\n                mapping->end = cluster + 1;\n\n                fix_fat = 0;\n\n            }\n\n        }\n\n\n\n        assert(mapping->begin < mapping->end);\n\n\n\n        /* next free cluster */\n\n        cluster = mapping->end;\n\n\n\n        if(cluster > s->cluster_count) {\n\n            error_setg(errp,\n\n                       \"Directory does not fit in FAT%d (capacity %.2f MB)\",\n\n                       s->fat_type, s->sector_count / 2000.0);\n\n            return -1;\n\n        }\n\n\n\n        /* fix fat for entry */\n\n        if (fix_fat) {\n\n            int j;\n\n            for(j = mapping->begin; j < mapping->end - 1; j++)\n\n                fat_set(s, j, j+1);\n\n            fat_set(s, mapping->end - 1, s->max_fat_value);\n\n        }\n\n    }\n\n\n\n    mapping = array_get(&(s->mapping), 0);\n\n    s->sectors_of_root_directory = mapping->end * s->sectors_per_cluster;\n\n    s->last_cluster_of_root_directory = mapping->end;\n\n\n\n    /* the FAT signature */\n\n    fat_set(s,0,s->max_fat_value);\n\n    fat_set(s,1,s->max_fat_value);\n\n\n\n    s->current_mapping = NULL;\n\n\n\n    bootsector = (bootsector_t *)(s->first_sectors\n\n                                  + s->offset_to_bootsector * 0x200);\n\n    bootsector->jump[0]=0xeb;\n\n    bootsector->jump[1]=0x3e;\n\n    bootsector->jump[2]=0x90;\n\n    memcpy(bootsector->name,\"QEMU    \",8);\n\n    bootsector->sector_size=cpu_to_le16(0x200);\n\n    bootsector->sectors_per_cluster=s->sectors_per_cluster;\n\n    bootsector->reserved_sectors=cpu_to_le16(1);\n\n    bootsector->number_of_fats=0x2; /* number of FATs */\n\n    bootsector->root_entries=cpu_to_le16(s->sectors_of_root_directory*0x10);\n\n    bootsector->total_sectors16=s->sector_count>0xffff?0:cpu_to_le16(s->sector_count);\n\n    /* media descriptor: hard disk=0xf8, floppy=0xf0 */\n\n    bootsector->media_type = (s->offset_to_bootsector > 0 ? 0xf8 : 0xf0);\n\n    s->fat.pointer[0] = bootsector->media_type;\n\n    bootsector->sectors_per_fat=cpu_to_le16(s->sectors_per_fat);\n\n    bootsector->sectors_per_track = cpu_to_le16(secs);\n\n    bootsector->number_of_heads = cpu_to_le16(heads);\n\n    bootsector->hidden_sectors = cpu_to_le32(s->offset_to_bootsector);\n\n    bootsector->total_sectors=cpu_to_le32(s->sector_count>0xffff?s->sector_count:0);\n\n\n\n    /* LATER TODO: if FAT32, this is wrong */\n\n    /* drive_number: fda=0, hda=0x80 */\n\n    bootsector->u.fat16.drive_number = s->offset_to_bootsector == 0 ? 0 : 0x80;\n\n    bootsector->u.fat16.signature=0x29;\n\n    bootsector->u.fat16.id=cpu_to_le32(0xfabe1afd);\n\n\n\n    memcpy(bootsector->u.fat16.volume_label, s->volume_label,\n\n           sizeof(bootsector->u.fat16.volume_label));\n\n    memcpy(bootsector->u.fat16.fat_type,\n\n           s->fat_type == 12 ? \"FAT12   \" : \"FAT16   \", 8);\n\n    bootsector->magic[0]=0x55; bootsector->magic[1]=0xaa;\n\n\n\n    return 0;\n\n}\n", "idx": 5630, "_split": "test", "_hash": "fe1fcbb47bc1fb18d5f8fee5097d18ac"}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)\n\n{\n\n    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);\n\n    s->freq = PXA25X_FREQ;\n\n    s->tm4 = NULL;\n\n}\n", "idx": 5646, "_split": "test", "_hash": "3c8deb238941ed1560fa6f5d65c535d9"}
{"project": "qemu", "commit_id": "0919ac787641db11024912651f3bc5764d4f1286", "target": 0, "func": "struct omap_mpu_state_s *omap2420_mpu_init(unsigned long sdram_size,\n\n                const char *core)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *)\n\n            g_malloc0(sizeof(struct omap_mpu_state_s));\n\n    ram_addr_t sram_base, q2_base;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq dma_irqs[4];\n\n    DriveInfo *dinfo;\n\n    int i;\n\n    SysBusDevice *busdev;\n\n    struct omap_target_agent_s *ta;\n\n\n\n    /* Core */\n\n    s->mpu_model = omap2420;\n\n    s->env = cpu_init(core ?: \"arm1136-r2\");\n\n    if (!s->env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    s->sdram_size = sdram_size;\n\n    s->sram_size = OMAP242X_SRAM_SIZE;\n\n\n\n    s->wakeup = qemu_allocate_irqs(omap_mpu_wakeup, s, 1)[0];\n\n\n\n    /* Clocks */\n\n    omap_clk_init(s);\n\n\n\n    /* Memory-mapped stuff */\n\n    cpu_register_physical_memory(OMAP2_Q2_BASE, s->sdram_size,\n\n                    (q2_base = qemu_ram_alloc(NULL, \"omap2.dram\",\n\n                                              s->sdram_size)) | IO_MEM_RAM);\n\n    cpu_register_physical_memory(OMAP2_SRAM_BASE, s->sram_size,\n\n                    (sram_base = qemu_ram_alloc(NULL, \"omap2.sram\",\n\n                                                s->sram_size)) | IO_MEM_RAM);\n\n\n\n    s->l4 = omap_l4_init(OMAP2_L4_BASE, 54);\n\n\n\n    /* Actually mapped at any 2K boundary in the ARM11 private-peripheral if */\n\n    cpu_irq = arm_pic_init_cpu(s->env);\n\n    s->ih[0] = omap2_inth_init(0x480fe000, 0x1000, 3, &s->irq[0],\n\n                    cpu_irq[ARM_PIC_CPU_IRQ], cpu_irq[ARM_PIC_CPU_FIQ],\n\n                    omap_findclk(s, \"mpu_intc_fclk\"),\n\n                    omap_findclk(s, \"mpu_intc_iclk\"));\n\n\n\n    s->prcm = omap_prcm_init(omap_l4tao(s->l4, 3),\n\n                    s->irq[0][OMAP_INT_24XX_PRCM_MPU_IRQ], NULL, NULL, s);\n\n\n\n    s->sysc = omap_sysctl_init(omap_l4tao(s->l4, 1),\n\n                    omap_findclk(s, \"omapctrl_iclk\"), s);\n\n\n\n    for (i = 0; i < 4; i ++)\n\n        dma_irqs[i] =\n\n                s->irq[omap2_dma_irq_map[i].ih][omap2_dma_irq_map[i].intr];\n\n    s->dma = omap_dma4_init(0x48056000, dma_irqs, s, 256, 32,\n\n                    omap_findclk(s, \"sdma_iclk\"),\n\n                    omap_findclk(s, \"sdma_fclk\"));\n\n    s->port->addr_valid = omap2_validate_addr;\n\n\n\n    /* Register SDRAM and SRAM ports for fast DMA transfers.  */\n\n    soc_dma_port_add_mem(s->dma, qemu_get_ram_ptr(q2_base),\n\n                         OMAP2_Q2_BASE, s->sdram_size);\n\n    soc_dma_port_add_mem(s->dma, qemu_get_ram_ptr(sram_base),\n\n                         OMAP2_SRAM_BASE, s->sram_size);\n\n\n\n    s->uart[0] = omap2_uart_init(omap_l4ta(s->l4, 19),\n\n                    s->irq[0][OMAP_INT_24XX_UART1_IRQ],\n\n                    omap_findclk(s, \"uart1_fclk\"),\n\n                    omap_findclk(s, \"uart1_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART1_TX],\n\n                    s->drq[OMAP24XX_DMA_UART1_RX],\n\n                    \"uart1\",\n\n                    serial_hds[0]);\n\n    s->uart[1] = omap2_uart_init(omap_l4ta(s->l4, 20),\n\n                    s->irq[0][OMAP_INT_24XX_UART2_IRQ],\n\n                    omap_findclk(s, \"uart2_fclk\"),\n\n                    omap_findclk(s, \"uart2_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART2_TX],\n\n                    s->drq[OMAP24XX_DMA_UART2_RX],\n\n                    \"uart2\",\n\n                    serial_hds[0] ? serial_hds[1] : NULL);\n\n    s->uart[2] = omap2_uart_init(omap_l4ta(s->l4, 21),\n\n                    s->irq[0][OMAP_INT_24XX_UART3_IRQ],\n\n                    omap_findclk(s, \"uart3_fclk\"),\n\n                    omap_findclk(s, \"uart3_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART3_TX],\n\n                    s->drq[OMAP24XX_DMA_UART3_RX],\n\n                    \"uart3\",\n\n                    serial_hds[0] && serial_hds[1] ? serial_hds[2] : NULL);\n\n\n\n    s->gptimer[0] = omap_gp_timer_init(omap_l4ta(s->l4, 7),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER1],\n\n                    omap_findclk(s, \"wu_gpt1_clk\"),\n\n                    omap_findclk(s, \"wu_l4_iclk\"));\n\n    s->gptimer[1] = omap_gp_timer_init(omap_l4ta(s->l4, 8),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER2],\n\n                    omap_findclk(s, \"core_gpt2_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[2] = omap_gp_timer_init(omap_l4ta(s->l4, 22),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER3],\n\n                    omap_findclk(s, \"core_gpt3_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[3] = omap_gp_timer_init(omap_l4ta(s->l4, 23),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER4],\n\n                    omap_findclk(s, \"core_gpt4_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[4] = omap_gp_timer_init(omap_l4ta(s->l4, 24),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER5],\n\n                    omap_findclk(s, \"core_gpt5_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[5] = omap_gp_timer_init(omap_l4ta(s->l4, 25),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER6],\n\n                    omap_findclk(s, \"core_gpt6_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[6] = omap_gp_timer_init(omap_l4ta(s->l4, 26),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER7],\n\n                    omap_findclk(s, \"core_gpt7_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[7] = omap_gp_timer_init(omap_l4ta(s->l4, 27),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER8],\n\n                    omap_findclk(s, \"core_gpt8_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[8] = omap_gp_timer_init(omap_l4ta(s->l4, 28),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER9],\n\n                    omap_findclk(s, \"core_gpt9_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[9] = omap_gp_timer_init(omap_l4ta(s->l4, 29),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER10],\n\n                    omap_findclk(s, \"core_gpt10_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[10] = omap_gp_timer_init(omap_l4ta(s->l4, 30),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER11],\n\n                    omap_findclk(s, \"core_gpt11_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[11] = omap_gp_timer_init(omap_l4ta(s->l4, 31),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER12],\n\n                    omap_findclk(s, \"core_gpt12_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    omap_tap_init(omap_l4ta(s->l4, 2), s);\n\n\n\n    s->synctimer = omap_synctimer_init(omap_l4tao(s->l4, 2), s,\n\n                    omap_findclk(s, \"clk32-kHz\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    s->i2c[0] = omap2_i2c_init(omap_l4tao(s->l4, 5),\n\n                    s->irq[0][OMAP_INT_24XX_I2C1_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_I2C1_TX],\n\n                    omap_findclk(s, \"i2c1.fclk\"),\n\n                    omap_findclk(s, \"i2c1.iclk\"));\n\n    s->i2c[1] = omap2_i2c_init(omap_l4tao(s->l4, 6),\n\n                    s->irq[0][OMAP_INT_24XX_I2C2_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_I2C2_TX],\n\n                    omap_findclk(s, \"i2c2.fclk\"),\n\n                    omap_findclk(s, \"i2c2.iclk\"));\n\n\n\n    s->gpio = qdev_create(NULL, \"omap2-gpio\");\n\n    qdev_prop_set_int32(s->gpio, \"mpu_model\", s->mpu_model);\n\n    qdev_prop_set_ptr(s->gpio, \"iclk\", omap_findclk(s, \"gpio_iclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk0\", omap_findclk(s, \"gpio1_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk1\", omap_findclk(s, \"gpio2_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk2\", omap_findclk(s, \"gpio3_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk3\", omap_findclk(s, \"gpio4_dbclk\"));\n\n    if (s->mpu_model == omap2430) {\n\n        qdev_prop_set_ptr(s->gpio, \"fclk4\", omap_findclk(s, \"gpio5_dbclk\"));\n\n    }\n\n    qdev_init_nofail(s->gpio);\n\n    busdev = sysbus_from_qdev(s->gpio);\n\n    sysbus_connect_irq(busdev, 0, s->irq[0][OMAP_INT_24XX_GPIO_BANK1]);\n\n    sysbus_connect_irq(busdev, 3, s->irq[0][OMAP_INT_24XX_GPIO_BANK2]);\n\n    sysbus_connect_irq(busdev, 6, s->irq[0][OMAP_INT_24XX_GPIO_BANK3]);\n\n    sysbus_connect_irq(busdev, 9, s->irq[0][OMAP_INT_24XX_GPIO_BANK4]);\n\n    ta = omap_l4ta(s->l4, 3);\n\n    sysbus_mmio_map(busdev, 0, omap_l4_region_base(ta, 1));\n\n    sysbus_mmio_map(busdev, 1, omap_l4_region_base(ta, 0));\n\n    sysbus_mmio_map(busdev, 2, omap_l4_region_base(ta, 2));\n\n    sysbus_mmio_map(busdev, 3, omap_l4_region_base(ta, 4));\n\n    sysbus_mmio_map(busdev, 4, omap_l4_region_base(ta, 5));\n\n\n\n    s->sdrc = omap_sdrc_init(0x68009000);\n\n    s->gpmc = omap_gpmc_init(s, 0x6800a000, s->irq[0][OMAP_INT_24XX_GPMC_IRQ],\n\n                             s->drq[OMAP24XX_DMA_GPMC]);\n\n\n\n    dinfo = drive_get(IF_SD, 0, 0);\n\n    if (!dinfo) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n\n        exit(1);\n\n    }\n\n    s->mmc = omap2_mmc_init(omap_l4tao(s->l4, 9), dinfo->bdrv,\n\n                    s->irq[0][OMAP_INT_24XX_MMC_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_MMC1_TX],\n\n                    omap_findclk(s, \"mmc_fclk\"), omap_findclk(s, \"mmc_iclk\"));\n\n\n\n    s->mcspi[0] = omap_mcspi_init(omap_l4ta(s->l4, 35), 4,\n\n                    s->irq[0][OMAP_INT_24XX_MCSPI1_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_SPI1_TX0],\n\n                    omap_findclk(s, \"spi1_fclk\"),\n\n                    omap_findclk(s, \"spi1_iclk\"));\n\n    s->mcspi[1] = omap_mcspi_init(omap_l4ta(s->l4, 36), 2,\n\n                    s->irq[0][OMAP_INT_24XX_MCSPI2_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_SPI2_TX0],\n\n                    omap_findclk(s, \"spi2_fclk\"),\n\n                    omap_findclk(s, \"spi2_iclk\"));\n\n\n\n    s->dss = omap_dss_init(omap_l4ta(s->l4, 10), 0x68000800,\n\n                    /* XXX wire M_IRQ_25, D_L2_IRQ_30 and I_IRQ_13 together */\n\n                    s->irq[0][OMAP_INT_24XX_DSS_IRQ], s->drq[OMAP24XX_DMA_DSS],\n\n                    omap_findclk(s, \"dss_clk1\"), omap_findclk(s, \"dss_clk2\"),\n\n                    omap_findclk(s, \"dss_54m_clk\"),\n\n                    omap_findclk(s, \"dss_l3_iclk\"),\n\n                    omap_findclk(s, \"dss_l4_iclk\"));\n\n\n\n    omap_sti_init(omap_l4ta(s->l4, 18), 0x54000000,\n\n                    s->irq[0][OMAP_INT_24XX_STI], omap_findclk(s, \"emul_ck\"),\n\n                    serial_hds[0] && serial_hds[1] && serial_hds[2] ?\n\n                    serial_hds[3] : NULL);\n\n\n\n    s->eac = omap_eac_init(omap_l4ta(s->l4, 32),\n\n                    s->irq[0][OMAP_INT_24XX_EAC_IRQ],\n\n                    /* Ten consecutive lines */\n\n                    &s->drq[OMAP24XX_DMA_EAC_AC_RD],\n\n                    omap_findclk(s, \"func_96m_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    /* All register mappings (includin those not currenlty implemented):\n\n     * SystemControlMod\t48000000 - 48000fff\n\n     * SystemControlL4\t48001000 - 48001fff\n\n     * 32kHz Timer Mod\t48004000 - 48004fff\n\n     * 32kHz Timer L4\t48005000 - 48005fff\n\n     * PRCM ModA\t48008000 - 480087ff\n\n     * PRCM ModB\t48008800 - 48008fff\n\n     * PRCM L4\t\t48009000 - 48009fff\n\n     * TEST-BCM Mod\t48012000 - 48012fff\n\n     * TEST-BCM L4\t48013000 - 48013fff\n\n     * TEST-TAP Mod\t48014000 - 48014fff\n\n     * TEST-TAP L4\t48015000 - 48015fff\n\n     * GPIO1 Mod\t48018000 - 48018fff\n\n     * GPIO Top\t\t48019000 - 48019fff\n\n     * GPIO2 Mod\t4801a000 - 4801afff\n\n     * GPIO L4\t\t4801b000 - 4801bfff\n\n     * GPIO3 Mod\t4801c000 - 4801cfff\n\n     * GPIO4 Mod\t4801e000 - 4801efff\n\n     * WDTIMER1 Mod\t48020000 - 48010fff\n\n     * WDTIMER Top\t48021000 - 48011fff\n\n     * WDTIMER2 Mod\t48022000 - 48012fff\n\n     * WDTIMER L4\t48023000 - 48013fff\n\n     * WDTIMER3 Mod\t48024000 - 48014fff\n\n     * WDTIMER3 L4\t48025000 - 48015fff\n\n     * WDTIMER4 Mod\t48026000 - 48016fff\n\n     * WDTIMER4 L4\t48027000 - 48017fff\n\n     * GPTIMER1 Mod\t48028000 - 48018fff\n\n     * GPTIMER1 L4\t48029000 - 48019fff\n\n     * GPTIMER2 Mod\t4802a000 - 4801afff\n\n     * GPTIMER2 L4\t4802b000 - 4801bfff\n\n     * L4-Config AP\t48040000 - 480407ff\n\n     * L4-Config IP\t48040800 - 48040fff\n\n     * L4-Config LA\t48041000 - 48041fff\n\n     * ARM11ETB Mod\t48048000 - 48049fff\n\n     * ARM11ETB L4\t4804a000 - 4804afff\n\n     * DISPLAY Top\t48050000 - 480503ff\n\n     * DISPLAY DISPC\t48050400 - 480507ff\n\n     * DISPLAY RFBI\t48050800 - 48050bff\n\n     * DISPLAY VENC\t48050c00 - 48050fff\n\n     * DISPLAY L4\t48051000 - 48051fff\n\n     * CAMERA Top\t48052000 - 480523ff\n\n     * CAMERA core\t48052400 - 480527ff\n\n     * CAMERA DMA\t48052800 - 48052bff\n\n     * CAMERA MMU\t48052c00 - 48052fff\n\n     * CAMERA L4\t48053000 - 48053fff\n\n     * SDMA Mod\t\t48056000 - 48056fff\n\n     * SDMA L4\t\t48057000 - 48057fff\n\n     * SSI Top\t\t48058000 - 48058fff\n\n     * SSI GDD\t\t48059000 - 48059fff\n\n     * SSI Port1\t4805a000 - 4805afff\n\n     * SSI Port2\t4805b000 - 4805bfff\n\n     * SSI L4\t\t4805c000 - 4805cfff\n\n     * USB Mod\t\t4805e000 - 480fefff\n\n     * USB L4\t\t4805f000 - 480fffff\n\n     * WIN_TRACER1 Mod\t48060000 - 48060fff\n\n     * WIN_TRACER1 L4\t48061000 - 48061fff\n\n     * WIN_TRACER2 Mod\t48062000 - 48062fff\n\n     * WIN_TRACER2 L4\t48063000 - 48063fff\n\n     * WIN_TRACER3 Mod\t48064000 - 48064fff\n\n     * WIN_TRACER3 L4\t48065000 - 48065fff\n\n     * WIN_TRACER4 Top\t48066000 - 480660ff\n\n     * WIN_TRACER4 ETT\t48066100 - 480661ff\n\n     * WIN_TRACER4 WT\t48066200 - 480662ff\n\n     * WIN_TRACER4 L4\t48067000 - 48067fff\n\n     * XTI Mod\t\t48068000 - 48068fff\n\n     * XTI L4\t\t48069000 - 48069fff\n\n     * UART1 Mod\t4806a000 - 4806afff\n\n     * UART1 L4\t\t4806b000 - 4806bfff\n\n     * UART2 Mod\t4806c000 - 4806cfff\n\n     * UART2 L4\t\t4806d000 - 4806dfff\n\n     * UART3 Mod\t4806e000 - 4806efff\n\n     * UART3 L4\t\t4806f000 - 4806ffff\n\n     * I2C1 Mod\t\t48070000 - 48070fff\n\n     * I2C1 L4\t\t48071000 - 48071fff\n\n     * I2C2 Mod\t\t48072000 - 48072fff\n\n     * I2C2 L4\t\t48073000 - 48073fff\n\n     * McBSP1 Mod\t48074000 - 48074fff\n\n     * McBSP1 L4\t48075000 - 48075fff\n\n     * McBSP2 Mod\t48076000 - 48076fff\n\n     * McBSP2 L4\t48077000 - 48077fff\n\n     * GPTIMER3 Mod\t48078000 - 48078fff\n\n     * GPTIMER3 L4\t48079000 - 48079fff\n\n     * GPTIMER4 Mod\t4807a000 - 4807afff\n\n     * GPTIMER4 L4\t4807b000 - 4807bfff\n\n     * GPTIMER5 Mod\t4807c000 - 4807cfff\n\n     * GPTIMER5 L4\t4807d000 - 4807dfff\n\n     * GPTIMER6 Mod\t4807e000 - 4807efff\n\n     * GPTIMER6 L4\t4807f000 - 4807ffff\n\n     * GPTIMER7 Mod\t48080000 - 48080fff\n\n     * GPTIMER7 L4\t48081000 - 48081fff\n\n     * GPTIMER8 Mod\t48082000 - 48082fff\n\n     * GPTIMER8 L4\t48083000 - 48083fff\n\n     * GPTIMER9 Mod\t48084000 - 48084fff\n\n     * GPTIMER9 L4\t48085000 - 48085fff\n\n     * GPTIMER10 Mod\t48086000 - 48086fff\n\n     * GPTIMER10 L4\t48087000 - 48087fff\n\n     * GPTIMER11 Mod\t48088000 - 48088fff\n\n     * GPTIMER11 L4\t48089000 - 48089fff\n\n     * GPTIMER12 Mod\t4808a000 - 4808afff\n\n     * GPTIMER12 L4\t4808b000 - 4808bfff\n\n     * EAC Mod\t\t48090000 - 48090fff\n\n     * EAC L4\t\t48091000 - 48091fff\n\n     * FAC Mod\t\t48092000 - 48092fff\n\n     * FAC L4\t\t48093000 - 48093fff\n\n     * MAILBOX Mod\t48094000 - 48094fff\n\n     * MAILBOX L4\t48095000 - 48095fff\n\n     * SPI1 Mod\t\t48098000 - 48098fff\n\n     * SPI1 L4\t\t48099000 - 48099fff\n\n     * SPI2 Mod\t\t4809a000 - 4809afff\n\n     * SPI2 L4\t\t4809b000 - 4809bfff\n\n     * MMC/SDIO Mod\t4809c000 - 4809cfff\n\n     * MMC/SDIO L4\t4809d000 - 4809dfff\n\n     * MS_PRO Mod\t4809e000 - 4809efff\n\n     * MS_PRO L4\t4809f000 - 4809ffff\n\n     * RNG Mod\t\t480a0000 - 480a0fff\n\n     * RNG L4\t\t480a1000 - 480a1fff\n\n     * DES3DES Mod\t480a2000 - 480a2fff\n\n     * DES3DES L4\t480a3000 - 480a3fff\n\n     * SHA1MD5 Mod\t480a4000 - 480a4fff\n\n     * SHA1MD5 L4\t480a5000 - 480a5fff\n\n     * AES Mod\t\t480a6000 - 480a6fff\n\n     * AES L4\t\t480a7000 - 480a7fff\n\n     * PKA Mod\t\t480a8000 - 480a9fff\n\n     * PKA L4\t\t480aa000 - 480aafff\n\n     * MG Mod\t\t480b0000 - 480b0fff\n\n     * MG L4\t\t480b1000 - 480b1fff\n\n     * HDQ/1-wire Mod\t480b2000 - 480b2fff\n\n     * HDQ/1-wire L4\t480b3000 - 480b3fff\n\n     * MPU interrupt\t480fe000 - 480fefff\n\n     * STI channel base\t54000000 - 5400ffff\n\n     * IVA RAM\t\t5c000000 - 5c01ffff\n\n     * IVA ROM\t\t5c020000 - 5c027fff\n\n     * IMG_BUF_A\t5c040000 - 5c040fff\n\n     * IMG_BUF_B\t5c042000 - 5c042fff\n\n     * VLCDS\t\t5c048000 - 5c0487ff\n\n     * IMX_COEF\t\t5c049000 - 5c04afff\n\n     * IMX_CMD\t\t5c051000 - 5c051fff\n\n     * VLCDQ\t\t5c053000 - 5c0533ff\n\n     * VLCDH\t\t5c054000 - 5c054fff\n\n     * SEQ_CMD\t\t5c055000 - 5c055fff\n\n     * IMX_REG\t\t5c056000 - 5c0560ff\n\n     * VLCD_REG\t\t5c056100 - 5c0561ff\n\n     * SEQ_REG\t\t5c056200 - 5c0562ff\n\n     * IMG_BUF_REG\t5c056300 - 5c0563ff\n\n     * SEQIRQ_REG\t5c056400 - 5c0564ff\n\n     * OCP_REG\t\t5c060000 - 5c060fff\n\n     * SYSC_REG\t\t5c070000 - 5c070fff\n\n     * MMU_REG\t\t5d000000 - 5d000fff\n\n     * sDMA R\t\t68000400 - 680005ff\n\n     * sDMA W\t\t68000600 - 680007ff\n\n     * Display Control\t68000800 - 680009ff\n\n     * DSP subsystem\t68000a00 - 68000bff\n\n     * MPU subsystem\t68000c00 - 68000dff\n\n     * IVA subsystem\t68001000 - 680011ff\n\n     * USB\t\t68001200 - 680013ff\n\n     * Camera\t\t68001400 - 680015ff\n\n     * VLYNQ (firewall)\t68001800 - 68001bff\n\n     * VLYNQ\t\t68001e00 - 68001fff\n\n     * SSI\t\t68002000 - 680021ff\n\n     * L4\t\t68002400 - 680025ff\n\n     * DSP (firewall)\t68002800 - 68002bff\n\n     * DSP subsystem\t68002e00 - 68002fff\n\n     * IVA (firewall)\t68003000 - 680033ff\n\n     * IVA\t\t68003600 - 680037ff\n\n     * GFX\t\t68003a00 - 68003bff\n\n     * CMDWR emulation\t68003c00 - 68003dff\n\n     * SMS\t\t68004000 - 680041ff\n\n     * OCM\t\t68004200 - 680043ff\n\n     * GPMC\t\t68004400 - 680045ff\n\n     * RAM (firewall)\t68005000 - 680053ff\n\n     * RAM (err login)\t68005400 - 680057ff\n\n     * ROM (firewall)\t68005800 - 68005bff\n\n     * ROM (err login)\t68005c00 - 68005fff\n\n     * GPMC (firewall)\t68006000 - 680063ff\n\n     * GPMC (err login)\t68006400 - 680067ff\n\n     * SMS (err login)\t68006c00 - 68006fff\n\n     * SMS registers\t68008000 - 68008fff\n\n     * SDRC registers\t68009000 - 68009fff\n\n     * GPMC registers\t6800a000   6800afff\n\n     */\n\n\n\n    qemu_register_reset(omap2_mpu_reset, s);\n\n\n\n    return s;\n\n}\n", "idx": 5670, "_split": "test", "_hash": "90dc10786fe4a6e900912f58df6da3a9"}
{"project": "qemu", "commit_id": "c878da3b27ceeed953c9f9a1eb002d59e9dcb4c6", "target": 0, "func": "static void tcg_out_qemu_ld_slow_path (TCGContext *s, TCGLabelQemuLdst *label)\n\n{\n\n    int s_bits;\n\n    int ir;\n\n    int opc = label->opc;\n\n    int mem_index = label->mem_index;\n\n    int data_reg = label->datalo_reg;\n\n    int data_reg2 = label->datahi_reg;\n\n    int addr_reg = label->addrlo_reg;\n\n    uint8_t *raddr = label->raddr;\n\n    uint8_t **label_ptr = &label->label_ptr[0];\n\n\n\n    s_bits = opc & 3;\n\n\n\n    /* resolve label address */\n\n    reloc_pc14 (label_ptr[0], (tcg_target_long) s->code_ptr);\n\n\n\n    /* slow path */\n\n    ir = 3;\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, TCG_AREG0);\n\n#if TARGET_LONG_BITS == 32\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, addr_reg);\n\n#else\n\n#ifdef TCG_TARGET_CALL_ALIGN_ARGS\n\n    ir |= 1;\n\n#endif\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, label->addrhi_reg);\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, addr_reg);\n\n#endif\n\n    tcg_out_movi (s, TCG_TYPE_I32, ir, mem_index);\n\n    tcg_out_call (s, (tcg_target_long) qemu_ld_helpers[s_bits], 1);\n\n    tcg_out32 (s, B | 8);\n\n    tcg_out32 (s, (tcg_target_long) raddr);\n\n    switch (opc) {\n\n    case 0|4:\n\n        tcg_out32 (s, EXTSB | RA (data_reg) | RS (3));\n\n        break;\n\n    case 1|4:\n\n        tcg_out32 (s, EXTSH | RA (data_reg) | RS (3));\n\n        break;\n\n    case 0:\n\n    case 1:\n\n    case 2:\n\n        if (data_reg != 3)\n\n            tcg_out_mov (s, TCG_TYPE_I32, data_reg, 3);\n\n        break;\n\n    case 3:\n\n        if (data_reg == 3) {\n\n            if (data_reg2 == 4) {\n\n                tcg_out_mov (s, TCG_TYPE_I32, 0, 4);\n\n                tcg_out_mov (s, TCG_TYPE_I32, 4, 3);\n\n                tcg_out_mov (s, TCG_TYPE_I32, 3, 0);\n\n            }\n\n            else {\n\n                tcg_out_mov (s, TCG_TYPE_I32, data_reg2, 3);\n\n                tcg_out_mov (s, TCG_TYPE_I32, 3, 4);\n\n            }\n\n        }\n\n        else {\n\n            if (data_reg != 4) tcg_out_mov (s, TCG_TYPE_I32, data_reg, 4);\n\n            if (data_reg2 != 3) tcg_out_mov (s, TCG_TYPE_I32, data_reg2, 3);\n\n        }\n\n        break;\n\n    }\n\n    /* Jump to the code corresponding to next IR of qemu_st */\n\n    tcg_out_b (s, 0, (tcg_target_long) raddr);\n\n}\n", "idx": 5672, "_split": "test", "_hash": "a4da81a23845cbad0ab87c8ad4d91d64"}
{"project": "qemu", "commit_id": "46321d6b5f8c880932a6b3d07bd0ff6f892e665c", "target": 0, "func": "static int nbd_negotiate_handle_info(NBDClient *client, uint32_t length,\n\n                                     uint32_t opt, uint16_t myflags,\n\n                                     Error **errp)\n\n{\n\n    int rc;\n\n    char name[NBD_MAX_NAME_SIZE + 1];\n\n    NBDExport *exp;\n\n    uint16_t requests;\n\n    uint16_t request;\n\n    uint32_t namelen;\n\n    bool sendname = false;\n\n    bool blocksize = false;\n\n    uint32_t sizes[3];\n\n    char buf[sizeof(uint64_t) + sizeof(uint16_t)];\n\n    const char *msg;\n\n\n\n    /* Client sends:\n\n        4 bytes: L, name length (can be 0)\n\n        L bytes: export name\n\n        2 bytes: N, number of requests (can be 0)\n\n        N * 2 bytes: N requests\n\n    */\n\n    if (length < sizeof(namelen) + sizeof(requests)) {\n\n        msg = \"overall request too short\";\n\n        goto invalid;\n\n    }\n\n    if (nbd_read(client->ioc, &namelen, sizeof(namelen), errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    be32_to_cpus(&namelen);\n\n    length -= sizeof(namelen);\n\n    if (namelen > length - sizeof(requests) || (length - namelen) % 2) {\n\n        msg = \"name length is incorrect\";\n\n        goto invalid;\n\n    }\n\n    if (nbd_read(client->ioc, name, namelen, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    name[namelen] = '\\0';\n\n    length -= namelen;\n\n    trace_nbd_negotiate_handle_export_name_request(name);\n\n\n\n    if (nbd_read(client->ioc, &requests, sizeof(requests), errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    be16_to_cpus(&requests);\n\n    length -= sizeof(requests);\n\n    trace_nbd_negotiate_handle_info_requests(requests);\n\n    if (requests != length / sizeof(request)) {\n\n        msg = \"incorrect number of  requests for overall length\";\n\n        goto invalid;\n\n    }\n\n    while (requests--) {\n\n        if (nbd_read(client->ioc, &request, sizeof(request), errp) < 0) {\n\n            return -EIO;\n\n        }\n\n        be16_to_cpus(&request);\n\n        length -= sizeof(request);\n\n        trace_nbd_negotiate_handle_info_request(request,\n\n                                                nbd_info_lookup(request));\n\n        /* We care about NBD_INFO_NAME and NBD_INFO_BLOCK_SIZE;\n\n         * everything else is either a request we don't know or\n\n         * something we send regardless of request */\n\n        switch (request) {\n\n        case NBD_INFO_NAME:\n\n            sendname = true;\n\n            break;\n\n        case NBD_INFO_BLOCK_SIZE:\n\n            blocksize = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    exp = nbd_export_find(name);\n\n    if (!exp) {\n\n        return nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_UNKNOWN,\n\n                                          opt, errp, \"export '%s' not present\",\n\n                                          name);\n\n    }\n\n\n\n    /* Don't bother sending NBD_INFO_NAME unless client requested it */\n\n    if (sendname) {\n\n        rc = nbd_negotiate_send_info(client, opt, NBD_INFO_NAME, length, name,\n\n                                     errp);\n\n        if (rc < 0) {\n\n            return rc;\n\n        }\n\n    }\n\n\n\n    /* Send NBD_INFO_DESCRIPTION only if available, regardless of\n\n     * client request */\n\n    if (exp->description) {\n\n        size_t len = strlen(exp->description);\n\n\n\n        rc = nbd_negotiate_send_info(client, opt, NBD_INFO_DESCRIPTION,\n\n                                     len, exp->description, errp);\n\n        if (rc < 0) {\n\n            return rc;\n\n        }\n\n    }\n\n\n\n    /* Send NBD_INFO_BLOCK_SIZE always, but tweak the minimum size\n\n     * according to whether the client requested it, and according to\n\n     * whether this is OPT_INFO or OPT_GO. */\n\n    /* minimum - 1 for back-compat, or 512 if client is new enough.\n\n     * TODO: consult blk_bs(blk)->bl.request_alignment? */\n\n    sizes[0] = (opt == NBD_OPT_INFO || blocksize) ? BDRV_SECTOR_SIZE : 1;\n\n    /* preferred - Hard-code to 4096 for now.\n\n     * TODO: is blk_bs(blk)->bl.opt_transfer appropriate? */\n\n    sizes[1] = 4096;\n\n    /* maximum - At most 32M, but smaller as appropriate. */\n\n    sizes[2] = MIN(blk_get_max_transfer(exp->blk), NBD_MAX_BUFFER_SIZE);\n\n    trace_nbd_negotiate_handle_info_block_size(sizes[0], sizes[1], sizes[2]);\n\n    cpu_to_be32s(&sizes[0]);\n\n    cpu_to_be32s(&sizes[1]);\n\n    cpu_to_be32s(&sizes[2]);\n\n    rc = nbd_negotiate_send_info(client, opt, NBD_INFO_BLOCK_SIZE,\n\n                                 sizeof(sizes), sizes, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    /* Send NBD_INFO_EXPORT always */\n\n    trace_nbd_negotiate_new_style_size_flags(exp->size,\n\n                                             exp->nbdflags | myflags);\n\n    stq_be_p(buf, exp->size);\n\n    stw_be_p(buf + 8, exp->nbdflags | myflags);\n\n    rc = nbd_negotiate_send_info(client, opt, NBD_INFO_EXPORT,\n\n                                 sizeof(buf), buf, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    /* If the client is just asking for NBD_OPT_INFO, but forgot to\n\n     * request block sizes, return an error.\n\n     * TODO: consult blk_bs(blk)->request_align, and only error if it\n\n     * is not 1? */\n\n    if (opt == NBD_OPT_INFO && !blocksize) {\n\n        return nbd_negotiate_send_rep_err(client->ioc,\n\n                                          NBD_REP_ERR_BLOCK_SIZE_REQD, opt,\n\n                                          errp,\n\n                                          \"request NBD_INFO_BLOCK_SIZE to \"\n\n                                          \"use this export\");\n\n    }\n\n\n\n    /* Final reply */\n\n    rc = nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, opt, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    if (opt == NBD_OPT_GO) {\n\n        client->exp = exp;\n\n        QTAILQ_INSERT_TAIL(&client->exp->clients, client, next);\n\n        nbd_export_get(client->exp);\n\n        rc = 1;\n\n    }\n\n    return rc;\n\n\n\n invalid:\n\n    if (nbd_drop(client->ioc, length, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    return nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_INVALID, opt,\n\n                                      errp, \"%s\", msg);\n\n}\n", "idx": 5673, "_split": "test", "_hash": "01691485f799507b903b4b6037c7a14c"}
{"project": "qemu", "commit_id": "28b70c9dbdce0d517ade9c04c7d7ae05c8b76d2f", "target": 0, "func": "static int scsi_req_stream_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)\n\n{\n\n    switch (buf[0]) {\n\n    /* stream commands */\n\n    case ERASE_12:\n\n    case ERASE_16:\n\n        cmd->xfer = 0;\n\n        break;\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case WRITE_6:\n\n        cmd->len = 6;\n\n        cmd->xfer = buf[4] | (buf[3] << 8) | (buf[2] << 16);\n\n        if (buf[1] & 0x01) { /* fixed */\n\n            cmd->xfer *= dev->blocksize;\n\n        }\n\n        break;\n\n    case READ_16:\n\n    case READ_REVERSE_16:\n\n    case VERIFY_16:\n\n    case WRITE_16:\n\n        cmd->len = 16;\n\n        cmd->xfer = buf[14] | (buf[13] << 8) | (buf[12] << 16);\n\n        if (buf[1] & 0x01) { /* fixed */\n\n            cmd->xfer *= dev->blocksize;\n\n        }\n\n        break;\n\n    case REWIND:\n\n    case LOAD_UNLOAD:\n\n        cmd->len = 6;\n\n        cmd->xfer = 0;\n\n        break;\n\n    case SPACE_16:\n\n        cmd->xfer = buf[13] | (buf[12] << 8);\n\n        break;\n\n    case READ_POSITION:\n\n        cmd->xfer = buf[8] | (buf[7] << 8);\n\n        break;\n\n    case FORMAT_UNIT:\n\n        cmd->xfer = buf[4] | (buf[3] << 8);\n\n        break;\n\n    /* generic commands */\n\n    default:\n\n        return scsi_req_length(cmd, dev, buf);\n\n    }\n\n    return 0;\n\n}\n", "idx": 5676, "_split": "test", "_hash": "ce7a9c87bd191a1b6db5723cf415b529"}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_tst_cc (DisasContext *dc, TCGv cc, int cond)\n\n{\n\n\tint arith_opt, move_opt;\n\n\n\n\t/* TODO: optimize more condition codes.  */\n\n\n\n\t/*\n\n\t * If the flags are live, we've gotta look into the bits of CCS.\n\n\t * Otherwise, if we just did an arithmetic operation we try to\n\n\t * evaluate the condition code faster.\n\n\t *\n\n\t * When this function is done, T0 should be non-zero if the condition\n\n\t * code is true.\n\n\t */\n\n\tarith_opt = arith_cc(dc) && !dc->flags_uptodate;\n\n\tmove_opt = (dc->cc_op == CC_OP_MOVE) && dc->flags_uptodate;\n\n\tswitch (cond) {\n\n\t\tcase CC_EQ:\n\n\t\t\tif (arith_opt || move_opt) {\n\n\t\t\t\t/* If cc_result is zero, T0 should be \n\n\t\t\t\t   non-zero otherwise T0 should be zero.  */\n\n\t\t\t\tint l1;\n\n\t\t\t\tl1 = gen_new_label();\n\n\t\t\t\ttcg_gen_movi_tl(cc, 0);\n\n\t\t\t\ttcg_gen_brcondi_tl(TCG_COND_NE, cc_result, \n\n\t\t\t\t\t\t   0, l1);\n\n\t\t\t\ttcg_gen_movi_tl(cc, 1);\n\n\t\t\t\tgen_set_label(l1);\n\n\t\t\t}\n\n\t\t\telse {\n\n\t\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t\ttcg_gen_andi_tl(cc, \n\n\t\t\t\t\t\tcpu_PR[PR_CCS], Z_FLAG);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_NE:\n\n\t\t\tif (arith_opt || move_opt)\n\n\t\t\t\ttcg_gen_mov_tl(cc, cc_result);\n\n\t\t\telse {\n\n\t\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t\ttcg_gen_xori_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\t\tZ_FLAG);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, Z_FLAG);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_CS:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS], C_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_CC:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_xori_tl(cc, cpu_PR[PR_CCS], C_FLAG);\n\n\t\t\ttcg_gen_andi_tl(cc, cc, C_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_VS:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS], V_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_VC:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_xori_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\tV_FLAG);\n\n\t\t\ttcg_gen_andi_tl(cc, cc, V_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_PL:\n\n\t\t\tif (arith_opt || move_opt) {\n\n\t\t\t\tint bits = 31;\n\n\n\n\t\t\t\tif (dc->cc_size == 1)\n\n\t\t\t\t\tbits = 7;\n\n\t\t\t\telse if (dc->cc_size == 2)\n\n\t\t\t\t\tbits = 15;\t\n\n\n\n\t\t\t\ttcg_gen_shri_tl(cc, cc_result, bits);\n\n\t\t\t\ttcg_gen_xori_tl(cc, cc, 1);\n\n\t\t\t} else {\n\n\t\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t\ttcg_gen_xori_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\t\tN_FLAG);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, N_FLAG);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_MI:\n\n\t\t\tif (arith_opt || move_opt) {\n\n\t\t\t\tint bits = 31;\n\n\n\n\t\t\t\tif (dc->cc_size == 1)\n\n\t\t\t\t\tbits = 7;\n\n\t\t\t\telse if (dc->cc_size == 2)\n\n\t\t\t\t\tbits = 15;\t\n\n\n\n\t\t\t\ttcg_gen_shri_tl(cc, cc_result, 31);\n\n\t\t\t}\n\n\t\t\telse {\n\n\t\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\t\tN_FLAG);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_LS:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\tC_FLAG | Z_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_HI:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t{\n\n\t\t\t\tTCGv tmp;\n\n\n\n\t\t\t\ttmp = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\t\ttcg_gen_xori_tl(tmp, cpu_PR[PR_CCS],\n\n\t\t\t\t\t\tC_FLAG | Z_FLAG);\n\n\t\t\t\t/* Overlay the C flag on top of the Z.  */\n\n\t\t\t\ttcg_gen_shli_tl(cc, tmp, 2);\n\n\t\t\t\ttcg_gen_and_tl(cc, tmp, cc);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, Z_FLAG);\n\n\n\n\t\t\t\ttcg_temp_free(tmp);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_GE:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t/* Overlay the V flag on top of the N.  */\n\n\t\t\ttcg_gen_shli_tl(cc, cpu_PR[PR_CCS], 2);\n\n\t\t\ttcg_gen_xor_tl(cc,\n\n\t\t\t\t       cpu_PR[PR_CCS], cc);\n\n\t\t\ttcg_gen_andi_tl(cc, cc, N_FLAG);\n\n\t\t\ttcg_gen_xori_tl(cc, cc, N_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_LT:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t/* Overlay the V flag on top of the N.  */\n\n\t\t\ttcg_gen_shli_tl(cc, cpu_PR[PR_CCS], 2);\n\n\t\t\ttcg_gen_xor_tl(cc,\n\n\t\t\t\t       cpu_PR[PR_CCS], cc);\n\n\t\t\ttcg_gen_andi_tl(cc, cc, N_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_GT:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t{\n\n\t\t\t\tTCGv n, z;\n\n\n\n\t\t\t\tn = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\t\tz = tcg_temp_new(TCG_TYPE_TL);\n\n\n\n\t\t\t\t/* To avoid a shift we overlay everything on\n\n\t\t\t\t   the V flag.  */\n\n\t\t\t\ttcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2);\n\n\t\t\t\ttcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1);\n\n\t\t\t\t/* invert Z.  */\n\n\t\t\t\ttcg_gen_xori_tl(z, z, 2);\n\n\n\n\t\t\t\ttcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]);\n\n\t\t\t\ttcg_gen_xori_tl(n, n, 2);\n\n\t\t\t\ttcg_gen_and_tl(cc, z, n);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, 2);\n\n\n\n\t\t\t\ttcg_temp_free(n);\n\n\t\t\t\ttcg_temp_free(z);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_LE:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t{\n\n\t\t\t\tTCGv n, z;\n\n\n\n\t\t\t\tn = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\t\tz = tcg_temp_new(TCG_TYPE_TL);\n\n\n\n\t\t\t\t/* To avoid a shift we overlay everything on\n\n\t\t\t\t   the V flag.  */\n\n\t\t\t\ttcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2);\n\n\t\t\t\ttcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1);\n\n\n\n\t\t\t\ttcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]);\n\n\t\t\t\ttcg_gen_or_tl(cc, z, n);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, 2);\n\n\n\n\t\t\t\ttcg_temp_free(n);\n\n\t\t\t\ttcg_temp_free(z);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_P:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS], P_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_A:\n\n\t\t\ttcg_gen_movi_tl(cc, 1);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tBUG();\n\n\t\t\tbreak;\n\n\t};\n\n}\n", "idx": 5694, "_split": "test", "_hash": "61b99f60ddfe16eb02a6fda38c9e04d1"}
{"project": "qemu", "commit_id": "b4854f1384176d897747de236f426d020668fa3c", "target": 0, "func": "void do_smm_enter(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    CPUState *cs = CPU(cpu);\n\n    target_ulong sm_state;\n\n    SegmentCache *dt;\n\n    int i, offset;\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"SMM: enter\\n\");\n\n    log_cpu_state_mask(CPU_LOG_INT, CPU(cpu), CPU_DUMP_CCOP);\n\n\n\n    env->hflags |= HF_SMM_MASK;\n\n    if (env->hflags2 & HF2_NMI_MASK) {\n\n        env->hflags2 |= HF2_SMM_INSIDE_NMI_MASK;\n\n    } else {\n\n        env->hflags2 |= HF2_NMI_MASK;\n\n    }\n\n    cpu_smm_update(env);\n\n\n\n    sm_state = env->smbase + 0x8000;\n\n\n\n#ifdef TARGET_X86_64\n\n    for (i = 0; i < 6; i++) {\n\n        dt = &env->segs[i];\n\n        offset = 0x7e00 + i * 16;\n\n        x86_stw_phys(cs, sm_state + offset, dt->selector);\n\n        x86_stw_phys(cs, sm_state + offset + 2, (dt->flags >> 8) & 0xf0ff);\n\n        x86_stl_phys(cs, sm_state + offset + 4, dt->limit);\n\n        x86_stq_phys(cs, sm_state + offset + 8, dt->base);\n\n    }\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7e68, env->gdt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e64, env->gdt.limit);\n\n\n\n    x86_stw_phys(cs, sm_state + 0x7e70, env->ldt.selector);\n\n    x86_stq_phys(cs, sm_state + 0x7e78, env->ldt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e74, env->ldt.limit);\n\n    x86_stw_phys(cs, sm_state + 0x7e72, (env->ldt.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7e88, env->idt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e84, env->idt.limit);\n\n\n\n    x86_stw_phys(cs, sm_state + 0x7e90, env->tr.selector);\n\n    x86_stq_phys(cs, sm_state + 0x7e98, env->tr.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e94, env->tr.limit);\n\n    x86_stw_phys(cs, sm_state + 0x7e92, (env->tr.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7ed0, env->efer);\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7ff8, env->regs[R_EAX]);\n\n    x86_stq_phys(cs, sm_state + 0x7ff0, env->regs[R_ECX]);\n\n    x86_stq_phys(cs, sm_state + 0x7fe8, env->regs[R_EDX]);\n\n    x86_stq_phys(cs, sm_state + 0x7fe0, env->regs[R_EBX]);\n\n    x86_stq_phys(cs, sm_state + 0x7fd8, env->regs[R_ESP]);\n\n    x86_stq_phys(cs, sm_state + 0x7fd0, env->regs[R_EBP]);\n\n    x86_stq_phys(cs, sm_state + 0x7fc8, env->regs[R_ESI]);\n\n    x86_stq_phys(cs, sm_state + 0x7fc0, env->regs[R_EDI]);\n\n    for (i = 8; i < 16; i++) {\n\n        x86_stq_phys(cs, sm_state + 0x7ff8 - i * 8, env->regs[i]);\n\n    }\n\n    x86_stq_phys(cs, sm_state + 0x7f78, env->eip);\n\n    x86_stl_phys(cs, sm_state + 0x7f70, cpu_compute_eflags(env));\n\n    x86_stl_phys(cs, sm_state + 0x7f68, env->dr[6]);\n\n    x86_stl_phys(cs, sm_state + 0x7f60, env->dr[7]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7f48, env->cr[4]);\n\n    x86_stq_phys(cs, sm_state + 0x7f50, env->cr[3]);\n\n    x86_stl_phys(cs, sm_state + 0x7f58, env->cr[0]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7efc, SMM_REVISION_ID);\n\n    x86_stl_phys(cs, sm_state + 0x7f00, env->smbase);\n\n#else\n\n    x86_stl_phys(cs, sm_state + 0x7ffc, env->cr[0]);\n\n    x86_stl_phys(cs, sm_state + 0x7ff8, env->cr[3]);\n\n    x86_stl_phys(cs, sm_state + 0x7ff4, cpu_compute_eflags(env));\n\n    x86_stl_phys(cs, sm_state + 0x7ff0, env->eip);\n\n    x86_stl_phys(cs, sm_state + 0x7fec, env->regs[R_EDI]);\n\n    x86_stl_phys(cs, sm_state + 0x7fe8, env->regs[R_ESI]);\n\n    x86_stl_phys(cs, sm_state + 0x7fe4, env->regs[R_EBP]);\n\n    x86_stl_phys(cs, sm_state + 0x7fe0, env->regs[R_ESP]);\n\n    x86_stl_phys(cs, sm_state + 0x7fdc, env->regs[R_EBX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fd8, env->regs[R_EDX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fd4, env->regs[R_ECX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fd0, env->regs[R_EAX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fcc, env->dr[6]);\n\n    x86_stl_phys(cs, sm_state + 0x7fc8, env->dr[7]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7fc4, env->tr.selector);\n\n    x86_stl_phys(cs, sm_state + 0x7f64, env->tr.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f60, env->tr.limit);\n\n    x86_stl_phys(cs, sm_state + 0x7f5c, (env->tr.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7fc0, env->ldt.selector);\n\n    x86_stl_phys(cs, sm_state + 0x7f80, env->ldt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f7c, env->ldt.limit);\n\n    x86_stl_phys(cs, sm_state + 0x7f78, (env->ldt.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7f74, env->gdt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f70, env->gdt.limit);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7f58, env->idt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f54, env->idt.limit);\n\n\n\n    for (i = 0; i < 6; i++) {\n\n        dt = &env->segs[i];\n\n        if (i < 3) {\n\n            offset = 0x7f84 + i * 12;\n\n        } else {\n\n            offset = 0x7f2c + (i - 3) * 12;\n\n        }\n\n        x86_stl_phys(cs, sm_state + 0x7fa8 + i * 4, dt->selector);\n\n        x86_stl_phys(cs, sm_state + offset + 8, dt->base);\n\n        x86_stl_phys(cs, sm_state + offset + 4, dt->limit);\n\n        x86_stl_phys(cs, sm_state + offset, (dt->flags >> 8) & 0xf0ff);\n\n    }\n\n    x86_stl_phys(cs, sm_state + 0x7f14, env->cr[4]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7efc, SMM_REVISION_ID);\n\n    x86_stl_phys(cs, sm_state + 0x7ef8, env->smbase);\n\n#endif\n\n    /* init SMM cpu state */\n\n\n\n#ifdef TARGET_X86_64\n\n    cpu_load_efer(env, 0);\n\n#endif\n\n    cpu_load_eflags(env, 0, ~(CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C |\n\n                              DF_MASK));\n\n    env->eip = 0x00008000;\n\n    cpu_x86_update_cr0(env,\n\n                       env->cr[0] & ~(CR0_PE_MASK | CR0_EM_MASK | CR0_TS_MASK |\n\n                                      CR0_PG_MASK));\n\n    cpu_x86_update_cr4(env, 0);\n\n    env->dr[7] = 0x00000400;\n\n\n\n    cpu_x86_load_seg_cache(env, R_CS, (env->smbase >> 4) & 0xffff, env->smbase,\n\n                           0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_SS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n}\n", "idx": 5707, "_split": "test", "_hash": "1c039c4ea86a026f10379178fb0ac860"}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,\n\n                        const char *default_devaddr)\n\n{\n\n    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;\n\n    PCIDevice *pci_dev;\n\n    DeviceState *dev;\n\n    int i;\n\n\n\n    i = qemu_check_nic_model_list(nd, pci_nic_models, default_model);\n\n    pci_dev = pci_create(pci_nic_names[i], devaddr);\n\n    dev = &pci_dev->qdev;\n\n    if (nd->id)\n\n        dev->id = qemu_strdup(nd->id);\n\n    dev->nd = nd;\n\n    qdev_init(dev);\n\n    nd->private = dev;\n\n    return pci_dev;\n\n}\n", "idx": 5718, "_split": "test", "_hash": "9fe6fdf66e32cf859daa54f5fc36d2cb"}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void qxl_realize_common(PCIQXLDevice *qxl, Error **errp)\n\n{\n\n    uint8_t* config = qxl->pci.config;\n\n    uint32_t pci_device_rev;\n\n    uint32_t io_size;\n\n\n\n    qxl->mode = QXL_MODE_UNDEFINED;\n\n    qxl->generation = 1;\n\n    qxl->num_memslots = NUM_MEMSLOTS;\n\n    qemu_mutex_init(&qxl->track_lock);\n\n    qemu_mutex_init(&qxl->async_lock);\n\n    qxl->current_async = QXL_UNDEFINED_IO;\n\n    qxl->guest_bug = 0;\n\n\n\n    switch (qxl->revision) {\n\n    case 1: /* spice 0.4 -- qxl-1 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V04;\n\n        io_size = 8;\n\n        break;\n\n    case 2: /* spice 0.6 -- qxl-2 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V06;\n\n        io_size = 16;\n\n        break;\n\n    case 3: /* qxl-3 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V10;\n\n        io_size = 32; /* PCI region size must be pow2 */\n\n        break;\n\n    case 4: /* qxl-4 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V12;\n\n        io_size = pow2ceil(QXL_IO_RANGE_SIZE);\n\n        break;\n\n    default:\n\n        error_setg(errp, \"Invalid revision %d for qxl device (max %d)\",\n\n                   qxl->revision, QXL_DEFAULT_REVISION);\n\n        return;\n\n    }\n\n\n\n    pci_set_byte(&config[PCI_REVISION_ID], pci_device_rev);\n\n    pci_set_byte(&config[PCI_INTERRUPT_PIN], 1);\n\n\n\n    qxl->rom_size = qxl_rom_size();\n\n    memory_region_init_ram(&qxl->rom_bar, OBJECT(qxl), \"qxl.vrom\",\n\n                           qxl->rom_size, &error_abort);\n\n    vmstate_register_ram(&qxl->rom_bar, &qxl->pci.qdev);\n\n    init_qxl_rom(qxl);\n\n    init_qxl_ram(qxl);\n\n\n\n    qxl->guest_surfaces.cmds = g_new0(QXLPHYSICAL, qxl->ssd.num_surfaces);\n\n    memory_region_init_ram(&qxl->vram_bar, OBJECT(qxl), \"qxl.vram\",\n\n                           qxl->vram_size, &error_abort);\n\n    vmstate_register_ram(&qxl->vram_bar, &qxl->pci.qdev);\n\n    memory_region_init_alias(&qxl->vram32_bar, OBJECT(qxl), \"qxl.vram32\",\n\n                             &qxl->vram_bar, 0, qxl->vram32_size);\n\n\n\n    memory_region_init_io(&qxl->io_bar, OBJECT(qxl), &qxl_io_ops, qxl,\n\n                          \"qxl-ioports\", io_size);\n\n    if (qxl->id == 0) {\n\n        vga_dirty_log_start(&qxl->vga);\n\n    }\n\n    memory_region_set_flush_coalesced(&qxl->io_bar);\n\n\n\n\n\n    pci_register_bar(&qxl->pci, QXL_IO_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_IO, &qxl->io_bar);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_ROM_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->rom_bar);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_RAM_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->vga.vram);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_VRAM_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->vram32_bar);\n\n\n\n    if (qxl->vram32_size < qxl->vram_size) {\n\n        /*\n\n         * Make the 64bit vram bar show up only in case it is\n\n         * configured to be larger than the 32bit vram bar.\n\n         */\n\n        pci_register_bar(&qxl->pci, QXL_VRAM64_RANGE_INDEX,\n\n                         PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                         PCI_BASE_ADDRESS_MEM_TYPE_64 |\n\n                         PCI_BASE_ADDRESS_MEM_PREFETCH,\n\n                         &qxl->vram_bar);\n\n    }\n\n\n\n    /* print pci bar details */\n\n    dprint(qxl, 1, \"ram/%s: %d MB [region 0]\\n\",\n\n           qxl->id == 0 ? \"pri\" : \"sec\",\n\n           qxl->vga.vram_size / (1024*1024));\n\n    dprint(qxl, 1, \"vram/32: %d MB [region 1]\\n\",\n\n           qxl->vram32_size / (1024*1024));\n\n    dprint(qxl, 1, \"vram/64: %d MB %s\\n\",\n\n           qxl->vram_size / (1024*1024),\n\n           qxl->vram32_size < qxl->vram_size ? \"[region 4]\" : \"[unmapped]\");\n\n\n\n    qxl->ssd.qxl.base.sif = &qxl_interface.base;\n\n    if (qemu_spice_add_display_interface(&qxl->ssd.qxl, qxl->vga.con) != 0) {\n\n        error_setg(errp, \"qxl interface %d.%d not supported by spice-server\",\n\n                   SPICE_INTERFACE_QXL_MAJOR, SPICE_INTERFACE_QXL_MINOR);\n\n        return;\n\n    }\n\n    qemu_add_vm_change_state_handler(qxl_vm_change_state_handler, qxl);\n\n\n\n    qxl->update_irq = qemu_bh_new(qxl_update_irq_bh, qxl);\n\n    qxl_reset_state(qxl);\n\n\n\n    qxl->update_area_bh = qemu_bh_new(qxl_render_update_area_bh, qxl);\n\n    qxl->ssd.cursor_bh = qemu_bh_new(qemu_spice_cursor_refresh_bh, &qxl->ssd);\n\n}\n", "idx": 5767, "_split": "test", "_hash": "e494b63dfe6b3cf530df5ba754d3c1fb"}
{"project": "qemu", "commit_id": "4c4f0e4801ac79632d03867c88aafc90b4ce503c", "target": 1, "func": "static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)\n\n{\n\n    OpenPICState *opp = opaque;\n\n    uint32_t retval = -1;\n\n    int idx;\n\n\n\n    DPRINTF(\"%s: addr %08x\\n\", __func__, addr);\n\n    if (addr & 0xF) {\n\n        goto out;\n\n    }\n\n    idx = (addr >> 6) & 0x3;\n\n    if (addr == 0x0) {\n\n        /* TIFR (TFRR) */\n\n        retval = opp->tifr;\n\n        goto out;\n\n    }\n\n    switch (addr & 0x30) {\n\n    case 0x00: /* TICC (GTCCR) */\n\n        retval = opp->timers[idx].ticc;\n\n        break;\n\n    case 0x10: /* TIBC (GTBCR) */\n\n        retval = opp->timers[idx].tibc;\n\n        break;\n\n    case 0x20: /* TIPV (TIPV) */\n\n        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);\n\n        break;\n\n    case 0x30: /* TIDE (TIDR) */\n\n        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);\n\n        break;\n\n    }\n\n\n\nout:\n\n    DPRINTF(\"%s: => %08x\\n\", __func__, retval);\n\n\n\n    return retval;\n\n}\n", "idx": 5797, "_split": "test", "_hash": "bcb97ebe69b55d1a54fc930efd25e2e4"}
{"project": "qemu", "commit_id": "40f860cd6c1aa0d3399e3f8158f20bdc5b2bfbfe", "target": 0, "func": "static void gen_exception_insn(DisasContext *s, int offset, int excp)\n\n{\n\n    gen_a64_set_pc_im(s->pc - offset);\n\n    gen_exception(excp);\n\n    s->is_jmp = DISAS_JUMP;\n\n}\n", "idx": 5810, "_split": "test", "_hash": "5660db6e64fcc3a871b9877d2371ff2d"}
{"project": "qemu", "commit_id": "ca6b6e1e68ac44b2e8895da10dd1c80dc03d08b7", "target": 0, "func": "static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp)\n\n{\n\n    const QDictEntry *ent;\n\n    const char *arg_name;\n\n    const QObject *arg_obj;\n\n    bool has_exec_key = false;\n\n    QDict *dict = NULL;\n\n\n\n    if (qobject_type(request) != QTYPE_QDICT) {\n\n        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT,\n\n                   \"request is not a dictionary\");\n\n        return NULL;\n\n    }\n\n\n\n    dict = qobject_to_qdict(request);\n\n\n\n    for (ent = qdict_first(dict); ent;\n\n         ent = qdict_next(dict, ent)) {\n\n        arg_name = qdict_entry_key(ent);\n\n        arg_obj = qdict_entry_value(ent);\n\n\n\n        if (!strcmp(arg_name, \"execute\")) {\n\n            if (qobject_type(arg_obj) != QTYPE_QSTRING) {\n\n                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, \"execute\",\n\n                           \"string\");\n\n                return NULL;\n\n            }\n\n            has_exec_key = true;\n\n        } else if (strcmp(arg_name, \"arguments\")) {\n\n            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if (!has_exec_key) {\n\n        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, \"execute\");\n\n        return NULL;\n\n    }\n\n\n\n    return dict;\n\n}\n", "idx": 5820, "_split": "test", "_hash": "c92b90a53646f4db51080ade5064a0e0"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_int64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    int64_t *v = pv;\n\n    qemu_get_sbe64s(f, v);\n\n    return 0;\n\n}\n", "idx": 5834, "_split": "test", "_hash": "0a2ad3e1196fc654ab08b168fc54ce88"}
{"project": "qemu", "commit_id": "ad5b88b1f198182642b6cbf3dacb4cade0c80fb9", "target": 1, "func": "static void acpi_build_update(void *build_opaque, uint32_t offset)\n\n{\n\n    AcpiBuildState *build_state = build_opaque;\n\n    AcpiBuildTables tables;\n\n\n\n    /* No state to update or already patched? Nothing to do. */\n\n    if (!build_state || build_state->patched) {\n\n        return;\n\n    }\n\n    build_state->patched = 1;\n\n\n\n    acpi_build_tables_init(&tables);\n\n\n\n    acpi_build(build_state->guest_info, &tables);\n\n\n\n    assert(acpi_data_len(tables.table_data) == build_state->table_size);\n\n    memcpy(build_state->table_ram, tables.table_data->data,\n\n           build_state->table_size);\n\n\n\n    acpi_build_tables_cleanup(&tables, true);\n\n}\n", "idx": 5837, "_split": "test", "_hash": "edd96d758c4035b1a752423289b36343"}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(slw)\n\n{\n\n    if (T1 & 0x20) {\n\n        T0 = 0;\n\n    } else {\n\n        T0 = T0 << T1;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 5855, "_split": "test", "_hash": "74271c52adb3b9b6c135a7b6b338da88"}
{"project": "qemu", "commit_id": "e5ba83c53add51796e8ea787d2b7cb1f9c3cb72d", "target": 0, "func": "CPUState *ppc440ep_init(MemoryRegion *address_space_mem, ram_addr_t *ram_size,\n\n                        PCIBus **pcip, const unsigned int pci_irq_nrs[4],\n\n                        int do_init, const char *cpu_model)\n\n{\n\n    MemoryRegion *ram_memories\n\n        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));\n\n    target_phys_addr_t ram_bases[PPC440EP_SDRAM_NR_BANKS];\n\n    target_phys_addr_t ram_sizes[PPC440EP_SDRAM_NR_BANKS];\n\n    CPUState *env;\n\n    qemu_irq *pic;\n\n    qemu_irq *irqs;\n\n    qemu_irq *pci_irqs;\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"440-Xilinx\"; // XXX: should be 440EP\n\n    }\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    ppc_booke_timers_init(env, 400000000, 0);\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n\n\n    /* SDRAM controller */\n\n    memset(ram_bases, 0, sizeof(ram_bases));\n\n    memset(ram_sizes, 0, sizeof(ram_sizes));\n\n    *ram_size = ppc4xx_sdram_adjust(*ram_size, PPC440EP_SDRAM_NR_BANKS,\n\n                                    ram_memories,\n\n                                    ram_bases, ram_sizes,\n\n                                    ppc440ep_sdram_bank_sizes);\n\n    /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */\n\n    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,\n\n                      ram_bases, ram_sizes, do_init);\n\n\n\n    /* PCI */\n\n    pci_irqs = g_malloc(sizeof(qemu_irq) * 4);\n\n    pci_irqs[0] = pic[pci_irq_nrs[0]];\n\n    pci_irqs[1] = pic[pci_irq_nrs[1]];\n\n    pci_irqs[2] = pic[pci_irq_nrs[2]];\n\n    pci_irqs[3] = pic[pci_irq_nrs[3]];\n\n    *pcip = ppc4xx_pci_init(env, pci_irqs,\n\n                            PPC440EP_PCI_CONFIG,\n\n                            PPC440EP_PCI_INTACK,\n\n                            PPC440EP_PCI_SPECIAL,\n\n                            PPC440EP_PCI_REGS);\n\n    if (!*pcip)\n\n        printf(\"couldn't create PCI controller!\\n\");\n\n\n\n    isa_mmio_init(PPC440EP_PCI_IO, PPC440EP_PCI_IOLEN);\n\n\n\n    if (serial_hds[0] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600300, 0, pic[0],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[0],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n    if (serial_hds[1] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600400, 0, pic[1],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[1],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    return env;\n\n}\n", "idx": 5875, "_split": "test", "_hash": "9f45dacb3fce45c91f1dc7d6900012b2"}
{"project": "qemu", "commit_id": "146beee5d9f94d96ab3bf54ac355a263290b75ac", "target": 0, "func": "static int piix4_initfn(PCIDevice *dev)\n\n{\n\n    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);\n\n    uint8_t *pci_conf;\n\n\n\n    isa_bus_new(&d->dev.qdev);\n\n\n\n    pci_conf = d->dev.config;\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge\n\n    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);\n\n\n\n    piix4_dev = &d->dev;\n\n    qemu_register_reset(piix4_reset, d);\n\n    return 0;\n\n}\n", "idx": 5899, "_split": "test", "_hash": "2fc6e17e02fe6b1b6c1cef335128d602"}
{"project": "qemu", "commit_id": "100f8f26086ad85a9361f2883edd55bc337ce594", "target": 1, "func": "void throttle_account(ThrottleState *ts, bool is_write, uint64_t size)\n\n{\n\n    double units = 1.0;\n\n\n\n    /* if cfg.op_size is defined and smaller than size we compute unit count */\n\n    if (ts->cfg.op_size && size > ts->cfg.op_size) {\n\n        units = (double) size / ts->cfg.op_size;\n\n    }\n\n\n\n    ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += size;\n\n    ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;\n\n\n\n    if (is_write) {\n\n        ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size;\n\n        ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units;\n\n    } else {\n\n        ts->cfg.buckets[THROTTLE_BPS_READ].level += size;\n\n        ts->cfg.buckets[THROTTLE_OPS_READ].level += units;\n\n    }\n\n}\n", "idx": 5920, "_split": "test", "_hash": "1d1bf46d4ac3cac2584a817eb698c331"}
{"project": "qemu", "commit_id": "e8a095dadb70e2ea6d5169d261920db3747bfa45", "target": 1, "func": "void bdrv_remove_aio_context_notifier(BlockDriverState *bs,\n\n                                      void (*attached_aio_context)(AioContext *,\n\n                                                                   void *),\n\n                                      void (*detach_aio_context)(void *),\n\n                                      void *opaque)\n\n{\n\n    BdrvAioNotifier *ban, *ban_next;\n\n\n\n    QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_next) {\n\n        if (ban->attached_aio_context == attached_aio_context &&\n\n            ban->detach_aio_context   == detach_aio_context   &&\n\n            ban->opaque               == opaque)\n\n        {\n\n            QLIST_REMOVE(ban, list);\n\n            g_free(ban);\n\n\n\n            return;\n\n        }\n\n    }\n\n\n\n    abort();\n\n}\n", "idx": 5931, "_split": "test", "_hash": "1b154649afc525581135e39a509fa346"}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)\n\n{\n\n    TCGv_i64 tmp;\n\n    TCGv tmp2;\n\n\n\n    /* Load value and extend to 64 bits.  */\n\n    tmp = tcg_temp_new_i64();\n\n    tmp2 = load_reg(s, rlow);\n\n    tcg_gen_extu_i32_i64(tmp, tmp2);\n\n    dead_tmp(tmp2);\n\n    tcg_gen_add_i64(val, val, tmp);\n\n    tcg_temp_free_i64(tmp);\n\n}\n", "idx": 5962, "_split": "test", "_hash": "8af9cd41429bd8bbd830ecd7e3b9da05"}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void test_bmdma_simple_rw(void)\n\n{\n\n    QPCIDevice *dev;\n\n    void *bmdma_base, *ide_base;\n\n    uint8_t status;\n\n    uint8_t *buf;\n\n    uint8_t *cmpbuf;\n\n    size_t len = 512;\n\n    uintptr_t guest_buf = guest_alloc(guest_malloc, len);\n\n\n\n    PrdtEntry prdt[] = {\n\n        {\n\n            .addr = cpu_to_le32(guest_buf),\n\n            .size = cpu_to_le32(len | PRDT_EOT),\n\n        },\n\n    };\n\n\n\n    dev = get_pci_device(&bmdma_base, &ide_base);\n\n\n\n    buf = g_malloc(len);\n\n    cmpbuf = g_malloc(len);\n\n\n\n    /* Write 0x55 pattern to sector 0 */\n\n    memset(buf, 0x55, len);\n\n    memwrite(guest_buf, buf, len);\n\n\n\n    status = send_dma_request(CMD_WRITE_DMA, 0, 1, prdt,\n\n                              ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    /* Write 0xaa pattern to sector 1 */\n\n    memset(buf, 0xaa, len);\n\n    memwrite(guest_buf, buf, len);\n\n\n\n    status = send_dma_request(CMD_WRITE_DMA, 1, 1, prdt,\n\n                              ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    /* Read and verify 0x55 pattern in sector 0 */\n\n    memset(cmpbuf, 0x55, len);\n\n\n\n    status = send_dma_request(CMD_READ_DMA, 0, 1, prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    memread(guest_buf, buf, len);\n\n    g_assert(memcmp(buf, cmpbuf, len) == 0);\n\n\n\n    /* Read and verify 0xaa pattern in sector 1 */\n\n    memset(cmpbuf, 0xaa, len);\n\n\n\n    status = send_dma_request(CMD_READ_DMA, 1, 1, prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    memread(guest_buf, buf, len);\n\n    g_assert(memcmp(buf, cmpbuf, len) == 0);\n\n\n\n\n\n    g_free(buf);\n\n    g_free(cmpbuf);\n\n}\n", "idx": 5963, "_split": "test", "_hash": "d1c0a727fbe83e838918d0be743057c9"}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s)\n\n{\n\n    VirtIOBlockReq *req = virtio_blk_alloc_request(s);\n\n\n\n    if (!virtqueue_pop(s->vq, &req->elem)) {\n\n        virtio_blk_free_request(req);\n\n        return NULL;\n\n    }\n\n\n\n    return req;\n\n}\n", "idx": 6007, "_split": "test", "_hash": "586872a6dab227ba29a16f5d9d1894ed"}
{"project": "qemu", "commit_id": "ea375f9ab8c76686dca0af8cb4f87a4eb569cad3", "target": 1, "func": "void qemu_system_reset(void)\n\n{\n\n    QEMUResetEntry *re, *nre;\n\n\n\n    /* reset all devices */\n\n    QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, nre) {\n\n        re->func(re->opaque);\n\n    }\n\n\n}", "idx": 6025, "_split": "test", "_hash": "ee9171f4446be315619f25800941089a"}
{"project": "qemu", "commit_id": "a9c0183059d6a4e4d940cd86ac0f9402b0655d24", "target": 0, "func": "static void sd_reset(SDState *sd, BlockDriverState *bdrv)\n\n{\n\n    uint64_t size;\n\n    uint64_t sect;\n\n\n\n    if (bdrv) {\n\n        bdrv_get_geometry(bdrv, &sect);\n\n    } else {\n\n        sect = 0;\n\n    }\n\n    size = sect << 9;\n\n\n\n    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;\n\n\n\n    sd->state = sd_idle_state;\n\n    sd->rca = 0x0000;\n\n    sd_set_ocr(sd);\n\n    sd_set_scr(sd);\n\n    sd_set_cid(sd);\n\n    sd_set_csd(sd, size);\n\n    sd_set_cardstatus(sd);\n\n    sd_set_sdstatus(sd);\n\n\n\n    sd->bdrv = bdrv;\n\n\n\n    if (sd->wp_groups)\n\n        g_free(sd->wp_groups);\n\n    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;\n\n    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);\n\n    memset(sd->function_group, 0, sizeof(int) * 6);\n\n    sd->erase_start = 0;\n\n    sd->erase_end = 0;\n\n    sd->size = size;\n\n    sd->blk_len = 0x200;\n\n    sd->pwd_len = 0;\n\n    sd->expecting_acmd = 0;\n\n}\n", "idx": 6032, "_split": "test", "_hash": "072b5563e1c73fe719e726ab635ddf73"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void phys_page_set(AddressSpaceDispatch *d,\n\n                          target_phys_addr_t index, target_phys_addr_t nb,\n\n                          uint16_t leaf)\n\n{\n\n    /* Wildly overreserve - it doesn't matter much. */\n\n    phys_map_node_reserve(3 * P_L2_LEVELS);\n\n\n\n    phys_page_set_level(&d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);\n\n}\n", "idx": 6033, "_split": "test", "_hash": "230acf4a9e624eb057dabbf8727719b3"}
{"project": "qemu", "commit_id": "425532d71d5d295cc9c649500e4969ac621ce51d", "target": 0, "func": "static inline void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n\n                              const int *const_args)\n\n{\n\n    int c;\n\n\n\n    switch (opc) {\n\n    case INDEX_op_exit_tb:\n\n        if (check_fit_tl(args[0], 13)) {\n\n            tcg_out_arithi(s, TCG_REG_G0, TCG_REG_I7, 8, RETURN);\n\n            tcg_out_movi_imm13(s, TCG_REG_O0, args[0]);\n\n        } else {\n\n            tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_I0, args[0] & ~0x3ff);\n\n            tcg_out_arithi(s, TCG_REG_G0, TCG_REG_I7, 8, RETURN);\n\n            tcg_out_arithi(s, TCG_REG_O0, TCG_REG_O0,\n\n                           args[0] & 0x3ff, ARITH_OR);\n\n        }\n\n        break;\n\n    case INDEX_op_goto_tb:\n\n        if (s->tb_jmp_offset) {\n\n            /* direct jump method */\n\n            uint32_t old_insn = *(uint32_t *)s->code_ptr;\n\n            s->tb_jmp_offset[args[0]] = s->code_ptr - s->code_buf;\n\n            /* Make sure to preserve links during retranslation.  */\n\n            tcg_out32(s, CALL | (old_insn & ~INSN_OP(-1)));\n\n        } else {\n\n            /* indirect jump method */\n\n            tcg_out_ld_ptr(s, TCG_REG_T1, (uintptr_t)(s->tb_next + args[0]));\n\n            tcg_out_arithi(s, TCG_REG_G0, TCG_REG_T1, 0, JMPL);\n\n        }\n\n        tcg_out_nop(s);\n\n        s->tb_next_offset[args[0]] = s->code_ptr - s->code_buf;\n\n        break;\n\n    case INDEX_op_call:\n\n        if (const_args[0]) {\n\n            tcg_out_calli(s, args[0]);\n\n        } else {\n\n            tcg_out_arithi(s, TCG_REG_O7, args[0], 0, JMPL);\n\n        }\n\n        /* delay slot */\n\n        tcg_out_nop(s);\n\n        break;\n\n    case INDEX_op_br:\n\n        tcg_out_bpcc(s, COND_A, BPCC_PT, args[0]);\n\n        tcg_out_nop(s);\n\n        break;\n\n    case INDEX_op_movi_i32:\n\n        tcg_out_movi(s, TCG_TYPE_I32, args[0], (uint32_t)args[1]);\n\n        break;\n\n\n\n#define OP_32_64(x)                             \\\n\n        glue(glue(case INDEX_op_, x), _i32):    \\\n\n        glue(glue(case INDEX_op_, x), _i64)\n\n\n\n    OP_32_64(ld8u):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDUB);\n\n        break;\n\n    OP_32_64(ld8s):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDSB);\n\n        break;\n\n    OP_32_64(ld16u):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDUH);\n\n        break;\n\n    OP_32_64(ld16s):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDSH);\n\n        break;\n\n    case INDEX_op_ld_i32:\n\n    case INDEX_op_ld32u_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDUW);\n\n        break;\n\n    OP_32_64(st8):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STB);\n\n        break;\n\n    OP_32_64(st16):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STH);\n\n        break;\n\n    case INDEX_op_st_i32:\n\n    case INDEX_op_st32_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STW);\n\n        break;\n\n    OP_32_64(add):\n\n        c = ARITH_ADD;\n\n        goto gen_arith;\n\n    OP_32_64(sub):\n\n        c = ARITH_SUB;\n\n        goto gen_arith;\n\n    OP_32_64(and):\n\n        c = ARITH_AND;\n\n        goto gen_arith;\n\n    OP_32_64(andc):\n\n        c = ARITH_ANDN;\n\n        goto gen_arith;\n\n    OP_32_64(or):\n\n        c = ARITH_OR;\n\n        goto gen_arith;\n\n    OP_32_64(orc):\n\n        c = ARITH_ORN;\n\n        goto gen_arith;\n\n    OP_32_64(xor):\n\n        c = ARITH_XOR;\n\n        goto gen_arith;\n\n    case INDEX_op_shl_i32:\n\n        c = SHIFT_SLL;\n\n    do_shift32:\n\n        /* Limit immediate shift count lest we create an illegal insn.  */\n\n        tcg_out_arithc(s, args[0], args[1], args[2] & 31, const_args[2], c);\n\n        break;\n\n    case INDEX_op_shr_i32:\n\n        c = SHIFT_SRL;\n\n        goto do_shift32;\n\n    case INDEX_op_sar_i32:\n\n        c = SHIFT_SRA;\n\n        goto do_shift32;\n\n    case INDEX_op_mul_i32:\n\n        c = ARITH_UMUL;\n\n        goto gen_arith;\n\n\n\n    OP_32_64(neg):\n\n\tc = ARITH_SUB;\n\n\tgoto gen_arith1;\n\n    OP_32_64(not):\n\n\tc = ARITH_ORN;\n\n\tgoto gen_arith1;\n\n\n\n    case INDEX_op_div_i32:\n\n        tcg_out_div32(s, args[0], args[1], args[2], const_args[2], 0);\n\n        break;\n\n    case INDEX_op_divu_i32:\n\n        tcg_out_div32(s, args[0], args[1], args[2], const_args[2], 1);\n\n        break;\n\n\n\n    case INDEX_op_brcond_i32:\n\n        tcg_out_brcond_i32(s, args[2], args[0], args[1], const_args[1],\n\n                           args[3]);\n\n        break;\n\n    case INDEX_op_setcond_i32:\n\n        tcg_out_setcond_i32(s, args[3], args[0], args[1],\n\n                            args[2], const_args[2]);\n\n        break;\n\n    case INDEX_op_movcond_i32:\n\n        tcg_out_movcond_i32(s, args[5], args[0], args[1],\n\n                            args[2], const_args[2], args[3], const_args[3]);\n\n        break;\n\n\n\n    case INDEX_op_add2_i32:\n\n        tcg_out_addsub2(s, args[0], args[1], args[2], args[3],\n\n                        args[4], const_args[4], args[5], const_args[5],\n\n                        ARITH_ADDCC, ARITH_ADDX);\n\n        break;\n\n    case INDEX_op_sub2_i32:\n\n        tcg_out_addsub2(s, args[0], args[1], args[2], args[3],\n\n                        args[4], const_args[4], args[5], const_args[5],\n\n                        ARITH_SUBCC, ARITH_SUBX);\n\n        break;\n\n    case INDEX_op_mulu2_i32:\n\n        c = ARITH_UMUL;\n\n        goto do_mul2;\n\n    case INDEX_op_muls2_i32:\n\n        c = ARITH_SMUL;\n\n    do_mul2:\n\n        /* The 32-bit multiply insns produce a full 64-bit result.  If the\n\n           destination register can hold it, we can avoid the slower RDY.  */\n\n        tcg_out_arithc(s, args[0], args[2], args[3], const_args[3], c);\n\n        if (SPARC64 || args[0] <= TCG_REG_O7) {\n\n            tcg_out_arithi(s, args[1], args[0], 32, SHIFT_SRLX);\n\n        } else {\n\n            tcg_out_rdy(s, args[1]);\n\n        }\n\n        break;\n\n\n\n    case INDEX_op_qemu_ld_i32:\n\n        tcg_out_qemu_ld(s, args[0], args[1], args[2], args[3], false);\n\n        break;\n\n    case INDEX_op_qemu_ld_i64:\n\n        tcg_out_qemu_ld(s, args[0], args[1], args[2], args[3], true);\n\n        break;\n\n    case INDEX_op_qemu_st_i32:\n\n        tcg_out_qemu_st(s, args[0], args[1], args[2], args[3]);\n\n        break;\n\n    case INDEX_op_qemu_st_i64:\n\n        tcg_out_qemu_st(s, args[0], args[1], args[2], args[3]);\n\n        break;\n\n\n\n    case INDEX_op_movi_i64:\n\n        tcg_out_movi(s, TCG_TYPE_I64, args[0], args[1]);\n\n        break;\n\n    case INDEX_op_ld32s_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDSW);\n\n        break;\n\n    case INDEX_op_ld_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDX);\n\n        break;\n\n    case INDEX_op_st_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STX);\n\n        break;\n\n    case INDEX_op_shl_i64:\n\n        c = SHIFT_SLLX;\n\n    do_shift64:\n\n        /* Limit immediate shift count lest we create an illegal insn.  */\n\n        tcg_out_arithc(s, args[0], args[1], args[2] & 63, const_args[2], c);\n\n        break;\n\n    case INDEX_op_shr_i64:\n\n        c = SHIFT_SRLX;\n\n        goto do_shift64;\n\n    case INDEX_op_sar_i64:\n\n        c = SHIFT_SRAX;\n\n        goto do_shift64;\n\n    case INDEX_op_mul_i64:\n\n        c = ARITH_MULX;\n\n        goto gen_arith;\n\n    case INDEX_op_div_i64:\n\n        c = ARITH_SDIVX;\n\n        goto gen_arith;\n\n    case INDEX_op_divu_i64:\n\n        c = ARITH_UDIVX;\n\n        goto gen_arith;\n\n    case INDEX_op_ext32s_i64:\n\n        tcg_out_arithi(s, args[0], args[1], 0, SHIFT_SRA);\n\n        break;\n\n    case INDEX_op_ext32u_i64:\n\n        tcg_out_arithi(s, args[0], args[1], 0, SHIFT_SRL);\n\n        break;\n\n    case INDEX_op_trunc_shr_i32:\n\n        if (args[2] == 0) {\n\n            tcg_out_mov(s, TCG_TYPE_I32, args[0], args[1]);\n\n        } else {\n\n            tcg_out_arithi(s, args[0], args[1], args[2], SHIFT_SRLX);\n\n        }\n\n        break;\n\n\n\n    case INDEX_op_brcond_i64:\n\n        tcg_out_brcond_i64(s, args[2], args[0], args[1], const_args[1],\n\n                           args[3]);\n\n        break;\n\n    case INDEX_op_setcond_i64:\n\n        tcg_out_setcond_i64(s, args[3], args[0], args[1],\n\n                            args[2], const_args[2]);\n\n        break;\n\n    case INDEX_op_movcond_i64:\n\n        tcg_out_movcond_i64(s, args[5], args[0], args[1],\n\n                            args[2], const_args[2], args[3], const_args[3]);\n\n        break;\n\n\n\n    gen_arith:\n\n        tcg_out_arithc(s, args[0], args[1], args[2], const_args[2], c);\n\n        break;\n\n\n\n    gen_arith1:\n\n\ttcg_out_arithc(s, args[0], TCG_REG_G0, args[1], const_args[1], c);\n\n\tbreak;\n\n\n\n    default:\n\n        fprintf(stderr, \"unknown opcode 0x%x\\n\", opc);\n\n        tcg_abort();\n\n    }\n\n}\n", "idx": 6043, "_split": "test", "_hash": "686634bae370342096ed35b0ddc56122"}
{"project": "qemu", "commit_id": "80dcfb8532ae76343109a48f12ba8ca1c505c179", "target": 0, "func": "static int virtio_serial_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    VirtIOSerial *s = opaque;\n\n    VirtIOSerialPort *port;\n\n    uint32_t max_nr_ports, nr_active_ports, ports_map;\n\n    unsigned int i;\n\n    int ret;\n\n\n\n    if (version_id > 3) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* The virtio device */\n\n    ret = virtio_load(&s->vdev, f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (version_id < 2) {\n\n        return 0;\n\n    }\n\n\n\n    /* The config space */\n\n    qemu_get_be16s(f, &s->config.cols);\n\n    qemu_get_be16s(f, &s->config.rows);\n\n\n\n    qemu_get_be32s(f, &max_nr_ports);\n\n    tswap32s(&max_nr_ports);\n\n    if (max_nr_ports > tswap32(s->config.max_nr_ports)) {\n\n        /* Source could have had more ports than us. Fail migration. */\n\n        return -EINVAL;\n\n    }\n\n\n\n    for (i = 0; i < (max_nr_ports + 31) / 32; i++) {\n\n        qemu_get_be32s(f, &ports_map);\n\n\n\n        if (ports_map != s->ports_map[i]) {\n\n            /*\n\n             * Ports active on source and destination don't\n\n             * match. Fail migration.\n\n             */\n\n            return -EINVAL;\n\n        }\n\n    }\n\n\n\n    qemu_get_be32s(f, &nr_active_ports);\n\n\n\n    /* Items in struct VirtIOSerialPort */\n\n    for (i = 0; i < nr_active_ports; i++) {\n\n        uint32_t id;\n\n        bool host_connected;\n\n\n\n        id = qemu_get_be32(f);\n\n        port = find_port_by_id(s, id);\n\n        if (!port) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        port->guest_connected = qemu_get_byte(f);\n\n        host_connected = qemu_get_byte(f);\n\n        if (host_connected != port->host_connected) {\n\n            /*\n\n             * We have to let the guest know of the host connection\n\n             * status change\n\n             */\n\n            send_control_event(port, VIRTIO_CONSOLE_PORT_OPEN,\n\n                               port->host_connected);\n\n        }\n\n\n\n        if (version_id > 2) {\n\n            uint32_t elem_popped;\n\n\n\n            qemu_get_be32s(f, &elem_popped);\n\n            if (elem_popped) {\n\n                qemu_get_be32s(f, &port->iov_idx);\n\n                qemu_get_be64s(f, &port->iov_offset);\n\n\n\n                qemu_get_buffer(f, (unsigned char *)&port->elem,\n\n                                sizeof(port->elem));\n\n                virtqueue_map_sg(port->elem.in_sg, port->elem.in_addr,\n\n                                 port->elem.in_num, 1);\n\n                virtqueue_map_sg(port->elem.out_sg, port->elem.out_addr,\n\n                                 port->elem.out_num, 1);\n\n\n\n                /*\n\n                 *  Port was throttled on source machine.  Let's\n\n                 *  unthrottle it here so data starts flowing again.\n\n                 */\n\n                virtio_serial_throttle_port(port, false);\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 6069, "_split": "test", "_hash": "8cbfdcaa315b756246742946c4b90601"}
{"project": "qemu", "commit_id": "130257dc443574a9da91dc293665be2cfc40245a", "target": 0, "func": "static CharDriverState *qemu_chr_open_spice_port(const char *id,\n\n                                                 ChardevBackend *backend,\n\n                                                 ChardevReturn *ret,\n\n                                                 Error **errp)\n\n{\n\n    const char *name = backend->spiceport->fqdn;\n\n    CharDriverState *chr;\n\n    SpiceCharDriver *s;\n\n\n\n    if (name == NULL) {\n\n        fprintf(stderr, \"spice-qemu-char: missing name parameter\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    chr = chr_open(\"port\", spice_port_set_fe_open);\n\n    s = chr->opaque;\n\n    s->sin.portname = g_strdup(name);\n\n\n\n    return chr;\n\n}\n", "idx": 6092, "_split": "test", "_hash": "dcd2b37d32382b67b0436e0b9dc9a038"}
{"project": "qemu", "commit_id": "ec53b45bcd1f74f7a4c31331fa6d50b402cd6d26", "target": 0, "func": "void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)\n\n{\n\n#if defined(TARGET_HAS_ICE)\n\n    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);\n\n\n\n    breakpoint_invalidate(cpu, breakpoint->pc);\n\n\n\n    g_free(breakpoint);\n\n#endif\n\n}\n", "idx": 6098, "_split": "test", "_hash": "726c297cb8e8574d0a560d603dcc2a84"}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static const void *boston_fdt_filter(void *opaque, const void *fdt_orig,\n\n                                     const void *match_data, hwaddr *load_addr)\n\n{\n\n    BostonState *s = BOSTON(opaque);\n\n    MachineState *machine = s->mach;\n\n    const char *cmdline;\n\n    int err;\n\n    void *fdt;\n\n    size_t fdt_sz, ram_low_sz, ram_high_sz;\n\n\n\n    fdt_sz = fdt_totalsize(fdt_orig) * 2;\n\n    fdt = g_malloc0(fdt_sz);\n\n\n\n    err = fdt_open_into(fdt_orig, fdt, fdt_sz);\n\n    if (err) {\n\n        fprintf(stderr, \"unable to open FDT\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    cmdline = (machine->kernel_cmdline && machine->kernel_cmdline[0])\n\n            ? machine->kernel_cmdline : \" \";\n\n    err = qemu_fdt_setprop_string(fdt, \"/chosen\", \"bootargs\", cmdline);\n\n    if (err < 0) {\n\n        fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    ram_low_sz = MIN(256 * M_BYTE, machine->ram_size);\n\n    ram_high_sz = machine->ram_size - ram_low_sz;\n\n    qemu_fdt_setprop_sized_cells(fdt, \"/memory@0\", \"reg\",\n\n                                 1, 0x00000000, 1, ram_low_sz,\n\n                                 1, 0x90000000, 1, ram_high_sz);\n\n\n\n    fdt = g_realloc(fdt, fdt_totalsize(fdt));\n\n    qemu_fdt_dumpdtb(fdt, fdt_sz);\n\n\n\n    s->fdt_base = *load_addr;\n\n\n\n    return fdt;\n\n}\n", "idx": 6108, "_split": "test", "_hash": "faae098cbe0c27b6faf908462461e9ab"}
{"project": "qemu", "commit_id": "47e04430ed3e6ab835f023a5c84381ca2ce9f4d8", "target": 0, "func": "static void decode_bo_addrmode_post_pre_base(CPUTriCoreState *env,\n\n                                             DisasContext *ctx)\n\n{\n\n    uint32_t op2;\n\n    uint32_t off10;\n\n    int32_t r1, r2;\n\n    TCGv temp;\n\n\n\n    r1 = MASK_OP_BO_S1D(ctx->opcode);\n\n    r2  = MASK_OP_BO_S2(ctx->opcode);\n\n    off10 = MASK_OP_BO_OFF10_SEXT(ctx->opcode);\n\n    op2 = MASK_OP_BO_OP2(ctx->opcode);\n\n\n\n    switch (op2) {\n\n    case OPC2_32_BO_CACHEA_WI_SHORTOFF:\n\n    case OPC2_32_BO_CACHEA_W_SHORTOFF:\n\n    case OPC2_32_BO_CACHEA_I_SHORTOFF:\n\n        /* instruction to access the cache */\n\n        break;\n\n    case OPC2_32_BO_CACHEA_WI_POSTINC:\n\n    case OPC2_32_BO_CACHEA_W_POSTINC:\n\n    case OPC2_32_BO_CACHEA_I_POSTINC:\n\n        /* instruction to access the cache, but we still need to handle\n\n           the addressing mode */\n\n        tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_CACHEA_WI_PREINC:\n\n    case OPC2_32_BO_CACHEA_W_PREINC:\n\n    case OPC2_32_BO_CACHEA_I_PREINC:\n\n        /* instruction to access the cache, but we still need to handle\n\n           the addressing mode */\n\n        tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_CACHEI_WI_SHORTOFF:\n\n    case OPC2_32_BO_CACHEI_W_SHORTOFF:\n\n        /* TODO: Raise illegal opcode trap,\n\n                 if tricore_feature(TRICORE_FEATURE_13) */\n\n        break;\n\n    case OPC2_32_BO_CACHEI_W_POSTINC:\n\n    case OPC2_32_BO_CACHEI_WI_POSTINC:\n\n        if (!tricore_feature(env, TRICORE_FEATURE_13)) {\n\n            tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);\n\n        } /* TODO: else raise illegal opcode trap */\n\n        break;\n\n    case OPC2_32_BO_CACHEI_W_PREINC:\n\n    case OPC2_32_BO_CACHEI_WI_PREINC:\n\n        if (!tricore_feature(env, TRICORE_FEATURE_13)) {\n\n            tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);\n\n        } /* TODO: else raise illegal opcode trap */\n\n        break;\n\n    case OPC2_32_BO_ST_A_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_a[r1], cpu_gpr_a[r2], off10, MO_LESL);\n\n        break;\n\n    case OPC2_32_BO_ST_A_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LESL);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_A_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_a[r1], cpu_gpr_a[r2], off10, MO_LESL);\n\n        break;\n\n    case OPC2_32_BO_ST_B_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_UB);\n\n        break;\n\n    case OPC2_32_BO_ST_B_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_UB);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_B_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_UB);\n\n        break;\n\n    case OPC2_32_BO_ST_D_SHORTOFF:\n\n        gen_offset_st_2regs(cpu_gpr_d[r1+1], cpu_gpr_d[r1], cpu_gpr_a[r2],\n\n                            off10, ctx);\n\n        break;\n\n    case OPC2_32_BO_ST_D_POSTINC:\n\n        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], cpu_gpr_a[r2], ctx);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_D_PREINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_addi_tl(temp, cpu_gpr_a[r2], off10);\n\n        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);\n\n        tcg_gen_mov_tl(cpu_gpr_a[r2], temp);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_DA_SHORTOFF:\n\n        gen_offset_st_2regs(cpu_gpr_a[r1+1], cpu_gpr_a[r1], cpu_gpr_a[r2],\n\n                            off10, ctx);\n\n        break;\n\n    case OPC2_32_BO_ST_DA_POSTINC:\n\n        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], cpu_gpr_a[r2], ctx);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_DA_PREINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_addi_tl(temp, cpu_gpr_a[r2], off10);\n\n        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);\n\n        tcg_gen_mov_tl(cpu_gpr_a[r2], temp);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_H_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUW);\n\n        break;\n\n    case OPC2_32_BO_ST_H_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LEUW);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_H_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUW);\n\n        break;\n\n    case OPC2_32_BO_ST_Q_SHORTOFF:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16);\n\n        gen_offset_st(ctx, temp, cpu_gpr_a[r2], off10, MO_LEUW);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_Q_POSTINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16);\n\n        tcg_gen_qemu_st_tl(temp, cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LEUW);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_Q_PREINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16);\n\n        gen_st_preincr(ctx, temp, cpu_gpr_a[r2], off10, MO_LEUW);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_W_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUL);\n\n        break;\n\n    case OPC2_32_BO_ST_W_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LEUL);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_W_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUL);\n\n        break;\n\n    }\n\n}\n", "idx": 6186, "_split": "test", "_hash": "4024f9d746c6b529478a077e8abbfc97"}
{"project": "qemu", "commit_id": "bee62662a312b99b4418b558a99b3963a4cbff07", "target": 0, "func": "static int kvm_mips_get_fpu_registers(CPUState *cs)\n\n{\n\n    MIPSCPU *cpu = MIPS_CPU(cs);\n\n    CPUMIPSState *env = &cpu->env;\n\n    int err, ret = 0;\n\n    unsigned int i;\n\n\n\n    /* Only get FPU state if we're emulating a CPU with an FPU */\n\n    if (env->CP0_Config1 & (1 << CP0C1_FP)) {\n\n        /* FPU Control Registers */\n\n        err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_IR,\n\n                                    &env->active_fpu.fcr0);\n\n        if (err < 0) {\n\n            DPRINTF(\"%s: Failed to get FCR_IR (%d)\\n\", __func__, err);\n\n            ret = err;\n\n        }\n\n        err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_CSR,\n\n                                    &env->active_fpu.fcr31);\n\n        if (err < 0) {\n\n            DPRINTF(\"%s: Failed to get FCR_CSR (%d)\\n\", __func__, err);\n\n            ret = err;\n\n        } else {\n\n            restore_fp_status(env);\n\n        }\n\n\n\n        /* Floating point registers */\n\n        for (i = 0; i < 32; ++i) {\n\n            if (env->CP0_Status & (1 << CP0St_FR)) {\n\n                err = kvm_mips_get_one_ureg64(cs, KVM_REG_MIPS_FPR_64(i),\n\n                                              &env->active_fpu.fpr[i].d);\n\n            } else {\n\n                err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FPR_32(i),\n\n                                      &env->active_fpu.fpr[i].w[FP_ENDIAN_IDX]);\n\n            }\n\n            if (err < 0) {\n\n                DPRINTF(\"%s: Failed to get FPR%u (%d)\\n\", __func__, i, err);\n\n                ret = err;\n\n            }\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 6189, "_split": "test", "_hash": "5116f68a34ec0e31e51ca9bf334cde2c"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_loongson_integer(DisasContext *ctx, uint32_t opc,\n\n                                 int rd, int rs, int rt)\n\n{\n\n    const char *opn = \"loongson\";\n\n    TCGv t0, t1;\n\n\n\n    if (rd == 0) {\n\n        /* Treat as NOP. */\n\n        MIPS_DEBUG(\"NOP\");\n\n        return;\n\n    }\n\n\n\n    switch (opc) {\n\n    case OPC_MULT_G_2E:\n\n    case OPC_MULT_G_2F:\n\n    case OPC_MULTU_G_2E:\n\n    case OPC_MULTU_G_2F:\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_DMULT_G_2E:\n\n    case OPC_DMULT_G_2F:\n\n    case OPC_DMULTU_G_2E:\n\n    case OPC_DMULTU_G_2F:\n\n#endif\n\n        t0 = tcg_temp_new();\n\n        t1 = tcg_temp_new();\n\n        break;\n\n    default:\n\n        t0 = tcg_temp_local_new();\n\n        t1 = tcg_temp_local_new();\n\n        break;\n\n    }\n\n\n\n    gen_load_gpr(t0, rs);\n\n    gen_load_gpr(t1, rt);\n\n\n\n    switch (opc) {\n\n    case OPC_MULT_G_2E:\n\n    case OPC_MULT_G_2F:\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n        opn = \"mult.g\";\n\n        break;\n\n    case OPC_MULTU_G_2E:\n\n    case OPC_MULTU_G_2F:\n\n        tcg_gen_ext32u_tl(t0, t0);\n\n        tcg_gen_ext32u_tl(t1, t1);\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n        opn = \"multu.g\";\n\n        break;\n\n    case OPC_DIV_G_2E:\n\n    case OPC_DIV_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_ext32s_tl(t0, t0);\n\n            tcg_gen_ext32s_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2);\n\n            tcg_gen_mov_tl(cpu_gpr[rd], t0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_div_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"div.g\";\n\n        break;\n\n    case OPC_DIVU_G_2E:\n\n    case OPC_DIVU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_divu_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"divu.g\";\n\n        break;\n\n    case OPC_MOD_G_2E:\n\n    case OPC_MOD_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_rem_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"mod.g\";\n\n        break;\n\n    case OPC_MODU_G_2E:\n\n    case OPC_MODU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_remu_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"modu.g\";\n\n        break;\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_DMULT_G_2E:\n\n    case OPC_DMULT_G_2F:\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        opn = \"dmult.g\";\n\n        break;\n\n    case OPC_DMULTU_G_2E:\n\n    case OPC_DMULTU_G_2F:\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        opn = \"dmultu.g\";\n\n        break;\n\n    case OPC_DDIV_G_2E:\n\n    case OPC_DDIV_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2);\n\n            tcg_gen_mov_tl(cpu_gpr[rd], t0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_div_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"ddiv.g\";\n\n        break;\n\n    case OPC_DDIVU_G_2E:\n\n    case OPC_DDIVU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_divu_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"ddivu.g\";\n\n        break;\n\n    case OPC_DMOD_G_2E:\n\n    case OPC_DMOD_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_rem_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"dmod.g\";\n\n        break;\n\n    case OPC_DMODU_G_2E:\n\n    case OPC_DMODU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_remu_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"dmodu.g\";\n\n        break;\n\n#endif\n\n    }\n\n\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %s\", opn, regnames[rd], regnames[rs]);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n", "idx": 6193, "_split": "test", "_hash": "283b6556e44843b66edd86851f601309"}
{"project": "qemu", "commit_id": "7d489dcdf5fd71b5052ffd401b869a627e1c751f", "target": 0, "func": "static void vfio_pci_load_rom(VFIOPCIDevice *vdev)\n\n{\n\n    struct vfio_region_info reg_info = {\n\n        .argsz = sizeof(reg_info),\n\n        .index = VFIO_PCI_ROM_REGION_INDEX\n\n    };\n\n    uint64_t size;\n\n    off_t off = 0;\n\n    size_t bytes;\n\n\n\n    if (ioctl(vdev->vbasedev.fd, VFIO_DEVICE_GET_REGION_INFO, &reg_info)) {\n\n        error_report(\"vfio: Error getting ROM info: %m\");\n\n        return;\n\n    }\n\n\n\n    trace_vfio_pci_load_rom(vdev->vbasedev.name, (unsigned long)reg_info.size,\n\n                            (unsigned long)reg_info.offset,\n\n                            (unsigned long)reg_info.flags);\n\n\n\n    vdev->rom_size = size = reg_info.size;\n\n    vdev->rom_offset = reg_info.offset;\n\n\n\n    if (!vdev->rom_size) {\n\n        vdev->rom_read_failed = true;\n\n        error_report(\"vfio-pci: Cannot read device rom at \"\n\n                    \"%s\", vdev->vbasedev.name);\n\n        error_printf(\"Device option ROM contents are probably invalid \"\n\n                    \"(check dmesg).\\nSkip option ROM probe with rombar=0, \"\n\n                    \"or load from file with romfile=\\n\");\n\n        return;\n\n    }\n\n\n\n    vdev->rom = g_malloc(size);\n\n    memset(vdev->rom, 0xff, size);\n\n\n\n    while (size) {\n\n        bytes = pread(vdev->vbasedev.fd, vdev->rom + off,\n\n                      size, vdev->rom_offset + off);\n\n        if (bytes == 0) {\n\n            break;\n\n        } else if (bytes > 0) {\n\n            off += bytes;\n\n            size -= bytes;\n\n        } else {\n\n            if (errno == EINTR || errno == EAGAIN) {\n\n                continue;\n\n            }\n\n            error_report(\"vfio: Error reading device ROM: %m\");\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 6196, "_split": "test", "_hash": "43243287149a687754decd6af1b95ddb"}
{"project": "qemu", "commit_id": "684e508c23d28af8d6ed2c62738a0f60447c8274", "target": 1, "func": "static bool try_poll_mode(AioContext *ctx, bool blocking)\n\n{\n\n    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {\n\n        /* See qemu_soonest_timeout() uint64_t hack */\n\n        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),\n\n                             (uint64_t)ctx->poll_max_ns);\n\n\n\n        if (max_ns) {\n\n            if (run_poll_handlers(ctx, max_ns)) {\n\n                return true;\n\n            }\n\n        }\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 6206, "_split": "test", "_hash": "f2f7cb47cc44c807eb6643f4d7703d14"}
{"project": "qemu", "commit_id": "f1d3b99154138741161fc52f5a8c373bf71613c6", "target": 1, "func": "static void pci_basic(gconstpointer data)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QPCIBus *bus;\n\n    QVirtQueuePCI *tx, *rx;\n\n    QGuestAllocator *alloc;\n\n    void (*func) (const QVirtioBus *bus,\n\n                  QVirtioDevice *dev,\n\n                  QGuestAllocator *alloc,\n\n                  QVirtQueue *rvq,\n\n                  QVirtQueue *tvq,\n\n                  int socket) = data;\n\n    int sv[2], ret;\n\n\n\n    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv);\n\n    g_assert_cmpint(ret, !=, -1);\n\n\n\n    bus = pci_test_start(sv[1]);\n\n    dev = virtio_net_pci_init(bus, PCI_SLOT);\n\n\n\n    alloc = pc_alloc_init();\n\n    rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,\n\n                                           alloc, 0);\n\n    tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,\n\n                                           alloc, 1);\n\n\n\n    driver_init(&qvirtio_pci, &dev->vdev);\n\n    func(&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]);\n\n\n\n    /* End test */\n\n    close(sv[0]);\n\n    guest_free(alloc, tx->vq.desc);\n\n    pc_alloc_uninit(alloc);\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev);\n\n    qpci_free_pc(bus);\n\n    test_end();\n\n}\n", "idx": 6217, "_split": "test", "_hash": "846b4a46019237ea7d108fc35eb2d76f"}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_full_negative(void)\n\n{\n\n    const char *str = \" \\t -321\";\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, NULL, 0, &res);\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, -321ul);\n\n}\n", "idx": 6241, "_split": "test", "_hash": "b0d74a71894d40a9ce348de23a7e541b"}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static int vnc_validate_certificate(struct VncState *vs)\n\n{\n\n    int ret;\n\n    unsigned int status;\n\n    const gnutls_datum_t *certs;\n\n    unsigned int nCerts, i;\n\n    time_t now;\n\n\n\n    VNC_DEBUG(\"Validating client certificate\\n\");\n\n    if ((ret = gnutls_certificate_verify_peers2 (vs->tls_session, &status)) < 0) {\n\n\tVNC_DEBUG(\"Verify failed %s\\n\", gnutls_strerror(ret));\n\n\treturn -1;\n\n    }\n\n\n\n    if ((now = time(NULL)) == ((time_t)-1)) {\n\n\treturn -1;\n\n    }\n\n\n\n    if (status != 0) {\n\n\tif (status & GNUTLS_CERT_INVALID)\n\n\t    VNC_DEBUG(\"The certificate is not trusted.\\n\");\n\n\n\n\tif (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n\n\t    VNC_DEBUG(\"The certificate hasn't got a known issuer.\\n\");\n\n\n\n\tif (status & GNUTLS_CERT_REVOKED)\n\n\t    VNC_DEBUG(\"The certificate has been revoked.\\n\");\n\n\n\n\tif (status & GNUTLS_CERT_INSECURE_ALGORITHM)\n\n\t    VNC_DEBUG(\"The certificate uses an insecure algorithm\\n\");\n\n\n\n\treturn -1;\n\n    } else {\n\n\tVNC_DEBUG(\"Certificate is valid!\\n\");\n\n    }\n\n\n\n    /* Only support x509 for now */\n\n    if (gnutls_certificate_type_get(vs->tls_session) != GNUTLS_CRT_X509)\n\n\treturn -1;\n\n\n\n    if (!(certs = gnutls_certificate_get_peers(vs->tls_session, &nCerts)))\n\n\treturn -1;\n\n\n\n    for (i = 0 ; i < nCerts ; i++) {\n\n\tgnutls_x509_crt_t cert;\n\n\tVNC_DEBUG (\"Checking certificate chain %d\\n\", i);\n\n\tif (gnutls_x509_crt_init (&cert) < 0)\n\n\t    return -1;\n\n\n\n\tif (gnutls_x509_crt_import(cert, &certs[i], GNUTLS_X509_FMT_DER) < 0) {\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_expiration_time (cert) < now) {\n\n\t    VNC_DEBUG(\"The certificate has expired\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_activation_time (cert) > now) {\n\n\t    VNC_DEBUG(\"The certificate is not yet activated\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_activation_time (cert) > now) {\n\n\t    VNC_DEBUG(\"The certificate is not yet activated\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tgnutls_x509_crt_deinit (cert);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6243, "_split": "test", "_hash": "ed91436d569c3612f7a9005c726099a3"}
{"project": "qemu", "commit_id": "85df0de4cfe54fd64df7e37448cd152d0c9199a4", "target": 0, "func": "int fw_cfg_add_callback(void *opaque, uint16_t key, FWCfgCallback callback,\n\n                        void *callback_opaque, uint8_t *data, size_t len)\n\n{\n\n    FWCfgState *s = opaque;\n\n    int arch = !!(key & FW_CFG_ARCH_LOCAL);\n\n\n\n    key &= FW_CFG_ENTRY_MASK;\n\n\n\n    if (key >= FW_CFG_MAX_ENTRY || !(key & FW_CFG_WRITE_CHANNEL)\n\n        || len > 65535)\n\n        return 0;\n\n\n\n    s->entries[arch][key].data = data;\n\n    s->entries[arch][key].len = len;\n\n    s->entries[arch][key].callback_opaque = callback_opaque;\n\n    s->entries[arch][key].callback = callback;\n\n\n\n    return 1;\n\n}\n", "idx": 6251, "_split": "test", "_hash": "bfea65e5709fcf542d0cbf3d03f9edc1"}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline void gen_st16(TCGv val, TCGv addr, int index)\n\n{\n\n    tcg_gen_qemu_st16(val, addr, index);\n\n    dead_tmp(val);\n\n}\n", "idx": 6335, "_split": "test", "_hash": "30abcc6d7ab834738a9b963d48ab2d1e"}
{"project": "qemu", "commit_id": "2f295167e0c429cec233aef7dc8e9fd6f90376df", "target": 1, "func": "static void q35_host_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);\n\n\n\n    hc->root_bus_path = q35_host_root_bus_path;\n\n    dc->realize = q35_host_realize;\n\n    dc->props = mch_props;\n\n    /* Reason: needs to be wired up by pc_q35_init */\n\n    dc->user_creatable = false;\n\n    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);\n\n    dc->fw_name = \"pci\";\n\n}\n", "idx": 6346, "_split": "test", "_hash": "5902b334828063cc7a6ea77120687a86"}
{"project": "qemu", "commit_id": "340849a9ff2a246bbc9a2da3f079c9fdbd2d5852", "target": 1, "func": "static struct addrinfo *inet_parse_connect_saddr(InetSocketAddress *saddr,\n\n                                                 Error **errp)\n\n{\n\n    struct addrinfo ai, *res;\n\n    int rc;\n\n    Error *err = NULL;\n\n\n\n    memset(&ai, 0, sizeof(ai));\n\n\n\n    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;\n\n    ai.ai_family = inet_ai_family_from_address(saddr, &err);\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return NULL;\n\n    }\n\n\n\n    if (saddr->host == NULL || saddr->port == NULL) {\n\n        error_setg(errp, \"host and/or port not specified\");\n\n        return NULL;\n\n    }\n\n\n\n    /* lookup */\n\n    rc = getaddrinfo(saddr->host, saddr->port, &ai, &res);\n\n    if (rc != 0) {\n\n        error_setg(errp, \"address resolution failed for %s:%s: %s\",\n\n                   saddr->host, saddr->port, gai_strerror(rc));\n\n        return NULL;\n\n    }\n\n    return res;\n\n}\n", "idx": 6374, "_split": "test", "_hash": "c844cdc97fc8b26a6b99f5f0bc94cb9d"}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void bamboo_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    unsigned int pci_irq_nrs[4] = { 28, 27, 26, 25 };\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *isa = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_memories\n\n        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));\n\n    hwaddr ram_bases[PPC440EP_SDRAM_NR_BANKS];\n\n    hwaddr ram_sizes[PPC440EP_SDRAM_NR_BANKS];\n\n    qemu_irq *pic;\n\n    qemu_irq *irqs;\n\n    PCIBus *pcibus;\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    uint64_t elf_entry;\n\n    uint64_t elf_lowaddr;\n\n    hwaddr loadaddr = 0;\n\n    target_long initrd_size = 0;\n\n    DeviceState *dev;\n\n    int success;\n\n    int i;\n\n\n\n    /* Setup CPU. */\n\n    if (machine->cpu_model == NULL) {\n\n        machine->cpu_model = \"440EP\";\n\n    }\n\n    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, machine->cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    if (env->mmu_model != POWERPC_MMU_BOOKE) {\n\n        fprintf(stderr, \"MMU model %i not supported by this machine.\\n\",\n\n            env->mmu_model);\n\n        exit(1);\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, cpu);\n\n    ppc_booke_timers_init(cpu, 400000000, 0);\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n\n\n    /* SDRAM controller */\n\n    memset(ram_bases, 0, sizeof(ram_bases));\n\n    memset(ram_sizes, 0, sizeof(ram_sizes));\n\n    ram_size = ppc4xx_sdram_adjust(ram_size, PPC440EP_SDRAM_NR_BANKS,\n\n                                   ram_memories,\n\n                                   ram_bases, ram_sizes,\n\n                                   ppc440ep_sdram_bank_sizes);\n\n    /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */\n\n    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,\n\n                      ram_bases, ram_sizes, 1);\n\n\n\n    /* PCI */\n\n    dev = sysbus_create_varargs(TYPE_PPC4xx_PCI_HOST_BRIDGE,\n\n                                PPC440EP_PCI_CONFIG,\n\n                                pic[pci_irq_nrs[0]], pic[pci_irq_nrs[1]],\n\n                                pic[pci_irq_nrs[2]], pic[pci_irq_nrs[3]],\n\n                                NULL);\n\n    pcibus = (PCIBus *)qdev_get_child_bus(dev, \"pci.0\");\n\n    if (!pcibus) {\n\n        fprintf(stderr, \"couldn't create PCI controller!\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_init_alias(isa, NULL, \"isa_mmio\",\n\n                             get_system_io(), 0, PPC440EP_PCI_IOLEN);\n\n    memory_region_add_subregion(get_system_memory(), PPC440EP_PCI_IO, isa);\n\n\n\n    if (serial_hds[0] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600300, 0, pic[0],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[0],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n    if (serial_hds[1] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600400, 0, pic[1],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[1],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    if (pcibus) {\n\n        /* Register network interfaces. */\n\n        for (i = 0; i < nb_nics; i++) {\n\n            /* There are no PCI NICs on the Bamboo board, but there are\n\n             * PCI slots, so we can pick whatever default model we want. */\n\n            pci_nic_init_nofail(&nd_table[i], pcibus, \"e1000\", NULL);\n\n        }\n\n    }\n\n\n\n    /* Load kernel. */\n\n    if (kernel_filename) {\n\n        success = load_uimage(kernel_filename, &entry, &loadaddr, NULL,\n\n                              NULL, NULL);\n\n        if (success < 0) {\n\n            success = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                               &elf_lowaddr, NULL, 1, PPC_ELF_MACHINE,\n\n                               0, 0);\n\n            entry = elf_entry;\n\n            loadaddr = elf_lowaddr;\n\n        }\n\n        /* XXX try again as binary */\n\n        if (success < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Load initrd. */\n\n    if (initrd_filename) {\n\n        initrd_size = load_image_targphys(initrd_filename, RAMDISK_ADDR,\n\n                                          ram_size - RAMDISK_ADDR);\n\n\n\n        if (initrd_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load ram disk '%s' at %x\\n\",\n\n                    initrd_filename, RAMDISK_ADDR);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* If we're loading a kernel directly, we must load the device tree too. */\n\n    if (kernel_filename) {\n\n        if (bamboo_load_device_tree(FDT_ADDR, ram_size, RAMDISK_ADDR,\n\n                                    initrd_size, kernel_cmdline) < 0) {\n\n            fprintf(stderr, \"couldn't load device tree\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n}\n", "idx": 6385, "_split": "test", "_hash": "e03d0a78199d90019fb3badc003b48be"}
{"project": "qemu", "commit_id": "6476615d385eb249105b25873ef30ba4b9c808dc", "target": 0, "func": "void HELPER(stpq)(CPUS390XState *env, uint64_t addr,\n\n                  uint64_t low, uint64_t high)\n\n{\n\n    uintptr_t ra = GETPC();\n\n\n\n    if (parallel_cpus) {\n\n#ifndef CONFIG_ATOMIC128\n\n        cpu_loop_exit_atomic(ENV_GET_CPU(env), ra);\n\n#else\n\n        int mem_idx = cpu_mmu_index(env, false);\n\n        TCGMemOpIdx oi = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx);\n\n\n\n        Int128 v = int128_make128(low, high);\n\n        helper_atomic_sto_be_mmu(env, addr, v, oi, ra);\n\n#endif\n\n    } else {\n\n        check_alignment(env, addr, 16, ra);\n\n\n\n        cpu_stq_data_ra(env, addr + 0, high, ra);\n\n        cpu_stq_data_ra(env, addr + 8, low, ra);\n\n    }\n\n}\n", "idx": 6408, "_split": "test", "_hash": "c92b20631fcddd30d92a0d085f0bd522"}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void simple_number(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        int64_t decoded;\n\n        int skip;\n\n    } test_cases[] = {\n\n        { \"0\", 0 },\n\n        { \"1234\", 1234 },\n\n        { \"1\", 1 },\n\n        { \"-32\", -32 },\n\n        { \"-0\", 0, .skip = 1 },\n\n        { },\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QInt *qint;\n\n\n\n        qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL));\n\n        g_assert(qint);\n\n        g_assert(qint_get_int(qint) == test_cases[i].decoded);\n\n        if (test_cases[i].skip == 0) {\n\n            QString *str;\n\n\n\n            str = qobject_to_json(QOBJECT(qint));\n\n            g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);\n\n            QDECREF(str);\n\n        }\n\n\n\n        QDECREF(qint);\n\n    }\n\n}\n", "idx": 6486, "_split": "test", "_hash": "300f66e46df2cbe19b60fb5dde333f24"}
{"project": "qemu", "commit_id": "e13e973eedba0a52b4b8b079c4b85cdc68b7b4f0", "target": 1, "func": "static int ccid_initfn(USBDevice *dev)\n\n{\n\n    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);\n\n\n\n    s->bus = ccid_bus_new(&dev->qdev);\n\n    s->card = NULL;\n\n    s->cardinfo = NULL;\n\n    s->migration_state = MIGRATION_NONE;\n\n    s->migration_target_ip = 0;\n\n    s->migration_target_port = 0;\n\n    s->dev.speed = USB_SPEED_FULL;\n\n    s->notify_slot_change = false;\n\n    s->powered = true;\n\n    s->pending_answers_num = 0;\n\n    s->last_answer_error = 0;\n\n    s->bulk_in_pending_start = 0;\n\n    s->bulk_in_pending_end = 0;\n\n    s->current_bulk_in = NULL;\n\n    ccid_reset_error_status(s);\n\n    s->bulk_out_pos = 0;\n\n    ccid_reset_parameters(s);\n\n    ccid_reset(s);\n\n    return 0;\n\n}\n", "idx": 6500, "_split": "test", "_hash": "f51099b02a15c5a07cfdc57e3ead30ab"}
{"project": "qemu", "commit_id": "5a1972c8472fafd519a68b689fdcaf33ec857945", "target": 1, "func": "static void ppc4xx_pob_reset (void *opaque)\n\n{\n\n    ppc4xx_pob_t *pob;\n\n\n\n    pob = opaque;\n\n    /* No error */\n\n    pob->bear = 0x00000000;\n\n    pob->besr[0] = 0x0000000;\n\n    pob->besr[1] = 0x0000000;\n\n}\n", "idx": 6507, "_split": "test", "_hash": "6bfe7f0070ea48e1b059681c3238f5d3"}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset,\n\n                                  sPAPRMachineState *spapr)\n\n{\n\n    PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n    CPUPPCState *env = &cpu->env;\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs);\n\n    int index = ppc_get_vcpu_dt_id(cpu);\n\n    uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),\n\n                       0xffffffff, 0xffffffff};\n\n    uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq()\n\n        : SPAPR_TIMEBASE_FREQ;\n\n    uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;\n\n    uint32_t page_sizes_prop[64];\n\n    size_t page_sizes_prop_size;\n\n    uint32_t vcpus_per_socket = smp_threads * smp_cores;\n\n    uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)};\n\n    int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu));\n\n    sPAPRDRConnector *drc;\n\n    int drc_index;\n\n    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];\n\n    int i;\n\n\n\n    drc = spapr_drc_by_id(TYPE_SPAPR_DRC_CPU, index);\n\n    if (drc) {\n\n        drc_index = spapr_drc_index(drc);\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index)));\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"reg\", index)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"device_type\", \"cpu\")));\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"cpu-version\", env->spr[SPR_PVR])));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-block-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-line-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-block-size\",\n\n                           env->icache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-line-size\",\n\n                           env->icache_line_size)));\n\n\n\n    if (pcc->l1_dcache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-size\",\n\n                               pcc->l1_dcache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 dcache size for cpu\");\n\n    }\n\n    if (pcc->l1_icache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-size\",\n\n                               pcc->l1_icache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 icache size for cpu\");\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"timebase-frequency\", tbfreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"clock-frequency\", cpufreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"status\", \"okay\")));\n\n    _FDT((fdt_setprop(fdt, offset, \"64-bit\", NULL, 0)));\n\n\n\n    if (env->spr_cb[SPR_PURR].oea_read) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,purr\", NULL, 0)));\n\n    }\n\n\n\n    if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-segment-sizes\",\n\n                          segs, sizeof(segs))));\n\n    }\n\n\n\n    /* Advertise VMX/VSX (vector extensions) if available\n\n     *   0 / no property == no vector extensions\n\n     *   1               == VMX / Altivec available\n\n     *   2               == VSX available */\n\n    if (env->insns_flags & PPC_ALTIVEC) {\n\n        uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;\n\n\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,vmx\", vmx)));\n\n    }\n\n\n\n    /* Advertise DFP (Decimal Floating Point) if available\n\n     *   0 / no property == no DFP\n\n     *   1               == DFP available */\n\n    if (env->insns_flags2 & PPC2_DFP) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,dfp\", 1)));\n\n    }\n\n\n\n    page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop,\n\n                                                  sizeof(page_sizes_prop));\n\n    if (page_sizes_prop_size) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,segment-page-sizes\",\n\n                          page_sizes_prop, page_sizes_prop_size)));\n\n    }\n\n\n\n    spapr_populate_pa_features(env, fdt, offset, false);\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,chip-id\",\n\n                           cs->cpu_index / vcpus_per_socket)));\n\n\n\n    _FDT((fdt_setprop(fdt, offset, \"ibm,pft-size\",\n\n                      pft_size_prop, sizeof(pft_size_prop))));\n\n\n\n    if (nb_numa_nodes > 1) {\n\n        _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cpu));\n\n    }\n\n\n\n    _FDT(spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt));\n\n\n\n    if (pcc->radix_page_info) {\n\n        for (i = 0; i < pcc->radix_page_info->count; i++) {\n\n            radix_AP_encodings[i] =\n\n                cpu_to_be32(pcc->radix_page_info->entries[i]);\n\n        }\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-radix-AP-encodings\",\n\n                          radix_AP_encodings,\n\n                          pcc->radix_page_info->count *\n\n                          sizeof(radix_AP_encodings[0]))));\n\n    }\n\n}\n", "idx": 6524, "_split": "test", "_hash": "03422bbff76e1209b021bc0f52bda4a7"}
{"project": "qemu", "commit_id": "f94d18d6c6df388fde196d3ab252f57e33843a8b", "target": 0, "func": "static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid)\n\n{\n\n    XHCIState *xhci = epctx->xhci;\n\n    XHCIStreamContext *stctx;\n\n    XHCITransfer *xfer;\n\n    XHCIRing *ring;\n\n    USBEndpoint *ep = NULL;\n\n    uint64_t mfindex;\n\n    int length;\n\n    int i;\n\n\n\n    trace_usb_xhci_ep_kick(epctx->slotid, epctx->epid, streamid);\n\n\n\n    /* If the device has been detached, but the guest has not noticed this\n\n       yet the 2 above checks will succeed, but we must NOT continue */\n\n    if (!xhci->slots[epctx->slotid - 1].uport ||\n\n        !xhci->slots[epctx->slotid - 1].uport->dev ||\n\n        !xhci->slots[epctx->slotid - 1].uport->dev->attached) {\n\n        return;\n\n    }\n\n\n\n    if (epctx->retry) {\n\n        XHCITransfer *xfer = epctx->retry;\n\n\n\n        trace_usb_xhci_xfer_retry(xfer);\n\n        assert(xfer->running_retry);\n\n        if (xfer->timed_xfer) {\n\n            /* time to kick the transfer? */\n\n            mfindex = xhci_mfindex_get(xhci);\n\n            xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n\n            if (xfer->running_retry) {\n\n                return;\n\n            }\n\n            xfer->timed_xfer = 0;\n\n            xfer->running_retry = 1;\n\n        }\n\n        if (xfer->iso_xfer) {\n\n            /* retry iso transfer */\n\n            if (xhci_setup_packet(xfer) < 0) {\n\n                return;\n\n            }\n\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n            assert(xfer->packet.status != USB_RET_NAK);\n\n            xhci_complete_packet(xfer);\n\n        } else {\n\n            /* retry nak'ed transfer */\n\n            if (xhci_setup_packet(xfer) < 0) {\n\n                return;\n\n            }\n\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n            if (xfer->packet.status == USB_RET_NAK) {\n\n                return;\n\n            }\n\n            xhci_complete_packet(xfer);\n\n        }\n\n        assert(!xfer->running_retry);\n\n        xhci_ep_free_xfer(epctx->retry);\n\n        epctx->retry = NULL;\n\n    }\n\n\n\n    if (epctx->state == EP_HALTED) {\n\n        DPRINTF(\"xhci: ep halted, not running schedule\\n\");\n\n        return;\n\n    }\n\n\n\n\n\n    if (epctx->nr_pstreams) {\n\n        uint32_t err;\n\n        stctx = xhci_find_stream(epctx, streamid, &err);\n\n        if (stctx == NULL) {\n\n            return;\n\n        }\n\n        ring = &stctx->ring;\n\n        xhci_set_ep_state(xhci, epctx, stctx, EP_RUNNING);\n\n    } else {\n\n        ring = &epctx->ring;\n\n        streamid = 0;\n\n        xhci_set_ep_state(xhci, epctx, NULL, EP_RUNNING);\n\n    }\n\n    assert(ring->dequeue != 0);\n\n\n\n    while (1) {\n\n        length = xhci_ring_chain_length(xhci, ring);\n\n        if (length <= 0) {\n\n            break;\n\n        }\n\n        xfer = xhci_ep_alloc_xfer(epctx, length);\n\n        if (xfer == NULL) {\n\n            break;\n\n        }\n\n\n\n        for (i = 0; i < length; i++) {\n\n            TRBType type;\n\n            type = xhci_ring_fetch(xhci, ring, &xfer->trbs[i], NULL);\n\n            assert(type);\n\n        }\n\n        xfer->streamid = streamid;\n\n\n\n        if (epctx->epid == 1) {\n\n            xhci_fire_ctl_transfer(xhci, xfer);\n\n        } else {\n\n            xhci_fire_transfer(xhci, xfer, epctx);\n\n        }\n\n        if (xfer->complete) {\n\n            xhci_ep_free_xfer(xfer);\n\n            xfer = NULL;\n\n        }\n\n\n\n        if (epctx->state == EP_HALTED) {\n\n            break;\n\n        }\n\n        if (xfer != NULL && xfer->running_retry) {\n\n            DPRINTF(\"xhci: xfer nacked, stopping schedule\\n\");\n\n            epctx->retry = xfer;\n\n            break;\n\n        }\n\n    }\n\n\n\n    ep = xhci_epid_to_usbep(epctx);\n\n    if (ep) {\n\n        usb_device_flush_ep_queue(ep->dev, ep);\n\n    }\n\n}\n", "idx": 6532, "_split": "test", "_hash": "7457c1ca1459ac9a3dd048fa2a55170d"}
{"project": "qemu", "commit_id": "3f910692c287e1c611c00e763ebeb95ed0e017f8", "target": 1, "func": "static int vhdx_log_write(BlockDriverState *bs, BDRVVHDXState *s,\n\n                          void *data, uint32_t length, uint64_t offset)\n\n{\n\n    int ret = 0;\n\n    void *buffer = NULL;\n\n    void *merged_sector = NULL;\n\n    void *data_tmp, *sector_write;\n\n    unsigned int i;\n\n    int sector_offset;\n\n    uint32_t desc_sectors, sectors, total_length;\n\n    uint32_t sectors_written = 0;\n\n    uint32_t aligned_length;\n\n    uint32_t leading_length = 0;\n\n    uint32_t trailing_length = 0;\n\n    uint32_t partial_sectors = 0;\n\n    uint32_t bytes_written = 0;\n\n    uint64_t file_offset;\n\n    VHDXHeader *header;\n\n    VHDXLogEntryHeader new_hdr;\n\n    VHDXLogDescriptor *new_desc = NULL;\n\n    VHDXLogDataSector *data_sector = NULL;\n\n    MSGUID new_guid = { 0 };\n\n\n\n    header = s->headers[s->curr_header];\n\n\n\n    /* need to have offset read data, and be on 4096 byte boundary */\n\n\n\n    if (length > header->log_length) {\n\n        /* no log present.  we could create a log here instead of failing */\n\n        ret = -EINVAL;\n\n        goto exit;\n\n    }\n\n\n\n    if (guid_eq(header->log_guid, zero_guid)) {\n\n        vhdx_guid_generate(&new_guid);\n\n        vhdx_update_headers(bs, s, false, &new_guid);\n\n    } else {\n\n        /* currently, we require that the log be flushed after\n\n         * every write. */\n\n        ret = -ENOTSUP;\n\n        goto exit;\n\n    }\n\n\n\n    /* 0 is an invalid sequence number, but may also represent the first\n\n     * log write (or a wrapped seq) */\n\n    if (s->log.sequence == 0) {\n\n        s->log.sequence = 1;\n\n    }\n\n\n\n    sector_offset = offset % VHDX_LOG_SECTOR_SIZE;\n\n    file_offset = (offset / VHDX_LOG_SECTOR_SIZE) * VHDX_LOG_SECTOR_SIZE;\n\n\n\n    aligned_length = length;\n\n\n\n    /* add in the unaligned head and tail bytes */\n\n    if (sector_offset) {\n\n        leading_length = (VHDX_LOG_SECTOR_SIZE - sector_offset);\n\n        leading_length = leading_length > length ? length : leading_length;\n\n        aligned_length -= leading_length;\n\n        partial_sectors++;\n\n    }\n\n\n\n    sectors = aligned_length / VHDX_LOG_SECTOR_SIZE;\n\n    trailing_length = aligned_length - (sectors * VHDX_LOG_SECTOR_SIZE);\n\n    if (trailing_length) {\n\n        partial_sectors++;\n\n    }\n\n\n\n    sectors += partial_sectors;\n\n\n\n    /* sectors is now how many sectors the data itself takes, not\n\n     * including the header and descriptor metadata */\n\n\n\n    new_hdr = (VHDXLogEntryHeader) {\n\n                .signature           = VHDX_LOG_SIGNATURE,\n\n                .tail                = s->log.tail,\n\n                .sequence_number     = s->log.sequence,\n\n                .descriptor_count    = sectors,\n\n                .reserved            = 0,\n\n                .flushed_file_offset = bdrv_getlength(bs->file->bs),\n\n                .last_file_offset    = bdrv_getlength(bs->file->bs),\n\n              };\n\n\n\n    new_hdr.log_guid = header->log_guid;\n\n\n\n    desc_sectors = vhdx_compute_desc_sectors(new_hdr.descriptor_count);\n\n\n\n    total_length = (desc_sectors + sectors) * VHDX_LOG_SECTOR_SIZE;\n\n    new_hdr.entry_length = total_length;\n\n\n\n    vhdx_log_entry_hdr_le_export(&new_hdr);\n\n\n\n    buffer = qemu_blockalign(bs, total_length);\n\n    memcpy(buffer, &new_hdr, sizeof(new_hdr));\n\n\n\n    new_desc = buffer + sizeof(new_hdr);\n\n    data_sector = buffer + (desc_sectors * VHDX_LOG_SECTOR_SIZE);\n\n    data_tmp = data;\n\n\n\n    /* All log sectors are 4KB, so for any partial sectors we must\n\n     * merge the data with preexisting data from the final file\n\n     * destination */\n\n    merged_sector = qemu_blockalign(bs, VHDX_LOG_SECTOR_SIZE);\n\n\n\n    for (i = 0; i < sectors; i++) {\n\n        new_desc->signature       = VHDX_LOG_DESC_SIGNATURE;\n\n        new_desc->sequence_number = s->log.sequence;\n\n        new_desc->file_offset     = file_offset;\n\n\n\n        if (i == 0 && leading_length) {\n\n            /* partial sector at the front of the buffer */\n\n            ret = bdrv_pread(bs->file, file_offset, merged_sector,\n\n                             VHDX_LOG_SECTOR_SIZE);\n\n            if (ret < 0) {\n\n                goto exit;\n\n            }\n\n            memcpy(merged_sector + sector_offset, data_tmp, leading_length);\n\n            bytes_written = leading_length;\n\n            sector_write = merged_sector;\n\n        } else if (i == sectors - 1 && trailing_length) {\n\n            /* partial sector at the end of the buffer */\n\n            ret = bdrv_pread(bs->file,\n\n                            file_offset,\n\n                            merged_sector + trailing_length,\n\n                            VHDX_LOG_SECTOR_SIZE - trailing_length);\n\n            if (ret < 0) {\n\n                goto exit;\n\n            }\n\n            memcpy(merged_sector, data_tmp, trailing_length);\n\n            bytes_written = trailing_length;\n\n            sector_write = merged_sector;\n\n        } else {\n\n            bytes_written = VHDX_LOG_SECTOR_SIZE;\n\n            sector_write = data_tmp;\n\n        }\n\n\n\n        /* populate the raw sector data into the proper structures,\n\n         * as well as update the descriptor, and convert to proper\n\n         * endianness */\n\n        vhdx_log_raw_to_le_sector(new_desc, data_sector, sector_write,\n\n                                  s->log.sequence);\n\n\n\n        data_tmp += bytes_written;\n\n        data_sector++;\n\n        new_desc++;\n\n        file_offset += VHDX_LOG_SECTOR_SIZE;\n\n    }\n\n\n\n    /* checksum covers entire entry, from the log header through the\n\n     * last data sector */\n\n    vhdx_update_checksum(buffer, total_length,\n\n                         offsetof(VHDXLogEntryHeader, checksum));\n\n\n\n    /* now write to the log */\n\n    ret = vhdx_log_write_sectors(bs, &s->log, &sectors_written, buffer,\n\n                                 desc_sectors + sectors);\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\n    if (sectors_written != desc_sectors + sectors) {\n\n        /* instead of failing, we could flush the log here */\n\n        ret = -EINVAL;\n\n        goto exit;\n\n    }\n\n\n\n    s->log.sequence++;\n\n    /* write new tail */\n\n    s->log.tail = s->log.write;\n\n\n\nexit:\n\n    qemu_vfree(buffer);\n\n    qemu_vfree(merged_sector);\n\n    return ret;\n\n}\n", "idx": 6545, "_split": "test", "_hash": "3492e16d699830f7093bcef42eca37ab"}
{"project": "qemu", "commit_id": "aa4a3dce1c88ed51b616806b8214b7c8428b7470", "target": 1, "func": "static void vmxnet3_net_uninit(VMXNET3State *s)\n\n{\n\n    g_free(s->mcast_list);\n\n    vmxnet_tx_pkt_reset(s->tx_pkt);\n\n    vmxnet_tx_pkt_uninit(s->tx_pkt);\n\n    vmxnet_rx_pkt_uninit(s->rx_pkt);\n\n    qemu_del_nic(s->nic);\n\n}\n", "idx": 6547, "_split": "test", "_hash": "8b4d4c1f65d803c203f2b8adc30a9b76"}
{"project": "qemu", "commit_id": "61c7480fa36775cc2baa2f8141f0c64a15f827b5", "target": 1, "func": "CPUArchState *cpu_copy(CPUArchState *env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    CPUState *new_cpu = cpu_init(cpu_model);\n\n    CPUArchState *new_env = cpu->env_ptr;\n\n    CPUBreakpoint *bp;\n\n    CPUWatchpoint *wp;\n\n\n\n    /* Reset non arch specific state */\n\n    cpu_reset(new_cpu);\n\n\n\n    memcpy(new_env, env, sizeof(CPUArchState));\n\n\n\n    /* Clone all break/watchpoints.\n\n       Note: Once we support ptrace with hw-debug register access, make sure\n\n       BP_CPU break/watchpoints are handled correctly on clone. */\n\n    QTAILQ_INIT(&cpu->breakpoints);\n\n    QTAILQ_INIT(&cpu->watchpoints);\n\n    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {\n\n        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);\n\n    }\n\n    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {\n\n        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);\n\n    }\n\n\n\n    return new_env;\n\n}\n", "idx": 6577, "_split": "test", "_hash": "e2e8c1ce192e5a5480d52f4bef836e5f"}
{"project": "qemu", "commit_id": "6e99c631f116221d169ea53953d91b8aa74d297a", "target": 0, "func": "static int net_socket_can_send(void *opaque)\n\n{\n\n    NetSocketState *s = opaque;\n\n\n\n    return qemu_can_send_packet(&s->nc);\n\n}\n", "idx": 6594, "_split": "test", "_hash": "4914b5860f08c2a21fd1344772b56234"}
{"project": "qemu", "commit_id": "64d7e9a421fea0ac50b44541f5521de455e7cd5d", "target": 0, "func": "static void ppc_prep_init (ram_addr_t ram_size,\n\n                           const char *boot_device,\n\n                           const char *kernel_filename,\n\n                           const char *kernel_cmdline,\n\n                           const char *initrd_filename,\n\n                           const char *cpu_model)\n\n{\n\n    CPUState *env = NULL;\n\n    char *filename;\n\n    nvram_t nvram;\n\n    M48t59State *m48t59;\n\n    int PPC_io_memory;\n\n    int linux_boot, i, nb_nics1, bios_size;\n\n    ram_addr_t ram_offset, bios_offset;\n\n    uint32_t kernel_base, initrd_base;\n\n    long kernel_size, initrd_size;\n\n    PCIBus *pci_bus;\n\n    qemu_irq *i8259;\n\n    qemu_irq *cpu_exit_irq;\n\n    int ppc_boot_device;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    DriveInfo *fd[MAX_FD];\n\n\n\n    sysctrl = qemu_mallocz(sizeof(sysctrl_t));\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL)\n\n        cpu_model = \"602\";\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        if (env->flags & POWERPC_FLAG_RTC_CLK) {\n\n            /* POWER / PowerPC 601 RTC clock frequency is 7.8125 MHz */\n\n            cpu_ppc_tb_init(env, 7812500UL);\n\n        } else {\n\n            /* Set time-base frequency to 100 Mhz */\n\n            cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n        }\n\n        qemu_register_reset((QEMUResetHandler*)&cpu_reset, env);\n\n    }\n\n\n\n    /* allocate RAM */\n\n    ram_offset = qemu_ram_alloc(NULL, \"ppc_prep.ram\", ram_size);\n\n    cpu_register_physical_memory(0, ram_size, ram_offset);\n\n\n\n    /* allocate and load BIOS */\n\n    bios_offset = qemu_ram_alloc(NULL, \"ppc_prep.bios\", BIOS_SIZE);\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (filename) {\n\n        bios_size = get_image_size(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if (bios_size > 0 && bios_size <= BIOS_SIZE) {\n\n        target_phys_addr_t bios_addr;\n\n        bios_size = (bios_size + 0xfff) & ~0xfff;\n\n        bios_addr = (uint32_t)(-bios_size);\n\n        cpu_register_physical_memory(bios_addr, bios_size,\n\n                                     bios_offset | IO_MEM_ROM);\n\n        bios_size = load_image_targphys(filename, bios_addr, bios_size);\n\n    }\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        hw_error(\"qemu: could not load PPC PREP bios '%s'\\n\", bios_name);\n\n    }\n\n    if (filename) {\n\n        qemu_free(filename);\n\n    }\n\n\n\n    if (linux_boot) {\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* now we can load the kernel */\n\n        kernel_size = load_image_targphys(kernel_filename, kernel_base,\n\n                                          ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            hw_error(\"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                hw_error(\"qemu: could not load initial ram disk '%s'\\n\",\n\n                          initrd_filename);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        ppc_boot_device = '\\0';\n\n        /* For now, OHW cannot boot from the network. */\n\n        for (i = 0; boot_device[i] != '\\0'; i++) {\n\n            if (boot_device[i] >= 'a' && boot_device[i] <= 'f') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n        }\n\n        if (ppc_boot_device == '\\0') {\n\n            fprintf(stderr, \"No valid boot device for Mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    isa_mem_base = 0xc0000000;\n\n    if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) {\n\n        hw_error(\"Only 6xx bus is supported on PREP machine\\n\");\n\n    }\n\n    i8259 = i8259_init(first_cpu->irq_inputs[PPC6xx_INPUT_INT]);\n\n    pci_bus = pci_prep_init(i8259);\n\n    /* Hmm, prep has no pci-isa bridge ??? */\n\n    isa_bus_new(NULL);\n\n    isa_bus_irqs(i8259);\n\n    //    pci_bus = i440fx_init();\n\n    /* Register 8 MB of ISA IO space (needed for non-contiguous map) */\n\n    PPC_io_memory = cpu_register_io_memory(PPC_prep_io_read,\n\n                                           PPC_prep_io_write, sysctrl,\n\n                                           DEVICE_LITTLE_ENDIAN);\n\n    cpu_register_physical_memory(0x80000000, 0x00800000, PPC_io_memory);\n\n\n\n    /* init basic PC hardware */\n\n    pci_vga_init(pci_bus);\n\n    //    openpic = openpic_init(0x00000000, 0xF0000000, 1);\n\n    //    pit = pit_init(0x40, i8259[0]);\n\n    rtc_init(2000, NULL);\n\n\n\n    if (serial_hds[0])\n\n        serial_isa_init(0, serial_hds[0]);\n\n    nb_nics1 = nb_nics;\n\n    if (nb_nics1 > NE2000_NB_MAX)\n\n        nb_nics1 = NE2000_NB_MAX;\n\n    for(i = 0; i < nb_nics1; i++) {\n\n        if (nd_table[i].model == NULL) {\n\n\t    nd_table[i].model = qemu_strdup(\"ne2k_isa\");\n\n        }\n\n        if (strcmp(nd_table[i].model, \"ne2k_isa\") == 0) {\n\n            isa_ne2000_init(ne2000_io[i], ne2000_irq[i], &nd_table[i]);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], \"ne2k_pci\", NULL);\n\n        }\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n    }\n\n\n\n    for(i = 0; i < 1/*MAX_IDE_BUS*/; i++) {\n\n        isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i],\n\n                     hd[2 * i],\n\n\t\t     hd[2 * i + 1]);\n\n    }\n\n    isa_create_simple(\"i8042\");\n\n\n\n    cpu_exit_irq = qemu_allocate_irqs(cpu_request_exit, NULL, 1);\n\n    DMA_init(1, cpu_exit_irq);\n\n\n\n    //    SB16_init();\n\n\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        fd[i] = drive_get(IF_FLOPPY, 0, i);\n\n    }\n\n    fdctrl_init_isa(fd);\n\n\n\n    /* Register speaker port */\n\n    register_ioport_read(0x61, 1, 1, speaker_ioport_read, NULL);\n\n    register_ioport_write(0x61, 1, 1, speaker_ioport_write, NULL);\n\n    /* Register fake IO ports for PREP */\n\n    sysctrl->reset_irq = first_cpu->irq_inputs[PPC6xx_INPUT_HRESET];\n\n    register_ioport_read(0x398, 2, 1, &PREP_io_read, sysctrl);\n\n    register_ioport_write(0x398, 2, 1, &PREP_io_write, sysctrl);\n\n    /* System control ports */\n\n    register_ioport_read(0x0092, 0x01, 1, &PREP_io_800_readb, sysctrl);\n\n    register_ioport_write(0x0092, 0x01, 1, &PREP_io_800_writeb, sysctrl);\n\n    register_ioport_read(0x0800, 0x52, 1, &PREP_io_800_readb, sysctrl);\n\n    register_ioport_write(0x0800, 0x52, 1, &PREP_io_800_writeb, sysctrl);\n\n    /* PCI intack location */\n\n    PPC_io_memory = cpu_register_io_memory(PPC_intack_read,\n\n                                           PPC_intack_write, NULL,\n\n                                           DEVICE_LITTLE_ENDIAN);\n\n    cpu_register_physical_memory(0xBFFFFFF0, 0x4, PPC_io_memory);\n\n    /* PowerPC control and status register group */\n\n#if 0\n\n    PPC_io_memory = cpu_register_io_memory(PPC_XCSR_read, PPC_XCSR_write,\n\n                                           NULL, DEVICE_LITTLE_ENDIAN);\n\n    cpu_register_physical_memory(0xFEFF0000, 0x1000, PPC_io_memory);\n\n#endif\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, -1);\n\n    }\n\n\n\n    m48t59 = m48t59_init(i8259[8], 0, 0x0074, NVRAM_SIZE, 59);\n\n    if (m48t59 == NULL)\n\n        return;\n\n    sysctrl->nvram = m48t59;\n\n\n\n    /* Initialise NVRAM */\n\n    nvram.opaque = m48t59;\n\n    nvram.read_fn = &m48t59_read;\n\n    nvram.write_fn = &m48t59_write;\n\n    PPC_NVRAM_set_params(&nvram, NVRAM_SIZE, \"PREP\", ram_size, ppc_boot_device,\n\n                         kernel_base, kernel_size,\n\n                         kernel_cmdline,\n\n                         initrd_base, initrd_size,\n\n                         /* XXX: need an option to load a NVRAM image */\n\n                         0,\n\n                         graphic_width, graphic_height, graphic_depth);\n\n\n\n    /* Special port to get debug messages from Open-Firmware */\n\n    register_ioport_write(0x0F00, 4, 1, &PPC_debug_write, NULL);\n\n}\n", "idx": 6605, "_split": "test", "_hash": "fc93530474aabed907059bd692a5631b"}
{"project": "qemu", "commit_id": "d96391c1ffeb30a0afa695c86579517c69d9a889", "target": 1, "func": "target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)\n\n{\n\n    check_hwrena(env, 0);\n\n    return env->CP0_EBase & 0x3ff;\n\n}\n", "idx": 6628, "_split": "test", "_hash": "ba9a8aa6c428153c3bfbe890032d9362"}
{"project": "qemu", "commit_id": "9cb805fd2674f474d058fee6d7aa9e83fcd3d336", "target": 1, "func": "void qmp_inject_nmi(Error **errp)\n\n{\n\n#if defined(TARGET_I386)\n\n    CPUState *cs;\n\n\n\n    CPU_FOREACH(cs) {\n\n        X86CPU *cpu = X86_CPU(cs);\n\n\n\n        if (!cpu->apic_state) {\n\n            cpu_interrupt(cs, CPU_INTERRUPT_NMI);\n\n        } else {\n\n            apic_deliver_nmi(cpu->apic_state);\n\n        }\n\n    }\n\n#elif defined(TARGET_S390X)\n\n    CPUState *cs;\n\n    S390CPU *cpu;\n\n\n\n    CPU_FOREACH(cs) {\n\n        cpu = S390_CPU(cs);\n\n        if (cpu->env.cpu_num == monitor_get_cpu_index()) {\n\n            if (s390_cpu_restart(S390_CPU(cs)) == -1) {\n\n                error_set(errp, QERR_UNSUPPORTED);\n\n                return;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n#else\n\n    error_set(errp, QERR_UNSUPPORTED);\n\n#endif\n\n}\n", "idx": 6635, "_split": "test", "_hash": "24814f1bd43f5721931d184197d7e6d2"}
{"project": "qemu", "commit_id": "e175bce587936bf479889881488821ea8d61c89c", "target": 1, "func": "void helper_single_step(CPUX86State *env)\n\n{\n\n#ifndef CONFIG_USER_ONLY\n\n    check_hw_breakpoints(env, 1);\n\n    env->dr[6] |= DR6_BS;\n\n#endif\n\n    raise_exception(env, EXCP01_DB);\n\n}\n", "idx": 6641, "_split": "test", "_hash": "44c7fe07dd3cc245bde2d184e00417b7"}
{"project": "qemu", "commit_id": "e0cb42ae4bc4438ba4ec0760df2d830b8759b255", "target": 1, "func": "static void con_disconnect(struct XenDevice *xendev)\n\n{\n\n    struct XenConsole *con = container_of(xendev, struct XenConsole, xendev);\n\n\n\n    if (con->chr) {\n\n        qemu_chr_add_handlers(con->chr, NULL, NULL, NULL, NULL);\n\n        qemu_chr_fe_release(con->chr);\n\n    }\n\n    xen_be_unbind_evtchn(&con->xendev);\n\n\n\n    if (con->sring) {\n\n        if (!xendev->dev) {\n\n            munmap(con->sring, XC_PAGE_SIZE);\n\n        } else {\n\n            xengnttab_unmap(xendev->gnttabdev, con->sring, 1);\n\n        }\n\n        con->sring = NULL;\n\n    }\n\n}\n", "idx": 6650, "_split": "test", "_hash": "0cf24ce34a3901e54e9026ddbb47391a"}
{"project": "qemu", "commit_id": "2e63eb2becc228232f12a1ea30a91b2aa8c5cecd", "target": 1, "func": "static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->realize = xen_pt_realize;\n\n    k->exit = xen_pt_unregister_device;\n\n    k->config_read = xen_pt_pci_read_config;\n\n    k->config_write = xen_pt_pci_write_config;\n\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->desc = \"Assign an host PCI device with Xen\";\n\n    dc->props = xen_pci_passthrough_properties;\n\n};", "idx": 6674, "_split": "test", "_hash": "8a452f11d28c25373e2fe2f31d6d6e80"}
{"project": "qemu", "commit_id": "fa1298c2d623522eda7b4f1f721fcb935abb7360", "target": 1, "func": "static int ohci_bus_start(OHCIState *ohci)\n\n{\n\n    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n\n                    ohci_frame_boundary,\n\n                    ohci);\n\n\n\n    if (ohci->eof_timer == NULL) {\n\n        trace_usb_ohci_bus_eof_timer_failed(ohci->name);\n\n        ohci_die(ohci);\n\n        return 0;\n\n    }\n\n\n\n    trace_usb_ohci_start(ohci->name);\n\n\n\n    /* Delay the first SOF event by one frame time as\n\n     * linux driver is not ready to receive it and\n\n     * can meet some race conditions\n\n     */\n\n\n\n    ohci_eof_timer(ohci);\n\n\n\n    return 1;\n\n}\n", "idx": 6685, "_split": "test", "_hash": "e292d2d497519fb9a718547b486ce53c"}
{"project": "qemu", "commit_id": "3ac2f2f765a0bc18dfb18c38a522e6123289ffc1", "target": 1, "func": "void bdrv_image_info_specific_dump(fprintf_function func_fprintf, void *f,\n\n                                   ImageInfoSpecific *info_spec)\n\n{\n\n    QObject *obj, *data;\n\n    Visitor *v = qmp_output_visitor_new(&obj);\n\n\n\n    visit_type_ImageInfoSpecific(v, NULL, &info_spec, &error_abort);\n\n    visit_complete(v, &obj);\n\n    assert(qobject_type(obj) == QTYPE_QDICT);\n\n    data = qdict_get(qobject_to_qdict(obj), \"data\");\n\n    dump_qobject(func_fprintf, f, 1, data);\n\n\n    visit_free(v);\n\n}", "idx": 6699, "_split": "test", "_hash": "03d472ebab2ecdad6cc84b42f002a0e8"}
{"project": "qemu", "commit_id": "d5fee0bbe68d5e61e2d2beb5ff6de0b9c1cfd182", "target": 0, "func": "int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,\n\n                              int mmu_idx)\n\n{\n\n    if (ppc64_radix_guest(cpu)) { /* Guest uses radix */\n\n        /* TODO - Unsupported */\n\n        error_report(\"Guest Radix Support Unimplemented\");\n\n        exit(1);\n\n    } else { /* Guest uses hash */\n\n        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);\n\n    }\n\n}\n", "idx": 6753, "_split": "test", "_hash": "5208656b9dfeaf0c0567113d4f186efb"}
{"project": "qemu", "commit_id": "40c4ed3f95f0b2ffa0848df0fc311556bb7472a1", "target": 1, "func": "void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    IDEBus *bus = opaque;\n\n    IDEState *s = idebus_active_if(bus);\n\n    uint8_t *p;\n\n\n\n    /* PIO data access allowed only when DRQ bit is set */\n\n    if (!(s->status & DRQ_STAT))\n\n        return;\n\n\n\n    p = s->data_ptr;\n\n    *(uint16_t *)p = le16_to_cpu(val);\n\n    p += 2;\n\n    s->data_ptr = p;\n\n    if (p >= s->data_end)\n\n        s->end_transfer_func(s);\n\n}\n", "idx": 6775, "_split": "test", "_hash": "8c9939abc9adba17e0d7d8751e7107f9"}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void keyword_literal(void)\n\n{\n\n    QObject *obj;\n\n    QBool *qbool;\n\n    QObject *null;\n\n    QString *str;\n\n\n\n    obj = qobject_from_json(\"true\", NULL);\n\n    qbool = qobject_to_qbool(obj);\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == true);\n\n\n\n    str = qobject_to_json(obj);\n\n    g_assert(strcmp(qstring_get_str(str), \"true\") == 0);\n\n    QDECREF(str);\n\n\n\n    QDECREF(qbool);\n\n\n\n    obj = qobject_from_json(\"false\", NULL);\n\n    qbool = qobject_to_qbool(obj);\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == false);\n\n\n\n    str = qobject_to_json(obj);\n\n    g_assert(strcmp(qstring_get_str(str), \"false\") == 0);\n\n    QDECREF(str);\n\n\n\n    QDECREF(qbool);\n\n\n\n    qbool = qobject_to_qbool(qobject_from_jsonf(\"%i\", false));\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == false);\n\n    QDECREF(qbool);\n\n\n\n    /* Test that non-zero values other than 1 get collapsed to true */\n\n    qbool = qobject_to_qbool(qobject_from_jsonf(\"%i\", 2));\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == true);\n\n    QDECREF(qbool);\n\n\n\n    obj = qobject_from_json(\"null\", NULL);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QNULL);\n\n\n\n    null = qnull();\n\n    g_assert(null == obj);\n\n\n\n    qobject_decref(obj);\n\n    qobject_decref(null);\n\n}\n", "idx": 6816, "_split": "test", "_hash": "ac549335645f2ae3a410d451c7108a34"}
{"project": "qemu", "commit_id": "093209cd681fe9fb65bd8a1c2ff711b8168bbfcd", "target": 0, "func": "static void ppc_core99_init (ram_addr_t ram_size,\n\n                             const char *boot_device,\n\n                             const char *kernel_filename,\n\n                             const char *kernel_cmdline,\n\n                             const char *initrd_filename,\n\n                             const char *cpu_model)\n\n{\n\n    CPUState *env = NULL, *envs[MAX_CPUS];\n\n    char *filename;\n\n    qemu_irq *pic, **openpic_irqs;\n\n    int unin_memory;\n\n    int linux_boot, i;\n\n    ram_addr_t ram_offset, bios_offset, vga_bios_offset;\n\n    uint32_t kernel_base, kernel_size, initrd_base, initrd_size;\n\n    PCIBus *pci_bus;\n\n    MacIONVRAMState *nvr;\n\n    int nvram_mem_index;\n\n    int vga_bios_size, bios_size;\n\n    int pic_mem_index, dbdma_mem_index, cuda_mem_index, escc_mem_index;\n\n    int ide_mem_index[3];\n\n    int ppc_boot_device;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    void *fw_cfg;\n\n    void *dbdma;\n\n    uint8_t *vga_bios_ptr;\n\n    int machine_arch;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL)\n\n#ifdef TARGET_PPC64\n\n        cpu_model = \"970fx\";\n\n#else\n\n        cpu_model = \"G4\";\n\n#endif\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        /* Set time-base frequency to 100 Mhz */\n\n        cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n#if 0\n\n        env->osi_call = vga_osi_call;\n\n#endif\n\n        qemu_register_reset((QEMUResetHandler*)&cpu_reset, env);\n\n        envs[i] = env;\n\n    }\n\n\n\n    /* allocate RAM */\n\n    ram_offset = qemu_ram_alloc(NULL, \"ppc_core99.ram\", ram_size);\n\n    cpu_register_physical_memory(0, ram_size, ram_offset);\n\n\n\n    /* allocate and load BIOS */\n\n    bios_offset = qemu_ram_alloc(NULL, \"ppc_core99.bios\", BIOS_SIZE);\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    cpu_register_physical_memory(PROM_ADDR, BIOS_SIZE, bios_offset | IO_MEM_ROM);\n\n\n\n    /* Load OpenBIOS (ELF) */\n\n    if (filename) {\n\n        bios_size = load_elf(filename, NULL, NULL, NULL,\n\n                             NULL, NULL, 1, ELF_MACHINE, 0);\n\n\n\n        qemu_free(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        hw_error(\"qemu: could not load PowerPC bios '%s'\\n\", bios_name);\n\n        exit(1);\n\n    }\n\n\n\n    /* allocate and load VGA BIOS */\n\n    vga_bios_offset = qemu_ram_alloc(NULL, \"ppc_core99.vbios\", VGA_BIOS_SIZE);\n\n    vga_bios_ptr = qemu_get_ram_ptr(vga_bios_offset);\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, VGABIOS_FILENAME);\n\n    if (filename) {\n\n        vga_bios_size = load_image(filename, vga_bios_ptr + 8);\n\n        qemu_free(filename);\n\n    } else {\n\n        vga_bios_size = -1;\n\n    }\n\n    if (vga_bios_size < 0) {\n\n        /* if no bios is present, we can still work */\n\n        fprintf(stderr, \"qemu: warning: could not load VGA bios '%s'\\n\",\n\n                VGABIOS_FILENAME);\n\n        vga_bios_size = 0;\n\n    } else {\n\n        /* set a specific header (XXX: find real Apple format for NDRV\n\n           drivers) */\n\n        vga_bios_ptr[0] = 'N';\n\n        vga_bios_ptr[1] = 'D';\n\n        vga_bios_ptr[2] = 'R';\n\n        vga_bios_ptr[3] = 'V';\n\n        cpu_to_be32w((uint32_t *)(vga_bios_ptr + 4), vga_bios_size);\n\n        vga_bios_size += 8;\n\n\n\n        /* Round to page boundary */\n\n        vga_bios_size = (vga_bios_size + TARGET_PAGE_SIZE - 1) &\n\n            TARGET_PAGE_MASK;\n\n    }\n\n\n\n    if (linux_boot) {\n\n        uint64_t lowaddr = 0;\n\n        int bswap_needed;\n\n\n\n#ifdef BSWAP_NEEDED\n\n        bswap_needed = 1;\n\n#else\n\n        bswap_needed = 0;\n\n#endif\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_aout(kernel_filename, kernel_base,\n\n                                    ram_size - kernel_base, bswap_needed,\n\n                                    TARGET_PAGE_SIZE);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              kernel_base,\n\n                                              ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            hw_error(\"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                hw_error(\"qemu: could not load initial ram disk '%s'\\n\",\n\n                         initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        ppc_boot_device = '\\0';\n\n        /* We consider that NewWorld PowerMac never have any floppy drive\n\n         * For now, OHW cannot boot from the network.\n\n         */\n\n        for (i = 0; boot_device[i] != '\\0'; i++) {\n\n            if (boot_device[i] >= 'c' && boot_device[i] <= 'f') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n        }\n\n        if (ppc_boot_device == '\\0') {\n\n            fprintf(stderr, \"No valid boot device for Mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    isa_mem_base = 0x80000000;\n\n\n\n    /* Register 8 MB of ISA IO space */\n\n    isa_mmio_init(0xf2000000, 0x00800000, 1);\n\n\n\n    /* UniN init */\n\n    unin_memory = cpu_register_io_memory(unin_read, unin_write, NULL);\n\n    cpu_register_physical_memory(0xf8000000, 0x00001000, unin_memory);\n\n\n\n    openpic_irqs = qemu_mallocz(smp_cpus * sizeof(qemu_irq *));\n\n    openpic_irqs[0] =\n\n        qemu_mallocz(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        /* Mac99 IRQ connection between OpenPIC outputs pins\n\n         * and PowerPC input pins\n\n         */\n\n        switch (PPC_INPUT(env)) {\n\n        case PPC_FLAGS_INPUT_6xx:\n\n            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n            openpic_irqs[i][OPENPIC_OUTPUT_INT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_MCP];\n\n            /* Not connected ? */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;\n\n            /* Check this */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_HRESET];\n\n            break;\n\n#if defined(TARGET_PPC64)\n\n        case PPC_FLAGS_INPUT_970:\n\n            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n            openpic_irqs[i][OPENPIC_OUTPUT_INT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_MCP];\n\n            /* Not connected ? */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;\n\n            /* Check this */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_HRESET];\n\n            break;\n\n#endif /* defined(TARGET_PPC64) */\n\n        default:\n\n            hw_error(\"Bus model not supported on mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n    pic = openpic_init(NULL, &pic_mem_index, smp_cpus, openpic_irqs, NULL);\n\n    if (PPC_INPUT(env) == PPC_FLAGS_INPUT_970) {\n\n        /* 970 gets a U3 bus */\n\n        pci_bus = pci_pmac_u3_init(pic);\n\n        machine_arch = ARCH_MAC99_U3;\n\n    } else {\n\n        pci_bus = pci_pmac_init(pic);\n\n        machine_arch = ARCH_MAC99;\n\n    }\n\n    /* init basic PC hardware */\n\n    pci_vga_init(pci_bus, vga_bios_offset, vga_bios_size);\n\n\n\n    escc_mem_index = escc_init(0x80013000, pic[0x25], pic[0x24],\n\n                               serial_hds[0], serial_hds[1], ESCC_CLOCK, 4);\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init_nofail(&nd_table[i], \"ne2k_pci\", NULL);\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n    dbdma = DBDMA_init(&dbdma_mem_index);\n\n\n\n    /* We only emulate 2 out of 3 IDE controllers for now */\n\n    ide_mem_index[0] = -1;\n\n    hd[0] = drive_get(IF_IDE, 0, 0);\n\n    hd[1] = drive_get(IF_IDE, 0, 1);\n\n    ide_mem_index[1] = pmac_ide_init(hd, pic[0x0d], dbdma, 0x16, pic[0x02]);\n\n    hd[0] = drive_get(IF_IDE, 1, 0);\n\n    hd[1] = drive_get(IF_IDE, 1, 1);\n\n    ide_mem_index[2] = pmac_ide_init(hd, pic[0x0e], dbdma, 0x1a, pic[0x02]);\n\n\n\n    /* cuda also initialize ADB */\n\n    if (machine_arch == ARCH_MAC99_U3) {\n\n        usb_enabled = 1;\n\n    }\n\n    cuda_init(&cuda_mem_index, pic[0x19]);\n\n\n\n    adb_kbd_init(&adb_bus);\n\n    adb_mouse_init(&adb_bus);\n\n\n\n    macio_init(pci_bus, PCI_DEVICE_ID_APPLE_UNI_N_KEYL, 0, pic_mem_index,\n\n               dbdma_mem_index, cuda_mem_index, NULL, 3, ide_mem_index,\n\n               escc_mem_index);\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, -1);\n\n    }\n\n\n\n    /* U3 needs to use USB for input because Linux doesn't support via-cuda\n\n       on PPC64 */\n\n    if (machine_arch == ARCH_MAC99_U3) {\n\n        usbdevice_create(\"keyboard\");\n\n        usbdevice_create(\"mouse\");\n\n    }\n\n\n\n    if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8)\n\n        graphic_depth = 15;\n\n\n\n    /* The NewWorld NVRAM is not located in the MacIO device */\n\n    nvr = macio_nvram_init(&nvram_mem_index, 0x2000, 1);\n\n    pmac_format_nvram_partition(nvr, 0x2000);\n\n    macio_nvram_map(nvr, 0xFFF04000);\n\n    /* No PCI init: the BIOS will do it */\n\n\n\n    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, machine_arch);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);\n\n        pstrcpy_targphys(\"cmdline\", CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, ppc_boot_device);\n\n\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth);\n\n\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_IS_KVM, kvm_enabled());\n\n    if (kvm_enabled()) {\n\n#ifdef CONFIG_KVM\n\n        uint8_t *hypercall;\n\n\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, kvmppc_get_tbfreq());\n\n        hypercall = qemu_malloc(16);\n\n        kvmppc_get_hypercall(env, hypercall, 16);\n\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_PPC_KVM_HC, hypercall, 16);\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_KVM_PID, getpid());\n\n#endif\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, get_ticks_per_sec());\n\n    }\n\n\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}\n", "idx": 6829, "_split": "test", "_hash": "c318cfa95cb6f3f77dd83a5948c703a9"}
{"project": "qemu", "commit_id": "492c30af2567a59413c064f88eb81e1691865195", "target": 0, "func": "void DMA_run(void)\n\n{\n\n    /* XXXXX */\n\n}\n", "idx": 6838, "_split": "test", "_hash": "fb4cb71b6d1e04ef43b9ac2da33f5b2f"}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "INLINE int16 extractFloat64Exp( float64 a )\n\n{\n\n\n\n    return ( a>>52 ) & 0x7FF;\n\n\n\n}\n", "idx": 6844, "_split": "test", "_hash": "4bee587d65864ccdc936a322341f3e16"}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint32_t helper_fcmp_un(uint32_t a, uint32_t b)\n\n{\n\n    CPU_FloatU fa, fb;\n\n    uint32_t r = 0;\n\n\n\n    fa.l = a;\n\n    fb.l = b;\n\n\n\n    if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) {\n\n        update_fpu_flags(float_flag_invalid);\n\n        r = 1;\n\n    }\n\n\n\n    if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) {\n\n        r = 1;\n\n    }\n\n\n\n    return r;\n\n}\n", "idx": 6852, "_split": "test", "_hash": "7138b01d3641cdc31921cb38b0cb632a"}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static int vhost_user_start(VhostUserState *s)\n\n{\n\n    VhostNetOptions options;\n\n\n\n    if (vhost_user_running(s)) {\n\n        return 0;\n\n    }\n\n\n\n    options.backend_type = VHOST_BACKEND_TYPE_USER;\n\n    options.net_backend = &s->nc;\n\n    options.opaque = s->chr;\n\n\n\n    s->vhost_net = vhost_net_init(&options);\n\n\n\n    return vhost_user_running(s) ? 0 : -1;\n\n}\n", "idx": 6867, "_split": "test", "_hash": "21874305f95231eb09e99fa290c8679a"}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "static void sdhci_send_command(SDHCIState *s)\n\n{\n\n    SDRequest request;\n\n    uint8_t response[16];\n\n    int rlen;\n\n\n\n    s->errintsts = 0;\n\n    s->acmd12errsts = 0;\n\n    request.cmd = s->cmdreg >> 8;\n\n    request.arg = s->argument;\n\n    DPRINT_L1(\"sending CMD%u ARG[0x%08x]\\n\", request.cmd, request.arg);\n\n    rlen = sdbus_do_command(&s->sdbus, &request, response);\n\n\n\n    if (s->cmdreg & SDHC_CMD_RESPONSE) {\n\n        if (rlen == 4) {\n\n            s->rspreg[0] = (response[0] << 24) | (response[1] << 16) |\n\n                           (response[2] << 8)  |  response[3];\n\n            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;\n\n            DPRINT_L1(\"Response: RSPREG[31..0]=0x%08x\\n\", s->rspreg[0]);\n\n        } else if (rlen == 16) {\n\n            s->rspreg[0] = (response[11] << 24) | (response[12] << 16) |\n\n                           (response[13] << 8) |  response[14];\n\n            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |\n\n                           (response[9] << 8)  |  response[10];\n\n            s->rspreg[2] = (response[3] << 24) | (response[4] << 16) |\n\n                           (response[5] << 8)  |  response[6];\n\n            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |\n\n                            response[2];\n\n            DPRINT_L1(\"Response received:\\n RSPREG[127..96]=0x%08x, RSPREG[95..\"\n\n                  \"64]=0x%08x,\\n RSPREG[63..32]=0x%08x, RSPREG[31..0]=0x%08x\\n\",\n\n                  s->rspreg[3], s->rspreg[2], s->rspreg[1], s->rspreg[0]);\n\n        } else {\n\n            ERRPRINT(\"Timeout waiting for command response\\n\");\n\n            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {\n\n                s->errintsts |= SDHC_EIS_CMDTIMEOUT;\n\n                s->norintsts |= SDHC_NIS_ERR;\n\n            }\n\n        }\n\n\n\n        if ((s->norintstsen & SDHC_NISEN_TRSCMP) &&\n\n            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {\n\n            s->norintsts |= SDHC_NIS_TRSCMP;\n\n        }\n\n    }\n\n\n\n    if (s->norintstsen & SDHC_NISEN_CMDCMP) {\n\n        s->norintsts |= SDHC_NIS_CMDCMP;\n\n    }\n\n\n\n    sdhci_update_irq(s);\n\n\n\n    if (s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {\n\n        s->data_count = 0;\n\n        sdhci_data_transfer(s);\n\n    }\n\n}\n", "idx": 6891, "_split": "test", "_hash": "68e5b78329117e36f0d568bba0a6fa58"}
{"project": "qemu", "commit_id": "ddf21908961073199f3d186204da4810f2ea150b", "target": 0, "func": "static void test_dealloc_types(void)\n\n{\n\n    UserDefOne *ud1test, *ud1a, *ud1b;\n\n    UserDefOneList *ud1list;\n\n\n\n    ud1test = g_malloc0(sizeof(UserDefOne));\n\n    ud1test->base = g_new0(UserDefZero, 1);\n\n    ud1test->base->integer = 42;\n\n    ud1test->string = g_strdup(\"hi there 42\");\n\n\n\n    qapi_free_UserDefOne(ud1test);\n\n\n\n    ud1a = g_malloc0(sizeof(UserDefOne));\n\n    ud1a->base = g_new0(UserDefZero, 1);\n\n    ud1a->base->integer = 43;\n\n    ud1a->string = g_strdup(\"hi there 43\");\n\n\n\n    ud1b = g_malloc0(sizeof(UserDefOne));\n\n    ud1b->base = g_new0(UserDefZero, 1);\n\n    ud1b->base->integer = 44;\n\n    ud1b->string = g_strdup(\"hi there 44\");\n\n\n\n    ud1list = g_malloc0(sizeof(UserDefOneList));\n\n    ud1list->value = ud1a;\n\n    ud1list->next = g_malloc0(sizeof(UserDefOneList));\n\n    ud1list->next->value = ud1b;\n\n\n\n    qapi_free_UserDefOneList(ud1list);\n\n}\n", "idx": 6919, "_split": "test", "_hash": "9861ff47c2b646e3204b11033614362a"}
{"project": "qemu", "commit_id": "362786f14a753d8a5256ef97d7c10ed576d6572b", "target": 0, "func": "void net_checksum_calculate(uint8_t *data, int length)\n\n{\n\n    int hlen, plen, proto, csum_offset;\n\n    uint16_t csum;\n\n\n\n    if ((data[14] & 0xf0) != 0x40)\n\n\treturn; /* not IPv4 */\n\n    hlen  = (data[14] & 0x0f) * 4;\n\n    plen  = (data[16] << 8 | data[17]) - hlen;\n\n    proto = data[23];\n\n\n\n    switch (proto) {\n\n    case PROTO_TCP:\n\n\tcsum_offset = 16;\n\n\tbreak;\n\n    case PROTO_UDP:\n\n\tcsum_offset = 6;\n\n\tbreak;\n\n    default:\n\n\treturn;\n\n    }\n\n\n\n    if (plen < csum_offset+2)\n\n\treturn;\n\n\n\n    data[14+hlen+csum_offset]   = 0;\n\n    data[14+hlen+csum_offset+1] = 0;\n\n    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);\n\n    data[14+hlen+csum_offset]   = csum >> 8;\n\n    data[14+hlen+csum_offset+1] = csum & 0xff;\n\n}\n", "idx": 6927, "_split": "test", "_hash": "c0b29c4a43d78fa29c2b93c9a6479a90"}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static void x86_cpu_parse_featurestr(const char *typename, char *features,\n\n                                     Error **errp)\n\n{\n\n    char *featurestr; /* Single 'key=value\" string being parsed */\n\n    static bool cpu_globals_initialized;\n\n    bool ambiguous = false;\n\n\n\n    if (cpu_globals_initialized) {\n\n        return;\n\n    }\n\n    cpu_globals_initialized = true;\n\n\n\n    if (!features) {\n\n        return;\n\n    }\n\n\n\n    for (featurestr = strtok(features, \",\");\n\n         featurestr;\n\n         featurestr = strtok(NULL, \",\")) {\n\n        const char *name;\n\n        const char *val = NULL;\n\n        char *eq = NULL;\n\n        char num[32];\n\n        GlobalProperty *prop;\n\n\n\n        /* Compatibility syntax: */\n\n        if (featurestr[0] == '+') {\n\n            plus_features = g_list_append(plus_features,\n\n                                          g_strdup(featurestr + 1));\n\n            continue;\n\n        } else if (featurestr[0] == '-') {\n\n            minus_features = g_list_append(minus_features,\n\n                                           g_strdup(featurestr + 1));\n\n            continue;\n\n        }\n\n\n\n        eq = strchr(featurestr, '=');\n\n        if (eq) {\n\n            *eq++ = 0;\n\n            val = eq;\n\n        } else {\n\n            val = \"on\";\n\n        }\n\n\n\n        feat2prop(featurestr);\n\n        name = featurestr;\n\n\n\n        if (g_list_find_custom(plus_features, name, compare_string)) {\n\n            error_report(\"warning: Ambiguous CPU model string. \"\n\n                         \"Don't mix both \\\"+%s\\\" and \\\"%s=%s\\\"\",\n\n                         name, name, val);\n\n            ambiguous = true;\n\n        }\n\n        if (g_list_find_custom(minus_features, name, compare_string)) {\n\n            error_report(\"warning: Ambiguous CPU model string. \"\n\n                         \"Don't mix both \\\"-%s\\\" and \\\"%s=%s\\\"\",\n\n                         name, name, val);\n\n            ambiguous = true;\n\n        }\n\n\n\n        /* Special case: */\n\n        if (!strcmp(name, \"tsc-freq\")) {\n\n            int64_t tsc_freq;\n\n\n\n            tsc_freq = qemu_strtosz_metric(val, NULL);\n\n            if (tsc_freq < 0) {\n\n                error_setg(errp, \"bad numerical value %s\", val);\n\n                return;\n\n            }\n\n            snprintf(num, sizeof(num), \"%\" PRId64, tsc_freq);\n\n            val = num;\n\n            name = \"tsc-frequency\";\n\n        }\n\n\n\n        prop = g_new0(typeof(*prop), 1);\n\n        prop->driver = typename;\n\n        prop->property = g_strdup(name);\n\n        prop->value = g_strdup(val);\n\n        prop->errp = &error_fatal;\n\n        qdev_prop_register_global(prop);\n\n    }\n\n\n\n    if (ambiguous) {\n\n        error_report(\"warning: Compatibility of ambiguous CPU model \"\n\n                     \"strings won't be kept on future QEMU versions\");\n\n    }\n\n}\n", "idx": 6935, "_split": "test", "_hash": "a27e845a3294d08d662e95be5a6ce262"}
{"project": "qemu", "commit_id": "361dcc790db8c87b2e46ab610739191ced894c44", "target": 1, "func": "static VirtIOSCSIVring *virtio_scsi_vring_init(VirtIOSCSI *s,\n\n                                               VirtQueue *vq,\n\n                                               EventNotifierHandler *handler,\n\n                                               int n)\n\n{\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    VirtIOSCSIVring *r = g_slice_new(VirtIOSCSIVring);\n\n    int rc;\n\n\n\n    /* Set up virtqueue notify */\n\n    rc = k->set_host_notifier(qbus->parent, n, true);\n\n    if (rc != 0) {\n\n        fprintf(stderr, \"virtio-scsi: Failed to set host notifier (%d)\\n\",\n\n                rc);\n\n        exit(1);\n\n    }\n\n    r->host_notifier = *virtio_queue_get_host_notifier(vq);\n\n    r->guest_notifier = *virtio_queue_get_guest_notifier(vq);\n\n    aio_set_event_notifier(s->ctx, &r->host_notifier, handler);\n\n\n\n    r->parent = s;\n\n\n\n    if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {\n\n        fprintf(stderr, \"virtio-scsi: VRing setup failed\\n\");\n\n        exit(1);\n\n    }\n\n    return r;\n\n}\n", "idx": 6946, "_split": "test", "_hash": "c259db4b861b13ec065354b34bf6b490"}
{"project": "qemu", "commit_id": "7d91ddd25e3a4e5008a2ac16127d51a34fd56bf1", "target": 1, "func": "void qemu_net_queue_purge(NetQueue *queue, NetClientState *from)\n\n{\n\n    NetPacket *packet, *next;\n\n\n\n    QTAILQ_FOREACH_SAFE(packet, &queue->packets, entry, next) {\n\n        if (packet->sender == from) {\n\n            QTAILQ_REMOVE(&queue->packets, packet, entry);\n\n\n            g_free(packet);\n\n        }\n\n    }\n\n}", "idx": 6951, "_split": "test", "_hash": "da810b8d47fbc3432455528b2dc07aad"}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,\n\n                                   size_t datalen)\n\n{\n\n    ssize_t ret = gnutls_read(*session, data, datalen);\n\n    if (ret < 0) {\n\n        if (ret == GNUTLS_E_AGAIN) {\n\n            errno = EAGAIN;\n\n        } else {\n\n            errno = EIO;\n\n        }\n\n        ret = -1;\n\n    }\n\n    return ret;\n\n}\n", "idx": 6953, "_split": "test", "_hash": "b534d75752cbbf210cb4248e1424c3b7"}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static void qpa_fini_out (HWVoiceOut *hw)\n\n{\n\n    void *ret;\n\n    PAVoiceOut *pa = (PAVoiceOut *) hw;\n\n\n\n    audio_pt_lock (&pa->pt, AUDIO_FUNC);\n\n    pa->done = 1;\n\n    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);\n\n    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);\n\n\n\n    if (pa->s) {\n\n        pa_simple_free (pa->s);\n\n        pa->s = NULL;\n\n    }\n\n\n\n    audio_pt_fini (&pa->pt, AUDIO_FUNC);\n\n    g_free (pa->pcm_buf);\n\n    pa->pcm_buf = NULL;\n\n}\n", "idx": 7004, "_split": "test", "_hash": "0c1f5445c27d9c3f46468f77990b80ce"}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static int scsi_device_init(SCSIDevice *s)\n\n{\n\n    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);\n\n    if (sc->init) {\n\n        return sc->init(s);\n\n    }\n\n    return 0;\n\n}\n", "idx": 7017, "_split": "test", "_hash": "5b37b3889346f9f2f2bae288962e4f0e"}
{"project": "qemu", "commit_id": "aaa0eb75e2e56d483c89731a447c999985713b43", "target": 0, "func": "static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,\n\n                             int nb_sectors, int dirty)\n\n{\n\n    int64_t start, end;\n\n    unsigned long val, idx, bit;\n\n\n\n    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;\n\n    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;\n\n\n\n    for (; start <= end; start++) {\n\n        idx = start / (sizeof(unsigned long) * 8);\n\n        bit = start % (sizeof(unsigned long) * 8);\n\n        val = bs->dirty_bitmap[idx];\n\n        if (dirty) {\n\n            val |= 1 << bit;\n\n        } else {\n\n            val &= ~(1 << bit);\n\n        }\n\n        bs->dirty_bitmap[idx] = val;\n\n    }\n\n}\n", "idx": 7019, "_split": "test", "_hash": "d2fdddea900060bc2fd2a78a5622a9dd"}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "static size_t net_tx_pkt_fetch_fragment(struct NetTxPkt *pkt,\n\n    int *src_idx, size_t *src_offset, struct iovec *dst, int *dst_idx)\n\n{\n\n    size_t fetched = 0;\n\n    struct iovec *src = pkt->vec;\n\n\n\n    *dst_idx = NET_TX_PKT_FRAGMENT_HEADER_NUM;\n\n\n\n    while (fetched < pkt->virt_hdr.gso_size) {\n\n\n\n        /* no more place in fragment iov */\n\n        if (*dst_idx == NET_MAX_FRAG_SG_LIST) {\n\n            break;\n\n        }\n\n\n\n        /* no more data in iovec */\n\n        if (*src_idx == (pkt->payload_frags + NET_TX_PKT_PL_START_FRAG)) {\n\n            break;\n\n        }\n\n\n\n\n\n        dst[*dst_idx].iov_base = src[*src_idx].iov_base + *src_offset;\n\n        dst[*dst_idx].iov_len = MIN(src[*src_idx].iov_len - *src_offset,\n\n            pkt->virt_hdr.gso_size - fetched);\n\n\n\n        *src_offset += dst[*dst_idx].iov_len;\n\n        fetched += dst[*dst_idx].iov_len;\n\n\n\n        if (*src_offset == src[*src_idx].iov_len) {\n\n            *src_offset = 0;\n\n            (*src_idx)++;\n\n        }\n\n\n\n        (*dst_idx)++;\n\n    }\n\n\n\n    return fetched;\n\n}\n", "idx": 7027, "_split": "test", "_hash": "7a12c5b37e1770547c087a80fe7127b3"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void lsi_ram_write(void *opaque, target_phys_addr_t addr,\n\n                          uint64_t val, unsigned size)\n\n{\n\n    LSIState *s = opaque;\n\n    uint32_t newval;\n\n    uint32_t mask;\n\n    int shift;\n\n\n\n    newval = s->script_ram[addr >> 2];\n\n    shift = (addr & 3) * 8;\n\n    mask = ((uint64_t)1 << (size * 8)) - 1;\n\n    newval &= ~(mask << shift);\n\n    newval |= val << shift;\n\n    s->script_ram[addr >> 2] = newval;\n\n}\n", "idx": 7033, "_split": "test", "_hash": "2744545e021303e0ee36e81f9aa20b67"}
{"project": "qemu", "commit_id": "6b33f3ae8b79726ef0812597b8a83c3e82d31514", "target": 0, "func": "static int img_commit(int argc, char **argv)\n\n{\n\n    int c, ret, flags;\n\n    const char *filename, *fmt, *cache, *base;\n\n    BlockBackend *blk;\n\n    BlockDriverState *bs, *base_bs;\n\n    bool progress = false, quiet = false, drop = false;\n\n    bool writethrough;\n\n    Error *local_err = NULL;\n\n    CommonBlockJobCBInfo cbi;\n\n    bool image_opts = false;\n\n    AioContext *aio_context;\n\n\n\n    fmt = NULL;\n\n    cache = BDRV_DEFAULT_CACHE;\n\n    base = NULL;\n\n    for(;;) {\n\n        static const struct option long_options[] = {\n\n            {\"help\", no_argument, 0, 'h'},\n\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n\n            {0, 0, 0, 0}\n\n        };\n\n        c = getopt_long(argc, argv, \"f:ht:b:dpq\",\n\n                        long_options, NULL);\n\n        if (c == -1) {\n\n            break;\n\n        }\n\n        switch(c) {\n\n        case '?':\n\n        case 'h':\n\n            help();\n\n            break;\n\n        case 'f':\n\n            fmt = optarg;\n\n            break;\n\n        case 't':\n\n            cache = optarg;\n\n            break;\n\n        case 'b':\n\n            base = optarg;\n\n            /* -b implies -d */\n\n            drop = true;\n\n            break;\n\n        case 'd':\n\n            drop = true;\n\n            break;\n\n        case 'p':\n\n            progress = true;\n\n            break;\n\n        case 'q':\n\n            quiet = true;\n\n            break;\n\n        case OPTION_OBJECT: {\n\n            QemuOpts *opts;\n\n            opts = qemu_opts_parse_noisily(&qemu_object_opts,\n\n                                           optarg, true);\n\n            if (!opts) {\n\n                return 1;\n\n            }\n\n        }   break;\n\n        case OPTION_IMAGE_OPTS:\n\n            image_opts = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Progress is not shown in Quiet mode */\n\n    if (quiet) {\n\n        progress = false;\n\n    }\n\n\n\n    if (optind != argc - 1) {\n\n        error_exit(\"Expecting one image file name\");\n\n    }\n\n    filename = argv[optind++];\n\n\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n\n                          user_creatable_add_opts_foreach,\n\n                          NULL, NULL)) {\n\n        return 1;\n\n    }\n\n\n\n    flags = BDRV_O_RDWR | BDRV_O_UNMAP;\n\n    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);\n\n    if (ret < 0) {\n\n        error_report(\"Invalid cache option: %s\", cache);\n\n        return 1;\n\n    }\n\n\n\n    blk = img_open(image_opts, filename, fmt, flags, writethrough, quiet);\n\n    if (!blk) {\n\n        return 1;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    qemu_progress_init(progress, 1.f);\n\n    qemu_progress_print(0.f, 100);\n\n\n\n    if (base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n        if (!base_bs) {\n\n            error_setg(&local_err, QERR_BASE_NOT_FOUND, base);\n\n            goto done;\n\n        }\n\n    } else {\n\n        /* This is different from QMP, which by default uses the deepest file in\n\n         * the backing chain (i.e., the very base); however, the traditional\n\n         * behavior of qemu-img commit is using the immediate backing file. */\n\n        base_bs = backing_bs(bs);\n\n        if (!base_bs) {\n\n            error_setg(&local_err, \"Image does not have a backing file\");\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    cbi = (CommonBlockJobCBInfo){\n\n        .errp = &local_err,\n\n        .bs   = bs,\n\n    };\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n    commit_active_start(\"commit\", bs, base_bs, BLOCK_JOB_DEFAULT, 0,\n\n                        BLOCKDEV_ON_ERROR_REPORT, common_block_job_cb, &cbi,\n\n                        &local_err, false);\n\n    aio_context_release(aio_context);\n\n    if (local_err) {\n\n        goto done;\n\n    }\n\n\n\n    /* When the block job completes, the BlockBackend reference will point to\n\n     * the old backing file. In order to avoid that the top image is already\n\n     * deleted, so we can still empty it afterwards, increment the reference\n\n     * counter here preemptively. */\n\n    if (!drop) {\n\n        bdrv_ref(bs);\n\n    }\n\n\n\n    run_block_job(bs->job, &local_err);\n\n    if (local_err) {\n\n        goto unref_backing;\n\n    }\n\n\n\n    if (!drop && bs->drv->bdrv_make_empty) {\n\n        ret = bs->drv->bdrv_make_empty(bs);\n\n        if (ret) {\n\n            error_setg_errno(&local_err, -ret, \"Could not empty %s\",\n\n                             filename);\n\n            goto unref_backing;\n\n        }\n\n    }\n\n\n\nunref_backing:\n\n    if (!drop) {\n\n        bdrv_unref(bs);\n\n    }\n\n\n\ndone:\n\n    qemu_progress_end();\n\n\n\n    blk_unref(blk);\n\n\n\n    if (local_err) {\n\n        error_report_err(local_err);\n\n        return 1;\n\n    }\n\n\n\n    qprintf(quiet, \"Image committed.\\n\");\n\n    return 0;\n\n}\n", "idx": 7069, "_split": "test", "_hash": "f6f610cb6c03a1c5e6c9c299149d4ba1"}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "unsigned long setup_arg_pages(void * mh, char ** argv, char ** env)\n\n{\n\n    unsigned long stack_base, error, size;\n\n    int i;\n\n    int * stack;\n\n    int argc, envc;\n\n\n\n    /* Create enough stack to hold everything.  If we don't use\n\n     * it for args, we'll use it for something else...\n\n     */\n\n    size = stack_size;\n\n\n\n    error = target_mmap(0,\n\n                        size + qemu_host_page_size,\n\n                        PROT_READ | PROT_WRITE,\n\n                        MAP_PRIVATE | MAP_ANONYMOUS,\n\n                        -1, 0);\n\n    if (error == -1)\n\n        qerror(\"stk mmap\");\n\n\n\n    /* we reserve one extra page at the top of the stack as guard */\n\n    target_mprotect(error + size, qemu_host_page_size, PROT_NONE);\n\n\n\n    stack_base = error + size;\n\n    stack = (void*)stack_base;\n\n/*\n\n *    | STRING AREA |\n\n *    +-------------+\n\n *    |      0      |\n\n*    +-------------+\n\n *    |  apple[n]   |\n\n *    +-------------+\n\n *           :\n\n *    +-------------+\n\n *    |  apple[0]   |\n\n *    +-------------+\n\n *    |      0      |\n\n *    +-------------+\n\n *    |    env[n]   |\n\n *    +-------------+\n\n *           :\n\n *           :\n\n *    +-------------+\n\n *    |    env[0]   |\n\n *    +-------------+\n\n *    |      0      |\n\n *    +-------------+\n\n *    | arg[argc-1] |\n\n *    +-------------+\n\n *           :\n\n *           :\n\n *    +-------------+\n\n *    |    arg[0]   |\n\n *    +-------------+\n\n *    |     argc    |\n\n *    +-------------+\n\n * sp->    |      mh     | address of where the a.out's file offset 0 is in memory\n\n *    +-------------+\n\n*/\n\n    /* Construct the stack Stack grows down */\n\n    stack--;\n\n\n\n    /* XXX: string should go up there */\n\n\n\n    *stack = 0;\n\n    stack--;\n\n\n\n    /* Push the absolute path of our executable */\n\n    DPRINTF(\"pushing apple %s (0x%x)\\n\", (char*)argv[0], (int)argv[0]);\n\n    stl(stack, (int) argv[0]);\n\n\n\n    stack--;\n\n\n\n    stl(stack, 0);\n\n    stack--;\n\n\n\n    /* Get envc */\n\n    for(envc = 0; env[envc]; envc++);\n\n\n\n    for(i = envc-1; i >= 0; i--)\n\n    {\n\n        DPRINTF(\"pushing env %s (0x%x)\\n\", (char*)env[i], (int)env[i]);\n\n        stl(stack, (int)env[i]);\n\n        stack--;\n\n\n\n        /* XXX: remove that when string will be on top of the stack */\n\n        page_set_flags((int)env[i], (int)(env[i]+strlen(env[i])), PROT_READ | PAGE_VALID);\n\n    }\n\n\n\n    /* Add on the stack the interp_prefix choosen if so */\n\n    if(interp_prefix[0])\n\n    {\n\n        char *dyld_root;\n\n        asprintf(&dyld_root, \"DYLD_ROOT_PATH=%s\", interp_prefix);\n\n        page_set_flags((int)dyld_root, (int)(dyld_root+strlen(interp_prefix)+1), PROT_READ | PAGE_VALID);\n\n\n\n        stl(stack, (int)dyld_root);\n\n        stack--;\n\n    }\n\n\n\n#ifdef DONT_USE_DYLD_SHARED_MAP\n\n    {\n\n        char *shared_map_mode;\n\n        asprintf(&shared_map_mode, \"DYLD_SHARED_REGION=avoid\");\n\n        page_set_flags((int)shared_map_mode, (int)(shared_map_mode+strlen(shared_map_mode)+1), PROT_READ | PAGE_VALID);\n\n\n\n        stl(stack, (int)shared_map_mode);\n\n        stack--;\n\n    }\n\n#endif\n\n\n\n#ifdef ACTIVATE_DYLD_TRACE\n\n    char * extra_env_static[] = {\"DYLD_DEBUG_TRACE=yes\",\n\n    \"DYLD_PREBIND_DEBUG=3\", \"DYLD_UNKNOW_TRACE=yes\",\n\n    \"DYLD_PRINT_INITIALIZERS=yes\",\n\n    \"DYLD_PRINT_SEGMENTS=yes\", \"DYLD_PRINT_REBASINGS=yes\", \"DYLD_PRINT_BINDINGS=yes\", \"DYLD_PRINT_INITIALIZERS=yes\", \"DYLD_PRINT_WARNINGS=yes\" };\n\n\n\n    char ** extra_env = malloc(sizeof(extra_env_static));\n\n    bcopy(extra_env_static, extra_env, sizeof(extra_env_static));\n\n    page_set_flags((int)extra_env, (int)((void*)extra_env+sizeof(extra_env_static)), PROT_READ | PAGE_VALID);\n\n\n\n    for(i = 0; i<9; i++)\n\n    {\n\n        DPRINTF(\"pushing (extra) env %s (0x%x)\\n\", (char*)extra_env[i], (int)extra_env[i]);\n\n        stl(stack, (int) extra_env[i]);\n\n        stack--;\n\n    }\n\n#endif\n\n\n\n    stl(stack, 0);\n\n    stack--;\n\n\n\n    /* Get argc */\n\n    for(argc = 0; argv[argc]; argc++);\n\n\n\n    for(i = argc-1; i >= 0; i--)\n\n    {\n\n        DPRINTF(\"pushing arg %s (0x%x)\\n\", (char*)argv[i], (int)argv[i]);\n\n        stl(stack, (int) argv[i]);\n\n        stack--;\n\n\n\n        /* XXX: remove that when string will be on top of the stack */\n\n        page_set_flags((int)argv[i], (int)(argv[i]+strlen(argv[i])), PROT_READ | PAGE_VALID);\n\n    }\n\n\n\n    DPRINTF(\"pushing argc %d \\n\", argc);\n\n    stl(stack, argc);\n\n    stack--;\n\n\n\n    DPRINTF(\"pushing mh 0x%x \\n\", (int)mh);\n\n    stl(stack, (int) mh);\n\n\n\n    /* Stack points on the mh */\n\n    return (unsigned long)stack;\n\n}\n", "idx": 7099, "_split": "test", "_hash": "7565e50dbe9a7fb29c55331983150a35"}
{"project": "qemu", "commit_id": "10a412dab3f54439ea3d60274eb41668f7d83bd2", "target": 0, "func": "int sd_do_command(SDState *sd, SDRequest *req,\n\n                  uint8_t *response) {\n\n    uint32_t last_status = sd->card_status;\n\n    sd_rsp_type_t rtype;\n\n    int rsplen;\n\n\n\n    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) {\n\n        return 0;\n\n    }\n\n\n\n    if (sd_req_crc_validate(req)) {\n\n        sd->card_status |= COM_CRC_ERROR;\n\n        rtype = sd_illegal;\n\n        goto send_response;\n\n    }\n\n\n\n    sd->card_status &= ~CARD_STATUS_B;\n\n    sd_set_status(sd);\n\n\n\n    if (last_status & CARD_IS_LOCKED) {\n\n        if (!cmd_valid_while_locked(sd, req)) {\n\n            sd->card_status |= ILLEGAL_COMMAND;\n\n            fprintf(stderr, \"SD: Card is locked\\n\");\n\n            rtype = sd_illegal;\n\n            goto send_response;\n\n        }\n\n    }\n\n\n\n    if (last_status & APP_CMD) {\n\n        rtype = sd_app_command(sd, *req);\n\n        sd->card_status &= ~APP_CMD;\n\n    } else\n\n        rtype = sd_normal_command(sd, *req);\n\n\n\n    if (rtype == sd_illegal) {\n\n        sd->card_status |= ILLEGAL_COMMAND;\n\n    }\n\n\n\n    sd->current_cmd = req->cmd;\n\n\n\nsend_response:\n\n    switch (rtype) {\n\n    case sd_r1:\n\n    case sd_r1b:\n\n        sd_response_r1_make(sd, response, last_status);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r2_i:\n\n        memcpy(response, sd->cid, sizeof(sd->cid));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r2_s:\n\n        memcpy(response, sd->csd, sizeof(sd->csd));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r3:\n\n        sd_response_r3_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r6:\n\n        sd_response_r6_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r7:\n\n        sd_response_r7_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r0:\n\n    case sd_illegal:\n\n    default:\n\n        rsplen = 0;\n\n        break;\n\n    }\n\n\n\n#ifdef DEBUG_SD\n\n    if (rsplen) {\n\n        int i;\n\n        DPRINTF(\"Response:\");\n\n        for (i = 0; i < rsplen; i++)\n\n            printf(\" %02x\", response[i]);\n\n        printf(\" state %d\\n\", sd->state);\n\n    } else {\n\n        DPRINTF(\"No response %d\\n\", sd->state);\n\n    }\n\n#endif\n\n\n\n    return rsplen;\n\n}\n", "idx": 7105, "_split": "test", "_hash": "b340a3e6ad2b1df238d14b1a8970c388"}
{"project": "qemu", "commit_id": "9646f4927faf68e8690588c2fd6dc9834c440b58", "target": 0, "func": "void cpu_x86_cpuid(CPUX86State *env, uint32_t index, uint32_t count,\n\n                   uint32_t *eax, uint32_t *ebx,\n\n                   uint32_t *ecx, uint32_t *edx)\n\n{\n\n    X86CPU *cpu = x86_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    uint32_t pkg_offset;\n\n\n\n    /* test if maximum index reached */\n\n    if (index & 0x80000000) {\n\n        if (index > env->cpuid_xlevel) {\n\n            if (env->cpuid_xlevel2 > 0) {\n\n                /* Handle the Centaur's CPUID instruction. */\n\n                if (index > env->cpuid_xlevel2) {\n\n                    index = env->cpuid_xlevel2;\n\n                } else if (index < 0xC0000000) {\n\n                    index = env->cpuid_xlevel;\n\n                }\n\n            } else {\n\n                /* Intel documentation states that invalid EAX input will\n\n                 * return the same information as EAX=cpuid_level\n\n                 * (Intel SDM Vol. 2A - Instruction Set Reference - CPUID)\n\n                 */\n\n                index =  env->cpuid_level;\n\n            }\n\n        }\n\n    } else {\n\n        if (index > env->cpuid_level)\n\n            index = env->cpuid_level;\n\n    }\n\n\n\n    switch(index) {\n\n    case 0:\n\n        *eax = env->cpuid_level;\n\n        *ebx = env->cpuid_vendor1;\n\n        *edx = env->cpuid_vendor2;\n\n        *ecx = env->cpuid_vendor3;\n\n        break;\n\n    case 1:\n\n        *eax = env->cpuid_version;\n\n        *ebx = (cpu->apic_id << 24) |\n\n               8 << 8; /* CLFLUSH size in quad words, Linux wants it. */\n\n        *ecx = env->features[FEAT_1_ECX];\n\n        if ((*ecx & CPUID_EXT_XSAVE) && (env->cr[4] & CR4_OSXSAVE_MASK)) {\n\n            *ecx |= CPUID_EXT_OSXSAVE;\n\n        }\n\n        *edx = env->features[FEAT_1_EDX];\n\n        if (cs->nr_cores * cs->nr_threads > 1) {\n\n            *ebx |= (cs->nr_cores * cs->nr_threads) << 16;\n\n            *edx |= CPUID_HT;\n\n        }\n\n        break;\n\n    case 2:\n\n        /* cache info: needed for Pentium Pro compatibility */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, 0, eax, ebx, ecx, edx);\n\n            break;\n\n        }\n\n        *eax = 1; /* Number of CPUID[EAX=2] calls required */\n\n        *ebx = 0;\n\n        if (!cpu->enable_l3_cache) {\n\n            *ecx = 0;\n\n        } else {\n\n            *ecx = L3_N_DESCRIPTOR;\n\n        }\n\n        *edx = (L1D_DESCRIPTOR << 16) | \\\n\n               (L1I_DESCRIPTOR <<  8) | \\\n\n               (L2_DESCRIPTOR);\n\n        break;\n\n    case 4:\n\n        /* cache info: needed for Core compatibility */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, count, eax, ebx, ecx, edx);\n\n            *eax &= ~0xFC000000;\n\n        } else {\n\n            *eax = 0;\n\n            switch (count) {\n\n            case 0: /* L1 dcache info */\n\n                *eax |= CPUID_4_TYPE_DCACHE | \\\n\n                        CPUID_4_LEVEL(1) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                *ebx = (L1D_LINE_SIZE - 1) | \\\n\n                       ((L1D_PARTITIONS - 1) << 12) | \\\n\n                       ((L1D_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L1D_SETS - 1;\n\n                *edx = CPUID_4_NO_INVD_SHARING;\n\n                break;\n\n            case 1: /* L1 icache info */\n\n                *eax |= CPUID_4_TYPE_ICACHE | \\\n\n                        CPUID_4_LEVEL(1) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                *ebx = (L1I_LINE_SIZE - 1) | \\\n\n                       ((L1I_PARTITIONS - 1) << 12) | \\\n\n                       ((L1I_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L1I_SETS - 1;\n\n                *edx = CPUID_4_NO_INVD_SHARING;\n\n                break;\n\n            case 2: /* L2 cache info */\n\n                *eax |= CPUID_4_TYPE_UNIFIED | \\\n\n                        CPUID_4_LEVEL(2) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                if (cs->nr_threads > 1) {\n\n                    *eax |= (cs->nr_threads - 1) << 14;\n\n                }\n\n                *ebx = (L2_LINE_SIZE - 1) | \\\n\n                       ((L2_PARTITIONS - 1) << 12) | \\\n\n                       ((L2_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L2_SETS - 1;\n\n                *edx = CPUID_4_NO_INVD_SHARING;\n\n                break;\n\n            case 3: /* L3 cache info */\n\n                if (!cpu->enable_l3_cache) {\n\n                    *eax = 0;\n\n                    *ebx = 0;\n\n                    *ecx = 0;\n\n                    *edx = 0;\n\n                    break;\n\n                }\n\n                *eax |= CPUID_4_TYPE_UNIFIED | \\\n\n                        CPUID_4_LEVEL(3) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                pkg_offset = apicid_pkg_offset(cs->nr_cores, cs->nr_threads);\n\n                *eax |= ((1 << pkg_offset) - 1) << 14;\n\n                *ebx = (L3_N_LINE_SIZE - 1) | \\\n\n                       ((L3_N_PARTITIONS - 1) << 12) | \\\n\n                       ((L3_N_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L3_N_SETS - 1;\n\n                *edx = CPUID_4_INCLUSIVE | CPUID_4_COMPLEX_IDX;\n\n                break;\n\n            default: /* end of info */\n\n                *eax = 0;\n\n                *ebx = 0;\n\n                *ecx = 0;\n\n                *edx = 0;\n\n                break;\n\n            }\n\n        }\n\n\n\n        /* QEMU gives out its own APIC IDs, never pass down bits 31..26.  */\n\n        if ((*eax & 31) && cs->nr_cores > 1) {\n\n            *eax |= (cs->nr_cores - 1) << 26;\n\n        }\n\n        break;\n\n    case 5:\n\n        /* mwait info: needed for Core compatibility */\n\n        *eax = 0; /* Smallest monitor-line size in bytes */\n\n        *ebx = 0; /* Largest monitor-line size in bytes */\n\n        *ecx = CPUID_MWAIT_EMX | CPUID_MWAIT_IBE;\n\n        *edx = 0;\n\n        break;\n\n    case 6:\n\n        /* Thermal and Power Leaf */\n\n        *eax = env->features[FEAT_6_EAX];\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    case 7:\n\n        /* Structured Extended Feature Flags Enumeration Leaf */\n\n        if (count == 0) {\n\n            *eax = 0; /* Maximum ECX value for sub-leaves */\n\n            *ebx = env->features[FEAT_7_0_EBX]; /* Feature flags */\n\n            *ecx = env->features[FEAT_7_0_ECX]; /* Feature flags */\n\n            if ((*ecx & CPUID_7_0_ECX_PKU) && env->cr[4] & CR4_PKE_MASK) {\n\n                *ecx |= CPUID_7_0_ECX_OSPKE;\n\n            }\n\n            *edx = 0; /* Reserved */\n\n        } else {\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx = 0;\n\n            *edx = 0;\n\n        }\n\n        break;\n\n    case 9:\n\n        /* Direct Cache Access Information Leaf */\n\n        *eax = 0; /* Bits 0-31 in DCA_CAP MSR */\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    case 0xA:\n\n        /* Architectural Performance Monitoring Leaf */\n\n        if (kvm_enabled() && cpu->enable_pmu) {\n\n            KVMState *s = cs->kvm_state;\n\n\n\n            *eax = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EAX);\n\n            *ebx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EBX);\n\n            *ecx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_ECX);\n\n            *edx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EDX);\n\n        } else {\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx = 0;\n\n            *edx = 0;\n\n        }\n\n        break;\n\n    case 0xB:\n\n        /* Extended Topology Enumeration Leaf */\n\n        if (!cpu->enable_cpuid_0xb) {\n\n                *eax = *ebx = *ecx = *edx = 0;\n\n                break;\n\n        }\n\n\n\n        *ecx = count & 0xff;\n\n        *edx = cpu->apic_id;\n\n\n\n        switch (count) {\n\n        case 0:\n\n            *eax = apicid_core_offset(cs->nr_cores, cs->nr_threads);\n\n            *ebx = cs->nr_threads;\n\n            *ecx |= CPUID_TOPOLOGY_LEVEL_SMT;\n\n            break;\n\n        case 1:\n\n            *eax = apicid_pkg_offset(cs->nr_cores, cs->nr_threads);\n\n            *ebx = cs->nr_cores * cs->nr_threads;\n\n            *ecx |= CPUID_TOPOLOGY_LEVEL_CORE;\n\n            break;\n\n        default:\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx |= CPUID_TOPOLOGY_LEVEL_INVALID;\n\n        }\n\n\n\n        assert(!(*eax & ~0x1f));\n\n        *ebx &= 0xffff; /* The count doesn't need to be reliable. */\n\n        break;\n\n    case 0xD: {\n\n        KVMState *s = cs->kvm_state;\n\n        uint64_t ena_mask;\n\n        int i;\n\n\n\n        /* Processor Extended State */\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {\n\n            break;\n\n        }\n\n        if (kvm_enabled()) {\n\n            ena_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);\n\n            ena_mask <<= 32;\n\n            ena_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);\n\n        } else {\n\n            ena_mask = -1;\n\n        }\n\n\n\n        if (count == 0) {\n\n            *ecx = 0x240;\n\n            for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {\n\n                const ExtSaveArea *esa = &x86_ext_save_areas[i];\n\n                if ((env->features[esa->feature] & esa->bits) == esa->bits\n\n                    && ((ena_mask >> i) & 1) != 0) {\n\n                    if (i < 32) {\n\n                        *eax |= 1u << i;\n\n                    } else {\n\n                        *edx |= 1u << (i - 32);\n\n                    }\n\n                    *ecx = MAX(*ecx, esa->offset + esa->size);\n\n                }\n\n            }\n\n            *eax |= ena_mask & (XSTATE_FP_MASK | XSTATE_SSE_MASK);\n\n            *ebx = *ecx;\n\n        } else if (count == 1) {\n\n            *eax = env->features[FEAT_XSAVE];\n\n        } else if (count < ARRAY_SIZE(x86_ext_save_areas)) {\n\n            const ExtSaveArea *esa = &x86_ext_save_areas[count];\n\n            if ((env->features[esa->feature] & esa->bits) == esa->bits\n\n                && ((ena_mask >> count) & 1) != 0) {\n\n                *eax = esa->size;\n\n                *ebx = esa->offset;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n    case 0x80000000:\n\n        *eax = env->cpuid_xlevel;\n\n        *ebx = env->cpuid_vendor1;\n\n        *edx = env->cpuid_vendor2;\n\n        *ecx = env->cpuid_vendor3;\n\n        break;\n\n    case 0x80000001:\n\n        *eax = env->cpuid_version;\n\n        *ebx = 0;\n\n        *ecx = env->features[FEAT_8000_0001_ECX];\n\n        *edx = env->features[FEAT_8000_0001_EDX];\n\n\n\n        /* The Linux kernel checks for the CMPLegacy bit and\n\n         * discards multiple thread information if it is set.\n\n         * So don't set it here for Intel to make Linux guests happy.\n\n         */\n\n        if (cs->nr_cores * cs->nr_threads > 1) {\n\n            if (env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1 ||\n\n                env->cpuid_vendor2 != CPUID_VENDOR_INTEL_2 ||\n\n                env->cpuid_vendor3 != CPUID_VENDOR_INTEL_3) {\n\n                *ecx |= 1 << 1;    /* CmpLegacy bit */\n\n            }\n\n        }\n\n        break;\n\n    case 0x80000002:\n\n    case 0x80000003:\n\n    case 0x80000004:\n\n        *eax = env->cpuid_model[(index - 0x80000002) * 4 + 0];\n\n        *ebx = env->cpuid_model[(index - 0x80000002) * 4 + 1];\n\n        *ecx = env->cpuid_model[(index - 0x80000002) * 4 + 2];\n\n        *edx = env->cpuid_model[(index - 0x80000002) * 4 + 3];\n\n        break;\n\n    case 0x80000005:\n\n        /* cache info (L1 cache) */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, 0, eax, ebx, ecx, edx);\n\n            break;\n\n        }\n\n        *eax = (L1_DTLB_2M_ASSOC << 24) | (L1_DTLB_2M_ENTRIES << 16) | \\\n\n               (L1_ITLB_2M_ASSOC <<  8) | (L1_ITLB_2M_ENTRIES);\n\n        *ebx = (L1_DTLB_4K_ASSOC << 24) | (L1_DTLB_4K_ENTRIES << 16) | \\\n\n               (L1_ITLB_4K_ASSOC <<  8) | (L1_ITLB_4K_ENTRIES);\n\n        *ecx = (L1D_SIZE_KB_AMD << 24) | (L1D_ASSOCIATIVITY_AMD << 16) | \\\n\n               (L1D_LINES_PER_TAG << 8) | (L1D_LINE_SIZE);\n\n        *edx = (L1I_SIZE_KB_AMD << 24) | (L1I_ASSOCIATIVITY_AMD << 16) | \\\n\n               (L1I_LINES_PER_TAG << 8) | (L1I_LINE_SIZE);\n\n        break;\n\n    case 0x80000006:\n\n        /* cache info (L2 cache) */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, 0, eax, ebx, ecx, edx);\n\n            break;\n\n        }\n\n        *eax = (AMD_ENC_ASSOC(L2_DTLB_2M_ASSOC) << 28) | \\\n\n               (L2_DTLB_2M_ENTRIES << 16) | \\\n\n               (AMD_ENC_ASSOC(L2_ITLB_2M_ASSOC) << 12) | \\\n\n               (L2_ITLB_2M_ENTRIES);\n\n        *ebx = (AMD_ENC_ASSOC(L2_DTLB_4K_ASSOC) << 28) | \\\n\n               (L2_DTLB_4K_ENTRIES << 16) | \\\n\n               (AMD_ENC_ASSOC(L2_ITLB_4K_ASSOC) << 12) | \\\n\n               (L2_ITLB_4K_ENTRIES);\n\n        *ecx = (L2_SIZE_KB_AMD << 16) | \\\n\n               (AMD_ENC_ASSOC(L2_ASSOCIATIVITY) << 12) | \\\n\n               (L2_LINES_PER_TAG << 8) | (L2_LINE_SIZE);\n\n        if (!cpu->enable_l3_cache) {\n\n            *edx = ((L3_SIZE_KB / 512) << 18) | \\\n\n                   (AMD_ENC_ASSOC(L3_ASSOCIATIVITY) << 12) | \\\n\n                   (L3_LINES_PER_TAG << 8) | (L3_LINE_SIZE);\n\n        } else {\n\n            *edx = ((L3_N_SIZE_KB_AMD / 512) << 18) | \\\n\n                   (AMD_ENC_ASSOC(L3_N_ASSOCIATIVITY) << 12) | \\\n\n                   (L3_N_LINES_PER_TAG << 8) | (L3_N_LINE_SIZE);\n\n        }\n\n        break;\n\n    case 0x80000007:\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = env->features[FEAT_8000_0007_EDX];\n\n        break;\n\n    case 0x80000008:\n\n        /* virtual & phys address size in low 2 bytes. */\n\n        if (env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM) {\n\n            /* 64 bit processor, 48 bits virtual, configurable\n\n             * physical bits.\n\n             */\n\n            *eax = 0x00003000 + cpu->phys_bits;\n\n        } else {\n\n            *eax = cpu->phys_bits;\n\n        }\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        if (cs->nr_cores * cs->nr_threads > 1) {\n\n            *ecx |= (cs->nr_cores * cs->nr_threads) - 1;\n\n        }\n\n        break;\n\n    case 0x8000000A:\n\n        if (env->features[FEAT_8000_0001_ECX] & CPUID_EXT3_SVM) {\n\n            *eax = 0x00000001; /* SVM Revision */\n\n            *ebx = 0x00000010; /* nr of ASIDs */\n\n            *ecx = 0;\n\n            *edx = env->features[FEAT_SVM]; /* optional features */\n\n        } else {\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx = 0;\n\n            *edx = 0;\n\n        }\n\n        break;\n\n    case 0xC0000000:\n\n        *eax = env->cpuid_xlevel2;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    case 0xC0000001:\n\n        /* Support for VIA CPU's CPUID instruction */\n\n        *eax = env->cpuid_version;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = env->features[FEAT_C000_0001_EDX];\n\n        break;\n\n    case 0xC0000002:\n\n    case 0xC0000003:\n\n    case 0xC0000004:\n\n        /* Reserved for the future, and now filled with zero */\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    default:\n\n        /* reserved values: zero */\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    }\n\n}\n", "idx": 7109, "_split": "test", "_hash": "bb1cc922c4fc04b03d7ac463f2716a6a"}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)\n\n{\n\n    switch (size) {\n\n    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;\n\n    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;\n\n    default: abort();\n\n    }\n\n}\n", "idx": 7119, "_split": "test", "_hash": "ad87b5147f05616d38ef4300aeaa7885"}
{"project": "qemu", "commit_id": "53628efbc8aa7a7ab5354d24b971f4d69452151d", "target": 1, "func": "int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *buf, int len)\n\n{\n\n    int offset = 0, counter = 10;\n\n    int res;\n\n\n\n    if (!s->chr_sync_read) {\n\n        return 0;\n\n    }\n\n    \n\n    if (s->replay && replay_mode == REPLAY_MODE_PLAY) {\n\n        return replay_char_read_all_load(buf);\n\n    }\n\n\n\n    while (offset < len) {\n\n        do {\n\n            res = s->chr_sync_read(s, buf + offset, len - offset);\n\n            if (res == -1 && errno == EAGAIN) {\n\n                g_usleep(100);\n\n            }\n\n        } while (res == -1 && errno == EAGAIN);\n\n\n\n        if (res == 0) {\n\n            break;\n\n        }\n\n\n\n        if (res < 0) {\n\n            if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n                replay_char_read_all_save_error(res);\n\n            }\n\n            return res;\n\n        }\n\n\n\n        offset += res;\n\n\n\n        if (!counter--) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_char_read_all_save_buf(buf, offset);\n\n    }\n\n    return offset;\n\n}\n", "idx": 7125, "_split": "test", "_hash": "4411d3c0f76818595031cd8de7ccf506"}
{"project": "qemu", "commit_id": "a890643958f03aaa344290700093b280cb606c28", "target": 1, "func": "static bool qht_insert__locked(struct qht *ht, struct qht_map *map,\n\n                               struct qht_bucket *head, void *p, uint32_t hash,\n\n                               bool *needs_resize)\n\n{\n\n    struct qht_bucket *b = head;\n\n    struct qht_bucket *prev = NULL;\n\n    struct qht_bucket *new = NULL;\n\n    int i;\n\n\n\n    do {\n\n        for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {\n\n            if (b->pointers[i]) {\n\n                if (unlikely(b->pointers[i] == p)) {\n\n                    return false;\n\n                }\n\n            } else {\n\n                goto found;\n\n            }\n\n        }\n\n        prev = b;\n\n        b = b->next;\n\n    } while (b);\n\n\n\n    b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b));\n\n    memset(b, 0, sizeof(*b));\n\n    new = b;\n\n    i = 0;\n\n    atomic_inc(&map->n_added_buckets);\n\n    if (unlikely(qht_map_needs_resize(map)) && needs_resize) {\n\n        *needs_resize = true;\n\n    }\n\n\n\n found:\n\n    /* found an empty key: acquire the seqlock and write */\n\n    seqlock_write_begin(&head->sequence);\n\n    if (new) {\n\n        atomic_rcu_set(&prev->next, b);\n\n    }\n\n    b->hashes[i] = hash;\n\n    /* smp_wmb() implicit in seqlock_write_begin.  */\n\n    atomic_set(&b->pointers[i], p);\n\n    seqlock_write_end(&head->sequence);\n\n    return true;\n\n}\n", "idx": 7191, "_split": "test", "_hash": "dcde7af214fcbc4a9afa194f9027c5fc"}
{"project": "qemu", "commit_id": "aa8f057e74ae08014736a690ff41f76c756f75f1", "target": 0, "func": "static void virtio_crypto_instance_init(Object *obj)\n\n{\n\n    VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);\n\n\n\n    /*\n\n     * The default config_size is sizeof(struct virtio_crypto_config).\n\n     * Can be overriden with virtio_crypto_set_config_size.\n\n     */\n\n    vcrypto->config_size = sizeof(struct virtio_crypto_config);\n\n\n\n    object_property_add_link(obj, \"cryptodev\",\n\n                             TYPE_CRYPTODEV_BACKEND,\n\n                             (Object **)&vcrypto->conf.cryptodev,\n\n                             virtio_crypto_check_cryptodev_is_used,\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);\n\n}\n", "idx": 7213, "_split": "test", "_hash": "eb7b92f7e6f8ac15ed5884a5ac9e935c"}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "int cpu_sh4_handle_mmu_fault(CPUState * env, target_ulong address, int rw,\n\n\t\t\t     int mmu_idx, int is_softmmu)\n\n{\n\n    target_ulong physical;\n\n    int prot, ret, access_type;\n\n\n\n    access_type = ACCESS_INT;\n\n    ret =\n\n\tget_physical_address(env, &physical, &prot, address, rw,\n\n\t\t\t     access_type);\n\n\n\n    if (ret != MMU_OK) {\n\n\tenv->tea = address;\n\n\tswitch (ret) {\n\n\tcase MMU_ITLB_MISS:\n\n\tcase MMU_DTLB_MISS_READ:\n\n\t    env->exception_index = 0x040;\n\n\t    break;\n\n\tcase MMU_DTLB_MULTIPLE:\n\n\tcase MMU_ITLB_MULTIPLE:\n\n\t    env->exception_index = 0x140;\n\n\t    break;\n\n\tcase MMU_ITLB_VIOLATION:\n\n\t    env->exception_index = 0x0a0;\n\n\t    break;\n\n\tcase MMU_DTLB_MISS_WRITE:\n\n\t    env->exception_index = 0x060;\n\n\t    break;\n\n\tcase MMU_DTLB_INITIAL_WRITE:\n\n\t    env->exception_index = 0x080;\n\n\t    break;\n\n\tcase MMU_DTLB_VIOLATION_READ:\n\n\t    env->exception_index = 0x0a0;\n\n\t    break;\n\n\tcase MMU_DTLB_VIOLATION_WRITE:\n\n\t    env->exception_index = 0x0c0;\n\n\t    break;\n\n\tcase MMU_IADDR_ERROR:\n\n\tcase MMU_DADDR_ERROR_READ:\n\n\t    env->exception_index = 0x0c0;\n\n\t    break;\n\n\tcase MMU_DADDR_ERROR_WRITE:\n\n\t    env->exception_index = 0x100;\n\n\t    break;\n\n\tdefault:\n\n\t    assert(0);\n\n\t}\n\n\treturn 1;\n\n    }\n\n\n\n    address &= TARGET_PAGE_MASK;\n\n    physical &= TARGET_PAGE_MASK;\n\n\n\n    return tlb_set_page(env, address, physical, prot, mmu_idx, is_softmmu);\n\n}\n", "idx": 7222, "_split": "test", "_hash": "37eb9814e2b92031e4030d16c5cfb7c5"}
{"project": "qemu", "commit_id": "40dfc16f5fe0afb66f9436718781264dfadb6c61", "target": 1, "func": "static int virtio_blk_device_exit(DeviceState *dev)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    VirtIOBlock *s = VIRTIO_BLK(dev);\n\n#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE\n\n    remove_migration_state_change_notifier(&s->migration_state_notifier);\n\n    virtio_blk_data_plane_destroy(s->dataplane);\n\n    s->dataplane = NULL;\n\n#endif\n\n    qemu_del_vm_change_state_handler(s->change);\n\n    unregister_savevm(dev, \"virtio-blk\", s);\n\n    blockdev_mark_auto_del(s->bs);\n\n    virtio_cleanup(vdev);\n\n    return 0;\n\n}\n", "idx": 7243, "_split": "test", "_hash": "3fed7c1e2512d2b2b9dbb2822343275d"}
{"project": "qemu", "commit_id": "0479097859372a760843ad1b9c6ed3705c6423ca", "target": 1, "func": "static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,\n\n                             void *opaque, Error **errp)\n\n{\n\n    uint64_t value;\n\n    MemoryRegion *mr;\n\n    PCDIMMDevice *dimm = PC_DIMM(obj);\n\n    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);\n\n\n\n    mr = ddc->get_memory_region(dimm);\n\n    value = memory_region_size(mr);\n\n\n\n    visit_type_uint64(v, name, &value, errp);\n\n}\n", "idx": 7267, "_split": "test", "_hash": "64d1af00a1867af884aadf856518457d"}
{"project": "qemu", "commit_id": "821303f59b63ab832f0921f070db55e95bb21858", "target": 1, "func": "target_ulong spapr_rtas_call(sPAPREnvironment *spapr,\n                             uint32_t token, uint32_t nargs, target_ulong args,\n                             uint32_t nret, target_ulong rets)\n{\n    if ((token >= TOKEN_BASE)\n        && ((token - TOKEN_BASE) < TOKEN_MAX)) {\n        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);\n        if (call->fn) {\n            call->fn(spapr, token, nargs, args, nret, rets);\n    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);\n    rtas_st(rets, 0, -3);\n    return H_PARAMETER;", "idx": 7269, "_split": "test", "_hash": "16c9da6227afc7467e9cc994e7f1a046"}
{"project": "qemu", "commit_id": "afa46c468acc18914c2773538f1b088c507766ee", "target": 0, "func": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *cmd)\n\n{\n\n    SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, req->dev);\n\n    SCSIGenericReq *r = DO_UPCAST(SCSIGenericReq, req, req);\n\n    int ret;\n\n\n\n    if (cmd[0] != REQUEST_SENSE && req->lun != s->qdev.lun) {\n\n        DPRINTF(\"Unimplemented LUN %d\\n\", req->lun);\n\n        scsi_req_build_sense(&r->req, SENSE_CODE(LUN_NOT_SUPPORTED));\n\n        scsi_req_complete(&r->req, CHECK_CONDITION);\n\n        return 0;\n\n    }\n\n\n\n    if (-1 == scsi_req_parse(&r->req, cmd)) {\n\n        BADF(\"Unsupported command length, command %x\\n\", cmd[0]);\n\n        scsi_command_complete(r, -EINVAL);\n\n        return 0;\n\n    }\n\n    scsi_req_fixup(&r->req);\n\n\n\n    DPRINTF(\"Command: lun=%d tag=0x%x len %zd data=0x%02x\", lun, tag,\n\n            r->req.cmd.xfer, cmd[0]);\n\n\n\n#ifdef DEBUG_SCSI\n\n    {\n\n        int i;\n\n        for (i = 1; i < r->req.cmd.len; i++) {\n\n            printf(\" 0x%02x\", cmd[i]);\n\n        }\n\n        printf(\"\\n\");\n\n    }\n\n#endif\n\n\n\n    if (r->req.cmd.xfer == 0) {\n\n        if (r->buf != NULL)\n\n            qemu_free(r->buf);\n\n        r->buflen = 0;\n\n        r->buf = NULL;\n\n        ret = execute_command(s->bs, r, SG_DXFER_NONE, scsi_command_complete);\n\n        if (ret < 0) {\n\n            scsi_command_complete(r, ret);\n\n            return 0;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (r->buflen != r->req.cmd.xfer) {\n\n        if (r->buf != NULL)\n\n            qemu_free(r->buf);\n\n        r->buf = qemu_malloc(r->req.cmd.xfer);\n\n        r->buflen = r->req.cmd.xfer;\n\n    }\n\n\n\n    memset(r->buf, 0, r->buflen);\n\n    r->len = r->req.cmd.xfer;\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n\n        r->len = 0;\n\n        return -r->req.cmd.xfer;\n\n    } else {\n\n        return r->req.cmd.xfer;\n\n    }\n\n}\n", "idx": 7315, "_split": "test", "_hash": "e9a5eacc1a6dea2f78fb53bc49b51a4c"}
{"project": "qemu", "commit_id": "fc6c9257c6dd47316a1c55d356bcd89bdc5fd642", "target": 0, "func": "void ip6_input(struct mbuf *m)\n\n{\n\n    struct ip6 *ip6;\n\n\n\n    DEBUG_CALL(\"ip6_input\");\n\n    DEBUG_ARG(\"m = %lx\", (long)m);\n\n    DEBUG_ARG(\"m_len = %d\", m->m_len);\n\n\n\n    if (m->m_len < sizeof(struct ip6)) {\n\n        goto bad;\n\n    }\n\n\n\n    ip6 = mtod(m, struct ip6 *);\n\n\n\n    if (ip6->ip_v != IP6VERSION) {\n\n        goto bad;\n\n    }\n\n\n\n    /* check ip_ttl for a correct ICMP reply */\n\n    if (ip6->ip_hl == 0) {\n\n        /*icmp_send_error(m, ICMP_TIMXCEED,ICMP_TIMXCEED_INTRANS, 0,\"ttl\");*/\n\n        goto bad;\n\n    }\n\n\n\n    /*\n\n     * Switch out to protocol's input routine.\n\n     */\n\n    switch (ip6->ip_nh) {\n\n    case IPPROTO_TCP:\n\n        /*tcp_input(m, hlen, (struct socket *)NULL);*/\n\n        break;\n\n    case IPPROTO_UDP:\n\n        /*udp_input(m, hlen);*/\n\n        break;\n\n    case IPPROTO_ICMPV6:\n\n        icmp6_input(m);\n\n        break;\n\n    default:\n\n        m_free(m);\n\n    }\n\n    return;\n\nbad:\n\n    m_free(m);\n\n}\n", "idx": 7324, "_split": "test", "_hash": "902cde6e40e9d446e7dec8b76e74029e"}
{"project": "qemu", "commit_id": "677ef6230b603571ae05125db469f7b4c8912a77", "target": 0, "func": "void fork_start(void)\n\n{\n\n    pthread_mutex_lock(&tcg_ctx.tb_ctx.tb_lock);\n\n    pthread_mutex_lock(&exclusive_lock);\n\n    mmap_fork_start();\n\n}\n", "idx": 7326, "_split": "test", "_hash": "15b579f404b705aed153c1455083ad83"}
{"project": "qemu", "commit_id": "2f859f80c2077e00237ea1dfae2523ebd8377f5f", "target": 0, "func": "static int write_dump_pages(DumpState *s)\n\n{\n\n    int ret = 0;\n\n    DataCache page_desc, page_data;\n\n    size_t len_buf_out, size_out;\n\n#ifdef CONFIG_LZO\n\n    lzo_bytep wrkmem = NULL;\n\n#endif\n\n    uint8_t *buf_out = NULL;\n\n    off_t offset_desc, offset_data;\n\n    PageDescriptor pd, pd_zero;\n\n    uint8_t *buf;\n\n    int endian = s->dump_info.d_endian;\n\n    GuestPhysBlock *block_iter = NULL;\n\n    uint64_t pfn_iter;\n\n\n\n    /* get offset of page_desc and page_data in dump file */\n\n    offset_desc = s->offset_page;\n\n    offset_data = offset_desc + sizeof(PageDescriptor) * s->num_dumpable;\n\n\n\n    prepare_data_cache(&page_desc, s, offset_desc);\n\n    prepare_data_cache(&page_data, s, offset_data);\n\n\n\n    /* prepare buffer to store compressed data */\n\n    len_buf_out = get_len_buf_out(s->page_size, s->flag_compress);\n\n    if (len_buf_out == 0) {\n\n        dump_error(s, \"dump: failed to get length of output buffer.\\n\");\n\n        goto out;\n\n    }\n\n\n\n#ifdef CONFIG_LZO\n\n    wrkmem = g_malloc(LZO1X_1_MEM_COMPRESS);\n\n#endif\n\n\n\n    buf_out = g_malloc(len_buf_out);\n\n\n\n    /*\n\n     * init zero page's page_desc and page_data, because every zero page\n\n     * uses the same page_data\n\n     */\n\n    pd_zero.size = cpu_convert_to_target32(s->page_size, endian);\n\n    pd_zero.flags = cpu_convert_to_target32(0, endian);\n\n    pd_zero.offset = cpu_convert_to_target64(offset_data, endian);\n\n    pd_zero.page_flags = cpu_convert_to_target64(0, endian);\n\n    buf = g_malloc0(s->page_size);\n\n    ret = write_cache(&page_data, buf, s->page_size, false);\n\n    g_free(buf);\n\n    if (ret < 0) {\n\n        dump_error(s, \"dump: failed to write page data(zero page).\\n\");\n\n        goto out;\n\n    }\n\n\n\n    offset_data += s->page_size;\n\n\n\n    /*\n\n     * dump memory to vmcore page by page. zero page will all be resided in the\n\n     * first page of page section\n\n     */\n\n    while (get_next_page(&block_iter, &pfn_iter, &buf, s)) {\n\n        /* check zero page */\n\n        if (is_zero_page(buf, s->page_size)) {\n\n            ret = write_cache(&page_desc, &pd_zero, sizeof(PageDescriptor),\n\n                              false);\n\n            if (ret < 0) {\n\n                dump_error(s, \"dump: failed to write page desc.\\n\");\n\n                goto out;\n\n            }\n\n        } else {\n\n            /*\n\n             * not zero page, then:\n\n             * 1. compress the page\n\n             * 2. write the compressed page into the cache of page_data\n\n             * 3. get page desc of the compressed page and write it into the\n\n             *    cache of page_desc\n\n             *\n\n             * only one compression format will be used here, for\n\n             * s->flag_compress is set. But when compression fails to work,\n\n             * we fall back to save in plaintext.\n\n             */\n\n             size_out = len_buf_out;\n\n             if ((s->flag_compress & DUMP_DH_COMPRESSED_ZLIB) &&\n\n                    (compress2(buf_out, (uLongf *)&size_out, buf, s->page_size,\n\n                    Z_BEST_SPEED) == Z_OK) && (size_out < s->page_size)) {\n\n                pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_ZLIB,\n\n                                                   endian);\n\n                pd.size  = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf_out, size_out, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n#ifdef CONFIG_LZO\n\n            } else if ((s->flag_compress & DUMP_DH_COMPRESSED_LZO) &&\n\n                    (lzo1x_1_compress(buf, s->page_size, buf_out,\n\n                    (lzo_uint *)&size_out, wrkmem) == LZO_E_OK) &&\n\n                    (size_out < s->page_size)) {\n\n                pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_LZO,\n\n                                                   endian);\n\n                pd.size  = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf_out, size_out, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n#endif\n\n#ifdef CONFIG_SNAPPY\n\n            } else if ((s->flag_compress & DUMP_DH_COMPRESSED_SNAPPY) &&\n\n                    (snappy_compress((char *)buf, s->page_size,\n\n                    (char *)buf_out, &size_out) == SNAPPY_OK) &&\n\n                    (size_out < s->page_size)) {\n\n                pd.flags = cpu_convert_to_target32(\n\n                                        DUMP_DH_COMPRESSED_SNAPPY, endian);\n\n                pd.size  = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf_out, size_out, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n#endif\n\n            } else {\n\n                /*\n\n                 * fall back to save in plaintext, size_out should be\n\n                 * assigned to s->page_size\n\n                 */\n\n                pd.flags = cpu_convert_to_target32(0, endian);\n\n                size_out = s->page_size;\n\n                pd.size = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf, s->page_size, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n            }\n\n\n\n            /* get and write page desc here */\n\n            pd.page_flags = cpu_convert_to_target64(0, endian);\n\n            pd.offset = cpu_convert_to_target64(offset_data, endian);\n\n            offset_data += size_out;\n\n\n\n            ret = write_cache(&page_desc, &pd, sizeof(PageDescriptor), false);\n\n            if (ret < 0) {\n\n                dump_error(s, \"dump: failed to write page desc.\\n\");\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\n    ret = write_cache(&page_desc, NULL, 0, true);\n\n    if (ret < 0) {\n\n        dump_error(s, \"dump: failed to sync cache for page_desc.\\n\");\n\n        goto out;\n\n    }\n\n    ret = write_cache(&page_data, NULL, 0, true);\n\n    if (ret < 0) {\n\n        dump_error(s, \"dump: failed to sync cache for page_data.\\n\");\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    free_data_cache(&page_desc);\n\n    free_data_cache(&page_data);\n\n\n\n#ifdef CONFIG_LZO\n\n    g_free(wrkmem);\n\n#endif\n\n\n\n    g_free(buf_out);\n\n\n\n    return ret;\n\n}\n", "idx": 7327, "_split": "test", "_hash": "35703c844030a918336dd81240e5225c"}
{"project": "qemu", "commit_id": "d516f74c99b1a2c289cfba0bacf125cbc9b681e3", "target": 0, "func": "static void do_ext_interrupt(CPUS390XState *env)\n\n{\n\n    S390CPU *cpu = s390_env_get_cpu(env);\n\n    uint64_t mask, addr;\n\n    LowCore *lowcore;\n\n    ExtQueue *q;\n\n\n\n    if (!(env->psw.mask & PSW_MASK_EXT)) {\n\n        cpu_abort(CPU(cpu), \"Ext int w/o ext mask\\n\");\n\n    }\n\n\n\n    lowcore = cpu_map_lowcore(env);\n\n\n\n    if (env->pending_int & INTERRUPT_EXT_CLOCK_COMPARATOR) {\n\n        lowcore->ext_int_code = cpu_to_be16(EXT_CLOCK_COMP);\n\n        lowcore->cpu_addr = 0;\n\n        env->pending_int &= ~INTERRUPT_EXT_CLOCK_COMPARATOR;\n\n    } else if (env->pending_int & INTERRUPT_EXT_CPU_TIMER) {\n\n        lowcore->ext_int_code = cpu_to_be16(EXT_CPU_TIMER);\n\n        lowcore->cpu_addr = 0;\n\n        env->pending_int &= ~INTERRUPT_EXT_CPU_TIMER;\n\n    } else if (env->pending_int & INTERRUPT_EXT_SERVICE) {\n\n        g_assert(env->ext_index >= 0);\n\n        /*\n\n         * FIXME: floating IRQs should be considered by all CPUs and\n\n         *        shuld not get cleared by CPU reset.\n\n         */\n\n        q = &env->ext_queue[env->ext_index];\n\n        lowcore->ext_int_code = cpu_to_be16(q->code);\n\n        lowcore->ext_params = cpu_to_be32(q->param);\n\n        lowcore->ext_params2 = cpu_to_be64(q->param64);\n\n        lowcore->cpu_addr = cpu_to_be16(env->core_id | VIRTIO_SUBCODE_64);\n\n        env->ext_index--;\n\n        if (env->ext_index == -1) {\n\n            env->pending_int &= ~INTERRUPT_EXT_SERVICE;\n\n        }\n\n    } else {\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    mask = be64_to_cpu(lowcore->external_new_psw.mask);\n\n    addr = be64_to_cpu(lowcore->external_new_psw.addr);\n\n    lowcore->external_old_psw.mask = cpu_to_be64(get_psw_mask(env));\n\n    lowcore->external_old_psw.addr = cpu_to_be64(env->psw.addr);\n\n\n\n    cpu_unmap_lowcore(lowcore);\n\n\n\n    DPRINTF(\"%s: %\" PRIx64 \" %\" PRIx64 \"\\n\", __func__,\n\n            env->psw.mask, env->psw.addr);\n\n\n\n    load_psw(env, mask, addr);\n\n}\n", "idx": 7332, "_split": "test", "_hash": "7ef697ce3505ddc2f79cf79961ccbfe7"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void verdex_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    PXA2xxState *cpu;\n\n    DriveInfo *dinfo;\n\n    int be;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n\n\n    uint32_t verdex_rom = 0x02000000;\n\n    uint32_t verdex_ram = 0x10000000;\n\n\n\n    cpu = pxa270_init(address_space_mem, verdex_ram, cpu_model ?: \"pxa270-c0\");\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    if (!dinfo && !qtest_enabled()) {\n\n        fprintf(stderr, \"A flash image must be given with the \"\n\n                \"'pflash' parameter\\n\");\n\n        exit(1);\n\n    }\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    if (!pflash_cfi01_register(0x00000000, NULL, \"verdex.rom\", verdex_rom,\n\n                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                               sector_len, verdex_rom / sector_len,\n\n                               2, 0, 0, 0, 0, be)) {\n\n        fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Interrupt line of NIC is connected to GPIO line 99 */\n\n    smc91c111_init(&nd_table[0], 0x04000300,\n\n                    qdev_get_gpio_in(cpu->gpio, 99));\n\n}\n", "idx": 7334, "_split": "test", "_hash": "592904054a0dbbbb3785dc8712495768"}
{"project": "qemu", "commit_id": "e3737b820b45e54b059656dc3f914f895ac7a88b", "target": 1, "func": "static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVBochsState *s = bs->opaque;\n    uint32_t i;\n    struct bochs_header bochs;\n    int ret;\n    bs->read_only = 1; // no write support yet\n    ret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));\n    if (ret < 0) {\n        return ret;\n    if (strcmp(bochs.magic, HEADER_MAGIC) ||\n        strcmp(bochs.type, REDOLOG_TYPE) ||\n        strcmp(bochs.subtype, GROWING_TYPE) ||\n\t((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n\t(le32_to_cpu(bochs.version) != HEADER_V1))) {\n        error_setg(errp, \"Image not in Bochs format\");\n        return -EINVAL;\n    if (le32_to_cpu(bochs.version) == HEADER_V1) {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512;\n    } else {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;\n    s->catalog_size = le32_to_cpu(bochs.catalog);\n    s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n    ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\n                     s->catalog_size * 4);\n    if (ret < 0) {\n        goto fail;\n    for (i = 0; i < s->catalog_size; i++)\n\tle32_to_cpus(&s->catalog_bitmap[i]);\n    s->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);\n    s->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512;\n    s->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;\n    s->extent_size = le32_to_cpu(bochs.extent);\n    if (s->catalog_size < bs->total_sectors / s->extent_size) {\n        error_setg(errp, \"Catalog size is too small for this disk size\");\n        ret = -EINVAL;\n        goto fail;\n    qemu_co_mutex_init(&s->lock);\n    return 0;\nfail:\n    g_free(s->catalog_bitmap);\n    return ret;", "idx": 7347, "_split": "test", "_hash": "70654bf24e6e883bfc89c65c4eb998c8"}
{"project": "qemu", "commit_id": "18b21a2f83a26c3d6a9e7f0bdc4e8eb2b177e8f6", "target": 0, "func": "void ppc_translate_init(void)\n\n{\n\n    int i;\n\n    char* p;\n\n    size_t cpu_reg_names_size;\n\n    static int done_init = 0;\n\n\n\n    if (done_init)\n\n        return;\n\n\n\n    cpu_env = tcg_global_reg_new_ptr(TCG_AREG0, \"env\");\n\n\n\n    p = cpu_reg_names;\n\n    cpu_reg_names_size = sizeof(cpu_reg_names);\n\n\n\n    for (i = 0; i < 8; i++) {\n\n        snprintf(p, cpu_reg_names_size, \"crf%d\", i);\n\n        cpu_crf[i] = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                            offsetof(CPUState, crf[i]), p);\n\n        p += 5;\n\n        cpu_reg_names_size -= 5;\n\n    }\n\n\n\n    for (i = 0; i < 32; i++) {\n\n        snprintf(p, cpu_reg_names_size, \"r%d\", i);\n\n        cpu_gpr[i] = tcg_global_mem_new(TCG_AREG0,\n\n                                        offsetof(CPUState, gpr[i]), p);\n\n        p += (i < 10) ? 3 : 4;\n\n        cpu_reg_names_size -= (i < 10) ? 3 : 4;\n\n#if !defined(TARGET_PPC64)\n\n        snprintf(p, cpu_reg_names_size, \"r%dH\", i);\n\n        cpu_gprh[i] = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                             offsetof(CPUState, gprh[i]), p);\n\n        p += (i < 10) ? 4 : 5;\n\n        cpu_reg_names_size -= (i < 10) ? 4 : 5;\n\n#endif\n\n\n\n        snprintf(p, cpu_reg_names_size, \"fp%d\", i);\n\n        cpu_fpr[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                            offsetof(CPUState, fpr[i]), p);\n\n        p += (i < 10) ? 4 : 5;\n\n        cpu_reg_names_size -= (i < 10) ? 4 : 5;\n\n\n\n        snprintf(p, cpu_reg_names_size, \"avr%dH\", i);\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n        cpu_avrh[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[0]), p);\n\n#else\n\n        cpu_avrh[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[1]), p);\n\n#endif\n\n        p += (i < 10) ? 6 : 7;\n\n        cpu_reg_names_size -= (i < 10) ? 6 : 7;\n\n\n\n        snprintf(p, cpu_reg_names_size, \"avr%dL\", i);\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n        cpu_avrl[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[1]), p);\n\n#else\n\n        cpu_avrl[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[0]), p);\n\n#endif\n\n        p += (i < 10) ? 6 : 7;\n\n        cpu_reg_names_size -= (i < 10) ? 6 : 7;\n\n    }\n\n\n\n    cpu_nip = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, nip), \"nip\");\n\n\n\n    cpu_msr = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, msr), \"msr\");\n\n\n\n    cpu_ctr = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, ctr), \"ctr\");\n\n\n\n    cpu_lr = tcg_global_mem_new(TCG_AREG0,\n\n                                offsetof(CPUState, lr), \"lr\");\n\n\n\n    cpu_xer = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, xer), \"xer\");\n\n\n\n    cpu_reserve = tcg_global_mem_new(TCG_AREG0,\n\n                                     offsetof(CPUState, reserve), \"reserve\");\n\n\n\n    cpu_fpscr = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                       offsetof(CPUState, fpscr), \"fpscr\");\n\n\n\n    cpu_access_type = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                             offsetof(CPUState, access_type), \"access_type\");\n\n\n\n    /* register helpers */\n\n#define GEN_HELPER 2\n\n#include \"helper.h\"\n\n\n\n    done_init = 1;\n\n}\n", "idx": 7360, "_split": "test", "_hash": "ac9a1951de586e4b3b71e426cd3f12ff"}
{"project": "qemu", "commit_id": "7d08d85645def18eac2a9d672c1868a35e0bcf79", "target": 0, "func": "static void gen_mtfsfi(DisasContext *ctx)\n\n{\n\n    int bf, sh;\n\n    TCGv_i64 t0;\n\n    TCGv_i32 t1;\n\n\n\n    if (unlikely(!ctx->fpu_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_FPU);\n\n        return;\n\n    }\n\n    bf = crbD(ctx->opcode) >> 2;\n\n    sh = 7 - bf;\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    gen_reset_fpstatus();\n\n    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));\n\n    t1 = tcg_const_i32(1 << sh);\n\n    gen_helper_store_fpscr(cpu_env, t0, t1);\n\n    tcg_temp_free_i64(t0);\n\n    tcg_temp_free_i32(t1);\n\n    if (unlikely(Rc(ctx->opcode) != 0)) {\n\n        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);\n\n        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);\n\n    }\n\n    /* We can raise a differed exception */\n\n    gen_helper_float_check_status(cpu_env);\n\n}\n", "idx": 7380, "_split": "test", "_hash": "a5e6c26fd8aa34000e9a9307bfcc9515"}
{"project": "qemu", "commit_id": "1e356fc14beaa3ece6c0e961bd479af58be3198b", "target": 1, "func": "void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp)\n\n{\n\n    int i;\n\n    size_t pagesize = getpagesize();\n\n\n\n    memory = (memory + pagesize - 1) & -pagesize;\n\n    for (i = 0; i < memory / pagesize; i++) {\n\n        memset(area + pagesize * i, 0, 1);\n\n    }\n\n}\n", "idx": 7393, "_split": "test", "_hash": "f3ac936b011ce402e22bbbb4ac314388"}
{"project": "qemu", "commit_id": "30ca440eec9fe1d7eec5a48addac656438778278", "target": 0, "func": "static void hotplug(void)\n\n{\n\n    qtest_start(\"-device virtio-net-pci\");\n\n\n\n    qpci_plug_device_test(\"virtio-net-pci\", \"net1\", PCI_SLOT_HP, NULL);\n\n    qpci_unplug_acpi_device_test(\"net1\", PCI_SLOT_HP);\n\n\n\n    test_end();\n\n}\n", "idx": 7420, "_split": "test", "_hash": "cce68ba7347b4d20b21bbf561f14eb75"}
{"project": "qemu", "commit_id": "3a51dee658b9cc781acd57dd11bffbd1e402f93d", "target": 0, "func": "static void ide_identify(IDEState *s)\n\n{\n\n    uint16_t *p;\n\n    unsigned int oldsize;\n\n\n\n    memset(s->io_buffer, 0, 512);\n\n    p = (uint16_t *)s->io_buffer;\n\n    stw(p + 0, 0x0040);\n\n    stw(p + 1, s->cylinders); \n\n    stw(p + 3, s->heads);\n\n    stw(p + 4, 512 * s->sectors); /* sectors */\n\n    stw(p + 5, 512); /* sector size */\n\n    stw(p + 6, s->sectors); \n\n    stw(p + 20, 3); /* buffer type */\n\n    stw(p + 21, 512); /* cache size in sectors */\n\n    stw(p + 22, 4); /* ecc bytes */\n\n    padstr((uint8_t *)(p + 27), \"QEMU HARDDISK\", 40);\n\n#if MAX_MULT_SECTORS > 1    \n\n    stw(p + 47, MAX_MULT_SECTORS);\n\n#endif\n\n    stw(p + 48, 1); /* dword I/O */\n\n    stw(p + 49, 1 << 9); /* LBA supported, no DMA */\n\n    stw(p + 51, 0x200); /* PIO transfer cycle */\n\n    stw(p + 52, 0x200); /* DMA transfer cycle */\n\n    stw(p + 54, s->cylinders);\n\n    stw(p + 55, s->heads);\n\n    stw(p + 56, s->sectors);\n\n    oldsize = s->cylinders * s->heads * s->sectors;\n\n    stw(p + 57, oldsize);\n\n    stw(p + 58, oldsize >> 16);\n\n    if (s->mult_sectors)\n\n        stw(p + 59, 0x100 | s->mult_sectors);\n\n    stw(p + 60, s->nb_sectors);\n\n    stw(p + 61, s->nb_sectors >> 16);\n\n    stw(p + 80, (1 << 1) | (1 << 2));\n\n    stw(p + 82, (1 << 14));\n\n    stw(p + 83, (1 << 14));\n\n    stw(p + 84, (1 << 14));\n\n    stw(p + 85, (1 << 14));\n\n    stw(p + 86, 0);\n\n    stw(p + 87, (1 << 14));\n\n}\n", "idx": 7430, "_split": "test", "_hash": "64e3ff843526a97311d6ccaa48c04162"}
{"project": "qemu", "commit_id": "d62b5dea30284eacd88055bb08db7c295655945f", "target": 0, "func": "BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,\n\n                                 QEMUIOVector *qiov, int nb_sectors,\n\n                                 BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    BlockDriverAIOCB *ret;\n\n\n\n    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);\n\n\n\n    if (!drv)\n\n        return NULL;\n\n    if (bdrv_check_request(bs, sector_num, nb_sectors))\n\n        return NULL;\n\n\n\n    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,\n\n                              cb, opaque);\n\n\n\n    if (ret) {\n\n\t/* Update stats even though technically transfer has not happened. */\n\n\tbs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;\n\n\tbs->rd_ops ++;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 7449, "_split": "test", "_hash": "d48a5be54c3492daaed59725850e8b70"}
{"project": "qemu", "commit_id": "56b4a42a2e0ae74cee629abcb82993e79deeb356", "target": 0, "func": "static void migrate_set_downtime(QTestState *who, const char *value)\n\n{\n\n    QDict *rsp;\n\n    gchar *cmd;\n\n\n\n    cmd = g_strdup_printf(\"{ 'execute': 'migrate_set_downtime',\"\n\n                          \"'arguments': { 'value': %s } }\", value);\n\n    rsp = qtest_qmp(who, cmd);\n\n    g_free(cmd);\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n}\n", "idx": 7458, "_split": "test", "_hash": "027a23499e945cf3d6c6987d5b9f8a3e"}
{"project": "qemu", "commit_id": "90e26f5aacd265257f7de58ee59f72dc36dff40e", "target": 0, "func": "target_ulong do_arm_semihosting(CPUARMState *env)\n\n{\n\n    ARMCPU *cpu = arm_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    target_ulong args;\n\n    target_ulong arg0, arg1, arg2, arg3;\n\n    char * s;\n\n    int nr;\n\n    uint32_t ret;\n\n    uint32_t len;\n\n#ifdef CONFIG_USER_ONLY\n\n    TaskState *ts = cs->opaque;\n\n#else\n\n    CPUARMState *ts = env;\n\n#endif\n\n\n\n    if (is_a64(env)) {\n\n        /* Note that the syscall number is in W0, not X0 */\n\n        nr = env->xregs[0] & 0xffffffffU;\n\n        args = env->xregs[1];\n\n    } else {\n\n        nr = env->regs[0];\n\n        args = env->regs[1];\n\n    }\n\n\n\n    switch (nr) {\n\n    case TARGET_SYS_OPEN:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        s = lock_user_string(arg0);\n\n        if (!s) {\n\n            /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n            return (uint32_t)-1;\n\n        }\n\n        if (arg1 >= 12) {\n\n            unlock_user(s, arg0, 0);\n\n            return (uint32_t)-1;\n\n        }\n\n        if (strcmp(s, \":tt\") == 0) {\n\n            int result_fileno = arg1 < 4 ? STDIN_FILENO : STDOUT_FILENO;\n\n            unlock_user(s, arg0, 0);\n\n            return result_fileno;\n\n        }\n\n        if (use_gdb_syscalls()) {\n\n            ret = arm_gdb_syscall(cpu, arm_semi_cb, \"open,%s,%x,1a4\", arg0,\n\n                                  (int)arg2+1, gdb_open_modeflags[arg1]);\n\n        } else {\n\n            ret = set_swi_errno(ts, open(s, open_modeflags[arg1], 0644));\n\n        }\n\n        unlock_user(s, arg0, 0);\n\n        return ret;\n\n    case TARGET_SYS_CLOSE:\n\n        GET_ARG(0);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"close,%x\", arg0);\n\n        } else {\n\n            return set_swi_errno(ts, close(arg0));\n\n        }\n\n    case TARGET_SYS_WRITEC:\n\n        {\n\n          char c;\n\n\n\n          if (get_user_u8(c, args))\n\n              /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n              return (uint32_t)-1;\n\n          /* Write to debug console.  stderr is near enough.  */\n\n          if (use_gdb_syscalls()) {\n\n                return arm_gdb_syscall(cpu, arm_semi_cb, \"write,2,%x,1\", args);\n\n          } else {\n\n                return write(STDERR_FILENO, &c, 1);\n\n          }\n\n        }\n\n    case TARGET_SYS_WRITE0:\n\n        if (!(s = lock_user_string(args)))\n\n            /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n            return (uint32_t)-1;\n\n        len = strlen(s);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"write,2,%x,%x\",\n\n                                   args, len);\n\n        } else {\n\n            ret = write(STDERR_FILENO, s, len);\n\n        }\n\n        unlock_user(s, args, 0);\n\n        return ret;\n\n    case TARGET_SYS_WRITE:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        len = arg2;\n\n        if (use_gdb_syscalls()) {\n\n            arm_semi_syscall_len = len;\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"write,%x,%x,%x\",\n\n                                   arg0, arg1, len);\n\n        } else {\n\n            s = lock_user(VERIFY_READ, arg1, len, 1);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            ret = set_swi_errno(ts, write(arg0, s, len));\n\n            unlock_user(s, arg1, 0);\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return len - ret;\n\n        }\n\n    case TARGET_SYS_READ:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        len = arg2;\n\n        if (use_gdb_syscalls()) {\n\n            arm_semi_syscall_len = len;\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"read,%x,%x,%x\",\n\n                                   arg0, arg1, len);\n\n        } else {\n\n            s = lock_user(VERIFY_WRITE, arg1, len, 0);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            do {\n\n                ret = set_swi_errno(ts, read(arg0, s, len));\n\n            } while (ret == -1 && errno == EINTR);\n\n            unlock_user(s, arg1, len);\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return len - ret;\n\n        }\n\n    case TARGET_SYS_READC:\n\n       /* XXX: Read from debug console. Not implemented.  */\n\n        return 0;\n\n    case TARGET_SYS_ISTTY:\n\n        GET_ARG(0);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"isatty,%x\", arg0);\n\n        } else {\n\n            return isatty(arg0);\n\n        }\n\n    case TARGET_SYS_SEEK:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"lseek,%x,%x,0\",\n\n                                   arg0, arg1);\n\n        } else {\n\n            ret = set_swi_errno(ts, lseek(arg0, arg1, SEEK_SET));\n\n            if (ret == (uint32_t)-1)\n\n              return -1;\n\n            return 0;\n\n        }\n\n    case TARGET_SYS_FLEN:\n\n        GET_ARG(0);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_flen_cb, \"fstat,%x,%x\",\n\n                                   arg0, arm_flen_buf(cpu));\n\n        } else {\n\n            struct stat buf;\n\n            ret = set_swi_errno(ts, fstat(arg0, &buf));\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return buf.st_size;\n\n        }\n\n    case TARGET_SYS_TMPNAM:\n\n        /* XXX: Not implemented.  */\n\n        return -1;\n\n    case TARGET_SYS_REMOVE:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        if (use_gdb_syscalls()) {\n\n            ret = arm_gdb_syscall(cpu, arm_semi_cb, \"unlink,%s\",\n\n                                  arg0, (int)arg1+1);\n\n        } else {\n\n            s = lock_user_string(arg0);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            ret =  set_swi_errno(ts, remove(s));\n\n            unlock_user(s, arg0, 0);\n\n        }\n\n        return ret;\n\n    case TARGET_SYS_RENAME:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        GET_ARG(3);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"rename,%s,%s\",\n\n                                   arg0, (int)arg1+1, arg2, (int)arg3+1);\n\n        } else {\n\n            char *s2;\n\n            s = lock_user_string(arg0);\n\n            s2 = lock_user_string(arg2);\n\n            if (!s || !s2)\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                ret = (uint32_t)-1;\n\n            else\n\n                ret = set_swi_errno(ts, rename(s, s2));\n\n            if (s2)\n\n                unlock_user(s2, arg2, 0);\n\n            if (s)\n\n                unlock_user(s, arg0, 0);\n\n            return ret;\n\n        }\n\n    case TARGET_SYS_CLOCK:\n\n        return clock() / (CLOCKS_PER_SEC / 100);\n\n    case TARGET_SYS_TIME:\n\n        return set_swi_errno(ts, time(NULL));\n\n    case TARGET_SYS_SYSTEM:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"system,%s\",\n\n                                   arg0, (int)arg1+1);\n\n        } else {\n\n            s = lock_user_string(arg0);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            ret = set_swi_errno(ts, system(s));\n\n            unlock_user(s, arg0, 0);\n\n            return ret;\n\n        }\n\n    case TARGET_SYS_ERRNO:\n\n#ifdef CONFIG_USER_ONLY\n\n        return ts->swi_errno;\n\n#else\n\n        return syscall_err;\n\n#endif\n\n    case TARGET_SYS_GET_CMDLINE:\n\n        {\n\n            /* Build a command-line from the original argv.\n\n             *\n\n             * The inputs are:\n\n             *     * arg0, pointer to a buffer of at least the size\n\n             *               specified in arg1.\n\n             *     * arg1, size of the buffer pointed to by arg0 in\n\n             *               bytes.\n\n             *\n\n             * The outputs are:\n\n             *     * arg0, pointer to null-terminated string of the\n\n             *               command line.\n\n             *     * arg1, length of the string pointed to by arg0.\n\n             */\n\n\n\n            char *output_buffer;\n\n            size_t input_size;\n\n            size_t output_size;\n\n            int status = 0;\n\n#if !defined(CONFIG_USER_ONLY)\n\n            const char *cmdline;\n\n#endif\n\n            GET_ARG(0);\n\n            GET_ARG(1);\n\n            input_size = arg1;\n\n            /* Compute the size of the output string.  */\n\n#if !defined(CONFIG_USER_ONLY)\n\n            cmdline = semihosting_get_cmdline();\n\n            if (cmdline == NULL) {\n\n                cmdline = \"\"; /* Default to an empty line. */\n\n            }\n\n            output_size = strlen(cmdline) + 1; /* Count terminating 0. */\n\n#else\n\n            unsigned int i;\n\n\n\n            output_size = ts->info->arg_end - ts->info->arg_start;\n\n            if (!output_size) {\n\n                /* We special-case the \"empty command line\" case (argc==0).\n\n                   Just provide the terminating 0. */\n\n                output_size = 1;\n\n            }\n\n#endif\n\n\n\n            if (output_size > input_size) {\n\n                 /* Not enough space to store command-line arguments.  */\n\n                return -1;\n\n            }\n\n\n\n            /* Adjust the command-line length.  */\n\n            if (SET_ARG(1, output_size - 1)) {\n\n                /* Couldn't write back to argument block */\n\n                return -1;\n\n            }\n\n\n\n            /* Lock the buffer on the ARM side.  */\n\n            output_buffer = lock_user(VERIFY_WRITE, arg0, output_size, 0);\n\n            if (!output_buffer) {\n\n                return -1;\n\n            }\n\n\n\n            /* Copy the command-line arguments.  */\n\n#if !defined(CONFIG_USER_ONLY)\n\n            pstrcpy(output_buffer, output_size, cmdline);\n\n#else\n\n            if (output_size == 1) {\n\n                /* Empty command-line.  */\n\n                output_buffer[0] = '\\0';\n\n                goto out;\n\n            }\n\n\n\n            if (copy_from_user(output_buffer, ts->info->arg_start,\n\n                               output_size)) {\n\n                status = -1;\n\n                goto out;\n\n            }\n\n\n\n            /* Separate arguments by white spaces.  */\n\n            for (i = 0; i < output_size - 1; i++) {\n\n                if (output_buffer[i] == 0) {\n\n                    output_buffer[i] = ' ';\n\n                }\n\n            }\n\n        out:\n\n#endif\n\n            /* Unlock the buffer on the ARM side.  */\n\n            unlock_user(output_buffer, arg0, output_size);\n\n\n\n            return status;\n\n        }\n\n    case TARGET_SYS_HEAPINFO:\n\n        {\n\n            target_ulong retvals[4];\n\n            uint32_t limit;\n\n            int i;\n\n\n\n            GET_ARG(0);\n\n\n\n#ifdef CONFIG_USER_ONLY\n\n            /* Some C libraries assume the heap immediately follows .bss, so\n\n               allocate it using sbrk.  */\n\n            if (!ts->heap_limit) {\n\n                abi_ulong ret;\n\n\n\n                ts->heap_base = do_brk(0);\n\n                limit = ts->heap_base + ARM_ANGEL_HEAP_SIZE;\n\n                /* Try a big heap, and reduce the size if that fails.  */\n\n                for (;;) {\n\n                    ret = do_brk(limit);\n\n                    if (ret >= limit) {\n\n                        break;\n\n                    }\n\n                    limit = (ts->heap_base >> 1) + (limit >> 1);\n\n                }\n\n                ts->heap_limit = limit;\n\n            }\n\n\n\n            retvals[0] = ts->heap_base;\n\n            retvals[1] = ts->heap_limit;\n\n            retvals[2] = ts->stack_base;\n\n            retvals[3] = 0; /* Stack limit.  */\n\n#else\n\n            limit = ram_size;\n\n            /* TODO: Make this use the limit of the loaded application.  */\n\n            retvals[0] = limit / 2;\n\n            retvals[1] = limit;\n\n            retvals[2] = limit; /* Stack base */\n\n            retvals[3] = 0; /* Stack limit.  */\n\n#endif\n\n\n\n            for (i = 0; i < ARRAY_SIZE(retvals); i++) {\n\n                bool fail;\n\n\n\n                if (is_a64(env)) {\n\n                    fail = put_user_u64(retvals[i], arg0 + i * 8);\n\n                } else {\n\n                    fail = put_user_u32(retvals[i], arg0 + i * 4);\n\n                }\n\n\n\n                if (fail) {\n\n                    /* Couldn't write back to argument block */\n\n                    return -1;\n\n                }\n\n            }\n\n            return 0;\n\n        }\n\n    case TARGET_SYS_EXIT:\n\n        if (is_a64(env)) {\n\n            /* The A64 version of this call takes a parameter block,\n\n             * so the application-exit type can return a subcode which\n\n             * is the exit status code from the application.\n\n             */\n\n            GET_ARG(0);\n\n            GET_ARG(1);\n\n\n\n            if (arg0 == ADP_Stopped_ApplicationExit) {\n\n                ret = arg1;\n\n            } else {\n\n                ret = 1;\n\n            }\n\n        } else {\n\n            /* ARM specifies only Stopped_ApplicationExit as normal\n\n             * exit, everything else is considered an error */\n\n            ret = (args == ADP_Stopped_ApplicationExit) ? 0 : 1;\n\n        }\n\n        gdb_exit(env, ret);\n\n        exit(ret);\n\n    case TARGET_SYS_SYNCCACHE:\n\n        /* Clean the D-cache and invalidate the I-cache for the specified\n\n         * virtual address range. This is a nop for us since we don't\n\n         * implement caches. This is only present on A64.\n\n         */\n\n        if (is_a64(env)) {\n\n            return 0;\n\n        }\n\n        /* fall through -- invalid for A32/T32 */\n\n    default:\n\n        fprintf(stderr, \"qemu: Unsupported SemiHosting SWI 0x%02x\\n\", nr);\n\n        cpu_dump_state(cs, stderr, fprintf, 0);\n\n        abort();\n\n    }\n\n}\n", "idx": 7462, "_split": "test", "_hash": "80afbfc4ad7290152cdef597e8ac81d9"}
{"project": "qemu", "commit_id": "d85937e683f6ff4d68293cb24c780fb1f6820d2c", "target": 0, "func": "static qemu_irq *ppce500_init_mpic(PPCE500Params *params, MemoryRegion *ccsr,\n\n                                   qemu_irq **irqs)\n\n{\n\n    qemu_irq *mpic;\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    int i, j, k;\n\n\n\n    mpic = g_new(qemu_irq, 256);\n\n    dev = qdev_create(NULL, \"openpic\");\n\n    qdev_prop_set_uint32(dev, \"nb_cpus\", smp_cpus);\n\n    qdev_prop_set_uint32(dev, \"model\", params->mpic_version);\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n\n\n    k = 0;\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        for (j = 0; j < OPENPIC_OUTPUT_NB; j++) {\n\n            sysbus_connect_irq(s, k++, irqs[i][j]);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        mpic[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n\n\n    memory_region_add_subregion(ccsr, MPC8544_MPIC_REGS_OFFSET,\n\n                                s->mmio[0].memory);\n\n\n\n    return mpic;\n\n}\n", "idx": 7480, "_split": "test", "_hash": "1a872f3cac00e8037d4351735649ae84"}
{"project": "qemu", "commit_id": "33577b47c64435fcc2a1bc01c7e82534256f1fc3", "target": 0, "func": "CharDriverState *qemu_chr_new(const char *label, const char *filename, void (*init)(struct CharDriverState *s))\n\n{\n\n    const char *p;\n\n    CharDriverState *chr;\n\n    QemuOpts *opts;\n\n    Error *err = NULL;\n\n\n\n    if (strstart(filename, \"chardev:\", &p)) {\n\n        return qemu_chr_find(p);\n\n    }\n\n\n\n    opts = qemu_chr_parse_compat(label, filename);\n\n    if (!opts)\n\n        return NULL;\n\n\n\n    chr = qemu_chr_new_from_opts(opts, init, &err);\n\n    if (err) {\n\n        error_report_err(err);\n\n    }\n\n    if (chr && qemu_opt_get_bool(opts, \"mux\", 0)) {\n\n        qemu_chr_fe_claim_no_fail(chr);\n\n        monitor_init(chr, MONITOR_USE_READLINE);\n\n    }\n\n    return chr;\n\n}\n", "idx": 7481, "_split": "test", "_hash": "dd24d41f34f235d6e7d1b61edf8acb48"}
{"project": "qemu", "commit_id": "7873df408dd44eb92840b108211d5aa5db7db526", "target": 0, "func": "static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,\n\n                            const char *model, const char *name,\n\n                            const char *ifname, const char *script,\n\n                            const char *downscript, const char *vhostfdname,\n\n                            int vnet_hdr, int fd)\n\n{\n\n    TAPState *s;\n\n\n\n    s = net_tap_fd_init(peer, model, name, fd, vnet_hdr);\n\n    if (!s) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    if (tap_set_sndbuf(s->fd, tap) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (tap->has_fd || tap->has_fds) {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"fd=%d\", fd);\n\n    } else if (tap->has_helper) {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"helper=%s\",\n\n                 tap->helper);\n\n    } else {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n                 \"ifname=%s,script=%s,downscript=%s\", ifname, script,\n\n                 downscript);\n\n\n\n        if (strcmp(downscript, \"no\") != 0) {\n\n            snprintf(s->down_script, sizeof(s->down_script), \"%s\", downscript);\n\n            snprintf(s->down_script_arg, sizeof(s->down_script_arg),\n\n                     \"%s\", ifname);\n\n        }\n\n    }\n\n\n\n    if (tap->has_vhost ? tap->vhost :\n\n        vhostfdname || (tap->has_vhostforce && tap->vhostforce)) {\n\n        int vhostfd;\n\n\n\n        if (tap->has_vhostfd) {\n\n            vhostfd = monitor_handle_fd_param(cur_mon, vhostfdname);\n\n            if (vhostfd == -1) {\n\n                return -1;\n\n            }\n\n        } else {\n\n            vhostfd = -1;\n\n        }\n\n\n\n        s->vhost_net = vhost_net_init(&s->nc, vhostfd,\n\n                                      tap->has_vhostforce && tap->vhostforce);\n\n        if (!s->vhost_net) {\n\n            error_report(\"vhost-net requested but could not be initialized\");\n\n            return -1;\n\n        }\n\n    } else if (tap->has_vhostfd || tap->has_vhostfds) {\n\n        error_report(\"vhostfd= is not valid without vhost\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7490, "_split": "test", "_hash": "f5f3636b71a08f722d4457536cc1e2a8"}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "int qdev_prop_check_globals(void)\n\n{\n\n    GList *l;\n\n    int ret = 0;\n\n\n\n    for (l = global_props; l; l = l->next) {\n\n        GlobalProperty *prop = l->data;\n\n        ObjectClass *oc;\n\n        DeviceClass *dc;\n\n        if (prop->used) {\n\n            continue;\n\n        }\n\n        if (!prop->user_provided) {\n\n            continue;\n\n        }\n\n        oc = object_class_by_name(prop->driver);\n\n        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);\n\n        if (!oc) {\n\n            error_report(\"Warning: global %s.%s has invalid class name\",\n\n                       prop->driver, prop->property);\n\n            ret = 1;\n\n            continue;\n\n        }\n\n        dc = DEVICE_CLASS(oc);\n\n        if (!dc->hotpluggable && !prop->used) {\n\n            error_report(\"Warning: global %s.%s=%s not used\",\n\n                       prop->driver, prop->property, prop->value);\n\n            ret = 1;\n\n            continue;\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 7491, "_split": "test", "_hash": "830a6a130b1614a9afd41fa4dd092ed3"}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static int qesd_init_out (HWVoiceOut *hw, audsettings_t *as)\n\n{\n\n    ESDVoiceOut *esd = (ESDVoiceOut *) hw;\n\n    audsettings_t obt_as = *as;\n\n    int esdfmt = ESD_STREAM | ESD_PLAY;\n\n    int err;\n\n    sigset_t set, old_set;\n\n\n\n    sigfillset (&set);\n\n\n\n    esdfmt |= (as->nchannels == 2) ? ESD_STEREO : ESD_MONO;\n\n    switch (as->fmt) {\n\n    case AUD_FMT_S8:\n\n    case AUD_FMT_U8:\n\n        esdfmt |= ESD_BITS8;\n\n        obt_as.fmt = AUD_FMT_U8;\n\n        break;\n\n\n\n    case AUD_FMT_S32:\n\n    case AUD_FMT_U32:\n\n        dolog (\"Will use 16 instead of 32 bit samples\\n\");\n\n\n\n    case AUD_FMT_S16:\n\n    case AUD_FMT_U16:\n\n    deffmt:\n\n        esdfmt |= ESD_BITS16;\n\n        obt_as.fmt = AUD_FMT_S16;\n\n        break;\n\n\n\n    default:\n\n        dolog (\"Internal logic error: Bad audio format %d\\n\", as->fmt);\n\n        goto deffmt;\n\n\n\n    }\n\n    obt_as.endianness = AUDIO_HOST_ENDIANNESS;\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n\n\n    hw->samples = conf.samples;\n\n    esd->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    if (!esd->pcm_buf) {\n\n        dolog (\"Could not allocate buffer (%d bytes)\\n\",\n\n               hw->samples << hw->info.shift);\n\n        return -1;\n\n    }\n\n\n\n    esd->fd = -1;\n\n    err = pthread_sigmask (SIG_BLOCK, &set, &old_set);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask failed\\n\");\n\n        goto fail1;\n\n    }\n\n\n\n    esd->fd = esd_play_stream (esdfmt, as->freq, conf.dac_host, NULL);\n\n    if (esd->fd < 0) {\n\n        qesd_logerr (errno, \"esd_play_stream failed\\n\");\n\n        goto fail2;\n\n    }\n\n\n\n    if (audio_pt_init (&esd->pt, qesd_thread_out, esd, AUDIO_CAP, AUDIO_FUNC)) {\n\n        goto fail3;\n\n    }\n\n\n\n    err = pthread_sigmask (SIG_SETMASK, &old_set, NULL);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask(restore) failed\\n\");\n\n    }\n\n\n\n    return 0;\n\n\n\n fail3:\n\n    if (close (esd->fd)) {\n\n        qesd_logerr (errno, \"%s: close on esd socket(%d) failed\\n\",\n\n                     AUDIO_FUNC, esd->fd);\n\n    }\n\n    esd->fd = -1;\n\n\n\n fail2:\n\n    err = pthread_sigmask (SIG_SETMASK, &old_set, NULL);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask(restore) failed\\n\");\n\n    }\n\n\n\n fail1:\n\n    qemu_free (esd->pcm_buf);\n\n    esd->pcm_buf = NULL;\n\n    return -1;\n\n}\n", "idx": 7498, "_split": "test", "_hash": "8ab0bc57b27ad07c9c24457680904a32"}
{"project": "qemu", "commit_id": "03a63484a6978f68caff087bbaabcd1d383563af", "target": 1, "func": "static void monitor_find_completion(const char *cmdline)\n\n{\n\n    const char *cmdname;\n\n    char *args[MAX_ARGS];\n\n    int nb_args, i, len;\n\n    const char *ptype, *str;\n\n    const mon_cmd_t *cmd;\n\n    const KeyDef *key;\n\n\n\n    parse_cmdline(cmdline, &nb_args, args);\n\n#ifdef DEBUG_COMPLETION\n\n    for(i = 0; i < nb_args; i++) {\n\n        monitor_printf(cur_mon, \"arg%d = '%s'\\n\", i, (char *)args[i]);\n\n    }\n\n#endif\n\n\n\n    /* if the line ends with a space, it means we want to complete the\n\n       next arg */\n\n    len = strlen(cmdline);\n\n    if (len > 0 && qemu_isspace(cmdline[len - 1])) {\n\n        if (nb_args >= MAX_ARGS)\n\n            return;\n\n        args[nb_args++] = qemu_strdup(\"\");\n\n    }\n\n    if (nb_args <= 1) {\n\n        /* command completion */\n\n        if (nb_args == 0)\n\n            cmdname = \"\";\n\n        else\n\n            cmdname = args[0];\n\n        readline_set_completion_index(cur_mon->rs, strlen(cmdname));\n\n        for(cmd = mon_cmds; cmd->name != NULL; cmd++) {\n\n            cmd_completion(cmdname, cmd->name);\n\n        }\n\n    } else {\n\n        /* find the command */\n\n        for(cmd = mon_cmds; cmd->name != NULL; cmd++) {\n\n            if (compare_cmd(args[0], cmd->name))\n\n                goto found;\n\n        }\n\n        return;\n\n    found:\n\n        ptype = next_arg_type(cmd->args_type);\n\n        for(i = 0; i < nb_args - 2; i++) {\n\n            if (*ptype != '\\0') {\n\n                ptype = next_arg_type(ptype);\n\n                while (*ptype == '?')\n\n                    ptype = next_arg_type(ptype);\n\n            }\n\n        }\n\n        str = args[nb_args - 1];\n\n        if (*ptype == '-' && ptype[1] != '\\0') {\n\n            ptype += 2;\n\n        }\n\n        switch(*ptype) {\n\n        case 'F':\n\n            /* file completion */\n\n            readline_set_completion_index(cur_mon->rs, strlen(str));\n\n            file_completion(str);\n\n            break;\n\n        case 'B':\n\n            /* block device name completion */\n\n            readline_set_completion_index(cur_mon->rs, strlen(str));\n\n            bdrv_iterate(block_completion_it, (void *)str);\n\n            break;\n\n        case 's':\n\n            /* XXX: more generic ? */\n\n            if (!strcmp(cmd->name, \"info\")) {\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for(cmd = info_cmds; cmd->name != NULL; cmd++) {\n\n                    cmd_completion(str, cmd->name);\n\n                }\n\n            } else if (!strcmp(cmd->name, \"sendkey\")) {\n\n                char *sep = strrchr(str, '-');\n\n                if (sep)\n\n                    str = sep + 1;\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for(key = key_defs; key->name != NULL; key++) {\n\n                    cmd_completion(str, key->name);\n\n                }\n\n            } else if (!strcmp(cmd->name, \"help|?\")) {\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for (cmd = mon_cmds; cmd->name != NULL; cmd++) {\n\n                    cmd_completion(str, cmd->name);\n\n                }\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    for(i = 0; i < nb_args; i++)\n\n        qemu_free(args[i]);\n\n}\n", "idx": 7521, "_split": "test", "_hash": "6fc3660a90c82ffb175846a4fec9bdaf"}
{"project": "qemu", "commit_id": "10a412dab3f54439ea3d60274eb41668f7d83bd2", "target": 0, "func": "static void sd_response_r1_make(SDState *sd,\n\n                                uint8_t *response, uint32_t last_status)\n\n{\n\n    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;\n\n    uint32_t status;\n\n\n\n    status = (sd->card_status & ~mask) | (last_status & mask);\n\n    sd->card_status &= ~CARD_STATUS_C | APP_CMD;\n\n\n\n    response[0] = (status >> 24) & 0xff;\n\n    response[1] = (status >> 16) & 0xff;\n\n    response[2] = (status >> 8) & 0xff;\n\n    response[3] = (status >> 0) & 0xff;\n\n}\n", "idx": 7556, "_split": "test", "_hash": "4d394d0e0c7c552669082f56ce09bcb8"}
{"project": "qemu", "commit_id": "da57febfed7bad11be79f047b59719c38abd0712", "target": 0, "func": "DeviceState *qdev_try_create(BusState *bus, const char *name)\n\n{\n\n    DeviceState *dev;\n\n\n\n    if (object_class_by_name(name) == NULL) {\n\n        return NULL;\n\n    }\n\n    dev = DEVICE(object_new(name));\n\n    if (!dev) {\n\n        return NULL;\n\n    }\n\n\n\n    if (!bus) {\n\n        bus = sysbus_get_default();\n\n    }\n\n\n\n    qdev_set_parent_bus(dev, bus);\n\n    qdev_prop_set_globals(dev);\n\n\n\n    return dev;\n\n}\n", "idx": 7579, "_split": "test", "_hash": "cf0ed8c0999b821800c178d4940be78b"}
{"project": "qemu", "commit_id": "31478f26ab4ed82d35b763bbf259810d0c8b44e1", "target": 1, "func": "Visitor *qobject_input_visitor_new_keyval(QObject *obj)\n\n{\n\n    QObjectInputVisitor *v = qobject_input_visitor_base_new(obj);\n\n\n\n    v->visitor.type_int64 = qobject_input_type_int64_keyval;\n\n    v->visitor.type_uint64 = qobject_input_type_uint64_keyval;\n\n    v->visitor.type_bool = qobject_input_type_bool_keyval;\n\n    v->visitor.type_str = qobject_input_type_str;\n\n    v->visitor.type_number = qobject_input_type_number_keyval;\n\n    v->visitor.type_any = qobject_input_type_any;\n\n    v->visitor.type_null = qobject_input_type_null;\n\n    v->visitor.type_size = qobject_input_type_size_keyval;\n\n\n\n    return &v->visitor;\n\n}\n", "idx": 7590, "_split": "test", "_hash": "9871a56f05a83d073784c301f156978d"}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)\n\n{\n\n    int iomemtype;\n\n    pl080_state *s;\n\n\n\n    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));\n\n    iomemtype = cpu_register_io_memory(0, pl080_readfn,\n\n                                       pl080_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->nchannels = nchannels;\n\n    /* ??? Save/restore.  */\n\n    return s;\n\n}\n", "idx": 7596, "_split": "test", "_hash": "25d692d87e2750311669734360d98c39"}
{"project": "qemu", "commit_id": "d5de7839d78b08c7bd14b03dac0413699b90da67", "target": 1, "func": "static void decode_32Bit_opc(CPUTriCoreState *env, DisasContext *ctx)\n\n{\n\n    int op1;\n\n    int32_t r1, r2, r3;\n\n    int32_t address, const16;\n\n    int8_t b, const4;\n\n    int32_t bpos;\n\n    TCGv temp, temp2, temp3;\n\n\n\n    op1 = MASK_OP_MAJOR(ctx->opcode);\n\n\n\n    /* handle JNZ.T opcode only being 7 bit long */\n\n    if (unlikely((op1 & 0x7f) == OPCM_32_BRN_JTT)) {\n\n        op1 = OPCM_32_BRN_JTT;\n\n    }\n\n\n\n    switch (op1) {\n\n/* ABS-format */\n\n    case OPCM_32_ABS_LDW:\n\n        decode_abs_ldw(env, ctx);\n\n\n    case OPCM_32_ABS_LDB:\n\n        decode_abs_ldb(env, ctx);\n\n\n    case OPCM_32_ABS_LDMST_SWAP:\n\n        decode_abs_ldst_swap(env, ctx);\n\n\n    case OPCM_32_ABS_LDST_CONTEXT:\n\n        decode_abs_ldst_context(env, ctx);\n\n\n    case OPCM_32_ABS_STORE:\n\n        decode_abs_store(env, ctx);\n\n\n    case OPCM_32_ABS_STOREB_H:\n\n        decode_abs_storeb_h(env, ctx);\n\n\n    case OPC1_32_ABS_STOREQ:\n\n        address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n        r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n        temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n        temp2 = tcg_temp_new();\n\n\n\n        tcg_gen_shri_tl(temp2, cpu_gpr_d[r1], 16);\n\n        tcg_gen_qemu_st_tl(temp2, temp, ctx->mem_idx, MO_LEUW);\n\n\n\n        tcg_temp_free(temp2);\n\n        tcg_temp_free(temp);\n\n\n    case OPC1_32_ABS_LD_Q:\n\n        address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n        r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n        temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n\n\n        tcg_gen_qemu_ld_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LEUW);\n\n        tcg_gen_shli_tl(cpu_gpr_d[r1], cpu_gpr_d[r1], 16);\n\n\n\n        tcg_temp_free(temp);\n\n\n    case OPC1_32_ABS_LEA:\n\n        address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n        r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n        tcg_gen_movi_tl(cpu_gpr_a[r1], EA_ABS_FORMAT(address));\n\n\n/* ABSB-format */\n\n    case OPC1_32_ABSB_ST_T:\n\n        address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n        b = MASK_OP_ABSB_B(ctx->opcode);\n\n        bpos = MASK_OP_ABSB_BPOS(ctx->opcode);\n\n\n\n        temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n        temp2 = tcg_temp_new();\n\n\n\n        tcg_gen_qemu_ld_tl(temp2, temp, ctx->mem_idx, MO_UB);\n\n        tcg_gen_andi_tl(temp2, temp2, ~(0x1u << bpos));\n\n        tcg_gen_ori_tl(temp2, temp2, (b << bpos));\n\n        tcg_gen_qemu_st_tl(temp2, temp, ctx->mem_idx, MO_UB);\n\n\n\n        tcg_temp_free(temp);\n\n        tcg_temp_free(temp2);\n\n\n/* B-format */\n\n    case OPC1_32_B_CALL:\n\n    case OPC1_32_B_CALLA:\n\n    case OPC1_32_B_J:\n\n    case OPC1_32_B_JA:\n\n    case OPC1_32_B_JL:\n\n    case OPC1_32_B_JLA:\n\n        address = MASK_OP_B_DISP24(ctx->opcode);\n\n        gen_compute_branch(ctx, op1, 0, 0, 0, address);\n\n\n/* Bit-format */\n\n    case OPCM_32_BIT_ANDACC:\n\n        decode_bit_andacc(env, ctx);\n\n\n    case OPCM_32_BIT_LOGICAL_T1:\n\n        decode_bit_logical_t(env, ctx);\n\n\n    case OPCM_32_BIT_INSERT:\n\n        decode_bit_insert(env, ctx);\n\n\n    case OPCM_32_BIT_LOGICAL_T2:\n\n        decode_bit_logical_t2(env, ctx);\n\n\n    case OPCM_32_BIT_ORAND:\n\n        decode_bit_orand(env, ctx);\n\n\n    case OPCM_32_BIT_SH_LOGIC1:\n\n        decode_bit_sh_logic1(env, ctx);\n\n\n    case OPCM_32_BIT_SH_LOGIC2:\n\n        decode_bit_sh_logic2(env, ctx);\n\n\n    /* BO Format */\n\n    case OPCM_32_BO_ADDRMODE_POST_PRE_BASE:\n\n        decode_bo_addrmode_post_pre_base(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_BITREVERSE_CIRCULAR:\n\n        decode_bo_addrmode_bitreverse_circular(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_LD_POST_PRE_BASE:\n\n        decode_bo_addrmode_ld_post_pre_base(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_LD_BITREVERSE_CIRCULAR:\n\n        decode_bo_addrmode_ld_bitreverse_circular(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_STCTX_POST_PRE_BASE:\n\n        decode_bo_addrmode_stctx_post_pre_base(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_LDMST_BITREVERSE_CIRCULAR:\n\n        decode_bo_addrmode_ldmst_bitreverse_circular(env, ctx);\n\n\n/* BOL-format */\n\n    case OPC1_32_BOL_LD_A_LONGOFF:\n\n    case OPC1_32_BOL_LD_W_LONGOFF:\n\n    case OPC1_32_BOL_LEA_LONGOFF:\n\n    case OPC1_32_BOL_ST_W_LONGOFF:\n\n    case OPC1_32_BOL_ST_A_LONGOFF:\n\n        decode_bol_opc(env, ctx, op1);\n\n\n/* BRC Format */\n\n    case OPCM_32_BRC_EQ_NEQ:\n\n    case OPCM_32_BRC_GE:\n\n    case OPCM_32_BRC_JLT:\n\n    case OPCM_32_BRC_JNE:\n\n        const4 = MASK_OP_BRC_CONST4_SEXT(ctx->opcode);\n\n        address = MASK_OP_BRC_DISP15_SEXT(ctx->opcode);\n\n        r1 = MASK_OP_BRC_S1(ctx->opcode);\n\n        gen_compute_branch(ctx, op1, r1, 0, const4, address);\n\n\n/* BRN Format */\n\n    case OPCM_32_BRN_JTT:\n\n        address = MASK_OP_BRN_DISP15_SEXT(ctx->opcode);\n\n        r1 = MASK_OP_BRN_S1(ctx->opcode);\n\n        gen_compute_branch(ctx, op1, r1, 0, 0, address);\n\n\n/* BRR Format */\n\n    case OPCM_32_BRR_EQ_NEQ:\n\n    case OPCM_32_BRR_ADDR_EQ_NEQ:\n\n    case OPCM_32_BRR_GE:\n\n    case OPCM_32_BRR_JLT:\n\n    case OPCM_32_BRR_JNE:\n\n    case OPCM_32_BRR_JNZ:\n\n    case OPCM_32_BRR_LOOP:\n\n        address = MASK_OP_BRR_DISP15_SEXT(ctx->opcode);\n\n        r2 = MASK_OP_BRR_S2(ctx->opcode);\n\n        r1 = MASK_OP_BRR_S1(ctx->opcode);\n\n        gen_compute_branch(ctx, op1, r1, r2, 0, address);\n\n\n/* RC Format */\n\n    case OPCM_32_RC_LOGICAL_SHIFT:\n\n        decode_rc_logical_shift(env, ctx);\n\n\n    case OPCM_32_RC_ACCUMULATOR:\n\n        decode_rc_accumulator(env, ctx);\n\n\n    case OPCM_32_RC_SERVICEROUTINE:\n\n        decode_rc_serviceroutine(env, ctx);\n\n\n    case OPCM_32_RC_MUL:\n\n        decode_rc_mul(env, ctx);\n\n\n/* RCPW Format */\n\n    case OPCM_32_RCPW_MASK_INSERT:\n\n        decode_rcpw_insert(env, ctx);\n\n\n/* RCRR Format */\n\n    case OPC1_32_RCRR_INSERT:\n\n        r1 = MASK_OP_RCRR_S1(ctx->opcode);\n\n        r2 = MASK_OP_RCRR_S3(ctx->opcode);\n\n        r3 = MASK_OP_RCRR_D(ctx->opcode);\n\n        const16 = MASK_OP_RCRR_CONST4(ctx->opcode);\n\n        temp = tcg_const_i32(const16);\n\n        temp2 = tcg_temp_new(); /* width*/\n\n        temp3 = tcg_temp_new(); /* pos */\n\n\n\n        tcg_gen_andi_tl(temp2, cpu_gpr_d[r3+1], 0x1f);\n\n        tcg_gen_andi_tl(temp3, cpu_gpr_d[r3], 0x1f);\n\n\n\n        gen_insert(cpu_gpr_d[r2], cpu_gpr_d[r1], temp, temp2, temp3);\n\n\n\n        tcg_temp_free(temp);\n\n        tcg_temp_free(temp2);\n\n        tcg_temp_free(temp3);\n\n\n/* RCRW Format */\n\n    case OPCM_32_RCRW_MASK_INSERT:\n\n        decode_rcrw_insert(env, ctx);\n\n\n/* RCR Format */\n\n    case OPCM_32_RCR_COND_SELECT:\n\n        decode_rcr_cond_select(env, ctx);\n\n\n    case OPCM_32_RCR_MADD:\n\n        decode_rcr_madd(env, ctx);\n\n\n    case OPCM_32_RCR_MSUB:\n\n        decode_rcr_msub(env, ctx);\n\n\n/* RLC Format */\n\n    case OPC1_32_RLC_ADDI:\n\n    case OPC1_32_RLC_ADDIH:\n\n    case OPC1_32_RLC_ADDIH_A:\n\n    case OPC1_32_RLC_MFCR:\n\n    case OPC1_32_RLC_MOV:\n\n    case OPC1_32_RLC_MOV_64:\n\n    case OPC1_32_RLC_MOV_U:\n\n    case OPC1_32_RLC_MOV_H:\n\n    case OPC1_32_RLC_MOVH_A:\n\n    case OPC1_32_RLC_MTCR:\n\n        decode_rlc_opc(env, ctx, op1);\n\n\n\n\n\n\n    }\n\n}", "idx": 7654, "_split": "test", "_hash": "24a1b35677a653a09080507381f6c518"}
{"project": "qemu", "commit_id": "b7b5233ad7fdd9985bb6d05b7919f3a20723ff2c", "target": 1, "func": "void *g_realloc(void *ptr, size_t size)\n\n{\n\n    size_t old_size, copy;\n\n    void *new_ptr;\n\n\n\n    if (!ptr)\n\n        return g_malloc(size);\n\n    old_size = *(size_t *)((char *)ptr - 16);\n\n    copy = old_size < size ? old_size : size;\n\n    new_ptr = g_malloc(size);\n\n    memcpy(new_ptr, ptr, copy);\n\n    g_free(ptr);\n\n    return new_ptr;\n\n}\n", "idx": 7662, "_split": "test", "_hash": "592065530fb54099d6713e8ce659c74b"}
{"project": "qemu", "commit_id": "196a778428989217b82de042725dc8eb29c8f8d8", "target": 1, "func": "static void ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    PCIQXLDevice *d = opaque;\n\n    uint32_t io_port = addr - d->io_base;\n\n\n\n    switch (io_port) {\n\n    case QXL_IO_RESET:\n\n    case QXL_IO_SET_MODE:\n\n    case QXL_IO_MEMSLOT_ADD:\n\n    case QXL_IO_MEMSLOT_DEL:\n\n    case QXL_IO_CREATE_PRIMARY:\n\n        break;\n\n    default:\n\n        if (d->mode == QXL_MODE_NATIVE || d->mode == QXL_MODE_COMPAT)\n\n            break;\n\n        dprint(d, 1, \"%s: unexpected port 0x%x in vga mode\\n\", __FUNCTION__, io_port);\n\n        return;\n\n    }\n\n\n\n    switch (io_port) {\n\n    case QXL_IO_UPDATE_AREA:\n\n    {\n\n        QXLRect update = d->ram->update_area;\n\n        qemu_mutex_unlock_iothread();\n\n        d->ssd.worker->update_area(d->ssd.worker, d->ram->update_surface,\n\n                                   &update, NULL, 0, 0);\n\n        qemu_mutex_lock_iothread();\n\n        break;\n\n    }\n\n    case QXL_IO_NOTIFY_CMD:\n\n        d->ssd.worker->wakeup(d->ssd.worker);\n\n        break;\n\n    case QXL_IO_NOTIFY_CURSOR:\n\n        d->ssd.worker->wakeup(d->ssd.worker);\n\n        break;\n\n    case QXL_IO_UPDATE_IRQ:\n\n        qxl_set_irq(d);\n\n        break;\n\n    case QXL_IO_NOTIFY_OOM:\n\n        if (!SPICE_RING_IS_EMPTY(&d->ram->release_ring)) {\n\n            break;\n\n        }\n\n        pthread_yield();\n\n        if (!SPICE_RING_IS_EMPTY(&d->ram->release_ring)) {\n\n            break;\n\n        }\n\n        d->oom_running = 1;\n\n        d->ssd.worker->oom(d->ssd.worker);\n\n        d->oom_running = 0;\n\n        break;\n\n    case QXL_IO_SET_MODE:\n\n        dprint(d, 1, \"QXL_SET_MODE %d\\n\", val);\n\n        qxl_set_mode(d, val, 0);\n\n        break;\n\n    case QXL_IO_LOG:\n\n        if (d->guestdebug) {\n\n            fprintf(stderr, \"qxl/guest: %s\", d->ram->log_buf);\n\n        }\n\n        break;\n\n    case QXL_IO_RESET:\n\n        dprint(d, 1, \"QXL_IO_RESET\\n\");\n\n        qxl_hard_reset(d, 0);\n\n        break;\n\n    case QXL_IO_MEMSLOT_ADD:\n\n        PANIC_ON(val >= NUM_MEMSLOTS);\n\n        PANIC_ON(d->guest_slots[val].active);\n\n        d->guest_slots[val].slot = d->ram->mem_slot;\n\n        qxl_add_memslot(d, val, 0);\n\n        break;\n\n    case QXL_IO_MEMSLOT_DEL:\n\n        qxl_del_memslot(d, val);\n\n        break;\n\n    case QXL_IO_CREATE_PRIMARY:\n\n        PANIC_ON(val != 0);\n\n        dprint(d, 1, \"QXL_IO_CREATE_PRIMARY\\n\");\n\n        d->guest_primary.surface = d->ram->create_surface;\n\n        qxl_create_guest_primary(d, 0);\n\n        break;\n\n    case QXL_IO_DESTROY_PRIMARY:\n\n        PANIC_ON(val != 0);\n\n        dprint(d, 1, \"QXL_IO_DESTROY_PRIMARY\\n\");\n\n        qxl_destroy_primary(d);\n\n        break;\n\n    case QXL_IO_DESTROY_SURFACE_WAIT:\n\n        d->ssd.worker->destroy_surface_wait(d->ssd.worker, val);\n\n        break;\n\n    case QXL_IO_DESTROY_ALL_SURFACES:\n\n        d->ssd.worker->destroy_surfaces(d->ssd.worker);\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: ioport=0x%x, abort()\\n\", __FUNCTION__, io_port);\n\n        abort();\n\n    }\n\n}\n", "idx": 7696, "_split": "test", "_hash": "bba7d31d02aaf2319175adb55b62f87d"}
{"project": "qemu", "commit_id": "049a9f7b946fe1d3ff97127f8905881dbb78cb00", "target": 1, "func": "static void i82378_init(DeviceState *dev, I82378State *s)\n\n{\n\n    ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, \"isa.0\"));\n\n    ISADevice *pit;\n\n    qemu_irq *out0_irq;\n\n\n\n    /* This device has:\n\n       2 82C59 (irq)\n\n       1 82C54 (pit)\n\n       2 82C37 (dma)\n\n       NMI\n\n       Utility Bus Support Registers\n\n\n\n       All devices accept byte access only, except timer\n\n     */\n\n\n\n    qdev_init_gpio_out(dev, s->out, 2);\n\n    qdev_init_gpio_in(dev, i82378_request_pic_irq, 16);\n\n\n\n    /* Workaround the fact that i8259 is not qdev'ified... */\n\n    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, s, 1);\n\n\n\n    /* 2 82C59 (irq) */\n\n    s->i8259 = i8259_init(isabus, *out0_irq);\n\n    isa_bus_irqs(isabus, s->i8259);\n\n\n\n    /* 1 82C54 (pit) */\n\n    pit = pit_init(isabus, 0x40, 0, NULL);\n\n\n\n    /* speaker */\n\n    pcspk_init(isabus, pit);\n\n\n\n    /* 2 82C37 (dma) */\n\n    DMA_init(1, &s->out[1]);\n\n    isa_create_simple(isabus, \"i82374\");\n\n\n\n    /* timer */\n\n    isa_create_simple(isabus, \"mc146818rtc\");\n\n}\n", "idx": 7732, "_split": "test", "_hash": "32c938cf77a32ee73c480f2803b18783"}
{"project": "qemu", "commit_id": "0ae18ceeaaa2c1749e742c4b112f6c3bf0896408", "target": 0, "func": "static void realview_init(ram_addr_t ram_size, int vga_ram_size,\n\n                     const char *boot_device, DisplayState *ds,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    qemu_irq *pic;\n\n    void *scsi_hba;\n\n    PCIBus *pci_bus;\n\n    NICInfo *nd;\n\n    int n;\n\n    int done_smc = 0;\n\n    qemu_irq cpu_irq[4];\n\n    int ncpu;\n\n    int index;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"arm926\";\n\n    /* FIXME: obey smp_cpus.  */\n\n    if (strcmp(cpu_model, \"arm11mpcore\") == 0) {\n\n        ncpu = 4;\n\n    } else {\n\n        ncpu = 1;\n\n    }\n\n\n\n    for (n = 0; n < ncpu; n++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        pic = arm_pic_init_cpu(env);\n\n        cpu_irq[n] = pic[ARM_PIC_CPU_IRQ];\n\n        if (n > 0) {\n\n            /* Set entry point for secondary CPUs.  This assumes we're using\n\n               the init code from arm_boot.c.  Real hardware resets all CPUs\n\n               the same.  */\n\n            env->regs[15] = 0x80000000;\n\n        }\n\n    }\n\n\n\n    /* ??? RAM should repeat to fill physical memory space.  */\n\n    /* SDRAM at address zero.  */\n\n    cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);\n\n\n\n    arm_sysctl_init(0x10000000, 0xc1400400);\n\n\n\n    if (ncpu == 1) {\n\n        /* ??? The documentation says GIC1 is nFIQ and either GIC2 or GIC3\n\n           is nIRQ (there are inconsistencies).  However Linux 2.6.17 expects\n\n           GIC1 to be nIRQ and ignores all the others, so do that for now.  */\n\n        pic = realview_gic_init(0x10040000, cpu_irq[0]);\n\n    } else {\n\n        pic = mpcore_irq_init(cpu_irq);\n\n    }\n\n\n\n    pl050_init(0x10006000, pic[20], 0);\n\n    pl050_init(0x10007000, pic[21], 1);\n\n\n\n    pl011_init(0x10009000, pic[12], serial_hds[0], PL011_ARM);\n\n    pl011_init(0x1000a000, pic[13], serial_hds[1], PL011_ARM);\n\n    pl011_init(0x1000b000, pic[14], serial_hds[2], PL011_ARM);\n\n    pl011_init(0x1000c000, pic[15], serial_hds[3], PL011_ARM);\n\n\n\n    /* DMA controller is optional, apparently.  */\n\n    pl080_init(0x10030000, pic[24], 2);\n\n\n\n    sp804_init(0x10011000, pic[4]);\n\n    sp804_init(0x10012000, pic[5]);\n\n\n\n    pl110_init(ds, 0x10020000, pic[23], 1);\n\n\n\n    index = drive_get_index(IF_SD, 0, 0);\n\n    if (index == -1) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital card\\n\");\n\n        exit(1);\n\n    }\n\n    pl181_init(0x10005000, drives_table[index].bdrv, pic[17], pic[18]);\n\n\n\n    pl031_init(0x10017000, pic[10]);\n\n\n\n    pci_bus = pci_vpb_init(pic, 48, 1);\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, 3, -1);\n\n    }\n\n    if (drive_get_max_bus(IF_SCSI) > 0) {\n\n        fprintf(stderr, \"qemu: too many SCSI bus\\n\");\n\n        exit(1);\n\n    }\n\n    scsi_hba = lsi_scsi_init(pci_bus, -1);\n\n    for (n = 0; n < LSI_MAX_DEVS; n++) {\n\n        index = drive_get_index(IF_SCSI, 0, n);\n\n        if (index == -1)\n\n            continue;\n\n        lsi_scsi_attach(scsi_hba, drives_table[index].bdrv, n);\n\n    }\n\n    for(n = 0; n < nb_nics; n++) {\n\n        nd = &nd_table[n];\n\n        if (!nd->model)\n\n            nd->model = done_smc ? \"rtl8139\" : \"smc91c111\";\n\n        if (strcmp(nd->model, \"smc91c111\") == 0) {\n\n            smc91c111_init(nd, 0x4e000000, pic[28]);\n\n        } else {\n\n            pci_nic_init(pci_bus, nd, -1);\n\n        }\n\n    }\n\n\n\n    /* Memory map for RealView Emulation Baseboard:  */\n\n    /* 0x10000000 System registers.  */\n\n    /*  0x10001000 System controller.  */\n\n    /*  0x10002000 Two-Wire Serial Bus.  */\n\n    /* 0x10003000 Reserved.  */\n\n    /*  0x10004000 AACI.  */\n\n    /*  0x10005000 MCI.  */\n\n    /* 0x10006000 KMI0.  */\n\n    /* 0x10007000 KMI1.  */\n\n    /*  0x10008000 Character LCD.  */\n\n    /* 0x10009000 UART0.  */\n\n    /* 0x1000a000 UART1.  */\n\n    /* 0x1000b000 UART2.  */\n\n    /* 0x1000c000 UART3.  */\n\n    /*  0x1000d000 SSPI.  */\n\n    /*  0x1000e000 SCI.  */\n\n    /* 0x1000f000 Reserved.  */\n\n    /*  0x10010000 Watchdog.  */\n\n    /* 0x10011000 Timer 0+1.  */\n\n    /* 0x10012000 Timer 2+3.  */\n\n    /*  0x10013000 GPIO 0.  */\n\n    /*  0x10014000 GPIO 1.  */\n\n    /*  0x10015000 GPIO 2.  */\n\n    /* 0x10016000 Reserved.  */\n\n    /* 0x10017000 RTC.  */\n\n    /*  0x10018000 DMC.  */\n\n    /*  0x10019000 PCI controller config.  */\n\n    /*  0x10020000 CLCD.  */\n\n    /* 0x10030000 DMA Controller.  */\n\n    /* 0x10040000 GIC1.  */\n\n    /* 0x10050000 GIC2.  */\n\n    /* 0x10060000 GIC3.  */\n\n    /* 0x10070000 GIC4.  */\n\n    /*  0x10080000 SMC.  */\n\n    /*  0x40000000 NOR flash.  */\n\n    /*  0x44000000 DoC flash.  */\n\n    /*  0x48000000 SRAM.  */\n\n    /*  0x4c000000 Configuration flash.  */\n\n    /* 0x4e000000 Ethernet.  */\n\n    /*  0x4f000000 USB.  */\n\n    /*  0x50000000 PISMO.  */\n\n    /*  0x54000000 PISMO.  */\n\n    /*  0x58000000 PISMO.  */\n\n    /*  0x5c000000 PISMO.  */\n\n    /* 0x60000000 PCI.  */\n\n    /* 0x61000000 PCI Self Config.  */\n\n    /* 0x62000000 PCI Config.  */\n\n    /* 0x63000000 PCI IO.  */\n\n    /* 0x64000000 PCI mem 0.  */\n\n    /* 0x68000000 PCI mem 1.  */\n\n    /* 0x6c000000 PCI mem 2.  */\n\n\n\n    realview_binfo.ram_size = ram_size;\n\n    realview_binfo.kernel_filename = kernel_filename;\n\n    realview_binfo.kernel_cmdline = kernel_cmdline;\n\n    realview_binfo.initrd_filename = initrd_filename;\n\n    realview_binfo.nb_cpus = ncpu;\n\n    arm_load_kernel(first_cpu, &realview_binfo);\n\n\n\n    /* ??? Hack to map an additional page of ram for the secondary CPU\n\n       startup code.  I guess this works on real hardware because the\n\n       BootROM happens to be in ROM/flash or in memory that isn't clobbered\n\n       until after Linux boots the secondary CPUs.  */\n\n    cpu_register_physical_memory(0x80000000, 0x1000, IO_MEM_RAM + ram_size);\n\n}\n", "idx": 7749, "_split": "test", "_hash": "a089f723cef197d741d6e2b6668c2e66"}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "QString *qstring_from_substr(const char *str, int start, int end)\n\n{\n\n    QString *qstring;\n\n\n\n    qstring = g_malloc(sizeof(*qstring));\n\n\n\n    qstring->length = end - start + 1;\n\n    qstring->capacity = qstring->length;\n\n\n\n    qstring->string = g_malloc(qstring->capacity + 1);\n\n    memcpy(qstring->string, str + start, qstring->length);\n\n    qstring->string[qstring->length] = 0;\n\n\n\n    QOBJECT_INIT(qstring, &qstring_type);\n\n\n\n    return qstring;\n\n}\n", "idx": 7754, "_split": "test", "_hash": "82e7e7784397f1911b98169c3a83bb65"}
{"project": "qemu", "commit_id": "12d69ac03b45156356b240424623719f15d8143e", "target": 0, "func": "static void test_source_wait_event_notifier(void)\n\n{\n\n    EventNotifierTestData data = { .n = 0, .active = 1 };\n\n    event_notifier_init(&data.e, false);\n\n    aio_set_event_notifier(ctx, &data.e, event_ready_cb);\n\n    g_assert(g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 0);\n\n    g_assert_cmpint(data.active, ==, 1);\n\n\n\n    event_notifier_set(&data.e);\n\n    g_assert(g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n    g_assert_cmpint(data.active, ==, 0);\n\n\n\n    while (g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n    g_assert_cmpint(data.active, ==, 0);\n\n\n\n    aio_set_event_notifier(ctx, &data.e, NULL);\n\n    while (g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n\n\n    event_notifier_cleanup(&data.e);\n\n}\n", "idx": 7761, "_split": "test", "_hash": "a53e642297f36295e793b391f9cf721f"}
{"project": "qemu", "commit_id": "f9749f28b78be36471d3d0f5d4b6eed030f8942e", "target": 0, "func": "static int coroutine_fn is_allocated_base(BlockDriverState *top,\n\n                                          BlockDriverState *base,\n\n                                          int64_t sector_num,\n\n                                          int nb_sectors, int *pnum)\n\n{\n\n    BlockDriverState *intermediate;\n\n    int ret, n;\n\n\n\n    ret = bdrv_co_is_allocated(top, sector_num, nb_sectors, &n);\n\n    if (ret) {\n\n        *pnum = n;\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * Is the unallocated chunk [sector_num, n] also\n\n     * unallocated between base and top?\n\n     */\n\n    intermediate = top->backing_hd;\n\n\n\n    while (intermediate != base) {\n\n        int pnum_inter;\n\n\n\n        ret = bdrv_co_is_allocated(intermediate, sector_num, nb_sectors,\n\n                                   &pnum_inter);\n\n        if (ret < 0) {\n\n            return ret;\n\n        } else if (ret) {\n\n            *pnum = pnum_inter;\n\n            return 0;\n\n        }\n\n\n\n        /*\n\n         * [sector_num, nb_sectors] is unallocated on top but intermediate\n\n         * might have\n\n         *\n\n         * [sector_num+x, nr_sectors] allocated.\n\n         */\n\n        if (n > pnum_inter) {\n\n            n = pnum_inter;\n\n        }\n\n\n\n        intermediate = intermediate->backing_hd;\n\n    }\n\n\n\n    *pnum = n;\n\n    return 1;\n\n}\n", "idx": 7762, "_split": "test", "_hash": "0e7f696ebe27f6570ef2f19815d3ec01"}
{"project": "qemu", "commit_id": "c6bf0f7ffa90c720377eb6bddd27037041acbc5b", "target": 0, "func": "static DisplayType select_display(const char *p)\n\n{\n\n    Error *err = NULL;\n\n    const char *opts;\n\n    DisplayType display = DT_DEFAULT;\n\n\n\n    if (strstart(p, \"sdl\", &opts)) {\n\n#ifdef CONFIG_SDL\n\n        display = DT_SDL;\n\n        while (*opts) {\n\n            const char *nextopt;\n\n\n\n            if (strstart(opts, \",frame=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    no_frame = 0;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    no_frame = 1;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else if (strstart(opts, \",alt_grab=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    alt_grab = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    alt_grab = 0;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else if (strstart(opts, \",ctrl_grab=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    ctrl_grab = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    ctrl_grab = 0;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else if (strstart(opts, \",window_close=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    no_quit = 0;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    no_quit = 1;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else if (strstart(opts, \",gl=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    request_opengl = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    request_opengl = 0;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else {\n\n            invalid_sdl_args:\n\n                fprintf(stderr, \"Invalid SDL option string: %s\\n\", p);\n\n                exit(1);\n\n            }\n\n            opts = nextopt;\n\n        }\n\n#else\n\n        fprintf(stderr, \"SDL support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"vnc\", &opts)) {\n\n#ifdef CONFIG_VNC\n\n        if (*opts == '=') {\n\n            if (vnc_parse(opts + 1, &err) == NULL) {\n\n                error_report_err(err);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            fprintf(stderr, \"VNC requires a display argument vnc=<display>\\n\");\n\n            exit(1);\n\n        }\n\n#else\n\n        fprintf(stderr, \"VNC support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"curses\", &opts)) {\n\n#ifdef CONFIG_CURSES\n\n        display = DT_CURSES;\n\n#else\n\n        fprintf(stderr, \"Curses support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"gtk\", &opts)) {\n\n#ifdef CONFIG_GTK\n\n        display = DT_GTK;\n\n        while (*opts) {\n\n            const char *nextopt;\n\n\n\n            if (strstart(opts, \",grab_on_hover=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    grab_on_hover = true;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    grab_on_hover = false;\n\n                } else {\n\n                    goto invalid_gtk_args;\n\n                }\n\n            } else if (strstart(opts, \",gl=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    request_opengl = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    request_opengl = 0;\n\n                } else {\n\n                    goto invalid_gtk_args;\n\n                }\n\n            } else {\n\n            invalid_gtk_args:\n\n                fprintf(stderr, \"Invalid GTK option string: %s\\n\", p);\n\n                exit(1);\n\n            }\n\n            opts = nextopt;\n\n        }\n\n#else\n\n        fprintf(stderr, \"GTK support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"none\", &opts)) {\n\n        display = DT_NONE;\n\n    } else {\n\n        fprintf(stderr, \"Unknown display type: %s\\n\", p);\n\n        exit(1);\n\n    }\n\n\n\n    return display;\n\n}\n", "idx": 7766, "_split": "test", "_hash": "163d2f422940fdd7971c6eaf3c9e744d"}
{"project": "qemu", "commit_id": "75f19f8c3006970632303b49043b075dc4fe922e", "target": 0, "func": "static void megasas_unmap_frame(MegasasState *s, MegasasCmd *cmd)\n\n{\n\n    PCIDevice *p = PCI_DEVICE(s);\n\n\n\n    pci_dma_unmap(p, cmd->frame, cmd->pa_size, 0, 0);\n\n    cmd->frame = NULL;\n\n    cmd->pa = 0;\n\n    clear_bit(cmd->index, s->frame_map);\n\n}\n", "idx": 7779, "_split": "test", "_hash": "95610ee4423c70abddd3beb574a57cca"}
{"project": "qemu", "commit_id": "02cb7f3a256517cbf3136caff2863fbafc57b540", "target": 0, "func": "int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,\n\n                  int flags, int mode)\n\n{\n\n    int err;\n\n    FsCred cred;\n\n\n\n    cred_init(&cred);\n\n    cred.fc_mode = mode & 07777;\n\n    cred.fc_uid = fidp->uid;\n\n    cred.fc_gid = gid;\n\n    v9fs_co_run_in_worker(\n\n        {\n\n            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);\n\n            err = 0;\n\n            if (fidp->fs.fd == -1) {\n\n                err = -errno;\n\n            }\n\n        });\n\n    if (!err) {\n\n        total_open_fd++;\n\n        if (total_open_fd > open_fd_hw) {\n\n            v9fs_reclaim_fd(s);\n\n        }\n\n    }\n\n    return err;\n\n}\n", "idx": 7780, "_split": "test", "_hash": "cf16fd2014c70fdbdbe54f611d2a1aa1"}
{"project": "qemu", "commit_id": "bbe2f399b222f1f2fcf5cd2ea78e4f5c9a66c64e", "target": 0, "func": "static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)\n\n{\n\n    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\n    static const uint8_t vlan[] = {0x81, 0x00};\n\n    uint8_t *ptr = (uint8_t *)buf;\n\n    int i;\n\n\n\n    if (n->promisc)\n\n        return 1;\n\n\n\n    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {\n\n        int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;\n\n        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))\n\n            return 0;\n\n    }\n\n\n\n    if ((ptr[0] & 1) && n->allmulti)\n\n        return 1;\n\n\n\n    if (!memcmp(ptr, bcast, sizeof(bcast)))\n\n        return 1;\n\n\n\n    if (!memcmp(ptr, n->mac, ETH_ALEN))\n\n        return 1;\n\n\n\n    for (i = 0; i < n->mac_table.in_use; i++) {\n\n        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))\n\n            return 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7782, "_split": "test", "_hash": "f4f8fe21947a5ccbc5eb30c9d8bdca2a"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_tlbsx_440(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    TCGv t0;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    t0 = tcg_temp_new();\n\n    gen_addr_reg_index(ctx, t0);\n\n    gen_helper_440_tlbsx(cpu_gpr[rD(ctx->opcode)], cpu_env, t0);\n\n    tcg_temp_free(t0);\n\n    if (Rc(ctx->opcode)) {\n\n        int l1 = gen_new_label();\n\n        tcg_gen_trunc_tl_i32(cpu_crf[0], cpu_so);\n\n        tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_gpr[rD(ctx->opcode)], -1, l1);\n\n        tcg_gen_ori_i32(cpu_crf[0], cpu_crf[0], 0x02);\n\n        gen_set_label(l1);\n\n    }\n\n#endif\n\n}\n", "idx": 7814, "_split": "test", "_hash": "6df990986562b7ac35bd217b6a995eef"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "GSource *iohandler_get_g_source(void)\n\n{\n\n    iohandler_init();\n\n    return aio_get_g_source(iohandler_ctx);\n\n}\n", "idx": 7828, "_split": "test", "_hash": "3735bf56e0c0b12265cec55bf92cba22"}
{"project": "qemu", "commit_id": "c1076c3e13a86140cc2ba29866512df8460cc7c2", "target": 0, "func": "static void pxa2xx_lcdc_dma0_redraw_rot0(PXA2xxLCDState *s,\n\n                hwaddr addr, int *miny, int *maxy)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s->con);\n\n    int src_width, dest_width;\n\n    drawfn fn = NULL;\n\n    if (s->dest_width)\n\n        fn = s->line_fn[s->transp][s->bpp];\n\n    if (!fn)\n\n        return;\n\n\n\n    src_width = (s->xres + 3) & ~3;     /* Pad to a 4 pixels multiple */\n\n    if (s->bpp == pxa_lcdc_19pbpp || s->bpp == pxa_lcdc_18pbpp)\n\n        src_width *= 3;\n\n    else if (s->bpp > pxa_lcdc_16bpp)\n\n        src_width *= 4;\n\n    else if (s->bpp > pxa_lcdc_8bpp)\n\n        src_width *= 2;\n\n\n\n    dest_width = s->xres * s->dest_width;\n\n    *miny = 0;\n\n    framebuffer_update_display(surface, s->sysmem,\n\n                               addr, s->xres, s->yres,\n\n                               src_width, dest_width, s->dest_width,\n\n                               s->invalidated,\n\n                               fn, s->dma_ch[0].palette, miny, maxy);\n\n}\n", "idx": 7866, "_split": "test", "_hash": "c6e6a34ee81e5f4442c9dae814412e3f"}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_dmar_q35(GArray *table_data, GArray *linker)\n\n{\n\n    int dmar_start = table_data->len;\n\n\n\n    AcpiTableDmar *dmar;\n\n    AcpiDmarHardwareUnit *drhd;\n\n\n\n    dmar = acpi_data_push(table_data, sizeof(*dmar));\n\n    dmar->host_address_width = VTD_HOST_ADDRESS_WIDTH - 1;\n\n    dmar->flags = 0;    /* No intr_remap for now */\n\n\n\n    /* DMAR Remapping Hardware Unit Definition structure */\n\n    drhd = acpi_data_push(table_data, sizeof(*drhd));\n\n    drhd->type = cpu_to_le16(ACPI_DMAR_TYPE_HARDWARE_UNIT);\n\n    drhd->length = cpu_to_le16(sizeof(*drhd));   /* No device scope now */\n\n    drhd->flags = ACPI_DMAR_INCLUDE_PCI_ALL;\n\n    drhd->pci_segment = cpu_to_le16(0);\n\n    drhd->address = cpu_to_le64(Q35_HOST_BRIDGE_IOMMU_ADDR);\n\n\n\n    build_header(linker, table_data, (void *)(table_data->data + dmar_start),\n\n                 \"DMAR\", table_data->len - dmar_start, 1, NULL);\n\n}\n", "idx": 7869, "_split": "test", "_hash": "b1859b8f80b3a6045d2638e9905a2eb8"}
{"project": "qemu", "commit_id": "db1da1f2b5f3a2383030438553988f0734a97dbe", "target": 0, "func": "static GtkWidget *gd_create_menu_machine(GtkDisplayState *s, GtkAccelGroup *accel_group)\n\n{\n\n    GtkWidget *machine_menu;\n\n    GtkWidget *separator;\n\n\n\n    machine_menu = gtk_menu_new();\n\n    gtk_menu_set_accel_group(GTK_MENU(machine_menu), accel_group);\n\n\n\n    s->pause_item = gtk_check_menu_item_new_with_mnemonic(_(\"_Pause\"));\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->pause_item);\n\n\n\n    separator = gtk_separator_menu_item_new();\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);\n\n\n\n    s->reset_item = gtk_menu_item_new_with_mnemonic(_(\"_Reset\"));\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->reset_item);\n\n\n\n    s->powerdown_item = gtk_menu_item_new_with_mnemonic(_(\"Power _Down\"));\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->powerdown_item);\n\n\n\n    separator = gtk_separator_menu_item_new();\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);\n\n\n\n    s->quit_item = gtk_menu_item_new_with_mnemonic(_(\"_Quit\"));\n\n    gtk_menu_item_set_accel_path(GTK_MENU_ITEM(s->quit_item),\n\n                                 \"<QEMU>/Machine/Quit\");\n\n    gtk_accel_map_add_entry(\"<QEMU>/Machine/Quit\",\n\n                            GDK_KEY_q, GDK_CONTROL_MASK);\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->quit_item);\n\n\n\n    return machine_menu;\n\n}\n", "idx": 7873, "_split": "test", "_hash": "6331bd413965fd13ae0ce163a21996ed"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,\n\n                                     uint64_t value, unsigned size)\n\n{\n\n    mv88w8618_flashcfg_state *s = opaque;\n\n\n\n    switch (offset) {\n\n    case MP_FLASHCFG_CFGR0:\n\n        s->cfgr0 = value;\n\n        break;\n\n    }\n\n}\n", "idx": 7874, "_split": "test", "_hash": "0efe4f642a28310c9d5389b0e5bd6041"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int qemu_rdma_get_fd(void *opaque)\n\n{\n\n    QEMUFileRDMA *rfile = opaque;\n\n    RDMAContext *rdma = rfile->rdma;\n\n\n\n    return rdma->comp_channel->fd;\n\n}\n", "idx": 7881, "_split": "test", "_hash": "c40c99cb2ba42af29cb681dc5a14763f"}
{"project": "qemu", "commit_id": "323ad19bcc601d3ec9cb6f0f5b4d67b602fc519e", "target": 1, "func": "static void dump_ppc_insns (CPUPPCState *env)\n\n{\n\n    opc_handler_t **table, *handler;\n\n    const char *p, *q;\n\n    uint8_t opc1, opc2, opc3;\n\n\n\n    printf(\"Instructions set:\\n\");\n\n    /* opc1 is 6 bits long */\n\n    for (opc1 = 0x00; opc1 < PPC_CPU_OPCODES_LEN; opc1++) {\n\n        table = env->opcodes;\n\n        handler = table[opc1];\n\n        if (is_indirect_opcode(handler)) {\n\n            /* opc2 is 5 bits long */\n\n            for (opc2 = 0; opc2 < PPC_CPU_INDIRECT_OPCODES_LEN; opc2++) {\n\n                table = env->opcodes;\n\n                handler = env->opcodes[opc1];\n\n                table = ind_table(handler);\n\n                handler = table[opc2];\n\n                if (is_indirect_opcode(handler)) {\n\n                    table = ind_table(handler);\n\n                    /* opc3 is 5 bits long */\n\n                    for (opc3 = 0; opc3 < PPC_CPU_INDIRECT_OPCODES_LEN;\n\n                            opc3++) {\n\n                        handler = table[opc3];\n\n                        if (handler->handler != &gen_invalid) {\n\n                            /* Special hack to properly dump SPE insns */\n\n                            p = strchr(handler->oname, '_');\n\n                            if (p == NULL) {\n\n                                printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                       \"%s\\n\",\n\n                                       opc1, opc2, opc3, opc1,\n\n                                       (opc3 << 5) | opc2,\n\n                                       handler->oname);\n\n                            } else {\n\n                                q = \"speundef\";\n\n                                if ((p - handler->oname) != strlen(q) ||\n\n                                    memcmp(handler->oname, q, strlen(q)) != 0) {\n\n                                    /* First instruction */\n\n                                    printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                           \"%.*s\\n\",\n\n                                           opc1, opc2 << 1, opc3, opc1,\n\n                                           (opc3 << 6) | (opc2 << 1),\n\n                                           (int)(p - handler->oname),\n\n                                           handler->oname);\n\n                                }\n\n                                if (strcmp(p + 1, q) != 0) {\n\n                                    /* Second instruction */\n\n                                    printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                           \"%s\\n\",\n\n                                           opc1, (opc2 << 1) | 1, opc3, opc1,\n\n                                           (opc3 << 6) | (opc2 << 1) | 1,\n\n                                           p + 1);\n\n                                }\n\n                            }\n\n                        }\n\n                    }\n\n                } else {\n\n                    if (handler->handler != &gen_invalid) {\n\n                        printf(\"INSN: %02x %02x -- (%02d %04d) : %s\\n\",\n\n                               opc1, opc2, opc1, opc2, handler->oname);\n\n                    }\n\n                }\n\n            }\n\n        } else {\n\n            if (handler->handler != &gen_invalid) {\n\n                printf(\"INSN: %02x -- -- (%02d ----) : %s\\n\",\n\n                       opc1, opc1, handler->oname);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 7882, "_split": "test", "_hash": "97afcaac37ee3aa35e5e15abf69074c6"}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void fd_coroutine_enter(void *opaque)\n\n{\n\n    FDYieldUntilData *data = opaque;\n\n    qemu_set_fd_handler(data->fd, NULL, NULL, NULL);\n\n    qemu_coroutine_enter(data->co, NULL);\n\n}\n", "idx": 7893, "_split": "test", "_hash": "25df7dbae5692379f1f09936f8c07756"}
{"project": "qemu", "commit_id": "e976c6a1e40ad74d616a186d3b48b0ad8f5eb970", "target": 1, "func": "static void qcow_aio_write_cb(void *opaque, int ret)\n\n{\n\n    QCowAIOCB *acb = opaque;\n\n    BlockDriverState *bs = acb->common.bs;\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    uint64_t cluster_offset;\n\n    const uint8_t *src_buf;\n\n    int n_end;\n\n\n\n    acb->hd_aiocb = NULL;\n\n\n\n    if (ret < 0) {\n\n    fail:\n\n        acb->common.cb(acb->common.opaque, ret);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    acb->nb_sectors -= acb->n;\n\n    acb->sector_num += acb->n;\n\n    acb->buf += acb->n * 512;\n\n\n\n    if (acb->nb_sectors == 0) {\n\n        /* request completed */\n\n        acb->common.cb(acb->common.opaque, 0);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    index_in_cluster = acb->sector_num & (s->cluster_sectors - 1);\n\n    n_end = index_in_cluster + acb->nb_sectors;\n\n    if (s->crypt_method &&\n\n        n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors)\n\n        n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n\n\n    cluster_offset = alloc_cluster_offset(bs, acb->sector_num << 9,\n\n                                          index_in_cluster,\n\n                                          n_end, &acb->n);\n\n    if (!cluster_offset || (cluster_offset & 511) != 0) {\n\n        ret = -EIO;\n\n        goto fail;\n\n    }\n\n    if (s->crypt_method) {\n\n        if (!acb->cluster_data) {\n\n            acb->cluster_data = qemu_mallocz(QCOW_MAX_CRYPT_CLUSTERS *\n\n                                             s->cluster_size);\n\n            if (!acb->cluster_data) {\n\n                ret = -ENOMEM;\n\n                goto fail;\n\n            }\n\n        }\n\n        encrypt_sectors(s, acb->sector_num, acb->cluster_data, acb->buf,\n\n                        acb->n, 1, &s->aes_encrypt_key);\n\n        src_buf = acb->cluster_data;\n\n    } else {\n\n        src_buf = acb->buf;\n\n    }\n\n    acb->hd_aiocb = bdrv_aio_write(s->hd,\n\n                                   (cluster_offset >> 9) + index_in_cluster,\n\n                                   src_buf, acb->n,\n\n                                   qcow_aio_write_cb, acb);\n\n    if (acb->hd_aiocb == NULL)\n\n        goto fail;\n\n}\n", "idx": 7916, "_split": "test", "_hash": "0795bd81f950943ea87e637275047abc"}
{"project": "qemu", "commit_id": "3393bc105d58e1f4a27d9a8e7062da9cef260cc3", "target": 0, "func": "static int usb_hub_handle_control(USBDevice *dev, USBPacket *p,\n\n               int request, int value, int index, int length, uint8_t *data)\n\n{\n\n    USBHubState *s = (USBHubState *)dev;\n\n    int ret;\n\n\n\n    ret = usb_desc_handle_control(dev, p, request, value, index, length, data);\n\n    if (ret >= 0) {\n\n        return ret;\n\n    }\n\n\n\n    switch(request) {\n\n    case EndpointOutRequest | USB_REQ_CLEAR_FEATURE:\n\n        if (value == 0 && index != 0x81) { /* clear ep halt */\n\n            goto fail;\n\n        }\n\n        ret = 0;\n\n        break;\n\n    case DeviceRequest | USB_REQ_GET_INTERFACE:\n\n        data[0] = 0;\n\n        ret = 1;\n\n        break;\n\n    case DeviceOutRequest | USB_REQ_SET_INTERFACE:\n\n        ret = 0;\n\n        break;\n\n        /* usb specific requests */\n\n    case GetHubStatus:\n\n        data[0] = 0;\n\n        data[1] = 0;\n\n        data[2] = 0;\n\n        data[3] = 0;\n\n        ret = 4;\n\n        break;\n\n    case GetPortStatus:\n\n        {\n\n            unsigned int n = index - 1;\n\n            USBHubPort *port;\n\n            if (n >= NUM_PORTS) {\n\n                goto fail;\n\n            }\n\n            port = &s->ports[n];\n\n            data[0] = port->wPortStatus;\n\n            data[1] = port->wPortStatus >> 8;\n\n            data[2] = port->wPortChange;\n\n            data[3] = port->wPortChange >> 8;\n\n            ret = 4;\n\n        }\n\n        break;\n\n    case SetHubFeature:\n\n    case ClearHubFeature:\n\n        if (value == 0 || value == 1) {\n\n        } else {\n\n            goto fail;\n\n        }\n\n        ret = 0;\n\n        break;\n\n    case SetPortFeature:\n\n        {\n\n            unsigned int n = index - 1;\n\n            USBHubPort *port;\n\n            USBDevice *dev;\n\n            if (n >= NUM_PORTS) {\n\n                goto fail;\n\n            }\n\n            port = &s->ports[n];\n\n            dev = port->port.dev;\n\n            switch(value) {\n\n            case PORT_SUSPEND:\n\n                port->wPortStatus |= PORT_STAT_SUSPEND;\n\n                break;\n\n            case PORT_RESET:\n\n                if (dev) {\n\n                    usb_send_msg(dev, USB_MSG_RESET);\n\n                    port->wPortChange |= PORT_STAT_C_RESET;\n\n                    /* set enable bit */\n\n                    port->wPortStatus |= PORT_STAT_ENABLE;\n\n                }\n\n                break;\n\n            case PORT_POWER:\n\n                break;\n\n            default:\n\n                goto fail;\n\n            }\n\n            ret = 0;\n\n        }\n\n        break;\n\n    case ClearPortFeature:\n\n        {\n\n            unsigned int n = index - 1;\n\n            USBHubPort *port;\n\n\n\n            if (n >= NUM_PORTS) {\n\n                goto fail;\n\n            }\n\n            port = &s->ports[n];\n\n            switch(value) {\n\n            case PORT_ENABLE:\n\n                port->wPortStatus &= ~PORT_STAT_ENABLE;\n\n                break;\n\n            case PORT_C_ENABLE:\n\n                port->wPortChange &= ~PORT_STAT_C_ENABLE;\n\n                break;\n\n            case PORT_SUSPEND:\n\n                port->wPortStatus &= ~PORT_STAT_SUSPEND;\n\n                break;\n\n            case PORT_C_SUSPEND:\n\n                port->wPortChange &= ~PORT_STAT_C_SUSPEND;\n\n                break;\n\n            case PORT_C_CONNECTION:\n\n                port->wPortChange &= ~PORT_STAT_C_CONNECTION;\n\n                break;\n\n            case PORT_C_OVERCURRENT:\n\n                port->wPortChange &= ~PORT_STAT_C_OVERCURRENT;\n\n                break;\n\n            case PORT_C_RESET:\n\n                port->wPortChange &= ~PORT_STAT_C_RESET;\n\n                break;\n\n            default:\n\n                goto fail;\n\n            }\n\n            ret = 0;\n\n        }\n\n        break;\n\n    case GetHubDescriptor:\n\n        {\n\n            unsigned int n, limit, var_hub_size = 0;\n\n            memcpy(data, qemu_hub_hub_descriptor,\n\n                   sizeof(qemu_hub_hub_descriptor));\n\n            data[2] = NUM_PORTS;\n\n\n\n            /* fill DeviceRemovable bits */\n\n            limit = ((NUM_PORTS + 1 + 7) / 8) + 7;\n\n            for (n = 7; n < limit; n++) {\n\n                data[n] = 0x00;\n\n                var_hub_size++;\n\n            }\n\n\n\n            /* fill PortPwrCtrlMask bits */\n\n            limit = limit + ((NUM_PORTS + 7) / 8);\n\n            for (;n < limit; n++) {\n\n                data[n] = 0xff;\n\n                var_hub_size++;\n\n            }\n\n\n\n            ret = sizeof(qemu_hub_hub_descriptor) + var_hub_size;\n\n            data[0] = ret;\n\n            break;\n\n        }\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n    return ret;\n\n}\n", "idx": 7936, "_split": "test", "_hash": "94572fec29b35ce6d7446acb3be563d7"}
{"project": "qemu", "commit_id": "3ad493fc5ea38c005670adc5933058a28ccabdd4", "target": 0, "func": "int cpu_arm_handle_mmu_fault (CPUState *env, target_ulong address,\n\n                              int access_type, int mmu_idx, int is_softmmu)\n\n{\n\n    uint32_t phys_addr;\n\n    target_ulong page_size;\n\n    int prot;\n\n    int ret, is_user;\n\n\n\n    is_user = mmu_idx == MMU_USER_IDX;\n\n    ret = get_phys_addr(env, address, access_type, is_user, &phys_addr, &prot,\n\n                        &page_size);\n\n    if (ret == 0) {\n\n        /* Map a single [sub]page.  */\n\n        phys_addr &= ~(uint32_t)0x3ff;\n\n        address &= ~(uint32_t)0x3ff;\n\n        tlb_set_page (env, address, phys_addr, prot | PAGE_EXEC, mmu_idx,\n\n                      page_size);\n\n        return 0;\n\n    }\n\n\n\n    if (access_type == 2) {\n\n        env->cp15.c5_insn = ret;\n\n        env->cp15.c6_insn = address;\n\n        env->exception_index = EXCP_PREFETCH_ABORT;\n\n    } else {\n\n        env->cp15.c5_data = ret;\n\n        if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6))\n\n            env->cp15.c5_data |= (1 << 11);\n\n        env->cp15.c6_data = address;\n\n        env->exception_index = EXCP_DATA_ABORT;\n\n    }\n\n    return 1;\n\n}\n", "idx": 7972, "_split": "test", "_hash": "b0f2a254e4a6d75958c73b3760c0d284"}
{"project": "qemu", "commit_id": "f8c88bbcda76d5674e4bb125471371b41d330df8", "target": 1, "func": "static int get_cpsr(QEMUFile *f, void *opaque, size_t size)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    CPUARMState *env = &cpu->env;\n\n    uint32_t val = qemu_get_be32(f);\n\n\n\n    env->aarch64 = ((val & PSTATE_nRW) == 0);\n\n\n\n    if (is_a64(env)) {\n\n        pstate_write(env, val);\n\n        return 0;\n\n    }\n\n\n\n    /* Avoid mode switch when restoring CPSR */\n\n    env->uncached_cpsr = val & CPSR_M;\n\n    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);\n\n    return 0;\n\n}\n", "idx": 7982, "_split": "test", "_hash": "b44cdd85d7b8951003ad5838637d7bc8"}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_handle_byte(int ch)\n\n{\n\n    switch(term_esc_state) {\n\n    case IS_NORM:\n\n        switch(ch) {\n\n        case 1:\n\n            term_bol();\n\n            break;\n\n        case 4:\n\n            term_delete_char();\n\n            break;\n\n        case 5:\n\n            term_eol();\n\n            break;\n\n        case 9:\n\n            term_completion();\n\n            break;\n\n        case 10:\n\n        case 13:\n\n            term_cmd_buf[term_cmd_buf_size] = '\\0';\n\n\t    term_hist_add(term_cmd_buf);\n\n            term_printf(\"\\n\");\n\n            term_handle_command(term_cmd_buf);\n\n            term_show_prompt();\n\n            break;\n\n        case 27:\n\n            term_esc_state = IS_ESC;\n\n            break;\n\n        case 127:\n\n        case 8:\n\n            term_backspace();\n\n            break;\n\n\tcase 155:\n\n            term_esc_state = IS_CSI;\n\n\t    break;\n\n        default:\n\n            if (ch >= 32) {\n\n                term_insert_char(ch);\n\n            }\n\n            break;\n\n        }\n\n        break;\n\n    case IS_ESC:\n\n        if (ch == '[') {\n\n            term_esc_state = IS_CSI;\n\n            term_esc_param = 0;\n\n        } else {\n\n            term_esc_state = IS_NORM;\n\n        }\n\n        break;\n\n    case IS_CSI:\n\n        switch(ch) {\n\n\tcase 'A':\n\n\tcase 'F':\n\n\t    term_up_char();\n\n\t    break;\n\n\tcase 'B':\n\n\tcase 'E':\n\n\t    term_down_char();\n\n\t    break;\n\n        case 'D':\n\n            term_backward_char();\n\n            break;\n\n        case 'C':\n\n            term_forward_char();\n\n            break;\n\n        case '0' ... '9':\n\n            term_esc_param = term_esc_param * 10 + (ch - '0');\n\n            goto the_end;\n\n        case '~':\n\n            switch(term_esc_param) {\n\n            case 1:\n\n                term_bol();\n\n                break;\n\n            case 3:\n\n                term_delete_char();\n\n                break;\n\n            case 4:\n\n                term_eol();\n\n                break;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        term_esc_state = IS_NORM;\n\n    the_end:\n\n        break;\n\n    }\n\n    term_update();\n\n}\n", "idx": 7992, "_split": "test", "_hash": "9bcecac4fb32e3fe140c1ee38610120e"}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "struct omap_l4_s *omap_l4_init(target_phys_addr_t base, int ta_num)\n\n{\n\n    struct omap_l4_s *bus = g_malloc0(\n\n                    sizeof(*bus) + ta_num * sizeof(*bus->ta));\n\n\n\n    bus->ta_num = ta_num;\n\n    bus->base = base;\n\n\n\n#ifdef L4_MUX_HACK\n\n    omap_l4_io_entries = 1;\n\n    omap_l4_io_entry = g_malloc0(125 * sizeof(*omap_l4_io_entry));\n\n\n\n    omap_cpu_io_entry =\n\n            cpu_register_io_memory(omap_l4_io_readfn,\n\n                            omap_l4_io_writefn, bus, DEVICE_NATIVE_ENDIAN);\n\n# define L4_PAGES\t(0xb4000 / TARGET_PAGE_SIZE)\n\n    omap_l4_io_readb_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_readh_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_readw_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_writeb_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_writeh_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_writew_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_opaque = g_malloc0(sizeof(void *) * L4_PAGES);\n\n#endif\n\n\n\n    return bus;\n\n}\n", "idx": 8010, "_split": "test", "_hash": "55ac5aecea0d4aa95b40f1509b50e4f5"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void qbus_list_bus(DeviceState *dev, char *dest, int len)\n\n{\n\n    BusState *child;\n\n    const char *sep = \" \";\n\n    int pos = 0;\n\n\n\n    pos += snprintf(dest+pos, len-pos,\"child busses at \\\"%s\\\":\",\n\n                    dev->id ? dev->id : dev->info->name);\n\n    LIST_FOREACH(child, &dev->child_bus, sibling) {\n\n        pos += snprintf(dest+pos, len-pos, \"%s\\\"%s\\\"\", sep, child->name);\n\n        sep = \", \";\n\n    }\n\n}\n", "idx": 8018, "_split": "test", "_hash": "64287a4c1ee8fbbf0d3edd6337a844e3"}
{"project": "qemu", "commit_id": "6817efea3a0d1bf87be815970cdb014c5a64b628", "target": 1, "func": "static int read_directory(BDRVVVFATState* s, int mapping_index)\n\n{\n\n    mapping_t* mapping = array_get(&(s->mapping), mapping_index);\n\n    direntry_t* direntry;\n\n    const char* dirname = mapping->path;\n\n    int first_cluster = mapping->begin;\n\n    int parent_index = mapping->info.dir.parent_mapping_index;\n\n    mapping_t* parent_mapping = (mapping_t*)\n\n        (parent_index >= 0 ? array_get(&(s->mapping), parent_index) : NULL);\n\n    int first_cluster_of_parent = parent_mapping ? parent_mapping->begin : -1;\n\n\n\n    DIR* dir=opendir(dirname);\n\n    struct dirent* entry;\n\n    int i;\n\n\n\n    assert(mapping->mode & MODE_DIRECTORY);\n\n\n\n    if(!dir) {\n\n        mapping->end = mapping->begin;\n\n        return -1;\n\n    }\n\n\n\n    i = mapping->info.dir.first_dir_index =\n\n            first_cluster == 0 ? 0 : s->directory.next;\n\n\n\n    if (first_cluster != 0) {\n\n        /* create the top entries of a subdirectory */\n\n        (void)create_short_and_long_name(s, i, \".\", 1);\n\n        (void)create_short_and_long_name(s, i, \"..\", 1);\n\n    }\n\n\n\n    /* actually read the directory, and allocate the mappings */\n\n    while((entry=readdir(dir))) {\n\n        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);\n\n        char* buffer;\n\n        direntry_t* direntry;\n\n        struct stat st;\n\n        int is_dot=!strcmp(entry->d_name,\".\");\n\n        int is_dotdot=!strcmp(entry->d_name,\"..\");\n\n\n\n        if(first_cluster == 0 && (is_dotdot || is_dot))\n\n            continue;\n\n\n\n        buffer = g_malloc(length);\n\n        snprintf(buffer,length,\"%s/%s\",dirname,entry->d_name);\n\n\n\n        if(stat(buffer,&st)<0) {\n\n            g_free(buffer);\n\n            continue;\n\n        }\n\n\n\n        /* create directory entry for this file */\n\n        if (!is_dot && !is_dotdot) {\n\n            direntry = create_short_and_long_name(s, i, entry->d_name, 0);\n\n        } else {\n\n            direntry = array_get(&(s->directory), is_dot ? i : i + 1);\n\n        }\n\n        direntry->attributes=(S_ISDIR(st.st_mode)?0x10:0x20);\n\n        direntry->reserved[0]=direntry->reserved[1]=0;\n\n        direntry->ctime=fat_datetime(st.st_ctime,1);\n\n        direntry->cdate=fat_datetime(st.st_ctime,0);\n\n        direntry->adate=fat_datetime(st.st_atime,0);\n\n        direntry->begin_hi=0;\n\n        direntry->mtime=fat_datetime(st.st_mtime,1);\n\n        direntry->mdate=fat_datetime(st.st_mtime,0);\n\n        if(is_dotdot)\n\n            set_begin_of_direntry(direntry, first_cluster_of_parent);\n\n        else if(is_dot)\n\n            set_begin_of_direntry(direntry, first_cluster);\n\n        else\n\n            direntry->begin=0; /* do that later */\n\n        if (st.st_size > 0x7fffffff) {\n\n            fprintf(stderr, \"File %s is larger than 2GB\\n\", buffer);\n\n            g_free(buffer);\n\n            closedir(dir);\n\n            return -2;\n\n        }\n\n        direntry->size=cpu_to_le32(S_ISDIR(st.st_mode)?0:st.st_size);\n\n\n\n        /* create mapping for this file */\n\n        if(!is_dot && !is_dotdot && (S_ISDIR(st.st_mode) || st.st_size)) {\n\n            s->current_mapping = array_get_next(&(s->mapping));\n\n            s->current_mapping->begin=0;\n\n            s->current_mapping->end=st.st_size;\n\n            /*\n\n             * we get the direntry of the most recent direntry, which\n\n             * contains the short name and all the relevant information.\n\n             */\n\n            s->current_mapping->dir_index=s->directory.next-1;\n\n            s->current_mapping->first_mapping_index = -1;\n\n            if (S_ISDIR(st.st_mode)) {\n\n                s->current_mapping->mode = MODE_DIRECTORY;\n\n                s->current_mapping->info.dir.parent_mapping_index =\n\n                    mapping_index;\n\n            } else {\n\n                s->current_mapping->mode = MODE_UNDEFINED;\n\n                s->current_mapping->info.file.offset = 0;\n\n            }\n\n            s->current_mapping->path=buffer;\n\n            s->current_mapping->read_only =\n\n                (st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0;\n\n        } else {\n\n            g_free(buffer);\n\n        }\n\n    }\n\n    closedir(dir);\n\n\n\n    /* fill with zeroes up to the end of the cluster */\n\n    while(s->directory.next%(0x10*s->sectors_per_cluster)) {\n\n        direntry_t* direntry=array_get_next(&(s->directory));\n\n        memset(direntry,0,sizeof(direntry_t));\n\n    }\n\n\n\n/* TODO: if there are more entries, bootsector has to be adjusted! */\n\n#define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster)\n\n    if (mapping_index == 0 && s->directory.next < ROOT_ENTRIES) {\n\n        /* root directory */\n\n        int cur = s->directory.next;\n\n        array_ensure_allocated(&(s->directory), ROOT_ENTRIES - 1);\n\n        s->directory.next = ROOT_ENTRIES;\n\n        memset(array_get(&(s->directory), cur), 0,\n\n                (ROOT_ENTRIES - cur) * sizeof(direntry_t));\n\n    }\n\n\n\n    /* re-get the mapping, since s->mapping was possibly realloc()ed */\n\n    mapping = array_get(&(s->mapping), mapping_index);\n\n    first_cluster += (s->directory.next - mapping->info.dir.first_dir_index)\n\n        * 0x20 / s->cluster_size;\n\n    mapping->end = first_cluster;\n\n\n\n    direntry = array_get(&(s->directory), mapping->dir_index);\n\n    set_begin_of_direntry(direntry, mapping->begin);\n\n\n\n    return 0;\n\n}\n", "idx": 8021, "_split": "test", "_hash": "0eb4716b50ca6d07807213b2b805d630"}
{"project": "qemu", "commit_id": "db7dfd4c7e4450b10048a53ce67bcac6305ad383", "target": 0, "func": "static void cubieboard_init(QEMUMachineInitArgs *args)\n\n{\n\n    CubieBoardState *s = g_new(CubieBoardState, 1);\n\n    Error *err = NULL;\n\n\n\n    s->a10 = AW_A10(object_new(TYPE_AW_A10));\n\n    object_property_set_bool(OBJECT(s->a10), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        error_report(\"Couldn't realize Allwinner A10: %s\\n\",\n\n                error_get_pretty(err));\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_init_ram(&s->sdram, NULL, \"cubieboard.ram\", args->ram_size);\n\n    vmstate_register_ram_global(&s->sdram);\n\n    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,\n\n                                &s->sdram);\n\n\n\n    cubieboard_binfo.ram_size = args->ram_size;\n\n    cubieboard_binfo.kernel_filename = args->kernel_filename;\n\n    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;\n\n    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);\n\n}\n", "idx": 8049, "_split": "test", "_hash": "b5378cd6dbcda9384d438fe2baa6183f"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void esp_init(target_phys_addr_t espaddr, int it_shift,\n\n              ESPDMAMemoryReadWriteFunc dma_memory_read,\n\n              ESPDMAMemoryReadWriteFunc dma_memory_write,\n\n              void *dma_opaque, qemu_irq irq, qemu_irq *reset,\n\n              qemu_irq *dma_enable)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    SysBusESPState *sysbus;\n\n    ESPState *esp;\n\n\n\n    dev = qdev_create(NULL, \"esp\");\n\n    sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev);\n\n    esp = &sysbus->esp;\n\n    esp->dma_memory_read = dma_memory_read;\n\n    esp->dma_memory_write = dma_memory_write;\n\n    esp->dma_opaque = dma_opaque;\n\n    sysbus->it_shift = it_shift;\n\n    /* XXX for now until rc4030 has been changed to use DMA enable signal */\n\n    esp->dma_enabled = 1;\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_mmio_map(s, 0, espaddr);\n\n    *reset = qdev_get_gpio_in(dev, 0);\n\n    *dma_enable = qdev_get_gpio_in(dev, 1);\n\n}\n", "idx": 8071, "_split": "test", "_hash": "53fe53c434148a347bc699065d28c427"}
{"project": "qemu", "commit_id": "80fb34eda099e7cc519a91e9701ab3c0262717b3", "target": 1, "func": "bool qio_task_propagate_error(QIOTask *task,\n\n                              Error **errp)\n\n{\n\n    if (task->err) {\n\n        error_propagate(errp, task->err);\n\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}", "idx": 8111, "_split": "test", "_hash": "bdc79248c303a5e04c510e3b34353d48"}
{"project": "qemu", "commit_id": "f7b879e072ae6839b1b1d1312f48fa7f256397e2", "target": 1, "func": "static void device_unparent(Object *obj)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    BusState *bus;\n\n\n\n    if (dev->realized) {\n\n        object_property_set_bool(obj, false, \"realized\", NULL);\n\n    }\n\n    while (dev->num_child_bus) {\n\n        bus = QLIST_FIRST(&dev->child_bus);\n\n        object_unparent(OBJECT(bus));\n\n    }\n\n    if (dev->parent_bus) {\n\n        bus_remove_child(dev->parent_bus, dev);\n\n        object_unref(OBJECT(dev->parent_bus));\n\n        dev->parent_bus = NULL;\n\n    }\n\n\n\n    /* Only send event if the device had been completely realized */\n\n    if (dev->pending_deleted_event) {\n\n        g_assert(dev->canonical_path);\n\n\n\n        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,\n\n                                       &error_abort);\n\n        g_free(dev->canonical_path);\n\n        dev->canonical_path = NULL;\n\n    }\n\n}\n", "idx": 8130, "_split": "test", "_hash": "6650a8948d171d8af046f5bc9910b283"}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "QBool *qbool_from_bool(bool value)\n\n{\n\n    QBool *qb;\n\n\n\n    qb = g_malloc(sizeof(*qb));\n\n    qb->value = value;\n\n    QOBJECT_INIT(qb, &qbool_type);\n\n\n\n    return qb;\n\n}\n", "idx": 8134, "_split": "test", "_hash": "38edd1b11e5d18eb2c0d69be9f96e044"}
{"project": "qemu", "commit_id": "edf779ffccc836661a7b654d320571a6c220caea", "target": 0, "func": "static void setup_rt_frame(int usig, struct emulated_sigaction *ka, \n\n                           target_siginfo_t *info,\n\n\t\t\t   target_sigset_t *set, CPUState *env)\n\n{\n\n\tstruct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame));\n\n\tint err = 0;\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))\n\n            return 1;\n\n#endif\n\n\t__put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);\n\n\t__put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);\n\n\terr |= copy_siginfo_to_user(&frame->info, info);\n\n\n\n\t/* Clear all the bits of the ucontext we don't use.  */\n\n\terr |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));\n\n\n\n\terr |= setup_sigcontext(&frame->uc.uc_mcontext, /*&frame->fpstate,*/\n\n\t\t\t\tenv, set->sig[0]);\n\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\n\n\n\tif (err == 0)\n\n\t\terr = setup_return(env, ka, &frame->retcode, frame, usig);\n\n\n\n\tif (err == 0) {\n\n\t\t/*\n\n\t\t * For realtime signals we must also set the second and third\n\n\t\t * arguments for the signal handler.\n\n\t\t *   -- Peter Maydell <pmaydell@chiark.greenend.org.uk> 2000-12-06\n\n\t\t */\n\n            env->regs[1] = (target_ulong)frame->pinfo;\n\n            env->regs[2] = (target_ulong)frame->puc;\n\n\t}\n\n\n\n        //\treturn err;\n\n}\n", "idx": 8145, "_split": "test", "_hash": "b980ba31ad583210715812457d86ba66"}
{"project": "qemu", "commit_id": "25e6a11832bcd0715068f0cc24fb46ec03de676e", "target": 1, "func": "static void spapr_phb_placement(sPAPRMachineState *spapr, uint32_t index,\n\n                                uint64_t *buid, hwaddr *pio,\n\n                                hwaddr *mmio32, hwaddr *mmio64,\n\n                                unsigned n_dma, uint32_t *liobns, Error **errp)\n\n{\n\n    /*\n\n     * New-style PHB window placement.\n\n     *\n\n     * Goals: Gives large (1TiB), naturally aligned 64-bit MMIO window\n\n     * for each PHB, in addition to 2GiB 32-bit MMIO and 64kiB PIO\n\n     * windows.\n\n     *\n\n     * Some guest kernels can't work with MMIO windows above 1<<46\n\n     * (64TiB), so we place up to 31 PHBs in the area 32TiB..64TiB\n\n     *\n\n     * 32TiB..(33TiB+1984kiB) contains the 64kiB PIO windows for each\n\n     * PHB stacked together.  (32TiB+2GiB)..(32TiB+64GiB) contains the\n\n     * 2GiB 32-bit MMIO windows for each PHB.  Then 33..64TiB has the\n\n     * 1TiB 64-bit MMIO windows for each PHB.\n\n     */\n\n    const uint64_t base_buid = 0x800000020000000ULL;\n\n    const int max_phbs =\n\n        (SPAPR_PCI_LIMIT - SPAPR_PCI_BASE) / SPAPR_PCI_MEM64_WIN_SIZE - 1;\n\n    int i;\n\n\n\n    /* Sanity check natural alignments */\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_BASE % SPAPR_PCI_MEM64_WIN_SIZE) != 0);\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_LIMIT % SPAPR_PCI_MEM64_WIN_SIZE) != 0);\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM64_WIN_SIZE % SPAPR_PCI_MEM32_WIN_SIZE) != 0);\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM32_WIN_SIZE % SPAPR_PCI_IO_WIN_SIZE) != 0);\n\n    /* Sanity check bounds */\n\n    QEMU_BUILD_BUG_ON((max_phbs * SPAPR_PCI_IO_WIN_SIZE) > SPAPR_PCI_MEM32_WIN_SIZE);\n\n    QEMU_BUILD_BUG_ON((max_phbs * SPAPR_PCI_MEM32_WIN_SIZE) > SPAPR_PCI_MEM64_WIN_SIZE);\n\n\n\n    if (index >= max_phbs) {\n\n        error_setg(errp, \"\\\"index\\\" for PAPR PHB is too large (max %u)\",\n\n                   max_phbs - 1);\n\n        return;\n\n    }\n\n\n\n    *buid = base_buid + index;\n\n    for (i = 0; i < n_dma; ++i) {\n\n        liobns[i] = SPAPR_PCI_LIOBN(index, i);\n\n    }\n\n\n\n    *pio = SPAPR_PCI_BASE + index * SPAPR_PCI_IO_WIN_SIZE;\n\n    *mmio32 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM32_WIN_SIZE;\n\n    *mmio64 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM64_WIN_SIZE;\n\n}\n", "idx": 8154, "_split": "test", "_hash": "de1aefd46df140b4e575f301129e8d69"}
{"project": "qemu", "commit_id": "fb6971c110387cf597b58c411658e3d15cc6c6fb", "target": 1, "func": "static void ppc405ep_compute_clocks (ppc405ep_cpc_t *cpc)\n\n{\n\n    uint32_t CPU_clk, PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk;\n\n    uint32_t UART0_clk, UART1_clk;\n\n    uint64_t VCO_out, PLL_out;\n\n    int M, D;\n\n\n\n    VCO_out = 0;\n\n    if ((cpc->pllmr[1] & 0x80000000) && !(cpc->pllmr[1] & 0x40000000)) {\n\n        M = (((cpc->pllmr[1] >> 20) - 1) & 0xF) + 1; /* FBMUL */\n\n#ifdef DEBUG_CLOCKS_LL\n\n        printf(\"FBMUL %01\" PRIx32 \" %d\\n\", (cpc->pllmr[1] >> 20) & 0xF, M);\n\n#endif\n\n        D = 8 - ((cpc->pllmr[1] >> 16) & 0x7); /* FWDA */\n\n#ifdef DEBUG_CLOCKS_LL\n\n        printf(\"FWDA %01\" PRIx32 \" %d\\n\", (cpc->pllmr[1] >> 16) & 0x7, D);\n\n#endif\n\n        VCO_out = cpc->sysclk * M * D;\n\n        if (VCO_out < 500000000UL || VCO_out > 1000000000UL) {\n\n            /* Error - unlock the PLL */\n\n            printf(\"VCO out of range %\" PRIu64 \"\\n\", VCO_out);\n\n#if 0\n\n            cpc->pllmr[1] &= ~0x80000000;\n\n            goto pll_bypass;\n\n#endif\n\n        }\n\n        PLL_out = VCO_out / D;\n\n        /* Pretend the PLL is locked */\n\n        cpc->boot |= 0x00000001;\n\n    } else {\n\n#if 0\n\n    pll_bypass:\n\n#endif\n\n        PLL_out = cpc->sysclk;\n\n        if (cpc->pllmr[1] & 0x40000000) {\n\n            /* Pretend the PLL is not locked */\n\n            cpc->boot &= ~0x00000001;\n\n        }\n\n    }\n\n    /* Now, compute all other clocks */\n\n    D = ((cpc->pllmr[0] >> 20) & 0x3) + 1; /* CCDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"CCDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 20) & 0x3, D);\n\n#endif\n\n    CPU_clk = PLL_out / D;\n\n    D = ((cpc->pllmr[0] >> 16) & 0x3) + 1; /* CBDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"CBDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 16) & 0x3, D);\n\n#endif\n\n    PLB_clk = CPU_clk / D;\n\n    D = ((cpc->pllmr[0] >> 12) & 0x3) + 1; /* OPDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"OPDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 12) & 0x3, D);\n\n#endif\n\n    OPB_clk = PLB_clk / D;\n\n    D = ((cpc->pllmr[0] >> 8) & 0x3) + 2; /* EPDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"EPDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 8) & 0x3, D);\n\n#endif\n\n    EBC_clk = PLB_clk / D;\n\n    D = ((cpc->pllmr[0] >> 4) & 0x3) + 1; /* MPDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"MPDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 4) & 0x3, D);\n\n#endif\n\n    MAL_clk = PLB_clk / D;\n\n    D = (cpc->pllmr[0] & 0x3) + 1; /* PPDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"PPDV %01\" PRIx32 \" %d\\n\", cpc->pllmr[0] & 0x3, D);\n\n#endif\n\n    PCI_clk = PLB_clk / D;\n\n    D = ((cpc->ucr - 1) & 0x7F) + 1; /* U0DIV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"U0DIV %01\" PRIx32 \" %d\\n\", cpc->ucr & 0x7F, D);\n\n#endif\n\n    UART0_clk = PLL_out / D;\n\n    D = (((cpc->ucr >> 8) - 1) & 0x7F) + 1; /* U1DIV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"U1DIV %01\" PRIx32 \" %d\\n\", (cpc->ucr >> 8) & 0x7F, D);\n\n#endif\n\n    UART1_clk = PLL_out / D;\n\n#ifdef DEBUG_CLOCKS\n\n    printf(\"Setup PPC405EP clocks - sysclk %\" PRIu32 \" VCO %\" PRIu64\n\n           \" PLL out %\" PRIu64 \" Hz\\n\", cpc->sysclk, VCO_out, PLL_out);\n\n    printf(\"CPU %\" PRIu32 \" PLB %\" PRIu32 \" OPB %\" PRIu32 \" EBC %\" PRIu32\n\n           \" MAL %\" PRIu32 \" PCI %\" PRIu32 \" UART0 %\" PRIu32\n\n           \" UART1 %\" PRIu32 \"\\n\",\n\n           CPU_clk, PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk,\n\n           UART0_clk, UART1_clk);\n\n#endif\n\n    /* Setup CPU clocks */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_CPU_CLK], CPU_clk);\n\n    /* Setup PLB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_PLB_CLK], PLB_clk);\n\n    /* Setup OPB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_OPB_CLK], OPB_clk);\n\n    /* Setup external clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_EBC_CLK], EBC_clk);\n\n    /* Setup MAL clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_MAL_CLK], MAL_clk);\n\n    /* Setup PCI clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_PCI_CLK], PCI_clk);\n\n    /* Setup UART0 clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_UART0_CLK], UART0_clk);\n\n    /* Setup UART1 clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_UART1_CLK], UART1_clk);\n\n}\n", "idx": 8155, "_split": "test", "_hash": "32bebc6eaf749c74a29adbe1d0696725"}
{"project": "qemu", "commit_id": "2e50326c44c802ca9b9d591341085e49208927be", "target": 1, "func": "void tap_fd_set_offload(int fd, int csum, int tso4,\n                        int tso6, int ecn, int ufo)\n{\n    unsigned int offload = 0;\n    if (csum) {\n        offload |= TUN_F_CSUM;\n        if (tso4)\n            offload |= TUN_F_TSO4;\n        if (tso6)\n            offload |= TUN_F_TSO6;\n        if ((tso4 || tso6) && ecn)\n            offload |= TUN_F_TSO_ECN;\n        if (ufo)\n            offload |= TUN_F_UFO;\n    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {\n        offload &= ~TUN_F_UFO;\n        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {\n            fprintf(stderr, \"TUNSETOFFLOAD ioctl() failed: %s\\n\",\n                    strerror(errno));", "idx": 8158, "_split": "test", "_hash": "17a14ddbffb5aff9b0ff820405122f33"}
{"project": "qemu", "commit_id": "29851ee7c8bd3fb8542e21cd0270c73132590350", "target": 1, "func": "int main()\n\n{\n\n    int rd, rt, dsp;\n\n    int result, resultdsp;\n\n\n\n    rt        = 0x12345678;\n\n    result    = 0xA000C000;\n\n    resultdsp = 1;\n\n\n\n    __asm\n\n        (\"shll.ph %0, %2, 0x0B\\n\\t\"\n\n         \"rddsp %1\\n\\t\"\n\n         : \"=r\"(rd), \"=r\"(dsp)\n\n         : \"r\"(rt)\n\n        );\n\n    dsp = (dsp >> 22) & 0x01;\n\n    assert(dsp == resultdsp);\n\n    assert(rd  == result);\n\n\n\n    return 0;\n\n}\n", "idx": 8209, "_split": "test", "_hash": "7401ee95e8dddac7e854e9ace11ad2b8"}
{"project": "qemu", "commit_id": "74892d2468b9f0c56b915ce94848d6f7fac39740", "target": 1, "func": "int vm_stop(RunState state)\n\n{\n\n    if (qemu_in_vcpu_thread()) {\n\n\n        qemu_system_vmstop_request(state);\n\n        /*\n\n         * FIXME: should not return to device code in case\n\n         * vm_stop() has been requested.\n\n         */\n\n        cpu_stop_current();\n\n        return 0;\n\n    }\n\n\n\n    return do_vm_stop(state);\n\n}", "idx": 8221, "_split": "test", "_hash": "244e906ebde2907236fcba39f2e58b45"}
{"project": "qemu", "commit_id": "f74990a5d019751c545e9800a3376b6336e77d38", "target": 0, "func": "static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])\n\n{\n\n    S390CPU *cpu = s390_env_get_cpu(env);\n\n    const unsigned long *features = cpu->model->features;\n\n    unsigned max_bit = 0;\n\n    S390Feat feat;\n\n\n\n    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);\n\n\n\n    if (test_bit(S390_FEAT_ZARCH, features)) {\n\n        /* z/Architecture is always active if around */\n\n        words[0] = 1ull << (63 - 2);\n\n    }\n\n\n\n    for (feat = find_first_bit(features, S390_FEAT_MAX);\n\n         feat < S390_FEAT_MAX;\n\n         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {\n\n        const S390FeatDef *def = s390_feat_def(feat);\n\n        if (def->type == S390_FEAT_TYPE_STFL) {\n\n            unsigned bit = def->bit;\n\n            if (bit > max_bit) {\n\n                max_bit = bit;\n\n            }\n\n            assert(bit / 64 < MAX_STFL_WORDS);\n\n            words[bit / 64] |= 1ULL << (63 - bit % 64);\n\n        }\n\n    }\n\n\n\n    return max_bit / 64;\n\n}\n", "idx": 8247, "_split": "test", "_hash": "b20a50c5c3a6cf49e325aa482f8c6244"}
{"project": "qemu", "commit_id": "185b43386ad999c80bdc58e41b87f05e5b3e8463", "target": 0, "func": "static int nbd_establish_connection(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n    int sock;\n\n    int ret;\n\n    off_t size;\n\n    size_t blocksize;\n\n\n\n    if (s->host_spec[0] == '/') {\n\n        sock = unix_socket_outgoing(s->host_spec);\n\n    } else {\n\n        sock = tcp_socket_outgoing_spec(s->host_spec);\n\n    }\n\n\n\n    /* Failed to establish connection */\n\n    if (sock < 0) {\n\n        logout(\"Failed to establish connection to NBD server\\n\");\n\n        return -errno;\n\n    }\n\n\n\n    /* NBD handshake */\n\n    ret = nbd_receive_negotiate(sock, s->export_name, &s->nbdflags, &size,\n\n                                &blocksize);\n\n    if (ret < 0) {\n\n        logout(\"Failed to negotiate with the NBD server\\n\");\n\n        closesocket(sock);\n\n        return -errno;\n\n    }\n\n\n\n    /* Now that we're connected, set the socket to be non-blocking and\n\n     * kick the reply mechanism.  */\n\n    socket_set_nonblock(sock);\n\n    qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL,\n\n                            nbd_have_request, NULL, s);\n\n\n\n    s->sock = sock;\n\n    s->size = size;\n\n    s->blocksize = blocksize;\n\n\n\n    logout(\"Established connection with NBD server\\n\");\n\n    return 0;\n\n}\n", "idx": 8254, "_split": "test", "_hash": "e894cd07e12dd6cc756ad4b69b4a9c57"}
{"project": "qemu", "commit_id": "524d18d8bd463431b120eeb5f9f3d1064a1c19e4", "target": 0, "func": "S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp)\n\n{\n\n    S390CPU *cpu;\n\n    Error *err = NULL;\n\n\n\n    cpu = cpu_s390x_create(cpu_model, &err);\n\n    if (err != NULL) {\n\n        goto out;\n\n    }\n\n\n\n    object_property_set_int(OBJECT(cpu), core_id, \"core-id\", &err);\n\n    if (err != NULL) {\n\n        goto out;\n\n    }\n\n    object_property_set_bool(OBJECT(cpu), true, \"realized\", &err);\n\n\n\nout:\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        object_unref(OBJECT(cpu));\n\n        cpu = NULL;\n\n    }\n\n    return cpu;\n\n}\n", "idx": 8291, "_split": "test", "_hash": "ecb08488ac263832bfc341e38fdf5f61"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "aio_compute_timeout(AioContext *ctx)\n\n{\n\n    int64_t deadline;\n\n    int timeout = -1;\n\n    QEMUBH *bh;\n\n\n\n    for (bh = atomic_rcu_read(&ctx->first_bh); bh;\n\n         bh = atomic_rcu_read(&bh->next)) {\n\n        if (bh->scheduled) {\n\n            if (bh->idle) {\n\n                /* idle bottom halves will be polled at least\n\n                 * every 10ms */\n\n                timeout = 10000000;\n\n            } else {\n\n                /* non-idle bottom halves will be executed\n\n                 * immediately */\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    deadline = timerlistgroup_deadline_ns(&ctx->tlg);\n\n    if (deadline == 0) {\n\n        return 0;\n\n    } else {\n\n        return qemu_soonest_timeout(timeout, deadline);\n\n    }\n\n}\n", "idx": 8296, "_split": "test", "_hash": "73e38804c0185dcff182c4cad8d4dca0"}
{"project": "qemu", "commit_id": "b061dc41f62048acd4a34c6570c0ea396cd9d0b4", "target": 1, "func": "static void type_initialize_interface(TypeImpl *ti, const char *parent)\n\n{\n\n    InterfaceClass *new_iface;\n\n    TypeInfo info = { };\n\n    TypeImpl *iface_impl;\n\n\n\n    info.parent = parent;\n\n    info.name = g_strdup_printf(\"%s::%s\", ti->name, info.parent);\n\n    info.abstract = true;\n\n\n\n    iface_impl = type_register(&info);\n\n    type_initialize(iface_impl);\n\n    g_free((char *)info.name);\n\n\n\n    new_iface = (InterfaceClass *)iface_impl->class;\n\n    new_iface->concrete_class = ti->class;\n\n\n\n    ti->class->interfaces = g_slist_append(ti->class->interfaces,\n\n                                           iface_impl->class);\n\n}\n", "idx": 8357, "_split": "test", "_hash": "b3160b74cab62f55d5fec353de56d096"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    struct nand_state_t *s = opaque;\n\n    uint32_t r;\n\n    int rdy;\n\n\n\n    r = nand_getio(s->nand);\n\n    nand_getpins(s->nand, &rdy);\n\n    s->rdy = rdy;\n\n\n\n    DNAND(printf(\"%s addr=%x r=%x\\n\", __func__, addr, r));\n\n    return r;\n\n}\n", "idx": 8380, "_split": "test", "_hash": "51cd188b621d341a9fa288265c4de2f4"}
{"project": "qemu", "commit_id": "442773cef15092b5927851237850760345d2cf16", "target": 0, "func": "void qmp_migrate_set_speed(int64_t value, Error **errp)\n\n{\n\n    MigrationState *s;\n\n\n\n    if (value < 0) {\n\n        value = 0;\n\n    }\n\n\n\n    s = migrate_get_current();\n\n    s->bandwidth_limit = value;\n\n    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);\n\n}\n", "idx": 8409, "_split": "test", "_hash": "d072e41ba40b2963f78f70a45ac6bf27"}
{"project": "qemu", "commit_id": "3d5d319e1221082974711af1d09d82f0755c1698", "target": 1, "func": "void block_job_resume_all(void)\n\n{\n\n    BlockJob *job = NULL;\n\n    while ((job = block_job_next(job))) {\n\n        AioContext *aio_context = blk_get_aio_context(job->blk);\n\n\n\n        aio_context_acquire(aio_context);\n\n        block_job_resume(job);\n\n        aio_context_release(aio_context);\n\n    }\n\n}\n", "idx": 8412, "_split": "test", "_hash": "f58bef3b94809a6825cfe5bd21b2058a"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_uint8(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint8_t *v = pv;\n\n    qemu_put_8s(f, v);\n\n}\n", "idx": 8431, "_split": "test", "_hash": "9b4bb69177bf44b86742d9be80fc53e8"}
{"project": "qemu", "commit_id": "61a36c9b5a12889994e6c45f4a175efcd63936db", "target": 1, "func": "static RemoveResult remove_hpte(PowerPCCPU *cpu, target_ulong ptex,\n\n                                target_ulong avpn,\n\n                                target_ulong flags,\n\n                                target_ulong *vp, target_ulong *rp)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    uint64_t token;\n\n    target_ulong v, r, rb;\n\n\n\n    if (!valid_pte_index(env, ptex)) {\n\n        return REMOVE_PARM;\n\n    }\n\n\n\n    token = ppc_hash64_start_access(cpu, ptex);\n\n    v = ppc_hash64_load_hpte0(cpu, token, 0);\n\n    r = ppc_hash64_load_hpte1(cpu, token, 0);\n\n    ppc_hash64_stop_access(token);\n\n\n\n    if ((v & HPTE64_V_VALID) == 0 ||\n\n        ((flags & H_AVPN) && (v & ~0x7fULL) != avpn) ||\n\n        ((flags & H_ANDCOND) && (v & avpn) != 0)) {\n\n        return REMOVE_NOT_FOUND;\n\n    }\n\n    *vp = v;\n\n    *rp = r;\n\n    ppc_hash64_store_hpte(cpu, ptex, HPTE64_V_HPTE_DIRTY, 0);\n\n    rb = compute_tlbie_rb(v, r, ptex);\n\n    ppc_tlb_invalidate_one(env, rb);\n\n    return REMOVE_SUCCESS;\n\n}\n", "idx": 8435, "_split": "test", "_hash": "655cb560cf0268d6066d0d17dfdb8b8b"}
{"project": "qemu", "commit_id": "33848ceed79679b5c9e558b768447af2614b8db2", "target": 1, "func": "int pcie_aer_init(PCIDevice *dev, uint16_t offset, uint16_t size)\n\n{\n\n    PCIExpressDevice *exp;\n\n\n\n    pcie_add_capability(dev, PCI_EXT_CAP_ID_ERR, PCI_ERR_VER,\n\n                        offset, size);\n\n    exp = &dev->exp;\n\n    exp->aer_cap = offset;\n\n\n\n    /* log_max is property */\n\n    if (dev->exp.aer_log.log_max == PCIE_AER_LOG_MAX_UNSET) {\n\n        dev->exp.aer_log.log_max = PCIE_AER_LOG_MAX_DEFAULT;\n\n    }\n\n    /* clip down the value to avoid unreasobale memory usage */\n\n    if (dev->exp.aer_log.log_max > PCIE_AER_LOG_MAX_LIMIT) {\n\n        return -EINVAL;\n\n    }\n\n    dev->exp.aer_log.log = g_malloc0(sizeof dev->exp.aer_log.log[0] *\n\n                                        dev->exp.aer_log.log_max);\n\n\n\n    pci_set_long(dev->w1cmask + offset + PCI_ERR_UNCOR_STATUS,\n\n                 PCI_ERR_UNC_SUPPORTED);\n\n\n\n    pci_set_long(dev->config + offset + PCI_ERR_UNCOR_SEVER,\n\n                 PCI_ERR_UNC_SEVERITY_DEFAULT);\n\n    pci_set_long(dev->wmask + offset + PCI_ERR_UNCOR_SEVER,\n\n                 PCI_ERR_UNC_SUPPORTED);\n\n\n\n    pci_long_test_and_set_mask(dev->w1cmask + offset + PCI_ERR_COR_STATUS,\n\n                               PCI_ERR_COR_SUPPORTED);\n\n\n\n    pci_set_long(dev->config + offset + PCI_ERR_COR_MASK,\n\n                 PCI_ERR_COR_MASK_DEFAULT);\n\n    pci_set_long(dev->wmask + offset + PCI_ERR_COR_MASK,\n\n                 PCI_ERR_COR_SUPPORTED);\n\n\n\n    /* capabilities and control. multiple header logging is supported */\n\n    if (dev->exp.aer_log.log_max > 0) {\n\n        pci_set_long(dev->config + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENC | PCI_ERR_CAP_ECRC_CHKC |\n\n                     PCI_ERR_CAP_MHRC);\n\n        pci_set_long(dev->wmask + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE |\n\n                     PCI_ERR_CAP_MHRE);\n\n    } else {\n\n        pci_set_long(dev->config + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENC | PCI_ERR_CAP_ECRC_CHKC);\n\n        pci_set_long(dev->wmask + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE);\n\n    }\n\n\n\n    switch (pcie_cap_get_type(dev)) {\n\n    case PCI_EXP_TYPE_ROOT_PORT:\n\n        /* this case will be set by pcie_aer_root_init() */\n\n        /* fallthrough */\n\n    case PCI_EXP_TYPE_DOWNSTREAM:\n\n    case PCI_EXP_TYPE_UPSTREAM:\n\n        pci_word_test_and_set_mask(dev->wmask + PCI_BRIDGE_CONTROL,\n\n                                   PCI_BRIDGE_CTL_SERR);\n\n        pci_long_test_and_set_mask(dev->w1cmask + PCI_STATUS,\n\n                                   PCI_SEC_STATUS_RCV_SYSTEM_ERROR);\n\n        break;\n\n    default:\n\n        /* nothing */\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 8447, "_split": "test", "_hash": "810085a11429ccd5940285d4b8572775"}
{"project": "qemu", "commit_id": "372579427a5040a26dfee78464b50e2bdf27ef26", "target": 1, "func": "static void qemu_tcg_init_vcpu(CPUState *cpu)\n\n{\n\n    char thread_name[VCPU_THREAD_NAME_SIZE];\n\n    static QemuCond *tcg_halt_cond;\n\n    static QemuThread *tcg_cpu_thread;\n\n\n\n    /* share a single thread for all cpus with TCG */\n\n    if (!tcg_cpu_thread) {\n\n        cpu->thread = g_malloc0(sizeof(QemuThread));\n\n        cpu->halt_cond = g_malloc0(sizeof(QemuCond));\n\n        qemu_cond_init(cpu->halt_cond);\n\n        tcg_halt_cond = cpu->halt_cond;\n\n        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, \"CPU %d/TCG\",\n\n                 cpu->cpu_index);\n\n        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,\n\n                           cpu, QEMU_THREAD_JOINABLE);\n\n#ifdef _WIN32\n\n        cpu->hThread = qemu_thread_get_handle(cpu->thread);\n\n#endif\n\n        while (!cpu->created) {\n\n            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);\n\n        }\n\n        tcg_cpu_thread = cpu->thread;\n\n    } else {\n\n        cpu->thread = tcg_cpu_thread;\n\n        cpu->halt_cond = tcg_halt_cond;\n\n    }\n\n}\n", "idx": 8457, "_split": "test", "_hash": "9fa0aac732eaa7745860db7d0dc7b204"}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)\n\n{\n\n    ssize_t ret;\n\n#ifdef CONFIG_VNC_TLS\n\n    if (vs->tls.session) {\n\n        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);\n\n    } else {\n\n#endif /* CONFIG_VNC_TLS */\n\n        ret = send(vs->csock, (const void *)data, datalen, 0);\n\n#ifdef CONFIG_VNC_TLS\n\n    }\n\n#endif /* CONFIG_VNC_TLS */\n\n    VNC_DEBUG(\"Wrote wire %p %zd -> %ld\\n\", data, datalen, ret);\n\n    return vnc_client_io_error(vs, ret, socket_error());\n\n}\n", "idx": 8466, "_split": "test", "_hash": "adebff330c391a46947aa43c4e36887e"}
{"project": "qemu", "commit_id": "e1622f4b15391bd44eb0f99a244fdf19a20fd981", "target": 1, "func": "static int memory_access_size(MemoryRegion *mr, unsigned l, hwaddr addr)\n\n{\n\n    unsigned access_size_min = mr->ops->impl.min_access_size;\n\n    unsigned access_size_max = mr->ops->impl.max_access_size;\n\n\n\n    /* Regions are assumed to support 1-4 byte accesses unless\n\n       otherwise specified.  */\n\n    if (access_size_min == 0) {\n\n        access_size_min = 1;\n\n    }\n\n    if (access_size_max == 0) {\n\n        access_size_max = 4;\n\n    }\n\n\n\n    /* Bound the maximum access by the alignment of the address.  */\n\n    if (!mr->ops->impl.unaligned) {\n\n        unsigned align_size_max = addr & -addr;\n\n        if (align_size_max != 0 && align_size_max < access_size_max) {\n\n            access_size_max = align_size_max;\n\n        }\n\n    }\n\n\n\n    /* Don't attempt accesses larger than the maximum.  */\n\n    if (l > access_size_max) {\n\n        l = access_size_max;\n\n    }\n\n    /* ??? The users of this function are wrong, not supporting minimums larger\n\n       than the remaining length.  C.f. memory.c:access_with_adjusted_size.  */\n\n    assert(l >= access_size_min);\n\n\n\n    return l;\n\n}\n", "idx": 8518, "_split": "test", "_hash": "c0757d3eb929cc71a8ee60213cda2369"}
{"project": "qemu", "commit_id": "d6b6abc51dda79a97f2c7bd6652c1940c068f1ec", "target": 1, "func": "void fw_cfg_add_file_callback(FWCfgState *s,  const char *filename,\n\n                              FWCfgCallback select_cb,\n\n                              FWCfgWriteCallback write_cb,\n\n                              void *callback_opaque,\n\n                              void *data, size_t len, bool read_only)\n\n{\n\n    int i, index, count;\n\n    size_t dsize;\n\n    MachineClass *mc = MACHINE_GET_CLASS(qdev_get_machine());\n\n    int order = 0;\n\n\n\n    if (!s->files) {\n\n        dsize = sizeof(uint32_t) + sizeof(FWCfgFile) * fw_cfg_file_slots(s);\n\n        s->files = g_malloc0(dsize);\n\n        fw_cfg_add_bytes(s, FW_CFG_FILE_DIR, s->files, dsize);\n\n    }\n\n\n\n    count = be32_to_cpu(s->files->count);\n\n    assert(count < fw_cfg_file_slots(s));\n\n\n\n    /* Find the insertion point. */\n\n    if (mc->legacy_fw_cfg_order) {\n\n        /*\n\n         * Sort by order. For files with the same order, we keep them\n\n         * in the sequence in which they were added.\n\n         */\n\n        order = get_fw_cfg_order(s, filename);\n\n        for (index = count;\n\n             index > 0 && order < s->entry_order[index - 1];\n\n             index--);\n\n    } else {\n\n        /* Sort by file name. */\n\n        for (index = count;\n\n             index > 0 && strcmp(filename, s->files->f[index - 1].name) < 0;\n\n             index--);\n\n    }\n\n\n\n    /*\n\n     * Move all the entries from the index point and after down one\n\n     * to create a slot for the new entry.  Because calculations are\n\n     * being done with the index, make it so that \"i\" is the current\n\n     * index and \"i - 1\" is the one being copied from, thus the\n\n     * unusual start and end in the for statement.\n\n     */\n\n    for (i = count + 1; i > index; i--) {\n\n        s->files->f[i] = s->files->f[i - 1];\n\n        s->files->f[i].select = cpu_to_be16(FW_CFG_FILE_FIRST + i);\n\n        s->entries[0][FW_CFG_FILE_FIRST + i] =\n\n            s->entries[0][FW_CFG_FILE_FIRST + i - 1];\n\n        s->entry_order[i] = s->entry_order[i - 1];\n\n    }\n\n\n\n    memset(&s->files->f[index], 0, sizeof(FWCfgFile));\n\n    memset(&s->entries[0][FW_CFG_FILE_FIRST + index], 0, sizeof(FWCfgEntry));\n\n\n\n    pstrcpy(s->files->f[index].name, sizeof(s->files->f[index].name), filename);\n\n    for (i = 0; i <= count; i++) {\n\n        if (i != index &&\n\n            strcmp(s->files->f[index].name, s->files->f[i].name) == 0) {\n\n            error_report(\"duplicate fw_cfg file name: %s\",\n\n                         s->files->f[index].name);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    fw_cfg_add_bytes_callback(s, FW_CFG_FILE_FIRST + index,\n\n                              select_cb, write_cb,\n\n                              callback_opaque, data, len,\n\n                              read_only);\n\n\n\n    s->files->f[index].size   = cpu_to_be32(len);\n\n    s->files->f[index].select = cpu_to_be16(FW_CFG_FILE_FIRST + index);\n\n    s->entry_order[index] = order;\n\n    trace_fw_cfg_add_file(s, index, s->files->f[index].name, len);\n\n\n\n    s->files->count = cpu_to_be32(count+1);\n\n}\n", "idx": 8522, "_split": "test", "_hash": "db48eeab6f04fd36b12439e4e3235957"}
{"project": "qemu", "commit_id": "2e1198672759eda6e122ff38fcf6df06f27e0fe2", "target": 1, "func": "static void stellaris_enet_save(QEMUFile *f, void *opaque)\n\n{\n\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n\n    int i;\n\n\n\n    qemu_put_be32(f, s->ris);\n\n    qemu_put_be32(f, s->im);\n\n    qemu_put_be32(f, s->rctl);\n\n    qemu_put_be32(f, s->tctl);\n\n    qemu_put_be32(f, s->thr);\n\n    qemu_put_be32(f, s->mctl);\n\n    qemu_put_be32(f, s->mdv);\n\n    qemu_put_be32(f, s->mtxd);\n\n    qemu_put_be32(f, s->mrxd);\n\n    qemu_put_be32(f, s->np);\n\n    qemu_put_be32(f, s->tx_fifo_len);\n\n    qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n\n    for (i = 0; i < 31; i++) {\n\n        qemu_put_be32(f, s->rx[i].len);\n\n        qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n\n\n\n    }\n\n    qemu_put_be32(f, s->next_packet);\n\n    qemu_put_be32(f, s->rx_fifo_offset);\n\n}\n", "idx": 8526, "_split": "test", "_hash": "db4e7a8913d7489efb7b7fa29dd99db4"}
{"project": "qemu", "commit_id": "091b1108ca6d6e3bfaea5f095f219bf5ea8c316b", "target": 1, "func": "static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *num_same)\n\n{\n\n    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;\n\n    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;\n\n    uint8_t bitmap[BDRV_SECTOR_SIZE];\n\n    int ret;\n\n    int changed;\n\n\n\n    ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    bitnum &= BITS_PER_BITMAP_SECTOR - 1;\n\n    changed = cow_test_bit(bitnum, bitmap);\n\n    *num_same = cow_find_streak(bitmap, changed, bitnum, nb_sectors);\n\n    return changed;\n\n}\n", "idx": 8543, "_split": "test", "_hash": "ad38b6302e8f3484591285e320b75a65"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "bool timerlist_expired(QEMUTimerList *timer_list)\n\n{\n\n    int64_t expire_time;\n\n\n\n    if (!atomic_read(&timer_list->active_timers)) {\n\n        return false;\n\n    }\n\n\n\n    qemu_mutex_lock(&timer_list->active_timers_lock);\n\n    if (!timer_list->active_timers) {\n\n        qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n        return false;\n\n    }\n\n    expire_time = timer_list->active_timers->expire_time;\n\n    qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n\n\n    return expire_time < qemu_clock_get_ns(timer_list->clock->type);\n\n}\n", "idx": 8565, "_split": "test", "_hash": "3464402240d32462507115b389d7b329"}
{"project": "qemu", "commit_id": "e97fc193e1c65deb51643d5251e98affe07c59ca", "target": 0, "func": "static void check_refcounts(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t size;\n\n    int nb_clusters, refcount1, refcount2, i;\n\n    QCowSnapshot *sn;\n\n    uint16_t *refcount_table;\n\n\n\n    size = bdrv_getlength(s->hd);\n\n    nb_clusters = size_to_clusters(s, size);\n\n    refcount_table = qemu_mallocz(nb_clusters * sizeof(uint16_t));\n\n\n\n    /* header */\n\n    inc_refcounts(bs, refcount_table, nb_clusters,\n\n                  0, s->cluster_size);\n\n\n\n    check_refcounts_l1(bs, refcount_table, nb_clusters,\n\n                       s->l1_table_offset, s->l1_size, 1);\n\n\n\n    /* snapshots */\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        check_refcounts_l1(bs, refcount_table, nb_clusters,\n\n                           sn->l1_table_offset, sn->l1_size, 0);\n\n    }\n\n    inc_refcounts(bs, refcount_table, nb_clusters,\n\n                  s->snapshots_offset, s->snapshots_size);\n\n\n\n    /* refcount data */\n\n    inc_refcounts(bs, refcount_table, nb_clusters,\n\n                  s->refcount_table_offset,\n\n                  s->refcount_table_size * sizeof(uint64_t));\n\n    for(i = 0; i < s->refcount_table_size; i++) {\n\n        int64_t offset;\n\n        offset = s->refcount_table[i];\n\n        if (offset != 0) {\n\n            inc_refcounts(bs, refcount_table, nb_clusters,\n\n                          offset, s->cluster_size);\n\n        }\n\n    }\n\n\n\n    /* compare ref counts */\n\n    for(i = 0; i < nb_clusters; i++) {\n\n        refcount1 = get_refcount(bs, i);\n\n        refcount2 = refcount_table[i];\n\n        if (refcount1 != refcount2)\n\n            fprintf(stderr, \"ERROR cluster %d refcount=%d reference=%d\\n\",\n\n                   i, refcount1, refcount2);\n\n    }\n\n\n\n    qemu_free(refcount_table);\n\n}\n", "idx": 8568, "_split": "test", "_hash": "fda00c1f4ce959d4f146608384636d48"}
{"project": "qemu", "commit_id": "456d60692310e7ac25cf822cc1e98192ad636ece", "target": 1, "func": "static int ipoctal_init(IPackDevice *ip)\n\n{\n\n    IPOctalState *s = IPOCTAL(ip);\n\n    unsigned i;\n\n\n\n    for (i = 0; i < N_CHANNELS; i++) {\n\n        SCC2698Channel *ch = &s->ch[i];\n\n        ch->ipoctal = s;\n\n\n\n        /* Redirect IP-Octal channels to host character devices */\n\n        if (ch->devpath) {\n\n            const char chr_name[] = \"ipoctal\";\n\n            char label[ARRAY_SIZE(chr_name) + 2];\n\n            static int index;\n\n\n\n            snprintf(label, sizeof(label), \"%s%d\", chr_name, index);\n\n\n\n            ch->dev = qemu_chr_new(label, ch->devpath, NULL);\n\n\n\n            if (ch->dev) {\n\n                index++;\n\n\n                qemu_chr_add_handlers(ch->dev, hostdev_can_receive,\n\n                                      hostdev_receive, hostdev_event, ch);\n\n                DPRINTF(\"Redirecting channel %u to %s (%s)\\n\",\n\n                        i, ch->devpath, label);\n\n            } else {\n\n                DPRINTF(\"Could not redirect channel %u to %s\\n\",\n\n                        i, ch->devpath);\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 8577, "_split": "test", "_hash": "668c766fabecfbac560a00a29d4911ff"}
{"project": "qemu", "commit_id": "8417cebfda193c7f9ca70be5e308eaa92cf84b94", "target": 1, "func": "static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)\n\n{\n\n    uint64_t start = MAX(r1.start, r2.start);\n\n    /* off-by-one arithmetic to prevent overflow */\n\n    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);\n\n    return addrrange_make(start, end - start + 1);\n\n}\n", "idx": 8592, "_split": "test", "_hash": "114af4e521fec22a7b71ad584aeca17c"}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static int64_t do_strtosz(const char *nptr, char **end,\n\n                          const char default_suffix, int64_t unit)\n\n{\n\n    int64_t retval;\n\n    char *endptr;\n\n    unsigned char c;\n\n    int mul_required = 0;\n\n    double val, mul, integral, fraction;\n\n\n\n    errno = 0;\n\n    val = strtod(nptr, &endptr);\n\n    if (isnan(val) || endptr == nptr || errno != 0) {\n\n        retval = -EINVAL;\n\n        goto out;\n\n    }\n\n    fraction = modf(val, &integral);\n\n    if (fraction != 0) {\n\n        mul_required = 1;\n\n    }\n\n    c = *endptr;\n\n    mul = suffix_mul(c, unit);\n\n    if (mul >= 0) {\n\n        endptr++;\n\n    } else {\n\n        mul = suffix_mul(default_suffix, unit);\n\n        assert(mul >= 0);\n\n    }\n\n    if (mul == 1 && mul_required) {\n\n        retval = -EINVAL;\n\n        goto out;\n\n    }\n\n    if ((val * mul >= INT64_MAX) || val < 0) {\n\n        retval = -ERANGE;\n\n        goto out;\n\n    }\n\n    retval = val * mul;\n\n\n\nout:\n\n    if (end) {\n\n        *end = endptr;\n\n    } else if (*endptr) {\n\n        retval = -EINVAL;\n\n    }\n\n\n\n    return retval;\n\n}\n", "idx": 8673, "_split": "test", "_hash": "b951115db1839fd3f7b67d414f5c765c"}
{"project": "qemu", "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194", "target": 1, "func": "static int check_refcounts_l1(BlockDriverState *bs,\n\n                              BdrvCheckResult *res,\n\n                              uint16_t **refcount_table,\n\n                              int64_t *refcount_table_size,\n\n                              int64_t l1_table_offset, int l1_size,\n\n                              int flags)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l1_table = NULL, l2_offset, l1_size2;\n\n    int i, ret;\n\n\n\n    l1_size2 = l1_size * sizeof(uint64_t);\n\n\n\n    /* Mark L1 table as used */\n\n    ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                        l1_table_offset, l1_size2);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Read L1 table entries from disk */\n\n    if (l1_size2 > 0) {\n\n        l1_table = g_try_malloc(l1_size2);\n\n        if (l1_table == NULL) {\n\n            ret = -ENOMEM;\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n        ret = bdrv_pread(bs->file, l1_table_offset, l1_table, l1_size2);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR: I/O error in check_refcounts_l1\\n\");\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n        for(i = 0;i < l1_size; i++)\n\n            be64_to_cpus(&l1_table[i]);\n\n    }\n\n\n\n    /* Do the actual checks */\n\n    for(i = 0; i < l1_size; i++) {\n\n        l2_offset = l1_table[i];\n\n        if (l2_offset) {\n\n            /* Mark L2 table as used */\n\n            l2_offset &= L1E_OFFSET_MASK;\n\n            ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                                l2_offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            /* L2 tables are cluster aligned */\n\n            if (offset_into_cluster(s, l2_offset)) {\n\n                fprintf(stderr, \"ERROR l2_offset=%\" PRIx64 \": Table is not \"\n\n                    \"cluster aligned; L1 entry corrupted\\n\", l2_offset);\n\n                res->corruptions++;\n\n            }\n\n\n\n            /* Process and check L2 entries */\n\n            ret = check_refcounts_l2(bs, res, refcount_table,\n\n                                     refcount_table_size, l2_offset, flags);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n    g_free(l1_table);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(l1_table);\n\n    return ret;\n\n}\n", "idx": 8707, "_split": "test", "_hash": "fa80f3cc5589ea3207514bf50848d588"}
{"project": "qemu", "commit_id": "5a1972c8472fafd519a68b689fdcaf33ec857945", "target": 1, "func": "static uint32_t dcr_read_pob (void *opaque, int dcrn)\n\n{\n\n    ppc4xx_pob_t *pob;\n\n    uint32_t ret;\n\n\n\n    pob = opaque;\n\n    switch (dcrn) {\n\n    case POB0_BEAR:\n\n        ret = pob->bear;\n\n        break;\n\n    case POB0_BESR0:\n\n    case POB0_BESR1:\n\n        ret = pob->besr[dcrn - POB0_BESR0];\n\n        break;\n\n    default:\n\n        /* Avoid gcc warning */\n\n        ret = 0;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 8720, "_split": "test", "_hash": "09a788fb87d4f1e9cdd759e6d2bd3284"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline int onenand_erase(OneNANDState *s, int sec, int num)\n\n{\n\n    uint8_t *blankbuf, *tmpbuf;\n\n    blankbuf = g_malloc(512);\n\n    if (!blankbuf) {\n\n        return 1;\n\n    }\n\n    tmpbuf = g_malloc(512);\n\n    if (!tmpbuf) {\n\n        g_free(blankbuf);\n\n        return 1;\n\n    }\n\n    memset(blankbuf, 0xff, 512);\n\n    for (; num > 0; num--, sec++) {\n\n        if (s->bdrv_cur) {\n\n            int erasesec = s->secs_cur + (sec >> 5);\n\n            if (bdrv_write(s->bdrv_cur, sec, blankbuf, 1) < 0) {\n\n                goto fail;\n\n            }\n\n            if (bdrv_read(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {\n\n                goto fail;\n\n            }\n\n            memcpy(tmpbuf + ((sec & 31) << 4), blankbuf, 1 << 4);\n\n            if (bdrv_write(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {\n\n                goto fail;\n\n            }\n\n        } else {\n\n            if (sec + 1 > s->secs_cur) {\n\n                goto fail;\n\n            }\n\n            memcpy(s->current + (sec << 9), blankbuf, 512);\n\n            memcpy(s->current + (s->secs_cur << 9) + (sec << 4),\n\n                   blankbuf, 1 << 4);\n\n        }\n\n    }\n\n\n\n    g_free(tmpbuf);\n\n    g_free(blankbuf);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(tmpbuf);\n\n    g_free(blankbuf);\n\n    return 1;\n\n}\n", "idx": 8755, "_split": "test", "_hash": "b395d63cf6c3961dabd007b9111af88f"}
{"project": "qemu", "commit_id": "ff74f33c310892c90c4439d963a6ce67f47ce18c", "target": 1, "func": "static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,\n\n                              const char *desc_file_path, Error **errp)\n\n{\n\n    int ret;\n\n    char access[11];\n\n    char type[11];\n\n    char fname[512];\n\n    const char *p = desc;\n\n    int64_t sectors = 0;\n\n    int64_t flat_offset;\n\n    char extent_path[PATH_MAX];\n\n    BlockDriverState *extent_file;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    VmdkExtent *extent;\n\n\n\n    while (*p) {\n\n        /* parse extent line:\n\n         * RW [size in sectors] FLAT \"file-name.vmdk\" OFFSET\n\n         * or\n\n         * RW [size in sectors] SPARSE \"file-name.vmdk\"\n\n         */\n\n        flat_offset = -1;\n\n        ret = sscanf(p, \"%10s %\" SCNd64 \" %10s \\\"%511[^\\n\\r\\\"]\\\" %\" SCNd64,\n\n                access, &sectors, type, fname, &flat_offset);\n\n        if (ret < 4 || strcmp(access, \"RW\")) {\n\n            goto next_line;\n\n        } else if (!strcmp(type, \"FLAT\")) {\n\n            if (ret != 5 || flat_offset < 0) {\n\n                error_setg(errp, \"Invalid extent lines: \\n%s\", p);\n\n                return -EINVAL;\n\n            }\n\n        } else if (!strcmp(type, \"VMFS\")) {\n\n            if (ret == 4) {\n\n                flat_offset = 0;\n\n            } else {\n\n                error_setg(errp, \"Invalid extent lines:\\n%s\", p);\n\n                return -EINVAL;\n\n            }\n\n        } else if (ret != 4) {\n\n            error_setg(errp, \"Invalid extent lines:\\n%s\", p);\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (sectors <= 0 ||\n\n            (strcmp(type, \"FLAT\") && strcmp(type, \"SPARSE\") &&\n\n             strcmp(type, \"VMFS\") && strcmp(type, \"VMFSSPARSE\")) ||\n\n            (strcmp(access, \"RW\"))) {\n\n            goto next_line;\n\n        }\n\n\n\n        path_combine(extent_path, sizeof(extent_path),\n\n                desc_file_path, fname);\n\n        extent_file = NULL;\n\n        ret = bdrv_open(&extent_file, extent_path, NULL, NULL,\n\n                        bs->open_flags | BDRV_O_PROTOCOL, NULL, errp);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        /* save to extents array */\n\n        if (!strcmp(type, \"FLAT\") || !strcmp(type, \"VMFS\")) {\n\n            /* FLAT extent */\n\n\n\n            ret = vmdk_add_extent(bs, extent_file, true, sectors,\n\n                            0, 0, 0, 0, 0, &extent, errp);\n\n            if (ret < 0) {\n\n\n                return ret;\n\n            }\n\n            extent->flat_start_offset = flat_offset << 9;\n\n        } else if (!strcmp(type, \"SPARSE\") || !strcmp(type, \"VMFSSPARSE\")) {\n\n            /* SPARSE extent and VMFSSPARSE extent are both \"COWD\" sparse file*/\n\n            char *buf = vmdk_read_desc(extent_file, 0, errp);\n\n            if (!buf) {\n\n                ret = -EINVAL;\n\n            } else {\n\n                ret = vmdk_open_sparse(bs, extent_file, bs->open_flags, buf, errp);\n\n            }\n\n            if (ret) {\n\n                g_free(buf);\n\n\n                return ret;\n\n            }\n\n            extent = &s->extents[s->num_extents - 1];\n\n        } else {\n\n            error_setg(errp, \"Unsupported extent type '%s'\", type);\n\n\n            return -ENOTSUP;\n\n        }\n\n        extent->type = g_strdup(type);\n\nnext_line:\n\n        /* move to next line */\n\n        while (*p) {\n\n            if (*p == '\\n') {\n\n                p++;\n\n                break;\n\n            }\n\n            p++;\n\n        }\n\n    }\n\n    return 0;\n\n}", "idx": 8793, "_split": "test", "_hash": "442ca224b9fe054b866b421ba0204a29"}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static ssize_t socket_read(int sockfd, void *buff, size_t size)\n\n{\n\n    ssize_t retval, total = 0;\n\n\n\n    while (size) {\n\n        retval = read(sockfd, buff, size);\n\n        if (retval == 0) {\n\n            return -EIO;\n\n        }\n\n        if (retval < 0) {\n\n            if (errno == EINTR) {\n\n                continue;\n\n            }\n\n            return -errno;\n\n        }\n\n        size -= retval;\n\n        buff += retval;\n\n        total += retval;\n\n    }\n\n    return total;\n\n}\n", "idx": 8846, "_split": "test", "_hash": "a2a1a473e4c39df70c2a5684c2a970ab"}
{"project": "qemu", "commit_id": "4981bdec0d9b3ddd3e1474de5aa9918f120b54f7", "target": 0, "func": "AioContext *blk_get_aio_context(BlockBackend *blk)\n\n{\n\n    return bdrv_get_aio_context(blk->bs);\n\n}\n", "idx": 8855, "_split": "test", "_hash": "1f61a70f318de4ffbba7f469d3fa2027"}
{"project": "qemu", "commit_id": "6f864e6ec8812d5a5525a7861ca599c6bcabdebe", "target": 0, "func": "static int vfio_load_rom(VFIODevice *vdev)\n\n{\n\n    uint64_t size = vdev->rom_size;\n\n    char name[32];\n\n    off_t off = 0, voff = vdev->rom_offset;\n\n    ssize_t bytes;\n\n    void *ptr;\n\n\n\n    /* If loading ROM from file, pci handles it */\n\n    if (vdev->pdev.romfile || !vdev->pdev.rom_bar || !size) {\n\n        return 0;\n\n    }\n\n\n\n    DPRINTF(\"%s(%04x:%02x:%02x.%x)\\n\", __func__, vdev->host.domain,\n\n            vdev->host.bus, vdev->host.slot, vdev->host.function);\n\n\n\n    snprintf(name, sizeof(name), \"vfio[%04x:%02x:%02x.%x].rom\",\n\n             vdev->host.domain, vdev->host.bus, vdev->host.slot,\n\n             vdev->host.function);\n\n    memory_region_init_ram(&vdev->pdev.rom, OBJECT(vdev), name, size);\n\n    ptr = memory_region_get_ram_ptr(&vdev->pdev.rom);\n\n    memset(ptr, 0xff, size);\n\n\n\n    while (size) {\n\n        bytes = pread(vdev->fd, ptr + off, size, voff + off);\n\n        if (bytes == 0) {\n\n            break; /* expect that we could get back less than the ROM BAR */\n\n        } else if (bytes > 0) {\n\n            off += bytes;\n\n            size -= bytes;\n\n        } else {\n\n            if (errno == EINTR || errno == EAGAIN) {\n\n                continue;\n\n            }\n\n            error_report(\"vfio: Error reading device ROM: %m\");\n\n            memory_region_destroy(&vdev->pdev.rom);\n\n            return -errno;\n\n        }\n\n    }\n\n\n\n    pci_register_bar(&vdev->pdev, PCI_ROM_SLOT, 0, &vdev->pdev.rom);\n\n    vdev->pdev.has_rom = true;\n\n    return 0;\n\n}\n", "idx": 8858, "_split": "test", "_hash": "a5a4dfbb442e0e63f10a143b722da7e9"}
{"project": "qemu", "commit_id": "9c5ce8db2e5c2769ed2fd3d91928dd1853b5ce7c", "target": 0, "func": "UuidInfo *qmp_query_uuid(Error **errp)\n\n{\n\n    UuidInfo *info = g_malloc0(sizeof(*info));\n\n    char uuid[64];\n\n\n\n    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],\n\n                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],\n\n                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],\n\n                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],\n\n                   qemu_uuid[14], qemu_uuid[15]);\n\n\n\n    info->UUID = g_strdup(uuid);\n\n    return info;\n\n}\n", "idx": 8866, "_split": "test", "_hash": "ed451ce36d6838e02a275039d119185e"}
{"project": "qemu", "commit_id": "5b456438f5bb395ed6b1eec95e18ce7a7a884a0a", "target": 1, "func": "static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)\n\n{\n\n    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n\n\n    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));\n\n    if (qdev_init(vdev) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    object_property_set_link(OBJECT(dev),\n\n                             OBJECT(dev->vdev.conf.default_backend), \"rng\",\n\n                             NULL);\n\n\n\n    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));\n\n}\n", "idx": 8903, "_split": "test", "_hash": "7ff50568c02d53dad92cab0b2ad01152"}
{"project": "qemu", "commit_id": "0fbfbb59a9766247be20023b17eb7872e7b29323", "target": 0, "func": "static void apic_update_irq(APICState *s)\n\n{\n\n    int irrv, ppr;\n\n    if (!(s->spurious_vec & APIC_SV_ENABLE))\n\n        return;\n\n    irrv = get_highest_priority_int(s->irr);\n\n    if (irrv < 0)\n\n        return;\n\n    ppr = apic_get_ppr(s);\n\n    if (ppr && (irrv & 0xf0) <= (ppr & 0xf0))\n\n        return;\n\n    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);\n\n}\n", "idx": 8927, "_split": "test", "_hash": "e484e18bc73219f795bded4becad9475"}
{"project": "qemu", "commit_id": "41ecc72ba5932381208e151bf2d2149a0342beff", "target": 0, "func": "setup_sigcontext(struct target_sigcontext *sc, struct target_fpstate *fpstate,\n\n\t\t CPUX86State *env, abi_ulong mask, abi_ulong fpstate_addr)\n\n{\n\n    CPUState *cs = CPU(x86_env_get_cpu(env));\n\n    int err = 0;\n\n    uint16_t magic;\n\n\n\n\t/* already locked in setup_frame() */\n\n    __put_user(env->segs[R_GS].selector, (unsigned int *)&sc->gs);\n\n    __put_user(env->segs[R_FS].selector, (unsigned int *)&sc->fs);\n\n    __put_user(env->segs[R_ES].selector, (unsigned int *)&sc->es);\n\n    __put_user(env->segs[R_DS].selector, (unsigned int *)&sc->ds);\n\n    __put_user(env->regs[R_EDI], &sc->edi);\n\n    __put_user(env->regs[R_ESI], &sc->esi);\n\n    __put_user(env->regs[R_EBP], &sc->ebp);\n\n    __put_user(env->regs[R_ESP], &sc->esp);\n\n    __put_user(env->regs[R_EBX], &sc->ebx);\n\n    __put_user(env->regs[R_EDX], &sc->edx);\n\n    __put_user(env->regs[R_ECX], &sc->ecx);\n\n    __put_user(env->regs[R_EAX], &sc->eax);\n\n    __put_user(cs->exception_index, &sc->trapno);\n\n    __put_user(env->error_code, &sc->err);\n\n    __put_user(env->eip, &sc->eip);\n\n    __put_user(env->segs[R_CS].selector, (unsigned int *)&sc->cs);\n\n    __put_user(env->eflags, &sc->eflags);\n\n    __put_user(env->regs[R_ESP], &sc->esp_at_signal);\n\n    __put_user(env->segs[R_SS].selector, (unsigned int *)&sc->ss);\n\n\n\n        cpu_x86_fsave(env, fpstate_addr, 1);\n\n        fpstate->status = fpstate->sw;\n\n        magic = 0xffff;\n\n    __put_user(magic, &fpstate->magic);\n\n    __put_user(fpstate_addr, &sc->fpstate);\n\n\n\n\t/* non-iBCS2 extensions.. */\n\n    __put_user(mask, &sc->oldmask);\n\n    __put_user(env->cr[2], &sc->cr2);\n\n\treturn err;\n\n}\n", "idx": 8931, "_split": "test", "_hash": "6d70b952acb610ff25fa7255c979f1d6"}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static void coroutine_fn qed_aio_complete(QEDAIOCB *acb)\n\n{\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n\n\n    /* Free resources */\n\n    qemu_iovec_destroy(&acb->cur_qiov);\n\n    qed_unref_l2_cache_entry(acb->request.l2_table);\n\n\n\n    /* Free the buffer we may have allocated for zero writes */\n\n    if (acb->flags & QED_AIOCB_ZERO) {\n\n        qemu_vfree(acb->qiov->iov[0].iov_base);\n\n        acb->qiov->iov[0].iov_base = NULL;\n\n    }\n\n\n\n    /* Start next allocating write request waiting behind this one.  Note that\n\n     * requests enqueue themselves when they first hit an unallocated cluster\n\n     * but they wait until the entire request is finished before waking up the\n\n     * next request in the queue.  This ensures that we don't cycle through\n\n     * requests multiple times but rather finish one at a time completely.\n\n     */\n\n    if (acb == s->allocating_acb) {\n\n        s->allocating_acb = NULL;\n\n        if (!qemu_co_queue_empty(&s->allocating_write_reqs)) {\n\n            qemu_co_enter_next(&s->allocating_write_reqs);\n\n        } else if (s->header.features & QED_F_NEED_CHECK) {\n\n            qed_start_need_check_timer(s);\n\n        }\n\n    }\n\n}\n", "idx": 8946, "_split": "test", "_hash": "a1fab960d8c5929c63be64e3b388a5f9"}
{"project": "qemu", "commit_id": "37f51384ae05bd50f83308339dbffa3e78404874", "target": 0, "func": "static bool vtd_do_iommu_translate(VTDAddressSpace *vtd_as, PCIBus *bus,\n\n                                   uint8_t devfn, hwaddr addr, bool is_write,\n\n                                   IOMMUTLBEntry *entry)\n\n{\n\n    IntelIOMMUState *s = vtd_as->iommu_state;\n\n    VTDContextEntry ce;\n\n    uint8_t bus_num = pci_bus_num(bus);\n\n    VTDContextCacheEntry *cc_entry = &vtd_as->context_cache_entry;\n\n    uint64_t slpte, page_mask;\n\n    uint32_t level;\n\n    uint16_t source_id = vtd_make_source_id(bus_num, devfn);\n\n    int ret_fr;\n\n    bool is_fpd_set = false;\n\n    bool reads = true;\n\n    bool writes = true;\n\n    uint8_t access_flags;\n\n    VTDIOTLBEntry *iotlb_entry;\n\n\n\n    /*\n\n     * We have standalone memory region for interrupt addresses, we\n\n     * should never receive translation requests in this region.\n\n     */\n\n    assert(!vtd_is_interrupt_addr(addr));\n\n\n\n    /* Try to fetch slpte form IOTLB */\n\n    iotlb_entry = vtd_lookup_iotlb(s, source_id, addr);\n\n    if (iotlb_entry) {\n\n        trace_vtd_iotlb_page_hit(source_id, addr, iotlb_entry->slpte,\n\n                                 iotlb_entry->domain_id);\n\n        slpte = iotlb_entry->slpte;\n\n        access_flags = iotlb_entry->access_flags;\n\n        page_mask = iotlb_entry->mask;\n\n        goto out;\n\n    }\n\n\n\n    /* Try to fetch context-entry from cache first */\n\n    if (cc_entry->context_cache_gen == s->context_cache_gen) {\n\n        trace_vtd_iotlb_cc_hit(bus_num, devfn, cc_entry->context_entry.hi,\n\n                               cc_entry->context_entry.lo,\n\n                               cc_entry->context_cache_gen);\n\n        ce = cc_entry->context_entry;\n\n        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;\n\n    } else {\n\n        ret_fr = vtd_dev_to_context_entry(s, bus_num, devfn, &ce);\n\n        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;\n\n        if (ret_fr) {\n\n            ret_fr = -ret_fr;\n\n            if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {\n\n                trace_vtd_fault_disabled();\n\n            } else {\n\n                vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);\n\n            }\n\n            goto error;\n\n        }\n\n        /* Update context-cache */\n\n        trace_vtd_iotlb_cc_update(bus_num, devfn, ce.hi, ce.lo,\n\n                                  cc_entry->context_cache_gen,\n\n                                  s->context_cache_gen);\n\n        cc_entry->context_entry = ce;\n\n        cc_entry->context_cache_gen = s->context_cache_gen;\n\n    }\n\n\n\n    /*\n\n     * We don't need to translate for pass-through context entries.\n\n     * Also, let's ignore IOTLB caching as well for PT devices.\n\n     */\n\n    if (vtd_ce_get_type(&ce) == VTD_CONTEXT_TT_PASS_THROUGH) {\n\n        entry->iova = addr & VTD_PAGE_MASK_4K;\n\n        entry->translated_addr = entry->iova;\n\n        entry->addr_mask = ~VTD_PAGE_MASK_4K;\n\n        entry->perm = IOMMU_RW;\n\n        trace_vtd_translate_pt(source_id, entry->iova);\n\n\n\n        /*\n\n         * When this happens, it means firstly caching-mode is not\n\n         * enabled, and this is the first passthrough translation for\n\n         * the device. Let's enable the fast path for passthrough.\n\n         *\n\n         * When passthrough is disabled again for the device, we can\n\n         * capture it via the context entry invalidation, then the\n\n         * IOMMU region can be swapped back.\n\n         */\n\n        vtd_pt_enable_fast_path(s, source_id);\n\n\n\n        return true;\n\n    }\n\n\n\n    ret_fr = vtd_iova_to_slpte(&ce, addr, is_write, &slpte, &level,\n\n                               &reads, &writes);\n\n    if (ret_fr) {\n\n        ret_fr = -ret_fr;\n\n        if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {\n\n            trace_vtd_fault_disabled();\n\n        } else {\n\n            vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);\n\n        }\n\n        goto error;\n\n    }\n\n\n\n    page_mask = vtd_slpt_level_page_mask(level);\n\n    access_flags = IOMMU_ACCESS_FLAG(reads, writes);\n\n    vtd_update_iotlb(s, source_id, VTD_CONTEXT_ENTRY_DID(ce.hi), addr, slpte,\n\n                     access_flags, level);\n\nout:\n\n    entry->iova = addr & page_mask;\n\n    entry->translated_addr = vtd_get_slpte_addr(slpte) & page_mask;\n\n    entry->addr_mask = ~page_mask;\n\n    entry->perm = access_flags;\n\n    return true;\n\n\n\nerror:\n\n    entry->iova = 0;\n\n    entry->translated_addr = 0;\n\n    entry->addr_mask = 0;\n\n    entry->perm = IOMMU_NONE;\n\n    return false;\n\n}\n", "idx": 8949, "_split": "test", "_hash": "5065cf14fed420611839b64a427df76c"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int load_multiboot(void *fw_cfg,\n\n                   FILE *f,\n\n                   const char *kernel_filename,\n\n                   const char *initrd_filename,\n\n                   const char *kernel_cmdline,\n\n                   int kernel_file_size,\n\n                   uint8_t *header)\n\n{\n\n    int i, is_multiboot = 0;\n\n    uint32_t flags = 0;\n\n    uint32_t mh_entry_addr;\n\n    uint32_t mh_load_addr;\n\n    uint32_t mb_kernel_size;\n\n    MultibootState mbs;\n\n    uint8_t bootinfo[MBI_SIZE];\n\n    uint8_t *mb_bootinfo_data;\n\n\n\n    /* Ok, let's see if it is a multiboot image.\n\n       The header is 12x32bit long, so the latest entry may be 8192 - 48. */\n\n    for (i = 0; i < (8192 - 48); i += 4) {\n\n        if (ldl_p(header+i) == 0x1BADB002) {\n\n            uint32_t checksum = ldl_p(header+i+8);\n\n            flags = ldl_p(header+i+4);\n\n            checksum += flags;\n\n            checksum += (uint32_t)0x1BADB002;\n\n            if (!checksum) {\n\n                is_multiboot = 1;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!is_multiboot)\n\n        return 0; /* no multiboot */\n\n\n\n    mb_debug(\"qemu: I believe we found a multiboot image!\\n\");\n\n    memset(bootinfo, 0, sizeof(bootinfo));\n\n    memset(&mbs, 0, sizeof(mbs));\n\n\n\n    if (flags & 0x00000004) { /* MULTIBOOT_HEADER_HAS_VBE */\n\n        fprintf(stderr, \"qemu: multiboot knows VBE. we don't.\\n\");\n\n    }\n\n    if (!(flags & 0x00010000)) { /* MULTIBOOT_HEADER_HAS_ADDR */\n\n        uint64_t elf_entry;\n\n        uint64_t elf_low, elf_high;\n\n        int kernel_size;\n\n        fclose(f);\n\n\n\n        if (((struct elf64_hdr*)header)->e_machine == EM_X86_64) {\n\n            fprintf(stderr, \"Cannot load x86-64 image, give a 32bit one.\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                               &elf_low, &elf_high, 0, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"Error while loading elf kernel\\n\");\n\n            exit(1);\n\n        }\n\n        mh_load_addr = elf_low;\n\n        mb_kernel_size = elf_high - elf_low;\n\n        mh_entry_addr = elf_entry;\n\n\n\n        mbs.mb_buf = g_malloc(mb_kernel_size);\n\n        if (rom_copy(mbs.mb_buf, mh_load_addr, mb_kernel_size) != mb_kernel_size) {\n\n            fprintf(stderr, \"Error while fetching elf kernel from rom\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        mb_debug(\"qemu: loading multiboot-elf kernel (%#x bytes) with entry %#zx\\n\",\n\n                  mb_kernel_size, (size_t)mh_entry_addr);\n\n    } else {\n\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_ADDR. */\n\n        uint32_t mh_header_addr = ldl_p(header+i+12);\n\n        uint32_t mh_load_end_addr = ldl_p(header+i+20);\n\n        uint32_t mh_bss_end_addr = ldl_p(header+i+24);\n\n        mh_load_addr = ldl_p(header+i+16);\n\n        uint32_t mb_kernel_text_offset = i - (mh_header_addr - mh_load_addr);\n\n        uint32_t mb_load_size = 0;\n\n        mh_entry_addr = ldl_p(header+i+28);\n\n\n\n        if (mh_load_end_addr) {\n\n            mb_kernel_size = mh_bss_end_addr - mh_load_addr;\n\n            mb_load_size = mh_load_end_addr - mh_load_addr;\n\n        } else {\n\n            mb_kernel_size = kernel_file_size - mb_kernel_text_offset;\n\n            mb_load_size = mb_kernel_size;\n\n        }\n\n\n\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_VBE.\n\n        uint32_t mh_mode_type = ldl_p(header+i+32);\n\n        uint32_t mh_width = ldl_p(header+i+36);\n\n        uint32_t mh_height = ldl_p(header+i+40);\n\n        uint32_t mh_depth = ldl_p(header+i+44); */\n\n\n\n        mb_debug(\"multiboot: mh_header_addr = %#x\\n\", mh_header_addr);\n\n        mb_debug(\"multiboot: mh_load_addr = %#x\\n\", mh_load_addr);\n\n        mb_debug(\"multiboot: mh_load_end_addr = %#x\\n\", mh_load_end_addr);\n\n        mb_debug(\"multiboot: mh_bss_end_addr = %#x\\n\", mh_bss_end_addr);\n\n        mb_debug(\"qemu: loading multiboot kernel (%#x bytes) at %#x\\n\",\n\n                 mb_load_size, mh_load_addr);\n\n\n\n        mbs.mb_buf = g_malloc(mb_kernel_size);\n\n        fseek(f, mb_kernel_text_offset, SEEK_SET);\n\n        if (fread(mbs.mb_buf, 1, mb_load_size, f) != mb_load_size) {\n\n            fprintf(stderr, \"fread() failed\\n\");\n\n            exit(1);\n\n        }\n\n        memset(mbs.mb_buf + mb_load_size, 0, mb_kernel_size - mb_load_size);\n\n        fclose(f);\n\n    }\n\n\n\n    mbs.mb_buf_phys = mh_load_addr;\n\n\n\n    mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_kernel_size);\n\n    mbs.offset_mbinfo = mbs.mb_buf_size;\n\n\n\n    /* Calculate space for cmdlines and mb_mods */\n\n    mbs.mb_buf_size += strlen(kernel_filename) + 1;\n\n    mbs.mb_buf_size += strlen(kernel_cmdline) + 1;\n\n    if (initrd_filename) {\n\n        const char *r = initrd_filename;\n\n        mbs.mb_buf_size += strlen(r) + 1;\n\n        mbs.mb_mods_avail = 1;\n\n        while (*(r = get_opt_value(NULL, 0, r))) {\n\n           mbs.mb_mods_avail++;\n\n           r++;\n\n        }\n\n        mbs.mb_buf_size += MB_MOD_SIZE * mbs.mb_mods_avail;\n\n    }\n\n\n\n    mbs.mb_buf_size = TARGET_PAGE_ALIGN(mbs.mb_buf_size);\n\n\n\n    /* enlarge mb_buf to hold cmdlines and mb-info structs */\n\n    mbs.mb_buf          = g_realloc(mbs.mb_buf, mbs.mb_buf_size);\n\n    mbs.offset_cmdlines = mbs.offset_mbinfo + mbs.mb_mods_avail * MB_MOD_SIZE;\n\n\n\n    if (initrd_filename) {\n\n        char *next_initrd, not_last;\n\n\n\n        mbs.offset_mods = mbs.mb_buf_size;\n\n\n\n        do {\n\n            char *next_space;\n\n            int mb_mod_length;\n\n            uint32_t offs = mbs.mb_buf_size;\n\n\n\n            next_initrd = (char *)get_opt_value(NULL, 0, initrd_filename);\n\n            not_last = *next_initrd;\n\n            *next_initrd = '\\0';\n\n            /* if a space comes after the module filename, treat everything\n\n               after that as parameters */\n\n            target_phys_addr_t c = mb_add_cmdline(&mbs, initrd_filename);\n\n            if ((next_space = strchr(initrd_filename, ' ')))\n\n                *next_space = '\\0';\n\n            mb_debug(\"multiboot loading module: %s\\n\", initrd_filename);\n\n            mb_mod_length = get_image_size(initrd_filename);\n\n            if (mb_mod_length < 0) {\n\n                fprintf(stderr, \"Failed to open file '%s'\\n\", initrd_filename);\n\n                exit(1);\n\n            }\n\n\n\n            mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_mod_length + mbs.mb_buf_size);\n\n            mbs.mb_buf = g_realloc(mbs.mb_buf, mbs.mb_buf_size);\n\n\n\n            load_image(initrd_filename, (unsigned char *)mbs.mb_buf + offs);\n\n            mb_add_mod(&mbs, mbs.mb_buf_phys + offs,\n\n                       mbs.mb_buf_phys + offs + mb_mod_length, c);\n\n\n\n            mb_debug(\"mod_start: %p\\nmod_end:   %p\\n  cmdline: \"TARGET_FMT_plx\"\\n\",\n\n                     (char *)mbs.mb_buf + offs,\n\n                     (char *)mbs.mb_buf + offs + mb_mod_length, c);\n\n            initrd_filename = next_initrd+1;\n\n        } while (not_last);\n\n    }\n\n\n\n    /* Commandline support */\n\n    char kcmdline[strlen(kernel_filename) + strlen(kernel_cmdline) + 2];\n\n    snprintf(kcmdline, sizeof(kcmdline), \"%s %s\",\n\n             kernel_filename, kernel_cmdline);\n\n    stl_p(bootinfo + MBI_CMDLINE, mb_add_cmdline(&mbs, kcmdline));\n\n\n\n    stl_p(bootinfo + MBI_MODS_ADDR,  mbs.mb_buf_phys + mbs.offset_mbinfo);\n\n    stl_p(bootinfo + MBI_MODS_COUNT, mbs.mb_mods_count); /* mods_count */\n\n\n\n    /* the kernel is where we want it to be now */\n\n    stl_p(bootinfo + MBI_FLAGS, MULTIBOOT_FLAGS_MEMORY\n\n                                | MULTIBOOT_FLAGS_BOOT_DEVICE\n\n                                | MULTIBOOT_FLAGS_CMDLINE\n\n                                | MULTIBOOT_FLAGS_MODULES\n\n                                | MULTIBOOT_FLAGS_MMAP);\n\n    stl_p(bootinfo + MBI_MEM_LOWER,   640);\n\n    stl_p(bootinfo + MBI_MEM_UPPER,   (ram_size / 1024) - 1024);\n\n    stl_p(bootinfo + MBI_BOOT_DEVICE, 0x8000ffff); /* XXX: use the -boot switch? */\n\n    stl_p(bootinfo + MBI_MMAP_ADDR,   ADDR_E820_MAP);\n\n\n\n    mb_debug(\"multiboot: mh_entry_addr = %#x\\n\", mh_entry_addr);\n\n    mb_debug(\"           mb_buf_phys   = \"TARGET_FMT_plx\"\\n\", mbs.mb_buf_phys);\n\n    mb_debug(\"           mod_start     = \"TARGET_FMT_plx\"\\n\", mbs.mb_buf_phys + mbs.offset_mods);\n\n    mb_debug(\"           mb_mods_count = %d\\n\", mbs.mb_mods_count);\n\n\n\n    /* save bootinfo off the stack */\n\n    mb_bootinfo_data = g_malloc(sizeof(bootinfo));\n\n    memcpy(mb_bootinfo_data, bootinfo, sizeof(bootinfo));\n\n\n\n    /* Pass variables to option rom */\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ENTRY, mh_entry_addr);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, mh_load_addr);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, mbs.mb_buf_size);\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_KERNEL_DATA,\n\n                     mbs.mb_buf, mbs.mb_buf_size);\n\n\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, ADDR_MBI);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, sizeof(bootinfo));\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_INITRD_DATA, mb_bootinfo_data,\n\n                     sizeof(bootinfo));\n\n\n\n    option_rom[nb_option_roms].name = \"multiboot.bin\";\n\n    option_rom[nb_option_roms].bootindex = 0;\n\n    nb_option_roms++;\n\n\n\n    return 1; /* yes, we are multiboot */\n\n}\n", "idx": 8955, "_split": "test", "_hash": "0a28bdf7399458f94e60d1e72c039423"}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_brcond(TCGContext *s, TCGMemOp ext, TCGCond c, TCGArg a,\n\n                           TCGArg b, bool b_const, TCGLabel *l)\n\n{\n\n    intptr_t offset;\n\n    bool need_cmp;\n\n\n\n    if (b_const && b == 0 && (c == TCG_COND_EQ || c == TCG_COND_NE)) {\n\n        need_cmp = false;\n\n    } else {\n\n        need_cmp = true;\n\n        tcg_out_cmp(s, ext, a, b, b_const);\n\n    }\n\n\n\n    if (!l->has_value) {\n\n        tcg_out_reloc(s, s->code_ptr, R_AARCH64_CONDBR19, l, 0);\n\n        offset = tcg_in32(s) >> 5;\n\n    } else {\n\n        offset = l->u.value_ptr - s->code_ptr;\n\n        assert(offset == sextract64(offset, 0, 19));\n\n    }\n\n\n\n    if (need_cmp) {\n\n        tcg_out_insn(s, 3202, B_C, c, offset);\n\n    } else if (c == TCG_COND_EQ) {\n\n        tcg_out_insn(s, 3201, CBZ, ext, a, offset);\n\n    } else {\n\n        tcg_out_insn(s, 3201, CBNZ, ext, a, offset);\n\n    }\n\n}\n", "idx": 8970, "_split": "test", "_hash": "6cd4c2b5edf8b87a9f06be2313e0f737"}
{"project": "qemu", "commit_id": "3736cc5be31f0399999e37d8b28ca9a3ed0b4ccb", "target": 0, "func": "static int nbd_negotiate_options(NBDClient *client, Error **errp)\n\n{\n\n    uint32_t flags;\n\n    bool fixedNewstyle = false;\n\n\n\n    /* Client sends:\n\n        [ 0 ..   3]   client flags\n\n\n\n        [ 0 ..   7]   NBD_OPTS_MAGIC\n\n        [ 8 ..  11]   NBD option\n\n        [12 ..  15]   Data length\n\n        ...           Rest of request\n\n\n\n        [ 0 ..   7]   NBD_OPTS_MAGIC\n\n        [ 8 ..  11]   Second NBD option\n\n        [12 ..  15]   Data length\n\n        ...           Rest of request\n\n    */\n\n\n\n    if (nbd_read(client->ioc, &flags, sizeof(flags), errp) < 0) {\n\n        error_prepend(errp, \"read failed: \");\n\n        return -EIO;\n\n    }\n\n    trace_nbd_negotiate_options_flags();\n\n    be32_to_cpus(&flags);\n\n    if (flags & NBD_FLAG_C_FIXED_NEWSTYLE) {\n\n        trace_nbd_negotiate_options_newstyle();\n\n        fixedNewstyle = true;\n\n        flags &= ~NBD_FLAG_C_FIXED_NEWSTYLE;\n\n    }\n\n    if (flags & NBD_FLAG_C_NO_ZEROES) {\n\n        trace_nbd_negotiate_options_no_zeroes();\n\n        client->no_zeroes = true;\n\n        flags &= ~NBD_FLAG_C_NO_ZEROES;\n\n    }\n\n    if (flags != 0) {\n\n        error_setg(errp, \"Unknown client flags 0x%\" PRIx32 \" received\", flags);\n\n        return -EIO;\n\n    }\n\n\n\n    while (1) {\n\n        int ret;\n\n        uint32_t option, length;\n\n        uint64_t magic;\n\n\n\n        if (nbd_read(client->ioc, &magic, sizeof(magic), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        magic = be64_to_cpu(magic);\n\n        trace_nbd_negotiate_options_check_magic(magic);\n\n        if (magic != NBD_OPTS_MAGIC) {\n\n            error_setg(errp, \"Bad magic received\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (nbd_read(client->ioc, &option,\n\n                     sizeof(option), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        option = be32_to_cpu(option);\n\n\n\n        if (nbd_read(client->ioc, &length, sizeof(length), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        length = be32_to_cpu(length);\n\n\n\n        trace_nbd_negotiate_options_check_option(option);\n\n        if (client->tlscreds &&\n\n            client->ioc == (QIOChannel *)client->sioc) {\n\n            QIOChannel *tioc;\n\n            if (!fixedNewstyle) {\n\n                error_setg(errp, \"Unsupported option 0x%\" PRIx32, option);\n\n                return -EINVAL;\n\n            }\n\n            switch (option) {\n\n            case NBD_OPT_STARTTLS:\n\n                tioc = nbd_negotiate_handle_starttls(client, length, errp);\n\n                if (!tioc) {\n\n                    return -EIO;\n\n                }\n\n                object_unref(OBJECT(client->ioc));\n\n                client->ioc = QIO_CHANNEL(tioc);\n\n                break;\n\n\n\n            case NBD_OPT_EXPORT_NAME:\n\n                /* No way to return an error to client, so drop connection */\n\n                error_setg(errp, \"Option 0x%x not permitted before TLS\",\n\n                           option);\n\n                return -EINVAL;\n\n\n\n            default:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                 NBD_REP_ERR_TLS_REQD,\n\n                                                 option, errp,\n\n                                                 \"Option 0x%\" PRIx32\n\n                                                 \"not permitted before TLS\",\n\n                                                 option);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                /* Let the client keep trying, unless they asked to\n\n                 * quit. In this mode, we've already sent an error, so\n\n                 * we can't ack the abort.  */\n\n                if (option == NBD_OPT_ABORT) {\n\n                    return 1;\n\n                }\n\n                break;\n\n            }\n\n        } else if (fixedNewstyle) {\n\n            switch (option) {\n\n            case NBD_OPT_LIST:\n\n                ret = nbd_negotiate_handle_list(client, length, errp);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                break;\n\n\n\n            case NBD_OPT_ABORT:\n\n                /* NBD spec says we must try to reply before\n\n                 * disconnecting, but that we must also tolerate\n\n                 * guests that don't wait for our reply. */\n\n                nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, option, NULL);\n\n                return 1;\n\n\n\n            case NBD_OPT_EXPORT_NAME:\n\n                return nbd_negotiate_handle_export_name(client, length, errp);\n\n\n\n            case NBD_OPT_STARTTLS:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                if (client->tlscreds) {\n\n                    ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                     NBD_REP_ERR_INVALID,\n\n                                                     option, errp,\n\n                                                     \"TLS already enabled\");\n\n                } else {\n\n                    ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                     NBD_REP_ERR_POLICY,\n\n                                                     option, errp,\n\n                                                     \"TLS not configured\");\n\n                }\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                break;\n\n            default:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                 NBD_REP_ERR_UNSUP,\n\n                                                 option, errp,\n\n                                                 \"Unsupported option 0x%\"\n\n                                                 PRIx32,\n\n                                                 option);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                break;\n\n            }\n\n        } else {\n\n            /*\n\n             * If broken new-style we should drop the connection\n\n             * for anything except NBD_OPT_EXPORT_NAME\n\n             */\n\n            switch (option) {\n\n            case NBD_OPT_EXPORT_NAME:\n\n                return nbd_negotiate_handle_export_name(client, length, errp);\n\n\n\n            default:\n\n                error_setg(errp, \"Unsupported option 0x%\" PRIx32, option);\n\n                return -EINVAL;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 8988, "_split": "test", "_hash": "7711e79686e9af1462fd9a8148041477"}
{"project": "qemu", "commit_id": "f21126df5f81797486eb3bd628da8e2ad5fae12e", "target": 1, "func": "static void pl181_fifo_run(pl181_state *s)\n\n{\n\n    uint32_t bits;\n\n    uint32_t value;\n\n    int n;\n\n    int is_read;\n\n\n\n    is_read = (s->datactrl & PL181_DATA_DIRECTION) != 0;\n\n    if (s->datacnt != 0 && (!is_read || sd_data_ready(s->card))\n\n            && !s->linux_hack) {\n\n        if (is_read) {\n\n            n = 0;\n\n            value = 0;\n\n            while (s->datacnt && s->fifo_len < PL181_FIFO_LEN) {\n\n                value |= (uint32_t)sd_read_data(s->card) << (n * 8);\n\n                s->datacnt--;\n\n                n++;\n\n                if (n == 4) {\n\n                    pl181_fifo_push(s, value);\n\n                    n = 0;\n\n                    value = 0;\n\n                }\n\n            }\n\n            if (n != 0) {\n\n                pl181_fifo_push(s, value);\n\n            }\n\n        } else { /* write */\n\n            n = 0;\n\n            while (s->datacnt > 0 && (s->fifo_len > 0 || n > 0)) {\n\n                if (n == 0) {\n\n                    value = pl181_fifo_pop(s);\n\n                    n = 4;\n\n                }\n\n                n--;\n\n                s->datacnt--;\n\n                sd_write_data(s->card, value & 0xff);\n\n                value >>= 8;\n\n            }\n\n        }\n\n    }\n\n    s->status &= ~(PL181_STATUS_RX_FIFO | PL181_STATUS_TX_FIFO);\n\n    if (s->datacnt == 0) {\n\n        s->status |= PL181_STATUS_DATAEND;\n\n        /* HACK: */\n\n        s->status |= PL181_STATUS_DATABLOCKEND;\n\n        DPRINTF(\"Transfer Complete\\n\");\n\n    }\n\n    if (s->datacnt == 0 && s->fifo_len == 0) {\n\n        s->datactrl &= ~PL181_DATA_ENABLE;\n\n        DPRINTF(\"Data engine idle\\n\");\n\n    } else {\n\n        /* Update FIFO bits.  */\n\n        bits = PL181_STATUS_TXACTIVE | PL181_STATUS_RXACTIVE;\n\n        if (s->fifo_len == 0) {\n\n            bits |= PL181_STATUS_TXFIFOEMPTY;\n\n            bits |= PL181_STATUS_RXFIFOEMPTY;\n\n        } else {\n\n            bits |= PL181_STATUS_TXDATAAVLBL;\n\n            bits |= PL181_STATUS_RXDATAAVLBL;\n\n        }\n\n        if (s->fifo_len == 16) {\n\n            bits |= PL181_STATUS_TXFIFOFULL;\n\n            bits |= PL181_STATUS_RXFIFOFULL;\n\n        }\n\n        if (s->fifo_len <= 8) {\n\n            bits |= PL181_STATUS_TXFIFOHALFEMPTY;\n\n        }\n\n        if (s->fifo_len >= 8) {\n\n            bits |= PL181_STATUS_RXFIFOHALFFULL;\n\n        }\n\n        if (s->datactrl & PL181_DATA_DIRECTION) {\n\n            bits &= PL181_STATUS_RX_FIFO;\n\n        } else {\n\n            bits &= PL181_STATUS_TX_FIFO;\n\n        }\n\n        s->status |= bits;\n\n    }\n\n}\n", "idx": 9025, "_split": "test", "_hash": "ad9b741f2e19883c34e59f2cdec1b6fb"}
{"project": "qemu", "commit_id": "2e2aa31674444b61e79536a90d63a90572e695c8", "target": 0, "func": "static void mptsas_scsi_init(PCIDevice *dev, Error **errp)\n\n{\n\n    DeviceState *d = DEVICE(dev);\n\n    MPTSASState *s = MPT_SAS(dev);\n\n    Error *err = NULL;\n\n    int ret;\n\n\n\n    dev->config[PCI_LATENCY_TIMER] = 0;\n\n    dev->config[PCI_INTERRUPT_PIN] = 0x01;\n\n\n\n    if (s->msi != ON_OFF_AUTO_OFF) {\n\n        ret = msi_init(dev, 0, 1, true, false, &err);\n\n        /* Any error other than -ENOTSUP(board's MSI support is broken)\n\n         * is a programming error */\n\n        assert(!ret || ret == -ENOTSUP);\n\n        if (ret && s->msi == ON_OFF_AUTO_ON) {\n\n            /* Can't satisfy user's explicit msi=on request, fail */\n\n            error_append_hint(&err, \"You have to use msi=auto (default) or \"\n\n                    \"msi=off with this machine type.\\n\");\n\n            error_propagate(errp, err);\n\n            s->msi_in_use = false;\n\n            return;\n\n        } else if (ret) {\n\n            /* With msi=auto, we fall back to MSI off silently */\n\n            error_free(err);\n\n            s->msi_in_use = false;\n\n        } else {\n\n            s->msi_in_use = true;\n\n        }\n\n    }\n\n\n\n    memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,\n\n                          \"mptsas-mmio\", 0x4000);\n\n    memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,\n\n                          \"mptsas-io\", 256);\n\n    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,\n\n                          \"mptsas-diag\", 0x10000);\n\n\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);\n\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);\n\n    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);\n\n\n\n    if (!s->sas_addr) {\n\n        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |\n\n                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;\n\n        s->sas_addr |= (pci_bus_num(dev->bus) << 16);\n\n        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);\n\n        s->sas_addr |= PCI_FUNC(dev->devfn);\n\n    }\n\n    s->max_devices = MPTSAS_NUM_PORTS;\n\n\n\n    s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);\n\n\n\n    QTAILQ_INIT(&s->pending);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, errp);\n\n    }\n\n}\n", "idx": 9038, "_split": "test", "_hash": "db91cfbea3d94029d269a10bde397f4d"}
{"project": "qemu", "commit_id": "1da41cc1c6c3efbe2ed47228068bd80dbdc49d0e", "target": 0, "func": "static void kvm_arm_gic_realize(DeviceState *dev, Error **errp)\n\n{\n\n    int i;\n\n    GICState *s = KVM_ARM_GIC(dev);\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n    KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s);\n\n\n\n    kgc->parent_realize(dev, errp);\n\n    if (error_is_set(errp)) {\n\n        return;\n\n    }\n\n\n\n    i = s->num_irq - GIC_INTERNAL;\n\n    /* For the GIC, also expose incoming GPIO lines for PPIs for each CPU.\n\n     * GPIO array layout is thus:\n\n     *  [0..N-1] SPIs\n\n     *  [N..N+31] PPIs for CPU 0\n\n     *  [N+32..N+63] PPIs for CPU 1\n\n     *   ...\n\n     */\n\n    i += (GIC_INTERNAL * s->num_cpu);\n\n    qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i);\n\n    /* We never use our outbound IRQ lines but provide them so that\n\n     * we maintain the same interface as the non-KVM GIC.\n\n     */\n\n    for (i = 0; i < s->num_cpu; i++) {\n\n        sysbus_init_irq(sbd, &s->parent_irq[i]);\n\n    }\n\n    /* Distributor */\n\n    memory_region_init_reservation(&s->iomem, OBJECT(s),\n\n                                   \"kvm-gic_dist\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n    kvm_arm_register_device(&s->iomem,\n\n                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)\n\n                            | KVM_VGIC_V2_ADDR_TYPE_DIST);\n\n    /* CPU interface for current core. Unlike arm_gic, we don't\n\n     * provide the \"interface for core #N\" memory regions, because\n\n     * cores with a VGIC don't have those.\n\n     */\n\n    memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s),\n\n                                   \"kvm-gic_cpu\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->cpuiomem[0]);\n\n    kvm_arm_register_device(&s->cpuiomem[0],\n\n                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)\n\n                            | KVM_VGIC_V2_ADDR_TYPE_CPU);\n\n}\n", "idx": 9039, "_split": "test", "_hash": "ec511440573c6ec434f9340fcb1a77f4"}
{"project": "qemu", "commit_id": "31783203c3b74c11015b20194d57dada559940cf", "target": 0, "func": "char *qemu_find_file(int type, const char *name)\n\n{\n\n    int len;\n\n    const char *subdir;\n\n    char *buf;\n\n\n\n    /* If name contains path separators then try it as a straight path.  */\n\n    if ((strchr(name, '/') || strchr(name, '\\\\'))\n\n        && access(name, R_OK) == 0) {\n\n        return g_strdup(name);\n\n    }\n\n    switch (type) {\n\n    case QEMU_FILE_TYPE_BIOS:\n\n        subdir = \"\";\n\n        break;\n\n    case QEMU_FILE_TYPE_KEYMAP:\n\n        subdir = \"keymaps/\";\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    len = strlen(data_dir) + strlen(name) + strlen(subdir) + 2;\n\n    buf = g_malloc0(len);\n\n    snprintf(buf, len, \"%s/%s%s\", data_dir, subdir, name);\n\n    if (access(buf, R_OK)) {\n\n        g_free(buf);\n\n        return NULL;\n\n    }\n\n    return buf;\n\n}\n", "idx": 9049, "_split": "test", "_hash": "87b7f1a067cf00da8bd581c80397514d"}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "void term_flush(void)\n\n{\n\n}\n", "idx": 9055, "_split": "test", "_hash": "e7bd1fa5a6759e0301c2ddfae8e6d883"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,\n\n                                 unsigned size)\n\n{\n\n    PICCommonState *s = opaque;\n\n    return s->elcr;\n\n}\n", "idx": 9067, "_split": "test", "_hash": "f5e6b48f775bbab4e744eaae8ec43feb"}
{"project": "qemu", "commit_id": "641bb63cd6b003ab0ca2e312a014449037d71647", "target": 0, "func": "static int inc_refcounts(BlockDriverState *bs,\n\n                         BdrvCheckResult *res,\n\n                         uint16_t *refcount_table,\n\n                         int64_t refcount_table_size,\n\n                         int64_t offset, int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t start, last, cluster_offset, k;\n\n\n\n    if (size <= 0) {\n\n        return 0;\n\n    }\n\n\n\n    start = start_of_cluster(s, offset);\n\n    last = start_of_cluster(s, offset + size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size) {\n\n        k = cluster_offset >> s->cluster_bits;\n\n        if (k >= refcount_table_size) {\n\n            fprintf(stderr, \"Warning: cluster offset=0x%\" PRIx64 \" is after \"\n\n                \"the end of the image file, can't properly check refcounts.\\n\",\n\n                cluster_offset);\n\n            res->check_errors++;\n\n        } else {\n\n            if (++refcount_table[k] == 0) {\n\n                fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n\n                    \"\\n\", cluster_offset);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9072, "_split": "test", "_hash": "69aa39170013f832a0c8093c23e23b49"}
{"project": "qemu", "commit_id": "f140e3000371e67ff4e00df3213e2d576d9c91be", "target": 1, "func": "static int nbd_co_request(BlockDriverState *bs,\n\n                          NBDRequest *request,\n\n                          QEMUIOVector *qiov)\n\n{\n\n    NBDClientSession *client = nbd_get_client_session(bs);\n\n    int ret;\n\n\n\n    if (qiov) {\n\n        assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ);\n\n        assert(request->len == iov_size(qiov->iov, qiov->niov));\n\n    } else {\n\n        assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ);\n\n    }\n\n    ret = nbd_co_send_request(bs, request,\n\n                              request->type == NBD_CMD_WRITE ? qiov : NULL);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return nbd_co_receive_reply(client, request->handle,\n\n                                request->type == NBD_CMD_READ ? qiov : NULL);\n\n}\n", "idx": 9087, "_split": "test", "_hash": "58d5a18ead1b99d10877e7a76ef51992"}
{"project": "qemu", "commit_id": "eff235eb2bcd7092901f4698a7907e742f3b7f2f", "target": 1, "func": "static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,\n\n                            const DisasInsn *di)\n\n{\n\n    unsigned r2 = extract32(insn, 21, 5);\n\n    unsigned r1 = extract32(insn, 16, 5);\n\n    unsigned cf = extract32(insn, 12, 4);\n\n    unsigned rt = extract32(insn,  0, 5);\n\n    TCGv tcg_r1, tcg_r2;\n\n    ExitStatus ret;\n\n\n\n    if (cf) {\n\n        nullify_over(ctx);\n\n    }\n\n    tcg_r1 = load_gpr(ctx, r1);\n\n    tcg_r2 = load_gpr(ctx, r2);\n\n    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);\n\n    return nullify_end(ctx, ret);\n\n}\n", "idx": 9091, "_split": "test", "_hash": "58895072ecbc34e669795b50174f6909"}
{"project": "qemu", "commit_id": "80ee15a6b274dfcedb0ad7db8c9e7d392210d6a1", "target": 1, "func": "uint64_t qcow2_get_cluster_offset(BlockDriverState *bs, uint64_t offset,\n\n    int *num)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l1_index, l2_index;\n\n    uint64_t l2_offset, *l2_table, cluster_offset;\n\n    int l1_bits, c;\n\n    int index_in_cluster, nb_available, nb_needed, nb_clusters;\n\n\n\n    index_in_cluster = (offset >> 9) & (s->cluster_sectors - 1);\n\n    nb_needed = *num + index_in_cluster;\n\n\n\n    l1_bits = s->l2_bits + s->cluster_bits;\n\n\n\n    /* compute how many bytes there are between the offset and\n\n     * the end of the l1 entry\n\n     */\n\n\n\n    nb_available = (1 << l1_bits) - (offset & ((1 << l1_bits) - 1));\n\n\n\n    /* compute the number of available sectors */\n\n\n\n    nb_available = (nb_available >> 9) + index_in_cluster;\n\n\n\n    if (nb_needed > nb_available) {\n\n        nb_needed = nb_available;\n\n    }\n\n\n\n    cluster_offset = 0;\n\n\n\n    /* seek the the l2 offset in the l1 table */\n\n\n\n    l1_index = offset >> l1_bits;\n\n    if (l1_index >= s->l1_size)\n\n        goto out;\n\n\n\n    l2_offset = s->l1_table[l1_index];\n\n\n\n    /* seek the l2 table of the given l2 offset */\n\n\n\n    if (!l2_offset)\n\n        goto out;\n\n\n\n    /* load the l2 table in memory */\n\n\n\n    l2_offset &= ~QCOW_OFLAG_COPIED;\n\n    l2_table = l2_load(bs, l2_offset);\n\n    if (l2_table == NULL)\n\n        return 0;\n\n\n\n    /* find the cluster offset for the given disk offset */\n\n\n\n    l2_index = (offset >> s->cluster_bits) & (s->l2_size - 1);\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n    nb_clusters = size_to_clusters(s, nb_needed << 9);\n\n\n\n    if (!cluster_offset) {\n\n        /* how many empty clusters ? */\n\n        c = count_contiguous_free_clusters(nb_clusters, &l2_table[l2_index]);\n\n    } else {\n\n        /* how many allocated clusters ? */\n\n        c = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], 0, QCOW_OFLAG_COPIED);\n\n    }\n\n\n\n   nb_available = (c * s->cluster_sectors);\n\nout:\n\n    if (nb_available > nb_needed)\n\n        nb_available = nb_needed;\n\n\n\n    *num = nb_available - index_in_cluster;\n\n\n\n    return cluster_offset & ~QCOW_OFLAG_COPIED;\n\n}\n", "idx": 9106, "_split": "test", "_hash": "122eba19bfcaaae00102aef52db75bdc"}
{"project": "qemu", "commit_id": "b8aecea23aaccf39da54c77ef248f5fa50dcfbc1", "target": 1, "func": "void memory_region_add_eventfd(MemoryRegion *mr,\n\n                               hwaddr addr,\n\n                               unsigned size,\n\n                               bool match_data,\n\n                               uint64_t data,\n\n                               EventNotifier *e)\n\n{\n\n    MemoryRegionIoeventfd mrfd = {\n\n        .addr.start = int128_make64(addr),\n\n        .addr.size = int128_make64(size),\n\n        .match_data = match_data,\n\n        .data = data,\n\n        .e = e,\n\n    };\n\n    unsigned i;\n\n\n\n    adjust_endianness(mr, &mrfd.data, size);\n\n    memory_region_transaction_begin();\n\n    for (i = 0; i < mr->ioeventfd_nb; ++i) {\n\n        if (memory_region_ioeventfd_before(mrfd, mr->ioeventfds[i])) {\n\n            break;\n\n        }\n\n    }\n\n    ++mr->ioeventfd_nb;\n\n    mr->ioeventfds = g_realloc(mr->ioeventfds,\n\n                                  sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);\n\n    memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i],\n\n            sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i));\n\n    mr->ioeventfds[i] = mrfd;\n\n    ioeventfd_update_pending |= mr->enabled;\n\n    memory_region_transaction_commit();\n\n}\n", "idx": 9122, "_split": "test", "_hash": "f58cc5463c1aafee2a22fa1fab933111"}
{"project": "qemu", "commit_id": "2531088f6c1ce1f620f8d5a545f0af95598e69fc", "target": 1, "func": "static void gic_set_irq(void *opaque, int irq, int level)\n\n{\n\n    /* Meaning of the 'irq' parameter:\n\n     *  [0..N-1] : external interrupts\n\n     *  [N..N+31] : PPI (internal) interrupts for CPU 0\n\n     *  [N+32..N+63] : PPI (internal interrupts for CPU 1\n\n     *  ...\n\n     */\n\n    GICState *s = (GICState *)opaque;\n\n    int cm, target;\n\n    if (irq < (s->num_irq - GIC_INTERNAL)) {\n\n        /* The first external input line is internal interrupt 32.  */\n\n        cm = ALL_CPU_MASK;\n\n        irq += GIC_INTERNAL;\n\n        target = GIC_TARGET(irq);\n\n    } else {\n\n        int cpu;\n\n        irq -= (s->num_irq - GIC_INTERNAL);\n\n        cpu = irq / GIC_INTERNAL;\n\n        irq %= GIC_INTERNAL;\n\n        cm = 1 << cpu;\n\n        target = cm;\n\n    }\n\n\n\n    assert(irq >= GIC_NR_SGIS);\n\n\n\n    if (level == GIC_TEST_LEVEL(irq, cm)) {\n\n        return;\n\n    }\n\n\n\n    if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {\n\n        gic_set_irq_11mpcore(s, irq, level, cm, target);\n\n    } else {\n\n        gic_set_irq_generic(s, irq, level, cm, target);\n\n    }\n\n\n\n\n    gic_update(s);\n\n}", "idx": 9150, "_split": "test", "_hash": "233e9c39c96352e88e8b2d454f2fe626"}
{"project": "qemu", "commit_id": "0f888bfaddfc5f55b0d82cde2e1164658a672375", "target": 1, "func": "VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg)\n{\n    VIOsPAPRDevice *sdev;\n    sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg);\n    if (!sdev && reg == 0) {\n        /* Hack for kernel early debug, which always specifies reg==0.\n         * We search all VIO devices, and grab the vty with the lowest\n         * reg.  This attempts to mimic existing PowerVM behaviour\n         * (early debug does work there, despite having no vty with\n         * reg==0. */\n        return spapr_vty_get_default(spapr->vio_bus);\n    return sdev;", "idx": 9172, "_split": "test", "_hash": "c92854712b7d4818a9e35689f3106fdf"}
{"project": "qemu", "commit_id": "356f59b8757f47c0aca3e2e4e51d6010f64cade1", "target": 1, "func": "void coroutine_fn block_job_pause_point(BlockJob *job)\n\n{\n\n    assert(job && block_job_started(job));\n\n\n\n    if (!block_job_should_pause(job)) {\n\n        return;\n\n    }\n\n    if (block_job_is_cancelled(job)) {\n\n        return;\n\n    }\n\n\n\n    if (job->driver->pause) {\n\n        job->driver->pause(job);\n\n    }\n\n\n\n    if (block_job_should_pause(job) && !block_job_is_cancelled(job)) {\n\n        job->paused = true;\n\n        job->busy = false;\n\n        qemu_coroutine_yield(); /* wait for block_job_resume() */\n\n        job->busy = true;\n\n        job->paused = false;\n\n    }\n\n\n\n    if (job->driver->resume) {\n\n        job->driver->resume(job);\n\n    }\n\n}\n", "idx": 9174, "_split": "test", "_hash": "fad1f906e75e8840d00866a0763417a1"}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "int bdrv_pread(BlockDriverState *bs, int64_t offset,\n               void *buf1, int count1)\n{\n    BlockDriver *drv = bs->drv;\n    if (!drv)\n        return -ENOMEDIUM;\n    if (!drv->bdrv_pread)\n        return bdrv_pread_em(bs, offset, buf1, count1);\n    return drv->bdrv_pread(bs, offset, buf1, count1);\n}", "idx": 9176, "_split": "test", "_hash": "554301983bacfeee99d64754e7ce34ae"}
{"project": "qemu", "commit_id": "b21da4e504fbdb907543a918b190783dc896d8e1", "target": 1, "func": "static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,\n                               unsigned int epid)\n{\n    XHCISlot *slot;\n    XHCIEPContext *epctx;\n    int i;\n    trace_usb_xhci_ep_disable(slotid, epid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n    slot = &xhci->slots[slotid-1];\n    if (!slot->eps[epid-1]) {\n        DPRINTF(\"xhci: slot %d ep %d already disabled\\n\", slotid, epid);\n        return CC_SUCCESS;\n    xhci_ep_nuke_xfers(xhci, slotid, epid);\n    epctx = slot->eps[epid-1];\n    if (epctx->nr_pstreams) {\n        xhci_free_streams(epctx);\n    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);\n    timer_free(epctx->kick_timer);\n    g_free(epctx);\n    slot->eps[epid-1] = NULL;\n    return CC_SUCCESS;", "idx": 9189, "_split": "test", "_hash": "288280b75c0a8b28e50173bcb771de0b"}
{"project": "qemu", "commit_id": "bc3e6a0d6c8ab6cd7cd4b576ed567756f1dcabd2", "target": 1, "func": "int pvpanic_init(ISABus *bus)\n\n{\n\n    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);\n\n    return 0;\n\n}\n", "idx": 9193, "_split": "test", "_hash": "960721d5a3cd9b83ad9bad9eedc3bb91"}
{"project": "qemu", "commit_id": "679aa175e84f5f80b32b307fce5a6b92729e0e61", "target": 0, "func": "static uint32_t gic_dist_readb(void *opaque, hwaddr offset, MemTxAttrs attrs)\n\n{\n\n    GICState *s = (GICState *)opaque;\n\n    uint32_t res;\n\n    int irq;\n\n    int i;\n\n    int cpu;\n\n    int cm;\n\n    int mask;\n\n\n\n    cpu = gic_get_current_cpu(s);\n\n    cm = 1 << cpu;\n\n    if (offset < 0x100) {\n\n        if (offset == 0)\n\n            return s->enabled;\n\n        if (offset == 4)\n\n            /* Interrupt Controller Type Register */\n\n            return ((s->num_irq / 32) - 1)\n\n                    | ((NUM_CPU(s) - 1) << 5)\n\n                    | (s->security_extn << 10);\n\n        if (offset < 0x08)\n\n            return 0;\n\n        if (offset >= 0x80) {\n\n            /* Interrupt Group Registers: these RAZ/WI if this is an NS\n\n             * access to a GIC with the security extensions, or if the GIC\n\n             * doesn't have groups at all.\n\n             */\n\n            res = 0;\n\n            if (!(s->security_extn && !attrs.secure) && gic_has_groups(s)) {\n\n                /* Every byte offset holds 8 group status bits */\n\n                irq = (offset - 0x080) * 8 + GIC_BASE_IRQ;\n\n                if (irq >= s->num_irq) {\n\n                    goto bad_reg;\n\n                }\n\n                for (i = 0; i < 8; i++) {\n\n                    if (GIC_TEST_GROUP(irq + i, cm)) {\n\n                        res |= (1 << i);\n\n                    }\n\n                }\n\n            }\n\n            return res;\n\n        }\n\n        goto bad_reg;\n\n    } else if (offset < 0x200) {\n\n        /* Interrupt Set/Clear Enable.  */\n\n        if (offset < 0x180)\n\n            irq = (offset - 0x100) * 8;\n\n        else\n\n            irq = (offset - 0x180) * 8;\n\n        irq += GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        for (i = 0; i < 8; i++) {\n\n            if (GIC_TEST_ENABLED(irq + i, cm)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x300) {\n\n        /* Interrupt Set/Clear Pending.  */\n\n        if (offset < 0x280)\n\n            irq = (offset - 0x200) * 8;\n\n        else\n\n            irq = (offset - 0x280) * 8;\n\n        irq += GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        mask = (irq < GIC_INTERNAL) ?  cm : ALL_CPU_MASK;\n\n        for (i = 0; i < 8; i++) {\n\n            if (gic_test_pending(s, irq + i, mask)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x400) {\n\n        /* Interrupt Active.  */\n\n        irq = (offset - 0x300) * 8 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        mask = (irq < GIC_INTERNAL) ?  cm : ALL_CPU_MASK;\n\n        for (i = 0; i < 8; i++) {\n\n            if (GIC_TEST_ACTIVE(irq + i, mask)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x800) {\n\n        /* Interrupt Priority.  */\n\n        irq = (offset - 0x400) + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = GIC_GET_PRIORITY(irq, cpu);\n\n    } else if (offset < 0xc00) {\n\n        /* Interrupt CPU Target.  */\n\n        if (s->num_cpu == 1 && s->revision != REV_11MPCORE) {\n\n            /* For uniprocessor GICs these RAZ/WI */\n\n            res = 0;\n\n        } else {\n\n            irq = (offset - 0x800) + GIC_BASE_IRQ;\n\n            if (irq >= s->num_irq) {\n\n                goto bad_reg;\n\n            }\n\n            if (irq >= 29 && irq <= 31) {\n\n                res = cm;\n\n            } else {\n\n                res = GIC_TARGET(irq);\n\n            }\n\n        }\n\n    } else if (offset < 0xf00) {\n\n        /* Interrupt Configuration.  */\n\n        irq = (offset - 0xc00) * 4 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        for (i = 0; i < 4; i++) {\n\n            if (GIC_TEST_MODEL(irq + i))\n\n                res |= (1 << (i * 2));\n\n            if (GIC_TEST_EDGE_TRIGGER(irq + i))\n\n                res |= (2 << (i * 2));\n\n        }\n\n    } else if (offset < 0xf10) {\n\n        goto bad_reg;\n\n    } else if (offset < 0xf30) {\n\n        if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {\n\n            goto bad_reg;\n\n        }\n\n\n\n        if (offset < 0xf20) {\n\n            /* GICD_CPENDSGIRn */\n\n            irq = (offset - 0xf10);\n\n        } else {\n\n            irq = (offset - 0xf20);\n\n            /* GICD_SPENDSGIRn */\n\n        }\n\n\n\n        res = s->sgi_pending[irq][cpu];\n\n    } else if (offset < 0xfe0) {\n\n        goto bad_reg;\n\n    } else /* offset >= 0xfe0 */ {\n\n        if (offset & 3) {\n\n            res = 0;\n\n        } else {\n\n            res = gic_id[(offset - 0xfe0) >> 2];\n\n        }\n\n    }\n\n    return res;\n\nbad_reg:\n\n    qemu_log_mask(LOG_GUEST_ERROR,\n\n                  \"gic_dist_readb: Bad offset %x\\n\", (int)offset);\n\n    return 0;\n\n}\n", "idx": 9210, "_split": "test", "_hash": "f475675b437e332f2a9973f0092f001b"}
{"project": "qemu", "commit_id": "36778660d7fd0748a6129916e47ecedd67bdb758", "target": 0, "func": "static inline int get_segment_6xx_tlb(CPUPPCState *env, mmu_ctx_t *ctx,\n\n                                      target_ulong eaddr, int rw, int type)\n\n{\n\n    hwaddr hash;\n\n    target_ulong vsid;\n\n    int ds, pr, target_page_bits;\n\n    int ret;\n\n    target_ulong sr, pgidx;\n\n\n\n    pr = msr_pr;\n\n    ctx->eaddr = eaddr;\n\n\n\n    sr = env->sr[eaddr >> 28];\n\n    ctx->key = (((sr & 0x20000000) && (pr != 0)) ||\n\n                ((sr & 0x40000000) && (pr == 0))) ? 1 : 0;\n\n    ds = sr & 0x80000000 ? 1 : 0;\n\n    ctx->nx = sr & 0x10000000 ? 1 : 0;\n\n    vsid = sr & 0x00FFFFFF;\n\n    target_page_bits = TARGET_PAGE_BITS;\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n            \"Check segment v=\" TARGET_FMT_lx \" %d \" TARGET_FMT_lx\n\n            \" nip=\" TARGET_FMT_lx \" lr=\" TARGET_FMT_lx\n\n            \" ir=%d dr=%d pr=%d %d t=%d\\n\",\n\n            eaddr, (int)(eaddr >> 28), sr, env->nip, env->lr, (int)msr_ir,\n\n            (int)msr_dr, pr != 0 ? 1 : 0, rw, type);\n\n    pgidx = (eaddr & ~SEGMENT_MASK_256M) >> target_page_bits;\n\n    hash = vsid ^ pgidx;\n\n    ctx->ptem = (vsid << 7) | (pgidx >> 10);\n\n\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n            \"pte segment: key=%d ds %d nx %d vsid \" TARGET_FMT_lx \"\\n\",\n\n            ctx->key, ds, ctx->nx, vsid);\n\n    ret = -1;\n\n    if (!ds) {\n\n        /* Check if instruction fetch is allowed, if needed */\n\n        if (type != ACCESS_CODE || ctx->nx == 0) {\n\n            /* Page address translation */\n\n            qemu_log_mask(CPU_LOG_MMU, \"htab_base \" TARGET_FMT_plx\n\n                    \" htab_mask \" TARGET_FMT_plx\n\n                    \" hash \" TARGET_FMT_plx \"\\n\",\n\n                    env->htab_base, env->htab_mask, hash);\n\n            ctx->hash[0] = hash;\n\n            ctx->hash[1] = ~hash;\n\n\n\n            /* Initialize real address with an invalid value */\n\n            ctx->raddr = (hwaddr)-1ULL;\n\n            /* Software TLB search */\n\n            ret = ppc6xx_tlb_check(env, ctx, eaddr, rw, type);\n\n#if defined(DUMP_PAGE_TABLES)\n\n            if (qemu_loglevel_mask(CPU_LOG_MMU)) {\n\n                CPUState *cs = ENV_GET_CPU(env);\n\n                hwaddr curaddr;\n\n                uint32_t a0, a1, a2, a3;\n\n\n\n                qemu_log(\"Page table: \" TARGET_FMT_plx \" len \" TARGET_FMT_plx\n\n                         \"\\n\", env->htab_base, env->htab_mask + 0x80);\n\n                for (curaddr = env->htab_base;\n\n                     curaddr < (env->htab_base + env->htab_mask + 0x80);\n\n                     curaddr += 16) {\n\n                    a0 = ldl_phys(cs->as, curaddr);\n\n                    a1 = ldl_phys(cs->as, curaddr + 4);\n\n                    a2 = ldl_phys(cs->as, curaddr + 8);\n\n                    a3 = ldl_phys(cs->as, curaddr + 12);\n\n                    if (a0 != 0 || a1 != 0 || a2 != 0 || a3 != 0) {\n\n                        qemu_log(TARGET_FMT_plx \": %08x %08x %08x %08x\\n\",\n\n                                 curaddr, a0, a1, a2, a3);\n\n                    }\n\n                }\n\n            }\n\n#endif\n\n        } else {\n\n            qemu_log_mask(CPU_LOG_MMU, \"No access allowed\\n\");\n\n            ret = -3;\n\n        }\n\n    } else {\n\n        target_ulong sr;\n\n\n\n        qemu_log_mask(CPU_LOG_MMU, \"direct store...\\n\");\n\n        /* Direct-store segment : absolutely *BUGGY* for now */\n\n\n\n        /* Direct-store implies a 32-bit MMU.\n\n         * Check the Segment Register's bus unit ID (BUID).\n\n         */\n\n        sr = env->sr[eaddr >> 28];\n\n        if ((sr & 0x1FF00000) >> 20 == 0x07f) {\n\n            /* Memory-forced I/O controller interface access */\n\n            /* If T=1 and BUID=x'07F', the 601 performs a memory access\n\n             * to SR[28-31] LA[4-31], bypassing all protection mechanisms.\n\n             */\n\n            ctx->raddr = ((sr & 0xF) << 28) | (eaddr & 0x0FFFFFFF);\n\n            ctx->prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n            return 0;\n\n        }\n\n\n\n        switch (type) {\n\n        case ACCESS_INT:\n\n            /* Integer load/store : only access allowed */\n\n            break;\n\n        case ACCESS_CODE:\n\n            /* No code fetch is allowed in direct-store areas */\n\n            return -4;\n\n        case ACCESS_FLOAT:\n\n            /* Floating point load/store */\n\n            return -4;\n\n        case ACCESS_RES:\n\n            /* lwarx, ldarx or srwcx. */\n\n            return -4;\n\n        case ACCESS_CACHE:\n\n            /* dcba, dcbt, dcbtst, dcbf, dcbi, dcbst, dcbz, or icbi */\n\n            /* Should make the instruction do no-op.\n\n             * As it already do no-op, it's quite easy :-)\n\n             */\n\n            ctx->raddr = eaddr;\n\n            return 0;\n\n        case ACCESS_EXT:\n\n            /* eciwx or ecowx */\n\n            return -4;\n\n        default:\n\n            qemu_log_mask(CPU_LOG_MMU, \"ERROR: instruction should not need \"\n\n                          \"address translation\\n\");\n\n            return -4;\n\n        }\n\n        if ((rw == 1 || ctx->key != 1) && (rw == 0 || ctx->key != 0)) {\n\n            ctx->raddr = eaddr;\n\n            ret = 2;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 9215, "_split": "test", "_hash": "081c0cabcb02277cae74c3eb279ab09f"}
{"project": "qemu", "commit_id": "df3c286c53ac51e7267f2761c7a0c62e11b6e815", "target": 0, "func": "static void slirp_socket_save(QEMUFile *f, struct socket *so)\n\n{\n\n    qemu_put_be32(f, so->so_urgc);\n\n    qemu_put_be16(f, so->so_ffamily);\n\n    switch (so->so_ffamily) {\n\n    case AF_INET:\n\n        qemu_put_be32(f, so->so_faddr.s_addr);\n\n        qemu_put_be16(f, so->so_fport);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to save so_faddr and so_fport\\n\");\n\n    }\n\n    qemu_put_be16(f, so->so_lfamily);\n\n    switch (so->so_lfamily) {\n\n    case AF_INET:\n\n        qemu_put_be32(f, so->so_laddr.s_addr);\n\n        qemu_put_be16(f, so->so_lport);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to save so_laddr and so_lport\\n\");\n\n    }\n\n    qemu_put_byte(f, so->so_iptos);\n\n    qemu_put_byte(f, so->so_emu);\n\n    qemu_put_byte(f, so->so_type);\n\n    qemu_put_be32(f, so->so_state);\n\n    slirp_sbuf_save(f, &so->so_rcv);\n\n    slirp_sbuf_save(f, &so->so_snd);\n\n    slirp_tcp_save(f, so->so_tcpcb);\n\n}\n", "idx": 9225, "_split": "test", "_hash": "87dfcd042452b203ccb5941386a74a45"}
{"project": "qemu", "commit_id": "8f5d58ef2c92d7b82d9a6eeefd7c8854a183ba4a", "target": 1, "func": "void object_property_allow_set_link(Object *obj, const char *name,\n\n                                    Object *val, Error **errp)\n\n{\n\n    /* Allow the link to be set, always */\n\n}\n", "idx": 9231, "_split": "test", "_hash": "7a78eb15abfe2c3e14f273806df7c52e"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t lan9118_readl(void *opaque, target_phys_addr_t offset,\n\n                              unsigned size)\n\n{\n\n    lan9118_state *s = (lan9118_state *)opaque;\n\n\n\n    //DPRINTF(\"Read reg 0x%02x\\n\", (int)offset);\n\n    if (offset < 0x20) {\n\n        /* RX FIFO */\n\n        return rx_fifo_pop(s);\n\n    }\n\n    switch (offset) {\n\n    case 0x40:\n\n        return rx_status_fifo_pop(s);\n\n    case 0x44:\n\n        return s->rx_status_fifo[s->tx_status_fifo_head];\n\n    case 0x48:\n\n        return tx_status_fifo_pop(s);\n\n    case 0x4c:\n\n        return s->tx_status_fifo[s->tx_status_fifo_head];\n\n    case CSR_ID_REV:\n\n        return 0x01180001;\n\n    case CSR_IRQ_CFG:\n\n        return s->irq_cfg;\n\n    case CSR_INT_STS:\n\n        return s->int_sts;\n\n    case CSR_INT_EN:\n\n        return s->int_en;\n\n    case CSR_BYTE_TEST:\n\n        return 0x87654321;\n\n    case CSR_FIFO_INT:\n\n        return s->fifo_int;\n\n    case CSR_RX_CFG:\n\n        return s->rx_cfg;\n\n    case CSR_TX_CFG:\n\n        return s->tx_cfg;\n\n    case CSR_HW_CFG:\n\n        return s->hw_cfg;\n\n    case CSR_RX_DP_CTRL:\n\n        return 0;\n\n    case CSR_RX_FIFO_INF:\n\n        return (s->rx_status_fifo_used << 16) | (s->rx_fifo_used << 2);\n\n    case CSR_TX_FIFO_INF:\n\n        return (s->tx_status_fifo_used << 16)\n\n               | (s->tx_fifo_size - s->txp->fifo_used);\n\n    case CSR_PMT_CTRL:\n\n        return s->pmt_ctrl;\n\n    case CSR_GPIO_CFG:\n\n        return s->gpio_cfg;\n\n    case CSR_GPT_CFG:\n\n        return s->gpt_cfg;\n\n    case CSR_GPT_CNT:\n\n        return ptimer_get_count(s->timer);\n\n    case CSR_WORD_SWAP:\n\n        return s->word_swap;\n\n    case CSR_FREE_RUN:\n\n        return (qemu_get_clock_ns(vm_clock) / 40) - s->free_timer_start;\n\n    case CSR_RX_DROP:\n\n        /* TODO: Implement dropped frames counter.  */\n\n        return 0;\n\n    case CSR_MAC_CSR_CMD:\n\n        return s->mac_cmd;\n\n    case CSR_MAC_CSR_DATA:\n\n        return s->mac_data;\n\n    case CSR_AFC_CFG:\n\n        return s->afc_cfg;\n\n    case CSR_E2P_CMD:\n\n        return s->e2p_cmd;\n\n    case CSR_E2P_DATA:\n\n        return s->e2p_data;\n\n    }\n\n    hw_error(\"lan9118_read: Bad reg 0x%x\\n\", (int)offset);\n\n    return 0;\n\n}\n", "idx": 9255, "_split": "test", "_hash": "5b7c4926c7e45fd281258b5e36c19cae"}
{"project": "qemu", "commit_id": "fc19f8a02e45c4d8ad24dd7eb374330b03dfc28e", "target": 0, "func": "static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,\n\n                          int nb_sectors, QEMUIOVector *qiov,\n\n                          int offset)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n\n\n    request.type = NBD_CMD_READ;\n\n    request.from = sector_num * 512;\n\n    request.len = nb_sectors * 512;\n\n\n\n    nbd_coroutine_start(s, &request);\n\n    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {\n\n        reply.error = errno;\n\n    } else {\n\n        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);\n\n    }\n\n    nbd_coroutine_end(s, &request);\n\n    return -reply.error;\n\n\n\n}\n", "idx": 9260, "_split": "test", "_hash": "121f8f969cd632b299d819139960791b"}
{"project": "qemu", "commit_id": "abda1f37eed86f3501db2e5439c1a7b97171ea22", "target": 1, "func": "int sd_do_command(SDState *sd, SDRequest *req,\n\n                  uint8_t *response) {\n\n    uint32_t last_status = sd->card_status;\n\n    sd_rsp_type_t rtype;\n\n    int rsplen;\n\n\n\n    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) {\n\n        return 0;\n\n    }\n\n\n\n    if (sd_req_crc_validate(req)) {\n\n        sd->card_status &= ~COM_CRC_ERROR;\n\n        return 0;\n\n    }\n\n\n\n    sd->card_status &= ~CARD_STATUS_B;\n\n    sd_set_status(sd);\n\n\n\n    if (last_status & CARD_IS_LOCKED) {\n\n        if (!cmd_valid_while_locked(sd, req)) {\n\n            sd->card_status |= ILLEGAL_COMMAND;\n\n            fprintf(stderr, \"SD: Card is locked\\n\");\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    if (last_status & APP_CMD) {\n\n        rtype = sd_app_command(sd, *req);\n\n        sd->card_status &= ~APP_CMD;\n\n    } else\n\n        rtype = sd_normal_command(sd, *req);\n\n\n\n    sd->current_cmd = req->cmd;\n\n\n\n    switch (rtype) {\n\n    case sd_r1:\n\n    case sd_r1b:\n\n        sd_response_r1_make(sd, response, last_status);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r2_i:\n\n        memcpy(response, sd->cid, sizeof(sd->cid));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r2_s:\n\n        memcpy(response, sd->csd, sizeof(sd->csd));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r3:\n\n        sd_response_r3_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r6:\n\n        sd_response_r6_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r7:\n\n        sd_response_r7_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r0:\n\n    default:\n\n        rsplen = 0;\n\n        break;\n\n    }\n\n\n\n    if (sd->card_status & ILLEGAL_COMMAND)\n\n        rsplen = 0;\n\n\n\n#ifdef DEBUG_SD\n\n    if (rsplen) {\n\n        int i;\n\n        DPRINTF(\"Response:\");\n\n        for (i = 0; i < rsplen; i++)\n\n            printf(\" %02x\", response[i]);\n\n        printf(\" state %d\\n\", sd->state);\n\n    } else {\n\n        DPRINTF(\"No response %d\\n\", sd->state);\n\n    }\n\n#endif\n\n\n\n    return rsplen;\n\n}\n", "idx": 9330, "_split": "test", "_hash": "3b65b37a2dd121062175647b727ccc44"}
{"project": "qemu", "commit_id": "85d604af5f96c32734af9974ec6ddb625b6716a2", "target": 1, "func": "target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,\n\n                             target_ulong r2)\n\n{\n\n    int64_t t1 = extract64(r1, 0, 32);\n\n    int64_t t2 = extract64(r2, 0, 32);\n\n    int64_t result = t1 * t2;\n\n\n\n    return suov32(env, result);\n\n}\n", "idx": 9352, "_split": "test", "_hash": "891e32e77668247cbcf281f6b9a163c6"}
{"project": "qemu", "commit_id": "db12451decf7dfe0f083564183e135f2095228b9", "target": 1, "func": "static void virtio_rng_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n\n\n\n    dc->props = virtio_rng_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    vdc->realize = virtio_rng_device_realize;\n\n    vdc->unrealize = virtio_rng_device_unrealize;\n\n    vdc->get_features = get_features;\n\n    vdc->load = virtio_rng_load_device;\n\n}\n", "idx": 9399, "_split": "test", "_hash": "8f7d4fc09fabdebe89974c0b49e7525b"}
{"project": "qemu", "commit_id": "f65ed4c1529f29a7d62d6733eaa50bed24a4b2ed", "target": 1, "func": "int kvm_init(int smp_cpus)\n{\n    KVMState *s;\n    int ret;\n    int i;\n    if (smp_cpus > 1)\n        return -EINVAL;\n    s = qemu_mallocz(sizeof(KVMState));\n    if (s == NULL)\n        return -ENOMEM;\n    for (i = 0; i < ARRAY_SIZE(s->slots); i++)\n        s->slots[i].slot = i;\n    s->vmfd = -1;\n    s->fd = open(\"/dev/kvm\", O_RDWR);\n    if (s->fd == -1) {\n        fprintf(stderr, \"Could not access KVM kernel module: %m\\n\");\n        ret = -errno;\n        goto err;\n    }\n    ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0);\n    if (ret < KVM_API_VERSION) {\n            ret = -EINVAL;\n        fprintf(stderr, \"kvm version too old\\n\");\n        goto err;\n    }\n    if (ret > KVM_API_VERSION) {\n        ret = -EINVAL;\n        fprintf(stderr, \"kvm version not supported\\n\");\n        goto err;\n    }\n    s->vmfd = kvm_ioctl(s, KVM_CREATE_VM, 0);\n    if (s->vmfd < 0)\n        goto err;\n    /* initially, KVM allocated its own memory and we had to jump through\n     * hooks to make phys_ram_base point to this.  Modern versions of KVM\n     * just use a user allocated buffer so we can use phys_ram_base\n     * unmodified.  Make sure we have a sufficiently modern version of KVM.\n     */\n    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION, KVM_CAP_USER_MEMORY);\n    if (ret <= 0) {\n        if (ret == 0)\n            ret = -EINVAL;\n        fprintf(stderr, \"kvm does not support KVM_CAP_USER_MEMORY\\n\");\n        goto err;\n    }\n    /* There was a nasty bug in < kvm-80 that prevents memory slots from being\n     * destroyed properly.  Since we rely on this capability, refuse to work\n     * with any kernel without this capability. */\n    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION,\n                    KVM_CAP_DESTROY_MEMORY_REGION_WORKS);\n    if (ret <= 0) {\n        if (ret == 0)\n            ret = -EINVAL;\n        fprintf(stderr,\n                \"KVM kernel module broken (DESTROY_MEMORY_REGION)\\n\"\n                \"Please upgrade to at least kvm-81.\\n\");\n        goto err;\n    }\n    ret = kvm_arch_init(s, smp_cpus);\n    if (ret < 0)\n        goto err;\n    kvm_state = s;\n    return 0;\nerr:\n    if (s) {\n        if (s->vmfd != -1)\n            close(s->vmfd);\n        if (s->fd != -1)\n            close(s->fd);\n    }\n    qemu_free(s);\n    return ret;\n}", "idx": 9418, "_split": "test", "_hash": "c418d7bb6fc66caa4ab7f5dacf63dd22"}
{"project": "qemu", "commit_id": "7c24384b3b984f0256ba10eb26d877ec28985019", "target": 1, "func": "static int64_t nfs_client_open(NFSClient *client, const char *filename,\n\n                               int flags, Error **errp)\n\n{\n\n    int ret = -EINVAL, i;\n\n    struct stat st;\n\n    URI *uri;\n\n    QueryParams *qp = NULL;\n\n    char *file = NULL, *strp = NULL;\n\n\n\n    uri = uri_parse(filename);\n\n    if (!uri) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    if (!uri->server) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    strp = strrchr(uri->path, '/');\n\n    if (strp == NULL) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    file = g_strdup(strp);\n\n    *strp = 0;\n\n\n\n    client->context = nfs_init_context();\n\n    if (client->context == NULL) {\n\n        error_setg(errp, \"Failed to init NFS context\");\n\n        goto fail;\n\n    }\n\n\n\n    qp = query_params_parse(uri->query);\n\n    for (i = 0; i < qp->n; i++) {\n\n        if (!qp->p[i].value) {\n\n            error_setg(errp, \"Value for NFS parameter expected: %s\",\n\n                       qp->p[i].name);\n\n            goto fail;\n\n        }\n\n        if (!strncmp(qp->p[i].name, \"uid\", 3)) {\n\n            nfs_set_uid(client->context, atoi(qp->p[i].value));\n\n        } else if (!strncmp(qp->p[i].name, \"gid\", 3)) {\n\n            nfs_set_gid(client->context, atoi(qp->p[i].value));\n\n        } else if (!strncmp(qp->p[i].name, \"tcp-syncnt\", 10)) {\n\n            nfs_set_tcp_syncnt(client->context, atoi(qp->p[i].value));\n\n        } else {\n\n            error_setg(errp, \"Unknown NFS parameter name: %s\",\n\n                       qp->p[i].name);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = nfs_mount(client->context, uri->server, uri->path);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to mount nfs share: %s\",\n\n                   nfs_get_error(client->context));\n\n        goto fail;\n\n    }\n\n\n\n    if (flags & O_CREAT) {\n\n        ret = nfs_creat(client->context, file, 0600, &client->fh);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to create file: %s\",\n\n                       nfs_get_error(client->context));\n\n            goto fail;\n\n        }\n\n    } else {\n\n        ret = nfs_open(client->context, file, flags, &client->fh);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to open file : %s\",\n\n                       nfs_get_error(client->context));\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = nfs_fstat(client->context, client->fh, &st);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to fstat file: %s\",\n\n                   nfs_get_error(client->context));\n\n        goto fail;\n\n    }\n\n\n\n    ret = DIV_ROUND_UP(st.st_size, BDRV_SECTOR_SIZE);\n\n    client->has_zero_init = S_ISREG(st.st_mode);\n\n    goto out;\n\nfail:\n\n    nfs_client_close(client);\n\nout:\n\n    if (qp) {\n\n        query_params_free(qp);\n\n    }\n\n    uri_free(uri);\n\n    g_free(file);\n\n    return ret;\n\n}\n", "idx": 9434, "_split": "test", "_hash": "bf128f75900f48f58e630d39e5163879"}
{"project": "qemu", "commit_id": "41264b385c2b324fea026204e5de9bef980733b1", "target": 1, "func": "static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)\n{\n    CPUState *cs = CPU(dev);\n    PowerPCCPU *cpu = POWERPC_CPU(dev);\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);\n    Error *local_err = NULL;\n#if !defined(CONFIG_USER_ONLY)\n    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;\n#endif\n#if !defined(CONFIG_USER_ONLY)\n    if (smp_threads > max_smt) {\n        error_setg(errp, \"Cannot support more than %d threads on PPC with %s\",\n                   max_smt, kvm_enabled() ? \"KVM\" : \"TCG\");\n    if (!is_power_of_2(smp_threads)) {\n        error_setg(errp, \"Cannot support %d threads on PPC with %s, \"\n                   \"threads count must be a power of 2.\",\n                   smp_threads, kvm_enabled() ? \"KVM\" : \"TCG\");\n#endif\n    cpu_exec_init(cs, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n#if !defined(CONFIG_USER_ONLY)\n    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt\n        + (cs->cpu_index % smp_threads);\n#endif\n    if (tcg_enabled()) {\n        if (ppc_fixup_cpu(cpu) != 0) {\n            error_setg(errp, \"Unable to emulate selected CPU with TCG\");\n#if defined(TARGET_PPCEMB)\n    if (!ppc_cpu_is_valid(pcc)) {\n        error_setg(errp, \"CPU does not possess a BookE or 4xx MMU. \"\n                   \"Please use qemu-system-ppc or qemu-system-ppc64 instead \"\n                   \"or choose another CPU model.\");\n#endif\n    create_ppc_opcodes(cpu, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n    init_ppc_proc(cpu);\n    if (pcc->insns_flags & PPC_FLOAT) {\n        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,\n                                 33, \"power-fpu.xml\", 0);\n    if (pcc->insns_flags & PPC_ALTIVEC) {\n        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,\n                                 34, \"power-altivec.xml\", 0);\n    if (pcc->insns_flags & PPC_SPE) {\n        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,\n                                 34, \"power-spe.xml\", 0);\n    if (pcc->insns_flags2 & PPC2_VSX) {\n        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,\n                                 32, \"power-vsx.xml\", 0);\n    qemu_init_vcpu(cs);\n    pcc->parent_realize(dev, errp);\n#if defined(PPC_DUMP_CPU)\n    {\n        CPUPPCState *env = &cpu->env;\n        const char *mmu_model, *excp_model, *bus_model;\n        switch (env->mmu_model) {\n        case POWERPC_MMU_32B:\n            mmu_model = \"PowerPC 32\";\n            break;\n        case POWERPC_MMU_SOFT_6xx:\n            mmu_model = \"PowerPC 6xx/7xx with software driven TLBs\";\n            break;\n        case POWERPC_MMU_SOFT_74xx:\n            mmu_model = \"PowerPC 74xx with software driven TLBs\";\n            break;\n        case POWERPC_MMU_SOFT_4xx:\n            mmu_model = \"PowerPC 4xx with software driven TLBs\";\n            break;\n        case POWERPC_MMU_SOFT_4xx_Z:\n            mmu_model = \"PowerPC 4xx with software driven TLBs \"\n                \"and zones protections\";\n            break;\n        case POWERPC_MMU_REAL:\n            mmu_model = \"PowerPC real mode only\";\n            break;\n        case POWERPC_MMU_MPC8xx:\n            mmu_model = \"PowerPC MPC8xx\";\n            break;\n        case POWERPC_MMU_BOOKE:\n            mmu_model = \"PowerPC BookE\";\n            break;\n        case POWERPC_MMU_BOOKE206:\n            mmu_model = \"PowerPC BookE 2.06\";\n            break;\n        case POWERPC_MMU_601:\n            mmu_model = \"PowerPC 601\";\n            break;\n#if defined (TARGET_PPC64)\n        case POWERPC_MMU_64B:\n            mmu_model = \"PowerPC 64\";\n            break;\n#endif\n        default:\n            mmu_model = \"Unknown or invalid\";\n            break;\n        switch (env->excp_model) {\n        case POWERPC_EXCP_STD:\n            excp_model = \"PowerPC\";\n            break;\n        case POWERPC_EXCP_40x:\n            excp_model = \"PowerPC 40x\";\n            break;\n        case POWERPC_EXCP_601:\n            excp_model = \"PowerPC 601\";\n            break;\n        case POWERPC_EXCP_602:\n            excp_model = \"PowerPC 602\";\n            break;\n        case POWERPC_EXCP_603:\n            excp_model = \"PowerPC 603\";\n            break;\n        case POWERPC_EXCP_603E:\n            excp_model = \"PowerPC 603e\";\n            break;\n        case POWERPC_EXCP_604:\n            excp_model = \"PowerPC 604\";\n            break;\n        case POWERPC_EXCP_7x0:\n            excp_model = \"PowerPC 740/750\";\n            break;\n        case POWERPC_EXCP_7x5:\n            excp_model = \"PowerPC 745/755\";\n            break;\n        case POWERPC_EXCP_74xx:\n            excp_model = \"PowerPC 74xx\";\n            break;\n        case POWERPC_EXCP_BOOKE:\n            excp_model = \"PowerPC BookE\";\n            break;\n#if defined (TARGET_PPC64)\n        case POWERPC_EXCP_970:\n            excp_model = \"PowerPC 970\";\n            break;\n#endif\n        default:\n            excp_model = \"Unknown or invalid\";\n            break;\n        switch (env->bus_model) {\n        case PPC_FLAGS_INPUT_6xx:\n            bus_model = \"PowerPC 6xx\";\n            break;\n        case PPC_FLAGS_INPUT_BookE:\n            bus_model = \"PowerPC BookE\";\n            break;\n        case PPC_FLAGS_INPUT_405:\n            bus_model = \"PowerPC 405\";\n            break;\n        case PPC_FLAGS_INPUT_401:\n            bus_model = \"PowerPC 401/403\";\n            break;\n        case PPC_FLAGS_INPUT_RCPU:\n            bus_model = \"RCPU / MPC8xx\";\n            break;\n#if defined (TARGET_PPC64)\n        case PPC_FLAGS_INPUT_970:\n            bus_model = \"PowerPC 970\";\n            break;\n#endif\n        default:\n            bus_model = \"Unknown or invalid\";\n            break;\n        printf(\"PowerPC %-12s : PVR %08x MSR %016\" PRIx64 \"\\n\"\n               \"    MMU model        : %s\\n\",\n               object_class_get_name(OBJECT_CLASS(pcc)),\n               pcc->pvr, pcc->msr_mask, mmu_model);\n#if !defined(CONFIG_USER_ONLY)\n        if (env->tlb.tlb6) {\n            printf(\"                       %d %s TLB in %d ways\\n\",\n                   env->nb_tlb, env->id_tlbs ? \"splitted\" : \"merged\",\n                   env->nb_ways);\n#endif\n        printf(\"    Exceptions model : %s\\n\"\n               \"    Bus model        : %s\\n\",\n               excp_model, bus_model);\n        printf(\"    MSR features     :\\n\");\n        if (env->flags & POWERPC_FLAG_SPE)\n            printf(\"                        signal processing engine enable\"\n                   \"\\n\");\n        else if (env->flags & POWERPC_FLAG_VRE)\n            printf(\"                        vector processor enable\\n\");\n        if (env->flags & POWERPC_FLAG_TGPR)\n            printf(\"                        temporary GPRs\\n\");\n        else if (env->flags & POWERPC_FLAG_CE)\n            printf(\"                        critical input enable\\n\");\n        if (env->flags & POWERPC_FLAG_SE)\n            printf(\"                        single-step trace mode\\n\");\n        else if (env->flags & POWERPC_FLAG_DWE)\n            printf(\"                        debug wait enable\\n\");\n        else if (env->flags & POWERPC_FLAG_UBLE)\n            printf(\"                        user BTB lock enable\\n\");\n        if (env->flags & POWERPC_FLAG_BE)\n            printf(\"                        branch-step trace mode\\n\");\n        else if (env->flags & POWERPC_FLAG_DE)\n            printf(\"                        debug interrupt enable\\n\");\n        if (env->flags & POWERPC_FLAG_PX)\n            printf(\"                        inclusive protection\\n\");\n        else if (env->flags & POWERPC_FLAG_PMM)\n            printf(\"                        performance monitor mark\\n\");\n        if (env->flags == POWERPC_FLAG_NONE)\n            printf(\"                        none\\n\");\n        printf(\"    Time-base/decrementer clock source: %s\\n\",\n               env->flags & POWERPC_FLAG_RTC_CLK ? \"RTC clock\" : \"bus clock\");\n        dump_ppc_insns(env);\n        dump_ppc_sprs(env);\n        fflush(stdout);\n#endif", "idx": 9437, "_split": "test", "_hash": "cf1032dc5f7c719c138d42895d77b5b3"}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    RamDevice *d;\n\n\n\n    /* allocate RAM */\n\n    dev = qdev_create(NULL, \"memory\");\n\n    s = sysbus_from_qdev(dev);\n\n\n\n    d = FROM_SYSBUS(RamDevice, s);\n\n    d->size = RAM_size;\n\n    qdev_init(dev);\n\n\n\n    sysbus_mmio_map(s, 0, addr);\n\n}\n", "idx": 9443, "_split": "test", "_hash": "1f4f7f4f81255b308b86fbb536193bbe"}
{"project": "qemu", "commit_id": "49aa4058ac6dd0081aaa45776f07c98df397ca5e", "target": 1, "func": "QemuOpts *qemu_chr_parse_compat(const char *label, const char *filename)\n\n{\n\n    char host[65], port[33], width[8], height[8];\n\n    int pos;\n\n    const char *p;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n\n\n    opts = qemu_opts_create(qemu_find_opts(\"chardev\"), label, 1, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        return NULL;\n\n    }\n\n\n\n    if (strstart(filename, \"mon:\", &p)) {\n\n        filename = p;\n\n        qemu_opt_set(opts, \"mux\", \"on\");\n\n        if (strcmp(filename, \"stdio\") == 0) {\n\n            /* Monitor is muxed to stdio: do not exit on Ctrl+C by default\n\n             * but pass it to the guest.  Handle this only for compat syntax,\n\n             * for -chardev syntax we have special option for this.\n\n             * This is what -nographic did, redirecting+muxing serial+monitor\n\n             * to stdio causing Ctrl+C to be passed to guest. */\n\n            qemu_opt_set(opts, \"signal\", \"off\");\n\n        }\n\n    }\n\n\n\n    if (strcmp(filename, \"null\")    == 0 ||\n\n        strcmp(filename, \"pty\")     == 0 ||\n\n        strcmp(filename, \"msmouse\") == 0 ||\n\n        strcmp(filename, \"braille\") == 0 ||\n\n        strcmp(filename, \"stdio\")   == 0) {\n\n        qemu_opt_set(opts, \"backend\", filename);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"vc\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"vc\");\n\n        if (*p == ':') {\n\n            if (sscanf(p+1, \"%8[0-9]x%8[0-9]\", width, height) == 2) {\n\n                /* pixels */\n\n                qemu_opt_set(opts, \"width\", width);\n\n                qemu_opt_set(opts, \"height\", height);\n\n            } else if (sscanf(p+1, \"%8[0-9]Cx%8[0-9]C\", width, height) == 2) {\n\n                /* chars */\n\n                qemu_opt_set(opts, \"cols\", width);\n\n                qemu_opt_set(opts, \"rows\", height);\n\n            } else {\n\n                goto fail;\n\n            }\n\n        }\n\n        return opts;\n\n    }\n\n    if (strcmp(filename, \"con:\") == 0) {\n\n        qemu_opt_set(opts, \"backend\", \"console\");\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"COM\", NULL)) {\n\n        qemu_opt_set(opts, \"backend\", \"serial\");\n\n        qemu_opt_set(opts, \"path\", filename);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"file:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"file\");\n\n        qemu_opt_set(opts, \"path\", p);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"pipe:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"pipe\");\n\n        qemu_opt_set(opts, \"path\", p);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"tcp:\", &p) ||\n\n        strstart(filename, \"telnet:\", &p)) {\n\n        if (sscanf(p, \"%64[^:]:%32[^,]%n\", host, port, &pos) < 2) {\n\n            host[0] = 0;\n\n            if (sscanf(p, \":%32[^,]%n\", port, &pos) < 1)\n\n                goto fail;\n\n        }\n\n        qemu_opt_set(opts, \"backend\", \"socket\");\n\n        qemu_opt_set(opts, \"host\", host);\n\n        qemu_opt_set(opts, \"port\", port);\n\n        if (p[pos] == ',') {\n\n            if (qemu_opts_do_parse(opts, p+pos+1, NULL) != 0)\n\n                goto fail;\n\n        }\n\n        if (strstart(filename, \"telnet:\", &p))\n\n            qemu_opt_set(opts, \"telnet\", \"on\");\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"udp:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"udp\");\n\n        if (sscanf(p, \"%64[^:]:%32[^@,]%n\", host, port, &pos) < 2) {\n\n            host[0] = 0;\n\n            if (sscanf(p, \":%32[^@,]%n\", port, &pos) < 1) {\n\n                goto fail;\n\n            }\n\n        }\n\n        qemu_opt_set(opts, \"host\", host);\n\n        qemu_opt_set(opts, \"port\", port);\n\n        if (p[pos] == '@') {\n\n            p += pos + 1;\n\n            if (sscanf(p, \"%64[^:]:%32[^,]%n\", host, port, &pos) < 2) {\n\n                host[0] = 0;\n\n                if (sscanf(p, \":%32[^,]%n\", port, &pos) < 1) {\n\n                    goto fail;\n\n                }\n\n            }\n\n            qemu_opt_set(opts, \"localaddr\", host);\n\n            qemu_opt_set(opts, \"localport\", port);\n\n        }\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"unix:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"socket\");\n\n        if (qemu_opts_do_parse(opts, p, \"path\") != 0)\n\n            goto fail;\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"/dev/parport\", NULL) ||\n\n        strstart(filename, \"/dev/ppi\", NULL)) {\n\n        qemu_opt_set(opts, \"backend\", \"parport\");\n\n        qemu_opt_set(opts, \"path\", filename);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"/dev/\", NULL)) {\n\n        qemu_opt_set(opts, \"backend\", \"tty\");\n\n        qemu_opt_set(opts, \"path\", filename);\n\n        return opts;\n\n    }\n\n\n\nfail:\n\n    qemu_opts_del(opts);\n\n    return NULL;\n\n}\n", "idx": 9445, "_split": "test", "_hash": "48860cdf776f5becb96f1163986b4fd1"}
{"project": "qemu", "commit_id": "c73860803f8f8f56ee01b6e796507bfb4ea073ec", "target": 1, "func": "POWERPC_FAMILY(POWER8)(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n\n\n    dc->fw_name = \"PowerPC,POWER8\";\n\n    dc->desc = \"POWER8\";\n\n    pcc->pvr = CPU_POWERPC_POWER8_BASE;\n\n    pcc->pvr_mask = CPU_POWERPC_POWER8_MASK;\n\n    pcc->init_proc = init_proc_POWER7;\n\n    pcc->check_pow = check_pow_nocheck;\n\n    pcc->insns_flags = PPC_INSNS_BASE | PPC_STRING | PPC_MFTB |\n\n                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |\n\n                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |\n\n                       PPC_FLOAT_STFIWX |\n\n\n                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |\n\n                       PPC_MEM_SYNC | PPC_MEM_EIEIO |\n\n                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |\n\n                       PPC_64B | PPC_ALTIVEC |\n\n                       PPC_SEGMENT_64B | PPC_SLBI |\n\n                       PPC_POPCNTB | PPC_POPCNTWD;\n\n    pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |\n\n                        PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |\n\n                        PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206;\n\n    pcc->msr_mask = 0x800000000284FF36ULL;\n\n    pcc->mmu_model = POWERPC_MMU_2_06;\n\n#if defined(CONFIG_SOFTMMU)\n\n    pcc->handle_mmu_fault = ppc_hash64_handle_mmu_fault;\n\n#endif\n\n    pcc->excp_model = POWERPC_EXCP_POWER7;\n\n    pcc->bus_model = PPC_FLAGS_INPUT_POWER7;\n\n    pcc->bfd_mach = bfd_mach_ppc64;\n\n    pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |\n\n                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |\n\n                 POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR |\n\n                 POWERPC_FLAG_VSX;\n\n    pcc->l1_dcache_size = 0x8000;\n\n    pcc->l1_icache_size = 0x8000;\n\n}", "idx": 9457, "_split": "test", "_hash": "867843943ef509fec662d4d5189b7d0d"}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "static int qemu_rdma_register_and_get_keys(RDMAContext *rdma,\n\n        RDMALocalBlock *block, uintptr_t host_addr,\n\n        uint32_t *lkey, uint32_t *rkey, int chunk,\n\n        uint8_t *chunk_start, uint8_t *chunk_end)\n\n{\n\n    if (block->mr) {\n\n        if (lkey) {\n\n            *lkey = block->mr->lkey;\n\n        }\n\n        if (rkey) {\n\n            *rkey = block->mr->rkey;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    /* allocate memory to store chunk MRs */\n\n    if (!block->pmr) {\n\n        block->pmr = g_malloc0(block->nb_chunks * sizeof(struct ibv_mr *));\n\n    }\n\n\n\n    /*\n\n     * If 'rkey', then we're the destination, so grant access to the source.\n\n     *\n\n     * If 'lkey', then we're the source VM, so grant access only to ourselves.\n\n     */\n\n    if (!block->pmr[chunk]) {\n\n        uint64_t len = chunk_end - chunk_start;\n\n\n\n        trace_qemu_rdma_register_and_get_keys(len, chunk_start);\n\n\n\n        block->pmr[chunk] = ibv_reg_mr(rdma->pd,\n\n                chunk_start, len,\n\n                (rkey ? (IBV_ACCESS_LOCAL_WRITE |\n\n                        IBV_ACCESS_REMOTE_WRITE) : 0));\n\n\n\n        if (!block->pmr[chunk]) {\n\n            perror(\"Failed to register chunk!\");\n\n            fprintf(stderr, \"Chunk details: block: %d chunk index %d\"\n\n                            \" start %\" PRIuPTR \" end %\" PRIuPTR\n\n                            \" host %\" PRIuPTR\n\n                            \" local %\" PRIuPTR \" registrations: %d\\n\",\n\n                            block->index, chunk, (uintptr_t)chunk_start,\n\n                            (uintptr_t)chunk_end, host_addr,\n\n                            (uintptr_t)block->local_host_addr,\n\n                            rdma->total_registrations);\n\n            return -1;\n\n        }\n\n        rdma->total_registrations++;\n\n    }\n\n\n\n    if (lkey) {\n\n        *lkey = block->pmr[chunk]->lkey;\n\n    }\n\n    if (rkey) {\n\n        *rkey = block->pmr[chunk]->rkey;\n\n    }\n\n    return 0;\n\n}\n", "idx": 9508, "_split": "test", "_hash": "c1c5395b271ad71b2451ee7532317795"}
{"project": "qemu", "commit_id": "e3697092228770c3b23d0bf524e18b508b109932", "target": 1, "func": "static void vga_draw_graphic(VGAState *s, int full_update)\n\n{\n\n    int y1, y, update, page_min, page_max, linesize, y_start, double_scan, mask, depth;\n\n    int width, height, shift_control, line_offset, page0, page1, bwidth, bits;\n\n    int disp_width, multi_scan, multi_run;\n\n    uint8_t *d;\n\n    uint32_t v, addr1, addr;\n\n    vga_draw_line_func *vga_draw_line;\n\n\n\n    full_update |= update_basic_params(s);\n\n\n\n    if (!full_update)\n\n        vga_sync_dirty_bitmap(s);\n\n\n\n    s->get_resolution(s, &width, &height);\n\n    disp_width = width;\n\n\n\n    shift_control = (s->gr[0x05] >> 5) & 3;\n\n    double_scan = (s->cr[0x09] >> 7);\n\n    if (shift_control != 1) {\n\n        multi_scan = (((s->cr[0x09] & 0x1f) + 1) << double_scan) - 1;\n\n    } else {\n\n        /* in CGA modes, multi_scan is ignored */\n\n        /* XXX: is it correct ? */\n\n        multi_scan = double_scan;\n\n    }\n\n    multi_run = multi_scan;\n\n    if (shift_control != s->shift_control ||\n\n        double_scan != s->double_scan) {\n\n        full_update = 1;\n\n        s->shift_control = shift_control;\n\n        s->double_scan = double_scan;\n\n    }\n\n\n\n    if (shift_control == 0) {\n\n        full_update |= update_palette16(s);\n\n        if (s->sr[0x01] & 8) {\n\n            v = VGA_DRAW_LINE4D2;\n\n            disp_width <<= 1;\n\n        } else {\n\n            v = VGA_DRAW_LINE4;\n\n        }\n\n        bits = 4;\n\n    } else if (shift_control == 1) {\n\n        full_update |= update_palette16(s);\n\n        if (s->sr[0x01] & 8) {\n\n            v = VGA_DRAW_LINE2D2;\n\n            disp_width <<= 1;\n\n        } else {\n\n            v = VGA_DRAW_LINE2;\n\n        }\n\n        bits = 4;\n\n    } else {\n\n        switch(s->get_bpp(s)) {\n\n        default:\n\n        case 0:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8D2;\n\n            bits = 4;\n\n            break;\n\n        case 8:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8;\n\n            bits = 8;\n\n            break;\n\n        case 15:\n\n            v = VGA_DRAW_LINE15;\n\n            bits = 16;\n\n            break;\n\n        case 16:\n\n            v = VGA_DRAW_LINE16;\n\n            bits = 16;\n\n            break;\n\n        case 24:\n\n            v = VGA_DRAW_LINE24;\n\n            bits = 24;\n\n            break;\n\n        case 32:\n\n            v = VGA_DRAW_LINE32;\n\n            bits = 32;\n\n            break;\n\n        }\n\n    }\n\n    vga_draw_line = vga_draw_line_table[v * NB_DEPTHS + get_depth_index(s->ds)];\n\n\n\n    depth = s->get_bpp(s);\n\n    if (s->line_offset != s->last_line_offset ||\n\n        disp_width != s->last_width ||\n\n        height != s->last_height ||\n\n        s->last_depth != depth) {\n\n        if (depth == 16 || depth == 32) {\n\n            if (is_graphic_console()) {\n\n                qemu_free_displaysurface(s->ds->surface);\n\n                s->ds->surface = qemu_create_displaysurface_from(disp_width, height, depth,\n\n                                                               s->line_offset,\n\n                                                               s->vram_ptr + (s->start_addr * 4));\n\n                dpy_resize(s->ds);\n\n            } else {\n\n                qemu_console_resize(s->ds, disp_width, height);\n\n            }\n\n        } else {\n\n            qemu_console_resize(s->ds, disp_width, height);\n\n        }\n\n        s->last_scr_width = disp_width;\n\n        s->last_scr_height = height;\n\n        s->last_width = disp_width;\n\n        s->last_height = height;\n\n        s->last_line_offset = s->line_offset;\n\n        s->last_depth = depth;\n\n        full_update = 1;\n\n    } else if (is_graphic_console() && is_buffer_shared(s->ds->surface) &&\n\n               (full_update || s->ds->surface->data != s->vram_ptr + (s->start_addr * 4))) {\n\n        s->ds->surface->data = s->vram_ptr + (s->start_addr * 4);\n\n        dpy_setdata(s->ds);\n\n    }\n\n\n\n    s->rgb_to_pixel =\n\n        rgb_to_pixel_dup_table[get_depth_index(s->ds)];\n\n\n\n    if (!is_buffer_shared(s->ds->surface) && s->cursor_invalidate)\n\n        s->cursor_invalidate(s);\n\n\n\n    line_offset = s->line_offset;\n\n#if 0\n\n    printf(\"w=%d h=%d v=%d line_offset=%d cr[0x09]=0x%02x cr[0x17]=0x%02x linecmp=%d sr[0x01]=0x%02x\\n\",\n\n           width, height, v, line_offset, s->cr[9], s->cr[0x17], s->line_compare, s->sr[0x01]);\n\n#endif\n\n    addr1 = (s->start_addr * 4);\n\n    bwidth = (width * bits + 7) / 8;\n\n    y_start = -1;\n\n    page_min = 0x7fffffff;\n\n    page_max = -1;\n\n    d = ds_get_data(s->ds);\n\n    linesize = ds_get_linesize(s->ds);\n\n    y1 = 0;\n\n    for(y = 0; y < height; y++) {\n\n        addr = addr1;\n\n        if (!(s->cr[0x17] & 1)) {\n\n            int shift;\n\n            /* CGA compatibility handling */\n\n            shift = 14 + ((s->cr[0x17] >> 6) & 1);\n\n            addr = (addr & ~(1 << shift)) | ((y1 & 1) << shift);\n\n        }\n\n        if (!(s->cr[0x17] & 2)) {\n\n            addr = (addr & ~0x8000) | ((y1 & 2) << 14);\n\n        }\n\n        page0 = s->vram_offset + (addr & TARGET_PAGE_MASK);\n\n        page1 = s->vram_offset + ((addr + bwidth - 1) & TARGET_PAGE_MASK);\n\n        update = full_update |\n\n            cpu_physical_memory_get_dirty(page0, VGA_DIRTY_FLAG) |\n\n            cpu_physical_memory_get_dirty(page1, VGA_DIRTY_FLAG);\n\n        if ((page1 - page0) > TARGET_PAGE_SIZE) {\n\n            /* if wide line, can use another page */\n\n            update |= cpu_physical_memory_get_dirty(page0 + TARGET_PAGE_SIZE,\n\n                                                    VGA_DIRTY_FLAG);\n\n        }\n\n        /* explicit invalidation for the hardware cursor */\n\n        update |= (s->invalidated_y_table[y >> 5] >> (y & 0x1f)) & 1;\n\n        if (update) {\n\n            if (y_start < 0)\n\n                y_start = y;\n\n            if (page0 < page_min)\n\n                page_min = page0;\n\n            if (page1 > page_max)\n\n                page_max = page1;\n\n            if (!(is_buffer_shared(s->ds->surface))) {\n\n                vga_draw_line(s, d, s->vram_ptr + addr, width);\n\n                if (s->cursor_draw_line)\n\n                    s->cursor_draw_line(s, d, y);\n\n            }\n\n        } else {\n\n            if (y_start >= 0) {\n\n                /* flush to display */\n\n                dpy_update(s->ds, 0, y_start,\n\n                           disp_width, y - y_start);\n\n                y_start = -1;\n\n            }\n\n        }\n\n        if (!multi_run) {\n\n            mask = (s->cr[0x17] & 3) ^ 3;\n\n            if ((y1 & mask) == mask)\n\n                addr1 += line_offset;\n\n            y1++;\n\n            multi_run = multi_scan;\n\n        } else {\n\n            multi_run--;\n\n        }\n\n        /* line compare acts on the displayed lines */\n\n        if (y == s->line_compare)\n\n            addr1 = 0;\n\n        d += linesize;\n\n    }\n\n    if (y_start >= 0) {\n\n        /* flush to display */\n\n        dpy_update(s->ds, 0, y_start,\n\n                   disp_width, y - y_start);\n\n    }\n\n    /* reset modified pages */\n\n    if (page_max != -1) {\n\n        cpu_physical_memory_reset_dirty(page_min, page_max + TARGET_PAGE_SIZE,\n\n                                        VGA_DIRTY_FLAG);\n\n    }\n\n    memset(s->invalidated_y_table, 0, ((height + 31) >> 5) * 4);\n\n}\n", "idx": 9509, "_split": "test", "_hash": "66a819e63b6ed50d15bdde68e766333f"}
{"project": "qemu", "commit_id": "9e472e101f37233f4e32d181d2fee29014c1cf2f", "target": 1, "func": "static int qemu_signalfd_compat(const sigset_t *mask)\n\n{\n\n    pthread_attr_t attr;\n\n    pthread_t tid;\n\n    struct sigfd_compat_info *info;\n\n    int fds[2];\n\n\n\n    info = malloc(sizeof(*info));\n\n    if (info == NULL) {\n\n        errno = ENOMEM;\n\n        return -1;\n\n    }\n\n\n\n    if (pipe(fds) == -1) {\n\n        free(info);\n\n        return -1;\n\n    }\n\n\n\n    memcpy(&info->mask, mask, sizeof(*mask));\n\n    info->fd = fds[1];\n\n\n\n    pthread_attr_init(&attr);\n\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n\n\n    pthread_create(&tid, &attr, sigwait_compat, info);\n\n\n\n    pthread_attr_destroy(&attr);\n\n\n\n    return fds[0];\n\n}\n", "idx": 9510, "_split": "test", "_hash": "fa073853cd5ad0b73612eeeaf0cc169f"}
{"project": "qemu", "commit_id": "7364dbdabb7824d5bde1e341bb6d928282f01c83", "target": 1, "func": "static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    uint32_t startlen = read_u32(data, 0);\n\n    VNC_DEBUG(\"Got client start len %d\\n\", startlen);\n\n    if (startlen > SASL_DATA_MAX_LEN) {\n\n        VNC_DEBUG(\"Too much SASL data %d\\n\", startlen);\n\n        vnc_client_error(vs);\n\n        return -1;\n\n    }\n\n\n\n    if (startlen == 0)\n\n        return protocol_client_auth_sasl_start(vs, NULL, 0);\n\n\n\n    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);\n\n    return 0;\n\n}\n", "idx": 9516, "_split": "test", "_hash": "a46cab3da2f7b012c93cd6cd7847e9c1"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,\n\n                                target_ulong pc2, TCGv r_cond)\n\n{\n\n    int l1;\n\n\n\n    l1 = gen_new_label();\n\n\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);\n\n\n\n    gen_goto_tb(dc, 0, pc2, pc1);\n\n\n\n    gen_set_label(l1);\n\n    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);\n\n}\n", "idx": 9546, "_split": "test", "_hash": "91a1edd19afe7005b64a870ad455f6ce"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "uint64_t qcow2_alloc_cluster_offset(BlockDriverState *bs,\n\n                                    uint64_t offset,\n\n                                    int n_start, int n_end,\n\n                                    int *num, QCowL2Meta *m)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l2_index, ret;\n\n    uint64_t l2_offset, *l2_table, cluster_offset;\n\n    int nb_clusters, i = 0;\n\n    QCowL2Meta *old_alloc;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_offset, &l2_index);\n\n    if (ret == 0)\n\n        return 0;\n\n\n\n    nb_clusters = size_to_clusters(s, n_end << 9);\n\n\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n\n\n    /* We keep all QCOW_OFLAG_COPIED clusters */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COPIED) {\n\n        nb_clusters = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], 0, 0);\n\n\n\n        cluster_offset &= ~QCOW_OFLAG_COPIED;\n\n        m->nb_clusters = 0;\n\n\n\n        goto out;\n\n    }\n\n\n\n    /* for the moment, multiple compressed clusters are not managed */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COMPRESSED)\n\n        nb_clusters = 1;\n\n\n\n    /* how many available clusters ? */\n\n\n\n    while (i < nb_clusters) {\n\n        i += count_contiguous_clusters(nb_clusters - i, s->cluster_size,\n\n                &l2_table[l2_index], i, 0);\n\n\n\n        if(be64_to_cpu(l2_table[l2_index + i]))\n\n            break;\n\n\n\n        i += count_contiguous_free_clusters(nb_clusters - i,\n\n                &l2_table[l2_index + i]);\n\n\n\n        cluster_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        if ((cluster_offset & QCOW_OFLAG_COPIED) ||\n\n                (cluster_offset & QCOW_OFLAG_COMPRESSED))\n\n            break;\n\n    }\n\n    nb_clusters = i;\n\n\n\n    /*\n\n     * Check if there already is an AIO write request in flight which allocates\n\n     * the same cluster. In this case we need to wait until the previous\n\n     * request has completed and updated the L2 table accordingly.\n\n     */\n\n    LIST_FOREACH(old_alloc, &s->cluster_allocs, next_in_flight) {\n\n\n\n        uint64_t end_offset = offset + nb_clusters * s->cluster_size;\n\n        uint64_t old_offset = old_alloc->offset;\n\n        uint64_t old_end_offset = old_alloc->offset +\n\n            old_alloc->nb_clusters * s->cluster_size;\n\n\n\n        if (end_offset < old_offset || offset > old_end_offset) {\n\n            /* No intersection */\n\n        } else {\n\n            if (offset < old_offset) {\n\n                /* Stop at the start of a running allocation */\n\n                nb_clusters = (old_offset - offset) >> s->cluster_bits;\n\n            } else {\n\n                nb_clusters = 0;\n\n            }\n\n\n\n            if (nb_clusters == 0) {\n\n                /* Set dependency and wait for a callback */\n\n                m->depends_on = old_alloc;\n\n                m->nb_clusters = 0;\n\n                *num = 0;\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!nb_clusters) {\n\n        abort();\n\n    }\n\n\n\n    LIST_INSERT_HEAD(&s->cluster_allocs, m, next_in_flight);\n\n\n\n    /* allocate a new cluster */\n\n\n\n    cluster_offset = qcow2_alloc_clusters(bs, nb_clusters * s->cluster_size);\n\n\n\n    /* save info needed for meta data update */\n\n    m->offset = offset;\n\n    m->n_start = n_start;\n\n    m->nb_clusters = nb_clusters;\n\n\n\nout:\n\n    m->nb_available = MIN(nb_clusters << (s->cluster_bits - 9), n_end);\n\n\n\n    *num = m->nb_available - n_start;\n\n\n\n    return cluster_offset;\n\n}\n", "idx": 9548, "_split": "test", "_hash": "a796707a3eb9f217008b24893e8101a6"}
{"project": "qemu", "commit_id": "ef1e1e0782e99c9dcf2b35e5310cdd8ca9211374", "target": 0, "func": "static int tx_consume(Rocker *r, DescInfo *info)\n\n{\n\n    PCIDevice *dev = PCI_DEVICE(r);\n\n    char *buf = desc_get_buf(info, true);\n\n    RockerTlv *tlv_frag;\n\n    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];\n\n    struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };\n\n    uint32_t pport;\n\n    uint32_t port;\n\n    uint16_t tx_offload = ROCKER_TX_OFFLOAD_NONE;\n\n    uint16_t tx_l3_csum_off = 0;\n\n    uint16_t tx_tso_mss = 0;\n\n    uint16_t tx_tso_hdr_len = 0;\n\n    int iovcnt = 0;\n\n    int err = ROCKER_OK;\n\n    int rem;\n\n    int i;\n\n\n\n    if (!buf) {\n\n        return -ROCKER_ENXIO;\n\n    }\n\n\n\n    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));\n\n\n\n    if (!tlvs[ROCKER_TLV_TX_FRAGS]) {\n\n        return -ROCKER_EINVAL;\n\n    }\n\n\n\n    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));\n\n    if (!fp_port_from_pport(pport, &port)) {\n\n        return -ROCKER_EINVAL;\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_OFFLOAD]) {\n\n        tx_offload = rocker_tlv_get_u8(tlvs[ROCKER_TLV_TX_OFFLOAD]);\n\n    }\n\n\n\n    switch (tx_offload) {\n\n    case ROCKER_TX_OFFLOAD_L3_CSUM:\n\n        if (!tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]) {\n\n            return -ROCKER_EINVAL;\n\n        }\n\n        break;\n\n    case ROCKER_TX_OFFLOAD_TSO:\n\n        if (!tlvs[ROCKER_TLV_TX_TSO_MSS] ||\n\n            !tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]) {\n\n            return -ROCKER_EINVAL;\n\n        }\n\n        break;\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]) {\n\n        tx_l3_csum_off = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]);\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_TSO_MSS]) {\n\n        tx_tso_mss = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_TSO_MSS]);\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]) {\n\n        tx_tso_hdr_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]);\n\n    }\n\n\n\n    rocker_tlv_for_each_nested(tlv_frag, tlvs[ROCKER_TLV_TX_FRAGS], rem) {\n\n        hwaddr frag_addr;\n\n        uint16_t frag_len;\n\n\n\n        if (rocker_tlv_type(tlv_frag) != ROCKER_TLV_TX_FRAG) {\n\n            err = -ROCKER_EINVAL;\n\n            goto err_bad_attr;\n\n        }\n\n\n\n        rocker_tlv_parse_nested(tlvs, ROCKER_TLV_TX_FRAG_ATTR_MAX, tlv_frag);\n\n\n\n        if (!tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR] ||\n\n            !tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]) {\n\n            err = -ROCKER_EINVAL;\n\n            goto err_bad_attr;\n\n        }\n\n\n\n        frag_addr = rocker_tlv_get_le64(tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR]);\n\n        frag_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]);\n\n\n\n        iov[iovcnt].iov_len = frag_len;\n\n        iov[iovcnt].iov_base = g_malloc(frag_len);\n\n        if (!iov[iovcnt].iov_base) {\n\n            err = -ROCKER_ENOMEM;\n\n            goto err_no_mem;\n\n        }\n\n\n\n        if (pci_dma_read(dev, frag_addr, iov[iovcnt].iov_base,\n\n                     iov[iovcnt].iov_len)) {\n\n            err = -ROCKER_ENXIO;\n\n            goto err_bad_io;\n\n        }\n\n\n\n        if (++iovcnt > ROCKER_TX_FRAGS_MAX) {\n\n            goto err_too_many_frags;\n\n        }\n\n    }\n\n\n\n    if (iovcnt) {\n\n        /* XXX perform Tx offloads */\n\n        /* XXX   silence compiler for now */\n\n        tx_l3_csum_off += tx_tso_mss = tx_tso_hdr_len = 0;\n\n    }\n\n\n\n    err = fp_port_eg(r->fp_port[port], iov, iovcnt);\n\n\n\nerr_too_many_frags:\n\nerr_bad_io:\n\nerr_no_mem:\n\nerr_bad_attr:\n\n    for (i = 0; i < ROCKER_TX_FRAGS_MAX; i++) {\n\n        if (iov[i].iov_base) {\n\n            g_free(iov[i].iov_base);\n\n        }\n\n    }\n\n\n\n    return err;\n\n}\n", "idx": 9574, "_split": "test", "_hash": "84b2ce1dc5e4cfd2e97379334906a7dc"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB,\n\n              CharDriverState *chrA, CharDriverState *chrB,\n\n              int clock, int it_shift)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    SerialState *d;\n\n\n\n    dev = qdev_create(NULL, \"escc\");\n\n    qdev_prop_set_uint32(dev, \"disabled\", 0);\n\n    qdev_prop_set_uint32(dev, \"frequency\", clock);\n\n    qdev_prop_set_uint32(dev, \"it_shift\", it_shift);\n\n    qdev_prop_set_chr(dev, \"chrB\", chrB);\n\n    qdev_prop_set_chr(dev, \"chrA\", chrA);\n\n    qdev_prop_set_uint32(dev, \"chnBtype\", ser);\n\n    qdev_prop_set_uint32(dev, \"chnAtype\", ser);\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irqB);\n\n    sysbus_connect_irq(s, 1, irqA);\n\n    if (base) {\n\n        sysbus_mmio_map(s, 0, base);\n\n    }\n\n\n\n    d = FROM_SYSBUS(SerialState, s);\n\n    return &d->mmio;\n\n}\n", "idx": 9584, "_split": "test", "_hash": "a51cf3ea87d4b1a80253626d5073f4c2"}
{"project": "qemu", "commit_id": "603987488c61ca02ee99890d07cdaecdb118a659", "target": 1, "func": "PCIBus *pci_pmac_init(qemu_irq *pic)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    UNINState *d;\n\n\n\n    /* Use values found on a real PowerMac */\n\n    /* Uninorth main bus */\n\n    dev = qdev_create(NULL, \"Uni-north main\");\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    d = FROM_SYSBUS(UNINState, s);\n\n    d->host_state.bus = pci_register_bus(&d->busdev.qdev, \"pci\",\n\n                                         pci_unin_set_irq, pci_unin_map_irq,\n\n                                         pic, 11 << 3, 4);\n\n\n\n    pci_create_simple(d->host_state.bus, 11 << 3, \"Uni-north main\");\n\n\n\n    sysbus_mmio_map(s, 0, 0xf2800000);\n\n    sysbus_mmio_map(s, 1, 0xf2c00000);\n\n\n\n    /* DEC 21154 bridge */\n\n#if 0\n\n    /* XXX: not activated as PPC BIOS doesn't handle multiple buses properly */\n\n    pci_create_simple(d->host_state.bus, 12 << 3, \"DEC 21154\");\n\n#endif\n\n\n\n    /* Uninorth AGP bus */\n\n    pci_create_simple(d->host_state.bus, 13 << 3, \"Uni-north AGP\");\n\n\n\n    /* Uninorth internal bus */\n\n#if 0\n\n    /* XXX: not needed for now */\n\n    pci_create_simple(d->host_state.bus, 14 << 3, \"Uni-north internal\");\n\n#endif\n\n\n\n    return d->host_state.bus;\n\n}\n", "idx": 9616, "_split": "test", "_hash": "c1020968214ea8fb7a55eaf04cb1a16e"}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static void json_message_process_token(JSONLexer *lexer, GString *input,\n\n                                       JSONTokenType type, int x, int y)\n\n{\n\n    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);\n\n    QDict *dict;\n\n\n\n    switch (type) {\n\n    case JSON_LCURLY:\n\n        parser->brace_count++;\n\n        break;\n\n    case JSON_RCURLY:\n\n        parser->brace_count--;\n\n        break;\n\n    case JSON_LSQUARE:\n\n        parser->bracket_count++;\n\n        break;\n\n    case JSON_RSQUARE:\n\n        parser->bracket_count--;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    dict = qdict_new();\n\n    qdict_put(dict, \"type\", qint_from_int(type));\n\n    qdict_put(dict, \"token\", qstring_from_str(input->str));\n\n    qdict_put(dict, \"x\", qint_from_int(x));\n\n    qdict_put(dict, \"y\", qint_from_int(y));\n\n\n\n    parser->token_size += input->len;\n\n\n\n    g_queue_push_tail(parser->tokens, dict);\n\n\n\n    if (type == JSON_ERROR) {\n\n        goto out_emit_bad;\n\n    } else if (parser->brace_count < 0 ||\n\n        parser->bracket_count < 0 ||\n\n        (parser->brace_count == 0 &&\n\n         parser->bracket_count == 0)) {\n\n        goto out_emit;\n\n    } else if (parser->token_size > MAX_TOKEN_SIZE ||\n\n               parser->bracket_count + parser->brace_count > MAX_NESTING) {\n\n        /* Security consideration, we limit total memory allocated per object\n\n         * and the maximum recursion depth that a message can force.\n\n         */\n\n        goto out_emit_bad;\n\n    }\n\n\n\n    return;\n\n\n\nout_emit_bad:\n\n    /*\n\n     * Clear out token list and tell the parser to emit an error\n\n     * indication by passing it a NULL list\n\n     */\n\n    json_message_free_tokens(parser);\n\nout_emit:\n\n    /* send current list of tokens to parser and reset tokenizer */\n\n    parser->brace_count = 0;\n\n    parser->bracket_count = 0;\n\n    /* parser->emit takes ownership of parser->tokens.  */\n\n    parser->emit(parser, parser->tokens);\n\n    parser->tokens = g_queue_new();\n\n    parser->token_size = 0;\n\n}\n", "idx": 9619, "_split": "test", "_hash": "7e89f4b726629947ef1450f1bc7be95e"}
{"project": "qemu", "commit_id": "041d95f42e39ed1d3a029332cab9966889f0aeb3", "target": 0, "func": "static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,\n\n                                              target_ulong eaddr, uint32_t pid)\n\n{\n\n#if !defined(FLUSH_ALL_TLBS)\n\n    CPUState *cs = CPU(ppc_env_get_cpu(env));\n\n    ppcemb_tlb_t *tlb;\n\n    hwaddr raddr;\n\n    target_ulong page, end;\n\n    int i;\n\n\n\n    for (i = 0; i < env->nb_tlb; i++) {\n\n        tlb = &env->tlb.tlbe[i];\n\n        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {\n\n            end = tlb->EPN + tlb->size;\n\n            for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) {\n\n                tlb_flush_page(cs, page);\n\n            }\n\n            tlb->prot &= ~PAGE_VALID;\n\n            break;\n\n        }\n\n    }\n\n#else\n\n    ppc4xx_tlb_invalidate_all(env);\n\n#endif\n\n}\n", "idx": 9629, "_split": "test", "_hash": "63982e9e09e39edb91417663c26d0ad3"}
{"project": "qemu", "commit_id": "9cd1e97a7ae2856ec00b5682db0dea17f42fc734", "target": 0, "func": "void pci_bridge_initfn(PCIDevice *dev, const char *typename)\n\n{\n\n    PCIBus *parent = dev->bus;\n\n    PCIBridge *br = PCI_BRIDGE(dev);\n\n    PCIBus *sec_bus = &br->sec_bus;\n\n\n\n    pci_word_test_and_set_mask(dev->config + PCI_STATUS,\n\n                               PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);\n\n\n\n    /*\n\n     * TODO: We implement VGA Enable in the Bridge Control Register\n\n     * therefore per the PCI to PCI bridge spec we must also implement\n\n     * VGA Palette Snooping.  When done, set this bit writable:\n\n     *\n\n     * pci_word_test_and_set_mask(dev->wmask + PCI_COMMAND,\n\n     *                            PCI_COMMAND_VGA_PALETTE);\n\n     */\n\n\n\n    pci_config_set_class(dev->config, PCI_CLASS_BRIDGE_PCI);\n\n    dev->config[PCI_HEADER_TYPE] =\n\n        (dev->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |\n\n        PCI_HEADER_TYPE_BRIDGE;\n\n    pci_set_word(dev->config + PCI_SEC_STATUS,\n\n                 PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);\n\n\n\n    /*\n\n     * If we don't specify the name, the bus will be addressed as <id>.0, where\n\n     * id is the device id.\n\n     * Since PCI Bridge devices have a single bus each, we don't need the index:\n\n     * let users address the bus using the device name.\n\n     */\n\n    if (!br->bus_name && dev->qdev.id && *dev->qdev.id) {\n\n\t    br->bus_name = dev->qdev.id;\n\n    }\n\n\n\n    qbus_create_inplace(sec_bus, sizeof(br->sec_bus), typename, DEVICE(dev),\n\n                        br->bus_name);\n\n    sec_bus->parent_dev = dev;\n\n    sec_bus->map_irq = br->map_irq ? br->map_irq : pci_swizzle_map_irq_fn;\n\n    sec_bus->address_space_mem = &br->address_space_mem;\n\n    memory_region_init(&br->address_space_mem, OBJECT(br), \"pci_bridge_pci\", UINT64_MAX);\n\n    sec_bus->address_space_io = &br->address_space_io;\n\n    memory_region_init(&br->address_space_io, OBJECT(br), \"pci_bridge_io\", 65536);\n\n    br->windows = pci_bridge_region_init(br);\n\n    QLIST_INIT(&sec_bus->child);\n\n    QLIST_INSERT_HEAD(&parent->child, sec_bus, sibling);\n\n}\n", "idx": 9630, "_split": "test", "_hash": "a807985f13278f3e5bd5c76bbea4f6d5"}
{"project": "qemu", "commit_id": "bc210eb163b162ff2e94e5c8f4307715731257f8", "target": 0, "func": "void qemu_pixman_linebuf_fill(pixman_image_t *linebuf, pixman_image_t *fb,\n\n                              int width, int y)\n\n{\n\n    pixman_image_composite(PIXMAN_OP_SRC, fb, NULL, linebuf,\n\n                           0, y, 0, 0, 0, 0, width, 1);\n\n}\n", "idx": 9639, "_split": "test", "_hash": "a25c669365d9e82ca55ce4595bec692d"}
{"project": "qemu", "commit_id": "30b8b68eb574fd68060eebcc4da790fdfe18d668", "target": 0, "func": "static inline abi_long target_to_host_cmsg(struct msghdr *msgh,\n\n                                           struct target_msghdr *target_msgh)\n\n{\n\n    struct cmsghdr *cmsg = CMSG_FIRSTHDR(msgh);\n\n    abi_long msg_controllen;\n\n    abi_ulong target_cmsg_addr;\n\n    struct target_cmsghdr *target_cmsg;\n\n    socklen_t space = 0;\n\n    \n\n    msg_controllen = tswapal(target_msgh->msg_controllen);\n\n    if (msg_controllen < sizeof (struct target_cmsghdr)) \n\n        goto the_end;\n\n    target_cmsg_addr = tswapal(target_msgh->msg_control);\n\n    target_cmsg = lock_user(VERIFY_READ, target_cmsg_addr, msg_controllen, 1);\n\n    if (!target_cmsg)\n\n        return -TARGET_EFAULT;\n\n\n\n    while (cmsg && target_cmsg) {\n\n        void *data = CMSG_DATA(cmsg);\n\n        void *target_data = TARGET_CMSG_DATA(target_cmsg);\n\n\n\n        int len = tswapal(target_cmsg->cmsg_len)\n\n                  - TARGET_CMSG_ALIGN(sizeof (struct target_cmsghdr));\n\n\n\n        space += CMSG_SPACE(len);\n\n        if (space > msgh->msg_controllen) {\n\n            space -= CMSG_SPACE(len);\n\n            gemu_log(\"Host cmsg overflow\\n\");\n\n            break;\n\n        }\n\n\n\n        if (tswap32(target_cmsg->cmsg_level) == TARGET_SOL_SOCKET) {\n\n            cmsg->cmsg_level = SOL_SOCKET;\n\n        } else {\n\n            cmsg->cmsg_level = tswap32(target_cmsg->cmsg_level);\n\n        }\n\n        cmsg->cmsg_type = tswap32(target_cmsg->cmsg_type);\n\n        cmsg->cmsg_len = CMSG_LEN(len);\n\n\n\n        if (cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_RIGHTS) {\n\n            gemu_log(\"Unsupported ancillary data: %d/%d\\n\", cmsg->cmsg_level, cmsg->cmsg_type);\n\n            memcpy(data, target_data, len);\n\n        } else {\n\n            int *fd = (int *)data;\n\n            int *target_fd = (int *)target_data;\n\n            int i, numfds = len / sizeof(int);\n\n\n\n            for (i = 0; i < numfds; i++)\n\n                fd[i] = tswap32(target_fd[i]);\n\n        }\n\n\n\n        cmsg = CMSG_NXTHDR(msgh, cmsg);\n\n        target_cmsg = TARGET_CMSG_NXTHDR(target_msgh, target_cmsg);\n\n    }\n\n    unlock_user(target_cmsg, target_cmsg_addr, 0);\n\n the_end:\n\n    msgh->msg_controllen = space;\n\n    return 0;\n\n}\n", "idx": 9643, "_split": "test", "_hash": "1ee2e90d78f1a9f6b2395c7bccdd3f28"}
{"project": "qemu", "commit_id": "9d6f1b73f83a02fb28438fa9a487f5c7d245e4af", "target": 0, "func": "static bool ga_open_pidfile(const char *pidfile)\n\n{\n\n    int pidfd;\n\n    char pidstr[32];\n\n\n\n    pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);\n\n    if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) {\n\n        g_critical(\"Cannot lock pid file, %s\", strerror(errno));\n\n        if (pidfd != -1) {\n\n            close(pidfd);\n\n        }\n\n        return false;\n\n    }\n\n\n\n    if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) {\n\n        g_critical(\"Failed to truncate pid file\");\n\n        goto fail;\n\n    }\n\n    sprintf(pidstr, \"%d\", getpid());\n\n    if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) {\n\n        g_critical(\"Failed to write pid file\");\n\n        goto fail;\n\n    }\n\n\n\n    return true;\n\n\n\nfail:\n\n    unlink(pidfile);\n\n    return false;\n\n}\n", "idx": 9647, "_split": "test", "_hash": "dd2114ccfb1c9bccb152bfe7231ab8b1"}
{"project": "qemu", "commit_id": "3d3efba020da1de57a715e2087cf761ed0ad0904", "target": 1, "func": "static void handle_pending_signal(CPUArchState *cpu_env, int sig)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(cpu_env);\n\n    abi_ulong handler;\n\n    sigset_t set, old_set;\n\n    target_sigset_t target_old_set;\n\n    struct target_sigaction *sa;\n\n    struct sigqueue *q;\n\n    TaskState *ts = cpu->opaque;\n\n    struct emulated_sigtable *k = &ts->sigtab[sig - 1];\n\n\n\n    trace_user_handle_signal(cpu_env, sig);\n\n    /* dequeue signal */\n\n    q = k->first;\n\n    k->first = q->next;\n\n    if (!k->first)\n\n        k->pending = 0;\n\n\n\n    sig = gdb_handlesig(cpu, sig);\n\n    if (!sig) {\n\n        sa = NULL;\n\n        handler = TARGET_SIG_IGN;\n\n    } else {\n\n        sa = &sigact_table[sig - 1];\n\n        handler = sa->_sa_handler;\n\n    }\n\n\n\n    if (ts->sigsegv_blocked && sig == TARGET_SIGSEGV) {\n\n        /* Guest has blocked SIGSEGV but we got one anyway. Assume this\n\n         * is a forced SIGSEGV (ie one the kernel handles via force_sig_info\n\n         * because it got a real MMU fault), and treat as if default handler.\n\n         */\n\n        handler = TARGET_SIG_DFL;\n\n    }\n\n\n\n    if (handler == TARGET_SIG_DFL) {\n\n        /* default handler : ignore some signal. The other are job control or fatal */\n\n        if (sig == TARGET_SIGTSTP || sig == TARGET_SIGTTIN || sig == TARGET_SIGTTOU) {\n\n            kill(getpid(),SIGSTOP);\n\n        } else if (sig != TARGET_SIGCHLD &&\n\n                   sig != TARGET_SIGURG &&\n\n                   sig != TARGET_SIGWINCH &&\n\n                   sig != TARGET_SIGCONT) {\n\n            force_sig(sig);\n\n        }\n\n    } else if (handler == TARGET_SIG_IGN) {\n\n        /* ignore sig */\n\n    } else if (handler == TARGET_SIG_ERR) {\n\n        force_sig(sig);\n\n    } else {\n\n        /* compute the blocked signals during the handler execution */\n\n        target_to_host_sigset(&set, &sa->sa_mask);\n\n        /* SA_NODEFER indicates that the current signal should not be\n\n           blocked during the handler */\n\n        if (!(sa->sa_flags & TARGET_SA_NODEFER))\n\n            sigaddset(&set, target_to_host_signal(sig));\n\n\n\n        /* block signals in the handler using Linux */\n\n        do_sigprocmask(SIG_BLOCK, &set, &old_set);\n\n        /* save the previous blocked signal state to restore it at the\n\n           end of the signal execution (see do_sigreturn) */\n\n        host_to_target_sigset_internal(&target_old_set, &old_set);\n\n\n\n        /* if the CPU is in VM86 mode, we restore the 32 bit values */\n\n#if defined(TARGET_I386) && !defined(TARGET_X86_64)\n\n        {\n\n            CPUX86State *env = cpu_env;\n\n            if (env->eflags & VM_MASK)\n\n                save_v86_state(env);\n\n        }\n\n#endif\n\n        /* prepare the stack frame of the virtual CPU */\n\n#if defined(TARGET_ABI_MIPSN32) || defined(TARGET_ABI_MIPSN64) \\\n\n    || defined(TARGET_OPENRISC) || defined(TARGET_TILEGX)\n\n        /* These targets do not have traditional signals.  */\n\n        setup_rt_frame(sig, sa, &q->info, &target_old_set, cpu_env);\n\n#else\n\n        if (sa->sa_flags & TARGET_SA_SIGINFO)\n\n            setup_rt_frame(sig, sa, &q->info, &target_old_set, cpu_env);\n\n        else\n\n            setup_frame(sig, sa, &target_old_set, cpu_env);\n\n#endif\n\n        if (sa->sa_flags & TARGET_SA_RESETHAND) {\n\n            sa->_sa_handler = TARGET_SIG_DFL;\n\n        }\n\n    }\n\n    if (q != &k->info)\n\n        free_sigqueue(cpu_env, q);\n\n}\n", "idx": 9650, "_split": "test", "_hash": "f3148d9c8e3969c897bcd80d13a02682"}
{"project": "qemu", "commit_id": "d659d94013390238961fac741572306c95496bf5", "target": 1, "func": "static void pcie_pci_bridge_write_config(PCIDevice *d,\n\n        uint32_t address, uint32_t val, int len)\n\n{\n\n    pci_bridge_write_config(d, address, val, len);\n\n    msi_write_config(d, address, val, len);\n\n    shpc_cap_write_config(d, address, val, len);\n\n}\n", "idx": 9651, "_split": "test", "_hash": "c1a4d9b11ec3d128695a128f35ee4d70"}
{"project": "qemu", "commit_id": "62be4e3a5041e84304aa23637da623a205c53ecc", "target": 0, "func": "static ram_addr_t find_ram_offset(ram_addr_t size)\n\n{\n\n    RAMBlock *block, *next_block;\n\n    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;\n\n\n\n    assert(size != 0); /* it would hand out same offset multiple times */\n\n\n\n    if (QTAILQ_EMPTY(&ram_list.blocks))\n\n        return 0;\n\n\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        ram_addr_t end, next = RAM_ADDR_MAX;\n\n\n\n        end = block->offset + block->length;\n\n\n\n        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {\n\n            if (next_block->offset >= end) {\n\n                next = MIN(next, next_block->offset);\n\n            }\n\n        }\n\n        if (next - end >= size && next - end < mingap) {\n\n            offset = end;\n\n            mingap = next - end;\n\n        }\n\n    }\n\n\n\n    if (offset == RAM_ADDR_MAX) {\n\n        fprintf(stderr, \"Failed to find gap of requested size: %\" PRIu64 \"\\n\",\n\n                (uint64_t)size);\n\n        abort();\n\n    }\n\n\n\n    return offset;\n\n}\n", "idx": 9670, "_split": "test", "_hash": "fec746bfa7e21a7a9324440d9342888b"}
{"project": "qemu", "commit_id": "d0d7708ba29cbcc343364a46bff981e0ff88366f", "target": 0, "func": "CharDriverState *qemu_chr_alloc(void)\n\n{\n\n    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));\n\n    qemu_mutex_init(&chr->chr_write_lock);\n\n    return chr;\n\n}\n", "idx": 9683, "_split": "test", "_hash": "5f267708242950fc2e403ac2bbe45615"}
{"project": "qemu", "commit_id": "fdaef06917100d97782df550c1807a1da054e27e", "target": 0, "func": "static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)\n\n{\n\n    SCSIRequest *req = &r->req;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    uint64_t nb_sectors;\n\n    int buflen = 0;\n\n    int ret;\n\n\n\n    switch (req->cmd.buf[0]) {\n\n    case TEST_UNIT_READY:\n\n        if (!bdrv_is_inserted(s->bs))\n\n            goto not_ready;\n\n        break;\n\n    case REQUEST_SENSE:\n\n        if (req->cmd.xfer < 4)\n\n            goto illegal_request;\n\n        buflen = scsi_device_get_sense(&s->qdev, outbuf, req->cmd.xfer,\n\n                                       (req->cmd.buf[1] & 1) == 0);\n\n        break;\n\n    case INQUIRY:\n\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n\n        if (buflen < 0)\n\n            goto illegal_request;\n\n        break;\n\n    case MODE_SENSE:\n\n    case MODE_SENSE_10:\n\n        buflen = scsi_disk_emulate_mode_sense(req, outbuf);\n\n        if (buflen < 0)\n\n            goto illegal_request;\n\n        break;\n\n    case READ_TOC:\n\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n\n        if (buflen < 0)\n\n            goto illegal_request;\n\n        break;\n\n    case RESERVE:\n\n        if (req->cmd.buf[1] & 1)\n\n            goto illegal_request;\n\n        break;\n\n    case RESERVE_10:\n\n        if (req->cmd.buf[1] & 3)\n\n            goto illegal_request;\n\n        break;\n\n    case RELEASE:\n\n        if (req->cmd.buf[1] & 1)\n\n            goto illegal_request;\n\n        break;\n\n    case RELEASE_10:\n\n        if (req->cmd.buf[1] & 3)\n\n            goto illegal_request;\n\n        break;\n\n    case START_STOP:\n\n        if (s->qdev.type == TYPE_ROM && (req->cmd.buf[4] & 2)) {\n\n            /* load/eject medium */\n\n            bdrv_eject(s->bs, !(req->cmd.buf[4] & 1));\n\n        }\n\n        break;\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n        bdrv_set_locked(s->bs, req->cmd.buf[4] & 1);\n\n        break;\n\n    case READ_CAPACITY_10:\n\n        /* The normal LEN field for this command is zero.  */\n\n        memset(outbuf, 0, 8);\n\n        bdrv_get_geometry(s->bs, &nb_sectors);\n\n        if (!nb_sectors)\n\n            goto not_ready;\n\n        nb_sectors /= s->cluster_size;\n\n        /* Returned value is the address of the last sector.  */\n\n        nb_sectors--;\n\n        /* Remember the new size for read/write sanity checking. */\n\n        s->max_lba = nb_sectors;\n\n        /* Clip to 2TB, instead of returning capacity modulo 2TB. */\n\n        if (nb_sectors > UINT32_MAX)\n\n            nb_sectors = UINT32_MAX;\n\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n\n        outbuf[3] = nb_sectors & 0xff;\n\n        outbuf[4] = 0;\n\n        outbuf[5] = 0;\n\n        outbuf[6] = s->cluster_size * 2;\n\n        outbuf[7] = 0;\n\n        buflen = 8;\n\n        break;\n\n    case SYNCHRONIZE_CACHE:\n\n        ret = bdrv_flush(s->bs);\n\n        if (ret < 0) {\n\n            if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_FLUSH)) {\n\n                return -1;\n\n            }\n\n        }\n\n        break;\n\n    case GET_CONFIGURATION:\n\n        memset(outbuf, 0, 8);\n\n        /* ??? This should probably return much more information.  For now\n\n           just return the basic header indicating the CD-ROM profile.  */\n\n        outbuf[7] = 8; // CD-ROM\n\n        buflen = 8;\n\n        break;\n\n    case SERVICE_ACTION_IN:\n\n        /* Service Action In subcommands. */\n\n        if ((req->cmd.buf[1] & 31) == 0x10) {\n\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n\n            memset(outbuf, 0, req->cmd.xfer);\n\n            bdrv_get_geometry(s->bs, &nb_sectors);\n\n            if (!nb_sectors)\n\n                goto not_ready;\n\n            nb_sectors /= s->cluster_size;\n\n            /* Returned value is the address of the last sector.  */\n\n            nb_sectors--;\n\n            /* Remember the new size for read/write sanity checking. */\n\n            s->max_lba = nb_sectors;\n\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n\n            outbuf[7] = nb_sectors & 0xff;\n\n            outbuf[8] = 0;\n\n            outbuf[9] = 0;\n\n            outbuf[10] = s->cluster_size * 2;\n\n            outbuf[11] = 0;\n\n            outbuf[12] = 0;\n\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n\n\n            /* set TPE bit if the format supports discard */\n\n            if (s->qdev.conf.discard_granularity) {\n\n                outbuf[14] = 0x80;\n\n            }\n\n\n\n            /* Protection, exponent and lowest lba field left blank. */\n\n            buflen = req->cmd.xfer;\n\n            break;\n\n        }\n\n        DPRINTF(\"Unsupported Service Action In\\n\");\n\n        goto illegal_request;\n\n    case REPORT_LUNS:\n\n        if (req->cmd.xfer < 16)\n\n            goto illegal_request;\n\n        memset(outbuf, 0, 16);\n\n        outbuf[3] = 8;\n\n        buflen = 16;\n\n        break;\n\n    case VERIFY_10:\n\n        break;\n\n    default:\n\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n\n        return -1;\n\n    }\n\n    return buflen;\n\n\n\nnot_ready:\n\n    if (!bdrv_is_inserted(s->bs)) {\n\n        scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n\n    } else {\n\n        scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n\n    }\n\n    return -1;\n\n\n\nillegal_request:\n\n    scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n\n    return -1;\n\n}\n", "idx": 9706, "_split": "test", "_hash": "0bfefdf127f6bcf66d6b3a5b48209c92"}
{"project": "qemu", "commit_id": "376692b9dc6f02303ee07a4146d08d8727d79c0c", "target": 0, "func": "static void flush_queued_work(CPUState *cpu)\n\n{\n\n    struct qemu_work_item *wi;\n\n\n\n    if (cpu->queued_work_first == NULL) {\n\n        return;\n\n    }\n\n\n\n    while ((wi = cpu->queued_work_first)) {\n\n        cpu->queued_work_first = wi->next;\n\n        wi->func(wi->data);\n\n        wi->done = true;\n\n        if (wi->free) {\n\n            g_free(wi);\n\n        }\n\n    }\n\n    cpu->queued_work_last = NULL;\n\n    qemu_cond_broadcast(&qemu_work_cond);\n\n}\n", "idx": 9707, "_split": "test", "_hash": "d9e80983b03f14cdaa5394a7f7bbe34e"}
{"project": "qemu", "commit_id": "e568f9df086965813a318ff0558782ba90e59c33", "target": 0, "func": "static int validate_guest_space(unsigned long guest_base,\n\n                                unsigned long guest_size)\n\n{\n\n    unsigned long real_start, test_page_addr;\n\n\n\n    /* We need to check that we can force a fault on access to the\n\n     * commpage at 0xffff0fxx\n\n     */\n\n    test_page_addr = guest_base + (0xffff0f00 & qemu_host_page_mask);\n\n\n\n    /* If the commpage lies within the already allocated guest space,\n\n     * then there is no way we can allocate it.\n\n     */\n\n    if (test_page_addr >= guest_base\n\n        && test_page_addr <= (guest_base + guest_size)) {\n\n        return -1;\n\n    }\n\n\n\n    /* Note it needs to be writeable to let us initialise it */\n\n    real_start = (unsigned long)\n\n                 mmap((void *)test_page_addr, qemu_host_page_size,\n\n                     PROT_READ | PROT_WRITE,\n\n                     MAP_ANONYMOUS | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n\n\n    /* If we can't map it then try another address */\n\n    if (real_start == -1ul) {\n\n        return 0;\n\n    }\n\n\n\n    if (real_start != test_page_addr) {\n\n        /* OS didn't put the page where we asked - unmap and reject */\n\n        munmap((void *)real_start, qemu_host_page_size);\n\n        return 0;\n\n    }\n\n\n\n    /* Leave the page mapped\n\n     * Populate it (mmap should have left it all 0'd)\n\n     */\n\n\n\n    /* Kernel helper versions */\n\n    __put_user(5, (uint32_t *)g2h(0xffff0ffcul));\n\n\n\n    /* Now it's populated make it RO */\n\n    if (mprotect((void *)test_page_addr, qemu_host_page_size, PROT_READ)) {\n\n        perror(\"Protecting guest commpage\");\n\n        exit(-1);\n\n    }\n\n\n\n    return 1; /* All good */\n\n}\n", "idx": 9709, "_split": "test", "_hash": "89d3c6c9c5bb45f5c6e55d0512c55359"}
{"project": "qemu", "commit_id": "f5f601afcec6c1081128fe5a0f831788ca9f56ed", "target": 1, "func": "long do_sigreturn(CPUCRISState *env)\n\n{\n\n\tstruct target_signal_frame *frame;\n\n\tabi_ulong frame_addr;\n\n\ttarget_sigset_t target_set;\n\n\tsigset_t set;\n\n\tint i;\n\n\n\n\tframe_addr = env->regs[R_SP];\n\n\t/* Make sure the guest isn't playing games.  */\n\n\tif (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))\n\n\t\tgoto badframe;\n\n\n\n\t/* Restore blocked signals */\n\n\tif (__get_user(target_set.sig[0], &frame->sc.oldmask))\n\n\t\tgoto badframe;\n\n\tfor(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n\t\tif (__get_user(target_set.sig[i], &frame->extramask[i - 1]))\n\n\t\t\tgoto badframe;\n\n\t}\n\n\ttarget_to_host_sigset_internal(&set, &target_set);\n\n        do_sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n\trestore_sigcontext(&frame->sc, env);\n\n\tunlock_user_struct(frame, frame_addr, 0);\n\n\treturn env->regs[10];\n\n  badframe:\n\n\tunlock_user_struct(frame, frame_addr, 0);\n\n\tforce_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 9721, "_split": "test", "_hash": "079d5dc09ac6bfbb82273fd1c3c215fa"}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usbredir_interrupt_packet(void *priv, uint32_t id,\n\n    struct usb_redir_interrupt_packet_header *interrupt_packet,\n\n    uint8_t *data, int data_len)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    uint8_t ep = interrupt_packet->endpoint;\n\n\n\n    DPRINTF(\"interrupt-in status %d ep %02X len %d id %u\\n\",\n\n            interrupt_packet->status, ep, data_len, id);\n\n\n\n    if (dev->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_INT) {\n\n        ERROR(\"received int packet for non interrupt endpoint %02X\\n\", ep);\n\n        free(data);\n\n        return;\n\n    }\n\n\n\n    if (ep & USB_DIR_IN) {\n\n        if (dev->endpoint[EP2I(ep)].interrupt_started == 0) {\n\n            DPRINTF(\"received int packet while not started ep %02X\\n\", ep);\n\n            free(data);\n\n            return;\n\n        }\n\n\n\n        /* bufp_alloc also adds the packet to the ep queue */\n\n        bufp_alloc(dev, data, data_len, interrupt_packet->status, ep);\n\n    } else {\n\n        int len = interrupt_packet->length;\n\n\n\n        AsyncURB *aurb = async_find(dev, id);\n\n        if (!aurb) {\n\n            return;\n\n        }\n\n\n\n        if (aurb->interrupt_packet.endpoint != interrupt_packet->endpoint) {\n\n            ERROR(\"return int packet mismatch, please report this!\\n\");\n\n            len = USB_RET_NAK;\n\n        }\n\n\n\n        if (aurb->packet) {\n\n            aurb->packet->len = usbredir_handle_status(dev,\n\n                                               interrupt_packet->status, len);\n\n            usb_packet_complete(&dev->dev, aurb->packet);\n\n        }\n\n        async_free(dev, aurb);\n\n    }\n\n}\n", "idx": 9722, "_split": "test", "_hash": "497646ce9cc7e1ec6c0012841ffbbdf5"}
{"project": "qemu", "commit_id": "fb846a094fdee7bb6a88b48aeed0d97a8080a20d", "target": 0, "func": "static void virtio_ccw_device_realize(VirtioCcwDevice *dev, Error **errp)\n\n{\n\n    unsigned int cssid = 0;\n\n    unsigned int ssid = 0;\n\n    unsigned int schid;\n\n    unsigned int devno;\n\n    bool have_devno = false;\n\n    bool found = false;\n\n    SubchDev *sch;\n\n    int num;\n\n    DeviceState *parent = DEVICE(dev);\n\n    Error *err = NULL;\n\n    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);\n\n    VirtIODevice *vdev;\n\n\n\n    sch = g_malloc0(sizeof(SubchDev));\n\n\n\n    sch->driver_data = dev;\n\n    dev->sch = sch;\n\n\n\n    dev->indicators = NULL;\n\n\n\n    /* Initialize subchannel structure. */\n\n    sch->channel_prog = 0x0;\n\n    sch->last_cmd_valid = false;\n\n    sch->thinint_active = false;\n\n    /*\n\n     * Use a device number if provided. Otherwise, fall back to subchannel\n\n     * number.\n\n     */\n\n    if (dev->bus_id) {\n\n        num = sscanf(dev->bus_id, \"%x.%x.%04x\", &cssid, &ssid, &devno);\n\n        if (num == 3) {\n\n            if ((cssid > MAX_CSSID) || (ssid > MAX_SSID)) {\n\n                error_setg(errp, \"Invalid cssid or ssid: cssid %x, ssid %x\",\n\n                           cssid, ssid);\n\n                goto out_err;\n\n            }\n\n            /* Enforce use of virtual cssid. */\n\n            if (cssid != VIRTUAL_CSSID) {\n\n                error_setg(errp, \"cssid %x not valid for virtio devices\",\n\n                           cssid);\n\n                goto out_err;\n\n            }\n\n            if (css_devno_used(cssid, ssid, devno)) {\n\n                error_setg(errp, \"Device %x.%x.%04x already exists\",\n\n                           cssid, ssid, devno);\n\n                goto out_err;\n\n            }\n\n            sch->cssid = cssid;\n\n            sch->ssid = ssid;\n\n            sch->devno = devno;\n\n            have_devno = true;\n\n        } else {\n\n            error_setg(errp, \"Malformed devno parameter '%s'\", dev->bus_id);\n\n            goto out_err;\n\n        }\n\n    }\n\n\n\n    /* Find the next free id. */\n\n    if (have_devno) {\n\n        for (schid = 0; schid <= MAX_SCHID; schid++) {\n\n            if (!css_find_subch(1, cssid, ssid, schid)) {\n\n                sch->schid = schid;\n\n                css_subch_assign(cssid, ssid, schid, devno, sch);\n\n                found = true;\n\n                break;\n\n            }\n\n        }\n\n        if (!found) {\n\n            error_setg(errp, \"No free subchannel found for %x.%x.%04x\",\n\n                       cssid, ssid, devno);\n\n            goto out_err;\n\n        }\n\n        trace_virtio_ccw_new_device(cssid, ssid, schid, devno,\n\n                                    \"user-configured\");\n\n    } else {\n\n        cssid = VIRTUAL_CSSID;\n\n        for (ssid = 0; ssid <= MAX_SSID; ssid++) {\n\n            for (schid = 0; schid <= MAX_SCHID; schid++) {\n\n                if (!css_find_subch(1, cssid, ssid, schid)) {\n\n                    sch->cssid = cssid;\n\n                    sch->ssid = ssid;\n\n                    sch->schid = schid;\n\n                    devno = schid;\n\n                    /*\n\n                     * If the devno is already taken, look further in this\n\n                     * subchannel set.\n\n                     */\n\n                    while (css_devno_used(cssid, ssid, devno)) {\n\n                        if (devno == MAX_SCHID) {\n\n                            devno = 0;\n\n                        } else if (devno == schid - 1) {\n\n                            error_setg(errp, \"No free devno found\");\n\n                            goto out_err;\n\n                        } else {\n\n                            devno++;\n\n                        }\n\n                    }\n\n                    sch->devno = devno;\n\n                    css_subch_assign(cssid, ssid, schid, devno, sch);\n\n                    found = true;\n\n                    break;\n\n                }\n\n            }\n\n            if (found) {\n\n                break;\n\n            }\n\n        }\n\n        if (!found) {\n\n            error_setg(errp, \"Virtual channel subsystem is full!\");\n\n            goto out_err;\n\n        }\n\n        trace_virtio_ccw_new_device(cssid, ssid, schid, devno,\n\n                                    \"auto-configured\");\n\n    }\n\n\n\n    /* Build initial schib. */\n\n    css_sch_build_virtual_schib(sch, 0, VIRTIO_CCW_CHPID_TYPE);\n\n\n\n    sch->ccw_cb = virtio_ccw_cb;\n\n\n\n    /* Build senseid data. */\n\n    memset(&sch->id, 0, sizeof(SenseId));\n\n    sch->id.reserved = 0xff;\n\n    sch->id.cu_type = VIRTIO_CCW_CU_TYPE;\n\n\n\n    if (k->realize) {\n\n        k->realize(dev, &err);\n\n    }\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        css_subch_assign(cssid, ssid, schid, devno, NULL);\n\n        goto out_err;\n\n    }\n\n\n\n    /* device_id is only set after vdev has been realized */\n\n    vdev = virtio_ccw_get_vdev(sch);\n\n    sch->id.cu_model = vdev->device_id;\n\n\n\n    /* Only the first 32 feature bits are used. */\n\n    dev->host_features[0] = virtio_bus_get_vdev_features(&dev->bus,\n\n                                                         dev->host_features[0]);\n\n\n\n    virtio_add_feature(&dev->host_features[0], VIRTIO_F_NOTIFY_ON_EMPTY);\n\n    virtio_add_feature(&dev->host_features[0], VIRTIO_F_BAD_FEATURE);\n\n\n\n    css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,\n\n                          parent->hotplugged, 1);\n\n    return;\n\n\n\nout_err:\n\n    dev->sch = NULL;\n\n    g_free(sch);\n\n}\n", "idx": 9744, "_split": "test", "_hash": "c9e056d67fb95aae1a0de230a493ae85"}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void op_cp1_registers(void)\n\n{\n\n    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {\n\n        CALL_FROM_TB1(do_raise_exception, EXCP_RI);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 9754, "_split": "test", "_hash": "8b62312c0aeee4471c9e140dfee79e39"}
{"project": "qemu", "commit_id": "e853ea1cc68716c3d9c22d04578020c6dd743306", "target": 1, "func": "GIOStatus ga_channel_write_all(GAChannel *c, const char *buf, size_t size)\n\n{\n\n    GIOStatus status = G_IO_STATUS_NORMAL;\n\n    size_t count;\n\n\n\n    while (size) {\n\n        status = ga_channel_write(c, buf, size, &count);\n\n        if (status == G_IO_STATUS_NORMAL) {\n\n            size -= count;\n\n            buf += count;\n\n        } else if (status != G_IO_STATUS_AGAIN) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    return status;\n\n}\n", "idx": 9787, "_split": "test", "_hash": "9969e0fb0a7b596f3898a3b4107e122c"}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "static void flush_queued_work(CPUState *env)\n\n{\n\n    struct qemu_work_item *wi;\n\n\n\n    if (!env->queued_work_first)\n\n        return;\n\n\n\n    while ((wi = env->queued_work_first)) {\n\n        env->queued_work_first = wi->next;\n\n        wi->func(wi->data);\n\n        wi->done = true;\n\n    }\n\n    env->queued_work_last = NULL;\n\n    qemu_cond_broadcast(&qemu_work_cond);\n\n}\n", "idx": 9805, "_split": "test", "_hash": "a1e6057b4081e7c9301e1fd459d22d75"}
{"project": "qemu", "commit_id": "477830727821e4bc337f4ac1fd222ffe0b900e1a", "target": 0, "func": "static int coroutine_fn add_aio_request(BDRVSheepdogState *s, AIOReq *aio_req,\n\n                           struct iovec *iov, int niov, bool create,\n\n                           enum AIOCBState aiocb_type)\n\n{\n\n    int nr_copies = s->inode.nr_copies;\n\n    SheepdogObjReq hdr;\n\n    unsigned int wlen;\n\n    int ret;\n\n    uint64_t oid = aio_req->oid;\n\n    unsigned int datalen = aio_req->data_len;\n\n    uint64_t offset = aio_req->offset;\n\n    uint8_t flags = aio_req->flags;\n\n    uint64_t old_oid = aio_req->base_oid;\n\n\n\n    if (!nr_copies) {\n\n        error_report(\"bug\");\n\n    }\n\n\n\n    memset(&hdr, 0, sizeof(hdr));\n\n\n\n    if (aiocb_type == AIOCB_READ_UDATA) {\n\n        wlen = 0;\n\n        hdr.opcode = SD_OP_READ_OBJ;\n\n        hdr.flags = flags;\n\n    } else if (create) {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_CREATE_AND_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    } else {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    }\n\n\n\n    if (s->cache_flags) {\n\n        hdr.flags |= s->cache_flags;\n\n    }\n\n\n\n    hdr.oid = oid;\n\n    hdr.cow_oid = old_oid;\n\n    hdr.copies = s->inode.nr_copies;\n\n\n\n    hdr.data_length = datalen;\n\n    hdr.offset = offset;\n\n\n\n    hdr.id = aio_req->id;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    s->co_send = qemu_coroutine_self();\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, co_write_request,\n\n                            aio_flush_request, s);\n\n    socket_set_cork(s->fd, 1);\n\n\n\n    /* send a header */\n\n    ret = qemu_co_send(s->fd, &hdr, sizeof(hdr));\n\n    if (ret < 0) {\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        error_report(\"failed to send a req, %s\", strerror(errno));\n\n        return -errno;\n\n    }\n\n\n\n    if (wlen) {\n\n        ret = qemu_co_sendv(s->fd, iov, niov, aio_req->iov_offset, wlen);\n\n        if (ret < 0) {\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            error_report(\"failed to send a data, %s\", strerror(errno));\n\n            return -errno;\n\n        }\n\n    }\n\n\n\n    socket_set_cork(s->fd, 0);\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, NULL,\n\n                            aio_flush_request, s);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    return 0;\n\n}\n", "idx": 9817, "_split": "test", "_hash": "e2effd90bd354f7a33567fca46cfbc4c"}
{"project": "qemu", "commit_id": "f51074cdc6e750daa3b6df727d83449a7e42b391", "target": 1, "func": "int pci_drive_hot_add(Monitor *mon, const QDict *qdict, DriveInfo *dinfo)\n\n{\n\n    /* On non-x86 we don't do PCI hotplug */\n\n    monitor_printf(mon, \"Can't hot-add drive to type %d\\n\", dinfo->type);\n\n    return -1;\n\n}\n", "idx": 9845, "_split": "test", "_hash": "fb9232faed9cdf42e614f5a99c4c251a"}
{"project": "qemu", "commit_id": "338c858c946017cd3ec8c2be06d817e001d94bc3", "target": 0, "func": "void cpu_loop(CPUAlphaState *env)\n\n{\n\n    CPUState *cs = CPU(alpha_env_get_cpu(env));\n\n    int trapnr;\n\n    target_siginfo_t info;\n\n    abi_long sysret;\n\n\n\n    while (1) {\n\n        cpu_exec_start(cs);\n\n        trapnr = cpu_alpha_exec(cs);\n\n        cpu_exec_end(cs);\n\n\n\n        /* All of the traps imply a transition through PALcode, which\n\n           implies an REI instruction has been executed.  Which means\n\n           that the intr_flag should be cleared.  */\n\n        env->intr_flag = 0;\n\n\n\n        switch (trapnr) {\n\n        case EXCP_RESET:\n\n            fprintf(stderr, \"Reset requested. Exit\\n\");\n\n            exit(EXIT_FAILURE);\n\n            break;\n\n        case EXCP_MCHK:\n\n            fprintf(stderr, \"Machine check exception. Exit\\n\");\n\n            exit(EXIT_FAILURE);\n\n            break;\n\n        case EXCP_SMP_INTERRUPT:\n\n        case EXCP_CLK_INTERRUPT:\n\n        case EXCP_DEV_INTERRUPT:\n\n            fprintf(stderr, \"External interrupt. Exit\\n\");\n\n            exit(EXIT_FAILURE);\n\n            break;\n\n        case EXCP_MMFAULT:\n\n            env->lock_addr = -1;\n\n            info.si_signo = TARGET_SIGSEGV;\n\n            info.si_errno = 0;\n\n            info.si_code = (page_get_flags(env->trap_arg0) & PAGE_VALID\n\n                            ? TARGET_SEGV_ACCERR : TARGET_SEGV_MAPERR);\n\n            info._sifields._sigfault._addr = env->trap_arg0;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n        case EXCP_UNALIGN:\n\n            env->lock_addr = -1;\n\n            info.si_signo = TARGET_SIGBUS;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_BUS_ADRALN;\n\n            info._sifields._sigfault._addr = env->trap_arg0;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n        case EXCP_OPCDEC:\n\n        do_sigill:\n\n            env->lock_addr = -1;\n\n            info.si_signo = TARGET_SIGILL;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_ILL_ILLOPC;\n\n            info._sifields._sigfault._addr = env->pc;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n        case EXCP_ARITH:\n\n            env->lock_addr = -1;\n\n            info.si_signo = TARGET_SIGFPE;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_FPE_FLTINV;\n\n            info._sifields._sigfault._addr = env->pc;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n        case EXCP_FEN:\n\n            /* No-op.  Linux simply re-enables the FPU.  */\n\n            break;\n\n        case EXCP_CALL_PAL:\n\n            env->lock_addr = -1;\n\n            switch (env->error_code) {\n\n            case 0x80:\n\n                /* BPT */\n\n                info.si_signo = TARGET_SIGTRAP;\n\n                info.si_errno = 0;\n\n                info.si_code = TARGET_TRAP_BRKPT;\n\n                info._sifields._sigfault._addr = env->pc;\n\n                queue_signal(env, info.si_signo, &info);\n\n                break;\n\n            case 0x81:\n\n                /* BUGCHK */\n\n                info.si_signo = TARGET_SIGTRAP;\n\n                info.si_errno = 0;\n\n                info.si_code = 0;\n\n                info._sifields._sigfault._addr = env->pc;\n\n                queue_signal(env, info.si_signo, &info);\n\n                break;\n\n            case 0x83:\n\n                /* CALLSYS */\n\n                trapnr = env->ir[IR_V0];\n\n                sysret = do_syscall(env, trapnr,\n\n                                    env->ir[IR_A0], env->ir[IR_A1],\n\n                                    env->ir[IR_A2], env->ir[IR_A3],\n\n                                    env->ir[IR_A4], env->ir[IR_A5],\n\n                                    0, 0);\n\n                if (trapnr == TARGET_NR_sigreturn\n\n                    || trapnr == TARGET_NR_rt_sigreturn) {\n\n                    break;\n\n                }\n\n                /* Syscall writes 0 to V0 to bypass error check, similar\n\n                   to how this is handled internal to Linux kernel.\n\n                   (Ab)use trapnr temporarily as boolean indicating error.  */\n\n                trapnr = (env->ir[IR_V0] != 0 && sysret < 0);\n\n                env->ir[IR_V0] = (trapnr ? -sysret : sysret);\n\n                env->ir[IR_A3] = trapnr;\n\n                break;\n\n            case 0x86:\n\n                /* IMB */\n\n                /* ??? We can probably elide the code using page_unprotect\n\n                   that is checking for self-modifying code.  Instead we\n\n                   could simply call tb_flush here.  Until we work out the\n\n                   changes required to turn off the extra write protection,\n\n                   this can be a no-op.  */\n\n                break;\n\n            case 0x9E:\n\n                /* RDUNIQUE */\n\n                /* Handled in the translator for usermode.  */\n\n                abort();\n\n            case 0x9F:\n\n                /* WRUNIQUE */\n\n                /* Handled in the translator for usermode.  */\n\n                abort();\n\n            case 0xAA:\n\n                /* GENTRAP */\n\n                info.si_signo = TARGET_SIGFPE;\n\n                switch (env->ir[IR_A0]) {\n\n                case TARGET_GEN_INTOVF:\n\n                    info.si_code = TARGET_FPE_INTOVF;\n\n                    break;\n\n                case TARGET_GEN_INTDIV:\n\n                    info.si_code = TARGET_FPE_INTDIV;\n\n                    break;\n\n                case TARGET_GEN_FLTOVF:\n\n                    info.si_code = TARGET_FPE_FLTOVF;\n\n                    break;\n\n                case TARGET_GEN_FLTUND:\n\n                    info.si_code = TARGET_FPE_FLTUND;\n\n                    break;\n\n                case TARGET_GEN_FLTINV:\n\n                    info.si_code = TARGET_FPE_FLTINV;\n\n                    break;\n\n                case TARGET_GEN_FLTINE:\n\n                    info.si_code = TARGET_FPE_FLTRES;\n\n                    break;\n\n                case TARGET_GEN_ROPRAND:\n\n                    info.si_code = 0;\n\n                    break;\n\n                default:\n\n                    info.si_signo = TARGET_SIGTRAP;\n\n                    info.si_code = 0;\n\n                    break;\n\n                }\n\n                info.si_errno = 0;\n\n                info._sifields._sigfault._addr = env->pc;\n\n                queue_signal(env, info.si_signo, &info);\n\n                break;\n\n            default:\n\n                goto do_sigill;\n\n            }\n\n            break;\n\n        case EXCP_DEBUG:\n\n            info.si_signo = gdb_handlesig(cs, TARGET_SIGTRAP);\n\n            if (info.si_signo) {\n\n                env->lock_addr = -1;\n\n                info.si_errno = 0;\n\n                info.si_code = TARGET_TRAP_BRKPT;\n\n                queue_signal(env, info.si_signo, &info);\n\n            }\n\n            break;\n\n        case EXCP_STL_C:\n\n        case EXCP_STQ_C:\n\n            do_store_exclusive(env, env->error_code, trapnr - EXCP_STL_C);\n\n            break;\n\n        case EXCP_INTERRUPT:\n\n            /* Just indicate that signals should be handled asap.  */\n\n            break;\n\n        default:\n\n            printf (\"Unhandled trap: 0x%x\\n\", trapnr);\n\n            cpu_dump_state(cs, stderr, fprintf, 0);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n        process_pending_signals (env);\n\n    }\n\n}\n", "idx": 9864, "_split": "test", "_hash": "eb7e89ba8b62acce4edce0b4d7ea99de"}
{"project": "qemu", "commit_id": "e70377dfa4bbc2e101066ca35675bed4129c5a8c", "target": 0, "func": "static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *target)\n\n{\n\n    int i;\n\n    S390PCIBusDevice *pbdev;\n\n    S390pciState *s = s390_get_phb();\n\n\n\n    if (!target) {\n\n        return NULL;\n\n    }\n\n\n\n    for (i = 0; i < PCI_SLOT_MAX; i++) {\n\n        pbdev = s->pbdev[i];\n\n        if (!pbdev) {\n\n            continue;\n\n        }\n\n\n\n        if (!strcmp(pbdev->target, target)) {\n\n            return pbdev;\n\n        }\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 9870, "_split": "test", "_hash": "f152dc50b70c3fb7c2d35e604076dddb"}
{"project": "qemu", "commit_id": "ab0997e0afdcb272fd04784a280b2df46b0c759f", "target": 1, "func": "static int qcow2_co_writev(BlockDriverState *bs,\n\n                           int64_t sector_num,\n\n                           int remaining_sectors,\n\n                           QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    int n_end;\n\n    int ret;\n\n    int cur_nr_sectors; /* number of sectors in current iteration */\n\n    QCowL2Meta l2meta;\n\n    uint64_t cluster_offset;\n\n    QEMUIOVector hd_qiov;\n\n    uint64_t bytes_done = 0;\n\n    uint8_t *cluster_data = NULL;\n\n\n\n    l2meta.nb_clusters = 0;\n\n    qemu_co_queue_init(&l2meta.dependent_requests);\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    s->cluster_cache_offset = -1; /* disable compressed cache */\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (remaining_sectors != 0) {\n\n\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n_end = index_in_cluster + remaining_sectors;\n\n        if (s->crypt_method &&\n\n            n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) {\n\n            n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n        }\n\n\n\n        ret = qcow2_alloc_cluster_offset(bs, sector_num << 9,\n\n            index_in_cluster, n_end, &cur_nr_sectors, &l2meta);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        cluster_offset = l2meta.cluster_offset;\n\n        assert((cluster_offset & 511) == 0);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (s->crypt_method) {\n\n            if (!cluster_data) {\n\n                cluster_data = g_malloc0(QCOW_MAX_CRYPT_CLUSTERS *\n\n                                                 s->cluster_size);\n\n            }\n\n\n\n            assert(hd_qiov.size <=\n\n                   QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n            qemu_iovec_to_buffer(&hd_qiov, cluster_data);\n\n\n\n            qcow2_encrypt_sectors(s, sector_num, cluster_data,\n\n                cluster_data, cur_nr_sectors, 1, &s->aes_encrypt_key);\n\n\n\n            qemu_iovec_reset(&hd_qiov);\n\n            qemu_iovec_add(&hd_qiov, cluster_data,\n\n                cur_nr_sectors * 512);\n\n        }\n\n\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        ret = bdrv_co_writev(bs->file,\n\n                             (cluster_offset >> 9) + index_in_cluster,\n\n                             cur_nr_sectors, &hd_qiov);\n\n        qemu_co_mutex_lock(&s->lock);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        ret = qcow2_alloc_cluster_link_l2(bs, &l2meta);\n\n\n\n        run_dependent_requests(s, &l2meta);\n\n\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n\n\n\n    return ret;\n\n}", "idx": 9922, "_split": "test", "_hash": "9f158e563969a9904c207344f734041f"}
{"project": "qemu", "commit_id": "1e7398a140f7a6bd9f5a438e7ad0f1ef50990e25", "target": 1, "func": "int vhost_dev_init(struct vhost_dev *hdev, void *opaque,\n\n                   VhostBackendType backend_type, bool force)\n\n{\n\n    uint64_t features;\n\n    int i, r;\n\n\n\n    if (vhost_set_backend_type(hdev, backend_type) < 0) {\n\n        close((uintptr_t)opaque);\n\n        return -1;\n\n    }\n\n\n\n    if (hdev->vhost_ops->vhost_backend_init(hdev, opaque) < 0) {\n\n        close((uintptr_t)opaque);\n\n        return -errno;\n\n    }\n\n\n\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_OWNER, NULL);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_GET_FEATURES, &features);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < hdev->nvqs; ++i) {\n\n        r = vhost_virtqueue_init(hdev, hdev->vqs + i, i);\n\n        if (r < 0) {\n\n            goto fail_vq;\n\n        }\n\n    }\n\n    hdev->features = features;\n\n\n\n    hdev->memory_listener = (MemoryListener) {\n\n        .begin = vhost_begin,\n\n        .commit = vhost_commit,\n\n        .region_add = vhost_region_add,\n\n        .region_del = vhost_region_del,\n\n        .region_nop = vhost_region_nop,\n\n        .log_start = vhost_log_start,\n\n        .log_stop = vhost_log_stop,\n\n        .log_sync = vhost_log_sync,\n\n        .log_global_start = vhost_log_global_start,\n\n        .log_global_stop = vhost_log_global_stop,\n\n        .eventfd_add = vhost_eventfd_add,\n\n        .eventfd_del = vhost_eventfd_del,\n\n        .priority = 10\n\n    };\n\n    hdev->migration_blocker = NULL;\n\n    if (!(hdev->features & (0x1ULL << VHOST_F_LOG_ALL))) {\n\n        error_setg(&hdev->migration_blocker,\n\n                   \"Migration disabled: vhost lacks VHOST_F_LOG_ALL feature.\");\n\n        migrate_add_blocker(hdev->migration_blocker);\n\n    }\n\n    hdev->mem = g_malloc0(offsetof(struct vhost_memory, regions));\n\n    hdev->n_mem_sections = 0;\n\n    hdev->mem_sections = NULL;\n\n    hdev->log = NULL;\n\n    hdev->log_size = 0;\n\n    hdev->log_enabled = false;\n\n    hdev->started = false;\n\n    hdev->memory_changed = false;\n\n    memory_listener_register(&hdev->memory_listener, &address_space_memory);\n\n    hdev->force = force;\n\n    return 0;\n\nfail_vq:\n\n    while (--i >= 0) {\n\n        vhost_virtqueue_cleanup(hdev->vqs + i);\n\n    }\n\nfail:\n\n    r = -errno;\n\n    hdev->vhost_ops->vhost_backend_cleanup(hdev);\n\n    return r;\n\n}\n", "idx": 9929, "_split": "test", "_hash": "e3eeedb7252c3f043868671c28202f6c"}
{"project": "qemu", "commit_id": "6a8f9661dc3c088ed0d2f5b41d940190407cbdc5", "target": 0, "func": "void qmp_transaction(TransactionActionList *dev_list, Error **errp)\n\n{\n\n    TransactionActionList *dev_entry = dev_list;\n\n    BlkTransactionState *state, *next;\n\n    Error *local_err = NULL;\n\n\n\n    QSIMPLEQ_HEAD(snap_bdrv_states, BlkTransactionState) snap_bdrv_states;\n\n    QSIMPLEQ_INIT(&snap_bdrv_states);\n\n\n\n    /* drain all i/o before any operations */\n\n    bdrv_drain_all();\n\n\n\n    /* We don't do anything in this loop that commits us to the operations */\n\n    while (NULL != dev_entry) {\n\n        TransactionAction *dev_info = NULL;\n\n        const BdrvActionOps *ops;\n\n\n\n        dev_info = dev_entry->value;\n\n        dev_entry = dev_entry->next;\n\n\n\n        assert(dev_info->kind < ARRAY_SIZE(actions));\n\n\n\n        ops = &actions[dev_info->kind];\n\n        assert(ops->instance_size > 0);\n\n\n\n        state = g_malloc0(ops->instance_size);\n\n        state->ops = ops;\n\n        state->action = dev_info;\n\n        QSIMPLEQ_INSERT_TAIL(&snap_bdrv_states, state, entry);\n\n\n\n        state->ops->prepare(state, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            goto delete_and_fail;\n\n        }\n\n    }\n\n\n\n    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {\n\n        if (state->ops->commit) {\n\n            state->ops->commit(state);\n\n        }\n\n    }\n\n\n\n    /* success */\n\n    goto exit;\n\n\n\ndelete_and_fail:\n\n    /* failure, and it is all-or-none; roll back all operations */\n\n    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {\n\n        if (state->ops->abort) {\n\n            state->ops->abort(state);\n\n        }\n\n    }\n\nexit:\n\n    QSIMPLEQ_FOREACH_SAFE(state, &snap_bdrv_states, entry, next) {\n\n        if (state->ops->clean) {\n\n            state->ops->clean(state);\n\n        }\n\n        g_free(state);\n\n    }\n\n}\n", "idx": 9943, "_split": "test", "_hash": "127552d538f65fd47b4181f49d1516e4"}
{"project": "qemu", "commit_id": "d15fda639ba356148fc7161bba863866fd2797ef", "target": 0, "func": "static int intel_hda_init(PCIDevice *pci)\n\n{\n\n    IntelHDAState *d = DO_UPCAST(IntelHDAState, pci, pci);\n\n    uint8_t *conf = d->pci.config;\n\n\n\n    d->name = d->pci.qdev.info->name;\n\n\n\n    pci_config_set_vendor_id(conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(conf, 0x2668);\n\n    pci_config_set_revision(conf, 1);\n\n    pci_config_set_class(conf, PCI_CLASS_MULTIMEDIA_HD_AUDIO);\n\n    pci_config_set_interrupt_pin(conf, 1);\n\n\n\n    /* HDCTL off 0x40 bit 0 selects signaling mode (1-HDA, 0 - Ac97) 18.1.19 */\n\n    conf[0x40] = 0x01;\n\n\n\n    d->mmio_addr = cpu_register_io_memory(intel_hda_mmio_read,\n\n                                          intel_hda_mmio_write, d,\n\n                                          DEVICE_NATIVE_ENDIAN);\n\n    pci_register_bar_simple(&d->pci, 0, 0x4000, 0, d->mmio_addr);\n\n    if (d->msi) {\n\n        msi_init(&d->pci, 0x50, 1, true, false);\n\n    }\n\n\n\n    hda_codec_bus_init(&d->pci.qdev, &d->codecs,\n\n                       intel_hda_response, intel_hda_xfer);\n\n\n\n    return 0;\n\n}\n", "idx": 9956, "_split": "test", "_hash": "821c4c0f0d21c0cd78803fa2d25f4521"}
{"project": "qemu", "commit_id": "9ef91a677110ec200d7b2904fc4bcae5a77329ad", "target": 0, "func": "static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    RawAIOCB *acb;\n\n\n\n    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    if (qemu_paio_write(&acb->aiocb) < 0) {\n\n        raw_aio_remove(acb);\n\n        return NULL;\n\n    }\n\n    return &acb->common;\n\n}\n", "idx": 9961, "_split": "test", "_hash": "55d5d626527bba3b18f23044d2f05601"}
{"project": "qemu", "commit_id": "e3af7c788b73a6495eb9d94992ef11f6ad6f3c56", "target": 0, "func": "static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)\n\n{\n\n    uint32_t ret;\n\n\n\n    switch (ot) {\n\n    case MO_8:\n\n        ret = cpu_ldub_code(env, s->pc);\n\n        s->pc++;\n\n        break;\n\n    case MO_16:\n\n        ret = cpu_lduw_code(env, s->pc);\n\n        s->pc += 2;\n\n        break;\n\n    case MO_32:\n\n#ifdef TARGET_X86_64\n\n    case MO_64:\n\n#endif\n\n        ret = cpu_ldl_code(env, s->pc);\n\n        s->pc += 4;\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n    return ret;\n\n}\n", "idx": 10000, "_split": "test", "_hash": "55d9e909de81fad9f4210d0d5de3cfad"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void bdrv_throttle_write_timer_cb(void *opaque)\n\n{\n\n    BlockDriverState *bs = opaque;\n\n    qemu_co_enter_next(&bs->throttled_reqs[1]);\n\n}\n", "idx": 10026, "_split": "test", "_hash": "2de7312a9bb1846a25c7bcba944d3651"}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "static int find_pte32(CPUPPCState *env, mmu_ctx_t *ctx, int h,\n\n                      int rw, int type, int target_page_bits)\n\n{\n\n    hwaddr pteg_off;\n\n    target_ulong pte0, pte1;\n\n    int i, good = -1;\n\n    int ret, r;\n\n\n\n    ret = -1; /* No entry found */\n\n    pteg_off = get_pteg_offset(env, ctx->hash[h], HASH_PTE_SIZE_32);\n\n    for (i = 0; i < 8; i++) {\n\n        if (env->external_htab) {\n\n            pte0 = ldl_p(env->external_htab + pteg_off + (i * 8));\n\n            pte1 = ldl_p(env->external_htab + pteg_off + (i * 8) + 4);\n\n        } else {\n\n            pte0 = ldl_phys(env->htab_base + pteg_off + (i * 8));\n\n            pte1 = ldl_phys(env->htab_base + pteg_off + (i * 8) + 4);\n\n        }\n\n        r = pte_check_hash32(ctx, pte0, pte1, h, rw, type);\n\n        LOG_MMU(\"Load pte from %08\" HWADDR_PRIx \" => \" TARGET_FMT_lx \" \"\n\n                TARGET_FMT_lx \" %d %d %d \" TARGET_FMT_lx \"\\n\",\n\n                pteg_off + (i * 8), pte0, pte1, (int)(pte0 >> 31), h,\n\n                (int)((pte0 >> 6) & 1), ctx->ptem);\n\n        switch (r) {\n\n        case -3:\n\n            /* PTE inconsistency */\n\n            return -1;\n\n        case -2:\n\n            /* Access violation */\n\n            ret = -2;\n\n            good = i;\n\n            break;\n\n        case -1:\n\n        default:\n\n            /* No PTE match */\n\n            break;\n\n        case 0:\n\n            /* access granted */\n\n            /* XXX: we should go on looping to check all PTEs consistency\n\n             *      but if we can speed-up the whole thing as the\n\n             *      result would be undefined if PTEs are not consistent.\n\n             */\n\n            ret = 0;\n\n            good = i;\n\n            goto done;\n\n        }\n\n    }\n\n    if (good != -1) {\n\n    done:\n\n        LOG_MMU(\"found PTE at addr %08\" HWADDR_PRIx \" prot=%01x ret=%d\\n\",\n\n                ctx->raddr, ctx->prot, ret);\n\n        /* Update page flags */\n\n        pte1 = ctx->raddr;\n\n        if (pte_update_flags(ctx, &pte1, ret, rw) == 1) {\n\n            if (env->external_htab) {\n\n                stl_p(env->external_htab + pteg_off + (good * 8) + 4,\n\n                      pte1);\n\n            } else {\n\n                stl_phys_notdirty(env->htab_base + pteg_off +\n\n                                  (good * 8) + 4, pte1);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* We have a TLB that saves 4K pages, so let's\n\n     * split a huge page to 4k chunks */\n\n    if (target_page_bits != TARGET_PAGE_BITS) {\n\n        ctx->raddr |= (ctx->eaddr & ((1 << target_page_bits) - 1))\n\n                      & TARGET_PAGE_MASK;\n\n    }\n\n    return ret;\n\n}\n", "idx": 10049, "_split": "test", "_hash": "97439c52df069cabf116837d4f8c179c"}
{"project": "qemu", "commit_id": "b9bec74bcb16519a876ec21cd5277c526a9b512d", "target": 0, "func": "static int kvm_put_xcrs(CPUState *env)\n\n{\n\n#ifdef KVM_CAP_XCRS\n\n    struct kvm_xcrs xcrs;\n\n\n\n    if (!kvm_has_xcrs())\n\n        return 0;\n\n\n\n    xcrs.nr_xcrs = 1;\n\n    xcrs.flags = 0;\n\n    xcrs.xcrs[0].xcr = 0;\n\n    xcrs.xcrs[0].value = env->xcr0;\n\n    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);\n\n#else\n\n    return 0;\n\n#endif\n\n}\n", "idx": 10055, "_split": "test", "_hash": "6107a166100cf4fda20902d11deede74"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static ExitStatus gen_bcond_internal(DisasContext *ctx, TCGCond cond,\n\n                                     TCGv cmp, int32_t disp)\n\n{\n\n    uint64_t dest = ctx->pc + (disp << 2);\n\n    int lab_true = gen_new_label();\n\n\n\n    if (use_goto_tb(ctx, dest)) {\n\n        tcg_gen_brcondi_i64(cond, cmp, 0, lab_true);\n\n\n\n        tcg_gen_goto_tb(0);\n\n        tcg_gen_movi_i64(cpu_pc, ctx->pc);\n\n        tcg_gen_exit_tb((uintptr_t)ctx->tb);\n\n\n\n        gen_set_label(lab_true);\n\n        tcg_gen_goto_tb(1);\n\n        tcg_gen_movi_i64(cpu_pc, dest);\n\n        tcg_gen_exit_tb((uintptr_t)ctx->tb + 1);\n\n\n\n        return EXIT_GOTO_TB;\n\n    } else {\n\n        TCGv_i64 z = tcg_const_i64(0);\n\n        TCGv_i64 d = tcg_const_i64(dest);\n\n        TCGv_i64 p = tcg_const_i64(ctx->pc);\n\n\n\n        tcg_gen_movcond_i64(cond, cpu_pc, cmp, z, d, p);\n\n\n\n        tcg_temp_free_i64(z);\n\n        tcg_temp_free_i64(d);\n\n        tcg_temp_free_i64(p);\n\n        return EXIT_PC_UPDATED;\n\n    }\n\n}\n", "idx": 10064, "_split": "test", "_hash": "1b1b125782b8fe544f58600e30910e74"}
{"project": "qemu", "commit_id": "1931e26054fdf2b1b84091f0b9662979eb6931ec", "target": 0, "func": "static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)\n\n{\n\n    uint32_t val = pci_default_read_config(d, address, len);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    val = bswap32(val);\n\n#endif\n\n    return val;\n\n}\n", "idx": 10081, "_split": "test", "_hash": "f7d330d8fa711186917a2fe2c2e61874"}
{"project": "qemu", "commit_id": "bbade20633a6b4ed7333e03a76038eda98950946", "target": 1, "func": "static void rtas_get_time_of_day(PowerPCCPU *cpu, sPAPREnvironment *spapr,\n\n                                 uint32_t token, uint32_t nargs,\n\n                                 target_ulong args,\n\n                                 uint32_t nret, target_ulong rets)\n\n{\n\n    struct tm tm;\n\n\n\n    if (nret != 8) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    qemu_get_timedate(&tm, spapr->rtc_offset);\n\n\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    rtas_st(rets, 1, tm.tm_year + 1900);\n\n    rtas_st(rets, 2, tm.tm_mon + 1);\n\n    rtas_st(rets, 3, tm.tm_mday);\n\n    rtas_st(rets, 4, tm.tm_hour);\n\n    rtas_st(rets, 5, tm.tm_min);\n\n    rtas_st(rets, 6, tm.tm_sec);\n\n    rtas_st(rets, 7, 0); /* we don't do nanoseconds */\n\n}\n", "idx": 10104, "_split": "test", "_hash": "7c2a058813b469521b6ff2ff03473941"}
{"project": "qemu", "commit_id": "3d948cdf3760b52238038626a7ffa7d30913060b", "target": 0, "func": "void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)\n\n{\n\n    BlockJob *job = find_block_job(device);\n\n\n\n    if (!job) {\n\n        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);\n\n        return;\n\n    }\n\n\n\n    block_job_set_speed(job, speed, errp);\n\n}\n", "idx": 10128, "_split": "test", "_hash": "0cbc2395cb41f1cb5f9f2f3b9e461115"}
{"project": "qemu", "commit_id": "338c25b6929b5436a42aaa106c7e9136cf1ff4dc", "target": 1, "func": "static int htab_save_later_pass(QEMUFile *f, sPAPREnvironment *spapr,\n\n                                int64_t max_ns)\n\n{\n\n    bool final = max_ns < 0;\n\n    int htabslots = HTAB_SIZE(spapr) / HASH_PTE_SIZE_64;\n\n    int examined = 0, sent = 0;\n\n    int index = spapr->htab_save_index;\n\n    int64_t starttime = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n\n\n    assert(!spapr->htab_first_pass);\n\n\n\n    do {\n\n        int chunkstart, invalidstart;\n\n\n\n        /* Consume non-dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && !HPTE_DIRTY(HPTE(spapr->htab, index))) {\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        chunkstart = index;\n\n        /* Consume valid dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && HPTE_DIRTY(HPTE(spapr->htab, index))\n\n               && HPTE_VALID(HPTE(spapr->htab, index))) {\n\n            CLEAN_HPTE(HPTE(spapr->htab, index));\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        invalidstart = index;\n\n        /* Consume invalid dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && HPTE_DIRTY(HPTE(spapr->htab, index))\n\n               && !HPTE_VALID(HPTE(spapr->htab, index))) {\n\n            CLEAN_HPTE(HPTE(spapr->htab, index));\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        if (index > chunkstart) {\n\n            int n_valid = invalidstart - chunkstart;\n\n            int n_invalid = index - invalidstart;\n\n\n\n            qemu_put_be32(f, chunkstart);\n\n            qemu_put_be16(f, n_valid);\n\n            qemu_put_be16(f, n_invalid);\n\n            qemu_put_buffer(f, HPTE(spapr->htab, chunkstart),\n\n                            HASH_PTE_SIZE_64 * n_valid);\n\n            sent += index - chunkstart;\n\n\n\n            if (!final && (qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - starttime) > max_ns) {\n\n                break;\n\n            }\n\n        }\n\n\n\n        if (examined >= htabslots) {\n\n            break;\n\n        }\n\n\n\n        if (index >= htabslots) {\n\n            assert(index == htabslots);\n\n            index = 0;\n\n        }\n\n    } while ((examined < htabslots) && (!qemu_file_rate_limit(f) || final));\n\n\n\n    if (index >= htabslots) {\n\n        assert(index == htabslots);\n\n        index = 0;\n\n    }\n\n\n\n    spapr->htab_save_index = index;\n\n\n\n    return (examined >= htabslots) && (sent == 0) ? 1 : 0;\n\n}\n", "idx": 10180, "_split": "test", "_hash": "dec3f3dc6405c77f7eea35f61eb10dde"}
{"project": "qemu", "commit_id": "6c5b5645ae0b73c052df962e18e48d87bb7385e0", "target": 0, "func": "static abi_long do_socket(int domain, int type, int protocol)\n\n{\n\n    int target_type = type;\n\n    int ret;\n\n\n\n    ret = target_to_host_sock_type(&type);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (domain == PF_NETLINK)\n\n        return -TARGET_EAFNOSUPPORT;\n\n\n\n    if (domain == AF_PACKET ||\n\n        (domain == AF_INET && type == SOCK_PACKET)) {\n\n        protocol = tswap16(protocol);\n\n    }\n\n\n\n    ret = get_errno(socket(domain, type, protocol));\n\n    if (ret >= 0) {\n\n        ret = sock_flags_fixup(ret, target_type);\n\n        if (type == SOCK_PACKET) {\n\n            /* Manage an obsolete case :\n\n             * if socket type is SOCK_PACKET, bind by name\n\n             */\n\n            fd_trans_register(ret, &target_packet_trans);\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 10190, "_split": "test", "_hash": "35907e55792876f62131eb062d2b1601"}
{"project": "qemu", "commit_id": "1a61a9ae61cdf7b7d24c3eb711fe772c196c235e", "target": 0, "func": "int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    uint32_t *hc = (uint32_t*)buf;\n\n\n\n    struct kvm_ppc_pvinfo pvinfo;\n\n\n\n    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&\n\n        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {\n\n        memcpy(buf, pvinfo.hcall, buf_len);\n\n\n\n        return 0;\n\n    }\n\n\n\n    /*\n\n     * Fallback to always fail hypercalls:\n\n     *\n\n     *     li r3, -1\n\n     *     nop\n\n     *     nop\n\n     *     nop\n\n     */\n\n\n\n    hc[0] = 0x3860ffff;\n\n    hc[1] = 0x60000000;\n\n    hc[2] = 0x60000000;\n\n    hc[3] = 0x60000000;\n\n\n\n    return 0;\n\n}\n", "idx": 10192, "_split": "test", "_hash": "d8da980b99a7b1ff8a75b387cc6cd42d"}
{"project": "qemu", "commit_id": "1bcef683bf840a928d633755031ac572d5fdb851", "target": 0, "func": "void process_incoming_migration(QEMUFile *f)\n\n{\n\n    if (qemu_loadvm_state(f) < 0) {\n\n        fprintf(stderr, \"load of migration failed\\n\");\n\n        exit(0);\n\n    }\n\n    qemu_announce_self();\n\n    DPRINTF(\"successfully loaded vm state\\n\");\n\n\n\n    incoming_expected = false;\n\n\n\n    if (autostart) {\n\n        vm_start();\n\n    } else {\n\n        runstate_set(RSTATE_PRE_LAUNCH);\n\n    }\n\n}\n", "idx": 10194, "_split": "test", "_hash": "b10c317cee40b1f98ee870eae6ccc36c"}
{"project": "qemu", "commit_id": "39a7a362e16bb27e98738d63f24d1ab5811e26a8", "target": 0, "func": "void qemu_coroutine_delete(Coroutine *co_)\n\n{\n\n    CoroutineThreadState *s = coroutine_get_thread_state();\n\n    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);\n\n\n\n    if (s->pool_size < POOL_MAX_SIZE) {\n\n        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);\n\n        co->base.caller = NULL;\n\n        s->pool_size++;\n\n        return;\n\n    }\n\n\n\n    g_free(co->stack);\n\n    g_free(co);\n\n}\n", "idx": 10266, "_split": "test", "_hash": "df9e9659dccab9a13f497914ae7496ce"}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "int float64_eq_signaling( float64 a, float64 b STATUS_PARAM )\n\n{\n\n\n\n    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )\n\n         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )\n\n       ) {\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n        return 0;\n\n    }\n\n    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );\n\n\n\n}\n", "idx": 10268, "_split": "test", "_hash": "b2d15f85ec48032e786be4cc6cb027eb"}
{"project": "qemu", "commit_id": "92dcc234ec1f266fb5d59bed77d66320c2c75965", "target": 0, "func": "static int tpm_passthrough_unix_tx_bufs(int tpm_fd,\n\n                                        const uint8_t *in, uint32_t in_len,\n\n                                        uint8_t *out, uint32_t out_len)\n\n{\n\n    int ret;\n\n\n\n    ret = tpm_passthrough_unix_write(tpm_fd, in, in_len);\n\n    if (ret != in_len) {\n\n        error_report(\"tpm_passthrough: error while transmitting data \"\n\n                     \"to TPM: %s (%i)\\n\",\n\n                     strerror(errno), errno);\n\n        goto err_exit;\n\n    }\n\n\n\n    ret = tpm_passthrough_unix_read(tpm_fd, out, out_len);\n\n    if (ret < 0) {\n\n        error_report(\"tpm_passthrough: error while reading data from \"\n\n                     \"TPM: %s (%i)\\n\",\n\n                     strerror(errno), errno);\n\n    } else if (ret < sizeof(struct tpm_resp_hdr) ||\n\n               tpm_passthrough_get_size_from_buffer(out) != ret) {\n\n        ret = -1;\n\n        error_report(\"tpm_passthrough: received invalid response \"\n\n                     \"packet from TPM\\n\");\n\n    }\n\n\n\nerr_exit:\n\n    if (ret < 0) {\n\n        tpm_write_fatal_error_response(out, out_len);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 10269, "_split": "test", "_hash": "de0efb3fffa770fb13d2f15f578eb16a"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,\n\n                        uint8_t *buf, int len, int is_write)\n\n{\n\n    int l;\n\n    target_phys_addr_t phys_addr;\n\n    target_ulong page;\n\n\n\n    while (len > 0) {\n\n        page = addr & TARGET_PAGE_MASK;\n\n        phys_addr = cpu_get_phys_page_debug(env, page);\n\n        /* if no physical page mapped, return an error */\n\n        if (phys_addr == -1)\n\n            return -1;\n\n        l = (page + TARGET_PAGE_SIZE) - addr;\n\n        if (l > len)\n\n            l = len;\n\n        phys_addr += (addr & ~TARGET_PAGE_MASK);\n\n        if (is_write)\n\n            cpu_physical_memory_write_rom(phys_addr, buf, l);\n\n        else\n\n            cpu_physical_memory_rw(phys_addr, buf, l, is_write);\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n    }\n\n    return 0;\n\n}\n", "idx": 10278, "_split": "test", "_hash": "0a07a0a201b6c0e557e0f039a8d9ca0f"}
{"project": "qemu", "commit_id": "0919ac787641db11024912651f3bc5764d4f1286", "target": 0, "func": "struct omap_uwire_s *omap_uwire_init(MemoryRegion *system_memory,\n\n                target_phys_addr_t base,\n\n                qemu_irq *irq, qemu_irq dma, omap_clk clk)\n\n{\n\n    struct omap_uwire_s *s = (struct omap_uwire_s *)\n\n            g_malloc0(sizeof(struct omap_uwire_s));\n\n\n\n    s->txirq = irq[0];\n\n    s->rxirq = irq[1];\n\n    s->txdrq = dma;\n\n    omap_uwire_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_uwire_ops, s, \"omap-uwire\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 10282, "_split": "test", "_hash": "3d2780c04c912f2f327e172142d963b9"}
{"project": "qemu", "commit_id": "66668d197fa40747e835e15617eda2f1bc80982f", "target": 0, "func": "static int send_sub_rect(VncState *vs, int x, int y, int w, int h)\n\n{\n\n    VncPalette *palette = &color_count_palette;\n\n    uint32_t bg = 0, fg = 0;\n\n    int colors;\n\n    int ret = 0;\n\n#ifdef CONFIG_VNC_JPEG\n\n    bool force_jpeg = false;\n\n    bool allow_jpeg = true;\n\n#endif\n\n\n\n    vnc_framebuffer_update(vs, x, y, w, h, vs->tight.type);\n\n\n\n    vnc_tight_start(vs);\n\n    vnc_raw_send_framebuffer_update(vs, x, y, w, h);\n\n    vnc_tight_stop(vs);\n\n\n\n#ifdef CONFIG_VNC_JPEG\n\n    if (!vs->vd->non_adaptive && vs->tight.quality != (uint8_t)-1) {\n\n        double freq = vnc_update_freq(vs, x, y, w, h);\n\n\n\n        if (freq < tight_jpeg_conf[vs->tight.quality].jpeg_freq_min) {\n\n            allow_jpeg = false;\n\n        }\n\n        if (freq >= tight_jpeg_conf[vs->tight.quality].jpeg_freq_threshold) {\n\n            force_jpeg = true;\n\n            vnc_sent_lossy_rect(vs, x, y, w, h);\n\n        }\n\n    }\n\n#endif\n\n\n\n    colors = tight_fill_palette(vs, x, y, w * h, &bg, &fg, palette);\n\n\n\n#ifdef CONFIG_VNC_JPEG\n\n    if (allow_jpeg && vs->tight.quality != (uint8_t)-1) {\n\n        ret = send_sub_rect_jpeg(vs, x, y, w, h, bg, fg, colors, palette,\n\n                                 force_jpeg);\n\n    } else {\n\n        ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n\n    }\n\n#else\n\n    ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n\n#endif\n\n\n\n    return ret;\n\n}\n", "idx": 10291, "_split": "test", "_hash": "620314530091257ada105e4736415803"}
{"project": "qemu", "commit_id": "5238c88657d751e3acf3e953a9b11f5f24262f75", "target": 0, "func": "static ExitStatus translate_one(DisasContext *ctx, uint32_t insn)\n\n{\n\n    uint32_t palcode;\n\n    int32_t disp21, disp16;\n\n#ifndef CONFIG_USER_ONLY\n\n    int32_t disp12;\n\n#endif\n\n    uint16_t fn11;\n\n    uint8_t opc, ra, rb, rc, fpfn, fn7, islit, real_islit;\n\n    uint8_t lit;\n\n    ExitStatus ret;\n\n\n\n    /* Decode all instruction fields */\n\n    opc = insn >> 26;\n\n    ra = (insn >> 21) & 0x1F;\n\n    rb = (insn >> 16) & 0x1F;\n\n    rc = insn & 0x1F;\n\n    real_islit = islit = (insn >> 12) & 1;\n\n    if (rb == 31 && !islit) {\n\n        islit = 1;\n\n        lit = 0;\n\n    } else\n\n        lit = (insn >> 13) & 0xFF;\n\n    palcode = insn & 0x03FFFFFF;\n\n    disp21 = ((int32_t)((insn & 0x001FFFFF) << 11)) >> 11;\n\n    disp16 = (int16_t)(insn & 0x0000FFFF);\n\n#ifndef CONFIG_USER_ONLY\n\n    disp12 = (int32_t)((insn & 0x00000FFF) << 20) >> 20;\n\n#endif\n\n    fn11 = (insn >> 5) & 0x000007FF;\n\n    fpfn = fn11 & 0x3F;\n\n    fn7 = (insn >> 5) & 0x0000007F;\n\n    LOG_DISAS(\"opc %02x ra %2d rb %2d rc %2d disp16 %6d\\n\",\n\n              opc, ra, rb, rc, disp16);\n\n\n\n    ret = NO_EXIT;\n\n    switch (opc) {\n\n    case 0x00:\n\n        /* CALL_PAL */\n\n        ret = gen_call_pal(ctx, palcode);\n\n        break;\n\n    case 0x01:\n\n        /* OPC01 */\n\n        goto invalid_opc;\n\n    case 0x02:\n\n        /* OPC02 */\n\n        goto invalid_opc;\n\n    case 0x03:\n\n        /* OPC03 */\n\n        goto invalid_opc;\n\n    case 0x04:\n\n        /* OPC04 */\n\n        goto invalid_opc;\n\n    case 0x05:\n\n        /* OPC05 */\n\n        goto invalid_opc;\n\n    case 0x06:\n\n        /* OPC06 */\n\n        goto invalid_opc;\n\n    case 0x07:\n\n        /* OPC07 */\n\n        goto invalid_opc;\n\n    case 0x08:\n\n        /* LDA */\n\n        if (likely(ra != 31)) {\n\n            if (rb != 31) {\n\n                tcg_gen_addi_i64(cpu_ir[ra], cpu_ir[rb], disp16);\n\n            } else {\n\n                tcg_gen_movi_i64(cpu_ir[ra], disp16);\n\n            }\n\n        }\n\n        break;\n\n    case 0x09:\n\n        /* LDAH */\n\n        if (likely(ra != 31)) {\n\n            if (rb != 31) {\n\n                tcg_gen_addi_i64(cpu_ir[ra], cpu_ir[rb], disp16 << 16);\n\n            } else {\n\n                tcg_gen_movi_i64(cpu_ir[ra], disp16 << 16);\n\n            }\n\n        }\n\n        break;\n\n    case 0x0A:\n\n        /* LDBU */\n\n        if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) {\n\n            gen_load_mem(ctx, &tcg_gen_qemu_ld8u, ra, rb, disp16, 0, 0);\n\n            break;\n\n        }\n\n        goto invalid_opc;\n\n    case 0x0B:\n\n        /* LDQ_U */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 0, 1);\n\n        break;\n\n    case 0x0C:\n\n        /* LDWU */\n\n        if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) {\n\n            gen_load_mem(ctx, &tcg_gen_qemu_ld16u, ra, rb, disp16, 0, 0);\n\n            break;\n\n        }\n\n        goto invalid_opc;\n\n    case 0x0D:\n\n        /* STW */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st16, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x0E:\n\n        /* STB */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st8, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x0F:\n\n        /* STQ_U */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 0, 1);\n\n        break;\n\n    case 0x10:\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* ADDL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    } else {\n\n                        tcg_gen_add_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x02:\n\n            /* S4ADDL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 2);\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(tmp, tmp, lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(tmp, tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], tmp);\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x09:\n\n            /* SUBL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x0B:\n\n            /* S4SUBL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 2);\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(tmp, tmp, lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(tmp, tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], tmp);\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x0F:\n\n            /* CMPBGE */\n\n            gen_cmpbge(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x12:\n\n            /* S8ADDL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 3);\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(tmp, tmp, lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(tmp, tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], tmp);\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x1B:\n\n            /* S8SUBL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 3);\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(tmp, tmp, lit);\n\n                    } else {\n\n                       tcg_gen_sub_i64(tmp, tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], tmp);\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x1D:\n\n            /* CMPULT */\n\n            gen_cmp(TCG_COND_LTU, ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x20:\n\n            /* ADDQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x22:\n\n            /* S4ADDQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 2);\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(cpu_ir[rc], tmp, lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(cpu_ir[rc], tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x29:\n\n            /* SUBQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x2B:\n\n            /* S4SUBQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 2);\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(cpu_ir[rc], tmp, lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(cpu_ir[rc], tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x2D:\n\n            /* CMPEQ */\n\n            gen_cmp(TCG_COND_EQ, ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x32:\n\n            /* S8ADDQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 3);\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(cpu_ir[rc], tmp, lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(cpu_ir[rc], tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x3B:\n\n            /* S8SUBQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 3);\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(cpu_ir[rc], tmp, lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(cpu_ir[rc], tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x3D:\n\n            /* CMPULE */\n\n            gen_cmp(TCG_COND_LEU, ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x40:\n\n            /* ADDL/V */\n\n            gen_addlv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x49:\n\n            /* SUBL/V */\n\n            gen_sublv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x4D:\n\n            /* CMPLT */\n\n            gen_cmp(TCG_COND_LT, ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x60:\n\n            /* ADDQ/V */\n\n            gen_addqv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x69:\n\n            /* SUBQ/V */\n\n            gen_subqv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x6D:\n\n            /* CMPLE */\n\n            gen_cmp(TCG_COND_LE, ra, rb, rc, islit, lit);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x11:\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* AND */\n\n            if (likely(rc != 31)) {\n\n                if (ra == 31) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                } else if (islit) {\n\n                    tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                } else {\n\n                    tcg_gen_and_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                }\n\n            }\n\n            break;\n\n        case 0x08:\n\n            /* BIC */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[ra], ~lit);\n\n                    } else {\n\n                        tcg_gen_andc_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x14:\n\n            /* CMOVLBS */\n\n            gen_cmov(TCG_COND_NE, ra, rb, rc, islit, lit, 1);\n\n            break;\n\n        case 0x16:\n\n            /* CMOVLBC */\n\n            gen_cmov(TCG_COND_EQ, ra, rb, rc, islit, lit, 1);\n\n            break;\n\n        case 0x20:\n\n            /* BIS */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_ori_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_or_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x24:\n\n            /* CMOVEQ */\n\n            gen_cmov(TCG_COND_EQ, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x26:\n\n            /* CMOVNE */\n\n            gen_cmov(TCG_COND_NE, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x28:\n\n            /* ORNOT */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_ori_i64(cpu_ir[rc], cpu_ir[ra], ~lit);\n\n                    } else {\n\n                        tcg_gen_orc_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], ~lit);\n\n                    } else {\n\n                        tcg_gen_not_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x40:\n\n            /* XOR */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_xori_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_xor_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x44:\n\n            /* CMOVLT */\n\n            gen_cmov(TCG_COND_LT, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x46:\n\n            /* CMOVGE */\n\n            gen_cmov(TCG_COND_GE, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x48:\n\n            /* EQV */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_xori_i64(cpu_ir[rc], cpu_ir[ra], ~lit);\n\n                    } else {\n\n                        tcg_gen_eqv_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], ~lit);\n\n                    } else {\n\n                        tcg_gen_not_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x61:\n\n            /* AMASK */\n\n            if (likely(rc != 31)) {\n\n                uint64_t amask = ctx->tb->flags >> TB_FLAGS_AMASK_SHIFT;\n\n\n\n                if (islit) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], lit & ~amask);\n\n                } else {\n\n                    tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[rb], ~amask);\n\n                }\n\n            }\n\n            break;\n\n        case 0x64:\n\n            /* CMOVLE */\n\n            gen_cmov(TCG_COND_LE, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x66:\n\n            /* CMOVGT */\n\n            gen_cmov(TCG_COND_GT, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x6C:\n\n            /* IMPLVER */\n\n            if (rc != 31) {\n\n                tcg_gen_movi_i64(cpu_ir[rc], ctx->implver);\n\n            }\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x12:\n\n        switch (fn7) {\n\n        case 0x02:\n\n            /* MSKBL */\n\n            gen_msk_l(ra, rb, rc, islit, lit, 0x01);\n\n            break;\n\n        case 0x06:\n\n            /* EXTBL */\n\n            gen_ext_l(ra, rb, rc, islit, lit, 0x01);\n\n            break;\n\n        case 0x0B:\n\n            /* INSBL */\n\n            gen_ins_l(ra, rb, rc, islit, lit, 0x01);\n\n            break;\n\n        case 0x12:\n\n            /* MSKWL */\n\n            gen_msk_l(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x16:\n\n            /* EXTWL */\n\n            gen_ext_l(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x1B:\n\n            /* INSWL */\n\n            gen_ins_l(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x22:\n\n            /* MSKLL */\n\n            gen_msk_l(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x26:\n\n            /* EXTLL */\n\n            gen_ext_l(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x2B:\n\n            /* INSLL */\n\n            gen_ins_l(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x30:\n\n            /* ZAP */\n\n            gen_zap(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x31:\n\n            /* ZAPNOT */\n\n            gen_zapnot(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x32:\n\n            /* MSKQL */\n\n            gen_msk_l(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x34:\n\n            /* SRL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_shri_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f);\n\n                    } else {\n\n                        TCGv shift = tcg_temp_new();\n\n                        tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f);\n\n                        tcg_gen_shr_i64(cpu_ir[rc], cpu_ir[ra], shift);\n\n                        tcg_temp_free(shift);\n\n                    }\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x36:\n\n            /* EXTQL */\n\n            gen_ext_l(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x39:\n\n            /* SLL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_shli_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f);\n\n                    } else {\n\n                        TCGv shift = tcg_temp_new();\n\n                        tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f);\n\n                        tcg_gen_shl_i64(cpu_ir[rc], cpu_ir[ra], shift);\n\n                        tcg_temp_free(shift);\n\n                    }\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x3B:\n\n            /* INSQL */\n\n            gen_ins_l(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x3C:\n\n            /* SRA */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_sari_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f);\n\n                    } else {\n\n                        TCGv shift = tcg_temp_new();\n\n                        tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f);\n\n                        tcg_gen_sar_i64(cpu_ir[rc], cpu_ir[ra], shift);\n\n                        tcg_temp_free(shift);\n\n                    }\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x52:\n\n            /* MSKWH */\n\n            gen_msk_h(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x57:\n\n            /* INSWH */\n\n            gen_ins_h(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x5A:\n\n            /* EXTWH */\n\n            gen_ext_h(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x62:\n\n            /* MSKLH */\n\n            gen_msk_h(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x67:\n\n            /* INSLH */\n\n            gen_ins_h(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x6A:\n\n            /* EXTLH */\n\n            gen_ext_h(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x72:\n\n            /* MSKQH */\n\n            gen_msk_h(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x77:\n\n            /* INSQH */\n\n            gen_ins_h(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x7A:\n\n            /* EXTQH */\n\n            gen_ext_h(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x13:\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* MULL */\n\n            if (likely(rc != 31)) {\n\n                if (ra == 31) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_muli_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_mul_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                }\n\n            }\n\n            break;\n\n        case 0x20:\n\n            /* MULQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra == 31) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                } else if (islit) {\n\n                    tcg_gen_muli_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                } else {\n\n                    tcg_gen_mul_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                }\n\n            }\n\n            break;\n\n        case 0x30:\n\n            /* UMULH */\n\n            {\n\n                TCGv low;\n\n                if (unlikely(rc == 31)){\n\n                    break;\n\n                }\n\n                if (ra == 31) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                    break;\n\n                }\n\n                low = tcg_temp_new();\n\n                if (islit) {\n\n                    tcg_gen_movi_tl(low, lit);\n\n                    tcg_gen_mulu2_i64(low, cpu_ir[rc], cpu_ir[ra], low);\n\n                } else {\n\n                    tcg_gen_mulu2_i64(low, cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                }\n\n                tcg_temp_free(low);\n\n            }\n\n            break;\n\n        case 0x40:\n\n            /* MULL/V */\n\n            gen_mullv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x60:\n\n            /* MULQ/V */\n\n            gen_mulqv(ra, rb, rc, islit, lit);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x14:\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x04:\n\n            /* ITOFS */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_trunc_i64_i32(tmp, cpu_ir[ra]);\n\n                    gen_helper_memory_to_s(cpu_fir[rc], tmp);\n\n                    tcg_temp_free_i32(tmp);\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x0A:\n\n            /* SQRTF */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) {\n\n                gen_fsqrtf(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x0B:\n\n            /* SQRTS */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) {\n\n                gen_fsqrts(ctx, rb, rc, fn11);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x14:\n\n            /* ITOFF */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_trunc_i64_i32(tmp, cpu_ir[ra]);\n\n                    gen_helper_memory_to_f(cpu_fir[rc], tmp);\n\n                    tcg_temp_free_i32(tmp);\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x24:\n\n            /* ITOFT */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    tcg_gen_mov_i64(cpu_fir[rc], cpu_ir[ra]);\n\n                } else {\n\n                    tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n                }\n\n            }\n\n            break;\n\n        case 0x2A:\n\n            /* SQRTG */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) {\n\n                gen_fsqrtg(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x02B:\n\n            /* SQRTT */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) {\n\n                gen_fsqrtt(ctx, rb, rc, fn11);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x15:\n\n        /* VAX floating point */\n\n        /* XXX: rounding mode and trap are ignored (!) */\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x00:\n\n            /* ADDF */\n\n            gen_faddf(ra, rb, rc);\n\n            break;\n\n        case 0x01:\n\n            /* SUBF */\n\n            gen_fsubf(ra, rb, rc);\n\n            break;\n\n        case 0x02:\n\n            /* MULF */\n\n            gen_fmulf(ra, rb, rc);\n\n            break;\n\n        case 0x03:\n\n            /* DIVF */\n\n            gen_fdivf(ra, rb, rc);\n\n            break;\n\n        case 0x1E:\n\n            /* CVTDG */\n\n#if 0 // TODO\n\n            gen_fcvtdg(rb, rc);\n\n#else\n\n            goto invalid_opc;\n\n#endif\n\n            break;\n\n        case 0x20:\n\n            /* ADDG */\n\n            gen_faddg(ra, rb, rc);\n\n            break;\n\n        case 0x21:\n\n            /* SUBG */\n\n            gen_fsubg(ra, rb, rc);\n\n            break;\n\n        case 0x22:\n\n            /* MULG */\n\n            gen_fmulg(ra, rb, rc);\n\n            break;\n\n        case 0x23:\n\n            /* DIVG */\n\n            gen_fdivg(ra, rb, rc);\n\n            break;\n\n        case 0x25:\n\n            /* CMPGEQ */\n\n            gen_fcmpgeq(ra, rb, rc);\n\n            break;\n\n        case 0x26:\n\n            /* CMPGLT */\n\n            gen_fcmpglt(ra, rb, rc);\n\n            break;\n\n        case 0x27:\n\n            /* CMPGLE */\n\n            gen_fcmpgle(ra, rb, rc);\n\n            break;\n\n        case 0x2C:\n\n            /* CVTGF */\n\n            gen_fcvtgf(rb, rc);\n\n            break;\n\n        case 0x2D:\n\n            /* CVTGD */\n\n#if 0 // TODO\n\n            gen_fcvtgd(rb, rc);\n\n#else\n\n            goto invalid_opc;\n\n#endif\n\n            break;\n\n        case 0x2F:\n\n            /* CVTGQ */\n\n            gen_fcvtgq(rb, rc);\n\n            break;\n\n        case 0x3C:\n\n            /* CVTQF */\n\n            gen_fcvtqf(rb, rc);\n\n            break;\n\n        case 0x3E:\n\n            /* CVTQG */\n\n            gen_fcvtqg(rb, rc);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x16:\n\n        /* IEEE floating-point */\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x00:\n\n            /* ADDS */\n\n            gen_fadds(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x01:\n\n            /* SUBS */\n\n            gen_fsubs(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x02:\n\n            /* MULS */\n\n            gen_fmuls(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x03:\n\n            /* DIVS */\n\n            gen_fdivs(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x20:\n\n            /* ADDT */\n\n            gen_faddt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x21:\n\n            /* SUBT */\n\n            gen_fsubt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x22:\n\n            /* MULT */\n\n            gen_fmult(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x23:\n\n            /* DIVT */\n\n            gen_fdivt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x24:\n\n            /* CMPTUN */\n\n            gen_fcmptun(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x25:\n\n            /* CMPTEQ */\n\n            gen_fcmpteq(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x26:\n\n            /* CMPTLT */\n\n            gen_fcmptlt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x27:\n\n            /* CMPTLE */\n\n            gen_fcmptle(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x2C:\n\n            if (fn11 == 0x2AC || fn11 == 0x6AC) {\n\n                /* CVTST */\n\n                gen_fcvtst(ctx, rb, rc, fn11);\n\n            } else {\n\n                /* CVTTS */\n\n                gen_fcvtts(ctx, rb, rc, fn11);\n\n            }\n\n            break;\n\n        case 0x2F:\n\n            /* CVTTQ */\n\n            gen_fcvttq(ctx, rb, rc, fn11);\n\n            break;\n\n        case 0x3C:\n\n            /* CVTQS */\n\n            gen_fcvtqs(ctx, rb, rc, fn11);\n\n            break;\n\n        case 0x3E:\n\n            /* CVTQT */\n\n            gen_fcvtqt(ctx, rb, rc, fn11);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x17:\n\n        switch (fn11) {\n\n        case 0x010:\n\n            /* CVTLQ */\n\n            gen_fcvtlq(rb, rc);\n\n            break;\n\n        case 0x020:\n\n            if (likely(rc != 31)) {\n\n                if (ra == rb) {\n\n                    /* FMOV */\n\n                    if (ra == 31) {\n\n                        tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_fir[rc], cpu_fir[ra]);\n\n                    }\n\n                } else {\n\n                    /* CPYS */\n\n                    gen_fcpys(ra, rb, rc);\n\n                }\n\n            }\n\n            break;\n\n        case 0x021:\n\n            /* CPYSN */\n\n            gen_fcpysn(ra, rb, rc);\n\n            break;\n\n        case 0x022:\n\n            /* CPYSE */\n\n            gen_fcpyse(ra, rb, rc);\n\n            break;\n\n        case 0x024:\n\n            /* MT_FPCR */\n\n            if (likely(ra != 31)) {\n\n                gen_helper_store_fpcr(cpu_env, cpu_fir[ra]);\n\n            } else {\n\n                TCGv tmp = tcg_const_i64(0);\n\n                gen_helper_store_fpcr(cpu_env, tmp);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n        case 0x025:\n\n            /* MF_FPCR */\n\n            if (likely(ra != 31)) {\n\n                gen_helper_load_fpcr(cpu_fir[ra], cpu_env);\n\n            }\n\n            break;\n\n        case 0x02A:\n\n            /* FCMOVEQ */\n\n            gen_fcmov(TCG_COND_EQ, ra, rb, rc);\n\n            break;\n\n        case 0x02B:\n\n            /* FCMOVNE */\n\n            gen_fcmov(TCG_COND_NE, ra, rb, rc);\n\n            break;\n\n        case 0x02C:\n\n            /* FCMOVLT */\n\n            gen_fcmov(TCG_COND_LT, ra, rb, rc);\n\n            break;\n\n        case 0x02D:\n\n            /* FCMOVGE */\n\n            gen_fcmov(TCG_COND_GE, ra, rb, rc);\n\n            break;\n\n        case 0x02E:\n\n            /* FCMOVLE */\n\n            gen_fcmov(TCG_COND_LE, ra, rb, rc);\n\n            break;\n\n        case 0x02F:\n\n            /* FCMOVGT */\n\n            gen_fcmov(TCG_COND_GT, ra, rb, rc);\n\n            break;\n\n        case 0x030:\n\n            /* CVTQL */\n\n            gen_fcvtql(rb, rc);\n\n            break;\n\n        case 0x130:\n\n            /* CVTQL/V */\n\n        case 0x530:\n\n            /* CVTQL/SV */\n\n            /* ??? I'm pretty sure there's nothing that /sv needs to do that\n\n               /v doesn't do.  The only thing I can think is that /sv is a\n\n               valid instruction merely for completeness in the ISA.  */\n\n            gen_fcvtql_v(ctx, rb, rc);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x18:\n\n        switch ((uint16_t)disp16) {\n\n        case 0x0000:\n\n            /* TRAPB */\n\n            /* No-op.  */\n\n            break;\n\n        case 0x0400:\n\n            /* EXCB */\n\n            /* No-op.  */\n\n            break;\n\n        case 0x4000:\n\n            /* MB */\n\n            /* No-op */\n\n            break;\n\n        case 0x4400:\n\n            /* WMB */\n\n            /* No-op */\n\n            break;\n\n        case 0x8000:\n\n            /* FETCH */\n\n            /* No-op */\n\n            break;\n\n        case 0xA000:\n\n            /* FETCH_M */\n\n            /* No-op */\n\n            break;\n\n        case 0xC000:\n\n            /* RPCC */\n\n            if (ra != 31) {\n\n                if (use_icount) {\n\n                    gen_io_start();\n\n                    gen_helper_load_pcc(cpu_ir[ra], cpu_env);\n\n                    gen_io_end();\n\n                    ret = EXIT_PC_STALE;\n\n                } else {\n\n                    gen_helper_load_pcc(cpu_ir[ra], cpu_env);\n\n                }\n\n            }\n\n            break;\n\n        case 0xE000:\n\n            /* RC */\n\n            gen_rx(ra, 0);\n\n            break;\n\n        case 0xE800:\n\n            /* ECB */\n\n            break;\n\n        case 0xF000:\n\n            /* RS */\n\n            gen_rx(ra, 1);\n\n            break;\n\n        case 0xF800:\n\n            /* WH64 */\n\n            /* No-op */\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x19:\n\n        /* HW_MFPR (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            return gen_mfpr(ra, insn & 0xffff);\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x1A:\n\n        /* JMP, JSR, RET, JSR_COROUTINE.  These only differ by the branch\n\n           prediction stack action, which of course we don't implement.  */\n\n        if (rb != 31) {\n\n            tcg_gen_andi_i64(cpu_pc, cpu_ir[rb], ~3);\n\n        } else {\n\n            tcg_gen_movi_i64(cpu_pc, 0);\n\n        }\n\n        if (ra != 31) {\n\n            tcg_gen_movi_i64(cpu_ir[ra], ctx->pc);\n\n        }\n\n        ret = EXIT_PC_UPDATED;\n\n        break;\n\n    case 0x1B:\n\n        /* HW_LD (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            TCGv addr;\n\n\n\n            if (ra == 31) {\n\n                break;\n\n            }\n\n\n\n            addr = tcg_temp_new();\n\n            if (rb != 31) {\n\n                tcg_gen_addi_i64(addr, cpu_ir[rb], disp12);\n\n            } else {\n\n                tcg_gen_movi_i64(addr, disp12);\n\n            }\n\n            switch ((insn >> 12) & 0xF) {\n\n            case 0x0:\n\n                /* Longword physical access (hw_ldl/p) */\n\n                gen_helper_ldl_phys(cpu_ir[ra], cpu_env, addr);\n\n                break;\n\n            case 0x1:\n\n                /* Quadword physical access (hw_ldq/p) */\n\n                gen_helper_ldq_phys(cpu_ir[ra], cpu_env, addr);\n\n                break;\n\n            case 0x2:\n\n                /* Longword physical access with lock (hw_ldl_l/p) */\n\n                gen_helper_ldl_l_phys(cpu_ir[ra], cpu_env, addr);\n\n                break;\n\n            case 0x3:\n\n                /* Quadword physical access with lock (hw_ldq_l/p) */\n\n                gen_helper_ldq_l_phys(cpu_ir[ra], cpu_env, addr);\n\n                break;\n\n            case 0x4:\n\n                /* Longword virtual PTE fetch (hw_ldl/v) */\n\n                goto invalid_opc;\n\n            case 0x5:\n\n                /* Quadword virtual PTE fetch (hw_ldq/v) */\n\n                goto invalid_opc;\n\n                break;\n\n            case 0x6:\n\n                /* Incpu_ir[ra]id */\n\n                goto invalid_opc;\n\n            case 0x7:\n\n                /* Incpu_ir[ra]id */\n\n                goto invalid_opc;\n\n            case 0x8:\n\n                /* Longword virtual access (hw_ldl) */\n\n                goto invalid_opc;\n\n            case 0x9:\n\n                /* Quadword virtual access (hw_ldq) */\n\n                goto invalid_opc;\n\n            case 0xA:\n\n                /* Longword virtual access with protection check (hw_ldl/w) */\n\n                tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_KERNEL_IDX, MO_LESL);\n\n                break;\n\n            case 0xB:\n\n                /* Quadword virtual access with protection check (hw_ldq/w) */\n\n                tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_KERNEL_IDX, MO_LEQ);\n\n                break;\n\n            case 0xC:\n\n                /* Longword virtual access with alt access mode (hw_ldl/a)*/\n\n                goto invalid_opc;\n\n            case 0xD:\n\n                /* Quadword virtual access with alt access mode (hw_ldq/a) */\n\n                goto invalid_opc;\n\n            case 0xE:\n\n                /* Longword virtual access with alternate access mode and\n\n                   protection checks (hw_ldl/wa) */\n\n                tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_USER_IDX, MO_LESL);\n\n                break;\n\n            case 0xF:\n\n                /* Quadword virtual access with alternate access mode and\n\n                   protection checks (hw_ldq/wa) */\n\n                tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_USER_IDX, MO_LEQ);\n\n                break;\n\n            }\n\n            tcg_temp_free(addr);\n\n            break;\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x1C:\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* SEXTB */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_BWX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (islit) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], (int64_t)((int8_t)lit));\n\n                } else {\n\n                    tcg_gen_ext8s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                }\n\n            }\n\n            break;\n\n        case 0x01:\n\n            /* SEXTW */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) {\n\n                if (likely(rc != 31)) {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], (int64_t)((int16_t)lit));\n\n                    } else {\n\n                        tcg_gen_ext16s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x30:\n\n            /* CTPOP */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) {\n\n                if (likely(rc != 31)) {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], ctpop64(lit));\n\n                    } else {\n\n                        gen_helper_ctpop(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x31:\n\n            /* PERR */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_perr(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x32:\n\n            /* CTLZ */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) {\n\n                if (likely(rc != 31)) {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], clz64(lit));\n\n                    } else {\n\n                        gen_helper_ctlz(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x33:\n\n            /* CTTZ */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) {\n\n                if (likely(rc != 31)) {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], ctz64(lit));\n\n                    } else {\n\n                        gen_helper_cttz(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x34:\n\n            /* UNPKBW */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                if (real_islit || ra != 31) {\n\n                    goto invalid_opc;\n\n                }\n\n                gen_unpkbw(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x35:\n\n            /* UNPKBL */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                if (real_islit || ra != 31) {\n\n                    goto invalid_opc;\n\n                }\n\n                gen_unpkbl(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x36:\n\n            /* PKWB */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                if (real_islit || ra != 31) {\n\n                    goto invalid_opc;\n\n                }\n\n                gen_pkwb(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x37:\n\n            /* PKLB */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                if (real_islit || ra != 31) {\n\n                    goto invalid_opc;\n\n                }\n\n                gen_pklb(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x38:\n\n            /* MINSB8 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_minsb8(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x39:\n\n            /* MINSW4 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_minsw4(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3A:\n\n            /* MINUB8 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_minub8(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3B:\n\n            /* MINUW4 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_minuw4(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3C:\n\n            /* MAXUB8 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_maxub8(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3D:\n\n            /* MAXUW4 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_maxuw4(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3E:\n\n            /* MAXSB8 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_maxsb8(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3F:\n\n            /* MAXSW4 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_maxsw4(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x70:\n\n            /* FTOIT */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    tcg_gen_mov_i64(cpu_ir[rc], cpu_fir[ra]);\n\n                } else {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                }\n\n            }\n\n            break;\n\n        case 0x78:\n\n            /* FTOIS */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (rc != 31) {\n\n                TCGv_i32 tmp1 = tcg_temp_new_i32();\n\n                if (ra != 31) {\n\n                    gen_helper_s_to_memory(tmp1, cpu_fir[ra]);\n\n                } else {\n\n                    TCGv tmp2 = tcg_const_i64(0);\n\n                    gen_helper_s_to_memory(tmp1, tmp2);\n\n                    tcg_temp_free(tmp2);\n\n                }\n\n                tcg_gen_ext_i32_i64(cpu_ir[rc], tmp1);\n\n                tcg_temp_free_i32(tmp1);\n\n            }\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x1D:\n\n        /* HW_MTPR (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            return gen_mtpr(ctx, rb, insn & 0xffff);\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x1E:\n\n        /* HW_RET (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            if (rb == 31) {\n\n                /* Pre-EV6 CPUs interpreted this as HW_REI, loading the return\n\n                   address from EXC_ADDR.  This turns out to be useful for our\n\n                   emulation PALcode, so continue to accept it.  */\n\n                TCGv tmp = tcg_temp_new();\n\n                tcg_gen_ld_i64(tmp, cpu_env, offsetof(CPUAlphaState, exc_addr));\n\n                gen_helper_hw_ret(cpu_env, tmp);\n\n                tcg_temp_free(tmp);\n\n            } else {\n\n                gen_helper_hw_ret(cpu_env, cpu_ir[rb]);\n\n            }\n\n            ret = EXIT_PC_UPDATED;\n\n            break;\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x1F:\n\n        /* HW_ST (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            TCGv addr, val;\n\n            addr = tcg_temp_new();\n\n            if (rb != 31) {\n\n                tcg_gen_addi_i64(addr, cpu_ir[rb], disp12);\n\n            } else {\n\n                tcg_gen_movi_i64(addr, disp12);\n\n            }\n\n            if (ra != 31) {\n\n                val = cpu_ir[ra];\n\n            } else {\n\n                val = tcg_temp_new();\n\n                tcg_gen_movi_i64(val, 0);\n\n            }\n\n            switch ((insn >> 12) & 0xF) {\n\n            case 0x0:\n\n                /* Longword physical access */\n\n                gen_helper_stl_phys(cpu_env, addr, val);\n\n                break;\n\n            case 0x1:\n\n                /* Quadword physical access */\n\n                gen_helper_stq_phys(cpu_env, addr, val);\n\n                break;\n\n            case 0x2:\n\n                /* Longword physical access with lock */\n\n                gen_helper_stl_c_phys(val, cpu_env, addr, val);\n\n                break;\n\n            case 0x3:\n\n                /* Quadword physical access with lock */\n\n                gen_helper_stq_c_phys(val, cpu_env, addr, val);\n\n                break;\n\n            case 0x4:\n\n                /* Longword virtual access */\n\n                goto invalid_opc;\n\n            case 0x5:\n\n                /* Quadword virtual access */\n\n                goto invalid_opc;\n\n            case 0x6:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x7:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x8:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x9:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xA:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xB:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xC:\n\n                /* Longword virtual access with alternate access mode */\n\n                goto invalid_opc;\n\n            case 0xD:\n\n                /* Quadword virtual access with alternate access mode */\n\n                goto invalid_opc;\n\n            case 0xE:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xF:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            }\n\n            if (ra == 31) {\n\n                tcg_temp_free(val);\n\n            }\n\n            tcg_temp_free(addr);\n\n            break;\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x20:\n\n        /* LDF */\n\n        gen_load_mem(ctx, &gen_qemu_ldf, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x21:\n\n        /* LDG */\n\n        gen_load_mem(ctx, &gen_qemu_ldg, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x22:\n\n        /* LDS */\n\n        gen_load_mem(ctx, &gen_qemu_lds, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x23:\n\n        /* LDT */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x24:\n\n        /* STF */\n\n        gen_store_mem(ctx, &gen_qemu_stf, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x25:\n\n        /* STG */\n\n        gen_store_mem(ctx, &gen_qemu_stg, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x26:\n\n        /* STS */\n\n        gen_store_mem(ctx, &gen_qemu_sts, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x27:\n\n        /* STT */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x28:\n\n        /* LDL */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld32s, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x29:\n\n        /* LDQ */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2A:\n\n        /* LDL_L */\n\n        gen_load_mem(ctx, &gen_qemu_ldl_l, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2B:\n\n        /* LDQ_L */\n\n        gen_load_mem(ctx, &gen_qemu_ldq_l, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2C:\n\n        /* STL */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st32, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2D:\n\n        /* STQ */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2E:\n\n        /* STL_C */\n\n        ret = gen_store_conditional(ctx, ra, rb, disp16, 0);\n\n        break;\n\n    case 0x2F:\n\n        /* STQ_C */\n\n        ret = gen_store_conditional(ctx, ra, rb, disp16, 1);\n\n        break;\n\n    case 0x30:\n\n        /* BR */\n\n        ret = gen_bdirect(ctx, ra, disp21);\n\n        break;\n\n    case 0x31: /* FBEQ */\n\n        ret = gen_fbcond(ctx, TCG_COND_EQ, ra, disp21);\n\n        break;\n\n    case 0x32: /* FBLT */\n\n        ret = gen_fbcond(ctx, TCG_COND_LT, ra, disp21);\n\n        break;\n\n    case 0x33: /* FBLE */\n\n        ret = gen_fbcond(ctx, TCG_COND_LE, ra, disp21);\n\n        break;\n\n    case 0x34:\n\n        /* BSR */\n\n        ret = gen_bdirect(ctx, ra, disp21);\n\n        break;\n\n    case 0x35: /* FBNE */\n\n        ret = gen_fbcond(ctx, TCG_COND_NE, ra, disp21);\n\n        break;\n\n    case 0x36: /* FBGE */\n\n        ret = gen_fbcond(ctx, TCG_COND_GE, ra, disp21);\n\n        break;\n\n    case 0x37: /* FBGT */\n\n        ret = gen_fbcond(ctx, TCG_COND_GT, ra, disp21);\n\n        break;\n\n    case 0x38:\n\n        /* BLBC */\n\n        ret = gen_bcond(ctx, TCG_COND_EQ, ra, disp21, 1);\n\n        break;\n\n    case 0x39:\n\n        /* BEQ */\n\n        ret = gen_bcond(ctx, TCG_COND_EQ, ra, disp21, 0);\n\n        break;\n\n    case 0x3A:\n\n        /* BLT */\n\n        ret = gen_bcond(ctx, TCG_COND_LT, ra, disp21, 0);\n\n        break;\n\n    case 0x3B:\n\n        /* BLE */\n\n        ret = gen_bcond(ctx, TCG_COND_LE, ra, disp21, 0);\n\n        break;\n\n    case 0x3C:\n\n        /* BLBS */\n\n        ret = gen_bcond(ctx, TCG_COND_NE, ra, disp21, 1);\n\n        break;\n\n    case 0x3D:\n\n        /* BNE */\n\n        ret = gen_bcond(ctx, TCG_COND_NE, ra, disp21, 0);\n\n        break;\n\n    case 0x3E:\n\n        /* BGE */\n\n        ret = gen_bcond(ctx, TCG_COND_GE, ra, disp21, 0);\n\n        break;\n\n    case 0x3F:\n\n        /* BGT */\n\n        ret = gen_bcond(ctx, TCG_COND_GT, ra, disp21, 0);\n\n        break;\n\n    invalid_opc:\n\n        ret = gen_invalid(ctx);\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 10295, "_split": "test", "_hash": "587bbb8c46ce5cc03be88938a363c06b"}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float32 HELPER(ucf64_abss)(float32 a)\n\n{\n\n    return float32_abs(a);\n\n}\n", "idx": 10316, "_split": "test", "_hash": "17edc818d1ce3b48eacad37f6a0e014e"}
{"project": "qemu", "commit_id": "b7680cb6078bd7294a3dd86473d3f2fdee991dd0", "target": 0, "func": "int qemu_thread_equal(QemuThread *thread1, QemuThread *thread2)\n\n{\n\n   return pthread_equal(thread1->thread, thread2->thread);\n\n}\n", "idx": 10322, "_split": "test", "_hash": "97817553f2de1c3ab53d9f37c78f6ed0"}
{"project": "qemu", "commit_id": "1b27d7a1e8609b2eeb6238f2c629eb82217523f6", "target": 0, "func": "static void ivshmem_io_writel(void *opaque, target_phys_addr_t addr,\n\n                                                            uint32_t val)\n\n{\n\n    IVShmemState *s = opaque;\n\n\n\n    uint64_t write_one = 1;\n\n    uint16_t dest = val >> 16;\n\n    uint16_t vector = val & 0xff;\n\n\n\n    addr &= 0xfc;\n\n\n\n    IVSHMEM_DPRINTF(\"writing to addr \" TARGET_FMT_plx \"\\n\", addr);\n\n    switch (addr)\n\n    {\n\n        case INTRMASK:\n\n            ivshmem_IntrMask_write(s, val);\n\n            break;\n\n\n\n        case INTRSTATUS:\n\n            ivshmem_IntrStatus_write(s, val);\n\n            break;\n\n\n\n        case DOORBELL:\n\n            /* check that dest VM ID is reasonable */\n\n            if ((dest < 0) || (dest > s->max_peer)) {\n\n                IVSHMEM_DPRINTF(\"Invalid destination VM ID (%d)\\n\", dest);\n\n                break;\n\n            }\n\n\n\n            /* check doorbell range */\n\n            if ((vector >= 0) && (vector < s->peers[dest].nb_eventfds)) {\n\n                IVSHMEM_DPRINTF(\"Writing %\" PRId64 \" to VM %d on vector %d\\n\",\n\n                                                    write_one, dest, vector);\n\n                if (write(s->peers[dest].eventfds[vector],\n\n                                                    &(write_one), 8) != 8) {\n\n                    IVSHMEM_DPRINTF(\"error writing to eventfd\\n\");\n\n                }\n\n            }\n\n            break;\n\n        default:\n\n            IVSHMEM_DPRINTF(\"Invalid VM Doorbell VM %d\\n\", dest);\n\n    }\n\n}\n", "idx": 10327, "_split": "test", "_hash": "f64c5b0b6bd294d7e6d4e004c07928be"}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static inline void gen_outs(DisasContext *s, TCGMemOp ot)\n\n{\n\n    if (use_icount)\n\n        gen_io_start();\n\n    gen_string_movl_A0_ESI(s);\n\n    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);\n\n\n\n    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);\n\n    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);\n\n    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);\n\n    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n\n\n    gen_op_movl_T0_Dshift(ot);\n\n    gen_op_add_reg_T0(s->aflag, R_ESI);\n\n    if (use_icount)\n\n        gen_io_end();\n\n}\n", "idx": 10333, "_split": "test", "_hash": "df9962f537982cc256efd3fa8db6bc26"}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "void test_fcmp(double a, double b)\n\n{\n\n    long eflags, fpus;\n\n\n\n    fpu_clear_exceptions();\n\n    asm(\"fcom %2\\n\"\n\n        \"fstsw %%ax\\n\"\n\n        : \"=a\" (fpus)\n\n        : \"t\" (a), \"u\" (b));\n\n    printf(\"fcom(%f %f)=%04lx \\n\",\n\n           a, b, fpus & (0x4500 | FPUS_EMASK));\n\n    fpu_clear_exceptions();\n\n    asm(\"fucom %2\\n\"\n\n        \"fstsw %%ax\\n\"\n\n        : \"=a\" (fpus)\n\n        : \"t\" (a), \"u\" (b));\n\n    printf(\"fucom(%f %f)=%04lx\\n\",\n\n           a, b, fpus & (0x4500 | FPUS_EMASK));\n\n    if (TEST_FCOMI) {\n\n        /* test f(u)comi instruction */\n\n        fpu_clear_exceptions();\n\n        asm(\"fcomi %3, %2\\n\"\n\n            \"fstsw %%ax\\n\"\n\n            \"pushf\\n\"\n\n            \"pop %0\\n\"\n\n            : \"=r\" (eflags), \"=a\" (fpus)\n\n            : \"t\" (a), \"u\" (b));\n\n        printf(\"fcomi(%f %f)=%04lx %02lx\\n\",\n\n               a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C));\n\n        fpu_clear_exceptions();\n\n        asm(\"fucomi %3, %2\\n\"\n\n            \"fstsw %%ax\\n\"\n\n            \"pushf\\n\"\n\n            \"pop %0\\n\"\n\n            : \"=r\" (eflags), \"=a\" (fpus)\n\n            : \"t\" (a), \"u\" (b));\n\n        printf(\"fucomi(%f %f)=%04lx %02lx\\n\",\n\n               a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C));\n\n    }\n\n    fpu_clear_exceptions();\n\n    asm volatile(\"fxam\\n\"\n\n                 \"fstsw %%ax\\n\"\n\n                 : \"=a\" (fpus)\n\n                 : \"t\" (a));\n\n    printf(\"fxam(%f)=%04lx\\n\", a, fpus & 0x4700);\n\n    fpu_clear_exceptions();\n\n}\n", "idx": 10338, "_split": "test", "_hash": "b7271d9fa71c2b99444ff26516077209"}
{"project": "qemu", "commit_id": "b0706b716769494f321a0d2bfd9fa9893992f995", "target": 1, "func": "void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,\n\n                             hwaddr paddr, MemTxAttrs attrs, int prot,\n\n                             int mmu_idx, target_ulong size)\n\n{\n\n    CPUArchState *env = cpu->env_ptr;\n\n    MemoryRegionSection *section;\n\n    unsigned int index;\n\n    target_ulong address;\n\n    target_ulong code_address;\n\n    uintptr_t addend;\n\n    CPUTLBEntry *te;\n\n    hwaddr iotlb, xlat, sz;\n\n    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;\n\n    int asidx = cpu_asidx_from_attrs(cpu, attrs);\n\n\n\n    assert_cpu_is_self(cpu);\n\n    assert(size >= TARGET_PAGE_SIZE);\n\n    if (size != TARGET_PAGE_SIZE) {\n\n        tlb_add_large_page(env, vaddr, size);\n\n    }\n\n\n\n    sz = size;\n\n    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);\n\n    assert(sz >= TARGET_PAGE_SIZE);\n\n\n\n    tlb_debug(\"vaddr=\" TARGET_FMT_lx \" paddr=0x\" TARGET_FMT_plx\n\n              \" prot=%x idx=%d\\n\",\n\n              vaddr, paddr, prot, mmu_idx);\n\n\n\n    address = vaddr;\n\n    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {\n\n        /* IO memory case */\n\n        address |= TLB_MMIO;\n\n        addend = 0;\n\n    } else {\n\n        /* TLB_MMIO for rom/romd handled below */\n\n        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;\n\n    }\n\n\n\n    code_address = address;\n\n    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,\n\n                                            prot, &address);\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    te = &env->tlb_table[mmu_idx][index];\n\n\n\n    /* do not discard the translation in te, evict it into a victim tlb */\n\n    env->tlb_v_table[mmu_idx][vidx] = *te;\n\n    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];\n\n\n\n    /* refill the tlb */\n\n    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;\n\n    env->iotlb[mmu_idx][index].attrs = attrs;\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((memory_region_is_ram(section->mr) && section->readonly)\n\n            || memory_region_is_romd(section->mr)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if (memory_region_is_ram(section->mr)\n\n                   && cpu_physical_memory_is_clean(\n\n                        memory_region_get_ram_addr(section->mr) + xlat)) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n", "idx": 10351, "_split": "test", "_hash": "e0beee8effb71776e2cc7253cb38d7fb"}
{"project": "qemu", "commit_id": "3a661f1eabf7e8db66e28489884d9b54aacb94ea", "target": 1, "func": "static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,\n\n                                       const uint8_t *key, size_t nkey,\n\n                                       Error **errp)\n\n{\n\n    QCryptoCipherBuiltin *ctxt;\n\n\n\n    if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {\n\n        error_setg(errp, \"Unsupported cipher mode %d\", cipher->mode);\n\n        return -1;\n\n    }\n\n\n\n    ctxt = g_new0(QCryptoCipherBuiltin, 1);\n\n\n\n    ctxt->state.desrfb.key = g_new0(uint8_t, nkey);\n\n    memcpy(ctxt->state.desrfb.key, key, nkey);\n\n    ctxt->state.desrfb.nkey = nkey;\n\n\n\n\n    ctxt->free = qcrypto_cipher_free_des_rfb;\n\n    ctxt->setiv = qcrypto_cipher_setiv_des_rfb;\n\n    ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb;\n\n    ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb;\n\n\n\n    cipher->opaque = ctxt;\n\n\n\n    return 0;\n\n}", "idx": 10355, "_split": "test", "_hash": "9596be79de4ecdc50a1c90440ee6da00"}
{"project": "qemu", "commit_id": "f57ba05823b7c444133f0862077b45824a6a89b5", "target": 0, "func": "static int virtio_ccw_handle_set_vq(SubchDev *sch, CCW1 ccw, bool check_len,\n\n                                    bool is_legacy)\n\n{\n\n    int ret;\n\n    VqInfoBlock info;\n\n    VqInfoBlockLegacy linfo;\n\n    size_t info_len = is_legacy ? sizeof(linfo) : sizeof(info);\n\n\n\n    if (check_len) {\n\n        if (ccw.count != info_len) {\n\n            return -EINVAL;\n\n        }\n\n    } else if (ccw.count < info_len) {\n\n        /* Can't execute command. */\n\n        return -EINVAL;\n\n    }\n\n    if (!ccw.cda) {\n\n        return -EFAULT;\n\n    }\n\n    if (is_legacy) {\n\n        linfo.queue = address_space_ldq_be(&address_space_memory, ccw.cda,\n\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n\n        linfo.align = address_space_ldl_be(&address_space_memory,\n\n                                           ccw.cda + sizeof(linfo.queue),\n\n                                           MEMTXATTRS_UNSPECIFIED,\n\n                                           NULL);\n\n        linfo.index = address_space_lduw_be(&address_space_memory,\n\n                                            ccw.cda + sizeof(linfo.queue)\n\n                                            + sizeof(linfo.align),\n\n                                            MEMTXATTRS_UNSPECIFIED,\n\n                                            NULL);\n\n        linfo.num = address_space_lduw_be(&address_space_memory,\n\n                                          ccw.cda + sizeof(linfo.queue)\n\n                                          + sizeof(linfo.align)\n\n                                          + sizeof(linfo.index),\n\n                                          MEMTXATTRS_UNSPECIFIED,\n\n                                          NULL);\n\n        ret = virtio_ccw_set_vqs(sch, NULL, &linfo);\n\n    } else {\n\n        info.desc = address_space_ldq_be(&address_space_memory, ccw.cda,\n\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.index = address_space_lduw_be(&address_space_memory,\n\n                                           ccw.cda + sizeof(info.desc)\n\n                                           + sizeof(info.res0),\n\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.num = address_space_lduw_be(&address_space_memory,\n\n                                         ccw.cda + sizeof(info.desc)\n\n                                         + sizeof(info.res0)\n\n                                         + sizeof(info.index),\n\n                                         MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.avail = address_space_ldq_be(&address_space_memory,\n\n                                          ccw.cda + sizeof(info.desc)\n\n                                          + sizeof(info.res0)\n\n                                          + sizeof(info.index)\n\n                                          + sizeof(info.num),\n\n                                          MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.used = address_space_ldq_be(&address_space_memory,\n\n                                         ccw.cda + sizeof(info.desc)\n\n                                         + sizeof(info.res0)\n\n                                         + sizeof(info.index)\n\n                                         + sizeof(info.num)\n\n                                         + sizeof(info.avail),\n\n                                         MEMTXATTRS_UNSPECIFIED, NULL);\n\n        ret = virtio_ccw_set_vqs(sch, &info, NULL);\n\n    }\n\n    sch->curr_status.scsw.count = 0;\n\n    return ret;\n\n}\n", "idx": 10364, "_split": "test", "_hash": "4a9bc5e0c778a0380dc16743234ab714"}
{"project": "qemu", "commit_id": "ddf21908961073199f3d186204da4810f2ea150b", "target": 0, "func": "static void vnc_client_cache_addr(VncState *client)\n\n{\n\n    Error *err = NULL;\n\n\n\n    client->info = g_malloc0(sizeof(*client->info));\n\n    client->info->base = g_malloc0(sizeof(*client->info->base));\n\n    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,\n\n                                         &err);\n\n    if (err) {\n\n        qapi_free_VncClientInfo(client->info);\n\n        client->info = NULL;\n\n        error_free(err);\n\n    }\n\n}\n", "idx": 10370, "_split": "test", "_hash": "2cf5d9d86b421930e3fc80fd6d778717"}
{"project": "qemu", "commit_id": "b131c74a0e485b084ddaffc8214c8a19af492be7", "target": 0, "func": "int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)\n\n{\n\n    return kvm_irqchip_assign_irqfd(s, fd, virq, true);\n\n}\n", "idx": 10374, "_split": "test", "_hash": "016011f967bb21b532fd175fd025909e"}
{"project": "qemu", "commit_id": "cdbf6e165988ab9d7c01da03b9e27bb8ac0c76aa", "target": 0, "func": "static gboolean udp_chr_read(GIOChannel *chan, GIOCondition cond, void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    NetCharDriver *s = chr->opaque;\n\n    gsize bytes_read = 0;\n\n    GIOStatus status;\n\n\n\n    if (s->max_size == 0)\n\n        return FALSE;\n\n    status = g_io_channel_read_chars(s->chan, (gchar *)s->buf, sizeof(s->buf),\n\n                                     &bytes_read, NULL);\n\n    s->bufcnt = bytes_read;\n\n    s->bufptr = s->bufcnt;\n\n    if (status != G_IO_STATUS_NORMAL) {\n\n        return FALSE;\n\n    }\n\n\n\n    s->bufptr = 0;\n\n    while (s->max_size > 0 && s->bufptr < s->bufcnt) {\n\n        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);\n\n        s->bufptr++;\n\n        s->max_size = qemu_chr_be_can_write(chr);\n\n    }\n\n\n\n    return TRUE;\n\n}\n", "idx": 10385, "_split": "test", "_hash": "111d732615b6a182a2f60bbb354bb5e6"}
{"project": "qemu", "commit_id": "a01d8cadadf4c0dad8fc5157ee56aea8ec323982", "target": 1, "func": "PCIBus *pci_prep_init(qemu_irq *pic)\n\n{\n\n    PREPPCIState *s;\n\n    PCIDevice *d;\n\n    int PPC_io_memory;\n\n\n\n    s = qemu_mallocz(sizeof(PREPPCIState));\n\n    s->bus = pci_register_bus(prep_set_irq, prep_map_irq, pic, 0, 2);\n\n\n\n    register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s);\n\n    register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s);\n\n\n\n    register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, s);\n\n    register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, s);\n\n    register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s);\n\n    register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s);\n\n    register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s);\n\n    register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s);\n\n\n\n    PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read,\n\n                                           PPC_PCIIO_write, s);\n\n    cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory);\n\n\n\n    /* PCI host bridge */\n\n    d = pci_register_device(s->bus, \"PREP Host Bridge - Motorola Raven\",\n\n                            sizeof(PCIDevice), 0, NULL, NULL);\n\n    d->config[0x00] = 0x57; // vendor_id : Motorola\n\n    d->config[0x01] = 0x10;\n\n    d->config[0x02] = 0x01; // device_id : Raven\n\n    d->config[0x03] = 0x48;\n\n    d->config[0x08] = 0x00; // revision\n\n    d->config[0x0A] = 0x00; // class_sub = pci host\n\n    d->config[0x0B] = 0x06; // class_base = PCI_bridge\n\n    d->config[0x0C] = 0x08; // cache_line_size\n\n    d->config[0x0D] = 0x10; // latency_timer\n\n    d->config[0x0E] = 0x00; // header_type\n\n    d->config[0x34] = 0x00; // capabilities_pointer\n\n\n\n    return s->bus;\n\n}\n", "idx": 10406, "_split": "test", "_hash": "0ea9e274c3d9d9e58d61f8de7fcdd60d"}
{"project": "qemu", "commit_id": "d02532f08e207419e412ea7cd4eb8b36f04f426d", "target": 1, "func": "int page_unprotect(target_ulong address, uintptr_t pc, void *puc)\n\n{\n\n    unsigned int prot;\n\n    PageDesc *p;\n\n    target_ulong host_start, host_end, addr;\n\n\n\n    /* Technically this isn't safe inside a signal handler.  However we\n\n       know this only ever happens in a synchronous SEGV handler, so in\n\n       practice it seems to be ok.  */\n\n    mmap_lock();\n\n\n\n    p = page_find(address >> TARGET_PAGE_BITS);\n\n    if (!p) {\n\n        mmap_unlock();\n\n        return 0;\n\n    }\n\n\n\n    /* if the page was really writable, then we change its\n\n       protection back to writable */\n\n    if ((p->flags & PAGE_WRITE_ORG) && !(p->flags & PAGE_WRITE)) {\n\n        host_start = address & qemu_host_page_mask;\n\n        host_end = host_start + qemu_host_page_size;\n\n\n\n        prot = 0;\n\n        for (addr = host_start ; addr < host_end ; addr += TARGET_PAGE_SIZE) {\n\n            p = page_find(addr >> TARGET_PAGE_BITS);\n\n            p->flags |= PAGE_WRITE;\n\n            prot |= p->flags;\n\n\n\n            /* and since the content will be modified, we must invalidate\n\n               the corresponding translated code. */\n\n            tb_invalidate_phys_page(addr, pc, puc);\n\n#ifdef DEBUG_TB_CHECK\n\n            tb_invalidate_check(addr);\n\n#endif\n\n        }\n\n        mprotect((void *)g2h(host_start), qemu_host_page_size,\n\n                 prot & PAGE_BITS);\n\n\n\n        mmap_unlock();\n\n        return 1;\n\n    }\n\n    mmap_unlock();\n\n    return 0;\n\n}\n", "idx": 10416, "_split": "test", "_hash": "732494be8826711567eaf91d4fe106a2"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val,\n\n                       unsigned int size, int mem_index)\n\n{\n\n    int l1 = gen_new_label();\n\n    TCGv taddr = tcg_temp_local_new();\n\n    TCGv tval = tcg_temp_local_new();\n\n    TCGv t1 = tcg_temp_local_new();\n\n    dc->postinc = 0;\n\n    cris_evaluate_flags(dc);\n\n\n\n    tcg_gen_mov_tl(taddr, addr);\n\n    tcg_gen_mov_tl(tval, val);\n\n\n\n    /* Store only if F flag isn't set */\n\n    tcg_gen_andi_tl(t1, cpu_PR[PR_CCS], F_FLAG_V10);\n\n    tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n    if (size == 1) {\n\n        tcg_gen_qemu_st8(tval, taddr, mem_index);\n\n    } else if (size == 2) {\n\n        tcg_gen_qemu_st16(tval, taddr, mem_index);\n\n    } else {\n\n        tcg_gen_qemu_st32(tval, taddr, mem_index);\n\n    }\n\n    gen_set_label(l1);\n\n    tcg_gen_shri_tl(t1, t1, 1);  /* shift F to P position */\n\n    tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], t1); /*P=F*/\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(tval);\n\n    tcg_temp_free(taddr);\n\n}\n", "idx": 10478, "_split": "test", "_hash": "a67d9b9a008da74501ccb4ee491a5185"}
{"project": "qemu", "commit_id": "947858b0ba97f4ec097de667e45eff99212867c3", "target": 0, "func": "static void ide_trim_bh_cb(void *opaque)\n\n{\n\n    TrimAIOCB *iocb = opaque;\n\n\n\n    iocb->common.cb(iocb->common.opaque, iocb->ret);\n\n\n\n    qemu_bh_delete(iocb->bh);\n\n    iocb->bh = NULL;\n\n    qemu_aio_unref(iocb);\n\n}\n", "idx": 10480, "_split": "test", "_hash": "edfb0286b5a682b19bfdc58f722496ac"}
{"project": "qemu", "commit_id": "ad11ad77748bdd8016370db210751683dc038dd6", "target": 0, "func": "static abi_long do_ioctl_dm(const IOCTLEntry *ie, uint8_t *buf_temp, int fd,\n\n                            abi_long cmd, abi_long arg)\n\n{\n\n    void *argptr;\n\n    struct dm_ioctl *host_dm;\n\n    abi_long guest_data;\n\n    uint32_t guest_data_size;\n\n    int target_size;\n\n    const argtype *arg_type = ie->arg_type;\n\n    abi_long ret;\n\n    void *big_buf = NULL;\n\n    char *host_data;\n\n\n\n    arg_type++;\n\n    target_size = thunk_type_size(arg_type, 0);\n\n    argptr = lock_user(VERIFY_READ, arg, target_size, 1);\n\n    if (!argptr) {\n\n        ret = -TARGET_EFAULT;\n\n        goto out;\n\n    }\n\n    thunk_convert(buf_temp, argptr, arg_type, THUNK_HOST);\n\n    unlock_user(argptr, arg, 0);\n\n\n\n    /* buf_temp is too small, so fetch things into a bigger buffer */\n\n    big_buf = g_malloc0(((struct dm_ioctl*)buf_temp)->data_size * 2);\n\n    memcpy(big_buf, buf_temp, target_size);\n\n    buf_temp = big_buf;\n\n    host_dm = big_buf;\n\n\n\n    guest_data = arg + host_dm->data_start;\n\n    if ((guest_data - arg) < 0) {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n    guest_data_size = host_dm->data_size - host_dm->data_start;\n\n    host_data = (char*)host_dm + host_dm->data_start;\n\n\n\n    argptr = lock_user(VERIFY_READ, guest_data, guest_data_size, 1);\n\n    switch (ie->host_cmd) {\n\n    case DM_REMOVE_ALL:\n\n    case DM_LIST_DEVICES:\n\n    case DM_DEV_CREATE:\n\n    case DM_DEV_REMOVE:\n\n    case DM_DEV_SUSPEND:\n\n    case DM_DEV_STATUS:\n\n    case DM_DEV_WAIT:\n\n    case DM_TABLE_STATUS:\n\n    case DM_TABLE_CLEAR:\n\n    case DM_TABLE_DEPS:\n\n    case DM_LIST_VERSIONS:\n\n        /* no input data */\n\n        break;\n\n    case DM_DEV_RENAME:\n\n    case DM_DEV_SET_GEOMETRY:\n\n        /* data contains only strings */\n\n        memcpy(host_data, argptr, guest_data_size);\n\n        break;\n\n    case DM_TARGET_MSG:\n\n        memcpy(host_data, argptr, guest_data_size);\n\n        *(uint64_t*)host_data = tswap64(*(uint64_t*)argptr);\n\n        break;\n\n    case DM_TABLE_LOAD:\n\n    {\n\n        void *gspec = argptr;\n\n        void *cur_data = host_data;\n\n        const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) };\n\n        int spec_size = thunk_type_size(arg_type, 0);\n\n        int i;\n\n\n\n        for (i = 0; i < host_dm->target_count; i++) {\n\n            struct dm_target_spec *spec = cur_data;\n\n            uint32_t next;\n\n            int slen;\n\n\n\n            thunk_convert(spec, gspec, arg_type, THUNK_HOST);\n\n            slen = strlen((char*)gspec + spec_size) + 1;\n\n            next = spec->next;\n\n            spec->next = sizeof(*spec) + slen;\n\n            strcpy((char*)&spec[1], gspec + spec_size);\n\n            gspec += next;\n\n            cur_data += spec->next;\n\n        }\n\n        break;\n\n    }\n\n    default:\n\n        ret = -TARGET_EINVAL;\n\n        goto out;\n\n    }\n\n    unlock_user(argptr, guest_data, 0);\n\n\n\n    ret = get_errno(ioctl(fd, ie->host_cmd, buf_temp));\n\n    if (!is_error(ret)) {\n\n        guest_data = arg + host_dm->data_start;\n\n        guest_data_size = host_dm->data_size - host_dm->data_start;\n\n        argptr = lock_user(VERIFY_WRITE, guest_data, guest_data_size, 0);\n\n        switch (ie->host_cmd) {\n\n        case DM_REMOVE_ALL:\n\n        case DM_DEV_CREATE:\n\n        case DM_DEV_REMOVE:\n\n        case DM_DEV_RENAME:\n\n        case DM_DEV_SUSPEND:\n\n        case DM_DEV_STATUS:\n\n        case DM_TABLE_LOAD:\n\n        case DM_TABLE_CLEAR:\n\n        case DM_TARGET_MSG:\n\n        case DM_DEV_SET_GEOMETRY:\n\n            /* no return data */\n\n            break;\n\n        case DM_LIST_DEVICES:\n\n        {\n\n            struct dm_name_list *nl = (void*)host_dm + host_dm->data_start;\n\n            uint32_t remaining_data = guest_data_size;\n\n            void *cur_data = argptr;\n\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_name_list) };\n\n            int nl_size = 12; /* can't use thunk_size due to alignment */\n\n\n\n            while (1) {\n\n                uint32_t next = nl->next;\n\n                if (next) {\n\n                    nl->next = nl_size + (strlen(nl->name) + 1);\n\n                }\n\n                if (remaining_data < nl->next) {\n\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n\n                    break;\n\n                }\n\n                thunk_convert(cur_data, nl, arg_type, THUNK_TARGET);\n\n                strcpy(cur_data + nl_size, nl->name);\n\n                cur_data += nl->next;\n\n                remaining_data -= nl->next;\n\n                if (!next) {\n\n                    break;\n\n                }\n\n                nl = (void*)nl + next;\n\n            }\n\n            break;\n\n        }\n\n        case DM_DEV_WAIT:\n\n        case DM_TABLE_STATUS:\n\n        {\n\n            struct dm_target_spec *spec = (void*)host_dm + host_dm->data_start;\n\n            void *cur_data = argptr;\n\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) };\n\n            int spec_size = thunk_type_size(arg_type, 0);\n\n            int i;\n\n\n\n            for (i = 0; i < host_dm->target_count; i++) {\n\n                uint32_t next = spec->next;\n\n                int slen = strlen((char*)&spec[1]) + 1;\n\n                spec->next = (cur_data - argptr) + spec_size + slen;\n\n                if (guest_data_size < spec->next) {\n\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n\n                    break;\n\n                }\n\n                thunk_convert(cur_data, spec, arg_type, THUNK_TARGET);\n\n                strcpy(cur_data + spec_size, (char*)&spec[1]);\n\n                cur_data = argptr + spec->next;\n\n                spec = (void*)host_dm + host_dm->data_start + next;\n\n            }\n\n            break;\n\n        }\n\n        case DM_TABLE_DEPS:\n\n        {\n\n            void *hdata = (void*)host_dm + host_dm->data_start;\n\n            int count = *(uint32_t*)hdata;\n\n            uint64_t *hdev = hdata + 8;\n\n            uint64_t *gdev = argptr + 8;\n\n            int i;\n\n\n\n            *(uint32_t*)argptr = tswap32(count);\n\n            for (i = 0; i < count; i++) {\n\n                *gdev = tswap64(*hdev);\n\n                gdev++;\n\n                hdev++;\n\n            }\n\n            break;\n\n        }\n\n        case DM_LIST_VERSIONS:\n\n        {\n\n            struct dm_target_versions *vers = (void*)host_dm + host_dm->data_start;\n\n            uint32_t remaining_data = guest_data_size;\n\n            void *cur_data = argptr;\n\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_versions) };\n\n            int vers_size = thunk_type_size(arg_type, 0);\n\n\n\n            while (1) {\n\n                uint32_t next = vers->next;\n\n                if (next) {\n\n                    vers->next = vers_size + (strlen(vers->name) + 1);\n\n                }\n\n                if (remaining_data < vers->next) {\n\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n\n                    break;\n\n                }\n\n                thunk_convert(cur_data, vers, arg_type, THUNK_TARGET);\n\n                strcpy(cur_data + vers_size, vers->name);\n\n                cur_data += vers->next;\n\n                remaining_data -= vers->next;\n\n                if (!next) {\n\n                    break;\n\n                }\n\n                vers = (void*)vers + next;\n\n            }\n\n            break;\n\n        }\n\n        default:\n\n            ret = -TARGET_EINVAL;\n\n            goto out;\n\n        }\n\n        unlock_user(argptr, guest_data, guest_data_size);\n\n\n\n        argptr = lock_user(VERIFY_WRITE, arg, target_size, 0);\n\n        if (!argptr) {\n\n            ret = -TARGET_EFAULT;\n\n            goto out;\n\n        }\n\n        thunk_convert(argptr, buf_temp, arg_type, THUNK_TARGET);\n\n        unlock_user(argptr, arg, target_size);\n\n    }\n\nout:\n\n    if (big_buf) {\n\n        free(big_buf);\n\n    }\n\n    return ret;\n\n}\n", "idx": 10485, "_split": "test", "_hash": "d244b8d15e48deeb88f46ea6d1090574"}
{"project": "qemu", "commit_id": "240ce26a0533a6e5ee472789fbfbd9f7f939197e", "target": 1, "func": "static int decode_micromips_opc (CPUMIPSState *env, DisasContext *ctx, int *is_branch)\n\n{\n\n    uint32_t op;\n\n\n\n    /* make sure instructions are on a halfword boundary */\n\n    if (ctx->pc & 0x1) {\n\n        env->CP0_BadVAddr = ctx->pc;\n\n        generate_exception(ctx, EXCP_AdEL);\n\n        ctx->bstate = BS_STOP;\n\n        return 2;\n\n    }\n\n\n\n    op = (ctx->opcode >> 10) & 0x3f;\n\n    /* Enforce properly-sized instructions in a delay slot */\n\n    if (ctx->hflags & MIPS_HFLAG_BMASK) {\n\n        int bits = ctx->hflags & MIPS_HFLAG_BMASK_EXT;\n\n\n\n        switch (op) {\n\n        case POOL32A:\n\n        case POOL32B:\n\n        case POOL32I:\n\n        case POOL32C:\n\n        case ADDI32:\n\n        case ADDIU32:\n\n        case ORI32:\n\n        case XORI32:\n\n        case SLTI32:\n\n        case SLTIU32:\n\n        case ANDI32:\n\n        case JALX32:\n\n        case LBU32:\n\n        case LHU32:\n\n        case POOL32F:\n\n        case JALS32:\n\n        case BEQ32:\n\n        case BNE32:\n\n        case J32:\n\n        case JAL32:\n\n        case SB32:\n\n        case SH32:\n\n        case POOL32S:\n\n        case ADDIUPC:\n\n        case SWC132:\n\n        case SDC132:\n\n        case SD32:\n\n        case SW32:\n\n        case LB32:\n\n        case LH32:\n\n        case DADDIU32:\n\n        case LWC132:\n\n        case LDC132:\n\n        case LD32:\n\n        case LW32:\n\n            if (bits & MIPS_HFLAG_BDS16) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                /* Just stop translation; the user is confused.  */\n\n                ctx->bstate = BS_STOP;\n\n                return 2;\n\n            }\n\n            break;\n\n        case POOL16A:\n\n        case POOL16B:\n\n        case POOL16C:\n\n        case LWGP16:\n\n        case POOL16F:\n\n        case LBU16:\n\n        case LHU16:\n\n        case LWSP16:\n\n        case LW16:\n\n        case SB16:\n\n        case SH16:\n\n        case SWSP16:\n\n        case SW16:\n\n        case MOVE16:\n\n        case ANDI16:\n\n        case POOL16D:\n\n        case POOL16E:\n\n        case BEQZ16:\n\n        case BNEZ16:\n\n        case B16:\n\n        case LI16:\n\n            if (bits & MIPS_HFLAG_BDS32) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                /* Just stop translation; the user is confused.  */\n\n                ctx->bstate = BS_STOP;\n\n                return 2;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    switch (op) {\n\n    case POOL16A:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rs1 = mmreg(uMIPS_RS1(ctx->opcode));\n\n            int rs2 = mmreg(uMIPS_RS2(ctx->opcode));\n\n            uint32_t opc = 0;\n\n\n\n            switch (ctx->opcode & 0x1) {\n\n            case ADDU16:\n\n                opc = OPC_ADDU;\n\n                break;\n\n            case SUBU16:\n\n                opc = OPC_SUBU;\n\n                break;\n\n            }\n\n\n\n            gen_arith(ctx, opc, rd, rs1, rs2);\n\n        }\n\n        break;\n\n    case POOL16B:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rs = mmreg(uMIPS_RS(ctx->opcode));\n\n            int amount = (ctx->opcode >> 1) & 0x7;\n\n            uint32_t opc = 0;\n\n            amount = amount == 0 ? 8 : amount;\n\n\n\n            switch (ctx->opcode & 0x1) {\n\n            case SLL16:\n\n                opc = OPC_SLL;\n\n                break;\n\n            case SRL16:\n\n                opc = OPC_SRL;\n\n                break;\n\n            }\n\n\n\n            gen_shift_imm(ctx, opc, rd, rs, amount);\n\n        }\n\n        break;\n\n    case POOL16C:\n\n        gen_pool16c_insn(ctx, is_branch);\n\n        break;\n\n    case LWGP16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = 28;            /* GP */\n\n            int16_t offset = SIMM(ctx->opcode, 0, 7) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case POOL16F:\n\n        if (ctx->opcode & 1) {\n\n            generate_exception(ctx, EXCP_RI);\n\n        } else {\n\n            /* MOVEP */\n\n            int enc_dest = uMIPS_RD(ctx->opcode);\n\n            int enc_rt = uMIPS_RS2(ctx->opcode);\n\n            int enc_rs = uMIPS_RS1(ctx->opcode);\n\n            int rd, rs, re, rt;\n\n            static const int rd_enc[] = { 5, 5, 6, 4, 4, 4, 4, 4 };\n\n            static const int re_enc[] = { 6, 7, 7, 21, 22, 5, 6, 7 };\n\n            static const int rs_rt_enc[] = { 0, 17, 2, 3, 16, 18, 19, 20 };\n\n\n\n            rd = rd_enc[enc_dest];\n\n            re = re_enc[enc_dest];\n\n            rs = rs_rt_enc[enc_rs];\n\n            rt = rs_rt_enc[enc_rt];\n\n\n\n            gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0);\n\n            gen_arith_imm(ctx, OPC_ADDIU, re, rt, 0);\n\n        }\n\n        break;\n\n    case LBU16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4);\n\n            offset = (offset == 0xf ? -1 : offset);\n\n\n\n            gen_ld(ctx, OPC_LBU, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LHU16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1;\n\n\n\n            gen_ld(ctx, OPC_LHU, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LWSP16:\n\n        {\n\n            int rd = (ctx->opcode >> 5) & 0x1f;\n\n            int rb = 29;            /* SP */\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LW16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SB16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4);\n\n\n\n            gen_st(ctx, OPC_SB, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SH16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1;\n\n\n\n            gen_st(ctx, OPC_SH, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SWSP16:\n\n        {\n\n            int rd = (ctx->opcode >> 5) & 0x1f;\n\n            int rb = 29;            /* SP */\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2;\n\n\n\n            gen_st(ctx, OPC_SW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SW16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2;\n\n\n\n            gen_st(ctx, OPC_SW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case MOVE16:\n\n        {\n\n            int rd = uMIPS_RD5(ctx->opcode);\n\n            int rs = uMIPS_RS5(ctx->opcode);\n\n\n\n            gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0);\n\n        }\n\n        break;\n\n    case ANDI16:\n\n        gen_andi16(ctx);\n\n        break;\n\n    case POOL16D:\n\n        switch (ctx->opcode & 0x1) {\n\n        case ADDIUS5:\n\n            gen_addius5(ctx);\n\n            break;\n\n        case ADDIUSP:\n\n            gen_addiusp(ctx);\n\n            break;\n\n        }\n\n        break;\n\n    case POOL16E:\n\n        switch (ctx->opcode & 0x1) {\n\n        case ADDIUR2:\n\n            gen_addiur2(ctx);\n\n            break;\n\n        case ADDIUR1SP:\n\n            gen_addiur1sp(ctx);\n\n            break;\n\n        }\n\n        break;\n\n    case B16:\n\n        gen_compute_branch(ctx, OPC_BEQ, 2, 0, 0,\n\n                           SIMM(ctx->opcode, 0, 10) << 1);\n\n        *is_branch = 1;\n\n        break;\n\n    case BNEZ16:\n\n    case BEQZ16:\n\n        gen_compute_branch(ctx, op == BNEZ16 ? OPC_BNE : OPC_BEQ, 2,\n\n                           mmreg(uMIPS_RD(ctx->opcode)),\n\n                           0, SIMM(ctx->opcode, 0, 7) << 1);\n\n        *is_branch = 1;\n\n        break;\n\n    case LI16:\n\n        {\n\n            int reg = mmreg(uMIPS_RD(ctx->opcode));\n\n            int imm = ZIMM(ctx->opcode, 0, 7);\n\n\n\n            imm = (imm == 0x7f ? -1 : imm);\n\n            tcg_gen_movi_tl(cpu_gpr[reg], imm);\n\n        }\n\n        break;\n\n    case RES_20:\n\n    case RES_28:\n\n    case RES_29:\n\n    case RES_30:\n\n    case RES_31:\n\n    case RES_38:\n\n    case RES_39:\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    default:\n\n        decode_micromips32_opc (env, ctx, op, is_branch);\n\n        return 4;\n\n    }\n\n\n\n    return 2;\n\n}\n", "idx": 10504, "_split": "test", "_hash": "f2cd2189001aedd8a0fa7a753ee18f57"}
{"project": "qemu", "commit_id": "2119882c7eb7e2c612b24fc0c8d86f5887d6f1c3", "target": 0, "func": "static BdrvDirtyBitmap *block_dirty_bitmap_lookup(const char *node,\n\n                                                  const char *name,\n\n                                                  BlockDriverState **pbs,\n\n                                                  AioContext **paio,\n\n                                                  Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BdrvDirtyBitmap *bitmap;\n\n    AioContext *aio_context;\n\n\n\n    if (!node) {\n\n        error_setg(errp, \"Node cannot be NULL\");\n\n        return NULL;\n\n    }\n\n    if (!name) {\n\n        error_setg(errp, \"Bitmap name cannot be NULL\");\n\n        return NULL;\n\n    }\n\n    bs = bdrv_lookup_bs(node, node, NULL);\n\n    if (!bs) {\n\n        error_setg(errp, \"Node '%s' not found\", node);\n\n        return NULL;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    bitmap = bdrv_find_dirty_bitmap(bs, name);\n\n    if (!bitmap) {\n\n        error_setg(errp, \"Dirty bitmap '%s' not found\", name);\n\n        goto fail;\n\n    }\n\n\n\n    if (pbs) {\n\n        *pbs = bs;\n\n    }\n\n    if (paio) {\n\n        *paio = aio_context;\n\n    } else {\n\n        aio_context_release(aio_context);\n\n    }\n\n\n\n    return bitmap;\n\n\n\n fail:\n\n    aio_context_release(aio_context);\n\n    return NULL;\n\n}\n", "idx": 10583, "_split": "test", "_hash": "bd305f7567911e4cee129f9358240600"}
{"project": "qemu", "commit_id": "446f16a6906e9d05aa9ce0dde727d4f731a89298", "target": 1, "func": "void ppce500_init(MachineState *machine, PPCE500Params *params)\n\n{\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    PCIBus *pci_bus;\n\n    CPUPPCState *env = NULL;\n\n    uint64_t loadaddr;\n\n    hwaddr kernel_base = -1LL;\n\n    int kernel_size = 0;\n\n    hwaddr dt_base = 0;\n\n    hwaddr initrd_base = 0;\n\n    int initrd_size = 0;\n\n    hwaddr cur_base = 0;\n\n    char *filename;\n\n    hwaddr bios_entry = 0;\n\n    target_long bios_size;\n\n    struct boot_info *boot_info;\n\n    int dt_size;\n\n    int i;\n\n    /* irq num for pin INTA, INTB, INTC and INTD is 1, 2, 3 and\n\n     * 4 respectively */\n\n    unsigned int pci_irq_nrs[PCI_NUM_PINS] = {1, 2, 3, 4};\n\n    qemu_irq **irqs, *mpic;\n\n    DeviceState *dev;\n\n    CPUPPCState *firstenv = NULL;\n\n    MemoryRegion *ccsr_addr_space;\n\n    SysBusDevice *s;\n\n    PPCE500CCSRState *ccsr;\n\n\n\n    /* Setup CPUs */\n\n    if (machine->cpu_model == NULL) {\n\n        machine->cpu_model = \"e500v2_v30\";\n\n    }\n\n\n\n    irqs = g_malloc0(smp_cpus * sizeof(qemu_irq *));\n\n    irqs[0] = g_malloc0(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        PowerPCCPU *cpu;\n\n        CPUState *cs;\n\n        qemu_irq *input;\n\n\n\n        cpu = cpu_ppc_init(machine->cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n        cs = CPU(cpu);\n\n\n\n        if (!firstenv) {\n\n            firstenv = env;\n\n        }\n\n\n\n        irqs[i] = irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n        input = (qemu_irq *)env->irq_inputs;\n\n        irqs[i][OPENPIC_OUTPUT_INT] = input[PPCE500_INPUT_INT];\n\n        irqs[i][OPENPIC_OUTPUT_CINT] = input[PPCE500_INPUT_CINT];\n\n        env->spr_cb[SPR_BOOKE_PIR].default_value = cs->cpu_index = i;\n\n        env->mpic_iack = params->ccsrbar_base +\n\n                         MPC8544_MPIC_REGS_OFFSET + 0xa0;\n\n\n\n        ppc_booke_timers_init(cpu, 400000000, PPC_TIMER_E500);\n\n\n\n        /* Register reset handler */\n\n        if (!i) {\n\n            /* Primary CPU */\n\n            struct boot_info *boot_info;\n\n            boot_info = g_malloc0(sizeof(struct boot_info));\n\n            qemu_register_reset(ppce500_cpu_reset, cpu);\n\n            env->load_info = boot_info;\n\n        } else {\n\n            /* Secondary CPUs */\n\n            qemu_register_reset(ppce500_cpu_reset_sec, cpu);\n\n        }\n\n    }\n\n\n\n    env = firstenv;\n\n\n\n    /* Fixup Memory size on a alignment boundary */\n\n    ram_size &= ~(RAM_SIZES_ALIGN - 1);\n\n    machine->ram_size = ram_size;\n\n\n\n    /* Register Memory */\n\n    memory_region_allocate_system_memory(ram, NULL, \"mpc8544ds.ram\", ram_size);\n\n    memory_region_add_subregion(address_space_mem, 0, ram);\n\n\n\n    dev = qdev_create(NULL, \"e500-ccsr\");\n\n    object_property_add_child(qdev_get_machine(), \"e500-ccsr\",\n\n                              OBJECT(dev), NULL);\n\n    qdev_init_nofail(dev);\n\n    ccsr = CCSR(dev);\n\n    ccsr_addr_space = &ccsr->ccsr_space;\n\n    memory_region_add_subregion(address_space_mem, params->ccsrbar_base,\n\n                                ccsr_addr_space);\n\n\n\n    mpic = ppce500_init_mpic(params, ccsr_addr_space, irqs);\n\n\n\n    /* Serial */\n\n    if (serial_hds[0]) {\n\n        serial_mm_init(ccsr_addr_space, MPC8544_SERIAL0_REGS_OFFSET,\n\n                       0, mpic[42], 399193,\n\n                       serial_hds[0], DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    if (serial_hds[1]) {\n\n        serial_mm_init(ccsr_addr_space, MPC8544_SERIAL1_REGS_OFFSET,\n\n                       0, mpic[42], 399193,\n\n                       serial_hds[1], DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    /* General Utility device */\n\n    dev = qdev_create(NULL, \"mpc8544-guts\");\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n    memory_region_add_subregion(ccsr_addr_space, MPC8544_UTIL_OFFSET,\n\n                                sysbus_mmio_get_region(s, 0));\n\n\n\n    /* PCI */\n\n    dev = qdev_create(NULL, \"e500-pcihost\");\n\n    qdev_prop_set_uint32(dev, \"first_slot\", params->pci_first_slot);\n\n    qdev_prop_set_uint32(dev, \"first_pin_irq\", pci_irq_nrs[0]);\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n    for (i = 0; i < PCI_NUM_PINS; i++) {\n\n        sysbus_connect_irq(s, i, mpic[pci_irq_nrs[i]]);\n\n    }\n\n\n\n    memory_region_add_subregion(ccsr_addr_space, MPC8544_PCI_REGS_OFFSET,\n\n                                sysbus_mmio_get_region(s, 0));\n\n\n\n    pci_bus = (PCIBus *)qdev_get_child_bus(dev, \"pci.0\");\n\n    if (!pci_bus)\n\n        printf(\"couldn't create PCI controller!\\n\");\n\n\n\n    if (pci_bus) {\n\n        /* Register network interfaces. */\n\n        for (i = 0; i < nb_nics; i++) {\n\n            pci_nic_init_nofail(&nd_table[i], pci_bus, \"virtio\", NULL);\n\n        }\n\n    }\n\n\n\n    /* Register spinning region */\n\n    sysbus_create_simple(\"e500-spin\", params->spin_base, NULL);\n\n\n\n    if (cur_base < (32 * 1024 * 1024)) {\n\n        /* u-boot occupies memory up to 32MB, so load blobs above */\n\n        cur_base = (32 * 1024 * 1024);\n\n    }\n\n\n\n    if (params->has_mpc8xxx_gpio) {\n\n        qemu_irq poweroff_irq;\n\n\n\n        dev = qdev_create(NULL, \"mpc8xxx_gpio\");\n\n        s = SYS_BUS_DEVICE(dev);\n\n        qdev_init_nofail(dev);\n\n        sysbus_connect_irq(s, 0, mpic[MPC8XXX_GPIO_IRQ]);\n\n        memory_region_add_subregion(ccsr_addr_space, MPC8XXX_GPIO_OFFSET,\n\n                                    sysbus_mmio_get_region(s, 0));\n\n\n\n        /* Power Off GPIO at Pin 0 */\n\n        poweroff_irq = qemu_allocate_irq(ppce500_power_off, NULL, 0);\n\n        qdev_connect_gpio_out(dev, 0, poweroff_irq);\n\n    }\n\n\n\n    /* Platform Bus Device */\n\n    if (params->has_platform_bus) {\n\n        dev = qdev_create(NULL, TYPE_PLATFORM_BUS_DEVICE);\n\n        dev->id = TYPE_PLATFORM_BUS_DEVICE;\n\n        qdev_prop_set_uint32(dev, \"num_irqs\", params->platform_bus_num_irqs);\n\n        qdev_prop_set_uint32(dev, \"mmio_size\", params->platform_bus_size);\n\n        qdev_init_nofail(dev);\n\n        s = SYS_BUS_DEVICE(dev);\n\n\n\n        for (i = 0; i < params->platform_bus_num_irqs; i++) {\n\n            int irqn = params->platform_bus_first_irq + i;\n\n            sysbus_connect_irq(s, i, mpic[irqn]);\n\n        }\n\n\n\n        memory_region_add_subregion(address_space_mem,\n\n                                    params->platform_bus_base,\n\n                                    sysbus_mmio_get_region(s, 0));\n\n    }\n\n\n\n    /* Load kernel. */\n\n    if (machine->kernel_filename) {\n\n        kernel_base = cur_base;\n\n        kernel_size = load_image_targphys(machine->kernel_filename,\n\n                                          cur_base,\n\n                                          ram_size - cur_base);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    machine->kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        cur_base += kernel_size;\n\n    }\n\n\n\n    /* Load initrd. */\n\n    if (machine->initrd_filename) {\n\n        initrd_base = (cur_base + INITRD_LOAD_PAD) & ~INITRD_PAD_MASK;\n\n        initrd_size = load_image_targphys(machine->initrd_filename, initrd_base,\n\n                                          ram_size - initrd_base);\n\n\n\n        if (initrd_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    machine->initrd_filename);\n\n            exit(1);\n\n        }\n\n\n\n        cur_base = initrd_base + initrd_size;\n\n    }\n\n\n\n    /*\n\n     * Smart firmware defaults ahead!\n\n     *\n\n     * We follow the following table to select which payload we execute.\n\n     *\n\n     *  -kernel | -bios | payload\n\n     * ---------+-------+---------\n\n     *     N    |   Y   | u-boot\n\n     *     N    |   N   | u-boot\n\n     *     Y    |   Y   | u-boot\n\n     *     Y    |   N   | kernel\n\n     *\n\n     * This ensures backwards compatibility with how we used to expose\n\n     * -kernel to users but allows them to run through u-boot as well.\n\n     */\n\n    if (bios_name == NULL) {\n\n        if (machine->kernel_filename) {\n\n            bios_name = machine->kernel_filename;\n\n        } else {\n\n            bios_name = \"u-boot.e500\";\n\n        }\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n\n\n    bios_size = load_elf(filename, NULL, NULL, &bios_entry, &loadaddr, NULL,\n\n                         1, ELF_MACHINE, 0);\n\n    if (bios_size < 0) {\n\n        /*\n\n         * Hrm. No ELF image? Try a uImage, maybe someone is giving us an\n\n         * ePAPR compliant kernel\n\n         */\n\n        kernel_size = load_uimage(filename, &bios_entry, &loadaddr, NULL,\n\n                                  NULL, NULL);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load firmware '%s'\\n\", filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Reserve space for dtb */\n\n    dt_base = (loadaddr + bios_size + DTC_LOAD_PAD) & ~DTC_PAD_MASK;\n\n\n\n    dt_size = ppce500_prep_device_tree(machine, params, dt_base,\n\n                                       initrd_base, initrd_size,\n\n                                       kernel_base, kernel_size);\n\n    if (dt_size < 0) {\n\n        fprintf(stderr, \"couldn't load device tree\\n\");\n\n        exit(1);\n\n    }\n\n    assert(dt_size < DTB_MAX_SIZE);\n\n\n\n    boot_info = env->load_info;\n\n    boot_info->entry = bios_entry;\n\n    boot_info->dt_base = dt_base;\n\n    boot_info->dt_size = dt_size;\n\n\n\n    if (kvm_enabled()) {\n\n        kvmppc_init();\n\n    }\n\n}\n", "idx": 10594, "_split": "test", "_hash": "d431a6786b9629b4f9bdc788b25bb1d6"}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int cris_addc_pi_m(int a, int **b)\n\n{\n\n\tasm volatile (\"addc [%1+], %0\\n\" : \"+r\" (a), \"+b\" (*b));\n\n\treturn a;\n\n}\n", "idx": 10640, "_split": "test", "_hash": "bf06b6367eb4a48def09a54a0ca84cfe"}
{"project": "qemu", "commit_id": "4871b51b9241b10f4fd8e04bbb21577886795e25", "target": 1, "func": "static void vmgenid_query_monitor_test(void)\n\n{\n\n    QemuUUID expected, measured;\n\n    gchar *cmd;\n\n\n\n    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);\n\n\n\n    cmd = g_strdup_printf(\"-machine accel=tcg -device vmgenid,id=testvgid,\"\n\n                          \"guid=%s\", VGID_GUID);\n\n    qtest_start(cmd);\n\n\n\n    /* Read the GUID via the monitor */\n\n    read_guid_from_monitor(&measured);\n\n    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);\n\n\n\n    qtest_quit(global_qtest);\n\n    g_free(cmd);\n\n}\n", "idx": 10648, "_split": "test", "_hash": "7d947bcd2a95ea47540aba8a79c1250a"}
{"project": "qemu", "commit_id": "3558f8055f37a34762b7a2a0f02687e6eeab893d", "target": 0, "func": "static inline void gen_op_movl_seg_T0_vm(int seg_reg)\n\n{\n\n    tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);\n\n    tcg_gen_st32_tl(cpu_T[0], cpu_env, \n\n                    offsetof(CPUX86State,segs[seg_reg].selector));\n\n    tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4);\n\n    tcg_gen_st_tl(cpu_T[0], cpu_env, \n\n                  offsetof(CPUX86State,segs[seg_reg].base));\n\n}\n", "idx": 10721, "_split": "test", "_hash": "a58818aeddbea25b56237a61110de208"}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d,\n\n                                        QGuestAllocator *alloc, uint16_t entry)\n\n{\n\n    uint16_t vector;\n\n    uint32_t control;\n\n    void *addr;\n\n\n\n    g_assert(d->pdev->msix_enabled);\n\n    addr = d->pdev->msix_table + (entry * 16);\n\n\n\n    g_assert_cmpint(entry, >=, 0);\n\n    g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev));\n\n    d->config_msix_entry = entry;\n\n\n\n    d->config_msix_data = 0x12345678;\n\n    d->config_msix_addr = guest_alloc(alloc, 4);\n\n\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_LOWER_ADDR,\n\n                                                    d->config_msix_addr & ~0UL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_UPPER_ADDR,\n\n                                            (d->config_msix_addr >> 32) & ~0UL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);\n\n\n\n    control = qpci_io_readl(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL,\n\n                                        control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT);\n\n\n\n    qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry);\n\n    vector = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR);\n\n    g_assert_cmphex(vector, !=, VIRTIO_MSI_NO_VECTOR);\n\n}\n", "idx": 10727, "_split": "test", "_hash": "aff22fe0d90b1a9f2245980137d3a331"}
{"project": "qemu", "commit_id": "d279279e2b5cd40dbcc863fb66a695990f304077", "target": 1, "func": "static void gen_rdhwr(DisasContext *ctx, int rt, int rd)\n\n{\n\n    TCGv t0;\n\n\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* The Linux kernel will emulate rdhwr if it's not supported natively.\n\n       Therefore only check the ISA in system mode.  */\n\n    check_insn(ctx, ISA_MIPS32R2);\n\n#endif\n\n    t0 = tcg_temp_new();\n\n\n\n    switch (rd) {\n\n    case 0:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_cpunum(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 1:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_synci_step(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 2:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_cc(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 3:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_ccres(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 29:\n\n#if defined(CONFIG_USER_ONLY)\n\n        tcg_gen_ld_tl(t0, cpu_env, offsetof(CPUMIPSState, tls_value));\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n#else\n\n        /* XXX: Some CPUs implement this in hardware.\n\n           Not supported yet. */\n\n#endif\n\n    default:            /* Invalid */\n\n        MIPS_INVAL(\"rdhwr\");\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n    tcg_temp_free(t0);\n\n}\n", "idx": 10730, "_split": "test", "_hash": "8665cbc9d62654b2d459f3e62928ea58"}
{"project": "qemu", "commit_id": "af01492755b82ccaf0d15014477b34ba3ea643fc", "target": 1, "func": "static void usb_msd_realize_bot(USBDevice *dev, Error **errp)\n\n{\n\n    MSDState *s = DO_UPCAST(MSDState, dev, dev);\n\n\n\n    usb_desc_create_serial(dev);\n\n    usb_desc_init(dev);\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),\n\n                 &usb_msd_scsi_info_bot, NULL);\n\n    s->bus.qbus.allow_hotplug = 0;\n\n    usb_msd_handle_reset(dev);\n\n}\n", "idx": 10735, "_split": "test", "_hash": "46bd5e07854fbda76239bbdc37794471"}
{"project": "qemu", "commit_id": "b60fae32ff33cbaab76d14cc5f55b979cf58516d", "target": 1, "func": "int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)\n\n{\n\n\n\n    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,\n\n                            sizeof(diag_501), 0) ||\n\n        cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)diag_501,\n\n                            sizeof(diag_501), 1)) {\n\n        return -EINVAL;\n\n    }\n\n    return 0;\n\n}\n", "idx": 10741, "_split": "test", "_hash": "94fd2bcdf764b672543e806e2fb96a1c"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,\n\n                                       uint64_t i)\n\n{\n\n    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)\n\n                                    + (i << RDMA_REG_CHUNK_SHIFT));\n\n}\n", "idx": 10744, "_split": "test", "_hash": "d0bce0bc51d5f4dd0faf55cd1dfb5a7e"}
{"project": "qemu", "commit_id": "d02f8adc6d2a178bcbf77d0413f9a96fdbed53f0", "target": 1, "func": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)\n\n{\n\n    AHCICmdHdr *cmd = ad->cur_cmd;\n\n    uint32_t opts = le32_to_cpu(cmd->opts);\n\n    uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80;\n\n    int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;\n\n    dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));\n\n    dma_addr_t real_prdt_len = prdt_len;\n\n    uint8_t *prdt;\n\n    int i;\n\n    int r = 0;\n\n    int sum = 0;\n\n    int off_idx = -1;\n\n    int off_pos = -1;\n\n    int tbl_entry_size;\n\n    IDEBus *bus = &ad->port;\n\n    BusState *qbus = BUS(bus);\n\n\n\n    if (!sglist_alloc_hint) {\n\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n\n        return -1;\n\n    }\n\n\n\n    /* map PRDT */\n\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n\n                                DMA_DIRECTION_TO_DEVICE))){\n\n        DPRINTF(ad->port_no, \"map failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (prdt_len < real_prdt_len) {\n\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n\n        r = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n\n    if (sglist_alloc_hint > 0) {\n\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n\n        sum = 0;\n\n        for (i = 0; i < sglist_alloc_hint; i++) {\n\n            /* flags_size is zero-based */\n\n            tbl_entry_size = (le32_to_cpu(tbl[i].flags_size) + 1);\n\n            if (offset <= (sum + tbl_entry_size)) {\n\n                off_idx = i;\n\n                off_pos = offset - sum;\n\n                break;\n\n            }\n\n            sum += tbl_entry_size;\n\n        }\n\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n\n                            \"off_idx: %d, off_pos: %d\\n\",\n\n                            __func__, off_idx, off_pos);\n\n            r = -1;\n\n            goto out;\n\n        }\n\n\n\n        qemu_sglist_init(sglist, qbus->parent, (sglist_alloc_hint - off_idx),\n\n                         ad->hba->as);\n\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr + off_pos),\n\n                        le32_to_cpu(tbl[off_idx].flags_size) + 1 - off_pos);\n\n\n\n        for (i = off_idx + 1; i < sglist_alloc_hint; i++) {\n\n            /* flags_size is zero-based */\n\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n\n                            le32_to_cpu(tbl[i].flags_size) + 1);\n\n        }\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n\n    return r;\n\n}\n", "idx": 10801, "_split": "test", "_hash": "86f524ca57850503c26cc213bce40214"}
{"project": "qemu", "commit_id": "141af038dd1e73ed32e473046adeb822537c1152", "target": 1, "func": "static void csrhci_reset(struct csrhci_s *s)\n\n{\n\n    s->out_len = 0;\n\n    s->out_size = FIFO_LEN;\n\n    s->in_len = 0;\n\n    s->baud_delay = NANOSECONDS_PER_SECOND;\n\n    s->enable = 0;\n\n    s->in_hdr = INT_MAX;\n\n    s->in_data = INT_MAX;\n\n\n\n    s->modem_state = 0;\n\n    /* After a while... (but sooner than 10ms) */\n\n    s->modem_state |= CHR_TIOCM_CTS;\n\n\n\n    memset(&s->bd_addr, 0, sizeof(bdaddr_t));\n\n}\n", "idx": 10847, "_split": "test", "_hash": "3cb008ccc9c121d9bb5a956ab5d91cad"}
{"project": "qemu", "commit_id": "0a73336d96397c80881219d080518fac6f1ecacb", "target": 1, "func": "int net_init_vhost_user(const Netdev *netdev, const char *name,\n\n                        NetClientState *peer, Error **errp)\n\n{\n\n    int queues;\n\n    const NetdevVhostUserOptions *vhost_user_opts;\n\n    CharDriverState *chr;\n\n\n\n    assert(netdev->type == NET_CLIENT_DRIVER_VHOST_USER);\n\n    vhost_user_opts = &netdev->u.vhost_user;\n\n\n\n    chr = net_vhost_parse_chardev(vhost_user_opts, errp);\n\n    if (!chr) {\n\n        return -1;\n\n    }\n\n\n\n    /* verify net frontend */\n\n    if (qemu_opts_foreach(qemu_find_opts(\"device\"), net_vhost_check_net,\n\n                          (char *)name, errp)) {\n\n        return -1;\n\n    }\n\n\n\n    queues = vhost_user_opts->has_queues ? vhost_user_opts->queues : 1;\n\n    if (queues < 1 || queues > MAX_QUEUE_NUM) {\n\n        error_setg(errp,\n\n                   \"vhost-user number of queues must be in range [1, %d]\",\n\n                   MAX_QUEUE_NUM);\n\n        return -1;\n\n    }\n\n\n\n    return net_vhost_user_init(peer, \"vhost_user\", name, chr, queues);\n\n}\n", "idx": 10857, "_split": "test", "_hash": "d609b61d51643e808079d2a77eb32357"}
{"project": "qemu", "commit_id": "0fb6395c0cb5046432a80d608ddde7a3b2f8a9ae", "target": 0, "func": "static void test_validate_fail_union_flat(TestInputVisitorData *data,\n\n                                          const void *unused)\n\n{\n\n    UserDefFlatUnion *tmp = NULL;\n\n    Error *errp = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string': 'c', 'integer': 41, 'boolean': true }\");\n\n\n\n    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);\n\n    g_assert(error_is_set(&errp));\n\n    qapi_free_UserDefFlatUnion(tmp);\n\n}\n", "idx": 10875, "_split": "test", "_hash": "34dae1ebce88a5a3f7d8192137d7df33"}
{"project": "qemu", "commit_id": "a9321a4d49d65d29c2926a51aedc5b91a01f3591", "target": 0, "func": "void cpu_x86_update_cr4(CPUX86State *env, uint32_t new_cr4)\n\n{\n\n#if defined(DEBUG_MMU)\n\n    printf(\"CR4 update: CR4=%08x\\n\", (uint32_t)env->cr[4]);\n\n#endif\n\n    if ((new_cr4 & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=\n\n        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {\n\n        tlb_flush(env, 1);\n\n    }\n\n    /* SSE handling */\n\n    if (!(env->cpuid_features & CPUID_SSE))\n\n        new_cr4 &= ~CR4_OSFXSR_MASK;\n\n    if (new_cr4 & CR4_OSFXSR_MASK)\n\n        env->hflags |= HF_OSFXSR_MASK;\n\n    else\n\n        env->hflags &= ~HF_OSFXSR_MASK;\n\n\n\n    env->cr[4] = new_cr4;\n\n}\n", "idx": 10877, "_split": "test", "_hash": "a9d10d534d2df2b95746e75ed6f87233"}
{"project": "qemu", "commit_id": "ffad4116b96e29e0fbe892806f97c0a6c903d30d", "target": 0, "func": "int drive_init(struct drive_opt *arg, int snapshot, void *opaque)\n\n{\n\n    char buf[128];\n\n    char file[1024];\n\n    char devname[128];\n\n    char serial[21];\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriverState *bdrv;\n\n    BlockDriver *drv = NULL;\n\n    QEMUMachine *machine = opaque;\n\n    int max_devs;\n\n    int index;\n\n    int cache;\n\n    int bdrv_flags, onerror;\n\n    int drives_table_idx;\n\n    char *str = arg->opt;\n\n    static const char * const params[] = { \"bus\", \"unit\", \"if\", \"index\",\n\n                                           \"cyls\", \"heads\", \"secs\", \"trans\",\n\n                                           \"media\", \"snapshot\", \"file\",\n\n                                           \"cache\", \"format\", \"serial\", \"werror\",\n\n                                           NULL };\n\n\n\n    if (check_params(buf, sizeof(buf), params, str) < 0) {\n\n         fprintf(stderr, \"qemu: unknown parameter '%s' in '%s'\\n\",\n\n                         buf, str);\n\n         return -1;\n\n    }\n\n\n\n    file[0] = 0;\n\n    cyls = heads = secs = 0;\n\n    bus_id = 0;\n\n    unit_id = -1;\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    index = -1;\n\n    cache = 3;\n\n\n\n    if (machine->use_scsi) {\n\n        type = IF_SCSI;\n\n        max_devs = MAX_SCSI_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"scsi\");\n\n    } else {\n\n        type = IF_IDE;\n\n        max_devs = MAX_IDE_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"ide\");\n\n    }\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"bus\", str)) {\n\n        bus_id = strtol(buf, NULL, 0);\n\n\tif (bus_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid bus id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"unit\", str)) {\n\n        unit_id = strtol(buf, NULL, 0);\n\n\tif (unit_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid unit id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", str)) {\n\n        pstrcpy(devname, sizeof(devname), buf);\n\n        if (!strcmp(buf, \"ide\")) {\n\n\t    type = IF_IDE;\n\n            max_devs = MAX_IDE_DEVS;\n\n        } else if (!strcmp(buf, \"scsi\")) {\n\n\t    type = IF_SCSI;\n\n            max_devs = MAX_SCSI_DEVS;\n\n        } else if (!strcmp(buf, \"floppy\")) {\n\n\t    type = IF_FLOPPY;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"pflash\")) {\n\n\t    type = IF_PFLASH;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"mtd\")) {\n\n\t    type = IF_MTD;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"sd\")) {\n\n\t    type = IF_SD;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"xen\")) {\n\n\t    type = IF_XEN;\n\n            max_devs = 0;\n\n\t} else {\n\n            fprintf(stderr, \"qemu: '%s' unsupported bus type '%s'\\n\", str, buf);\n\n            return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"index\", str)) {\n\n        index = strtol(buf, NULL, 0);\n\n\tif (index < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid index\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cyls\", str)) {\n\n        cyls = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"heads\", str)) {\n\n        heads = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"secs\", str)) {\n\n        secs = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1 || cyls > 16383) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical cyls number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (heads < 1 || heads > 16) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical heads number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (secs < 1 || secs > 63) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical secs number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"trans\", str)) {\n\n        if (!cyls) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' trans must be used with cyls,heads and secs\\n\",\n\n                    str);\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            fprintf(stderr, \"qemu: '%s' invalid translation type\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"media\", str)) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                fprintf(stderr,\n\n                        \"qemu: '%s' invalid physical CHS format\\n\", str);\n\n\t        return -1;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid media\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"snapshot\", str)) {\n\n        if (!strcmp(buf, \"on\"))\n\n\t    snapshot = 1;\n\n        else if (!strcmp(buf, \"off\"))\n\n\t    snapshot = 0;\n\n\telse {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid snapshot option\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cache\", str)) {\n\n        if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\"))\n\n            cache = 0;\n\n        else if (!strcmp(buf, \"writethrough\"))\n\n            cache = 1;\n\n        else if (!strcmp(buf, \"writeback\"))\n\n            cache = 2;\n\n        else {\n\n           fprintf(stderr, \"qemu: invalid cache option\\n\");\n\n           return -1;\n\n        }\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"format\", str)) {\n\n       if (strcmp(buf, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            fprintf(stderr, \"\\n\");\n\n\t    return -1;\n\n        }\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            fprintf(stderr, \"qemu: '%s' invalid format\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (arg->file == NULL)\n\n        get_param_value(file, sizeof(file), \"file\", str);\n\n    else\n\n        pstrcpy(file, sizeof(file), arg->file);\n\n\n\n    if (!get_param_value(serial, sizeof(serial), \"serial\", str))\n\n\t    memset(serial, 0,  sizeof(serial));\n\n\n\n    onerror = BLOCK_ERR_STOP_ENOSPC;\n\n    if (get_param_value(buf, sizeof(serial), \"werror\", str)) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n\n            fprintf(stderr, \"werror is no supported by this format\\n\");\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"ignore\"))\n\n            onerror = BLOCK_ERR_IGNORE;\n\n        else if (!strcmp(buf, \"enospc\"))\n\n            onerror = BLOCK_ERR_STOP_ENOSPC;\n\n        else if (!strcmp(buf, \"stop\"))\n\n            onerror = BLOCK_ERR_STOP_ANY;\n\n        else if (!strcmp(buf, \"report\"))\n\n            onerror = BLOCK_ERR_REPORT;\n\n        else {\n\n            fprintf(stderr, \"qemu: '%s' invalid write error action\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' index cannot be used with bus and unit\\n\", str);\n\n            return -1;\n\n        }\n\n        if (max_devs == 0)\n\n        {\n\n            unit_id = index;\n\n            bus_id = 0;\n\n        } else {\n\n            unit_id = index % max_devs;\n\n            bus_id = index / max_devs;\n\n        }\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get_index(type, bus_id, unit_id) != -1) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        fprintf(stderr, \"qemu: '%s' unit %d too big (max is %d)\\n\",\n\n                        str, unit_id, max_devs - 1);\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * ignore multiple definitions\n\n     */\n\n\n\n    if (drive_get_index(type, bus_id, unit_id) != -1)\n\n        return -2;\n\n\n\n    /* init */\n\n\n\n    if (type == IF_IDE || type == IF_SCSI)\n\n        mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n    if (max_devs)\n\n        snprintf(buf, sizeof(buf), \"%s%i%s%i\",\n\n                 devname, bus_id, mediastr, unit_id);\n\n    else\n\n        snprintf(buf, sizeof(buf), \"%s%s%i\",\n\n                 devname, mediastr, unit_id);\n\n    bdrv = bdrv_new(buf);\n\n    drives_table_idx = drive_get_free_idx();\n\n    drives_table[drives_table_idx].bdrv = bdrv;\n\n    drives_table[drives_table_idx].type = type;\n\n    drives_table[drives_table_idx].bus = bus_id;\n\n    drives_table[drives_table_idx].unit = unit_id;\n\n    drives_table[drives_table_idx].onerror = onerror;\n\n    drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt;\n\n    strncpy(drives_table[nb_drives].serial, serial, sizeof(serial));\n\n    nb_drives++;\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n    case IF_VIRTIO:\n\n        break;\n\n    }\n\n    if (!file[0])\n\n        return -2;\n\n    bdrv_flags = 0;\n\n    if (snapshot) {\n\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n\n        cache = 2; /* always use write-back with snapshot */\n\n    }\n\n    if (cache == 0) /* no caching */\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    else if (cache == 2) /* write-back */\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    else if (cache == 3) /* not specified */\n\n        bdrv_flags |= BDRV_O_CACHE_DEF;\n\n    if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) {\n\n        fprintf(stderr, \"qemu: could not open disk image %s\\n\",\n\n                        file);\n\n        return -1;\n\n    }\n\n    if (bdrv_key_required(bdrv))\n\n        autostart = 0;\n\n    return drives_table_idx;\n\n}\n", "idx": 10899, "_split": "test", "_hash": "32c82ca5bf94ba3163b4741cf72b5c3d"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void unix_wait_for_connect(int fd, Error *err, void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n\n\n    if (fd < 0) {\n\n        DPRINTF(\"migrate connect error: %s\\n\", error_get_pretty(err));\n\n        s->file = NULL;\n\n        migrate_fd_error(s);\n\n    } else {\n\n        DPRINTF(\"migrate connect success\\n\");\n\n        s->file = qemu_fopen_socket(fd, \"wb\");\n\n        migrate_fd_connect(s);\n\n    }\n\n}\n", "idx": 10914, "_split": "test", "_hash": "c1d44dc97bf8ab425124a89af2ef3b3a"}
{"project": "qemu", "commit_id": "a52b2cbf218d52f9e357961acb271a98a2bdff71", "target": 1, "func": "static void qxl_spice_monitors_config_async(PCIQXLDevice *qxl, int replay)\n\n{\n\n    trace_qxl_spice_monitors_config(qxl->id);\n\n    if (replay) {\n\n        /*\n\n         * don't use QXL_COOKIE_TYPE_IO:\n\n         *  - we are not running yet (post_load), we will assert\n\n         *    in send_events\n\n         *  - this is not a guest io, but a reply, so async_io isn't set.\n\n         */\n\n        spice_qxl_monitors_config_async(&qxl->ssd.qxl,\n\n                qxl->guest_monitors_config,\n\n                MEMSLOT_GROUP_GUEST,\n\n                (uintptr_t)qxl_cookie_new(\n\n                    QXL_COOKIE_TYPE_POST_LOAD_MONITORS_CONFIG,\n\n                    0));\n\n    } else {\n\n#if SPICE_SERVER_VERSION >= 0x000c06 /* release 0.12.6 */\n\n        if (qxl->max_outputs) {\n\n            spice_qxl_set_monitors_config_limit(&qxl->ssd.qxl,\n\n                                                qxl->max_outputs);\n\n        }\n\n#endif\n\n        qxl->guest_monitors_config = qxl->ram->monitors_config;\n\n        spice_qxl_monitors_config_async(&qxl->ssd.qxl,\n\n                qxl->ram->monitors_config,\n\n                MEMSLOT_GROUP_GUEST,\n\n                (uintptr_t)qxl_cookie_new(QXL_COOKIE_TYPE_IO,\n\n                                          QXL_IO_MONITORS_CONFIG_ASYNC));\n\n    }\n\n}\n", "idx": 10974, "_split": "test", "_hash": "9c6cffcecca1f74119e3318049ceae82"}
{"project": "qemu", "commit_id": "086abc1ccd0fa5103345adda819e6c6436949579", "target": 0, "func": "static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n    int queues = n->multiqueue ? n->max_queues : 1;\n\n\n\n    if (!get_vhost_net(nc->peer)) {\n\n        return;\n\n    }\n\n\n\n    if (!!n->vhost_started ==\n\n        (virtio_net_started(n, status) && !nc->peer->link_down)) {\n\n        return;\n\n    }\n\n    if (!n->vhost_started) {\n\n        int r;\n\n        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {\n\n            return;\n\n        }\n\n        n->vhost_started = 1;\n\n        r = vhost_net_start(vdev, n->nic->ncs, queues);\n\n        if (r < 0) {\n\n            error_report(\"unable to start vhost net: %d: \"\n\n                         \"falling back on userspace virtio\", -r);\n\n            n->vhost_started = 0;\n\n        }\n\n    } else {\n\n        vhost_net_stop(vdev, n->nic->ncs, queues);\n\n        n->vhost_started = 0;\n\n    }\n\n}\n", "idx": 10982, "_split": "test", "_hash": "8f9f71f2869a7354899c9593da19d8eb"}
{"project": "qemu", "commit_id": "7ebaf7955603cc50988e0eafd5e6074320fefc70", "target": 0, "func": "static void spapr_cpu_core_host_initfn(Object *obj)\n\n{\n\n    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);\n\n    char *name = g_strdup_printf(\"%s-\" TYPE_POWERPC_CPU, \"host\");\n\n    ObjectClass *oc = object_class_by_name(name);\n\n\n\n    g_assert(oc);\n\n    g_free((void *)name);\n\n    core->cpu_class = oc;\n\n}\n", "idx": 10984, "_split": "test", "_hash": "222f21f9c5b47db35c685ce1b87c9df6"}
{"project": "qemu", "commit_id": "9a78eead0c74333a394c0f7bbfc4423ac746fcd5", "target": 0, "func": "void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; m68k_cpu_defs[i].name; i++) {\n\n        (*cpu_fprintf)(f, \"%s\\n\", m68k_cpu_defs[i].name);\n\n    }\n\n}\n", "idx": 10999, "_split": "test", "_hash": "df761c863985ab453d8646f8d5adb4ef"}
{"project": "qemu", "commit_id": "5a2223ca26b1a34e131b5b9a63599d9426d2c25c", "target": 0, "func": "int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,\n\n                              PCIHotplugState state)\n\n{\n\n    int slot = PCI_SLOT(dev->devfn);\n\n    int bsel = acpi_pcihp_get_bsel(dev->bus);\n\n    if (bsel < 0) {\n\n        return -1;\n\n    }\n\n\n\n    /* Don't send event when device is enabled during qemu machine creation:\n\n     * it is present on boot, no hotplug event is necessary. We do send an\n\n     * event when the device is disabled later. */\n\n    if (state == PCI_COLDPLUG_ENABLED) {\n\n        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);\n\n        return 0;\n\n    }\n\n\n\n    if (state == PCI_HOTPLUG_ENABLED) {\n\n        enable_device(s, bsel, slot);\n\n    } else {\n\n        disable_device(s, bsel, slot);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11016, "_split": "test", "_hash": "f099b1109a9f58d003eaa0e3ebcaef56"}
{"project": "qemu", "commit_id": "f5aa4bdc766190b95d18be27d5cdf4d80c35b33c", "target": 1, "func": "static void test_flush_nodev(void)\n\n{\n\n    QPCIDevice *dev;\n\n    QPCIBar bmdma_bar, ide_bar;\n\n\n\n    ide_test_start(\"\");\n\n\n\n    dev = get_pci_device(&bmdma_bar, &ide_bar);\n\n\n\n    /* FLUSH CACHE command on device 0*/\n\n    qpci_io_writeb(dev, ide_bar, reg_device, 0);\n\n    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);\n\n\n\n    /* Just testing that qemu doesn't crash... */\n\n\n\n\n    ide_test_quit();\n\n}", "idx": 11046, "_split": "test", "_hash": "7b57b489114d1f981710d52bbadb2cfc"}
{"project": "qemu", "commit_id": "895b00f62a7e86724dc7352d67c7808d37366130", "target": 1, "func": "void qmp_guest_file_flush(int64_t handle, Error **errp)\n\n{\n\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n\n    FILE *fh;\n\n    int ret;\n\n\n\n    if (!gfh) {\n\n        return;\n\n    }\n\n\n\n    fh = gfh->fh;\n\n    ret = fflush(fh);\n\n    if (ret == EOF) {\n\n        error_setg_errno(errp, errno, \"failed to flush file\");\n\n\n\n    }\n\n}", "idx": 11070, "_split": "test", "_hash": "3c192e6af48417fd2b6dc0042a1b7ff3"}
{"project": "qemu", "commit_id": "ecbddbb106114f90008024b4e6c3ba1c38d7ca0e", "target": 1, "func": "static int os_host_main_loop_wait(int64_t timeout)\n{\n    GMainContext *context = g_main_context_default();\n    GPollFD poll_fds[1024 * 2]; /* this is probably overkill */\n    int select_ret = 0;\n    int g_poll_ret, ret, i, n_poll_fds;\n    PollingEntry *pe;\n    WaitObjects *w = &wait_objects;\n    gint poll_timeout;\n    int64_t poll_timeout_ns;\n    static struct timeval tv0;\n    fd_set rfds, wfds, xfds;\n    int nfds;\n    /* XXX: need to suppress polling by better using win32 events */\n    ret = 0;\n    for (pe = first_polling_entry; pe != NULL; pe = pe->next) {\n        ret |= pe->func(pe->opaque);\n    }\n    if (ret != 0) {\n        return ret;\n    }\n    FD_ZERO(&rfds);\n    FD_ZERO(&wfds);\n    FD_ZERO(&xfds);\n    nfds = pollfds_fill(gpollfds, &rfds, &wfds, &xfds);\n    if (nfds >= 0) {\n        select_ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv0);\n        if (select_ret != 0) {\n            timeout = 0;\n        }\n        if (select_ret > 0) {\n            pollfds_poll(gpollfds, nfds, &rfds, &wfds, &xfds);\n        }\n    }\n    g_main_context_prepare(context, &max_priority);\n    n_poll_fds = g_main_context_query(context, max_priority, &poll_timeout,\n                                      poll_fds, ARRAY_SIZE(poll_fds));\n    g_assert(n_poll_fds <= ARRAY_SIZE(poll_fds));\n    for (i = 0; i < w->num; i++) {\n        poll_fds[n_poll_fds + i].fd = (DWORD_PTR)w->events[i];\n        poll_fds[n_poll_fds + i].events = G_IO_IN;\n    }\n    if (poll_timeout < 0) {\n        poll_timeout_ns = -1;\n    } else {\n        poll_timeout_ns = (int64_t)poll_timeout * (int64_t)SCALE_MS;\n    }\n    poll_timeout_ns = qemu_soonest_timeout(poll_timeout_ns, timeout);\n    qemu_mutex_unlock_iothread();\n    g_poll_ret = qemu_poll_ns(poll_fds, n_poll_fds + w->num, poll_timeout_ns);\n    qemu_mutex_lock_iothread();\n    if (g_poll_ret > 0) {\n        for (i = 0; i < w->num; i++) {\n            w->revents[i] = poll_fds[n_poll_fds + i].revents;\n        }\n        for (i = 0; i < w->num; i++) {\n            if (w->revents[i] && w->func[i]) {\n                w->func[i](w->opaque[i]);\n            }\n        }\n    }\n    if (g_main_context_check(context, max_priority, poll_fds, n_poll_fds)) {\n        g_main_context_dispatch(context);\n    }\n    return select_ret || g_poll_ret;\n}", "idx": 11113, "_split": "test", "_hash": "c6abca5a23616547c36021d6de8e233d"}
{"project": "qemu", "commit_id": "a89d89d3e65800fa4a8e00de7af0ea8272bef779", "target": 1, "func": "int bdrv_snapshot_delete(BlockDriverState *bs, const char *snapshot_id)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n    if (drv->bdrv_snapshot_delete) {\n\n        return drv->bdrv_snapshot_delete(bs, snapshot_id);\n\n    }\n\n    if (bs->file) {\n\n        return bdrv_snapshot_delete(bs->file, snapshot_id);\n\n    }\n\n    return -ENOTSUP;\n\n}\n", "idx": 11117, "_split": "test", "_hash": "064be49b79a450263a8200082fde9b58"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t pci_apb_ioreadl (void *opaque, target_phys_addr_t addr)\n\n{\n\n    uint32_t val;\n\n\n\n    val = bswap32(cpu_inl(addr & IOPORTS_MASK));\n\n    return val;\n\n}\n", "idx": 11126, "_split": "test", "_hash": "90736cb8b7b72aa37f5bb0f0292603e9"}
{"project": "qemu", "commit_id": "5dafc53f1fb091d242f2179ffcb43bb28af36d1e", "target": 0, "func": "static void qemu_fill_buffer(QEMUFile *f)\n\n{\n\n    int len;\n\n\n\n    if (f->is_writable)\n\n        return;\n\n    if (f->is_file) {\n\n        fseek(f->outfile, f->buf_offset, SEEK_SET);\n\n        len = fread(f->buf, 1, IO_BUF_SIZE, f->outfile);\n\n        if (len < 0)\n\n            len = 0;\n\n    } else {\n\n        len = bdrv_pread(f->bs, f->base_offset + f->buf_offset,\n\n                         f->buf, IO_BUF_SIZE);\n\n        if (len < 0)\n\n            len = 0;\n\n    }\n\n    f->buf_index = 0;\n\n    f->buf_size = len;\n\n    f->buf_offset += len;\n\n}\n", "idx": 11127, "_split": "test", "_hash": "efa42cc900c1b2ff68fd6497b76364a9"}
{"project": "qemu", "commit_id": "8297be80f7cf71e09617669a8bd8b2836dcfd4c3", "target": 0, "func": "void net_hub_check_clients(void)\n\n{\n\n    NetHub *hub;\n\n    NetHubPort *port;\n\n    NetClientState *peer;\n\n\n\n    QLIST_FOREACH(hub, &hubs, next) {\n\n        int has_nic = 0, has_host_dev = 0;\n\n\n\n        QLIST_FOREACH(port, &hub->ports, next) {\n\n            peer = port->nc.peer;\n\n            if (!peer) {\n\n                fprintf(stderr, \"Warning: hub port %s has no peer\\n\",\n\n                        port->nc.name);\n\n                continue;\n\n            }\n\n\n\n            switch (peer->info->type) {\n\n            case NET_CLIENT_DRIVER_NIC:\n\n                has_nic = 1;\n\n                break;\n\n            case NET_CLIENT_DRIVER_USER:\n\n            case NET_CLIENT_DRIVER_TAP:\n\n            case NET_CLIENT_DRIVER_SOCKET:\n\n            case NET_CLIENT_DRIVER_VDE:\n\n            case NET_CLIENT_DRIVER_VHOST_USER:\n\n                has_host_dev = 1;\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n        }\n\n        if (has_host_dev && !has_nic) {\n\n            warn_report(\"vlan %d with no nics\", hub->id);\n\n        }\n\n        if (has_nic && !has_host_dev) {\n\n            fprintf(stderr,\n\n                    \"Warning: vlan %d is not connected to host network\\n\",\n\n                    hub->id);\n\n        }\n\n    }\n\n}\n", "idx": 11128, "_split": "test", "_hash": "e6d67b9dfe33ab3353fa043909dca7a3"}
{"project": "qemu", "commit_id": "cb2e28780c7080af489e72227683fe374f05022d", "target": 0, "func": "static int coroutine_fn bdrv_co_do_pwrite_zeroes(BlockDriverState *bs,\n\n    int64_t offset, int bytes, BdrvRequestFlags flags)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    QEMUIOVector qiov;\n\n    struct iovec iov = {0};\n\n    int ret = 0;\n\n    bool need_flush = false;\n\n    int head = 0;\n\n    int tail = 0;\n\n\n\n    int max_write_zeroes = MIN_NON_ZERO(bs->bl.max_pwrite_zeroes, INT_MAX);\n\n    int alignment = MAX(bs->bl.pwrite_zeroes_alignment,\n\n                        bs->bl.request_alignment);\n\n    int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,\n\n                                    MAX_WRITE_ZEROES_BOUNCE_BUFFER);\n\n\n\n    assert(alignment % bs->bl.request_alignment == 0);\n\n    head = offset % alignment;\n\n    tail = (offset + bytes) % alignment;\n\n    max_write_zeroes = QEMU_ALIGN_DOWN(max_write_zeroes, alignment);\n\n    assert(max_write_zeroes >= bs->bl.request_alignment);\n\n\n\n    while (bytes > 0 && !ret) {\n\n        int num = bytes;\n\n\n\n        /* Align request.  Block drivers can expect the \"bulk\" of the request\n\n         * to be aligned, and that unaligned requests do not cross cluster\n\n         * boundaries.\n\n         */\n\n        if (head) {\n\n            /* Make a small request up to the first aligned sector. For\n\n             * convenience, limit this request to max_transfer even if\n\n             * we don't need to fall back to writes.  */\n\n            num = MIN(MIN(bytes, max_transfer), alignment - head);\n\n            head = (head + num) % alignment;\n\n            assert(num < max_write_zeroes);\n\n        } else if (tail && num > alignment) {\n\n            /* Shorten the request to the last aligned sector.  */\n\n            num -= tail;\n\n        }\n\n\n\n        /* limit request size */\n\n        if (num > max_write_zeroes) {\n\n            num = max_write_zeroes;\n\n        }\n\n\n\n        ret = -ENOTSUP;\n\n        /* First try the efficient write zeroes operation */\n\n        if (drv->bdrv_co_pwrite_zeroes) {\n\n            ret = drv->bdrv_co_pwrite_zeroes(bs, offset, num,\n\n                                             flags & bs->supported_zero_flags);\n\n            if (ret != -ENOTSUP && (flags & BDRV_REQ_FUA) &&\n\n                !(bs->supported_zero_flags & BDRV_REQ_FUA)) {\n\n                need_flush = true;\n\n            }\n\n        } else {\n\n            assert(!bs->supported_zero_flags);\n\n        }\n\n\n\n        if (ret == -ENOTSUP) {\n\n            /* Fall back to bounce buffer if write zeroes is unsupported */\n\n            BdrvRequestFlags write_flags = flags & ~BDRV_REQ_ZERO_WRITE;\n\n\n\n            if ((flags & BDRV_REQ_FUA) &&\n\n                !(bs->supported_write_flags & BDRV_REQ_FUA)) {\n\n                /* No need for bdrv_driver_pwrite() to do a fallback\n\n                 * flush on each chunk; use just one at the end */\n\n                write_flags &= ~BDRV_REQ_FUA;\n\n                need_flush = true;\n\n            }\n\n            num = MIN(num, max_transfer);\n\n            iov.iov_len = num;\n\n            if (iov.iov_base == NULL) {\n\n                iov.iov_base = qemu_try_blockalign(bs, num);\n\n                if (iov.iov_base == NULL) {\n\n                    ret = -ENOMEM;\n\n                    goto fail;\n\n                }\n\n                memset(iov.iov_base, 0, num);\n\n            }\n\n            qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n            ret = bdrv_driver_pwritev(bs, offset, num, &qiov, write_flags);\n\n\n\n            /* Keep bounce buffer around if it is big enough for all\n\n             * all future requests.\n\n             */\n\n            if (num < max_transfer) {\n\n                qemu_vfree(iov.iov_base);\n\n                iov.iov_base = NULL;\n\n            }\n\n        }\n\n\n\n        offset += num;\n\n        bytes -= num;\n\n    }\n\n\n\nfail:\n\n    if (ret == 0 && need_flush) {\n\n        ret = bdrv_co_flush(bs);\n\n    }\n\n    qemu_vfree(iov.iov_base);\n\n    return ret;\n\n}\n", "idx": 11141, "_split": "test", "_hash": "3e530ac862f75177105f0f580d6dd5b4"}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)\n\n        qemu_put_be32s(f, &q->queue[i]);\n\n\n\n    qemu_put_sbe32s(f, &q->next);\n\n    qemu_put_sbe32s(f, &q->priority);\n\n}\n", "idx": 11142, "_split": "test", "_hash": "b242d416d1c67fa36437b66931add483"}
{"project": "qemu", "commit_id": "68d553587c0aa271c3eb2902921b503740d775b6", "target": 0, "func": "static EHCIQueue *ehci_state_fetchqh(EHCIState *ehci, int async)\n\n{\n\n    uint32_t entry;\n\n    EHCIQueue *q;\n\n    int reload;\n\n\n\n    entry = ehci_get_fetch_addr(ehci, async);\n\n    q = ehci_find_queue_by_qh(ehci, entry);\n\n    if (NULL == q) {\n\n        q = ehci_alloc_queue(ehci, async);\n\n    }\n\n    q->qhaddr = entry;\n\n    q->seen++;\n\n\n\n    if (q->seen > 1) {\n\n        /* we are going in circles -- stop processing */\n\n        ehci_set_state(ehci, async, EST_ACTIVE);\n\n        q = NULL;\n\n        goto out;\n\n    }\n\n\n\n    get_dwords(NLPTR_GET(q->qhaddr), (uint32_t *) &q->qh, sizeof(EHCIqh) >> 2);\n\n    ehci_trace_qh(q, NLPTR_GET(q->qhaddr), &q->qh);\n\n\n\n    if (q->async == EHCI_ASYNC_INFLIGHT) {\n\n        /* I/O still in progress -- skip queue */\n\n        ehci_set_state(ehci, async, EST_HORIZONTALQH);\n\n        goto out;\n\n    }\n\n    if (q->async == EHCI_ASYNC_FINISHED) {\n\n        /* I/O finished -- continue processing queue */\n\n        trace_usb_ehci_queue_action(q, \"resume\");\n\n        ehci_set_state(ehci, async, EST_EXECUTING);\n\n        goto out;\n\n    }\n\n\n\n    if (async && (q->qh.epchar & QH_EPCHAR_H)) {\n\n\n\n        /*  EHCI spec version 1.0 Section 4.8.3 & 4.10.1 */\n\n        if (ehci->usbsts & USBSTS_REC) {\n\n            ehci_clear_usbsts(ehci, USBSTS_REC);\n\n        } else {\n\n            DPRINTF(\"FETCHQH:  QH 0x%08x. H-bit set, reclamation status reset\"\n\n                       \" - done processing\\n\", q->qhaddr);\n\n            ehci_set_state(ehci, async, EST_ACTIVE);\n\n            q = NULL;\n\n            goto out;\n\n        }\n\n    }\n\n\n\n#if EHCI_DEBUG\n\n    if (q->qhaddr != q->qh.next) {\n\n    DPRINTF(\"FETCHQH:  QH 0x%08x (h %x halt %x active %x) next 0x%08x\\n\",\n\n               q->qhaddr,\n\n               q->qh.epchar & QH_EPCHAR_H,\n\n               q->qh.token & QTD_TOKEN_HALT,\n\n               q->qh.token & QTD_TOKEN_ACTIVE,\n\n               q->qh.next);\n\n    }\n\n#endif\n\n\n\n    reload = get_field(q->qh.epchar, QH_EPCHAR_RL);\n\n    if (reload) {\n\n        set_field(&q->qh.altnext_qtd, reload, QH_ALTNEXT_NAKCNT);\n\n    }\n\n\n\n    if (q->qh.token & QTD_TOKEN_HALT) {\n\n        ehci_set_state(ehci, async, EST_HORIZONTALQH);\n\n\n\n    } else if ((q->qh.token & QTD_TOKEN_ACTIVE) && (q->qh.current_qtd > 0x1000)) {\n\n        q->qtdaddr = q->qh.current_qtd;\n\n        ehci_set_state(ehci, async, EST_FETCHQTD);\n\n\n\n    } else {\n\n        /*  EHCI spec version 1.0 Section 4.10.2 */\n\n        ehci_set_state(ehci, async, EST_ADVANCEQUEUE);\n\n    }\n\n\n\nout:\n\n    return q;\n\n}\n", "idx": 11143, "_split": "test", "_hash": "7d6e0c81c995b6221af33ec81d50813d"}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static void omap_rtc_reset(struct omap_rtc_s *s)\n\n{\n\n    struct tm tm;\n\n\n\n    s->interrupts = 0;\n\n    s->comp_reg = 0;\n\n    s->running = 0;\n\n    s->pm_am = 0;\n\n    s->auto_comp = 0;\n\n    s->round = 0;\n\n    s->tick = qemu_get_clock(rt_clock);\n\n    memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));\n\n    s->alarm_tm.tm_mday = 0x01;\n\n    s->status = 1 << 7;\n\n    qemu_get_timedate(&tm, 0);\n\n    s->ti = mktimegm(&tm);\n\n\n\n    omap_rtc_alarm_update(s);\n\n    omap_rtc_tick(s);\n\n}\n", "idx": 11167, "_split": "test", "_hash": "80875ee6c7f7bf5298f06969f3b2a0ab"}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void tosa_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *rom = g_new(MemoryRegion, 1);\n\n    PXA2xxState *mpu;\n\n    TC6393xbState *tmio;\n\n    DeviceState *scp0, *scp1;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"pxa255\";\n\n\n\n    mpu = pxa255_init(address_space_mem, tosa_binfo.ram_size);\n\n\n\n    memory_region_init_ram(rom, NULL, \"tosa.rom\", TOSA_ROM, &error_abort);\n\n    vmstate_register_ram_global(rom);\n\n    memory_region_set_readonly(rom, true);\n\n    memory_region_add_subregion(address_space_mem, 0, rom);\n\n\n\n    tmio = tc6393xb_init(address_space_mem, 0x10000000,\n\n            qdev_get_gpio_in(mpu->gpio, TOSA_GPIO_TC6393XB_INT));\n\n\n\n    scp0 = sysbus_create_simple(\"scoop\", 0x08800000, NULL);\n\n    scp1 = sysbus_create_simple(\"scoop\", 0x14800040, NULL);\n\n\n\n    tosa_gpio_setup(mpu, scp0, scp1, tmio);\n\n\n\n    tosa_microdrive_attach(mpu);\n\n\n\n    tosa_tg_init(mpu);\n\n\n\n    tosa_binfo.kernel_filename = kernel_filename;\n\n    tosa_binfo.kernel_cmdline = kernel_cmdline;\n\n    tosa_binfo.initrd_filename = initrd_filename;\n\n    tosa_binfo.board_id = 0x208;\n\n    arm_load_kernel(mpu->cpu, &tosa_binfo);\n\n    sl_bootparam_write(SL_PXA_PARAM_BASE);\n\n}\n", "idx": 11193, "_split": "test", "_hash": "3df4e1b11539deb2bc898c7964729c38"}
{"project": "qemu", "commit_id": "73d60fa5fae60c8e07e1f295d8c7fd5d04320160", "target": 1, "func": "static void get_sensor_evt_enable(IPMIBmcSim *ibs,\n\n                                  uint8_t *cmd, unsigned int cmd_len,\n\n                                  uint8_t *rsp, unsigned int *rsp_len,\n\n                                  unsigned int max_rsp_len)\n\n{\n\n    IPMISensor *sens;\n\n\n\n    IPMI_CHECK_CMD_LEN(3);\n\n    if ((cmd[2] > MAX_SENSORS) ||\n\n        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {\n\n        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;\n\n        return;\n\n    }\n\n    sens = ibs->sensors + cmd[2];\n\n    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));\n\n    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);\n\n    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);\n\n}\n", "idx": 11202, "_split": "test", "_hash": "bc6ded73c9c6bedc31f461446c2b08f0"}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "struct omap_uart_s *omap_uart_init(hwaddr base,\n\n                qemu_irq irq, omap_clk fclk, omap_clk iclk,\n\n                qemu_irq txdma, qemu_irq rxdma,\n\n                const char *label, CharDriverState *chr)\n\n{\n\n    struct omap_uart_s *s = (struct omap_uart_s *)\n\n            g_malloc0(sizeof(struct omap_uart_s));\n\n\n\n    s->base = base;\n\n    s->fclk = fclk;\n\n    s->irq = irq;\n\n    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,\n\n                               omap_clk_getrate(fclk)/16,\n\n                               chr ?: qemu_chr_new(label, \"null\", NULL),\n\n                               DEVICE_NATIVE_ENDIAN);\n\n    return s;\n\n}\n", "idx": 11235, "_split": "test", "_hash": "45538b41b72536f228f7bc302cf3d7c9"}
{"project": "qemu", "commit_id": "fef6070eff233400015cede968b0afe46c80bb0f", "target": 0, "func": "static int create_dynamic_disk(int fd, uint8_t *buf, int64_t total_sectors)\n\n{\n\n    VHDDynDiskHeader *dyndisk_header =\n\n        (VHDDynDiskHeader *) buf;\n\n    size_t block_size, num_bat_entries;\n\n    int i;\n\n    int ret = -EIO;\n\n\n\n    // Write the footer (twice: at the beginning and at the end)\n\n    block_size = 0x200000;\n\n    num_bat_entries = (total_sectors + block_size / 512) / (block_size / 512);\n\n\n\n    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {\n\n        goto fail;\n\n    }\n\n\n\n    if (lseek(fd, 1536 + ((num_bat_entries * 4 + 511) & ~511), SEEK_SET) < 0) {\n\n        goto fail;\n\n    }\n\n    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {\n\n        goto fail;\n\n    }\n\n\n\n    // Write the initial BAT\n\n    if (lseek(fd, 3 * 512, SEEK_SET) < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    memset(buf, 0xFF, 512);\n\n    for (i = 0; i < (num_bat_entries * 4 + 511) / 512; i++) {\n\n        if (write(fd, buf, 512) != 512) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    // Prepare the Dynamic Disk Header\n\n    memset(buf, 0, 1024);\n\n\n\n    memcpy(dyndisk_header->magic, \"cxsparse\", 8);\n\n\n\n    /*\n\n     * Note: The spec is actually wrong here for data_offset, it says\n\n     * 0xFFFFFFFF, but MS tools expect all 64 bits to be set.\n\n     */\n\n    dyndisk_header->data_offset = be64_to_cpu(0xFFFFFFFFFFFFFFFFULL);\n\n    dyndisk_header->table_offset = be64_to_cpu(3 * 512);\n\n    dyndisk_header->version = be32_to_cpu(0x00010000);\n\n    dyndisk_header->block_size = be32_to_cpu(block_size);\n\n    dyndisk_header->max_table_entries = be32_to_cpu(num_bat_entries);\n\n\n\n    dyndisk_header->checksum = be32_to_cpu(vpc_checksum(buf, 1024));\n\n\n\n    // Write the header\n\n    if (lseek(fd, 512, SEEK_SET) < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    if (write(fd, buf, 1024) != 1024) {\n\n        goto fail;\n\n    }\n\n    ret = 0;\n\n\n\n fail:\n\n    return ret;\n\n}\n", "idx": 11268, "_split": "test", "_hash": "97fe55b0f78fc566f62f473436ba7be7"}
{"project": "qemu", "commit_id": "b9c532903fa528891c0eceb34ea40a0c47bfb5db", "target": 0, "func": "static int qemu_rbd_snap_list(BlockDriverState *bs,\n\n                              QEMUSnapshotInfo **psn_tab)\n\n{\n\n    BDRVRBDState *s = bs->opaque;\n\n    QEMUSnapshotInfo *sn_info, *sn_tab = NULL;\n\n    int i, snap_count;\n\n    rbd_snap_info_t *snaps;\n\n    int max_snaps = RBD_MAX_SNAPS;\n\n\n\n    do {\n\n        snaps = g_malloc(sizeof(*snaps) * max_snaps);\n\n        snap_count = rbd_snap_list(s->image, snaps, &max_snaps);\n\n        if (snap_count < 0) {\n\n            g_free(snaps);\n\n        }\n\n    } while (snap_count == -ERANGE);\n\n\n\n    if (snap_count <= 0) {\n\n        return snap_count;\n\n    }\n\n\n\n    sn_tab = g_malloc0(snap_count * sizeof(QEMUSnapshotInfo));\n\n\n\n    for (i = 0; i < snap_count; i++) {\n\n        const char *snap_name = snaps[i].name;\n\n\n\n        sn_info = sn_tab + i;\n\n        pstrcpy(sn_info->id_str, sizeof(sn_info->id_str), snap_name);\n\n        pstrcpy(sn_info->name, sizeof(sn_info->name), snap_name);\n\n\n\n        sn_info->vm_state_size = snaps[i].size;\n\n        sn_info->date_sec = 0;\n\n        sn_info->date_nsec = 0;\n\n        sn_info->vm_clock_nsec = 0;\n\n    }\n\n    rbd_snap_list_end(snaps);\n\n\n\n    *psn_tab = sn_tab;\n\n    return snap_count;\n\n}\n", "idx": 11303, "_split": "test", "_hash": "388d8531125391442f47c8a2271b467e"}
{"project": "qemu", "commit_id": "62c58ee0b24eafb44c06402fe059fbd7972eb409", "target": 0, "func": "static bool get_phys_addr_pmsav8(CPUARMState *env, uint32_t address,\n\n                                 MMUAccessType access_type, ARMMMUIdx mmu_idx,\n\n                                 hwaddr *phys_ptr, int *prot, uint32_t *fsr)\n\n{\n\n    ARMCPU *cpu = arm_env_get_cpu(env);\n\n    bool is_user = regime_is_user(env, mmu_idx);\n\n    int n;\n\n    int matchregion = -1;\n\n    bool hit = false;\n\n\n\n    *phys_ptr = address;\n\n    *prot = 0;\n\n\n\n    /* Unlike the ARM ARM pseudocode, we don't need to check whether this\n\n     * was an exception vector read from the vector table (which is always\n\n     * done using the default system address map), because those accesses\n\n     * are done in arm_v7m_load_vector(), which always does a direct\n\n     * read using address_space_ldl(), rather than going via this function.\n\n     */\n\n    if (regime_translation_disabled(env, mmu_idx)) { /* MPU disabled */\n\n        hit = true;\n\n    } else if (m_is_ppb_region(env, address)) {\n\n        hit = true;\n\n    } else if (pmsav7_use_background_region(cpu, mmu_idx, is_user)) {\n\n        hit = true;\n\n    } else {\n\n        for (n = (int)cpu->pmsav7_dregion - 1; n >= 0; n--) {\n\n            /* region search */\n\n            /* Note that the base address is bits [31:5] from the register\n\n             * with bits [4:0] all zeroes, but the limit address is bits\n\n             * [31:5] from the register with bits [4:0] all ones.\n\n             */\n\n            uint32_t base = env->pmsav8.rbar[n] & ~0x1f;\n\n            uint32_t limit = env->pmsav8.rlar[n] | 0x1f;\n\n\n\n            if (!(env->pmsav8.rlar[n] & 0x1)) {\n\n                /* Region disabled */\n\n                continue;\n\n            }\n\n\n\n            if (address < base || address > limit) {\n\n                continue;\n\n            }\n\n\n\n            if (hit) {\n\n                /* Multiple regions match -- always a failure (unlike\n\n                 * PMSAv7 where highest-numbered-region wins)\n\n                 */\n\n                *fsr = 0x00d; /* permission fault */\n\n                return true;\n\n            }\n\n\n\n            matchregion = n;\n\n            hit = true;\n\n\n\n            if (base & ~TARGET_PAGE_MASK) {\n\n                qemu_log_mask(LOG_UNIMP,\n\n                              \"MPU_RBAR[%d]: No support for MPU region base\"\n\n                              \"address of 0x%\" PRIx32 \". Minimum alignment is \"\n\n                              \"%d\\n\",\n\n                              n, base, TARGET_PAGE_BITS);\n\n                continue;\n\n            }\n\n            if ((limit + 1) & ~TARGET_PAGE_MASK) {\n\n                qemu_log_mask(LOG_UNIMP,\n\n                              \"MPU_RBAR[%d]: No support for MPU region limit\"\n\n                              \"address of 0x%\" PRIx32 \". Minimum alignment is \"\n\n                              \"%d\\n\",\n\n                              n, limit, TARGET_PAGE_BITS);\n\n                continue;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!hit) {\n\n        /* background fault */\n\n        *fsr = 0;\n\n        return true;\n\n    }\n\n\n\n    if (matchregion == -1) {\n\n        /* hit using the background region */\n\n        get_phys_addr_pmsav7_default(env, mmu_idx, address, prot);\n\n    } else {\n\n        uint32_t ap = extract32(env->pmsav8.rbar[matchregion], 1, 2);\n\n        uint32_t xn = extract32(env->pmsav8.rbar[matchregion], 0, 1);\n\n\n\n        if (m_is_system_region(env, address)) {\n\n            /* System space is always execute never */\n\n            xn = 1;\n\n        }\n\n\n\n        *prot = simple_ap_to_rw_prot(env, mmu_idx, ap);\n\n        if (*prot && !xn) {\n\n            *prot |= PAGE_EXEC;\n\n        }\n\n        /* We don't need to look the attribute up in the MAIR0/MAIR1\n\n         * registers because that only tells us about cacheability.\n\n         */\n\n    }\n\n\n\n    *fsr = 0x00d; /* Permission fault */\n\n    return !(*prot & (1 << access_type));\n\n}\n", "idx": 11316, "_split": "test", "_hash": "1191953a8e764566bfc265f13c18eeb2"}
{"project": "qemu", "commit_id": "7e55d65c56a03dcd2c5d7c49d37c5a74b55d4bd6", "target": 1, "func": "static int v9fs_xattr_read(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp,\n\n                           uint64_t off, uint32_t max_count)\n\n{\n\n    ssize_t err;\n\n    size_t offset = 7;\n\n    int read_count;\n\n    int64_t xattr_len;\n\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n\n    VirtQueueElement *elem = v->elems[pdu->idx];\n\n\n\n    xattr_len = fidp->fs.xattr.len;\n\n    read_count = xattr_len - off;\n\n    if (read_count > max_count) {\n\n        read_count = max_count;\n\n    } else if (read_count < 0) {\n\n        /*\n\n         * read beyond XATTR value\n\n         */\n\n        read_count = 0;\n\n    }\n\n    err = pdu_marshal(pdu, offset, \"d\", read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n\n\n    err = v9fs_pack(elem->in_sg, elem->in_num, offset,\n\n                    ((char *)fidp->fs.xattr.value) + off,\n\n                    read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n    return offset;\n\n}\n", "idx": 11328, "_split": "test", "_hash": "7f63fde3064cedee9e56770b8e45dff6"}
{"project": "qemu", "commit_id": "cdeaf1f15909e2e8af38f45aea7cfa467a729c52", "target": 1, "func": "static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num,\n\n                                      const uint8_t *buf, int nb_sectors)\n\n{\n\n    int ret;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = vmdk_write(bs, sector_num, buf, nb_sectors);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    return ret;\n\n}\n", "idx": 11334, "_split": "test", "_hash": "43126cfa6d5d54e99c27fd0bab47b967"}
{"project": "qemu", "commit_id": "968fc24d843c9e9b24231ca1960b47ef2fc724ea", "target": 1, "func": "int xbzrle_encode_buffer(uint8_t *old_buf, uint8_t *new_buf, int slen,\n\n                         uint8_t *dst, int dlen)\n\n{\n\n    uint32_t zrun_len = 0, nzrun_len = 0;\n\n    int d = 0, i = 0;\n\n    long res, xor;\n\n    uint8_t *nzrun_start = NULL;\n\n\n\n    g_assert(!(((uintptr_t)old_buf | (uintptr_t)new_buf | slen) %\n\n               sizeof(long)));\n\n\n\n    while (i < slen) {\n\n        /* overflow */\n\n        if (d + 2 > dlen) {\n\n            return -1;\n\n        }\n\n\n\n        /* not aligned to sizeof(long) */\n\n        res = (slen - i) % sizeof(long);\n\n        while (res && old_buf[i] == new_buf[i]) {\n\n            zrun_len++;\n\n            i++;\n\n            res--;\n\n        }\n\n\n\n        /* word at a time for speed */\n\n        if (!res) {\n\n            while (i < slen &&\n\n                   (*(long *)(old_buf + i)) == (*(long *)(new_buf + i))) {\n\n                i += sizeof(long);\n\n                zrun_len += sizeof(long);\n\n            }\n\n\n\n            /* go over the rest */\n\n            while (i < slen && old_buf[i] == new_buf[i]) {\n\n                zrun_len++;\n\n                i++;\n\n            }\n\n        }\n\n\n\n        /* buffer unchanged */\n\n        if (zrun_len == slen) {\n\n            return 0;\n\n        }\n\n\n\n        /* skip last zero run */\n\n        if (i == slen) {\n\n            return d;\n\n        }\n\n\n\n        d += uleb128_encode_small(dst + d, zrun_len);\n\n\n\n        zrun_len = 0;\n\n        nzrun_start = new_buf + i;\n\n\n\n        /* overflow */\n\n        if (d + 2 > dlen) {\n\n            return -1;\n\n        }\n\n        /* not aligned to sizeof(long) */\n\n        res = (slen - i) % sizeof(long);\n\n        while (res && old_buf[i] != new_buf[i]) {\n\n            i++;\n\n            nzrun_len++;\n\n            res--;\n\n        }\n\n\n\n        /* word at a time for speed, use of 32-bit long okay */\n\n        if (!res) {\n\n            /* truncation to 32-bit long okay */\n\n            long mask = (long)0x0101010101010101ULL;\n\n            while (i < slen) {\n\n                xor = *(long *)(old_buf + i) ^ *(long *)(new_buf + i);\n\n                if ((xor - mask) & ~xor & (mask << 7)) {\n\n                    /* found the end of an nzrun within the current long */\n\n                    while (old_buf[i] != new_buf[i]) {\n\n                        nzrun_len++;\n\n                        i++;\n\n                    }\n\n                    break;\n\n                } else {\n\n                    i += sizeof(long);\n\n                    nzrun_len += sizeof(long);\n\n                }\n\n            }\n\n        }\n\n\n\n        d += uleb128_encode_small(dst + d, nzrun_len);\n\n        /* overflow */\n\n        if (d + nzrun_len > dlen) {\n\n            return -1;\n\n        }\n\n        memcpy(dst + d, nzrun_start, nzrun_len);\n\n        d += nzrun_len;\n\n        nzrun_len = 0;\n\n    }\n\n\n\n    return d;\n\n}\n", "idx": 11359, "_split": "test", "_hash": "edf91438190451a283d2dc561caf3070"}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "static void gd_resize(DisplayChangeListener *dcl,\n\n                      DisplayState *ds)\n\n{\n\n    GtkDisplayState *s = ds->opaque;\n\n    cairo_format_t kind;\n\n    int stride;\n\n\n\n    DPRINTF(\"resize(width=%d, height=%d)\\n\",\n\n            ds_get_width(ds), ds_get_height(ds));\n\n\n\n    if (s->surface) {\n\n        cairo_surface_destroy(s->surface);\n\n    }\n\n\n\n    switch (ds->surface->pf.bits_per_pixel) {\n\n    case 8:\n\n        kind = CAIRO_FORMAT_A8;\n\n        break;\n\n    case 16:\n\n        kind = CAIRO_FORMAT_RGB16_565;\n\n        break;\n\n    case 32:\n\n        kind = CAIRO_FORMAT_RGB24;\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n        break;\n\n    }\n\n\n\n    stride = cairo_format_stride_for_width(kind, ds_get_width(ds));\n\n    g_assert(ds_get_linesize(ds) == stride);\n\n\n\n    s->surface = cairo_image_surface_create_for_data(ds_get_data(ds),\n\n                                                     kind,\n\n                                                     ds_get_width(ds),\n\n                                                     ds_get_height(ds),\n\n                                                     ds_get_linesize(ds));\n\n\n\n    if (!s->full_screen) {\n\n        GtkRequisition req;\n\n        double sx, sy;\n\n\n\n        if (s->free_scale) {\n\n            sx = s->scale_x;\n\n            sy = s->scale_y;\n\n\n\n            s->scale_y = 1.0;\n\n            s->scale_x = 1.0;\n\n        } else {\n\n            sx = 1.0;\n\n            sy = 1.0;\n\n        }\n\n\n\n        gtk_widget_set_size_request(s->drawing_area,\n\n                                    ds_get_width(ds) * s->scale_x,\n\n                                    ds_get_height(ds) * s->scale_y);\n\n#if GTK_CHECK_VERSION(3, 0, 0)\n\n        gtk_widget_get_preferred_size(s->vbox, NULL, &req);\n\n#else\n\n        gtk_widget_size_request(s->vbox, &req);\n\n#endif\n\n\n\n        gtk_window_resize(GTK_WINDOW(s->window),\n\n                          req.width * sx, req.height * sy);\n\n    }\n\n}\n", "idx": 11368, "_split": "test", "_hash": "5d482d9762924cb65ec30d9fd1cba6c4"}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)\n\n{\n\n    LM32JuartState *s = LM32_JUART(d);\n\n    unsigned char ch = jtx & 0xff;\n\n\n\n    trace_lm32_juart_set_jtx(s->jtx);\n\n\n\n    s->jtx = jtx;\n\n    if (s->chr) {\n\n\n\n        qemu_chr_fe_write_all(s->chr, &ch, 1);\n\n    }\n\n}", "idx": 11381, "_split": "test", "_hash": "1717bb33451da2adca033e64e9a982ab"}
{"project": "qemu", "commit_id": "2a0c46da967e5dc8cfe73b1b6fe7a1600c04f461", "target": 0, "func": "send_msg(\n\n    VSCMsgType type,\n\n    uint32_t reader_id,\n\n    const void *msg,\n\n    unsigned int length\n\n) {\n\n    VSCMsgHeader mhHeader;\n\n\n\n    qemu_mutex_lock(&socket_to_send_lock);\n\n\n\n    if (verbose > 10) {\n\n        printf(\"sending type=%d id=%u, len =%u (0x%x)\\n\",\n\n               type, reader_id, length, length);\n\n    }\n\n\n\n    mhHeader.type = htonl(type);\n\n    mhHeader.reader_id = 0;\n\n    mhHeader.length = htonl(length);\n\n    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));\n\n    g_byte_array_append(socket_to_send, (guint8 *)msg, length);\n\n    g_idle_add(socket_prepare_sending, NULL);\n\n\n\n    qemu_mutex_unlock(&socket_to_send_lock);\n\n\n\n    return 0;\n\n}\n", "idx": 11400, "_split": "test", "_hash": "aa597a588aa89d4aadb15ec4579b1d4d"}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static uint64_t boston_platreg_read(void *opaque, hwaddr addr,\n\n                                    unsigned size)\n\n{\n\n    BostonState *s = opaque;\n\n    uint32_t gic_freq, val;\n\n\n\n    if (size != 4) {\n\n        qemu_log_mask(LOG_UNIMP, \"%uB platform register read\", size);\n\n        return 0;\n\n    }\n\n\n\n    switch (addr & 0xffff) {\n\n    case PLAT_FPGA_BUILD:\n\n    case PLAT_CORE_CL:\n\n    case PLAT_WRAPPER_CL:\n\n        return 0;\n\n    case PLAT_DDR3_STATUS:\n\n        return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED;\n\n    case PLAT_MMCM_DIV:\n\n        gic_freq = mips_gictimer_get_freq(s->cps->gic.gic_timer) / 1000000;\n\n        val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT;\n\n        val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT;\n\n        val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT;\n\n        val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT;\n\n        return val;\n\n    case PLAT_BUILD_CFG:\n\n        val = PLAT_BUILD_CFG_PCIE0_EN;\n\n        val |= PLAT_BUILD_CFG_PCIE1_EN;\n\n        val |= PLAT_BUILD_CFG_PCIE2_EN;\n\n        return val;\n\n    case PLAT_DDR_CFG:\n\n        val = s->mach->ram_size / G_BYTE;\n\n        assert(!(val & ~PLAT_DDR_CFG_SIZE));\n\n        val |= PLAT_DDR_CFG_MHZ;\n\n        return val;\n\n    default:\n\n        qemu_log_mask(LOG_UNIMP, \"Read platform register 0x%\" HWADDR_PRIx,\n\n                      addr & 0xffff);\n\n        return 0;\n\n    }\n\n}\n", "idx": 11439, "_split": "test", "_hash": "ca701ab1cece481dde3853f76b3fe0ef"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qmp_migrate_cancel(Error **errp)\n\n{\n\n    migrate_fd_cancel(migrate_get_current());\n\n}\n", "idx": 11449, "_split": "test", "_hash": "8c7f60feeca952c5ce318466cac7e516"}
{"project": "qemu", "commit_id": "eefff991d059d299b917627d2a95bce34d2f97f3", "target": 1, "func": "int load_snapshot(const char *name, Error **errp)\n\n{\n\n    BlockDriverState *bs, *bs_vm_state;\n\n    QEMUSnapshotInfo sn;\n\n    QEMUFile *f;\n\n    int ret;\n\n    AioContext *aio_context;\n\n    MigrationIncomingState *mis = migration_incoming_get_current();\n\n\n\n    if (!bdrv_all_can_snapshot(&bs)) {\n\n        error_setg(errp,\n\n                   \"Device '%s' is writable but does not support snapshots\",\n\n                   bdrv_get_device_name(bs));\n\n        return -ENOTSUP;\n\n    }\n\n    ret = bdrv_all_find_snapshot(name, &bs);\n\n    if (ret < 0) {\n\n        error_setg(errp,\n\n                   \"Device '%s' does not have the requested snapshot '%s'\",\n\n                   bdrv_get_device_name(bs), name);\n\n        return ret;\n\n    }\n\n\n\n    bs_vm_state = bdrv_all_find_vmstate_bs();\n\n    if (!bs_vm_state) {\n\n        error_setg(errp, \"No block device supports snapshots\");\n\n        return -ENOTSUP;\n\n    }\n\n    aio_context = bdrv_get_aio_context(bs_vm_state);\n\n\n\n    /* Don't even try to load empty VM states */\n\n    aio_context_acquire(aio_context);\n\n    ret = bdrv_snapshot_find(bs_vm_state, &sn, name);\n\n    aio_context_release(aio_context);\n\n    if (ret < 0) {\n\n        return ret;\n\n    } else if (sn.vm_state_size == 0) {\n\n        error_setg(errp, \"This is a disk-only snapshot. Revert to it \"\n\n                   \" offline using qemu-img\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Flush all IO requests so they don't interfere with the new state.  */\n\n    bdrv_drain_all();\n\n\n\n    ret = bdrv_all_goto_snapshot(name, &bs);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Error %d while activating snapshot '%s' on '%s'\",\n\n                     ret, name, bdrv_get_device_name(bs));\n\n        return ret;\n\n    }\n\n\n\n    /* restore the VM state */\n\n    f = qemu_fopen_bdrv(bs_vm_state, 0);\n\n    if (!f) {\n\n        error_setg(errp, \"Could not open VM state file\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    qemu_system_reset(SHUTDOWN_CAUSE_NONE);\n\n    mis->from_src_file = f;\n\n\n\n    aio_context_acquire(aio_context);\n\n    ret = qemu_loadvm_state(f);\n\n    qemu_fclose(f);\n\n    aio_context_release(aio_context);\n\n\n\n    migration_incoming_state_destroy();\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Error %d while loading VM state\", ret);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11455, "_split": "test", "_hash": "f804b2d7a399ca0c4bd8c34769ecac20"}
{"project": "qemu", "commit_id": "9e14037f05e99ca3b8a33d8be9a2a636bbf09326", "target": 1, "func": "static void msmouse_chr_close (struct CharDriverState *chr)\n\n{\n\n    MouseState *mouse = chr->opaque;\n\n\n\n    qemu_input_handler_unregister(mouse->hs);\n\n    g_free(mouse);\n\n    g_free(chr);\n\n}\n", "idx": 11501, "_split": "test", "_hash": "f5e4b94f5a7af9c845c28814eb99d22d"}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "int qemu_init_main_loop(void)\n\n{\n\n    int ret;\n\n\n\n    ret = qemu_signal_init();\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    qemu_init_sigbus();\n\n\n\n    return qemu_event_init();\n\n}\n", "idx": 11516, "_split": "test", "_hash": "8c2efff1f2804fb98d254cbb131fa9ac"}
{"project": "qemu", "commit_id": "459db780be10f7adac723a5d3a4ffeac8ae6e768", "target": 1, "func": "envlist_parse(envlist_t *envlist, const char *env,\n\n    int (*callback)(envlist_t *, const char *))\n\n{\n\n\tchar *tmpenv, *envvar;\n\n\tchar *envsave = NULL;\n\n\n\n\tassert(callback != NULL);\n\n\n\n\tif ((envlist == NULL) || (env == NULL))\n\n\t\treturn (EINVAL);\n\n\n\n\t/*\n\n\t * We need to make temporary copy of the env string\n\n\t * as strtok_r(3) modifies it while it tokenizes.\n\n\t */\n\n\tif ((tmpenv = strdup(env)) == NULL)\n\n\t\treturn (errno);\n\n\n\n\tenvvar = strtok_r(tmpenv, \",\", &envsave);\n\n\twhile (envvar != NULL) {\n\n\t\tif ((*callback)(envlist, envvar) != 0) {\n\n\t\t\tfree(tmpenv);\n\n\t\t\treturn (errno);\n\n\t\t}\n\n\t\tenvvar = strtok_r(NULL, \",\", &envsave);\n\n\t}\n\n\n\n\tfree(tmpenv);\n\n\treturn (0);\n\n}\n", "idx": 11524, "_split": "test", "_hash": "6f8e618ed4add7dcd2e60fd38f1bec17"}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_neon_trn_u16(TCGv t0, TCGv t1)\n\n{\n\n    TCGv rd, tmp;\n\n\n\n    rd = new_tmp();\n\n    tmp = new_tmp();\n\n\n\n    tcg_gen_shli_i32(rd, t0, 16);\n\n    tcg_gen_andi_i32(tmp, t1, 0xffff);\n\n    tcg_gen_or_i32(rd, rd, tmp);\n\n    tcg_gen_shri_i32(t1, t1, 16);\n\n    tcg_gen_andi_i32(tmp, t0, 0xffff0000);\n\n    tcg_gen_or_i32(t1, t1, tmp);\n\n    tcg_gen_mov_i32(t0, rd);\n\n\n\n    dead_tmp(tmp);\n\n    dead_tmp(rd);\n\n}\n", "idx": 11546, "_split": "test", "_hash": "3e577007d64adc114d2a24335601af91"}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "restore_sigcontext(CPUMIPSState *regs, struct target_sigcontext *sc)\n\n{\n\n    int err = 0;\n\n    int i;\n\n\n\n    __get_user(regs->CP0_EPC, &sc->sc_pc);\n\n\n\n    __get_user(regs->active_tc.HI[0], &sc->sc_mdhi);\n\n    __get_user(regs->active_tc.LO[0], &sc->sc_mdlo);\n\n\n\n    for (i = 1; i < 32; ++i) {\n\n        __get_user(regs->active_tc.gpr[i], &sc->sc_regs[i]);\n\n    }\n\n\n\n    __get_user(regs->active_tc.HI[1], &sc->sc_hi1);\n\n    __get_user(regs->active_tc.HI[2], &sc->sc_hi2);\n\n    __get_user(regs->active_tc.HI[3], &sc->sc_hi3);\n\n    __get_user(regs->active_tc.LO[1], &sc->sc_lo1);\n\n    __get_user(regs->active_tc.LO[2], &sc->sc_lo2);\n\n    __get_user(regs->active_tc.LO[3], &sc->sc_lo3);\n\n    {\n\n        uint32_t dsp;\n\n        __get_user(dsp, &sc->sc_dsp);\n\n        cpu_wrdsp(dsp, 0x3ff, regs);\n\n    }\n\n\n\n    for (i = 0; i < 32; ++i) {\n\n        __get_user(regs->active_fpu.fpr[i].d, &sc->sc_fpregs[i]);\n\n    }\n\n\n\n    return err;\n\n}\n", "idx": 11566, "_split": "test", "_hash": "5108002986e3bf13f17d830e1743d0f9"}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static void sdhci_write_block_to_card(SDHCIState *s)\n\n{\n\n    int index = 0;\n\n\n\n    if (s->prnsts & SDHC_SPACE_AVAILABLE) {\n\n        if (s->norintstsen & SDHC_NISEN_WBUFRDY) {\n\n            s->norintsts |= SDHC_NIS_WBUFRDY;\n\n        }\n\n        sdhci_update_irq(s);\n\n        return;\n\n    }\n\n\n\n    if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {\n\n        if (s->blkcnt == 0) {\n\n            return;\n\n        } else {\n\n            s->blkcnt--;\n\n        }\n\n    }\n\n\n\n    for (index = 0; index < (s->blksize & 0x0fff); index++) {\n\n        sd_write_data(s->card, s->fifo_buffer[index]);\n\n    }\n\n\n\n    /* Next data can be written through BUFFER DATORT register */\n\n    s->prnsts |= SDHC_SPACE_AVAILABLE;\n\n\n\n    /* Finish transfer if that was the last block of data */\n\n    if ((s->trnmod & SDHC_TRNS_MULTI) == 0 ||\n\n            ((s->trnmod & SDHC_TRNS_MULTI) &&\n\n            (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) {\n\n        SDHCI_GET_CLASS(s)->end_data_transfer(s);\n\n    } else if (s->norintstsen & SDHC_NISEN_WBUFRDY) {\n\n        s->norintsts |= SDHC_NIS_WBUFRDY;\n\n    }\n\n\n\n    /* Generate Block Gap Event if requested and if not the last block */\n\n    if (s->stopped_state == sdhc_gap_write && (s->trnmod & SDHC_TRNS_MULTI) &&\n\n            s->blkcnt > 0) {\n\n        s->prnsts &= ~SDHC_DOING_WRITE;\n\n        if (s->norintstsen & SDHC_EISEN_BLKGAP) {\n\n            s->norintsts |= SDHC_EIS_BLKGAP;\n\n        }\n\n        SDHCI_GET_CLASS(s)->end_data_transfer(s);\n\n    }\n\n\n\n    sdhci_update_irq(s);\n\n}\n", "idx": 11592, "_split": "test", "_hash": "d464fdde8d4f2a254a2a5c927d1d7749"}
{"project": "qemu", "commit_id": "debaaa114a8877a939533ba846e64168fb287b7b", "target": 0, "func": "static AHCIQState *ahci_boot(void)\n\n{\n\n    AHCIQState *s;\n\n    const char *cli;\n\n\n\n    s = g_malloc0(sizeof(AHCIQState));\n\n\n\n    cli = \"-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s\"\n\n        \",format=qcow2\"\n\n        \" -M q35 \"\n\n        \"-device ide-hd,drive=drive0 \"\n\n        \"-global ide-hd.ver=%s\";\n\n    s->parent = qtest_pc_boot(cli, tmp_path, \"testdisk\", \"version\");\n\n    alloc_set_flags(s->parent->alloc, ALLOC_LEAK_ASSERT);\n\n\n\n    /* Verify that we have an AHCI device present. */\n\n    s->dev = get_ahci_device(&s->fingerprint);\n\n\n\n    return s;\n\n}\n", "idx": 11608, "_split": "test", "_hash": "69319b55651020f20b627274addd2bce"}
{"project": "qemu", "commit_id": "89ae337acbe4dba5b2481007aec1277252d2b86c", "target": 0, "func": "void address_space_destroy_dispatch(AddressSpace *as)\n\n{\n\n    AddressSpaceDispatch *d = as->dispatch;\n\n\n\n    memory_listener_unregister(&d->listener);\n\n    g_free(d);\n\n    as->dispatch = NULL;\n\n}\n", "idx": 11624, "_split": "test", "_hash": "df3002b2b4973d442ff857e2a6fca857"}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "mst_fpga_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n\tmst_irq_state *s = (mst_irq_state *) opaque;\n\n\n\n\tswitch (addr) {\n\n\tcase MST_LEDDAT1:\n\n\t\treturn s->leddat1;\n\n\tcase MST_LEDDAT2:\n\n\t\treturn s->leddat2;\n\n\tcase MST_LEDCTRL:\n\n\t\treturn s->ledctrl;\n\n\tcase MST_GPSWR:\n\n\t\treturn s->gpswr;\n\n\tcase MST_MSCWR1:\n\n\t\treturn s->mscwr1;\n\n\tcase MST_MSCWR2:\n\n\t\treturn s->mscwr2;\n\n\tcase MST_MSCWR3:\n\n\t\treturn s->mscwr3;\n\n\tcase MST_MSCRD:\n\n\t\treturn s->mscrd;\n\n\tcase MST_INTMSKENA:\n\n\t\treturn s->intmskena;\n\n\tcase MST_INTSETCLR:\n\n\t\treturn s->intsetclr;\n\n\tcase MST_PCMCIA0:\n\n\t\treturn s->pcmcia0;\n\n\tcase MST_PCMCIA1:\n\n\t\treturn s->pcmcia1;\n\n\tdefault:\n\n\t\tprintf(\"Mainstone - mst_fpga_readb: Bad register offset \"\n\n\t\t\t\"0x\" TARGET_FMT_plx \" \\n\", addr);\n\n\t}\n\n\treturn 0;\n\n}\n", "idx": 11631, "_split": "test", "_hash": "45c21f47794fe1a350c1f84c729fbf65"}
{"project": "qemu", "commit_id": "25f8e2f512d87f0a77fc5c0b367dd200a7834d21", "target": 0, "func": "static int pci_piix_ide_initfn(PCIIDEState *d)\n\n{\n\n    uint8_t *pci_conf = d->dev.config;\n\n\n\n    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode\n\n    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);\n\n\n\n    qemu_register_reset(piix3_reset, d);\n\n\n\n    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);\n\n\n\n    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);\n\n\n\n    pci_piix_init_ports(d);\n\n\n\n    return 0;\n\n}\n", "idx": 11635, "_split": "test", "_hash": "d166e146ccd756eaac9f39dc12e77ade"}
{"project": "qemu", "commit_id": "da3e8a23492dbc13c4b70d90b6ae42970624e63a", "target": 0, "func": "static void virtio_net_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)\n\n{\n\n    DeviceState *qdev = DEVICE(vpci_dev);\n\n    VirtIONetPCI *dev = VIRTIO_NET_PCI(vpci_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n\n\n    virtio_net_set_config_size(&dev->vdev, vpci_dev->host_features);\n\n    virtio_net_set_netclient_name(&dev->vdev, qdev->id,\n\n                                  object_get_typename(OBJECT(qdev)));\n\n    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));\n\n    object_property_set_bool(OBJECT(vdev), true, \"realized\", errp);\n\n}\n", "idx": 11641, "_split": "test", "_hash": "416c99ff9ec656569766319b8addf1c4"}
{"project": "qemu", "commit_id": "052495178821fdc97b4125a8677c1b68eb458db9", "target": 0, "func": "static void spapr_nvram_realize(VIOsPAPRDevice *dev, Error **errp)\n\n{\n\n    sPAPRNVRAM *nvram = VIO_SPAPR_NVRAM(dev);\n\n    int ret;\n\n\n\n    if (nvram->blk) {\n\n        nvram->size = blk_getlength(nvram->blk);\n\n\n\n        ret = blk_set_perm(nvram->blk,\n\n                           BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE,\n\n                           BLK_PERM_ALL, errp);\n\n        if (ret < 0) {\n\n            return;\n\n        }\n\n    } else {\n\n        nvram->size = DEFAULT_NVRAM_SIZE;\n\n    }\n\n\n\n    nvram->buf = g_malloc0(nvram->size);\n\n\n\n    if ((nvram->size < MIN_NVRAM_SIZE) || (nvram->size > MAX_NVRAM_SIZE)) {\n\n        error_setg(errp, \"spapr-nvram must be between %d and %d bytes in size\",\n\n                   MIN_NVRAM_SIZE, MAX_NVRAM_SIZE);\n\n        return;\n\n    }\n\n\n\n    if (nvram->blk) {\n\n        int alen = blk_pread(nvram->blk, 0, nvram->buf, nvram->size);\n\n\n\n        if (alen != nvram->size) {\n\n            error_setg(errp, \"can't read spapr-nvram contents\");\n\n            return;\n\n        }\n\n    } else if (nb_prom_envs > 0) {\n\n        /* Create a system partition to pass the -prom-env variables */\n\n        chrp_nvram_create_system_partition(nvram->buf, MIN_NVRAM_SIZE / 4);\n\n        chrp_nvram_create_free_partition(&nvram->buf[MIN_NVRAM_SIZE / 4],\n\n                                         nvram->size - MIN_NVRAM_SIZE / 4);\n\n    }\n\n\n\n    spapr_rtas_register(RTAS_NVRAM_FETCH, \"nvram-fetch\", rtas_nvram_fetch);\n\n    spapr_rtas_register(RTAS_NVRAM_STORE, \"nvram-store\", rtas_nvram_store);\n\n}\n", "idx": 11642, "_split": "test", "_hash": "9d4082677e413527e0d00b243aef8f17"}
{"project": "qemu", "commit_id": "4b63a0df3bda8a2c278e45d9d94d9ba6d5791d8d", "target": 1, "func": "static void ehci_free_packet(EHCIPacket *p)\n\n{\n\n    trace_usb_ehci_packet_action(p->queue, p, \"free\");\n\n    if (p->async == EHCI_ASYNC_INFLIGHT) {\n\n        usb_cancel_packet(&p->packet);\n\n        usb_packet_unmap(&p->packet, &p->sgl);\n\n        qemu_sglist_destroy(&p->sgl);\n\n\n\n\n\n\n\n\n\n\n\n\n    QTAILQ_REMOVE(&p->queue->packets, p, next);\n\n    usb_packet_cleanup(&p->packet);\n\n    g_free(p);\n", "idx": 11646, "_split": "test", "_hash": "6da0b83ba507095a71903af227699234"}
{"project": "qemu", "commit_id": "a87f39543a9259f671c5413723311180ee2ad2a8", "target": 0, "func": "static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)\n\n{\n\n    if (memory_region_is_ram(mr)) {\n\n        return !(is_write && mr->readonly);\n\n    }\n\n    if (memory_region_is_romd(mr)) {\n\n        return !is_write;\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 11674, "_split": "test", "_hash": "38d8cc139f3c5f57b6afbe10f6c32940"}
{"project": "qemu", "commit_id": "9db1c0f7a94c6382e2b3e1365566a9a8b8ae74c1", "target": 0, "func": "VirtIODevice *virtio_blk_init(DeviceState *dev, VirtIOBlkConf *blk)\n\n{\n\n    VirtIOBlock *s;\n\n    int cylinders, heads, secs;\n\n    static int virtio_blk_id;\n\n    DriveInfo *dinfo;\n\n\n\n    if (!blk->conf.bs) {\n\n        error_report(\"drive property not set\");\n\n        return NULL;\n\n    }\n\n    if (!bdrv_is_inserted(blk->conf.bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return NULL;\n\n    }\n\n\n\n    if (!blk->serial) {\n\n        /* try to fall back to value set with legacy -drive serial=... */\n\n        dinfo = drive_get_by_blockdev(blk->conf.bs);\n\n        if (*dinfo->serial) {\n\n            blk->serial = strdup(dinfo->serial);\n\n        }\n\n    }\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = blk->conf.bs;\n\n    s->conf = &blk->conf;\n\n    s->blk = blk;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    s->qdev = dev;\n\n    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n\n    bdrv_set_buffer_alignment(s->bs, s->conf->logical_block_size);\n\n\n\n    bdrv_iostatus_enable(s->bs);\n\n    add_boot_device_path(s->conf->bootindex, dev, \"/disk@0,0\");\n\n\n\n    return &s->vdev;\n\n}\n", "idx": 11685, "_split": "test", "_hash": "4e169247f5f8c05ca13cf634137f626e"}
{"project": "qemu", "commit_id": "599d64f6dc10f267a45e7abebfcafd8e7626585b", "target": 1, "func": "static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                             uint64_t value)\n\n{\n\n    if (ri->crm > 8) {\n\n        return EXCP_UDEF;\n\n    }\n\n    env->cp15.c6_region[ri->crm] = value;\n\n    return 0;\n\n}\n", "idx": 11714, "_split": "test", "_hash": "445ff5cdec17af45e3cbb22841872b8a"}
{"project": "qemu", "commit_id": "036078475427f2562c8e505f6bb44dbf5d8cbd95", "target": 1, "func": "static int usb_host_open(USBHostDevice *dev, int bus_num,\n\n                         int addr, const char *port,\n\n                         const char *prod_name, int speed)\n\n{\n\n    int fd = -1, ret;\n\n\n\n    trace_usb_host_open_started(bus_num, addr);\n\n\n\n    if (dev->fd != -1) {\n\n        goto fail;\n\n    }\n\n\n\n    fd = usb_host_open_device(bus_num, addr);\n\n    if (fd < 0) {\n\n        goto fail;\n\n    }\n\n    DPRINTF(\"husb: opened %s\\n\", buf);\n\n\n\n    dev->bus_num = bus_num;\n\n    dev->addr = addr;\n\n    strcpy(dev->port, port);\n\n    dev->fd = fd;\n\n\n\n    /* read the device description */\n\n    dev->descr_len = read(fd, dev->descr, sizeof(dev->descr));\n\n    if (dev->descr_len <= 0) {\n\n        perror(\"husb: reading device data failed\");\n\n        goto fail;\n\n    }\n\n\n\n#ifdef DEBUG\n\n    {\n\n        int x;\n\n        printf(\"=== begin dumping device descriptor data ===\\n\");\n\n        for (x = 0; x < dev->descr_len; x++) {\n\n            printf(\"%02x \", dev->descr[x]);\n\n        }\n\n        printf(\"\\n=== end dumping device descriptor data ===\\n\");\n\n    }\n\n#endif\n\n\n\n\n\n    /* start unconfigured -- we'll wait for the guest to set a configuration */\n\n    if (!usb_host_claim_interfaces(dev, 0)) {\n\n        goto fail;\n\n    }\n\n\n\n    usb_ep_init(&dev->dev);\n\n    usb_linux_update_endp_table(dev);\n\n\n\n    if (speed == -1) {\n\n        struct usbdevfs_connectinfo ci;\n\n\n\n        ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci);\n\n        if (ret < 0) {\n\n            perror(\"usb_host_device_open: USBDEVFS_CONNECTINFO\");\n\n            goto fail;\n\n        }\n\n\n\n        if (ci.slow) {\n\n            speed = USB_SPEED_LOW;\n\n        } else {\n\n            speed = USB_SPEED_HIGH;\n\n        }\n\n    }\n\n    dev->dev.speed = speed;\n\n    dev->dev.speedmask = (1 << speed);\n\n    if (dev->dev.speed == USB_SPEED_HIGH && usb_linux_full_speed_compat(dev)) {\n\n        dev->dev.speedmask |= USB_SPEED_MASK_FULL;\n\n    }\n\n\n\n    trace_usb_host_open_success(bus_num, addr);\n\n\n\n    if (!prod_name || prod_name[0] == '\\0') {\n\n        snprintf(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                 \"host:%d.%d\", bus_num, addr);\n\n    } else {\n\n        pstrcpy(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                prod_name);\n\n    }\n\n\n\n    ret = usb_device_attach(&dev->dev);\n\n    if (ret) {\n\n        goto fail;\n\n    }\n\n\n\n    /* USB devio uses 'write' flag to check for async completions */\n\n    qemu_set_fd_handler(dev->fd, NULL, async_complete, dev);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    trace_usb_host_open_failure(bus_num, addr);\n\n    if (dev->fd != -1) {\n\n        close(dev->fd);\n\n        dev->fd = -1;\n\n    }\n\n    return -1;\n\n}\n", "idx": 11742, "_split": "test", "_hash": "67a1738e8d413399ce8980fd1519750f"}
{"project": "qemu", "commit_id": "fa617181839741727d0067ea68807133f498f29b", "target": 1, "func": "static int esp_pci_scsi_init(PCIDevice *dev)\n\n{\n\n    PCIESPState *pci = PCI_ESP(dev);\n\n    DeviceState *d = DEVICE(dev);\n\n    ESPState *s = &pci->esp;\n\n    uint8_t *pci_conf;\n\n    Error *err = NULL;\n\n\n\n    pci_conf = dev->config;\n\n\n\n    /* Interrupt pin A */\n\n    pci_conf[PCI_INTERRUPT_PIN] = 0x01;\n\n\n\n    s->dma_memory_read = esp_pci_dma_memory_read;\n\n    s->dma_memory_write = esp_pci_dma_memory_write;\n\n    s->dma_opaque = pci;\n\n    s->chip_id = TCHI_AM53C974;\n\n    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,\n\n                          \"esp-io\", 0x80);\n\n\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);\n\n    s->irq = pci_allocate_irq(dev);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, &err);\n\n        if (err != NULL) {\n\n\n            error_free(err);\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}", "idx": 11748, "_split": "test", "_hash": "46ce849bfb455b361b51ba9eec0b6651"}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs)\n\n{\n\n    return telldir(fs->dir);\n\n}\n", "idx": 11781, "_split": "test", "_hash": "65fa9ca7d8d4a9a1535794000dd7ba8c"}
{"project": "qemu", "commit_id": "39a611a3e035e148257af314a522a6cd169c2d0e", "target": 1, "func": "void commit_active_start(BlockDriverState *bs, BlockDriverState *base,\n\n                         int64_t speed,\n\n                         BlockdevOnError on_error,\n\n                         BlockDriverCompletionFunc *cb,\n\n                         void *opaque, Error **errp)\n\n{\n\n    int64_t length, base_length;\n\n    int orig_base_flags;\n\n\n\n    orig_base_flags = bdrv_get_flags(base);\n\n\n\n    if (bdrv_reopen(base, bs->open_flags, errp)) {\n\n        return;\n\n    }\n\n\n\n    length = bdrv_getlength(bs);\n\n    if (length < 0) {\n\n        error_setg(errp, \"Unable to determine length of %s\", bs->filename);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    base_length = bdrv_getlength(base);\n\n    if (base_length < 0) {\n\n        error_setg(errp, \"Unable to determine length of %s\", base->filename);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    if (length > base_length) {\n\n        if (bdrv_truncate(base, length) < 0) {\n\n            error_setg(errp, \"Top image %s is larger than base image %s, and \"\n\n                             \"resize of base image failed\",\n\n                             bs->filename, base->filename);\n\n            goto error_restore_flags;\n\n        }\n\n    }\n\n\n\n    bdrv_ref(base);\n\n    mirror_start_job(bs, base, speed, 0, 0,\n\n                     on_error, on_error, cb, opaque, errp,\n\n                     &commit_active_job_driver, false, base);\n\n    if (error_is_set(errp)) {\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    return;\n\n\n\nerror_restore_flags:\n\n    /* ignore error and errp for bdrv_reopen, because we want to propagate\n\n     * the original error */\n\n    bdrv_reopen(base, orig_base_flags, NULL);\n\n    return;\n\n}\n", "idx": 11810, "_split": "test", "_hash": "c3da4daa7d8210e1ae7aac4bac441870"}
{"project": "qemu", "commit_id": "ba9c5de5f2d33d468a07a8794121472ea031a0b5", "target": 0, "func": "void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,\n\n                                 bool is_write, bool is_exec, int unused,\n\n                                 unsigned size)\n\n{\n\n    AlphaCPU *cpu = ALPHA_CPU(cs);\n\n    CPUAlphaState *env = &cpu->env;\n\n\n\n    env->trap_arg0 = addr;\n\n    env->trap_arg1 = is_write ? 1 : 0;\n\n    dynamic_excp(env, 0, EXCP_MCHK, 0);\n\n}\n", "idx": 11833, "_split": "test", "_hash": "b238651287675d7dc21d05f78a159723"}
{"project": "qemu", "commit_id": "e75ccf2c033fb0503d6cb7ddd0fd1dfa0aa4fc16", "target": 0, "func": "static int virtio_serial_init_pci(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n    VirtIODevice *vdev;\n\n\n\n    if (proxy->class_code != PCI_CLASS_COMMUNICATION_OTHER &&\n\n        proxy->class_code != PCI_CLASS_DISPLAY_OTHER && /* qemu 0.10 */\n\n        proxy->class_code != PCI_CLASS_OTHERS)          /* qemu-kvm  */\n\n        proxy->class_code = PCI_CLASS_COMMUNICATION_OTHER;\n\n\n\n    vdev = virtio_serial_init(&pci_dev->qdev, &proxy->serial);\n\n    if (!vdev) {\n\n        return -1;\n\n    }\n\n    vdev->nvectors = proxy->nvectors == DEV_NVECTORS_UNSPECIFIED\n\n                                        ? proxy->serial.max_virtserial_ports + 1\n\n                                        : proxy->nvectors;\n\n    virtio_init_pci(proxy, vdev,\n\n                    PCI_VENDOR_ID_REDHAT_QUMRANET,\n\n                    PCI_DEVICE_ID_VIRTIO_CONSOLE,\n\n                    proxy->class_code, 0x00);\n\n    proxy->nvectors = vdev->nvectors;\n\n    return 0;\n\n}\n", "idx": 11834, "_split": "test", "_hash": "68d7326ccf76a7b639f8ad3382a462d3"}
{"project": "qemu", "commit_id": "130257dc443574a9da91dc293665be2cfc40245a", "target": 0, "func": "static CharDriverState *qmp_chardev_open_serial(const char *id,\n\n                                                ChardevBackend *backend,\n\n                                                ChardevReturn *ret,\n\n                                                Error **errp)\n\n{\n\n    ChardevHostdev *serial = backend->serial;\n\n    int fd;\n\n\n\n    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);\n\n    if (fd < 0) {\n\n        return NULL;\n\n    }\n\n    qemu_set_nonblock(fd);\n\n    return qemu_chr_open_tty_fd(fd);\n\n}\n", "idx": 11840, "_split": "test", "_hash": "5cdccef3d3225e6550cf3c5144cc3aea"}
{"project": "qemu", "commit_id": "a369da5f31ddbdeb32a7f76622e480d3995fbb00", "target": 0, "func": "void alpha_pci_vga_setup(PCIBus *pci_bus)\n\n{\n\n    switch (vga_interface_type) {\n\n#ifdef CONFIG_SPICE\n\n    case VGA_QXL:\n\n        pci_create_simple(pci_bus, -1, \"qxl-vga\");\n\n        return;\n\n#endif\n\n    case VGA_CIRRUS:\n\n        pci_cirrus_vga_init(pci_bus);\n\n        return;\n\n    case VGA_VMWARE:\n\n        if (pci_vmsvga_init(pci_bus)) {\n\n            return;\n\n        }\n\n        break;\n\n    }\n\n    /* If VGA is enabled at all, and one of the above didn't work, then\n\n       fallback to Standard VGA.  */\n\n    if (vga_interface_type != VGA_NONE) {\n\n        pci_vga_init(pci_bus);\n\n    }\n\n}\n", "idx": 11843, "_split": "test", "_hash": "02562c028b2c32eb8509f1d1c100f4dc"}
{"project": "qemu", "commit_id": "75554a3ca10a7ad295d2a3d2e14ee6ba90f94c8b", "target": 0, "func": "struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *ta,\n\n                qemu_irq irq, omap_clk fclk, omap_clk iclk,\n\n                qemu_irq txdma, qemu_irq rxdma, CharDriverState *chr)\n\n{\n\n    target_phys_addr_t base = omap_l4_attach(ta, 0, 0);\n\n    struct omap_uart_s *s = omap_uart_init(base, irq,\n\n                    fclk, iclk, txdma, rxdma, chr);\n\n    int iomemtype = cpu_register_io_memory(0, omap_uart_readfn,\n\n                    omap_uart_writefn, s);\n\n\n\n    s->ta = ta;\n\n    s->base = base;\n\n\n\n    cpu_register_physical_memory(s->base + 0x20, 0x100, iomemtype);\n\n\n\n    return s;\n\n}\n", "idx": 11844, "_split": "test", "_hash": "2704e7f7e562fdca1f1689c6c9cea97f"}
{"project": "qemu", "commit_id": "6e6e55f5c2e5b520d6506c2716287ba3b5d1bbc8", "target": 0, "func": "static void QEMU_NORETURN help(void)\n\n{\n\n    const char *help_msg =\n\n           QEMU_IMG_VERSION\n\n           \"usage: qemu-img [standard options] command [command options]\\n\"\n\n           \"QEMU disk image utility\\n\"\n\n           \"\\n\"\n\n           \"    '-h', '--help'       display this help and exit\\n\"\n\n           \"    '-V', '--version'    output version information and exit\\n\"\n\n           \"    '-T', '--trace'      [[enable=]<pattern>][,events=<file>][,file=<file>]\\n\"\n\n           \"                         specify tracing options\\n\"\n\n           \"\\n\"\n\n           \"Command syntax:\\n\"\n\n#define DEF(option, callback, arg_string)        \\\n\n           \"  \" arg_string \"\\n\"\n\n#include \"qemu-img-cmds.h\"\n\n#undef DEF\n\n#undef GEN_DOCS\n\n           \"\\n\"\n\n           \"Command parameters:\\n\"\n\n           \"  'filename' is a disk image filename\\n\"\n\n           \"  'objectdef' is a QEMU user creatable object definition. See the qemu(1)\\n\"\n\n           \"    manual page for a description of the object properties. The most common\\n\"\n\n           \"    object type is a 'secret', which is used to supply passwords and/or\\n\"\n\n           \"    encryption keys.\\n\"\n\n           \"  'fmt' is the disk image format. It is guessed automatically in most cases\\n\"\n\n           \"  'cache' is the cache mode used to write the output disk image, the valid\\n\"\n\n           \"    options are: 'none', 'writeback' (default, except for convert), 'writethrough',\\n\"\n\n           \"    'directsync' and 'unsafe' (default for convert)\\n\"\n\n           \"  'src_cache' is the cache mode used to read input disk images, the valid\\n\"\n\n           \"    options are the same as for the 'cache' option\\n\"\n\n           \"  'size' is the disk image size in bytes. Optional suffixes\\n\"\n\n           \"    'k' or 'K' (kilobyte, 1024), 'M' (megabyte, 1024k), 'G' (gigabyte, 1024M),\\n\"\n\n           \"    'T' (terabyte, 1024G), 'P' (petabyte, 1024T) and 'E' (exabyte, 1024P)  are\\n\"\n\n           \"    supported. 'b' is ignored.\\n\"\n\n           \"  'output_filename' is the destination disk image filename\\n\"\n\n           \"  'output_fmt' is the destination format\\n\"\n\n           \"  'options' is a comma separated list of format specific options in a\\n\"\n\n           \"    name=value format. Use -o ? for an overview of the options supported by the\\n\"\n\n           \"    used format\\n\"\n\n           \"  'snapshot_param' is param used for internal snapshot, format\\n\"\n\n           \"    is 'snapshot.id=[ID],snapshot.name=[NAME]', or\\n\"\n\n           \"    '[ID_OR_NAME]'\\n\"\n\n           \"  'snapshot_id_or_name' is deprecated, use 'snapshot_param'\\n\"\n\n           \"    instead\\n\"\n\n           \"  '-c' indicates that target image must be compressed (qcow format only)\\n\"\n\n           \"  '-u' enables unsafe rebasing. It is assumed that old and new backing file\\n\"\n\n           \"       match exactly. The image doesn't need a working backing file before\\n\"\n\n           \"       rebasing in this case (useful for renaming the backing file)\\n\"\n\n           \"  '-h' with or without a command shows this help and lists the supported formats\\n\"\n\n           \"  '-p' show progress of command (only certain commands)\\n\"\n\n           \"  '-q' use Quiet mode - do not print any output (except errors)\\n\"\n\n           \"  '-S' indicates the consecutive number of bytes (defaults to 4k) that must\\n\"\n\n           \"       contain only zeros for qemu-img to create a sparse image during\\n\"\n\n           \"       conversion. If the number of bytes is 0, the source will not be scanned for\\n\"\n\n           \"       unallocated or zero sectors, and the destination image will always be\\n\"\n\n           \"       fully allocated\\n\"\n\n           \"  '--output' takes the format in which the output must be done (human or json)\\n\"\n\n           \"  '-n' skips the target volume creation (useful if the volume is created\\n\"\n\n           \"       prior to running qemu-img)\\n\"\n\n           \"\\n\"\n\n           \"Parameters to check subcommand:\\n\"\n\n           \"  '-r' tries to repair any inconsistencies that are found during the check.\\n\"\n\n           \"       '-r leaks' repairs only cluster leaks, whereas '-r all' fixes all\\n\"\n\n           \"       kinds of errors, with a higher risk of choosing the wrong fix or\\n\"\n\n           \"       hiding corruption that has already occurred.\\n\"\n\n           \"\\n\"\n\n           \"Parameters to convert subcommand:\\n\"\n\n           \"  '-m' specifies how many coroutines work in parallel during the convert\\n\"\n\n           \"       process (defaults to 8)\\n\"\n\n           \"  '-W' allow to write to the target out of order rather than sequential\\n\"\n\n           \"\\n\"\n\n           \"Parameters to snapshot subcommand:\\n\"\n\n           \"  'snapshot' is the name of the snapshot to create, apply or delete\\n\"\n\n           \"  '-a' applies a snapshot (revert disk to saved state)\\n\"\n\n           \"  '-c' creates a snapshot\\n\"\n\n           \"  '-d' deletes a snapshot\\n\"\n\n           \"  '-l' lists all snapshots in the given image\\n\"\n\n           \"\\n\"\n\n           \"Parameters to compare subcommand:\\n\"\n\n           \"  '-f' first image format\\n\"\n\n           \"  '-F' second image format\\n\"\n\n           \"  '-s' run in Strict mode - fail on different image size or sector allocation\\n\"\n\n           \"\\n\"\n\n           \"Parameters to dd subcommand:\\n\"\n\n           \"  'bs=BYTES' read and write up to BYTES bytes at a time \"\n\n           \"(default: 512)\\n\"\n\n           \"  'count=N' copy only N input blocks\\n\"\n\n           \"  'if=FILE' read from FILE\\n\"\n\n           \"  'of=FILE' write to FILE\\n\"\n\n           \"  'skip=N' skip N bs-sized blocks at the start of input\\n\";\n\n\n\n    printf(\"%s\\nSupported formats:\", help_msg);\n\n    bdrv_iterate_format(format_print, NULL);\n\n    printf(\"\\n\");\n\n    exit(EXIT_SUCCESS);\n\n}\n", "idx": 11852, "_split": "test", "_hash": "61d5c393098a074c8af1aa3cc4ccadfc"}
{"project": "qemu", "commit_id": "621ff94d5074d88253a5818c6b9c4db718fbfc65", "target": 0, "func": "static void coroutine_fn bdrv_create_co_entry(void *opaque)\n\n{\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    CreateCo *cco = opaque;\n\n    assert(cco->drv);\n\n\n\n    ret = cco->drv->bdrv_create(cco->filename, cco->opts, &local_err);\n\n    if (local_err) {\n\n        error_propagate(&cco->err, local_err);\n\n    }\n\n    cco->ret = ret;\n\n}\n", "idx": 11853, "_split": "test", "_hash": "042566b65f567ee6e1ae0f7858da5e4e"}
{"project": "qemu", "commit_id": "9658e4c342e6ae0d775101f8f6bb6efb16789af1", "target": 0, "func": "void helper_mtc0_entryhi(CPUMIPSState *env, target_ulong arg1)\n\n{\n\n    target_ulong old, val, mask;\n\n    mask = (TARGET_PAGE_MASK << 1) | env->CP0_EntryHi_ASID_mask;\n\n    if (((env->CP0_Config4 >> CP0C4_IE) & 0x3) >= 2) {\n\n        mask |= 1 << CP0EnHi_EHINV;\n\n    }\n\n\n\n    /* 1k pages not implemented */\n\n#if defined(TARGET_MIPS64)\n\n    if (env->insn_flags & ISA_MIPS32R6) {\n\n        int entryhi_r = extract64(arg1, 62, 2);\n\n        int config0_at = extract32(env->CP0_Config0, 13, 2);\n\n        bool no_supervisor = (env->CP0_Status_rw_bitmask & 0x8) == 0;\n\n        if ((entryhi_r == 2) ||\n\n            (entryhi_r == 1 && (no_supervisor || config0_at == 1))) {\n\n            /* skip EntryHi.R field if new value is reserved */\n\n            mask &= ~(0x3ull << 62);\n\n        }\n\n    }\n\n    mask &= env->SEGMask;\n\n#endif\n\n    old = env->CP0_EntryHi;\n\n    val = (arg1 & mask) | (old & ~mask);\n\n    env->CP0_EntryHi = val;\n\n    if (env->CP0_Config3 & (1 << CP0C3_MT)) {\n\n        sync_c0_entryhi(env, env->current_tc);\n\n    }\n\n    /* If the ASID changes, flush qemu's TLB.  */\n\n    if ((old & env->CP0_EntryHi_ASID_mask) !=\n\n        (val & env->CP0_EntryHi_ASID_mask)) {\n\n        cpu_mips_tlb_flush(env);\n\n    }\n\n}\n", "idx": 11854, "_split": "test", "_hash": "4bdc180627f53a91928da0aed893bcd6"}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static bool vmxnet3_verify_driver_magic(hwaddr dshmem)\n\n{\n\n    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);\n\n}\n", "idx": 11861, "_split": "test", "_hash": "bacc9027588ff7e264437fffe3114c6b"}
{"project": "qemu", "commit_id": "7443b43758ba5eeca8f81ca15fe9fced8983be26", "target": 1, "func": "ram_addr_t qemu_ram_addr_from_host_nofail(void *ptr)\n\n{\n\n    ram_addr_t ram_addr;\n\n\n\n    if (qemu_ram_addr_from_host(ptr, &ram_addr)) {\n\n        fprintf(stderr, \"Bad ram pointer %p\\n\", ptr);\n\n        abort();\n\n    }\n\n    return ram_addr;\n\n}\n", "idx": 11865, "_split": "test", "_hash": "bed155355c6ec330c1d77479c479123f"}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static inline int test_bit(uint32_t *field, int bit)\n\n{\n\n    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;\n\n}\n", "idx": 11911, "_split": "test", "_hash": "025342c30ffc070a05783b88b4e5ea4e"}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_decimal(void)\n\n{\n\n    const char *str = \"0123\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, &endptr, 10, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 123);\n\n    g_assert(endptr == str + strlen(str));\n\n\n\n    str = \"123\";\n\n    res = 999;\n\n    endptr = &f;\n\n    err = qemu_strtoul(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 123);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n", "idx": 11919, "_split": "test", "_hash": "077d36e3574ad84b6b5b2bea5b99a978"}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void piix3_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    dc->desc        = \"ISA bridge\";\n\n    dc->vmsd        = &vmstate_piix3;\n\n    dc->no_user     = 1,\n\n    k->no_hotplug   = 1;\n\n    k->init         = piix3_initfn;\n\n    k->config_write = piix3_write_config;\n\n    k->vendor_id    = PCI_VENDOR_ID_INTEL;\n\n    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */\n\n    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;\n\n    k->class_id     = PCI_CLASS_BRIDGE_ISA;\n\n}\n", "idx": 11933, "_split": "test", "_hash": "2e7181be259c44b5218db09b745bcf06"}
{"project": "qemu", "commit_id": "eefa3d8ef649f9055611361e2201cca49f8c3433", "target": 1, "func": "qio_channel_websock_source_dispatch(GSource *source,\n\n                                    GSourceFunc callback,\n\n                                    gpointer user_data)\n\n{\n\n    QIOChannelFunc func = (QIOChannelFunc)callback;\n\n    QIOChannelWebsockSource *wsource = (QIOChannelWebsockSource *)source;\n\n    GIOCondition cond = 0;\n\n\n\n    if (wsource->wioc->rawinput.offset) {\n\n        cond |= G_IO_IN;\n\n    }\n\n    if (wsource->wioc->rawoutput.offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER) {\n\n        cond |= G_IO_OUT;\n\n    }\n\n\n\n    return (*func)(QIO_CHANNEL(wsource->wioc),\n\n                   (cond & wsource->condition),\n\n                   user_data);\n\n}\n", "idx": 11936, "_split": "test", "_hash": "559a62d43199859d6fba1c4d2f422919"}
{"project": "qemu", "commit_id": "e40c3d2e7f4b58669a1b4e5dfb684e57c0bf62ce", "target": 0, "func": "static void acpi_dsdt_add_pci(Aml *scope, const MemMapEntry *memmap,\n\n                              uint32_t irq, bool use_highmem)\n\n{\n\n    Aml *method, *crs, *ifctx, *UUID, *ifctx1, *elsectx, *buf;\n\n    int i, bus_no;\n\n    hwaddr base_mmio = memmap[VIRT_PCIE_MMIO].base;\n\n    hwaddr size_mmio = memmap[VIRT_PCIE_MMIO].size;\n\n    hwaddr base_pio = memmap[VIRT_PCIE_PIO].base;\n\n    hwaddr size_pio = memmap[VIRT_PCIE_PIO].size;\n\n    hwaddr base_ecam = memmap[VIRT_PCIE_ECAM].base;\n\n    hwaddr size_ecam = memmap[VIRT_PCIE_ECAM].size;\n\n    int nr_pcie_buses = size_ecam / PCIE_MMCFG_SIZE_MIN;\n\n\n\n    Aml *dev = aml_device(\"%s\", \"PCI0\");\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A08\")));\n\n    aml_append(dev, aml_name_decl(\"_CID\", aml_string(\"PNP0A03\")));\n\n    aml_append(dev, aml_name_decl(\"_SEG\", aml_int(0)));\n\n    aml_append(dev, aml_name_decl(\"_BBN\", aml_int(0)));\n\n    aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n    aml_append(dev, aml_name_decl(\"_UID\", aml_string(\"PCI0\")));\n\n    aml_append(dev, aml_name_decl(\"_STR\", aml_unicode(\"PCIe 0 Device\")));\n\n    aml_append(dev, aml_name_decl(\"_CCA\", aml_int(1)));\n\n\n\n    /* Declare the PCI Routing Table. */\n\n    Aml *rt_pkg = aml_package(nr_pcie_buses * PCI_NUM_PINS);\n\n    for (bus_no = 0; bus_no < nr_pcie_buses; bus_no++) {\n\n        for (i = 0; i < PCI_NUM_PINS; i++) {\n\n            int gsi = (i + bus_no) % PCI_NUM_PINS;\n\n            Aml *pkg = aml_package(4);\n\n            aml_append(pkg, aml_int((bus_no << 16) | 0xFFFF));\n\n            aml_append(pkg, aml_int(i));\n\n            aml_append(pkg, aml_name(\"GSI%d\", gsi));\n\n            aml_append(pkg, aml_int(0));\n\n            aml_append(rt_pkg, pkg);\n\n        }\n\n    }\n\n    aml_append(dev, aml_name_decl(\"_PRT\", rt_pkg));\n\n\n\n    /* Create GSI link device */\n\n    for (i = 0; i < PCI_NUM_PINS; i++) {\n\n        uint32_t irqs =  irq + i;\n\n        Aml *dev_gsi = aml_device(\"GSI%d\", i);\n\n        aml_append(dev_gsi, aml_name_decl(\"_HID\", aml_string(\"PNP0C0F\")));\n\n        aml_append(dev_gsi, aml_name_decl(\"_UID\", aml_int(0)));\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n                   aml_interrupt(AML_CONSUMER, AML_LEVEL, AML_ACTIVE_HIGH,\n\n                                 AML_EXCLUSIVE, &irqs, 1));\n\n        aml_append(dev_gsi, aml_name_decl(\"_PRS\", crs));\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n                   aml_interrupt(AML_CONSUMER, AML_LEVEL, AML_ACTIVE_HIGH,\n\n                                 AML_EXCLUSIVE, &irqs, 1));\n\n        aml_append(dev_gsi, aml_name_decl(\"_CRS\", crs));\n\n        method = aml_method(\"_SRS\", 1, AML_NOTSERIALIZED);\n\n        aml_append(dev_gsi, method);\n\n        aml_append(dev, dev_gsi);\n\n    }\n\n\n\n    method = aml_method(\"_CBA\", 0, AML_NOTSERIALIZED);\n\n    aml_append(method, aml_return(aml_int(base_ecam)));\n\n    aml_append(dev, method);\n\n\n\n    method = aml_method(\"_CRS\", 0, AML_NOTSERIALIZED);\n\n    Aml *rbuf = aml_resource_template();\n\n    aml_append(rbuf,\n\n        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                            0x0000, 0x0000, nr_pcie_buses - 1, 0x0000,\n\n                            nr_pcie_buses));\n\n    aml_append(rbuf,\n\n        aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                         AML_NON_CACHEABLE, AML_READ_WRITE, 0x0000, base_mmio,\n\n                         base_mmio + size_mmio - 1, 0x0000, size_mmio));\n\n    aml_append(rbuf,\n\n        aml_dword_io(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                     AML_ENTIRE_RANGE, 0x0000, 0x0000, size_pio - 1, base_pio,\n\n                     size_pio));\n\n\n\n    if (use_highmem) {\n\n        hwaddr base_mmio_high = memmap[VIRT_PCIE_MMIO_HIGH].base;\n\n        hwaddr size_mmio_high = memmap[VIRT_PCIE_MMIO_HIGH].size;\n\n\n\n        aml_append(rbuf,\n\n            aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_NON_CACHEABLE, AML_READ_WRITE, 0x0000,\n\n                             base_mmio_high, base_mmio_high, 0x0000,\n\n                             size_mmio_high));\n\n    }\n\n\n\n    aml_append(method, aml_name_decl(\"RBUF\", rbuf));\n\n    aml_append(method, aml_return(rbuf));\n\n    aml_append(dev, method);\n\n\n\n    /* Declare an _OSC (OS Control Handoff) method */\n\n    aml_append(dev, aml_name_decl(\"SUPP\", aml_int(0)));\n\n    aml_append(dev, aml_name_decl(\"CTRL\", aml_int(0)));\n\n    method = aml_method(\"_OSC\", 4, AML_NOTSERIALIZED);\n\n    aml_append(method,\n\n        aml_create_dword_field(aml_arg(3), aml_int(0), \"CDW1\"));\n\n\n\n    /* PCI Firmware Specification 3.0\n\n     * 4.5.1. _OSC Interface for PCI Host Bridge Devices\n\n     * The _OSC interface for a PCI/PCI-X/PCI Express hierarchy is\n\n     * identified by the Universal Unique IDentifier (UUID)\n\n     * 33DB4D5B-1FF7-401C-9657-7441C03DD766\n\n     */\n\n    UUID = aml_touuid(\"33DB4D5B-1FF7-401C-9657-7441C03DD766\");\n\n    ifctx = aml_if(aml_equal(aml_arg(0), UUID));\n\n    aml_append(ifctx,\n\n        aml_create_dword_field(aml_arg(3), aml_int(4), \"CDW2\"));\n\n    aml_append(ifctx,\n\n        aml_create_dword_field(aml_arg(3), aml_int(8), \"CDW3\"));\n\n    aml_append(ifctx, aml_store(aml_name(\"CDW2\"), aml_name(\"SUPP\")));\n\n    aml_append(ifctx, aml_store(aml_name(\"CDW3\"), aml_name(\"CTRL\")));\n\n    aml_append(ifctx, aml_store(aml_and(aml_name(\"CTRL\"), aml_int(0x1D), NULL),\n\n                                aml_name(\"CTRL\")));\n\n\n\n    ifctx1 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));\n\n    aml_append(ifctx1, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(0x08), NULL),\n\n                                 aml_name(\"CDW1\")));\n\n    aml_append(ifctx, ifctx1);\n\n\n\n    ifctx1 = aml_if(aml_lnot(aml_equal(aml_name(\"CDW3\"), aml_name(\"CTRL\"))));\n\n    aml_append(ifctx1, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(0x10), NULL),\n\n                                 aml_name(\"CDW1\")));\n\n    aml_append(ifctx, ifctx1);\n\n\n\n    aml_append(ifctx, aml_store(aml_name(\"CTRL\"), aml_name(\"CDW3\")));\n\n    aml_append(ifctx, aml_return(aml_arg(3)));\n\n    aml_append(method, ifctx);\n\n\n\n    elsectx = aml_else();\n\n    aml_append(elsectx, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(4), NULL),\n\n                                  aml_name(\"CDW1\")));\n\n    aml_append(elsectx, aml_return(aml_arg(3)));\n\n    aml_append(method, elsectx);\n\n    aml_append(dev, method);\n\n\n\n    method = aml_method(\"_DSM\", 4, AML_NOTSERIALIZED);\n\n\n\n    /* PCI Firmware Specification 3.0\n\n     * 4.6.1. _DSM for PCI Express Slot Information\n\n     * The UUID in _DSM in this context is\n\n     * {E5C937D0-3553-4D7A-9117-EA4D19C3434D}\n\n     */\n\n    UUID = aml_touuid(\"E5C937D0-3553-4D7A-9117-EA4D19C3434D\");\n\n    ifctx = aml_if(aml_equal(aml_arg(0), UUID));\n\n    ifctx1 = aml_if(aml_equal(aml_arg(2), aml_int(0)));\n\n    uint8_t byte_list[1] = {1};\n\n    buf = aml_buffer(1, byte_list);\n\n    aml_append(ifctx1, aml_return(buf));\n\n    aml_append(ifctx, ifctx1);\n\n    aml_append(method, ifctx);\n\n\n\n    byte_list[0] = 0;\n\n    buf = aml_buffer(1, byte_list);\n\n    aml_append(method, aml_return(buf));\n\n    aml_append(dev, method);\n\n\n\n    Aml *dev_rp0 = aml_device(\"%s\", \"RP0\");\n\n    aml_append(dev_rp0, aml_name_decl(\"_ADR\", aml_int(0)));\n\n    aml_append(dev, dev_rp0);\n\n    aml_append(scope, dev);\n\n}\n", "idx": 11957, "_split": "test", "_hash": "7816dfdcf8edeb399fc81336bb81d1fc"}
{"project": "qemu", "commit_id": "ae261c86aaed62e7acddafab8262a2bf286d40b7", "target": 0, "func": "static int vmdk_parent_open(BlockDriverState *bs)\n\n{\n\n    char *p_name;\n\n    char desc[DESC_SIZE + 1];\n\n    BDRVVmdkState *s = bs->opaque;\n\n\n\n    desc[DESC_SIZE] = '\\0';\n\n    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {\n\n        return -1;\n\n    }\n\n\n\n    if ((p_name = strstr(desc,\"parentFileNameHint\")) != NULL) {\n\n        char *end_name;\n\n\n\n        p_name += sizeof(\"parentFileNameHint\") + 1;\n\n        if ((end_name = strchr(p_name,'\\\"')) == NULL)\n\n            return -1;\n\n        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)\n\n            return -1;\n\n\n\n        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11958, "_split": "test", "_hash": "5e7a159195ebabc9b469bbba2cc4c6ac"}
{"project": "qemu", "commit_id": "bf55b7afce53718ef96f4e6616da62c0ccac37dd", "target": 0, "func": "static MemoryRegionSection address_space_do_translate(AddressSpace *as,\n\n                                                      hwaddr addr,\n\n                                                      hwaddr *xlat,\n\n                                                      hwaddr *plen,\n\n                                                      bool is_write,\n\n                                                      bool is_mmio)\n\n{\n\n    IOMMUTLBEntry iotlb;\n\n    MemoryRegionSection *section;\n\n    MemoryRegion *mr;\n\n\n\n    for (;;) {\n\n        AddressSpaceDispatch *d = atomic_rcu_read(&as->dispatch);\n\n        section = address_space_translate_internal(d, addr, &addr, plen, is_mmio);\n\n        mr = section->mr;\n\n\n\n        if (!mr->iommu_ops) {\n\n            break;\n\n        }\n\n\n\n        iotlb = mr->iommu_ops->translate(mr, addr, is_write);\n\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n\n                | (addr & iotlb.addr_mask));\n\n        *plen = MIN(*plen, (addr | iotlb.addr_mask) - addr + 1);\n\n        if (!(iotlb.perm & (1 << is_write))) {\n\n            goto translate_fail;\n\n        }\n\n\n\n        as = iotlb.target_as;\n\n    }\n\n\n\n    *xlat = addr;\n\n\n\n    return *section;\n\n\n\ntranslate_fail:\n\n    return (MemoryRegionSection) { .mr = &io_mem_unassigned };\n\n}\n", "idx": 11969, "_split": "test", "_hash": "a7206261e7087f25349a8f462720d12d"}
{"project": "qemu", "commit_id": "30de46db50d2f9f74c5f7ab1cc463b8dec026407", "target": 0, "func": "static void read_guest_mem(void)\n\n{\n\n    uint32_t *guest_mem;\n\n    gint64 end_time;\n\n    int i, j;\n\n    size_t size;\n\n\n\n    g_mutex_lock(data_mutex);\n\n\n\n    end_time = g_get_monotonic_time() + 5 * G_TIME_SPAN_SECOND;\n\n    while (!fds_num) {\n\n        if (!_cond_wait_until(data_cond, data_mutex, end_time)) {\n\n            /* timeout has passed */\n\n            g_assert(fds_num);\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* check for sanity */\n\n    g_assert_cmpint(fds_num, >, 0);\n\n    g_assert_cmpint(fds_num, ==, memory.nregions);\n\n\n\n    /* iterate all regions */\n\n    for (i = 0; i < fds_num; i++) {\n\n\n\n        /* We'll check only the region statring at 0x0*/\n\n        if (memory.regions[i].guest_phys_addr != 0x0) {\n\n            continue;\n\n        }\n\n\n\n        g_assert_cmpint(memory.regions[i].memory_size, >, 1024);\n\n\n\n        size =  memory.regions[i].memory_size + memory.regions[i].mmap_offset;\n\n\n\n        guest_mem = mmap(0, size, PROT_READ | PROT_WRITE,\n\n                         MAP_SHARED, fds[i], 0);\n\n\n\n        g_assert(guest_mem != MAP_FAILED);\n\n        guest_mem += (memory.regions[i].mmap_offset / sizeof(*guest_mem));\n\n\n\n        for (j = 0; j < 256; j++) {\n\n            uint32_t a = readl(memory.regions[i].guest_phys_addr + j*4);\n\n            uint32_t b = guest_mem[j];\n\n\n\n            g_assert_cmpint(a, ==, b);\n\n        }\n\n\n\n        munmap(guest_mem, memory.regions[i].memory_size);\n\n    }\n\n\n\n    g_assert_cmpint(1, ==, 1);\n\n    g_mutex_unlock(data_mutex);\n\n}\n", "idx": 11975, "_split": "test", "_hash": "56914e964dc0a8c457b5a5a63d4908fd"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static uint64_t qemu_rdma_poll(RDMAContext *rdma, uint64_t *wr_id_out,\n\n                               uint32_t *byte_len)\n\n{\n\n    int ret;\n\n    struct ibv_wc wc;\n\n    uint64_t wr_id;\n\n\n\n    ret = ibv_poll_cq(rdma->cq, 1, &wc);\n\n\n\n    if (!ret) {\n\n        *wr_id_out = RDMA_WRID_NONE;\n\n        return 0;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ibv_poll_cq return %d!\\n\", ret);\n\n        return ret;\n\n    }\n\n\n\n    wr_id = wc.wr_id & RDMA_WRID_TYPE_MASK;\n\n\n\n    if (wc.status != IBV_WC_SUCCESS) {\n\n        fprintf(stderr, \"ibv_poll_cq wc.status=%d %s!\\n\",\n\n                        wc.status, ibv_wc_status_str(wc.status));\n\n        fprintf(stderr, \"ibv_poll_cq wrid=%s!\\n\", wrid_desc[wr_id]);\n\n\n\n        return -1;\n\n    }\n\n\n\n    if (rdma->control_ready_expected &&\n\n        (wr_id >= RDMA_WRID_RECV_CONTROL)) {\n\n        DDDPRINTF(\"completion %s #%\" PRId64 \" received (%\" PRId64 \")\"\n\n                  \" left %d\\n\", wrid_desc[RDMA_WRID_RECV_CONTROL],\n\n                  wr_id - RDMA_WRID_RECV_CONTROL, wr_id, rdma->nb_sent);\n\n        rdma->control_ready_expected = 0;\n\n    }\n\n\n\n    if (wr_id == RDMA_WRID_RDMA_WRITE) {\n\n        uint64_t chunk =\n\n            (wc.wr_id & RDMA_WRID_CHUNK_MASK) >> RDMA_WRID_CHUNK_SHIFT;\n\n        uint64_t index =\n\n            (wc.wr_id & RDMA_WRID_BLOCK_MASK) >> RDMA_WRID_BLOCK_SHIFT;\n\n        RDMALocalBlock *block = &(rdma->local_ram_blocks.block[index]);\n\n\n\n        DDDPRINTF(\"completions %s (%\" PRId64 \") left %d, \"\n\n                 \"block %\" PRIu64 \", chunk: %\" PRIu64 \" %p %p\\n\",\n\n                 print_wrid(wr_id), wr_id, rdma->nb_sent, index, chunk,\n\n                 block->local_host_addr, (void *)block->remote_host_addr);\n\n\n\n        clear_bit(chunk, block->transit_bitmap);\n\n\n\n        if (rdma->nb_sent > 0) {\n\n            rdma->nb_sent--;\n\n        }\n\n\n\n        if (!rdma->pin_all) {\n\n            /*\n\n             * FYI: If one wanted to signal a specific chunk to be unregistered\n\n             * using LRU or workload-specific information, this is the function\n\n             * you would call to do so. That chunk would then get asynchronously\n\n             * unregistered later.\n\n             */\n\n#ifdef RDMA_UNREGISTRATION_EXAMPLE\n\n            qemu_rdma_signal_unregister(rdma, index, chunk, wc.wr_id);\n\n#endif\n\n        }\n\n    } else {\n\n        DDDPRINTF(\"other completion %s (%\" PRId64 \") received left %d\\n\",\n\n            print_wrid(wr_id), wr_id, rdma->nb_sent);\n\n    }\n\n\n\n    *wr_id_out = wc.wr_id;\n\n    if (byte_len) {\n\n        *byte_len = wc.byte_len;\n\n    }\n\n\n\n    return  0;\n\n}\n", "idx": 11978, "_split": "test", "_hash": "6803655f8c1d7b9ff71b6452b8ea8acd"}
{"project": "qemu", "commit_id": "a879125b47c3ae554c01824f996a64a45a86556e", "target": 1, "func": "static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    outw(0xcfc, value);\n\n}\n", "idx": 11980, "_split": "test", "_hash": "ba6d961bcd441fa3b5e4b5cff4a74ce4"}
{"project": "qemu", "commit_id": "3daa41078aedf227ec98b0d1c9d56b77b6d20153", "target": 1, "func": "void scsi_req_cancel(SCSIRequest *req)\n\n{\n\n    trace_scsi_req_cancel(req->dev->id, req->lun, req->tag);\n\n    if (!req->enqueued) {\n\n        return;\n\n    }\n\n\n\n    scsi_req_ref(req);\n\n    scsi_req_dequeue(req);\n\n    req->io_canceled = true;\n\n    if (req->aiocb) {\n\n        blk_aio_cancel(req->aiocb);\n\n    } else {\n\n        scsi_req_cancel_complete(req);\n\n    }\n\n}", "idx": 11988, "_split": "test", "_hash": "abceaed0ad3743e0e6de93fd7b5d147d"}
{"project": "qemu", "commit_id": "577bf808958d06497928c639efaa473bf8c5e099", "target": 1, "func": "static void gen_exception_return(DisasContext *s, TCGv_i32 pc)\n\n{\n\n    TCGv_i32 tmp;\n\n    store_reg(s, 15, pc);\n\n    tmp = load_cpu_field(spsr);\n\n    gen_set_cpsr(tmp, CPSR_ERET_MASK);\n\n    tcg_temp_free_i32(tmp);\n\n    s->is_jmp = DISAS_UPDATE;\n\n}\n", "idx": 11998, "_split": "test", "_hash": "213a1b15ca7c0e85425761c9b77b903c"}
{"project": "qemu", "commit_id": "8dfd5f96515ca20c4eb109cb0ee28e2bb32fc505", "target": 0, "func": "static void qio_channel_websock_write_close(QIOChannelWebsock *ioc,\n\n                                            uint16_t code, const char *reason)\n\n{\n\n    struct iovec iov;\n\n    buffer_reserve(&ioc->rawoutput, 2 + (reason ? strlen(reason) : 0));\n\n    *(uint16_t *)(ioc->rawoutput.buffer + ioc->rawoutput.offset) =\n\n        cpu_to_be16(code);\n\n    ioc->rawoutput.offset += 2;\n\n    if (reason) {\n\n        buffer_append(&ioc->rawoutput, reason, strlen(reason));\n\n    }\n\n    iov.iov_base = ioc->rawoutput.buffer;\n\n    iov.iov_len = ioc->rawoutput.offset;\n\n    qio_channel_websock_encode(ioc, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE,\n\n                               &iov, 1, iov.iov_len);\n\n    buffer_reset(&ioc->rawoutput);\n\n    qio_channel_websock_write_wire(ioc, NULL);\n\n    qio_channel_shutdown(ioc->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);\n\n}\n", "idx": 12023, "_split": "test", "_hash": "abf05d668bb0d6d9dc03f41853907afa"}
{"project": "qemu", "commit_id": "77af8a2b95b79699de650965d5228772743efe84", "target": 0, "func": "static void fadt_setup(AcpiFadtDescriptorRev1 *fadt, AcpiPmInfo *pm)\n\n{\n\n    fadt->model = 1;\n\n    fadt->reserved1 = 0;\n\n    fadt->sci_int = cpu_to_le16(pm->sci_int);\n\n    fadt->smi_cmd = cpu_to_le32(ACPI_PORT_SMI_CMD);\n\n    fadt->acpi_enable = pm->acpi_enable_cmd;\n\n    fadt->acpi_disable = pm->acpi_disable_cmd;\n\n    /* EVT, CNT, TMR offset matches hw/acpi/core.c */\n\n    fadt->pm1a_evt_blk = cpu_to_le32(pm->io_base);\n\n    fadt->pm1a_cnt_blk = cpu_to_le32(pm->io_base + 0x04);\n\n    fadt->pm_tmr_blk = cpu_to_le32(pm->io_base + 0x08);\n\n    fadt->gpe0_blk = cpu_to_le32(pm->gpe0_blk);\n\n    /* EVT, CNT, TMR length matches hw/acpi/core.c */\n\n    fadt->pm1_evt_len = 4;\n\n    fadt->pm1_cnt_len = 2;\n\n    fadt->pm_tmr_len = 4;\n\n    fadt->gpe0_blk_len = pm->gpe0_blk_len;\n\n    fadt->plvl2_lat = cpu_to_le16(0xfff); /* C2 state not supported */\n\n    fadt->plvl3_lat = cpu_to_le16(0xfff); /* C3 state not supported */\n\n    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |\n\n                              (1 << ACPI_FADT_F_PROC_C1) |\n\n                              (1 << ACPI_FADT_F_SLP_BUTTON) |\n\n                              (1 << ACPI_FADT_F_RTC_S4));\n\n    fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_USE_PLATFORM_CLOCK);\n\n    /* APIC destination mode (\"Flat Logical\") has an upper limit of 8 CPUs\n\n     * For more than 8 CPUs, \"Clustered Logical\" mode has to be used\n\n     */\n\n    if (max_cpus > 8) {\n\n        fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL);\n\n    }\n\n    fadt->century = RTC_CENTURY;\n\n}\n", "idx": 12026, "_split": "test", "_hash": "73e4bd3741ffd03c3d76040e557036a7"}
{"project": "qemu", "commit_id": "da98c8eb4c35225049cad8cf767647eb39788b5d", "target": 0, "func": "void acpi_pm1_cnt_write(ACPIREGS *ar, uint16_t val)\n\n{\n\n    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);\n\n\n\n    if (val & ACPI_BITMASK_SLEEP_ENABLE) {\n\n        /* change suspend type */\n\n        uint16_t sus_typ = (val >> 10) & 7;\n\n        switch(sus_typ) {\n\n        case 0: /* soft power off */\n\n            qemu_system_shutdown_request();\n\n            break;\n\n        case 1:\n\n            /* ACPI_BITMASK_WAKE_STATUS should be set on resume.\n\n               Pretend that resume was caused by power button */\n\n            ar->pm1.evt.sts |=\n\n                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);\n\n            qemu_system_reset_request();\n\n            qemu_irq_raise(ar->pm1.cnt.cmos_s3);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 12036, "_split": "test", "_hash": "2d0436ebbd64955722f28eec1eb484b4"}
{"project": "qemu", "commit_id": "0fdddf80a88ac2efe068990d1878f472bb6b95d9", "target": 0, "func": "static void win32_rearm_timer(struct qemu_alarm_timer *t)\n\n{\n\n    struct qemu_alarm_win32 *data = t->priv;\n\n    uint64_t nearest_delta_us;\n\n\n\n    if (!active_timers[QEMU_TIMER_REALTIME] &&\n\n                !active_timers[QEMU_TIMER_VIRTUAL])\n\n        return;\n\n\n\n    nearest_delta_us = qemu_next_deadline_dyntick();\n\n    nearest_delta_us /= 1000;\n\n\n\n    timeKillEvent(data->timerId);\n\n\n\n    data->timerId = timeSetEvent(1,\n\n                        data->period,\n\n                        host_alarm_handler,\n\n                        (DWORD)t,\n\n                        TIME_ONESHOT | TIME_PERIODIC);\n\n\n\n    if (!data->timerId) {\n\n        fprintf(stderr, \"Failed to re-arm win32 alarm timer %ld\\n\",\n\n                GetLastError());\n\n\n\n        timeEndPeriod(data->period);\n\n        exit(1);\n\n    }\n\n}\n", "idx": 12038, "_split": "test", "_hash": "1ddd86bd70b1c853f1458752680acb6f"}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "static void qapi_dealloc_end_struct(Visitor *v, Error **errp)\n\n{\n\n    QapiDeallocVisitor *qov = to_qov(v);\n\n    void **obj = qapi_dealloc_pop(qov);\n\n    if (obj) {\n\n        g_free(*obj);\n\n    }\n\n}\n", "idx": 12075, "_split": "test", "_hash": "a33af124161b579dcc31b147abae84e4"}
{"project": "qemu", "commit_id": "c951d9a6751576a076ac80a5e5145ceb8d794d38", "target": 1, "func": "static void file_completion(const char *input)\n\n{\n\n    DIR *ffs;\n\n    struct dirent *d;\n\n    char path[1024];\n\n    char file[1024], file_prefix[1024];\n\n    int input_path_len;\n\n    const char *p;\n\n\n\n    p = strrchr(input, '/');\n\n    if (!p) {\n\n        input_path_len = 0;\n\n        pstrcpy(file_prefix, sizeof(file_prefix), input);\n\n        pstrcpy(path, sizeof(path), \".\");\n\n    } else {\n\n        input_path_len = p - input + 1;\n\n        memcpy(path, input, input_path_len);\n\n        if (input_path_len > sizeof(path) - 1)\n\n            input_path_len = sizeof(path) - 1;\n\n        path[input_path_len] = '\\0';\n\n        pstrcpy(file_prefix, sizeof(file_prefix), p + 1);\n\n    }\n\n#ifdef DEBUG_COMPLETION\n\n    monitor_printf(cur_mon, \"input='%s' path='%s' prefix='%s'\\n\",\n\n                   input, path, file_prefix);\n\n#endif\n\n    ffs = opendir(path);\n\n    if (!ffs)\n\n        return;\n\n    for(;;) {\n\n        struct stat sb;\n\n        d = readdir(ffs);\n\n        if (!d)\n\n            break;\n\n\n\n        if (strcmp(d->d_name, \".\") == 0 || strcmp(d->d_name, \"..\") == 0) {\n\n            continue;\n\n        }\n\n\n\n        if (strstart(d->d_name, file_prefix, NULL)) {\n\n            memcpy(file, input, input_path_len);\n\n            if (input_path_len < sizeof(file))\n\n                pstrcpy(file + input_path_len, sizeof(file) - input_path_len,\n\n                        d->d_name);\n\n            /* stat the file to find out if it's a directory.\n\n             * In that case add a slash to speed up typing long paths\n\n             */\n\n            stat(file, &sb);\n\n            if(S_ISDIR(sb.st_mode))\n\n                pstrcat(file, sizeof(file), \"/\");\n\n            readline_add_completion(cur_mon->rs, file);\n\n        }\n\n    }\n\n    closedir(ffs);\n\n}\n", "idx": 12079, "_split": "test", "_hash": "d2d89d26ee7a9b5e96d9fd28156ba096"}
{"project": "qemu", "commit_id": "6350b0904615cc0531cc3059ea34db5c009c88aa", "target": 1, "func": "static void set_int8(Object *obj, Visitor *v, void *opaque,\n\n                     const char *name, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop = opaque;\n\n    int8_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    Error *local_err = NULL;\n\n    int64_t value;\n\n\n\n    if (dev->state != DEV_STATE_CREATED) {\n\n        error_set(errp, QERR_PERMISSION_DENIED);\n\n        return;\n\n    }\n\n\n\n    visit_type_int(v, &value, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    if (value > prop->info->min && value <= prop->info->max) {\n\n        *ptr = value;\n\n    } else {\n\n        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,\n\n                  dev->id?:\"\", name, value, prop->info->min,\n\n                  prop->info->max);\n\n    }\n\n}\n", "idx": 12083, "_split": "test", "_hash": "b02e2c95d054667d8e98a29141a443e5"}
{"project": "qemu", "commit_id": "d7cd369402191814a1bb339a730f3af411e9682f", "target": 1, "func": "static void enter_migration_coroutine(void *opaque)\n\n{\n\n    Coroutine *co = opaque;\n\n    qemu_coroutine_enter(co, NULL);\n\n}\n", "idx": 12086, "_split": "test", "_hash": "e617fb07d2ae351a0507c66fecc757cc"}
{"project": "qemu", "commit_id": "9ef91a677110ec200d7b2904fc4bcae5a77329ad", "target": 0, "func": "int qemu_paio_init(struct qemu_paioinit *aioinit)\n\n{\n\n    int ret;\n\n\n\n    ret = pthread_attr_init(&attr);\n\n    if (ret) die2(ret, \"pthread_attr_init\");\n\n\n\n    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n    if (ret) die2(ret, \"pthread_attr_setdetachstate\");\n\n\n\n    TAILQ_INIT(&request_list);\n\n\n\n    return 0;\n\n}\n", "idx": 12111, "_split": "test", "_hash": "4cfb5e0385cd44d48c596bac83622d46"}
{"project": "qemu", "commit_id": "2c80e42395bfe0bf291c082f9399431e1ff9d758", "target": 0, "func": "dprint(int level, const char *fmt, ...)\n\n{\n\n    va_list args;\n\n\n\n    if (level <= debug) {\n\n        va_start(args, fmt);\n\n        vfprintf(stderr, fmt, args);\n\n        va_end(args);\n\n    }\n\n}\n", "idx": 12130, "_split": "test", "_hash": "f8e7fc888929dffad48e388d9310d10c"}
{"project": "qemu", "commit_id": "5d1abf234462d13bef3617cc2c55b6815703ddf2", "target": 0, "func": "static void s390_pcihost_hot_plug(HotplugHandler *hotplug_dev,\n\n                                  DeviceState *dev, Error **errp)\n\n{\n\n    PCIDevice *pci_dev = PCI_DEVICE(dev);\n\n    S390PCIBusDevice *pbdev;\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(pci_device_root_bus(pci_dev)\n\n                                           ->qbus.parent);\n\n\n\n    pbdev = &s->pbdev[PCI_SLOT(pci_dev->devfn)];\n\n\n\n    pbdev->fid = s390_pci_get_pfid(pci_dev);\n\n    pbdev->pdev = pci_dev;\n\n    pbdev->configured = true;\n\n    pbdev->fh = s390_pci_get_pfh(pci_dev);\n\n\n\n    s390_pcihost_setup_msix(pbdev);\n\n\n\n    if (dev->hotplugged) {\n\n        s390_pci_generate_plug_event(HP_EVENT_RESERVED_TO_STANDBY,\n\n                                     pbdev->fh, pbdev->fid);\n\n        s390_pci_generate_plug_event(HP_EVENT_TO_CONFIGURED,\n\n                                     pbdev->fh, pbdev->fid);\n\n    }\n\n}\n", "idx": 12133, "_split": "test", "_hash": "11632096c0b456d6464ed47c50bbd898"}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static uint64_t pxa2xx_mm_read(void *opaque, hwaddr addr,\n\n                               unsigned size)\n\n{\n\n    PXA2xxState *s = (PXA2xxState *) opaque;\n\n\n\n    switch (addr) {\n\n    case MDCNFG ... SA1110:\n\n        if ((addr & 3) == 0)\n\n            return s->mm_regs[addr >> 2];\n\n\n\n    default:\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 12134, "_split": "test", "_hash": "a022ededfca6dcf501ff035a7267c9ce"}
{"project": "qemu", "commit_id": "c471ad0e9bd46ca5f5c9c796e727230e043a091d", "target": 0, "func": "static int vhost_verify_ring_mappings(struct vhost_dev *dev,\n\n                                      uint64_t start_addr,\n\n                                      uint64_t size)\n\n{\n\n    int i, j;\n\n    int r = 0;\n\n    const char *part_name[] = {\n\n        \"descriptor table\",\n\n        \"available ring\",\n\n        \"used ring\"\n\n    };\n\n\n\n    for (i = 0; i < dev->nvqs; ++i) {\n\n        struct vhost_virtqueue *vq = dev->vqs + i;\n\n\n\n        j = 0;\n\n        r = vhost_verify_ring_part_mapping(vq->desc, vq->desc_phys,\n\n                                           vq->desc_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n\n\n        j++;\n\n        r = vhost_verify_ring_part_mapping(vq->avail, vq->avail_phys,\n\n                                           vq->avail_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n\n\n        j++;\n\n        r = vhost_verify_ring_part_mapping(vq->used, vq->used_phys,\n\n                                           vq->used_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (r == -ENOMEM) {\n\n        error_report(\"Unable to map %s for ring %d\", part_name[j], i);\n\n    } else if (r == -EBUSY) {\n\n        error_report(\"%s relocated for ring %d\", part_name[j], i);\n\n    }\n\n    return r;\n\n}\n", "idx": 12142, "_split": "test", "_hash": "838906c955688d2a887a0de6e66bc04f"}
{"project": "qemu", "commit_id": "3435f39513a104294b5e3bbf3612047028d25cfc", "target": 0, "func": "void qemu_ram_remap(ram_addr_t addr, ram_addr_t length)\n\n{\n\n    RAMBlock *block;\n\n    ram_addr_t offset;\n\n    int flags;\n\n    void *area, *vaddr;\n\n\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        offset = addr - block->offset;\n\n        if (offset < block->length) {\n\n            vaddr = block->host + offset;\n\n            if (block->flags & RAM_PREALLOC_MASK) {\n\n                ;\n\n            } else if (xen_enabled()) {\n\n                abort();\n\n            } else {\n\n                flags = MAP_FIXED;\n\n                munmap(vaddr, length);\n\n                if (mem_path) {\n\n#if defined(__linux__) && !defined(TARGET_S390X)\n\n                    if (block->fd) {\n\n#ifdef MAP_POPULATE\n\n                        flags |= mem_prealloc ? MAP_POPULATE | MAP_SHARED :\n\n                            MAP_PRIVATE;\n\n#else\n\n                        flags |= MAP_PRIVATE;\n\n#endif\n\n                        area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                    flags, block->fd, offset);\n\n                    } else {\n\n                        flags |= MAP_PRIVATE | MAP_ANONYMOUS;\n\n                        area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                    flags, -1, 0);\n\n                    }\n\n#else\n\n                    abort();\n\n#endif\n\n                } else {\n\n#if defined(TARGET_S390X) && defined(CONFIG_KVM)\n\n                    flags |= MAP_SHARED | MAP_ANONYMOUS;\n\n                    area = mmap(vaddr, length, PROT_EXEC|PROT_READ|PROT_WRITE,\n\n                                flags, -1, 0);\n\n#else\n\n                    flags |= MAP_PRIVATE | MAP_ANONYMOUS;\n\n                    area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                flags, -1, 0);\n\n#endif\n\n                }\n\n                if (area != vaddr) {\n\n                    fprintf(stderr, \"Could not remap addr: \"\n\n                            RAM_ADDR_FMT \"@\" RAM_ADDR_FMT \"\\n\",\n\n                            length, addr);\n\n                    exit(1);\n\n                }\n\n                memory_try_enable_merging(vaddr, length);\n\n                qemu_ram_setup_dump(vaddr, length);\n\n            }\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 12145, "_split": "test", "_hash": "5f9921fcd7d4a26f3da67acc50cc5ead"}
{"project": "qemu", "commit_id": "8f5d58ef2c92d7b82d9a6eeefd7c8854a183ba4a", "target": 1, "func": "const char *object_get_typename(Object *obj)\n\n{\n\n    return obj->class->type->name;\n\n}\n", "idx": 12182, "_split": "test", "_hash": "23ecc29fd75a4c22fa4c678298460dcb"}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int ram_init1(SysBusDevice *dev)\n\n{\n\n    RamDevice *d = SUN4U_RAM(dev);\n\n\n\n    memory_region_init_ram(&d->ram, OBJECT(d), \"sun4u.ram\", d->size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&d->ram);\n\n    sysbus_init_mmio(dev, &d->ram);\n\n    return 0;\n\n}\n", "idx": 12200, "_split": "test", "_hash": "e3922bd32e732d74cbc1b87679ffcc65"}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void stop_tco(const TestData *d)\n\n{\n\n    uint32_t val;\n\n\n\n    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);\n\n    val |= TCO_TMR_HLT;\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);\n\n}\n", "idx": 12205, "_split": "test", "_hash": "64568cb88a0cb8e97e3fbfd8993b1987"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_put_be32(QEMUFile *f, unsigned int v)\n\n{\n\n    qemu_put_byte(f, v >> 24);\n\n    qemu_put_byte(f, v >> 16);\n\n    qemu_put_byte(f, v >> 8);\n\n    qemu_put_byte(f, v);\n\n}\n", "idx": 12215, "_split": "test", "_hash": "90e2049a526f6db2f0a2f1eae4d1e817"}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "bool bdrv_is_first_non_filter(BlockDriverState *candidate)\n\n{\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    /* walk down the bs forest recursively */\n\n    while ((it = bdrv_next(it, &bs)) != NULL) {\n\n        bool perm;\n\n\n\n        /* try to recurse in this top level bs */\n\n        perm = bdrv_recurse_is_first_non_filter(bs, candidate);\n\n\n\n        /* candidate is the first non filter */\n\n        if (perm) {\n\n            return true;\n\n        }\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 12243, "_split": "test", "_hash": "7219a863bb0c6507aeb5fd8121ea0183"}
{"project": "qemu", "commit_id": "f4bf56fb78ed0e9f60fa1ed656c14ff4c494da5a", "target": 1, "func": "static int vhost_user_set_mem_table(struct vhost_dev *dev,\n\n                                    struct vhost_memory *mem)\n\n{\n\n    int fds[VHOST_MEMORY_MAX_NREGIONS];\n\n    int i, fd;\n\n    size_t fd_num = 0;\n\n    bool reply_supported = virtio_has_feature(dev->protocol_features,\n\n                                              VHOST_USER_PROTOCOL_F_REPLY_ACK);\n\n\n\n    VhostUserMsg msg = {\n\n        .hdr.request = VHOST_USER_SET_MEM_TABLE,\n\n        .hdr.flags = VHOST_USER_VERSION,\n\n    };\n\n\n\n    if (reply_supported) {\n\n        msg.hdr.flags |= VHOST_USER_NEED_REPLY_MASK;\n\n    }\n\n\n\n    for (i = 0; i < dev->mem->nregions; ++i) {\n\n        struct vhost_memory_region *reg = dev->mem->regions + i;\n\n        ram_addr_t offset;\n\n        MemoryRegion *mr;\n\n\n\n        assert((uintptr_t)reg->userspace_addr == reg->userspace_addr);\n\n        mr = memory_region_from_host((void *)(uintptr_t)reg->userspace_addr,\n\n                                     &offset);\n\n        fd = memory_region_get_fd(mr);\n\n        if (fd > 0) {\n\n            msg.payload.memory.regions[fd_num].userspace_addr = reg->userspace_addr;\n\n            msg.payload.memory.regions[fd_num].memory_size  = reg->memory_size;\n\n            msg.payload.memory.regions[fd_num].guest_phys_addr = reg->guest_phys_addr;\n\n            msg.payload.memory.regions[fd_num].mmap_offset = offset;\n\n            assert(fd_num < VHOST_MEMORY_MAX_NREGIONS);\n\n            fds[fd_num++] = fd;\n\n        }\n\n    }\n\n\n\n    msg.payload.memory.nregions = fd_num;\n\n\n\n    if (!fd_num) {\n\n        error_report(\"Failed initializing vhost-user memory map, \"\n\n                     \"consider using -object memory-backend-file share=on\");\n\n        return -1;\n\n    }\n\n\n\n    msg.hdr.size = sizeof(msg.payload.memory.nregions);\n\n    msg.hdr.size += sizeof(msg.payload.memory.padding);\n\n    msg.hdr.size += fd_num * sizeof(VhostUserMemoryRegion);\n\n\n\n    if (vhost_user_write(dev, &msg, fds, fd_num) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (reply_supported) {\n\n        return process_message_reply(dev, &msg);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12245, "_split": "test", "_hash": "6a995ec6e74b8478ff7c0868071c61cf"}
{"project": "qemu", "commit_id": "b1b27b64262fdace45e5ab134c4438338076cb98", "target": 1, "func": "static int nbd_co_readv_1(NbdClientSession *client, int64_t sector_num,\n\n                          int nb_sectors, QEMUIOVector *qiov,\n\n                          int offset)\n\n{\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n\n\n    request.type = NBD_CMD_READ;\n\n    request.from = sector_num * 512;\n\n    request.len = nb_sectors * 512;\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(client, &request, NULL, 0);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, qiov, offset);\n\n    }\n\n    nbd_coroutine_end(client, &request);\n\n    return -reply.error;\n\n\n\n}\n", "idx": 12257, "_split": "test", "_hash": "b2f4ab095e46e95a80ec7df956e491df"}
{"project": "qemu", "commit_id": "04f8c053cca9c329eebb761f3a1ffef3d349b84c", "target": 1, "func": "static void handle_qmp_command(JSONMessageParser *parser, QList *tokens)\n\n{\n\n    int err;\n\n    QObject *obj;\n\n    QDict *input, *args;\n\n    const mon_cmd_t *cmd;\n\n    Monitor *mon = cur_mon;\n\n    const char *cmd_name, *info_item;\n\n\n\n    args = NULL;\n\n\n\n    obj = json_parser_parse(tokens, NULL);\n\n    if (!obj) {\n\n        // FIXME: should be triggered in json_parser_parse()\n\n        qerror_report(QERR_JSON_PARSING);\n\n        goto err_out;\n\n\n        qerror_report(QERR_QMP_BAD_INPUT_OBJECT, \"object\");\n\n        qobject_decref(obj);\n\n        goto err_out;\n\n    }\n\n\n\n    input = qobject_to_qdict(obj);\n\n\n\n    mon->mc->id = qdict_get(input, \"id\");\n\n    qobject_incref(mon->mc->id);\n\n\n\n    obj = qdict_get(input, \"execute\");\n\n    if (!obj) {\n\n        qerror_report(QERR_QMP_BAD_INPUT_OBJECT, \"execute\");\n\n\n    } else if (qobject_type(obj) != QTYPE_QSTRING) {\n\n        qerror_report(QERR_QMP_BAD_INPUT_OBJECT_MEMBER, \"execute\", \"string\");\n\n\n    }\n\n\n\n    cmd_name = qstring_get_str(qobject_to_qstring(obj));\n\n\n\n    if (invalid_qmp_mode(mon, cmd_name)) {\n\n        qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);\n\n\n    }\n\n\n\n    /*\n\n     * XXX: We need this special case until we get info handlers\n\n     * converted into 'query-' commands\n\n     */\n\n    if (compare_cmd(cmd_name, \"info\")) {\n\n        qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);\n\n\n    } else if (strstart(cmd_name, \"query-\", &info_item)) {\n\n        cmd = monitor_find_command(\"info\");\n\n        qdict_put_obj(input, \"arguments\",\n\n                      qobject_from_jsonf(\"{ 'item': %s }\", info_item));\n\n    } else {\n\n        cmd = monitor_find_command(cmd_name);\n\n        if (!cmd || !monitor_handler_ported(cmd)) {\n\n            qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);\n\n\n        }\n\n    }\n\n\n\n    obj = qdict_get(input, \"arguments\");\n\n    if (!obj) {\n\n        args = qdict_new();\n\n\n\n\n    } else {\n\n        args = qobject_to_qdict(obj);\n\n        QINCREF(args);\n\n    }\n\n\n\n    QDECREF(input);\n\n\n\n    err = monitor_check_qmp_args(cmd, args);\n\n    if (err < 0) {\n\n        goto err_out;\n\n    }\n\n\n\n    if (monitor_handler_is_async(cmd)) {\n\n        qmp_async_cmd_handler(mon, cmd, args);\n\n    } else {\n\n        monitor_call_handler(mon, cmd, args);\n\n    }\n\n    goto out;\n\n\n\nerr_input:\n\n    QDECREF(input);\n\nerr_out:\n\n    monitor_protocol_emitter(mon, NULL);\n\nout:\n\n    QDECREF(args);\n\n}", "idx": 12281, "_split": "test", "_hash": "c54d31b16ce0e5b8e425438020b30ab4"}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static void find_best_solid_area(VncState *vs, int x, int y, int w, int h,\n\n                                 uint32_t color, int *w_ptr, int *h_ptr)\n\n{\n\n    int dx, dy, dw, dh;\n\n    int w_prev;\n\n    int w_best = 0, h_best = 0;\n\n\n\n    w_prev = w;\n\n\n\n    for (dy = y; dy < y + h; dy += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) {\n\n\n\n        dh = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, y + h - dy);\n\n        dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, w_prev);\n\n\n\n        if (!check_solid_tile(vs, x, dy, dw, dh, &color, true)) {\n\n            break;\n\n        }\n\n\n\n        for (dx = x + dw; dx < x + w_prev;) {\n\n            dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, x + w_prev - dx);\n\n\n\n            if (!check_solid_tile(vs, dx, dy, dw, dh, &color, true)) {\n\n                break;\n\n            }\n\n            dx += dw;\n\n        }\n\n\n\n        w_prev = dx - x;\n\n        if (w_prev * (dy + dh - y) > w_best * h_best) {\n\n            w_best = w_prev;\n\n            h_best = dy + dh - y;\n\n        }\n\n    }\n\n\n\n    *w_ptr = w_best;\n\n    *h_ptr = h_best;\n\n}\n", "idx": 12307, "_split": "test", "_hash": "fcb240cb7d3af9d8849df847b4a6e5e4"}
{"project": "qemu", "commit_id": "43771539d4666cba16298fc6b0ea63867425277c", "target": 0, "func": "static RAMBlock *qemu_get_ram_block(ram_addr_t addr)\n\n{\n\n    RAMBlock *block;\n\n\n\n    /* The list is protected by the iothread lock here.  */\n\n    block = ram_list.mru_block;\n\n    if (block && addr - block->offset < block->max_length) {\n\n        goto found;\n\n    }\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        if (addr - block->offset < block->max_length) {\n\n            goto found;\n\n        }\n\n    }\n\n\n\n    fprintf(stderr, \"Bad ram offset %\" PRIx64 \"\\n\", (uint64_t)addr);\n\n    abort();\n\n\n\nfound:\n\n    ram_list.mru_block = block;\n\n    return block;\n\n}\n", "idx": 12314, "_split": "test", "_hash": "61aa445548b90ddb979ce09642668bc8"}
{"project": "qemu", "commit_id": "a980a065fb5e86d6dec337e6cb6ff432f1a143c9", "target": 0, "func": "static int usbnet_can_receive(VLANClientState *nc)\n\n{\n\n    USBNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;\n\n\n\n    if (s->rndis && !s->rndis_state == RNDIS_DATA_INITIALIZED)\n\n        return 1;\n\n\n\n    return !s->in_len;\n\n}\n", "idx": 12320, "_split": "test", "_hash": "3b6a0ef0ede4893c13dba9a081235c51"}
{"project": "qemu", "commit_id": "333d50fe3d9a1ff0a6a1a44ef42a0d3a2a7f2abe", "target": 0, "func": "static int scsi_disk_emulate_mode_sense(SCSIRequest *req, uint8_t *outbuf)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    uint64_t nb_sectors;\n\n    int page, dbd, buflen, page_control;\n\n    uint8_t *p;\n\n    uint8_t dev_specific_param;\n\n\n\n    dbd = req->cmd.buf[1]  & 0x8;\n\n    page = req->cmd.buf[2] & 0x3f;\n\n    page_control = (req->cmd.buf[2] & 0xc0) >> 6;\n\n    DPRINTF(\"Mode Sense(%d) (page %d, len %d, page_control %d)\\n\",\n\n        (req->cmd.buf[0] == MODE_SENSE) ? 6 : 10, page, len, page_control);\n\n    memset(outbuf, 0, req->cmd.xfer);\n\n    p = outbuf;\n\n\n\n    if (bdrv_is_read_only(s->bs)) {\n\n        dev_specific_param = 0x80; /* Readonly.  */\n\n    } else {\n\n        dev_specific_param = 0x00;\n\n    }\n\n\n\n    if (req->cmd.buf[0] == MODE_SENSE) {\n\n        p[1] = 0; /* Default media type.  */\n\n        p[2] = dev_specific_param;\n\n        p[3] = 0; /* Block descriptor length.  */\n\n        p += 4;\n\n    } else { /* MODE_SENSE_10 */\n\n        p[2] = 0; /* Default media type.  */\n\n        p[3] = dev_specific_param;\n\n        p[6] = p[7] = 0; /* Block descriptor length.  */\n\n        p += 8;\n\n    }\n\n\n\n    bdrv_get_geometry(s->bs, &nb_sectors);\n\n    if ((~dbd) & nb_sectors) {\n\n        if (req->cmd.buf[0] == MODE_SENSE) {\n\n            outbuf[3] = 8; /* Block descriptor length  */\n\n        } else { /* MODE_SENSE_10 */\n\n            outbuf[7] = 8; /* Block descriptor length  */\n\n        }\n\n        nb_sectors /= s->cluster_size;\n\n        if (nb_sectors > 0xffffff)\n\n            nb_sectors = 0;\n\n        p[0] = 0; /* media density code */\n\n        p[1] = (nb_sectors >> 16) & 0xff;\n\n        p[2] = (nb_sectors >> 8) & 0xff;\n\n        p[3] = nb_sectors & 0xff;\n\n        p[4] = 0; /* reserved */\n\n        p[5] = 0; /* bytes 5-7 are the sector size in bytes */\n\n        p[6] = s->cluster_size * 2;\n\n        p[7] = 0;\n\n        p += 8;\n\n    }\n\n\n\n    if (page_control == 3) { /* Saved Values */\n\n        return -1; /* ILLEGAL_REQUEST */\n\n    }\n\n\n\n    switch (page) {\n\n    case 0x04:\n\n    case 0x05:\n\n    case 0x08:\n\n    case 0x2a:\n\n        p += mode_sense_page(req, page, p, page_control);\n\n        break;\n\n    case 0x3f:\n\n        p += mode_sense_page(req, 0x08, p, page_control);\n\n        p += mode_sense_page(req, 0x2a, p, page_control);\n\n        break;\n\n    default:\n\n        return -1; /* ILLEGAL_REQUEST */\n\n    }\n\n\n\n    buflen = p - outbuf;\n\n    /*\n\n     * The mode data length field specifies the length in bytes of the\n\n     * following data that is available to be transferred. The mode data\n\n     * length does not include itself.\n\n     */\n\n    if (req->cmd.buf[0] == MODE_SENSE) {\n\n        outbuf[0] = buflen - 1;\n\n    } else { /* MODE_SENSE_10 */\n\n        outbuf[0] = ((buflen - 2) >> 8) & 0xff;\n\n        outbuf[1] = (buflen - 2) & 0xff;\n\n    }\n\n    if (buflen > req->cmd.xfer)\n\n        buflen = req->cmd.xfer;\n\n    return buflen;\n\n}\n", "idx": 12326, "_split": "test", "_hash": "39ab52175e4b678cf9aeb997a1c8bb4a"}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "void tcg_add_target_add_op_defs(const TCGTargetOpDef *tdefs)\n\n{\n\n    TCGOpcode op;\n\n    TCGOpDef *def;\n\n    const char *ct_str;\n\n    int i, nb_args;\n\n\n\n    for(;;) {\n\n        if (tdefs->op == (TCGOpcode)-1)\n\n            break;\n\n        op = tdefs->op;\n\n        assert((unsigned)op < NB_OPS);\n\n        def = &tcg_op_defs[op];\n\n#if defined(CONFIG_DEBUG_TCG)\n\n        /* Duplicate entry in op definitions? */\n\n        assert(!def->used);\n\n        def->used = 1;\n\n#endif\n\n        nb_args = def->nb_iargs + def->nb_oargs;\n\n        for(i = 0; i < nb_args; i++) {\n\n            ct_str = tdefs->args_ct_str[i];\n\n            /* Incomplete TCGTargetOpDef entry? */\n\n            assert(ct_str != NULL);\n\n            tcg_regset_clear(def->args_ct[i].u.regs);\n\n            def->args_ct[i].ct = 0;\n\n            if (ct_str[0] >= '0' && ct_str[0] <= '9') {\n\n                int oarg;\n\n                oarg = ct_str[0] - '0';\n\n                assert(oarg < def->nb_oargs);\n\n                assert(def->args_ct[oarg].ct & TCG_CT_REG);\n\n                /* TCG_CT_ALIAS is for the output arguments. The input\n\n                   argument is tagged with TCG_CT_IALIAS. */\n\n                def->args_ct[i] = def->args_ct[oarg];\n\n                def->args_ct[oarg].ct = TCG_CT_ALIAS;\n\n                def->args_ct[oarg].alias_index = i;\n\n                def->args_ct[i].ct |= TCG_CT_IALIAS;\n\n                def->args_ct[i].alias_index = oarg;\n\n            } else {\n\n                for(;;) {\n\n                    if (*ct_str == '\\0')\n\n                        break;\n\n                    switch(*ct_str) {\n\n                    case 'i':\n\n                        def->args_ct[i].ct |= TCG_CT_CONST;\n\n                        ct_str++;\n\n                        break;\n\n                    default:\n\n                        if (target_parse_constraint(&def->args_ct[i], &ct_str) < 0) {\n\n                            fprintf(stderr, \"Invalid constraint '%s' for arg %d of operation '%s'\\n\",\n\n                                    ct_str, i, def->name);\n\n                            exit(1);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        /* TCGTargetOpDef entry with too much information? */\n\n        assert(i == TCG_MAX_OP_ARGS || tdefs->args_ct_str[i] == NULL);\n\n\n\n        /* sort the constraints (XXX: this is just an heuristic) */\n\n        sort_constraints(def, 0, def->nb_oargs);\n\n        sort_constraints(def, def->nb_oargs, def->nb_iargs);\n\n\n\n#if 0\n\n        {\n\n            int i;\n\n\n\n            printf(\"%s: sorted=\", def->name);\n\n            for(i = 0; i < def->nb_oargs + def->nb_iargs; i++)\n\n                printf(\" %d\", def->sorted_args[i]);\n\n            printf(\"\\n\");\n\n        }\n\n#endif\n\n        tdefs++;\n\n    }\n\n\n\n#if defined(CONFIG_DEBUG_TCG)\n\n    i = 0;\n\n    for (op = 0; op < tcg_op_defs_max; op++) {\n\n        const TCGOpDef *def = &tcg_op_defs[op];\n\n        if (def->flags & TCG_OPF_NOT_PRESENT) {\n\n            /* Wrong entry in op definitions? */\n\n            if (def->used) {\n\n                fprintf(stderr, \"Invalid op definition for %s\\n\", def->name);\n\n                i = 1;\n\n            }\n\n        } else {\n\n            /* Missing entry in op definitions? */\n\n            if (!def->used) {\n\n                fprintf(stderr, \"Missing op definition for %s\\n\", def->name);\n\n                i = 1;\n\n            }\n\n        }\n\n    }\n\n    if (i == 1) {\n\n        tcg_abort();\n\n    }\n\n#endif\n\n}\n", "idx": 12329, "_split": "test", "_hash": "4577c707d20ac58a495b30822d9559ee"}
{"project": "qemu", "commit_id": "06ac27f683c52890a6d174adba8c92354fa1eceb", "target": 1, "func": "void AUD_vlog (const char *cap, const char *fmt, va_list ap)\n\n{\n\n    if (conf.log_to_monitor) {\n\n        if (cap) {\n\n            monitor_printf(default_mon, \"%s: \", cap);\n\n        }\n\n\n\n        monitor_vprintf(default_mon, fmt, ap);\n\n    }\n\n    else {\n\n        if (cap) {\n\n            fprintf (stderr, \"%s: \", cap);\n\n        }\n\n\n\n        vfprintf (stderr, fmt, ap);\n\n    }\n\n}\n", "idx": 12347, "_split": "test", "_hash": "bb0b23810a4e1aa230505f29cff1e496"}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static int start_auth_vencrypt_subauth(VncState *vs)\n\n{\n\n    switch (vs->vd->subauth) {\n\n    case VNC_AUTH_VENCRYPT_TLSNONE:\n\n    case VNC_AUTH_VENCRYPT_X509NONE:\n\n       VNC_DEBUG(\"Accept TLS auth none\\n\");\n\n       vnc_write_u32(vs, 0); /* Accept auth completion */\n\n       vnc_read_when(vs, protocol_client_init, 1);\n\n       break;\n\n\n\n    case VNC_AUTH_VENCRYPT_TLSVNC:\n\n    case VNC_AUTH_VENCRYPT_X509VNC:\n\n       VNC_DEBUG(\"Start TLS auth VNC\\n\");\n\n       return start_auth_vnc(vs);\n\n\n\n    default: /* Should not be possible, but just in case */\n\n       VNC_DEBUG(\"Reject auth %d\\n\", vs->vd->auth);\n\n       vnc_write_u8(vs, 1);\n\n       if (vs->minor >= 8) {\n\n           static const char err[] = \"Unsupported authentication type\";\n\n           vnc_write_u32(vs, sizeof(err));\n\n           vnc_write(vs, err, sizeof(err));\n\n       }\n\n       vnc_client_error(vs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12365, "_split": "test", "_hash": "82e97ceda0fb94180453f705c57dc642"}
{"project": "qemu", "commit_id": "1dde716ed6719c341c1bfa427781f0715af90cbc", "target": 0, "func": "iscsi_unmap_cb(struct iscsi_context *iscsi, int status,\n\n                     void *command_data, void *opaque)\n\n{\n\n    IscsiAIOCB *acb = opaque;\n\n\n\n    if (acb->canceled != 0) {\n\n        return;\n\n    }\n\n\n\n    acb->status = 0;\n\n    if (status < 0) {\n\n        error_report(\"Failed to unmap data on iSCSI lun. %s\",\n\n                     iscsi_get_error(iscsi));\n\n        acb->status = -EIO;\n\n    }\n\n\n\n    iscsi_schedule_bh(acb);\n\n}\n", "idx": 12367, "_split": "test", "_hash": "24c65359336d471d345b7876e8a30918"}
{"project": "qemu", "commit_id": "abd696e4f74a9d30801c6ae2693efe4e5979c2f2", "target": 0, "func": "static void virtio_notify(struct subchannel_id schid)\n\n{\n\n    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);\n\n}\n", "idx": 12376, "_split": "test", "_hash": "373cbdee7c27ed33b6117df0b47383ab"}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)\n\n{\n\n    struct kvm_x86_mce mce = {\n\n        .bank = 9,\n\n        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN\n\n                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S\n\n                  | 0xc0,\n\n        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,\n\n        .addr = paddr,\n\n        .misc = (MCM_ADDR_PHYS << 6) | 0xc,\n\n    };\n\n\n\n    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);\n\n    kvm_mce_broadcast_rest(env);\n\n}\n", "idx": 12377, "_split": "test", "_hash": "016e6c03c30bcb0de88129e1256978ef"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void lm32_evr_init(QEMUMachineInitArgs *args)\n\n{\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    LM32CPU *cpu;\n\n    CPULM32State *env;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *address_space_mem =  get_system_memory();\n\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n\n    qemu_irq *cpu_irq, irq[32];\n\n    ResetInfo *reset_info;\n\n    int i;\n\n\n\n    /* memory map */\n\n    target_phys_addr_t flash_base  = 0x04000000;\n\n    size_t flash_sector_size       = 256 * 1024;\n\n    size_t flash_size              = 32 * 1024 * 1024;\n\n    target_phys_addr_t ram_base    = 0x08000000;\n\n    size_t ram_size                = 64 * 1024 * 1024;\n\n    target_phys_addr_t timer0_base = 0x80002000;\n\n    target_phys_addr_t uart0_base  = 0x80006000;\n\n    target_phys_addr_t timer1_base = 0x8000a000;\n\n    int uart0_irq                  = 0;\n\n    int timer0_irq                 = 1;\n\n    int timer1_irq                 = 3;\n\n\n\n    reset_info = g_malloc0(sizeof(ResetInfo));\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"lm32-full\";\n\n    }\n\n    cpu = cpu_lm32_init(cpu_model);\n\n    env = &cpu->env;\n\n    reset_info->cpu = cpu;\n\n\n\n    reset_info->flash_base = flash_base;\n\n\n\n    memory_region_init_ram(phys_ram, \"lm32_evr.sdram\", ram_size);\n\n    vmstate_register_ram_global(phys_ram);\n\n    memory_region_add_subregion(address_space_mem, ram_base, phys_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    /* Spansion S29NS128P */\n\n    pflash_cfi02_register(flash_base, NULL, \"lm32_evr.flash\", flash_size,\n\n                          dinfo ? dinfo->bdrv : NULL, flash_sector_size,\n\n                          flash_size / flash_sector_size, 1, 2,\n\n                          0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1);\n\n\n\n    /* create irq lines */\n\n    cpu_irq = qemu_allocate_irqs(cpu_irq_handler, env, 1);\n\n    env->pic_state = lm32_pic_init(*cpu_irq);\n\n    for (i = 0; i < 32; i++) {\n\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n\n    }\n\n\n\n    sysbus_create_simple(\"lm32-uart\", uart0_base, irq[uart0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer0_base, irq[timer0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer1_base, irq[timer1_irq]);\n\n\n\n    /* make sure juart isn't the first chardev */\n\n    env->juart_state = lm32_juart_init();\n\n\n\n    reset_info->bootstrap_pc = flash_base;\n\n\n\n    if (kernel_filename) {\n\n        uint64_t entry;\n\n        int kernel_size;\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n\n                               1, ELF_MACHINE, 0);\n\n        reset_info->bootstrap_pc = entry;\n\n\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename, ram_base,\n\n                                              ram_size);\n\n            reset_info->bootstrap_pc = ram_base;\n\n        }\n\n\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n}\n", "idx": 12378, "_split": "test", "_hash": "07922558d30680c048cd55e2be2ee5f5"}
{"project": "qemu", "commit_id": "075a1fe788d36b271ec25507466c30b9a90b5d54", "target": 0, "func": "static void gen_msa_branch(CPUMIPSState *env, DisasContext *ctx, uint32_t op1)\n\n{\n\n    uint8_t df = (ctx->opcode >> 21) & 0x3;\n\n    uint8_t wt = (ctx->opcode >> 16) & 0x1f;\n\n    int64_t s16 = (int16_t)ctx->opcode;\n\n\n\n    check_msa_access(ctx);\n\n\n\n    if (ctx->insn_flags & ISA_MIPS32R6 && ctx->hflags & MIPS_HFLAG_BMASK) {\n\n        generate_exception_end(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n    switch (op1) {\n\n    case OPC_BZ_V:\n\n    case OPC_BNZ_V:\n\n        {\n\n            TCGv_i64 t0 = tcg_temp_new_i64();\n\n            tcg_gen_or_i64(t0, msa_wr_d[wt<<1], msa_wr_d[(wt<<1)+1]);\n\n            tcg_gen_setcondi_i64((op1 == OPC_BZ_V) ?\n\n                    TCG_COND_EQ : TCG_COND_NE, t0, t0, 0);\n\n            tcg_gen_trunc_i64_tl(bcond, t0);\n\n            tcg_temp_free_i64(t0);\n\n        }\n\n        break;\n\n    case OPC_BZ_B:\n\n    case OPC_BZ_H:\n\n    case OPC_BZ_W:\n\n    case OPC_BZ_D:\n\n        gen_check_zero_element(bcond, df, wt);\n\n        break;\n\n    case OPC_BNZ_B:\n\n    case OPC_BNZ_H:\n\n    case OPC_BNZ_W:\n\n    case OPC_BNZ_D:\n\n        gen_check_zero_element(bcond, df, wt);\n\n        tcg_gen_setcondi_tl(TCG_COND_EQ, bcond, bcond, 0);\n\n        break;\n\n    }\n\n\n\n    ctx->btarget = ctx->pc + (s16 << 2) + 4;\n\n\n\n    ctx->hflags |= MIPS_HFLAG_BC;\n\n    ctx->hflags |= MIPS_HFLAG_BDS32;\n\n}\n", "idx": 12383, "_split": "test", "_hash": "ec17eabc51339b19bdc0766253a9d55b"}
{"project": "qemu", "commit_id": "65c0f1e9558c7c762cdb333406243fff1d687117", "target": 0, "func": "static QObject *parse_keyword(JSONParserContext *ctxt, QList **tokens)\n\n{\n\n    QObject *token, *ret;\n\n    QList *working = qlist_copy(*tokens);\n\n\n\n    token = qlist_pop(working);\n\n    if (token == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_get_type(token) != JSON_KEYWORD) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_is_keyword(token, \"true\")) {\n\n        ret = QOBJECT(qbool_from_int(true));\n\n    } else if (token_is_keyword(token, \"false\")) {\n\n        ret = QOBJECT(qbool_from_int(false));\n\n    } else {\n\n        parse_error(ctxt, token, \"invalid keyword `%s'\", token_get_value(token));\n\n        goto out;\n\n    }\n\n\n\n    qobject_decref(token);\n\n    QDECREF(*tokens);\n\n    *tokens = working;\n\n\n\n    return ret;\n\n\n\nout: \n\n    qobject_decref(token);\n\n    QDECREF(working);\n\n\n\n    return NULL;\n\n}\n", "idx": 12384, "_split": "test", "_hash": "327bb7d577b8d020d88ec7356d265554"}
{"project": "qemu", "commit_id": "7ef8cf9a0861b6f67f5e57428478c31bfd811651", "target": 1, "func": "static int scsi_req_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)\n\n{\n\n    cmd->xfer = scsi_cdb_length(buf);\n\n    switch (buf[0]) {\n\n    case TEST_UNIT_READY:\n\n    case REWIND:\n\n    case START_STOP:\n\n    case SET_CAPACITY:\n\n    case WRITE_FILEMARKS:\n\n    case WRITE_FILEMARKS_16:\n\n    case SPACE:\n\n    case RESERVE:\n\n    case RELEASE:\n\n    case ERASE:\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n    case SEEK_10:\n\n    case SYNCHRONIZE_CACHE:\n\n    case SYNCHRONIZE_CACHE_16:\n\n    case LOCATE_16:\n\n    case LOCK_UNLOCK_CACHE:\n\n    case SET_CD_SPEED:\n\n    case SET_LIMITS:\n\n    case WRITE_LONG_10:\n\n    case UPDATE_BLOCK:\n\n    case RESERVE_TRACK:\n\n    case SET_READ_AHEAD:\n\n    case PRE_FETCH:\n\n    case PRE_FETCH_16:\n\n    case ALLOW_OVERWRITE:\n\n        cmd->xfer = 0;\n\n        break;\n\n    case VERIFY_10:\n\n    case VERIFY_12:\n\n    case VERIFY_16:\n\n        if ((buf[1] & 2) == 0) {\n\n            cmd->xfer = 0;\n\n        } else if ((buf[1] & 4) == 1) {\n\n            cmd->xfer = 1;\n\n        }\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case MODE_SENSE:\n\n        break;\n\n    case WRITE_SAME_10:\n\n    case WRITE_SAME_16:\n\n        cmd->xfer = dev->blocksize;\n\n        break;\n\n    case READ_CAPACITY_10:\n\n        cmd->xfer = 8;\n\n        break;\n\n    case READ_BLOCK_LIMITS:\n\n        cmd->xfer = 6;\n\n        break;\n\n    case SEND_VOLUME_TAG:\n\n        /* GPCMD_SET_STREAMING from multimedia commands.  */\n\n        if (dev->type == TYPE_ROM) {\n\n            cmd->xfer = buf[10] | (buf[9] << 8);\n\n        } else {\n\n            cmd->xfer = buf[9] | (buf[8] << 8);\n\n        }\n\n        break;\n\n    case WRITE_6:\n\n        /* length 0 means 256 blocks */\n\n        if (cmd->xfer == 0) {\n\n            cmd->xfer = 256;\n\n        }\n\n    case WRITE_10:\n\n    case WRITE_VERIFY_10:\n\n    case WRITE_12:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_16:\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n        /* length 0 means 256 blocks */\n\n        if (cmd->xfer == 0) {\n\n            cmd->xfer = 256;\n\n        }\n\n    case READ_10:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case READ_12:\n\n    case READ_16:\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case FORMAT_UNIT:\n\n        /* MMC mandates the parameter list to be 12-bytes long.  Parameters\n\n         * for block devices are restricted to the header right now.  */\n\n        if (dev->type == TYPE_ROM && (buf[1] & 16)) {\n\n            cmd->xfer = 12;\n\n        } else {\n\n            cmd->xfer = (buf[1] & 16) == 0 ? 0 : (buf[1] & 32 ? 8 : 4);\n\n        }\n\n        break;\n\n    case INQUIRY:\n\n    case RECEIVE_DIAGNOSTIC:\n\n    case SEND_DIAGNOSTIC:\n\n        cmd->xfer = buf[4] | (buf[3] << 8);\n\n        break;\n\n    case READ_CD:\n\n    case READ_BUFFER:\n\n    case WRITE_BUFFER:\n\n    case SEND_CUE_SHEET:\n\n        cmd->xfer = buf[8] | (buf[7] << 8) | (buf[6] << 16);\n\n        break;\n\n    case PERSISTENT_RESERVE_OUT:\n\n        cmd->xfer = ldl_be_p(&buf[5]) & 0xffffffffULL;\n\n        break;\n\n    case ERASE_12:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* MMC command GET PERFORMANCE.  */\n\n            cmd->xfer = scsi_get_performance_length(buf[9] | (buf[8] << 8),\n\n                                                    buf[10], buf[1] & 0x1f);\n\n        }\n\n        break;\n\n    case MECHANISM_STATUS:\n\n    case READ_DVD_STRUCTURE:\n\n    case SEND_DVD_STRUCTURE:\n\n    case MAINTENANCE_OUT:\n\n    case MAINTENANCE_IN:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* GPCMD_REPORT_KEY and GPCMD_SEND_KEY from multi media commands */\n\n            cmd->xfer = buf[9] | (buf[8] << 8);\n\n        }\n\n        break;\n\n    case ATA_PASSTHROUGH_12:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* BLANK command of MMC */\n\n            cmd->xfer = 0;\n\n        } else {\n\n            cmd->xfer = ata_passthrough_12_xfer_size(dev, buf);\n\n        }\n\n        break;\n\n    case ATA_PASSTHROUGH_16:\n\n        cmd->xfer = ata_passthrough_16_xfer_size(dev, buf);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 12409, "_split": "test", "_hash": "8d3e03ace1ac7488f012412ababe2009"}
{"project": "qemu", "commit_id": "7df9381b7aa56c897e344f3bfe43bf5848bbd3e0", "target": 0, "func": "static int vfio_add_std_cap(VFIOPCIDevice *vdev, uint8_t pos)\n\n{\n\n    PCIDevice *pdev = &vdev->pdev;\n\n    uint8_t cap_id, next, size;\n\n    int ret;\n\n\n\n    cap_id = pdev->config[pos];\n\n    next = pdev->config[pos + PCI_CAP_LIST_NEXT];\n\n\n\n    /*\n\n     * If it becomes important to configure capabilities to their actual\n\n     * size, use this as the default when it's something we don't recognize.\n\n     * Since QEMU doesn't actually handle many of the config accesses,\n\n     * exact size doesn't seem worthwhile.\n\n     */\n\n    size = vfio_std_cap_max_size(pdev, pos);\n\n\n\n    /*\n\n     * pci_add_capability always inserts the new capability at the head\n\n     * of the chain.  Therefore to end up with a chain that matches the\n\n     * physical device, we insert from the end by making this recursive.\n\n     * This is also why we pre-calculate size above as cached config space\n\n     * will be changed as we unwind the stack.\n\n     */\n\n    if (next) {\n\n        ret = vfio_add_std_cap(vdev, next);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n    } else {\n\n        /* Begin the rebuild, use QEMU emulated list bits */\n\n        pdev->config[PCI_CAPABILITY_LIST] = 0;\n\n        vdev->emulated_config_bits[PCI_CAPABILITY_LIST] = 0xff;\n\n        vdev->emulated_config_bits[PCI_STATUS] |= PCI_STATUS_CAP_LIST;\n\n    }\n\n\n\n    /* Use emulated next pointer to allow dropping caps */\n\n    pci_set_byte(vdev->emulated_config_bits + pos + PCI_CAP_LIST_NEXT, 0xff);\n\n\n\n    switch (cap_id) {\n\n    case PCI_CAP_ID_MSI:\n\n        ret = vfio_msi_setup(vdev, pos);\n\n        break;\n\n    case PCI_CAP_ID_EXP:\n\n        vfio_check_pcie_flr(vdev, pos);\n\n        ret = vfio_setup_pcie_cap(vdev, pos, size);\n\n        break;\n\n    case PCI_CAP_ID_MSIX:\n\n        ret = vfio_msix_setup(vdev, pos);\n\n        break;\n\n    case PCI_CAP_ID_PM:\n\n        vfio_check_pm_reset(vdev, pos);\n\n        vdev->pm_cap = pos;\n\n        ret = pci_add_capability(pdev, cap_id, pos, size);\n\n        break;\n\n    case PCI_CAP_ID_AF:\n\n        vfio_check_af_flr(vdev, pos);\n\n        ret = pci_add_capability(pdev, cap_id, pos, size);\n\n        break;\n\n    default:\n\n        ret = pci_add_capability(pdev, cap_id, pos, size);\n\n        break;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        error_report(\"vfio: %04x:%02x:%02x.%x Error adding PCI capability \"\n\n                     \"0x%x[0x%x]@0x%x: %d\", vdev->host.domain,\n\n                     vdev->host.bus, vdev->host.slot, vdev->host.function,\n\n                     cap_id, size, pos, ret);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12434, "_split": "test", "_hash": "3fd61267daed09771f6c7626e3018eec"}
{"project": "qemu", "commit_id": "fb9fb692312a84ebc6e9c10da6f374c5871ff7b0", "target": 0, "func": "int cpu_exec(CPUState *env1)\n\n{\n\n#define DECLARE_HOST_REGS 1\n\n#include \"hostregs_helper.h\"\n\n    int ret, interrupt_request;\n\n    TranslationBlock *tb;\n\n    uint8_t *tc_ptr;\n\n    unsigned long next_tb;\n\n\n\n    if (cpu_halted(env1) == EXCP_HALTED)\n\n        return EXCP_HALTED;\n\n\n\n    cpu_single_env = env1;\n\n\n\n    /* first we save global registers */\n\n#define SAVE_HOST_REGS 1\n\n#include \"hostregs_helper.h\"\n\n    env = env1;\n\n\n\n#if defined(TARGET_I386)\n\n    /* put eflags in CPU temporary format */\n\n    CC_SRC = env->eflags & (CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n    DF = 1 - (2 * ((env->eflags >> 10) & 1));\n\n    CC_OP = CC_OP_EFLAGS;\n\n    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n#elif defined(TARGET_SPARC)\n\n#elif defined(TARGET_M68K)\n\n    env->cc_op = CC_OP_FLAGS;\n\n    env->cc_dest = env->sr & 0xf;\n\n    env->cc_x = (env->sr >> 4) & 1;\n\n#elif defined(TARGET_ALPHA)\n\n#elif defined(TARGET_ARM)\n\n#elif defined(TARGET_PPC)\n\n#elif defined(TARGET_MICROBLAZE)\n\n#elif defined(TARGET_MIPS)\n\n#elif defined(TARGET_SH4)\n\n#elif defined(TARGET_CRIS)\n\n#elif defined(TARGET_S390X)\n\n    /* XXXXX */\n\n#else\n\n#error unsupported target CPU\n\n#endif\n\n    env->exception_index = -1;\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    for(;;) {\n\n        if (setjmp(env->jmp_env) == 0) {\n\n#if defined(__sparc__) && !defined(CONFIG_SOLARIS)\n\n#undef env\n\n                    env = cpu_single_env;\n\n#define env cpu_single_env\n\n#endif\n\n            /* if an exception is pending, we execute it here */\n\n            if (env->exception_index >= 0) {\n\n                if (env->exception_index >= EXCP_INTERRUPT) {\n\n                    /* exit request from the cpu execution loop */\n\n                    ret = env->exception_index;\n\n                    if (ret == EXCP_DEBUG)\n\n                        cpu_handle_debug_exception(env);\n\n                    break;\n\n                } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n                    /* if user mode only, we simulate a fake exception\n\n                       which will be handled outside the cpu execution\n\n                       loop */\n\n#if defined(TARGET_I386)\n\n                    do_interrupt_user(env->exception_index,\n\n                                      env->exception_is_int,\n\n                                      env->error_code,\n\n                                      env->exception_next_eip);\n\n                    /* successfully delivered */\n\n                    env->old_exception = -1;\n\n#endif\n\n                    ret = env->exception_index;\n\n                    break;\n\n#else\n\n#if defined(TARGET_I386)\n\n                    /* simulate a real cpu exception. On i386, it can\n\n                       trigger new exceptions, but we do not handle\n\n                       double or triple faults yet. */\n\n                    do_interrupt(env->exception_index,\n\n                                 env->exception_is_int,\n\n                                 env->error_code,\n\n                                 env->exception_next_eip, 0);\n\n                    /* successfully delivered */\n\n                    env->old_exception = -1;\n\n#elif defined(TARGET_PPC)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_MICROBLAZE)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_MIPS)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_SPARC)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_ARM)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_SH4)\n\n\t\t    do_interrupt(env);\n\n#elif defined(TARGET_ALPHA)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_CRIS)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_M68K)\n\n                    do_interrupt(0);\n\n#endif\n\n                    env->exception_index = -1;\n\n#endif\n\n                }\n\n            }\n\n\n\n            if (kvm_enabled()) {\n\n                kvm_cpu_exec(env);\n\n                longjmp(env->jmp_env, 1);\n\n            }\n\n\n\n            next_tb = 0; /* force lookup of first TB */\n\n            for(;;) {\n\n                interrupt_request = env->interrupt_request;\n\n                if (unlikely(interrupt_request)) {\n\n                    if (unlikely(env->singlestep_enabled & SSTEP_NOIRQ)) {\n\n                        /* Mask out external interrupts for this step. */\n\n                        interrupt_request &= ~(CPU_INTERRUPT_HARD |\n\n                                               CPU_INTERRUPT_FIQ |\n\n                                               CPU_INTERRUPT_SMI |\n\n                                               CPU_INTERRUPT_NMI);\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_DEBUG) {\n\n                        env->interrupt_request &= ~CPU_INTERRUPT_DEBUG;\n\n                        env->exception_index = EXCP_DEBUG;\n\n                        cpu_loop_exit();\n\n                    }\n\n#if defined(TARGET_ARM) || defined(TARGET_SPARC) || defined(TARGET_MIPS) || \\\n\n    defined(TARGET_PPC) || defined(TARGET_ALPHA) || defined(TARGET_CRIS) || \\\n\n    defined(TARGET_MICROBLAZE)\n\n                    if (interrupt_request & CPU_INTERRUPT_HALT) {\n\n                        env->interrupt_request &= ~CPU_INTERRUPT_HALT;\n\n                        env->halted = 1;\n\n                        env->exception_index = EXCP_HLT;\n\n                        cpu_loop_exit();\n\n                    }\n\n#endif\n\n#if defined(TARGET_I386)\n\n                    if (interrupt_request & CPU_INTERRUPT_INIT) {\n\n                            svm_check_intercept(SVM_EXIT_INIT);\n\n                            do_cpu_init(env);\n\n                            env->exception_index = EXCP_HALTED;\n\n                            cpu_loop_exit();\n\n                    } else if (interrupt_request & CPU_INTERRUPT_SIPI) {\n\n                            do_cpu_sipi(env);\n\n                    } else if (env->hflags2 & HF2_GIF_MASK) {\n\n                        if ((interrupt_request & CPU_INTERRUPT_SMI) &&\n\n                            !(env->hflags & HF_SMM_MASK)) {\n\n                            svm_check_intercept(SVM_EXIT_SMI);\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_SMI;\n\n                            do_smm_enter();\n\n                            next_tb = 0;\n\n                        } else if ((interrupt_request & CPU_INTERRUPT_NMI) &&\n\n                                   !(env->hflags2 & HF2_NMI_MASK)) {\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_NMI;\n\n                            env->hflags2 |= HF2_NMI_MASK;\n\n                            do_interrupt(EXCP02_NMI, 0, 0, 0, 1);\n\n                            next_tb = 0;\n\n\t\t\t} else if (interrupt_request & CPU_INTERRUPT_MCE) {\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_MCE;\n\n                            do_interrupt(EXCP12_MCHK, 0, 0, 0, 0);\n\n                            next_tb = 0;\n\n                        } else if ((interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                                   (((env->hflags2 & HF2_VINTR_MASK) && \n\n                                     (env->hflags2 & HF2_HIF_MASK)) ||\n\n                                    (!(env->hflags2 & HF2_VINTR_MASK) && \n\n                                     (env->eflags & IF_MASK && \n\n                                      !(env->hflags & HF_INHIBIT_IRQ_MASK))))) {\n\n                            int intno;\n\n                            svm_check_intercept(SVM_EXIT_INTR);\n\n                            env->interrupt_request &= ~(CPU_INTERRUPT_HARD | CPU_INTERRUPT_VIRQ);\n\n                            intno = cpu_get_pic_interrupt(env);\n\n                            qemu_log_mask(CPU_LOG_TB_IN_ASM, \"Servicing hardware INT=0x%02x\\n\", intno);\n\n#if defined(__sparc__) && !defined(CONFIG_SOLARIS)\n\n#undef env\n\n                    env = cpu_single_env;\n\n#define env cpu_single_env\n\n#endif\n\n                            do_interrupt(intno, 0, 0, 0, 1);\n\n                            /* ensure that no TB jump will be modified as\n\n                               the program flow was changed */\n\n                            next_tb = 0;\n\n#if !defined(CONFIG_USER_ONLY)\n\n                        } else if ((interrupt_request & CPU_INTERRUPT_VIRQ) &&\n\n                                   (env->eflags & IF_MASK) && \n\n                                   !(env->hflags & HF_INHIBIT_IRQ_MASK)) {\n\n                            int intno;\n\n                            /* FIXME: this should respect TPR */\n\n                            svm_check_intercept(SVM_EXIT_VINTR);\n\n                            intno = ldl_phys(env->vm_vmcb + offsetof(struct vmcb, control.int_vector));\n\n                            qemu_log_mask(CPU_LOG_TB_IN_ASM, \"Servicing virtual hardware INT=0x%02x\\n\", intno);\n\n                            do_interrupt(intno, 0, 0, 0, 1);\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_VIRQ;\n\n                            next_tb = 0;\n\n#endif\n\n                        }\n\n                    }\n\n#elif defined(TARGET_PPC)\n\n#if 0\n\n                    if ((interrupt_request & CPU_INTERRUPT_RESET)) {\n\n                        cpu_reset(env);\n\n                    }\n\n#endif\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        ppc_hw_interrupt(env);\n\n                        if (env->pending_interrupts == 0)\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_HARD;\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_MICROBLAZE)\n\n                    if ((interrupt_request & CPU_INTERRUPT_HARD)\n\n                        && (env->sregs[SR_MSR] & MSR_IE)\n\n                        && !(env->sregs[SR_MSR] & (MSR_EIP | MSR_BIP))\n\n                        && !(env->iflags & (D_FLAG | IMM_FLAG))) {\n\n                        env->exception_index = EXCP_IRQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_MIPS)\n\n                    if ((interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                        (env->CP0_Status & env->CP0_Cause & CP0Ca_IP_mask) &&\n\n                        (env->CP0_Status & (1 << CP0St_IE)) &&\n\n                        !(env->CP0_Status & (1 << CP0St_EXL)) &&\n\n                        !(env->CP0_Status & (1 << CP0St_ERL)) &&\n\n                        !(env->hflags & MIPS_HFLAG_DM)) {\n\n                        /* Raise it */\n\n                        env->exception_index = EXCP_EXT_INTERRUPT;\n\n                        env->error_code = 0;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_SPARC)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        if (cpu_interrupts_enabled(env) &&\n\n                            env->interrupt_index > 0) {\n\n                            int pil = env->interrupt_index & 0xf;\n\n                            int type = env->interrupt_index & 0xf0;\n\n\n\n                            if (((type == TT_EXTINT) &&\n\n                                  cpu_pil_allowed(env, pil)) ||\n\n                                  type != TT_EXTINT) {\n\n                                env->exception_index = env->interrupt_index;\n\n                                do_interrupt(env);\n\n                                next_tb = 0;\n\n                            }\n\n                        }\n\n\t\t    } else if (interrupt_request & CPU_INTERRUPT_TIMER) {\n\n\t\t\t//do_interrupt(0, 0, 0, 0, 0);\n\n\t\t\tenv->interrupt_request &= ~CPU_INTERRUPT_TIMER;\n\n\t\t    }\n\n#elif defined(TARGET_ARM)\n\n                    if (interrupt_request & CPU_INTERRUPT_FIQ\n\n                        && !(env->uncached_cpsr & CPSR_F)) {\n\n                        env->exception_index = EXCP_FIQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n                    /* ARMv7-M interrupt return works by loading a magic value\n\n                       into the PC.  On real hardware the load causes the\n\n                       return to occur.  The qemu implementation performs the\n\n                       jump normally, then does the exception return when the\n\n                       CPU tries to execute code at the magic address.\n\n                       This will cause the magic PC value to be pushed to\n\n                       the stack if an interrupt occured at the wrong time.\n\n                       We avoid this by disabling interrupts when\n\n                       pc contains a magic address.  */\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD\n\n                        && ((IS_M(env) && env->regs[15] < 0xfffffff0)\n\n                            || !(env->uncached_cpsr & CPSR_I))) {\n\n                        env->exception_index = EXCP_IRQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_SH4)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_ALPHA)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_CRIS)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD\n\n                        && (env->pregs[PR_CCS] & I_FLAG)) {\n\n                        env->exception_index = EXCP_IRQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_NMI\n\n                        && (env->pregs[PR_CCS] & M_FLAG)) {\n\n                        env->exception_index = EXCP_NMI;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_M68K)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD\n\n                        && ((env->sr & SR_I) >> SR_I_SHIFT)\n\n                            < env->pending_level) {\n\n                        /* Real hardware gets the interrupt vector via an\n\n                           IACK cycle at this point.  Current emulated\n\n                           hardware doesn't rely on this, so we\n\n                           provide/save the vector when the interrupt is\n\n                           first signalled.  */\n\n                        env->exception_index = env->pending_vector;\n\n                        do_interrupt(1);\n\n                        next_tb = 0;\n\n                    }\n\n#endif\n\n                   /* Don't use the cached interupt_request value,\n\n                      do_interrupt may have updated the EXITTB flag. */\n\n                    if (env->interrupt_request & CPU_INTERRUPT_EXITTB) {\n\n                        env->interrupt_request &= ~CPU_INTERRUPT_EXITTB;\n\n                        /* ensure that no TB jump will be modified as\n\n                           the program flow was changed */\n\n                        next_tb = 0;\n\n                    }\n\n                }\n\n                if (unlikely(env->exit_request)) {\n\n                    env->exit_request = 0;\n\n                    env->exception_index = EXCP_INTERRUPT;\n\n                    cpu_loop_exit();\n\n                }\n\n#ifdef CONFIG_DEBUG_EXEC\n\n                if (qemu_loglevel_mask(CPU_LOG_TB_CPU)) {\n\n                    /* restore flags in standard format */\n\n#if defined(TARGET_I386)\n\n                    env->eflags = env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK);\n\n                    log_cpu_state(env, X86_DUMP_CCOP);\n\n                    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n#elif defined(TARGET_ARM)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_SPARC)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_PPC)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_M68K)\n\n                    cpu_m68k_flush_flags(env, env->cc_op);\n\n                    env->cc_op = CC_OP_FLAGS;\n\n                    env->sr = (env->sr & 0xffe0)\n\n                              | env->cc_dest | (env->cc_x << 4);\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_MICROBLAZE)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_MIPS)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_SH4)\n\n\t\t    log_cpu_state(env, 0);\n\n#elif defined(TARGET_ALPHA)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_CRIS)\n\n                    log_cpu_state(env, 0);\n\n#else\n\n#error unsupported target CPU\n\n#endif\n\n                }\n\n#endif\n\n                spin_lock(&tb_lock);\n\n                tb = tb_find_fast();\n\n                /* Note: we do it here to avoid a gcc bug on Mac OS X when\n\n                   doing it in tb_find_slow */\n\n                if (tb_invalidated_flag) {\n\n                    /* as some TB could have been invalidated because\n\n                       of memory exceptions while generating the code, we\n\n                       must recompute the hash index here */\n\n                    next_tb = 0;\n\n                    tb_invalidated_flag = 0;\n\n                }\n\n#ifdef CONFIG_DEBUG_EXEC\n\n                qemu_log_mask(CPU_LOG_EXEC, \"Trace 0x%08lx [\" TARGET_FMT_lx \"] %s\\n\",\n\n                             (long)tb->tc_ptr, tb->pc,\n\n                             lookup_symbol(tb->pc));\n\n#endif\n\n                /* see if we can patch the calling TB. When the TB\n\n                   spans two pages, we cannot safely do a direct\n\n                   jump. */\n\n                if (next_tb != 0 && tb->page_addr[1] == -1) {\n\n                    tb_add_jump((TranslationBlock *)(next_tb & ~3), next_tb & 3, tb);\n\n                }\n\n                spin_unlock(&tb_lock);\n\n\n\n                /* cpu_interrupt might be called while translating the\n\n                   TB, but before it is linked into a potentially\n\n                   infinite loop and becomes env->current_tb. Avoid\n\n                   starting execution if there is a pending interrupt. */\n\n                if (!unlikely (env->exit_request)) {\n\n                    env->current_tb = tb;\n\n                    tc_ptr = tb->tc_ptr;\n\n                /* execute the generated code */\n\n#if defined(__sparc__) && !defined(CONFIG_SOLARIS)\n\n#undef env\n\n                    env = cpu_single_env;\n\n#define env cpu_single_env\n\n#endif\n\n                    next_tb = tcg_qemu_tb_exec(tc_ptr);\n\n                    env->current_tb = NULL;\n\n                    if ((next_tb & 3) == 2) {\n\n                        /* Instruction counter expired.  */\n\n                        int insns_left;\n\n                        tb = (TranslationBlock *)(long)(next_tb & ~3);\n\n                        /* Restore PC.  */\n\n                        cpu_pc_from_tb(env, tb);\n\n                        insns_left = env->icount_decr.u32;\n\n                        if (env->icount_extra && insns_left >= 0) {\n\n                            /* Refill decrementer and continue execution.  */\n\n                            env->icount_extra += insns_left;\n\n                            if (env->icount_extra > 0xffff) {\n\n                                insns_left = 0xffff;\n\n                            } else {\n\n                                insns_left = env->icount_extra;\n\n                            }\n\n                            env->icount_extra -= insns_left;\n\n                            env->icount_decr.u16.low = insns_left;\n\n                        } else {\n\n                            if (insns_left > 0) {\n\n                                /* Execute remaining instructions.  */\n\n                                cpu_exec_nocache(insns_left, tb);\n\n                            }\n\n                            env->exception_index = EXCP_INTERRUPT;\n\n                            next_tb = 0;\n\n                            cpu_loop_exit();\n\n                        }\n\n                    }\n\n                }\n\n                /* reset soft MMU for next block (it can currently\n\n                   only be set by a memory fault) */\n\n            } /* for(;;) */\n\n        }\n\n    } /* for(;;) */\n\n\n\n\n\n#if defined(TARGET_I386)\n\n    /* restore flags in standard format */\n\n    env->eflags = env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK);\n\n#elif defined(TARGET_ARM)\n\n    /* XXX: Save/restore host fpu exception state?.  */\n\n#elif defined(TARGET_SPARC)\n\n#elif defined(TARGET_PPC)\n\n#elif defined(TARGET_M68K)\n\n    cpu_m68k_flush_flags(env, env->cc_op);\n\n    env->cc_op = CC_OP_FLAGS;\n\n    env->sr = (env->sr & 0xffe0)\n\n              | env->cc_dest | (env->cc_x << 4);\n\n#elif defined(TARGET_MICROBLAZE)\n\n#elif defined(TARGET_MIPS)\n\n#elif defined(TARGET_SH4)\n\n#elif defined(TARGET_ALPHA)\n\n#elif defined(TARGET_CRIS)\n\n#elif defined(TARGET_S390X)\n\n    /* XXXXX */\n\n#else\n\n#error unsupported target CPU\n\n#endif\n\n\n\n    /* restore global registers */\n\n#include \"hostregs_helper.h\"\n\n\n\n    /* fail safe : never use cpu_single_env outside cpu_exec() */\n\n    cpu_single_env = NULL;\n\n    return ret;\n\n}\n", "idx": 12451, "_split": "test", "_hash": "d344a7acccde92879482ef4a2b8bf2d2"}
{"project": "qemu", "commit_id": "42a6686b2f6199d086a58edd7731faeb2dbe7c14", "target": 0, "func": "void HELPER(v7m_msr)(CPUARMState *env, uint32_t maskreg, uint32_t val)\n\n{\n\n    /* We're passed bits [11..0] of the instruction; extract\n\n     * SYSm and the mask bits.\n\n     * Invalid combinations of SYSm and mask are UNPREDICTABLE;\n\n     * we choose to treat them as if the mask bits were valid.\n\n     * NB that the pseudocode 'mask' variable is bits [11..10],\n\n     * whereas ours is [11..8].\n\n     */\n\n    uint32_t mask = extract32(maskreg, 8, 4);\n\n    uint32_t reg = extract32(maskreg, 0, 8);\n\n\n\n    if (arm_current_el(env) == 0 && reg > 7) {\n\n        /* only xPSR sub-fields may be written by unprivileged */\n\n        return;\n\n    }\n\n\n\n    switch (reg) {\n\n    case 0 ... 7: /* xPSR sub-fields */\n\n        /* only APSR is actually writable */\n\n        if (!(reg & 4)) {\n\n            uint32_t apsrmask = 0;\n\n\n\n            if (mask & 8) {\n\n                apsrmask |= XPSR_NZCV | XPSR_Q;\n\n            }\n\n            if ((mask & 4) && arm_feature(env, ARM_FEATURE_THUMB_DSP)) {\n\n                apsrmask |= XPSR_GE;\n\n            }\n\n            xpsr_write(env, val, apsrmask);\n\n        }\n\n        break;\n\n    case 8: /* MSP */\n\n        if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {\n\n            env->v7m.other_sp = val;\n\n        } else {\n\n            env->regs[13] = val;\n\n        }\n\n        break;\n\n    case 9: /* PSP */\n\n        if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {\n\n            env->regs[13] = val;\n\n        } else {\n\n            env->v7m.other_sp = val;\n\n        }\n\n        break;\n\n    case 16: /* PRIMASK */\n\n        env->v7m.primask[env->v7m.secure] = val & 1;\n\n        break;\n\n    case 17: /* BASEPRI */\n\n        env->v7m.basepri[env->v7m.secure] = val & 0xff;\n\n        break;\n\n    case 18: /* BASEPRI_MAX */\n\n        val &= 0xff;\n\n        if (val != 0 && (val < env->v7m.basepri[env->v7m.secure]\n\n                         || env->v7m.basepri[env->v7m.secure] == 0)) {\n\n            env->v7m.basepri[env->v7m.secure] = val;\n\n        }\n\n        break;\n\n    case 19: /* FAULTMASK */\n\n        env->v7m.faultmask = val & 1;\n\n        break;\n\n    case 20: /* CONTROL */\n\n        /* Writing to the SPSEL bit only has an effect if we are in\n\n         * thread mode; other bits can be updated by any privileged code.\n\n         * switch_v7m_sp() deals with updating the SPSEL bit in\n\n         * env->v7m.control, so we only need update the others.\n\n         */\n\n        if (!arm_v7m_is_handler_mode(env)) {\n\n            switch_v7m_sp(env, (val & R_V7M_CONTROL_SPSEL_MASK) != 0);\n\n        }\n\n        env->v7m.control &= ~R_V7M_CONTROL_NPRIV_MASK;\n\n        env->v7m.control |= val & R_V7M_CONTROL_NPRIV_MASK;\n\n        break;\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"Attempt to write unknown special\"\n\n                                       \" register %d\\n\", reg);\n\n        return;\n\n    }\n\n}\n", "idx": 12452, "_split": "test", "_hash": "27e9bc5138acd41252ac03ac8fa11599"}
{"project": "qemu", "commit_id": "d7651f150d61936344c4fab45eaeb0716c606af2", "target": 0, "func": "static bool migrate_caps_check(bool *cap_list,\n\n                               MigrationCapabilityStatusList *params,\n\n                               Error **errp)\n\n{\n\n    MigrationCapabilityStatusList *cap;\n\n    bool old_postcopy_cap;\n\n\n\n    old_postcopy_cap = cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM];\n\n\n\n    for (cap = params; cap; cap = cap->next) {\n\n        cap_list[cap->value->capability] = cap->value->state;\n\n    }\n\n\n\n#ifndef CONFIG_LIVE_BLOCK_MIGRATION\n\n    if (cap_list[MIGRATION_CAPABILITY_BLOCK]) {\n\n        error_setg(errp, \"QEMU compiled without old-style (blk/-b, inc/-i) \"\n\n                   \"block migration\");\n\n        error_append_hint(errp, \"Use drive_mirror+NBD instead.\\n\");\n\n        return false;\n\n    }\n\n#endif\n\n\n\n    if (cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM]) {\n\n        if (cap_list[MIGRATION_CAPABILITY_COMPRESS]) {\n\n            /* The decompression threads asynchronously write into RAM\n\n             * rather than use the atomic copies needed to avoid\n\n             * userfaulting.  It should be possible to fix the decompression\n\n             * threads for compatibility in future.\n\n             */\n\n            error_setg(errp, \"Postcopy is not currently compatible \"\n\n                       \"with compression\");\n\n            return false;\n\n        }\n\n\n\n        /* This check is reasonably expensive, so only when it's being\n\n         * set the first time, also it's only the destination that needs\n\n         * special support.\n\n         */\n\n        if (!old_postcopy_cap && runstate_check(RUN_STATE_INMIGRATE) &&\n\n            !postcopy_ram_supported_by_host()) {\n\n            /* postcopy_ram_supported_by_host will have emitted a more\n\n             * detailed message\n\n             */\n\n            error_setg(errp, \"Postcopy is not supported\");\n\n            return false;\n\n        }\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 12470, "_split": "test", "_hash": "01cae9ec668ef21bc3d9a1c44621ef95"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,\n\n    bool is_read)\n\n{\n\n    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);\n\n    VirtIOBlock *s = req->dev;\n\n\n\n    if (action == BLOCK_ERROR_ACTION_STOP) {\n\n        req->next = s->rq;\n\n        s->rq = req;\n\n    } else if (action == BLOCK_ERROR_ACTION_REPORT) {\n\n        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);\n\n        block_acct_done(bdrv_get_stats(s->bs), &req->acct);\n\n        virtio_blk_free_request(req);\n\n    }\n\n\n\n    bdrv_error_action(s->bs, action, is_read, error);\n\n    return action != BLOCK_ERROR_ACTION_IGNORE;\n\n}\n", "idx": 12477, "_split": "test", "_hash": "f5fe20dc64b76f8e071ecf117722407b"}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,\n\n                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],\n\n                omap_clk fclk, omap_clk iclk)\n\n{\n\n    struct omap_mmc_s *s = (struct omap_mmc_s *)\n\n            g_malloc0(sizeof(struct omap_mmc_s));\n\n\n\n    s->irq = irq;\n\n    s->dma = dma;\n\n    s->clk = fclk;\n\n    s->lines = 4;\n\n    s->rev = 2;\n\n\n\n    omap_mmc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, \"omap.mmc\",\n\n                          omap_l4_region_size(ta, 0));\n\n    omap_l4_attach(ta, 0, &s->iomem);\n\n\n\n    /* Instantiate the storage */\n\n    s->card = sd_init(bd, false);\n\n    if (s->card == NULL) {\n\n        exit(1);\n\n    }\n\n\n\n    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];\n\n    sd_set_cb(s->card, NULL, s->cdet);\n\n\n\n    return s;\n\n}\n", "idx": 12499, "_split": "test", "_hash": "7499177d32142beb287d8ee81024936a"}
{"project": "qemu", "commit_id": "dca6eeed8c2a1c131d161139428dd18a35e58b03", "target": 0, "func": "static void calxeda_init(MachineState *machine, enum cxmachines machine_id)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    DeviceState *dev = NULL;\n\n    SysBusDevice *busdev;\n\n    qemu_irq pic[128];\n\n    int n;\n\n    qemu_irq cpu_irq[4];\n\n    qemu_irq cpu_fiq[4];\n\n    MemoryRegion *sysram;\n\n    MemoryRegion *dram;\n\n    MemoryRegion *sysmem;\n\n    char *sysboot_filename;\n\n\n\n    if (!cpu_model) {\n\n        switch (machine_id) {\n\n        case CALXEDA_HIGHBANK:\n\n            cpu_model = \"cortex-a9\";\n\n            break;\n\n        case CALXEDA_MIDWAY:\n\n            cpu_model = \"cortex-a15\";\n\n            break;\n\n        }\n\n    }\n\n\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        ObjectClass *oc = cpu_class_by_name(TYPE_ARM_CPU, cpu_model);\n\n        Object *cpuobj;\n\n        ARMCPU *cpu;\n\n        Error *err = NULL;\n\n\n\n        if (!oc) {\n\n            error_report(\"Unable to find CPU definition\");\n\n            exit(1);\n\n        }\n\n\n\n        cpuobj = object_new(object_class_get_name(oc));\n\n        cpu = ARM_CPU(cpuobj);\n\n\n\n        /* By default A9 and A15 CPUs have EL3 enabled.  This board does not\n\n         * currently support EL3 so the CPU EL3 property is disabled before\n\n         * realization.\n\n         */\n\n        if (object_property_find(cpuobj, \"has_el3\", NULL)) {\n\n            object_property_set_bool(cpuobj, false, \"has_el3\", &err);\n\n            if (err) {\n\n                error_report_err(err);\n\n                exit(1);\n\n            }\n\n        }\n\n\n\n        if (object_property_find(cpuobj, \"reset-cbar\", NULL)) {\n\n            object_property_set_int(cpuobj, MPCORE_PERIPHBASE,\n\n                                    \"reset-cbar\", &error_abort);\n\n        }\n\n        object_property_set_bool(cpuobj, true, \"realized\", &err);\n\n        if (err) {\n\n            error_report_err(err);\n\n            exit(1);\n\n        }\n\n        cpu_irq[n] = qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ);\n\n        cpu_fiq[n] = qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_FIQ);\n\n    }\n\n\n\n    sysmem = get_system_memory();\n\n    dram = g_new(MemoryRegion, 1);\n\n    memory_region_allocate_system_memory(dram, NULL, \"highbank.dram\", ram_size);\n\n    /* SDRAM at address zero.  */\n\n    memory_region_add_subregion(sysmem, 0, dram);\n\n\n\n    sysram = g_new(MemoryRegion, 1);\n\n    memory_region_init_ram(sysram, NULL, \"highbank.sysram\", 0x8000,\n\n                           &error_fatal);\n\n    memory_region_add_subregion(sysmem, 0xfff88000, sysram);\n\n    if (bios_name != NULL) {\n\n        sysboot_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (sysboot_filename != NULL) {\n\n            if (load_image_targphys(sysboot_filename, 0xfff88000, 0x8000) < 0) {\n\n                hw_error(\"Unable to load %s\\n\", bios_name);\n\n            }\n\n            g_free(sysboot_filename);\n\n        } else {\n\n           hw_error(\"Unable to find %s\\n\", bios_name);\n\n        }\n\n    }\n\n\n\n    switch (machine_id) {\n\n    case CALXEDA_HIGHBANK:\n\n        dev = qdev_create(NULL, \"l2x0\");\n\n        qdev_init_nofail(dev);\n\n        busdev = SYS_BUS_DEVICE(dev);\n\n        sysbus_mmio_map(busdev, 0, 0xfff12000);\n\n\n\n        dev = qdev_create(NULL, \"a9mpcore_priv\");\n\n        break;\n\n    case CALXEDA_MIDWAY:\n\n        dev = qdev_create(NULL, \"a15mpcore_priv\");\n\n        break;\n\n    }\n\n    qdev_prop_set_uint32(dev, \"num-cpu\", smp_cpus);\n\n    qdev_prop_set_uint32(dev, \"num-irq\", NIRQ_GIC);\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, MPCORE_PERIPHBASE);\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        sysbus_connect_irq(busdev, n, cpu_irq[n]);\n\n        sysbus_connect_irq(busdev, n + smp_cpus, cpu_fiq[n]);\n\n    }\n\n\n\n    for (n = 0; n < 128; n++) {\n\n        pic[n] = qdev_get_gpio_in(dev, n);\n\n    }\n\n\n\n    dev = qdev_create(NULL, \"sp804\");\n\n    qdev_prop_set_uint32(dev, \"freq0\", 150000000);\n\n    qdev_prop_set_uint32(dev, \"freq1\", 150000000);\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, 0xfff34000);\n\n    sysbus_connect_irq(busdev, 0, pic[18]);\n\n    sysbus_create_simple(\"pl011\", 0xfff36000, pic[20]);\n\n\n\n    dev = qdev_create(NULL, \"highbank-regs\");\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, 0xfff3c000);\n\n\n\n    sysbus_create_simple(\"pl061\", 0xfff30000, pic[14]);\n\n    sysbus_create_simple(\"pl061\", 0xfff31000, pic[15]);\n\n    sysbus_create_simple(\"pl061\", 0xfff32000, pic[16]);\n\n    sysbus_create_simple(\"pl061\", 0xfff33000, pic[17]);\n\n    sysbus_create_simple(\"pl031\", 0xfff35000, pic[19]);\n\n    sysbus_create_simple(\"pl022\", 0xfff39000, pic[23]);\n\n\n\n    sysbus_create_simple(\"sysbus-ahci\", 0xffe08000, pic[83]);\n\n\n\n    if (nd_table[0].used) {\n\n        qemu_check_nic_model(&nd_table[0], \"xgmac\");\n\n        dev = qdev_create(NULL, \"xgmac\");\n\n        qdev_set_nic_properties(dev, &nd_table[0]);\n\n        qdev_init_nofail(dev);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xfff50000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[77]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 1, pic[78]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 2, pic[79]);\n\n\n\n        qemu_check_nic_model(&nd_table[1], \"xgmac\");\n\n        dev = qdev_create(NULL, \"xgmac\");\n\n        qdev_set_nic_properties(dev, &nd_table[1]);\n\n        qdev_init_nofail(dev);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xfff51000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[80]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 1, pic[81]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 2, pic[82]);\n\n    }\n\n\n\n    highbank_binfo.ram_size = ram_size;\n\n    highbank_binfo.kernel_filename = kernel_filename;\n\n    highbank_binfo.kernel_cmdline = kernel_cmdline;\n\n    highbank_binfo.initrd_filename = initrd_filename;\n\n    /* highbank requires a dtb in order to boot, and the dtb will override\n\n     * the board ID. The following value is ignored, so set it to -1 to be\n\n     * clear that the value is meaningless.\n\n     */\n\n    highbank_binfo.board_id = -1;\n\n    highbank_binfo.nb_cpus = smp_cpus;\n\n    highbank_binfo.loader_start = 0;\n\n    highbank_binfo.write_secondary_boot = hb_write_secondary;\n\n    highbank_binfo.secondary_cpu_reset_hook = hb_reset_secondary;\n\n    arm_load_kernel(ARM_CPU(first_cpu), &highbank_binfo);\n\n}\n", "idx": 12544, "_split": "test", "_hash": "da0e8fd792b7e72f0d4c22fc08a2a2cc"}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "static int get_phys_addr_v5(CPUState *env, uint32_t address, int access_type,\n\n\t\t\t    int is_user, uint32_t *phys_ptr, int *prot)\n\n{\n\n    int code;\n\n    uint32_t table;\n\n    uint32_t desc;\n\n    int type;\n\n    int ap;\n\n    int domain;\n\n    uint32_t phys_addr;\n\n\n\n    /* Pagetable walk.  */\n\n    /* Lookup l1 descriptor.  */\n\n    table = get_level1_table_address(env, address);\n\n    desc = ldl_phys(table);\n\n    type = (desc & 3);\n\n    domain = (env->cp15.c3 >> ((desc >> 4) & 0x1e)) & 3;\n\n    if (type == 0) {\n\n        /* Section translation fault.  */\n\n        code = 5;\n\n        goto do_fault;\n\n    }\n\n    if (domain == 0 || domain == 2) {\n\n        if (type == 2)\n\n            code = 9; /* Section domain fault.  */\n\n        else\n\n            code = 11; /* Page domain fault.  */\n\n        goto do_fault;\n\n    }\n\n    if (type == 2) {\n\n        /* 1Mb section.  */\n\n        phys_addr = (desc & 0xfff00000) | (address & 0x000fffff);\n\n        ap = (desc >> 10) & 3;\n\n        code = 13;\n\n    } else {\n\n        /* Lookup l2 entry.  */\n\n\tif (type == 1) {\n\n\t    /* Coarse pagetable.  */\n\n\t    table = (desc & 0xfffffc00) | ((address >> 10) & 0x3fc);\n\n\t} else {\n\n\t    /* Fine pagetable.  */\n\n\t    table = (desc & 0xfffff000) | ((address >> 8) & 0xffc);\n\n\t}\n\n        desc = ldl_phys(table);\n\n        switch (desc & 3) {\n\n        case 0: /* Page translation fault.  */\n\n            code = 7;\n\n            goto do_fault;\n\n        case 1: /* 64k page.  */\n\n            phys_addr = (desc & 0xffff0000) | (address & 0xffff);\n\n            ap = (desc >> (4 + ((address >> 13) & 6))) & 3;\n\n            break;\n\n        case 2: /* 4k page.  */\n\n            phys_addr = (desc & 0xfffff000) | (address & 0xfff);\n\n            ap = (desc >> (4 + ((address >> 13) & 6))) & 3;\n\n            break;\n\n        case 3: /* 1k page.  */\n\n\t    if (type == 1) {\n\n\t\tif (arm_feature(env, ARM_FEATURE_XSCALE)) {\n\n\t\t    phys_addr = (desc & 0xfffff000) | (address & 0xfff);\n\n\t\t} else {\n\n\t\t    /* Page translation fault.  */\n\n\t\t    code = 7;\n\n\t\t    goto do_fault;\n\n\t\t}\n\n\t    } else {\n\n\t\tphys_addr = (desc & 0xfffffc00) | (address & 0x3ff);\n\n\t    }\n\n            ap = (desc >> 4) & 3;\n\n            break;\n\n        default:\n\n            /* Never happens, but compiler isn't smart enough to tell.  */\n\n            abort();\n\n        }\n\n        code = 15;\n\n    }\n\n    *prot = check_ap(env, ap, domain, access_type, is_user);\n\n    if (!*prot) {\n\n        /* Access permission fault.  */\n\n        goto do_fault;\n\n    }\n\n    *phys_ptr = phys_addr;\n\n    return 0;\n\ndo_fault:\n\n    return code | (domain << 4);\n\n}\n", "idx": 12545, "_split": "test", "_hash": "4a0cb740c3fc005a38001911f49e96d9"}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static void vmxnet3_update_mcast_filters(VMXNET3State *s)\n\n{\n\n    uint16_t list_bytes =\n\n        VMXNET3_READ_DRV_SHARED16(s->drv_shmem,\n\n                                  devRead.rxFilterConf.mfTableLen);\n\n\n\n    s->mcast_list_len = list_bytes / sizeof(s->mcast_list[0]);\n\n\n\n    s->mcast_list = g_realloc(s->mcast_list, list_bytes);\n\n    if (!s->mcast_list) {\n\n        if (s->mcast_list_len == 0) {\n\n            VMW_CFPRN(\"Current multicast list is empty\");\n\n        } else {\n\n            VMW_ERPRN(\"Failed to allocate multicast list of %d elements\",\n\n                      s->mcast_list_len);\n\n        }\n\n        s->mcast_list_len = 0;\n\n    } else {\n\n        int i;\n\n        hwaddr mcast_list_pa =\n\n            VMXNET3_READ_DRV_SHARED64(s->drv_shmem,\n\n                                      devRead.rxFilterConf.mfTablePA);\n\n\n\n        pci_dma_read(PCI_DEVICE(s), mcast_list_pa, s->mcast_list, list_bytes);\n\n\n\n        VMW_CFPRN(\"Current multicast list len is %d:\", s->mcast_list_len);\n\n        for (i = 0; i < s->mcast_list_len; i++) {\n\n            VMW_CFPRN(\"\\t\" MAC_FMT, MAC_ARG(s->mcast_list[i].a));\n\n        }\n\n    }\n\n}\n", "idx": 12548, "_split": "test", "_hash": "f1df23acbe1027b32b2c291dcc7a6d92"}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "void hmp_info_snapshots(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockDriverState *bs, *bs1;\n\n    QEMUSnapshotInfo *sn_tab, *sn, s, *sn_info = &s;\n\n    int nb_sns, i, ret, available;\n\n    int total;\n\n    int *available_snapshots;\n\n\n\n    bs = find_vmstate_bs();\n\n    if (!bs) {\n\n        monitor_printf(mon, \"No available block device supports snapshots\\n\");\n\n        return;\n\n    }\n\n\n\n    nb_sns = bdrv_snapshot_list(bs, &sn_tab);\n\n    if (nb_sns < 0) {\n\n        monitor_printf(mon, \"bdrv_snapshot_list: error %d\\n\", nb_sns);\n\n        return;\n\n    }\n\n\n\n    if (nb_sns == 0) {\n\n        monitor_printf(mon, \"There is no snapshot available.\\n\");\n\n        return;\n\n    }\n\n\n\n    available_snapshots = g_malloc0(sizeof(int) * nb_sns);\n\n    total = 0;\n\n    for (i = 0; i < nb_sns; i++) {\n\n        sn = &sn_tab[i];\n\n        available = 1;\n\n        bs1 = NULL;\n\n\n\n        while ((bs1 = bdrv_next(bs1))) {\n\n            if (bdrv_can_snapshot(bs1) && bs1 != bs) {\n\n                ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str);\n\n                if (ret < 0) {\n\n                    available = 0;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (available) {\n\n            available_snapshots[total] = i;\n\n            total++;\n\n        }\n\n    }\n\n\n\n    if (total > 0) {\n\n        bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, NULL);\n\n        monitor_printf(mon, \"\\n\");\n\n        for (i = 0; i < total; i++) {\n\n            sn = &sn_tab[available_snapshots[i]];\n\n            bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, sn);\n\n            monitor_printf(mon, \"\\n\");\n\n        }\n\n    } else {\n\n        monitor_printf(mon, \"There is no suitable snapshot available\\n\");\n\n    }\n\n\n\n    g_free(sn_tab);\n\n    g_free(available_snapshots);\n\n\n\n}\n", "idx": 12558, "_split": "test", "_hash": "aa93f4ac6e6c7e32f13928b4727aaf9b"}
{"project": "qemu", "commit_id": "913a87885f589d263e682c2eb6637c6e14538061", "target": 1, "func": "static int cirrus_bitblt_solidfill(CirrusVGAState *s, int blt_rop)\n\n{\n\n    cirrus_fill_t rop_func;\n\n\n\n    if (blit_is_unsafe(s)) {\n\n        return 0;\n\n    }\n\n    rop_func = cirrus_fill[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n\n    rop_func(s, s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),\n\n             s->cirrus_blt_dstpitch,\n\n             s->cirrus_blt_width, s->cirrus_blt_height);\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n\t\t\t     s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n\t\t\t     s->cirrus_blt_height);\n\n    cirrus_bitblt_reset(s);\n\n    return 1;\n\n}\n", "idx": 12596, "_split": "test", "_hash": "0e7e8891dcef3a29cefef7798e7036d2"}
{"project": "qemu", "commit_id": "2e061a7c86d77c599676d89c3461f8efe9c275b1", "target": 0, "func": "static void do_info_commands(Monitor *mon, QObject **ret_data)\n\n{\n\n    QList *cmd_list;\n\n    const mon_cmd_t *cmd;\n\n\n\n    cmd_list = qlist_new();\n\n\n\n    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {\n\n        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&\n\n            !compare_cmd(cmd->name, \"info\")) {\n\n            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));\n\n        }\n\n    }\n\n\n\n    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {\n\n        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {\n\n            char buf[128];\n\n            snprintf(buf, sizeof(buf), \"query-%s\", cmd->name);\n\n            qlist_append_obj(cmd_list, get_cmd_dict(buf));\n\n        }\n\n    }\n\n\n\n    *ret_data = QOBJECT(cmd_list);\n\n}\n", "idx": 12624, "_split": "test", "_hash": "18cbd98837bdb5ade1b69c3e017bc58f"}
{"project": "qemu", "commit_id": "f1c2dc7c866a939c39c14729290a21309a1c8a38", "target": 0, "func": "static void spapr_msi_write(void *opaque, hwaddr addr,\n\n                            uint64_t data, unsigned size)\n\n{\n\n    sPAPRPHBState *phb = opaque;\n\n    int ndev = addr >> 16;\n\n    int vec = ((addr & 0xFFFF) >> 2) | data;\n\n    uint32_t irq = phb->msi_table[ndev].irq + vec;\n\n\n\n    trace_spapr_pci_msi_write(addr, data, irq);\n\n\n\n    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));\n\n}\n", "idx": 12635, "_split": "test", "_hash": "441e5371b87291b9809ca83df42c9f44"}
{"project": "qemu", "commit_id": "2a1639291bf9f3c88c62d10459fedaa677536ff5", "target": 0, "func": "static void pxa2xx_pm_write(void *opaque, target_phys_addr_t addr,\n\n                uint32_t value)\n\n{\n\n    struct pxa2xx_state_s *s = (struct pxa2xx_state_s *) opaque;\n\n    if (addr > s->pm_base + PCMD31) {\n\n        /* Special case: PWRI2C registers appear in the same range.  */\n\n        pxa2xx_i2c_write(s->i2c[1], addr, value);\n\n        return;\n\n    }\n\n    addr -= s->pm_base;\n\n\n\n    switch (addr) {\n\n    case PMCR:\n\n        s->pm_regs[addr >> 2] &= 0x15 & ~(value & 0x2a);\n\n        s->pm_regs[addr >> 2] |= value & 0x15;\n\n        break;\n\n\n\n    case PSSR:\t/* Read-clean registers */\n\n    case RCSR:\n\n    case PKSR:\n\n        s->pm_regs[addr >> 2] &= ~value;\n\n        break;\n\n\n\n    default:\t/* Read-write registers */\n\n        if (addr >= PMCR && addr <= PCMD31 && !(addr & 3)) {\n\n            s->pm_regs[addr >> 2] = value;\n\n            break;\n\n        }\n\n\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n}\n", "idx": 12642, "_split": "test", "_hash": "05175755210b5de431a986b31f3b3c7a"}
{"project": "qemu", "commit_id": "9c605cb13547a5faa5cb1092e3e44ac8b0d0b841", "target": 0, "func": "CPUX86State *cpu_x86_init(void)\n\n{\n\n    CPUX86State *env;\n\n    int i;\n\n    static int inited;\n\n\n\n    cpu_x86_tblocks_init();\n\n\n\n    env = malloc(sizeof(CPUX86State));\n\n    if (!env)\n\n        return NULL;\n\n    memset(env, 0, sizeof(CPUX86State));\n\n    /* basic FPU init */\n\n    for(i = 0;i < 8; i++)\n\n        env->fptags[i] = 1;\n\n    env->fpuc = 0x37f;\n\n    /* flags setup */\n\n    env->eflags = 0;\n\n\n\n    /* init various static tables */\n\n    if (!inited) {\n\n        inited = 1;\n\n        optimize_flags_init();\n\n    }\n\n    return env;\n\n}\n", "idx": 12645, "_split": "test", "_hash": "397b6161ce21c142faf1318ebd2a97a3"}
{"project": "qemu", "commit_id": "c60bf3391bf4cb79b7adc6650094e21671ddaabd", "target": 0, "func": "void readline_show_prompt(ReadLineState *rs)\n\n{\n\n    monitor_printf(rs->mon, \"%s\", rs->prompt);\n\n    monitor_flush(rs->mon);\n\n    rs->last_cmd_buf_index = 0;\n\n    rs->last_cmd_buf_size = 0;\n\n    rs->esc_state = IS_NORM;\n\n}\n", "idx": 12663, "_split": "test", "_hash": "86843ac1ea8696c6f9e207b21f970ddf"}
{"project": "qemu", "commit_id": "f61eddcb2bb5cbbdd1d911b7e937db9affc29028", "target": 0, "func": "static int parallel_parse(const char *devname)\n\n{\n\n    static int index = 0;\n\n    char label[32];\n\n\n\n    if (strcmp(devname, \"none\") == 0)\n\n        return 0;\n\n    if (index == MAX_PARALLEL_PORTS) {\n\n        fprintf(stderr, \"qemu: too many parallel ports\\n\");\n\n        exit(1);\n\n    }\n\n    snprintf(label, sizeof(label), \"parallel%d\", index);\n\n    parallel_hds[index] = qemu_chr_new(label, devname, NULL);\n\n    if (!parallel_hds[index]) {\n\n        fprintf(stderr, \"qemu: could not connect parallel device\"\n\n                \" to character backend '%s'\\n\", devname);\n\n        return -1;\n\n    }\n\n    index++;\n\n    return 0;\n\n}\n", "idx": 12667, "_split": "test", "_hash": "aaaf1341fbf7dc34f8b263a6e33036a9"}
{"project": "qemu", "commit_id": "a9e1c28ddaae5a48415fec1f336b5560eb85d3e1", "target": 0, "func": "START_TEST(qfloat_destroy_test)\n\n{\n\n    QFloat *qf = qfloat_from_double(0.0);\n\n    QDECREF(qf);\n\n}\n", "idx": 12668, "_split": "test", "_hash": "103e12ad47b21ee3d99e05e0a7d5f016"}
{"project": "qemu", "commit_id": "b97400caef60ccfb0bc81c59f8bd824c43a0d6c8", "target": 0, "func": "static int local_lstat(FsContext *fs_ctx, V9fsPath *fs_path, struct stat *stbuf)\n\n{\n\n    int err;\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    err =  lstat(rpath(fs_ctx, path, buffer), stbuf);\n\n    if (err) {\n\n        return err;\n\n    }\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        /* Actual credentials are part of extended attrs */\n\n        uid_t tmp_uid;\n\n        gid_t tmp_gid;\n\n        mode_t tmp_mode;\n\n        dev_t tmp_dev;\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.uid\", &tmp_uid,\n\n                    sizeof(uid_t)) > 0) {\n\n            stbuf->st_uid = tmp_uid;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.gid\", &tmp_gid,\n\n                    sizeof(gid_t)) > 0) {\n\n            stbuf->st_gid = tmp_gid;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.mode\",\n\n                    &tmp_mode, sizeof(mode_t)) > 0) {\n\n            stbuf->st_mode = tmp_mode;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.rdev\", &tmp_dev,\n\n                        sizeof(dev_t)) > 0) {\n\n                stbuf->st_rdev = tmp_dev;\n\n        }\n\n    }\n\n    return err;\n\n}\n", "idx": 12672, "_split": "test", "_hash": "4c76e5b7a4f1cb9c543b6d0921807415"}
{"project": "qemu", "commit_id": "becf8217deb2afc347d5172d9f30c8a8964b8b27", "target": 0, "func": "void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,\n\n                                     uintptr_t retaddr)\n\n{\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    int t;\n\n\n\n    cs->exception_index = EXCP_PGM;\n\n    env->int_pgm_code = excp;\n\n\n\n    /* Use the (ultimate) callers address to find the insn that trapped.  */\n\n    cpu_restore_state(cs, retaddr);\n\n\n\n    /* Advance past the insn.  */\n\n    t = cpu_ldub_code(env, env->psw.addr);\n\n    env->int_pgm_ilen = t = get_ilen(t);\n\n    env->psw.addr += t;\n\n\n\n    cpu_loop_exit(cs);\n\n}\n", "idx": 12686, "_split": "test", "_hash": "32a9f3eb952573cea477e74325e2f028"}
{"project": "qemu", "commit_id": "a277c3e094d5e9f653ccc861f59e07c94c7fe6c7", "target": 0, "func": "static int usb_host_init(void)\n\n{\n\n    const struct libusb_pollfd **poll;\n\n    int i, rc;\n\n\n\n    if (ctx) {\n\n        return 0;\n\n    }\n\n    rc = libusb_init(&ctx);\n\n    if (rc != 0) {\n\n        return -1;\n\n    }\n\n    libusb_set_debug(ctx, loglevel);\n\n\n\n    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,\n\n                                usb_host_del_fd,\n\n                                ctx);\n\n    poll = libusb_get_pollfds(ctx);\n\n    if (poll) {\n\n        for (i = 0; poll[i] != NULL; i++) {\n\n            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);\n\n        }\n\n    }\n\n    free(poll);\n\n    return 0;\n\n}\n", "idx": 12701, "_split": "test", "_hash": "d6fc6134b4c4efb70e3b3628eeadfdf8"}
{"project": "qemu", "commit_id": "2dfb4c033f2f8fbad252bed1ba3e0fed112cbb7c", "target": 0, "func": "SnapshotInfo *qmp_blockdev_snapshot_delete_internal_sync(const char *device,\n\n                                                         bool has_id,\n\n                                                         const char *id,\n\n                                                         bool has_name,\n\n                                                         const char *name,\n\n                                                         Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockBackend *blk;\n\n    AioContext *aio_context;\n\n    QEMUSnapshotInfo sn;\n\n    Error *local_err = NULL;\n\n    SnapshotInfo *info = NULL;\n\n    int ret;\n\n\n\n    blk = blk_by_name(device);\n\n    if (!blk) {\n\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n\n                  \"Device '%s' not found\", device);\n\n        return NULL;\n\n    }\n\n\n\n    aio_context = blk_get_aio_context(blk);\n\n    aio_context_acquire(aio_context);\n\n\n\n    if (!has_id) {\n\n        id = NULL;\n\n    }\n\n\n\n    if (!has_name) {\n\n        name = NULL;\n\n    }\n\n\n\n    if (!id && !name) {\n\n        error_setg(errp, \"Name or id must be provided\");\n\n        goto out_aio_context;\n\n    }\n\n\n\n    if (!blk_is_available(blk)) {\n\n        error_setg(errp, \"Device '%s' has no medium\", device);\n\n        goto out_aio_context;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_INTERNAL_SNAPSHOT_DELETE, errp)) {\n\n        goto out_aio_context;\n\n    }\n\n\n\n    ret = bdrv_snapshot_find_by_id_and_name(bs, id, name, &sn, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out_aio_context;\n\n    }\n\n    if (!ret) {\n\n        error_setg(errp,\n\n                   \"Snapshot with id '%s' and name '%s' does not exist on \"\n\n                   \"device '%s'\",\n\n                   STR_OR_NULL(id), STR_OR_NULL(name), device);\n\n        goto out_aio_context;\n\n    }\n\n\n\n    bdrv_snapshot_delete(bs, id, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out_aio_context;\n\n    }\n\n\n\n    aio_context_release(aio_context);\n\n\n\n    info = g_new0(SnapshotInfo, 1);\n\n    info->id = g_strdup(sn.id_str);\n\n    info->name = g_strdup(sn.name);\n\n    info->date_nsec = sn.date_nsec;\n\n    info->date_sec = sn.date_sec;\n\n    info->vm_state_size = sn.vm_state_size;\n\n    info->vm_clock_nsec = sn.vm_clock_nsec % 1000000000;\n\n    info->vm_clock_sec = sn.vm_clock_nsec / 1000000000;\n\n\n\n    return info;\n\n\n\nout_aio_context:\n\n    aio_context_release(aio_context);\n\n    return NULL;\n\n}\n", "idx": 12704, "_split": "test", "_hash": "07a2d2723abbad20756bd3a393556604"}
{"project": "qemu", "commit_id": "3eff1f46f08a360a4ae9f834ce9fef4c45bf6f0f", "target": 0, "func": "static void virtio_scsi_complete_req(VirtIOSCSIReq *req)\n\n{\n\n    VirtIOSCSI *s = req->dev;\n\n    VirtQueue *vq = req->vq;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    virtqueue_push(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);\n\n    if (req->sreq) {\n\n        req->sreq->hba_private = NULL;\n\n        scsi_req_unref(req->sreq);\n\n    }\n\n    virtio_scsi_free_req(req);\n\n    virtio_notify(vdev, vq);\n\n}\n", "idx": 12710, "_split": "test", "_hash": "875bc51bcf74962fc16441330538e262"}
{"project": "qemu", "commit_id": "978f2205c791de0e02c8802a645bea657408abfd", "target": 0, "func": "bool timer_pending(QEMUTimer *ts)\n\n{\n\n    QEMUTimer *t;\n\n    for (t = ts->timer_list->active_timers; t != NULL; t = t->next) {\n\n        if (t == ts) {\n\n            return true;\n\n        }\n\n    }\n\n    return false;\n\n}\n", "idx": 12724, "_split": "test", "_hash": "a583266428c18fddf06c8ffe3801e9a7"}
{"project": "qemu", "commit_id": "edf779ffccc836661a7b654d320571a6c220caea", "target": 0, "func": "static void setup_rt_frame(int sig, struct emulated_sigaction *ka, \n\n                           target_siginfo_t *info,\n\n\t\t\t   target_sigset_t *set, CPUX86State *env)\n\n{\n\n\tstruct rt_sigframe *frame;\n\n\tint err = 0;\n\n\n\n\tframe = get_sigframe(ka, env, sizeof(*frame));\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\n\t\tgoto give_sigsegv;\n\n#endif\n\n\n\n\terr |= __put_user((/*current->exec_domain\n\n\t\t    \t   && current->exec_domain->signal_invmap\n\n\t\t    \t   && sig < 32\n\n\t\t    \t   ? current->exec_domain->signal_invmap[sig]\n\n\t\t\t   : */sig),\n\n\t\t\t  &frame->sig);\n\n\terr |= __put_user((target_ulong)&frame->info, &frame->pinfo);\n\n\terr |= __put_user((target_ulong)&frame->uc, &frame->puc);\n\n\terr |= copy_siginfo_to_user(&frame->info, info);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Create the ucontext.  */\n\n\terr |= __put_user(0, &frame->uc.uc_flags);\n\n\terr |= __put_user(0, &frame->uc.uc_link);\n\n\terr |= __put_user(/*current->sas_ss_sp*/ 0, &frame->uc.uc_stack.ss_sp);\n\n\terr |= __put_user(/* sas_ss_flags(regs->esp) */ 0,\n\n\t\t\t  &frame->uc.uc_stack.ss_flags);\n\n\terr |= __put_user(/* current->sas_ss_size */ 0, &frame->uc.uc_stack.ss_size);\n\n\terr |= setup_sigcontext(&frame->uc.uc_mcontext, &frame->fpstate,\n\n\t\t\t        env, set->sig[0]);\n\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up to return from userspace.  If provided, use a stub\n\n\t   already in userspace.  */\n\n\tif (ka->sa.sa_flags & TARGET_SA_RESTORER) {\n\n\t\terr |= __put_user(ka->sa.sa_restorer, &frame->pretcode);\n\n\t} else {\n\n\t\terr |= __put_user(frame->retcode, &frame->pretcode);\n\n\t\t/* This is movl $,%eax ; int $0x80 */\n\n\t\terr |= __put_user(0xb8, (char *)(frame->retcode+0));\n\n\t\terr |= __put_user(TARGET_NR_rt_sigreturn, (int *)(frame->retcode+1));\n\n\t\terr |= __put_user(0x80cd, (short *)(frame->retcode+5));\n\n\t}\n\n\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up registers for signal handler */\n\n\tenv->regs[R_ESP] = (unsigned long) frame;\n\n\tenv->eip = (unsigned long) ka->sa._sa_handler;\n\n\n\n        cpu_x86_load_seg(env, R_DS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_ES, __USER_DS);\n\n        cpu_x86_load_seg(env, R_SS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_CS, __USER_CS);\n\n\tenv->eflags &= ~TF_MASK;\n\n\n\n\treturn;\n\n\n\ngive_sigsegv:\n\n\tif (sig == TARGET_SIGSEGV)\n\n\t\tka->sa._sa_handler = TARGET_SIG_DFL;\n\n\tforce_sig(TARGET_SIGSEGV /* , current */);\n\n}\n", "idx": 12741, "_split": "test", "_hash": "75a8d2f4f29e066616386f0e7c10ddcd"}
{"project": "qemu", "commit_id": "f2001a7e0555b66d6db25a3ff1801540814045bb", "target": 0, "func": "static void tcp_chr_telnet_init(QIOChannel *ioc)\n\n{\n\n    char buf[3];\n\n    /* Send the telnet negotion to put telnet in binary, no echo, single char mode */\n\n    IACSET(buf, 0xff, 0xfb, 0x01);  /* IAC WILL ECHO */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfb, 0x03);  /* IAC WILL Suppress go ahead */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfb, 0x00);  /* IAC WILL Binary */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfd, 0x00);  /* IAC DO Binary */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n}\n", "idx": 12777, "_split": "test", "_hash": "f16a7995f658278ed869de03c4dbe7df"}
{"project": "qemu", "commit_id": "1606e4cf8a976513ecac70ad6642a7ec45744cf5", "target": 1, "func": "static void blk_delete(BlockBackend *blk)\n\n{\n\n    assert(!blk->refcnt);\n\n    assert(!blk->name);\n\n    assert(!blk->dev);\n\n\n\n\n    if (blk->root) {\n\n        blk_remove_bs(blk);\n\n\n    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));\n\n    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));\n\n    QTAILQ_REMOVE(&block_backends, blk, link);\n\n    drive_info_del(blk->legacy_dinfo);\n\n    block_acct_cleanup(&blk->stats);\n\n    g_free(blk);\n", "idx": 12780, "_split": "test", "_hash": "9969b9e41b2b627b2a5beb457c444197"}
{"project": "qemu", "commit_id": "bb16172c52ac18742f3df156912c169904e92147", "target": 1, "func": "static int gdbserver_open(int port)\n\n{\n\n    struct sockaddr_in sockaddr;\n\n    int fd, val, ret;\n\n\n\n    fd = socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        return -1;\n\n    }\n\n#ifndef _WIN32\n\n    fcntl(fd, F_SETFD, FD_CLOEXEC);\n\n#endif\n\n\n\n    /* allow fast reuse */\n\n    val = 1;\n\n    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));\n\n\n\n    sockaddr.sin_family = AF_INET;\n\n    sockaddr.sin_port = htons(port);\n\n    sockaddr.sin_addr.s_addr = 0;\n\n    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));\n\n    if (ret < 0) {\n\n        perror(\"bind\");\n\n\n        return -1;\n\n    }\n\n    ret = listen(fd, 0);\n\n    if (ret < 0) {\n\n        perror(\"listen\");\n\n\n        return -1;\n\n    }\n\n    return fd;\n\n}", "idx": 12785, "_split": "test", "_hash": "ee5413a0fedfe09d32b503922e9bbf45"}
{"project": "qemu", "commit_id": "280503ee9d7833a793770d732dda5358659825e9", "target": 1, "func": "static void spapr_nvram_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);\n\n\n\n    k->realize = spapr_nvram_realize;\n\n    k->devnode = spapr_nvram_devnode;\n\n    k->dt_name = \"nvram\";\n\n    k->dt_type = \"nvram\";\n\n    k->dt_compatible = \"qemu,spapr-nvram\";\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->props = spapr_nvram_properties;\n\n    dc->vmsd = &vmstate_spapr_nvram;\n\n\n\n}", "idx": 12786, "_split": "test", "_hash": "a17ab8d98ad22a5247e20a146776ad6a"}
{"project": "qemu", "commit_id": "aedbe19297907143f17b733a7ff0e0534377bed1", "target": 1, "func": "static void cpu_handle_ioreq(void *opaque)\n\n{\n\n    XenIOState *state = opaque;\n\n    ioreq_t *req = cpu_get_ioreq(state);\n\n\n\n    handle_buffered_iopage(state);\n\n    if (req) {\n\n        ioreq_t copy = *req;\n\n\n\n        xen_rmb();\n\n        handle_ioreq(state, &copy);\n\n        req->data = copy.data;\n\n\n\n        if (req->state != STATE_IOREQ_INPROCESS) {\n\n            fprintf(stderr, \"Badness in I/O request ... not in service?!: \"\n\n                    \"%x, ptr: %x, port: %\"PRIx64\", \"\n\n                    \"data: %\"PRIx64\", count: %u, size: %u, type: %u\\n\",\n\n                    req->state, req->data_is_ptr, req->addr,\n\n                    req->data, req->count, req->size, req->type);\n\n            destroy_hvm_domain(false);\n\n            return;\n\n        }\n\n\n\n        xen_wmb(); /* Update ioreq contents /then/ update state. */\n\n\n\n        /*\n\n         * We do this before we send the response so that the tools\n\n         * have the opportunity to pick up on the reset before the\n\n         * guest resumes and does a hlt with interrupts disabled which\n\n         * causes Xen to powerdown the domain.\n\n         */\n\n        if (runstate_is_running()) {\n\n            if (qemu_shutdown_requested_get()) {\n\n                destroy_hvm_domain(false);\n\n            }\n\n            if (qemu_reset_requested_get()) {\n\n                qemu_system_reset(VMRESET_REPORT);\n\n                destroy_hvm_domain(true);\n\n            }\n\n        }\n\n\n\n        req->state = STATE_IORESP_READY;\n\n        xenevtchn_notify(state->xce_handle,\n\n                         state->ioreq_local_port[state->send_vcpu]);\n\n    }\n\n}\n", "idx": 12787, "_split": "test", "_hash": "a9e93f2e03236a434300d4c08b918315"}
{"project": "qemu", "commit_id": "846424350b292f16b732b573273a5c1f195cd7a3", "target": 1, "func": "static bool scsi_target_emulate_inquiry(SCSITargetReq *r)\n\n{\n\n    assert(r->req.dev->lun != r->req.lun);\n\n    if (r->req.cmd.buf[1] & 0x2) {\n\n        /* Command support data - optional, not implemented */\n\n        return false;\n\n    }\n\n\n\n    if (r->req.cmd.buf[1] & 0x1) {\n\n        /* Vital product data */\n\n        uint8_t page_code = r->req.cmd.buf[2];\n\n        r->buf[r->len++] = page_code ; /* this page */\n\n        r->buf[r->len++] = 0x00;\n\n\n\n        switch (page_code) {\n\n        case 0x00: /* Supported page codes, mandatory */\n\n        {\n\n            int pages;\n\n            pages = r->len++;\n\n            r->buf[r->len++] = 0x00; /* list of supported pages (this page) */\n\n            r->buf[pages] = r->len - pages - 1; /* number of pages */\n\n            break;\n\n        }\n\n        default:\n\n            return false;\n\n        }\n\n        /* done with EVPD */\n\n        assert(r->len < sizeof(r->buf));\n\n        r->len = MIN(r->req.cmd.xfer, r->len);\n\n        return true;\n\n    }\n\n\n\n    /* Standard INQUIRY data */\n\n    if (r->req.cmd.buf[2] != 0) {\n\n        return false;\n\n    }\n\n\n\n    /* PAGE CODE == 0 */\n\n    r->len = MIN(r->req.cmd.xfer, 36);\n\n    memset(r->buf, 0, r->len);\n\n    if (r->req.lun != 0) {\n\n        r->buf[0] = TYPE_NO_LUN;\n\n    } else {\n\n        r->buf[0] = TYPE_NOT_PRESENT | TYPE_INACTIVE;\n\n        r->buf[2] = 5; /* Version */\n\n        r->buf[3] = 2 | 0x10; /* HiSup, response data format */\n\n        r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */\n\n        r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */\n\n        memcpy(&r->buf[8], \"QEMU    \", 8);\n\n        memcpy(&r->buf[16], \"QEMU TARGET     \", 16);\n\n        pstrcpy((char *) &r->buf[32], 4, qemu_get_version());\n\n    }\n\n    return true;\n\n}\n", "idx": 12789, "_split": "test", "_hash": "e71e644b934bf75268fd35d868368466"}
{"project": "qemu", "commit_id": "de82815db1c89da058b7fb941dab137d6d9ab738", "target": 1, "func": "int qcow2_expand_zero_clusters(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l1_table = NULL;\n\n    uint64_t nb_clusters;\n\n    uint8_t *expanded_clusters;\n\n    int ret;\n\n    int i, j;\n\n\n\n    nb_clusters = size_to_clusters(s, bs->file->total_sectors *\n\n                                   BDRV_SECTOR_SIZE);\n\n    expanded_clusters = g_malloc0((nb_clusters + 7) / 8);\n\n\n\n    ret = expand_zero_clusters_in_l1(bs, s->l1_table, s->l1_size,\n\n                                     &expanded_clusters, &nb_clusters);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Inactive L1 tables may point to active L2 tables - therefore it is\n\n     * necessary to flush the L2 table cache before trying to access the L2\n\n     * tables pointed to by inactive L1 entries (else we might try to expand\n\n     * zero clusters that have already been expanded); furthermore, it is also\n\n     * necessary to empty the L2 table cache, since it may contain tables which\n\n     * are now going to be modified directly on disk, bypassing the cache.\n\n     * qcow2_cache_empty() does both for us. */\n\n    ret = qcow2_cache_empty(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        int l1_sectors = (s->snapshots[i].l1_size * sizeof(uint64_t) +\n\n                BDRV_SECTOR_SIZE - 1) / BDRV_SECTOR_SIZE;\n\n\n\n        l1_table = g_realloc(l1_table, l1_sectors * BDRV_SECTOR_SIZE);\n\n\n\n        ret = bdrv_read(bs->file, s->snapshots[i].l1_table_offset /\n\n                BDRV_SECTOR_SIZE, (void *)l1_table, l1_sectors);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        for (j = 0; j < s->snapshots[i].l1_size; j++) {\n\n            be64_to_cpus(&l1_table[j]);\n\n        }\n\n\n\n        ret = expand_zero_clusters_in_l1(bs, l1_table, s->snapshots[i].l1_size,\n\n                                         &expanded_clusters, &nb_clusters);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\n\n\nfail:\n\n    g_free(expanded_clusters);\n\n    g_free(l1_table);\n\n    return ret;\n\n}\n", "idx": 12799, "_split": "test", "_hash": "b6a3295c44bfcfdd6ee9e721545a8fee"}
{"project": "qemu", "commit_id": "12848bfc5d719bad536c5448205a3226be1fda47", "target": 1, "func": "static int local_open2(FsContext *fs_ctx, const char *path, int flags,\n\n        FsCred *credp)\n\n{\n\n    int fd = -1;\n\n    int err = -1;\n\n    int serrno = 0;\n\n\n\n    /* Determine the security model */\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        fd = open(rpath(fs_ctx, path), flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            return fd;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set cleint credentials in xattr */\n\n        err = local_set_xattr(rpath(fs_ctx, path), credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {\n\n        fd = open(rpath(fs_ctx, path), flags, credp->fc_mode);\n\n        if (fd == -1) {\n\n            return fd;\n\n        }\n\n        err = local_post_create_passthrough(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    }\n\n    return fd;\n\n\n\nerr_end:\n\n    close(fd);\n\n    remove(rpath(fs_ctx, path));\n\n    errno = serrno;\n\n    return err;\n\n}\n", "idx": 12805, "_split": "test", "_hash": "5efe7fed3c7d5368a3b83b80bff83fa0"}
{"project": "qemu", "commit_id": "e9ebead2b5c70890454e698d9ff174e3020ea861", "target": 1, "func": "static void pc_init1(ram_addr_t ram_size, int vga_ram_size,\n\n                     const char *boot_device, DisplayState *ds,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename,\n\n                     int pci_enabled, const char *cpu_model)\n\n{\n\n    char buf[1024];\n\n    int ret, linux_boot, i;\n\n    ram_addr_t ram_addr, vga_ram_addr, bios_offset, vga_bios_offset;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size = 0;\n\n    int bios_size, isa_bios_size, vga_bios_size;\n\n    PCIBus *pci_bus;\n\n    int piix3_devfn = -1;\n\n    CPUState *env;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *i8259;\n\n    int index;\n\n    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BlockDriverState *fd[MAX_FD];\n\n\n\n    if (ram_size >= 0xe0000000 ) {\n\n        above_4g_mem_size = ram_size - 0xe0000000;\n\n        below_4g_mem_size = 0xe0000000;\n\n    } else {\n\n        below_4g_mem_size = ram_size;\n\n    }\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n#ifdef TARGET_X86_64\n\n        cpu_model = \"qemu64\";\n\n#else\n\n        cpu_model = \"qemu32\";\n\n#endif\n\n    }\n\n    \n\n    for(i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find x86 CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        if (i != 0)\n\n            env->halted = 1;\n\n        if (smp_cpus > 1) {\n\n            /* XXX: enable it in all cases */\n\n            env->cpuid_features |= CPUID_APIC;\n\n        }\n\n        qemu_register_reset(main_cpu_reset, env);\n\n        if (pci_enabled) {\n\n            apic_init(env);\n\n        }\n\n    }\n\n\n\n    vmport_init();\n\n\n\n    /* allocate RAM */\n\n    ram_addr = qemu_ram_alloc(0xa0000);\n\n    cpu_register_physical_memory(0, 0xa0000, ram_addr);\n\n\n\n    /* Allocate, even though we won't register, so we don't break the\n\n     * phys_ram_base + PA assumption. This range includes vga (0xa0000 - 0xc0000),\n\n     * and some bios areas, which will be registered later\n\n     */\n\n    ram_addr = qemu_ram_alloc(0x100000 - 0xa0000);\n\n    ram_addr = qemu_ram_alloc(below_4g_mem_size - 0x100000);\n\n    cpu_register_physical_memory(0x100000,\n\n                 below_4g_mem_size - 0x100000,\n\n                 ram_addr);\n\n\n\n    /* above 4giga memory allocation */\n\n    if (above_4g_mem_size > 0) {\n\n        ram_addr = qemu_ram_alloc(above_4g_mem_size);\n\n        cpu_register_physical_memory(0x100000000ULL,\n\n                                     above_4g_mem_size,\n\n                                     ram_addr);\n\n    }\n\n\n\n\n\n    /* allocate VGA RAM */\n\n    vga_ram_addr = qemu_ram_alloc(vga_ram_size);\n\n\n\n    /* BIOS load */\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, bios_name);\n\n    bios_size = get_image_size(buf);\n\n    if (bios_size <= 0 ||\n\n        (bios_size % 65536) != 0) {\n\n        goto bios_error;\n\n    }\n\n    bios_offset = qemu_ram_alloc(bios_size);\n\n    ret = load_image(buf, phys_ram_base + bios_offset);\n\n    if (ret != bios_size) {\n\n    bios_error:\n\n        fprintf(stderr, \"qemu: could not load PC BIOS '%s'\\n\", buf);\n\n        exit(1);\n\n    }\n\n\n\n    if (cirrus_vga_enabled || std_vga_enabled || vmsvga_enabled) {\n\n        /* VGA BIOS load */\n\n        if (cirrus_vga_enabled) {\n\n            snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, VGABIOS_CIRRUS_FILENAME);\n\n        } else {\n\n            snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, VGABIOS_FILENAME);\n\n        }\n\n        vga_bios_size = get_image_size(buf);\n\n        if (vga_bios_size <= 0 || vga_bios_size > 65536)\n\n            goto vga_bios_error;\n\n        vga_bios_offset = qemu_ram_alloc(65536);\n\n\n\n        ret = load_image(buf, phys_ram_base + vga_bios_offset);\n\n        if (ret != vga_bios_size) {\n\nvga_bios_error:\n\n            fprintf(stderr, \"qemu: could not load VGA BIOS '%s'\\n\", buf);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* setup basic memory access */\n\n    cpu_register_physical_memory(0xc0000, 0x10000,\n\n                                 vga_bios_offset | IO_MEM_ROM);\n\n\n\n    /* map the last 128KB of the BIOS in ISA space */\n\n    isa_bios_size = bios_size;\n\n    if (isa_bios_size > (128 * 1024))\n\n        isa_bios_size = 128 * 1024;\n\n    cpu_register_physical_memory(0x100000 - isa_bios_size,\n\n                                 isa_bios_size,\n\n                                 (bios_offset + bios_size - isa_bios_size) | IO_MEM_ROM);\n\n\n\n    {\n\n        ram_addr_t option_rom_offset;\n\n        int size, offset;\n\n\n\n        offset = 0;\n\n        if (linux_boot) {\n\n            option_rom_offset = qemu_ram_alloc(TARGET_PAGE_SIZE);\n\n            load_linux(phys_ram_base + option_rom_offset,\n\n                       kernel_filename, initrd_filename, kernel_cmdline);\n\n            cpu_register_physical_memory(0xd0000, TARGET_PAGE_SIZE,\n\n                                         option_rom_offset | IO_MEM_ROM);\n\n            offset = TARGET_PAGE_SIZE;\n\n        }\n\n\n\n        for (i = 0; i < nb_option_roms; i++) {\n\n            size = get_image_size(option_rom[i]);\n\n            if (size < 0) {\n\n                fprintf(stderr, \"Could not load option rom '%s'\\n\",\n\n                        option_rom[i]);\n\n                exit(1);\n\n            }\n\n            if (size > (0x10000 - offset))\n\n                goto option_rom_error;\n\n            option_rom_offset = qemu_ram_alloc(size);\n\n            ret = load_image(option_rom[i], phys_ram_base + option_rom_offset);\n\n            if (ret != size) {\n\n            option_rom_error:\n\n                fprintf(stderr, \"Too many option ROMS\\n\");\n\n                exit(1);\n\n            }\n\n            size = (size + 4095) & ~4095;\n\n            cpu_register_physical_memory(0xd0000 + offset,\n\n                                         size, option_rom_offset | IO_MEM_ROM);\n\n            offset += size;\n\n        }\n\n    }\n\n\n\n    /* map all the bios at the top of memory */\n\n    cpu_register_physical_memory((uint32_t)(-bios_size),\n\n                                 bios_size, bios_offset | IO_MEM_ROM);\n\n\n\n    bochs_bios_init();\n\n\n\n    cpu_irq = qemu_allocate_irqs(pic_irq_request, NULL, 1);\n\n    i8259 = i8259_init(cpu_irq[0]);\n\n    ferr_irq = i8259[13];\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, i8259);\n\n        piix3_devfn = piix3_init(pci_bus, -1);\n\n    } else {\n\n        pci_bus = NULL;\n\n    }\n\n\n\n    /* init basic PC hardware */\n\n    register_ioport_write(0x80, 1, 1, ioport80_write, NULL);\n\n\n\n    register_ioport_write(0xf0, 1, 1, ioportF0_write, NULL);\n\n\n\n    if (cirrus_vga_enabled) {\n\n        if (pci_enabled) {\n\n            pci_cirrus_vga_init(pci_bus,\n\n                                ds, phys_ram_base + vga_ram_addr,\n\n                                vga_ram_addr, vga_ram_size);\n\n        } else {\n\n            isa_cirrus_vga_init(ds, phys_ram_base + vga_ram_addr,\n\n                                vga_ram_addr, vga_ram_size);\n\n        }\n\n    } else if (vmsvga_enabled) {\n\n        if (pci_enabled)\n\n            pci_vmsvga_init(pci_bus, ds, phys_ram_base + vga_ram_addr,\n\n                            vga_ram_addr, vga_ram_size);\n\n        else\n\n            fprintf(stderr, \"%s: vmware_vga: no PCI bus\\n\", __FUNCTION__);\n\n    } else if (std_vga_enabled) {\n\n        if (pci_enabled) {\n\n            pci_vga_init(pci_bus, ds, phys_ram_base + vga_ram_addr,\n\n                         vga_ram_addr, vga_ram_size, 0, 0);\n\n        } else {\n\n            isa_vga_init(ds, phys_ram_base + vga_ram_addr,\n\n                         vga_ram_addr, vga_ram_size);\n\n        }\n\n    }\n\n\n\n    rtc_state = rtc_init(0x70, i8259[8]);\n\n\n\n    qemu_register_boot_set(pc_boot_set, rtc_state);\n\n\n\n    register_ioport_read(0x92, 1, 1, ioport92_read, NULL);\n\n    register_ioport_write(0x92, 1, 1, ioport92_write, NULL);\n\n\n\n    if (pci_enabled) {\n\n        ioapic = ioapic_init();\n\n    }\n\n    pit = pit_init(0x40, i8259[0]);\n\n    pcspk_init(pit);\n\n    if (!no_hpet) {\n\n        hpet_init(i8259);\n\n    }\n\n    if (pci_enabled) {\n\n        pic_set_alt_irq_func(isa_pic, ioapic_set_irq, ioapic);\n\n    }\n\n\n\n    for(i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_init(serial_io[i], i8259[serial_irq[i]], 115200,\n\n                        serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {\n\n        if (parallel_hds[i]) {\n\n            parallel_init(parallel_io[i], i8259[parallel_irq[i]],\n\n                          parallel_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!pci_enabled || (nd->model && strcmp(nd->model, \"ne2k_isa\") == 0))\n\n            pc_init_ne2k_isa(nd, i8259);\n\n        else\n\n            pci_nic_init(pci_bus, nd, -1, \"ne2k_pci\");\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n\tif (index != -1)\n\n\t    hd[i] = drives_table[index].bdrv;\n\n\telse\n\n\t    hd[i] = NULL;\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1, i8259);\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            isa_ide_init(ide_iobase[i], ide_iobase2[i], i8259[ide_irq[i]],\n\n\t                 hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n        }\n\n    }\n\n\n\n    i8042_init(i8259[1], i8259[12], 0x60);\n\n    DMA_init(0);\n\n#ifdef HAS_AUDIO\n\n    audio_init(pci_enabled ? pci_bus : NULL, i8259);\n\n#endif\n\n\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        index = drive_get_index(IF_FLOPPY, 0, i);\n\n\tif (index != -1)\n\n\t    fd[i] = drives_table[index].bdrv;\n\n\telse\n\n\t    fd[i] = NULL;\n\n    }\n\n    floppy_controller = fdctrl_init(i8259[6], 2, 0, 0x3f0, fd);\n\n\n\n    cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device, hd);\n\n\n\n    if (pci_enabled && usb_enabled) {\n\n        usb_uhci_piix3_init(pci_bus, piix3_devfn + 2);\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        uint8_t *eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */\n\n        i2c_bus *smbus;\n\n\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100, i8259[9]);\n\n        for (i = 0; i < 8; i++) {\n\n            smbus_eeprom_device_init(smbus, 0x50 + i, eeprom_buf + (i * 256));\n\n        }\n\n    }\n\n\n\n    if (i440fx_state) {\n\n        i440fx_init_memory_mappings(i440fx_state);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n\tint max_bus;\n\n        int bus, unit;\n\n        void *scsi;\n\n\n\n        max_bus = drive_get_max_bus(IF_SCSI);\n\n\n\n\tfor (bus = 0; bus <= max_bus; bus++) {\n\n            scsi = lsi_scsi_init(pci_bus, -1);\n\n            for (unit = 0; unit < LSI_MAX_DEVS; unit++) {\n\n\t        index = drive_get_index(IF_SCSI, bus, unit);\n\n\t\tif (index == -1)\n\n\t\t    continue;\n\n\t\tlsi_scsi_attach(scsi, drives_table[index].bdrv, unit);\n\n\t    }\n\n        }\n\n    }\n\n\n\n    /* Add virtio block devices */\n\n    if (pci_enabled) {\n\n        int index;\n\n        int unit_id = 0;\n\n\n\n        while ((index = drive_get_index(IF_VIRTIO, 0, unit_id)) != -1) {\n\n            virtio_blk_init(pci_bus, drives_table[index].bdrv);\n\n            unit_id++;\n\n        }\n\n    }\n\n\n\n    /* Add virtio balloon device */\n\n    if (pci_enabled)\n\n        virtio_balloon_init(pci_bus);\n\n\n\n    /* Add virtio console devices */\n\n    if (pci_enabled) {\n\n        for(i = 0; i < MAX_VIRTIO_CONSOLES; i++) {\n\n            if (virtcon_hds[i])\n\n                virtio_console_init(pci_bus, virtcon_hds[i]);\n\n        }\n\n    }\n\n}\n", "idx": 12828, "_split": "test", "_hash": "5b5299e83d5bfacb5ed75f6d31e272bc"}
{"project": "qemu", "commit_id": "0bed71edbc323de12ed1e5390a85a013f6a143f4", "target": 0, "func": "static int slirp_hostfwd(SlirpState *s, const char *redir_str,\n\n                         int legacy_format)\n\n{\n\n    struct in_addr host_addr = { .s_addr = INADDR_ANY };\n\n    struct in_addr guest_addr = { .s_addr = 0 };\n\n    int host_port, guest_port;\n\n    const char *p;\n\n    char buf[256];\n\n    int is_udp;\n\n    char *end;\n\n\n\n    p = redir_str;\n\n    if (!p || get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (!strcmp(buf, \"tcp\") || buf[0] == '\\0') {\n\n        is_udp = 0;\n\n    } else if (!strcmp(buf, \"udp\")) {\n\n        is_udp = 1;\n\n    } else {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (!legacy_format) {\n\n        if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n            goto fail_syntax;\n\n        }\n\n        if (buf[0] != '\\0' && !inet_aton(buf, &host_addr)) {\n\n            goto fail_syntax;\n\n        }\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, legacy_format ? ':' : '-') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    host_port = strtol(buf, &end, 0);\n\n    if (*end != '\\0' || host_port < 1 || host_port > 65535) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (buf[0] != '\\0' && !inet_aton(buf, &guest_addr)) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    guest_port = strtol(p, &end, 0);\n\n    if (*end != '\\0' || guest_port < 1 || guest_port > 65535) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (slirp_add_hostfwd(s->slirp, is_udp, host_addr, host_port, guest_addr,\n\n                          guest_port) < 0) {\n\n        error_report(\"could not set up host forwarding rule '%s'\",\n\n                     redir_str);\n\n        return -1;\n\n    }\n\n    return 0;\n\n\n\n fail_syntax:\n\n    error_report(\"invalid host forwarding rule '%s'\", redir_str);\n\n    return -1;\n\n}\n", "idx": 12846, "_split": "test", "_hash": "ddb488a6afcb43ad415b1e5807724c43"}
{"project": "qemu", "commit_id": "e6eef7c221634c942e9f586df84aae623aa06cd5", "target": 0, "func": "int kvm_arch_put_registers(CPUState *cs, int level)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    CPUS390XState *env = &cpu->env;\n\n    struct kvm_sregs sregs;\n\n    struct kvm_regs regs;\n\n    struct kvm_fpu fpu;\n\n    int r;\n\n    int i;\n\n\n\n    /* always save the PSW  and the GPRS*/\n\n    cs->kvm_run->psw_addr = env->psw.addr;\n\n    cs->kvm_run->psw_mask = env->psw.mask;\n\n\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_GPRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            cs->kvm_run->s.regs.gprs[i] = env->regs[i];\n\n            cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_GPRS;\n\n        }\n\n    } else {\n\n        for (i = 0; i < 16; i++) {\n\n            regs.gprs[i] = env->regs[i];\n\n        }\n\n        r = kvm_vcpu_ioctl(cs, KVM_SET_REGS, &regs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    /* Floating point */\n\n    for (i = 0; i < 16; i++) {\n\n        fpu.fprs[i] = env->fregs[i].ll;\n\n    }\n\n    fpu.fpc = env->fpc;\n\n\n\n    r = kvm_vcpu_ioctl(cs, KVM_SET_FPU, &fpu);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    /* Do we need to save more than that? */\n\n    if (level == KVM_PUT_RUNTIME_STATE) {\n\n        return 0;\n\n    }\n\n\n\n    /*\n\n     * These ONE_REGS are not protected by a capability. As they are only\n\n     * necessary for migration we just trace a possible error, but don't\n\n     * return with an error return code.\n\n     */\n\n    kvm_set_one_reg(cs, KVM_REG_S390_CPU_TIMER, &env->cputm);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_CLOCK_COMP, &env->ckc);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_TODPR, &env->todpr);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_GBEA, &env->gbea);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_PP, &env->pp);\n\n\n\n    if (cap_async_pf) {\n\n        r = kvm_set_one_reg(cs, KVM_REG_S390_PFTOKEN, &env->pfault_token);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n        r = kvm_set_one_reg(cs, KVM_REG_S390_PFCOMPARE, &env->pfault_compare);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n        r = kvm_set_one_reg(cs, KVM_REG_S390_PFSELECT, &env->pfault_select);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    if (cap_sync_regs &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_ACRS &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_CRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            cs->kvm_run->s.regs.acrs[i] = env->aregs[i];\n\n            cs->kvm_run->s.regs.crs[i] = env->cregs[i];\n\n        }\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_ACRS;\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_CRS;\n\n    } else {\n\n        for (i = 0; i < 16; i++) {\n\n            sregs.acrs[i] = env->aregs[i];\n\n            sregs.crs[i] = env->cregs[i];\n\n        }\n\n        r = kvm_vcpu_ioctl(cs, KVM_SET_SREGS, &sregs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    /* Finally the prefix */\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_PREFIX) {\n\n        cs->kvm_run->s.regs.prefix = env->psa;\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_PREFIX;\n\n    } else {\n\n        /* prefix is only supported via sync regs */\n\n    }\n\n    return 0;\n\n}\n", "idx": 12853, "_split": "test", "_hash": "997f66f74cbce0d1f8933c41f35b4b00"}
{"project": "qemu", "commit_id": "ffbb1705a33df8e2fb12b24d96663d63b22eaf8b", "target": 0, "func": "static void spapr_hotplug_req_event(uint8_t hp_id, uint8_t hp_action,\n\n                                    sPAPRDRConnectorType drc_type,\n\n                                    uint32_t drc)\n\n{\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_machine());\n\n    struct hp_log_full *new_hp;\n\n    struct rtas_error_log *hdr;\n\n    struct rtas_event_log_v6 *v6hdr;\n\n    struct rtas_event_log_v6_maina *maina;\n\n    struct rtas_event_log_v6_mainb *mainb;\n\n    struct rtas_event_log_v6_hp *hp;\n\n\n\n    new_hp = g_malloc0(sizeof(struct hp_log_full));\n\n    hdr = &new_hp->hdr;\n\n    v6hdr = &new_hp->v6hdr;\n\n    maina = &new_hp->maina;\n\n    mainb = &new_hp->mainb;\n\n    hp = &new_hp->hp;\n\n\n\n    hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6\n\n                               | RTAS_LOG_SEVERITY_EVENT\n\n                               | RTAS_LOG_DISPOSITION_NOT_RECOVERED\n\n                               | RTAS_LOG_OPTIONAL_PART_PRESENT\n\n                               | RTAS_LOG_INITIATOR_HOTPLUG\n\n                               | RTAS_LOG_TYPE_HOTPLUG);\n\n    hdr->extended_length = cpu_to_be32(sizeof(*new_hp)\n\n                                       - sizeof(new_hp->hdr));\n\n\n\n    spapr_init_v6hdr(v6hdr);\n\n    spapr_init_maina(maina, 3 /* Main-A, Main-B, HP */);\n\n\n\n    mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB);\n\n    mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb));\n\n    mainb->subsystem_id = 0x80; /* External environment */\n\n    mainb->event_severity = 0x00; /* Informational / non-error */\n\n    mainb->event_subtype = 0x00; /* Normal shutdown */\n\n\n\n    hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG);\n\n    hp->hdr.section_length = cpu_to_be16(sizeof(*hp));\n\n    hp->hdr.section_version = 1; /* includes extended modifier */\n\n    hp->hotplug_action = hp_action;\n\n    hp->hotplug_identifier = hp_id;\n\n\n\n    switch (drc_type) {\n\n    case SPAPR_DR_CONNECTOR_TYPE_PCI:\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI;\n\n        if (hp->hotplug_action == RTAS_LOG_V6_HP_ACTION_ADD) {\n\n            spapr_hotplug_set_signalled(drc);\n\n        }\n\n        break;\n\n    case SPAPR_DR_CONNECTOR_TYPE_LMB:\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_MEMORY;\n\n        break;\n\n    case SPAPR_DR_CONNECTOR_TYPE_CPU:\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_CPU;\n\n        break;\n\n    default:\n\n        /* we shouldn't be signaling hotplug events for resources\n\n         * that don't support them\n\n         */\n\n        g_assert(false);\n\n        return;\n\n    }\n\n\n\n    if (hp_id == RTAS_LOG_V6_HP_ID_DRC_COUNT) {\n\n        hp->drc.count = cpu_to_be32(drc);\n\n    } else if (hp_id == RTAS_LOG_V6_HP_ID_DRC_INDEX) {\n\n        hp->drc.index = cpu_to_be32(drc);\n\n    }\n\n\n\n    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp, true);\n\n\n\n    qemu_irq_pulse(xics_get_qirq(spapr->xics, spapr->check_exception_irq));\n\n}\n", "idx": 12887, "_split": "test", "_hash": "c31c240720ab434027d761536985fac9"}
{"project": "qemu", "commit_id": "3393bc105d58e1f4a27d9a8e7062da9cef260cc3", "target": 0, "func": "static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)\n\n{\n\n    USBHubPort *port;\n\n    USBDevice *dev;\n\n    int i, ret;\n\n\n\n    for(i = 0; i < NUM_PORTS; i++) {\n\n        port = &s->ports[i];\n\n        dev = port->port.dev;\n\n        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {\n\n            ret = usb_handle_packet(dev, p);\n\n            if (ret != USB_RET_NODEV) {\n\n                return ret;\n\n            }\n\n        }\n\n    }\n\n    return USB_RET_NODEV;\n\n}\n", "idx": 12894, "_split": "test", "_hash": "11949499caee9d2ac4049d21201f2c4f"}
{"project": "qemu", "commit_id": "c6d2283068026035a6468aae9dcde953bd7521ac", "target": 1, "func": "BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num,\n\n                                  QEMUIOVector *qiov, int nb_sectors,\n\n                                  BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    BlockDriverAIOCB *ret;\n\n\n\n    if (!drv)\n\n        return NULL;\n\n    if (bs->read_only)\n\n        return NULL;\n\n    if (bdrv_check_request(bs, sector_num, nb_sectors))\n\n        return NULL;\n\n\n\n    if (bs->dirty_tracking) {\n\n        set_dirty_bitmap(bs, sector_num, nb_sectors, 1);\n\n    }\n\n\n\n    ret = drv->bdrv_aio_writev(bs, sector_num, qiov, nb_sectors,\n\n                               cb, opaque);\n\n\n\n    if (ret) {\n\n\t/* Update stats even though technically transfer has not happened. */\n\n\tbs->wr_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;\n\n\tbs->wr_ops ++;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 12916, "_split": "test", "_hash": "3914882813583e96c98daf27b24df9bf"}
{"project": "qemu", "commit_id": "068593deea6cc61b06243a33c7fcfadb1650b654", "target": 1, "func": "void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)\n\n{\n\n    int i = 0;\n\n    int x = 0;\n\n    uint32_t l_64 = (l + 1) / 8;\n\n\n\n    HELPER_LOG(\"%s l %d dest %\" PRIx64 \" src %\" PRIx64 \"\\n\",\n\n               __func__, l, dest, src);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if ((l > 32) &&\n\n        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&\n\n        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {\n\n        if (dest == (src + 1)) {\n\n            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));\n\n            return;\n\n        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {\n\n            mvc_fast_memmove(env, l + 1, dest, src);\n\n            return;\n\n        }\n\n    }\n\n#else\n\n    if (dest == (src + 1)) {\n\n        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);\n\n        return;\n\n    } else {\n\n        memmove(g2h(dest), g2h(src), l + 1);\n\n        return;\n\n    }\n\n#endif\n\n\n\n    /* handle the parts that fit into 8-byte loads/stores */\n\n    if (dest != (src + 1)) {\n\n        for (i = 0; i < l_64; i++) {\n\n            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));\n\n            x += 8;\n\n        }\n\n    }\n\n\n\n    /* slow version crossing pages with byte accesses */\n\n    for (i = x; i <= l; i++) {\n\n        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));\n\n    }\n\n}\n", "idx": 12946, "_split": "test", "_hash": "964c699d870dbccc679634e446d12c0c"}
{"project": "qemu", "commit_id": "0d2cd785ef1282b14687f9f7f4b63ae4a2430be3", "target": 1, "func": "static void test_properties(const char *path, bool recurse)\n\n{\n\n    char *child_path;\n\n    QDict *response, *tuple;\n\n    QList *list;\n\n    QListEntry *entry;\n\n\n\n    g_test_message(\"Obtaining properties of %s\", path);\n\n    response = qmp(\"{ 'execute': 'qom-list',\"\n\n                   \"  'arguments': { 'path': %s } }\", path);\n\n    g_assert(response);\n\n\n\n    if (!recurse) {\n\n        return;\n\n    }\n\n\n\n    g_assert(qdict_haskey(response, \"return\"));\n\n    list = qobject_to_qlist(qdict_get(response, \"return\"));\n\n    QLIST_FOREACH_ENTRY(list, entry) {\n\n        tuple = qobject_to_qdict(qlist_entry_obj(entry));\n\n        bool is_child = strstart(qdict_get_str(tuple, \"type\"), \"child<\", NULL);\n\n        bool is_link = strstart(qdict_get_str(tuple, \"type\"), \"link<\", NULL);\n\n\n\n        if (is_child || is_link) {\n\n            child_path = g_strdup_printf(\"%s/%s\",\n\n                                         path, qdict_get_str(tuple, \"name\"));\n\n            test_properties(child_path, is_child);\n\n            g_free(child_path);\n\n        } else {\n\n            const char *prop = qdict_get_str(tuple, \"name\");\n\n            g_test_message(\"Testing property %s.%s\", path, prop);\n\n            response = qmp(\"{ 'execute': 'qom-get',\"\n\n                           \"  'arguments': { 'path': %s,\"\n\n                           \"                 'property': %s } }\",\n\n                           path, prop);\n\n            /* qom-get may fail but should not, e.g., segfault. */\n\n            g_assert(response);\n\n        }\n\n    }\n\n}\n", "idx": 12949, "_split": "test", "_hash": "13905dda7ba17a2826272b43c27f9bc9"}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "static int rdma_add_block(RDMAContext *rdma, const char *block_name,\n\n                         void *host_addr,\n\n                         ram_addr_t block_offset, uint64_t length)\n\n{\n\n    RDMALocalBlocks *local = &rdma->local_ram_blocks;\n\n    RDMALocalBlock *block;\n\n    RDMALocalBlock *old = local->block;\n\n\n\n    local->block = g_malloc0(sizeof(RDMALocalBlock) * (local->nb_blocks + 1));\n\n\n\n    if (local->nb_blocks) {\n\n        int x;\n\n\n\n        if (rdma->blockmap) {\n\n            for (x = 0; x < local->nb_blocks; x++) {\n\n                g_hash_table_remove(rdma->blockmap,\n\n                                    (void *)(uintptr_t)old[x].offset);\n\n                g_hash_table_insert(rdma->blockmap,\n\n                                    (void *)(uintptr_t)old[x].offset,\n\n                                    &local->block[x]);\n\n            }\n\n        }\n\n        memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nb_blocks);\n\n        g_free(old);\n\n    }\n\n\n\n    block = &local->block[local->nb_blocks];\n\n\n\n    block->block_name = g_strdup(block_name);\n\n    block->local_host_addr = host_addr;\n\n    block->offset = block_offset;\n\n    block->length = length;\n\n    block->index = local->nb_blocks;\n\n    block->src_index = ~0U; /* Filled in by the receipt of the block list */\n\n    block->nb_chunks = ram_chunk_index(host_addr, host_addr + length) + 1UL;\n\n    block->transit_bitmap = bitmap_new(block->nb_chunks);\n\n    bitmap_clear(block->transit_bitmap, 0, block->nb_chunks);\n\n    block->unregister_bitmap = bitmap_new(block->nb_chunks);\n\n    bitmap_clear(block->unregister_bitmap, 0, block->nb_chunks);\n\n    block->remote_keys = g_malloc0(block->nb_chunks * sizeof(uint32_t));\n\n\n\n    block->is_ram_block = local->init ? false : true;\n\n\n\n    if (rdma->blockmap) {\n\n        g_hash_table_insert(rdma->blockmap, (void *) block_offset, block);\n\n    }\n\n\n\n    trace_rdma_add_block(block_name, local->nb_blocks,\n\n                         (uintptr_t) block->local_host_addr,\n\n                         block->offset, block->length,\n\n                         (uintptr_t) (block->local_host_addr + block->length),\n\n                         BITS_TO_LONGS(block->nb_chunks) *\n\n                             sizeof(unsigned long) * 8,\n\n                         block->nb_chunks);\n\n\n\n    local->nb_blocks++;\n\n\n\n    return 0;\n\n}\n", "idx": 12968, "_split": "test", "_hash": "877501b2a081c3d6e375449baa04fcc4"}
{"project": "qemu", "commit_id": "65f82df0d7a71ce1b10cd4c5ab08888d176ac840", "target": 1, "func": "process_tx_desc(E1000State *s, struct e1000_tx_desc *dp)\n\n{\n\n    uint32_t txd_lower = le32_to_cpu(dp->lower.data);\n\n    uint32_t dtype = txd_lower & (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D);\n\n    unsigned int split_size = txd_lower & 0xffff, bytes, sz, op;\n\n    unsigned int msh = 0xfffff, hdr = 0;\n\n    uint64_t addr;\n\n    struct e1000_context_desc *xp = (struct e1000_context_desc *)dp;\n\n    struct e1000_tx *tp = &s->tx;\n\n\n\n    if (dtype == E1000_TXD_CMD_DEXT) {\t// context descriptor\n\n        op = le32_to_cpu(xp->cmd_and_length);\n\n        tp->ipcss = xp->lower_setup.ip_fields.ipcss;\n\n        tp->ipcso = xp->lower_setup.ip_fields.ipcso;\n\n        tp->ipcse = le16_to_cpu(xp->lower_setup.ip_fields.ipcse);\n\n        tp->tucss = xp->upper_setup.tcp_fields.tucss;\n\n        tp->tucso = xp->upper_setup.tcp_fields.tucso;\n\n        tp->tucse = le16_to_cpu(xp->upper_setup.tcp_fields.tucse);\n\n        tp->paylen = op & 0xfffff;\n\n        tp->hdr_len = xp->tcp_seg_setup.fields.hdr_len;\n\n        tp->mss = le16_to_cpu(xp->tcp_seg_setup.fields.mss);\n\n        tp->ip = (op & E1000_TXD_CMD_IP) ? 1 : 0;\n\n        tp->tcp = (op & E1000_TXD_CMD_TCP) ? 1 : 0;\n\n        tp->tse = (op & E1000_TXD_CMD_TSE) ? 1 : 0;\n\n        tp->tso_frames = 0;\n\n        if (tp->tucso == 0) {\t// this is probably wrong\n\n            DBGOUT(TXSUM, \"TCP/UDP: cso 0!\\n\");\n\n            tp->tucso = tp->tucss + (tp->tcp ? 16 : 6);\n\n        }\n\n        return;\n\n    } else if (dtype == (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D)) {\n\n        // data descriptor\n\n        if (tp->size == 0) {\n\n            tp->sum_needed = le32_to_cpu(dp->upper.data) >> 8;\n\n        }\n\n        tp->cptse = ( txd_lower & E1000_TXD_CMD_TSE ) ? 1 : 0;\n\n    } else {\n\n        // legacy descriptor\n\n        tp->cptse = 0;\n\n    }\n\n\n\n    if (vlan_enabled(s) && is_vlan_txd(txd_lower) &&\n\n        (tp->cptse || txd_lower & E1000_TXD_CMD_EOP)) {\n\n        tp->vlan_needed = 1;\n\n        cpu_to_be16wu((uint16_t *)(tp->vlan_header),\n\n                      le16_to_cpup((uint16_t *)(s->mac_reg + VET)));\n\n        cpu_to_be16wu((uint16_t *)(tp->vlan_header + 2),\n\n                      le16_to_cpu(dp->upper.fields.special));\n\n    }\n\n        \n\n    addr = le64_to_cpu(dp->buffer_addr);\n\n    if (tp->tse && tp->cptse) {\n\n        hdr = tp->hdr_len;\n\n        msh = hdr + tp->mss;\n\n        do {\n\n            bytes = split_size;\n\n            if (tp->size + bytes > msh)\n\n                bytes = msh - tp->size;\n\n\n\n            bytes = MIN(sizeof(tp->data) - tp->size, bytes);\n\n            pci_dma_read(&s->dev, addr, tp->data + tp->size, bytes);\n\n            if ((sz = tp->size + bytes) >= hdr && tp->size < hdr)\n\n                memmove(tp->header, tp->data, hdr);\n\n            tp->size = sz;\n\n            addr += bytes;\n\n            if (sz == msh) {\n\n                xmit_seg(s);\n\n                memmove(tp->data, tp->header, hdr);\n\n                tp->size = hdr;\n\n            }\n\n        } while (split_size -= bytes);\n\n    } else if (!tp->tse && tp->cptse) {\n\n        // context descriptor TSE is not set, while data descriptor TSE is set\n\n        DBGOUT(TXERR, \"TCP segmentaion Error\\n\");\n\n    } else {\n\n\n        pci_dma_read(&s->dev, addr, tp->data + tp->size, split_size);\n\n        tp->size += split_size;\n\n    }\n\n\n\n    if (!(txd_lower & E1000_TXD_CMD_EOP))\n\n        return;\n\n    if (!(tp->tse && tp->cptse && tp->size < hdr))\n\n        xmit_seg(s);\n\n    tp->tso_frames = 0;\n\n    tp->sum_needed = 0;\n\n    tp->vlan_needed = 0;\n\n    tp->size = 0;\n\n    tp->cptse = 0;\n\n}", "idx": 12984, "_split": "test", "_hash": "5340ff520a9e24a965bc66d5b9cc3c64"}
{"project": "qemu", "commit_id": "9a4c0e220d8a4f82b5665d0ee95ef94d8e1509d5", "target": 0, "func": "static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)\n\n{\n\n    VirtIOInputPCI *vinput = VIRTIO_INPUT_PCI(vpci_dev);\n\n    DeviceState *vdev = DEVICE(&vinput->vdev);\n\n\n\n    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));\n\n    /* force virtio-1.0 */\n\n    vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;\n\n    vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;\n\n    object_property_set_bool(OBJECT(vdev), true, \"realized\", errp);\n\n}\n", "idx": 13001, "_split": "test", "_hash": "35bc511013d2017c19657112d56d5c64"}
{"project": "qemu", "commit_id": "3f66f764ee25f10d3e1144ebc057a949421b7728", "target": 0, "func": "static void test_visitor_out_string(TestOutputVisitorData *data,\n\n                                    const void *unused)\n\n{\n\n    char *string = (char *) \"Q E M U\";\n\n    Error *err = NULL;\n\n    QObject *obj;\n\n\n\n    visit_type_str(data->ov, &string, NULL, &err);\n\n    g_assert(!err);\n\n\n\n    obj = qmp_output_get_qobject(data->qov);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QSTRING);\n\n    g_assert_cmpstr(qstring_get_str(qobject_to_qstring(obj)), ==, string);\n\n\n\n    qobject_decref(obj);\n\n}\n", "idx": 13002, "_split": "test", "_hash": "1fc579160c6ce646b48f8f70dbc338c6"}
{"project": "qemu", "commit_id": "d1048bef9df0aacde9a54bf9b5b97a6e10950d8c", "target": 0, "func": "static void pc_machine_set_vmport(Object *obj, bool value, Error **errp)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(obj);\n\n\n\n    pcms->vmport = value;\n\n}\n", "idx": 13012, "_split": "test", "_hash": "9b64ce90e9f7acd93ed49f33b55cf150"}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "static int buffer_empty(Buffer *buffer)\n\n{\n\n    return buffer->offset == 0;\n\n}\n", "idx": 13031, "_split": "test", "_hash": "d750630cd3aae507ffe8ed625ac8d1c5"}
{"project": "qemu", "commit_id": "b0d768c35e08d2057b63e8e77e7a513c447199fa", "target": 1, "func": "static gboolean pty_chr_timer(gpointer opaque)\n\n{\n\n    struct CharDriverState *chr = opaque;\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (s->connected) {\n\n        goto out;\n\n    }\n\n\n\n    /* Next poll ... */\n\n    pty_chr_update_read_handler(chr);\n\n\n\nout:\n\n    s->timer_tag = 0;\n\n    return FALSE;\n\n}\n", "idx": 13035, "_split": "test", "_hash": "a1f2299ffbf31704997872cb71e4a89b"}
{"project": "qemu", "commit_id": "fdfab37dfeffefbd4533b4158055c9b82d7c3e69", "target": 0, "func": "static int check_oflag_copied(BlockDriverState *bs, BdrvCheckResult *res,\n\n                              BdrvCheckMode fix)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t *l2_table = qemu_blockalign(bs, s->cluster_size);\n\n    int ret;\n\n    uint64_t refcount;\n\n    int i, j;\n\n\n\n    for (i = 0; i < s->l1_size; i++) {\n\n        uint64_t l1_entry = s->l1_table[i];\n\n        uint64_t l2_offset = l1_entry & L1E_OFFSET_MASK;\n\n        bool l2_dirty = false;\n\n\n\n        if (!l2_offset) {\n\n            continue;\n\n        }\n\n\n\n        ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,\n\n                                 &refcount);\n\n        if (ret < 0) {\n\n            /* don't print message nor increment check_errors */\n\n            continue;\n\n        }\n\n        if ((refcount == 1) != ((l1_entry & QCOW_OFLAG_COPIED) != 0)) {\n\n            fprintf(stderr, \"%s OFLAG_COPIED L2 cluster: l1_index=%d \"\n\n                    \"l1_entry=%\" PRIx64 \" refcount=%\" PRIu64 \"\\n\",\n\n                    fix & BDRV_FIX_ERRORS ? \"Repairing\" :\n\n                                            \"ERROR\",\n\n                    i, l1_entry, refcount);\n\n            if (fix & BDRV_FIX_ERRORS) {\n\n                s->l1_table[i] = refcount == 1\n\n                               ? l1_entry |  QCOW_OFLAG_COPIED\n\n                               : l1_entry & ~QCOW_OFLAG_COPIED;\n\n                ret = qcow2_write_l1_entry(bs, i);\n\n                if (ret < 0) {\n\n                    res->check_errors++;\n\n                    goto fail;\n\n                }\n\n                res->corruptions_fixed++;\n\n            } else {\n\n                res->corruptions++;\n\n            }\n\n        }\n\n\n\n        ret = bdrv_pread(bs->file, l2_offset, l2_table,\n\n                         s->l2_size * sizeof(uint64_t));\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR: Could not read L2 table: %s\\n\",\n\n                    strerror(-ret));\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n\n\n        for (j = 0; j < s->l2_size; j++) {\n\n            uint64_t l2_entry = be64_to_cpu(l2_table[j]);\n\n            uint64_t data_offset = l2_entry & L2E_OFFSET_MASK;\n\n            QCow2ClusterType cluster_type = qcow2_get_cluster_type(l2_entry);\n\n\n\n            if ((cluster_type == QCOW2_CLUSTER_NORMAL) ||\n\n                ((cluster_type == QCOW2_CLUSTER_ZERO) && (data_offset != 0))) {\n\n                ret = qcow2_get_refcount(bs,\n\n                                         data_offset >> s->cluster_bits,\n\n                                         &refcount);\n\n                if (ret < 0) {\n\n                    /* don't print message nor increment check_errors */\n\n                    continue;\n\n                }\n\n                if ((refcount == 1) != ((l2_entry & QCOW_OFLAG_COPIED) != 0)) {\n\n                    fprintf(stderr, \"%s OFLAG_COPIED data cluster: \"\n\n                            \"l2_entry=%\" PRIx64 \" refcount=%\" PRIu64 \"\\n\",\n\n                            fix & BDRV_FIX_ERRORS ? \"Repairing\" :\n\n                                                    \"ERROR\",\n\n                            l2_entry, refcount);\n\n                    if (fix & BDRV_FIX_ERRORS) {\n\n                        l2_table[j] = cpu_to_be64(refcount == 1\n\n                                    ? l2_entry |  QCOW_OFLAG_COPIED\n\n                                    : l2_entry & ~QCOW_OFLAG_COPIED);\n\n                        l2_dirty = true;\n\n                        res->corruptions_fixed++;\n\n                    } else {\n\n                        res->corruptions++;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        if (l2_dirty) {\n\n            ret = qcow2_pre_write_overlap_check(bs, QCOW2_OL_ACTIVE_L2,\n\n                                                l2_offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"ERROR: Could not write L2 table; metadata \"\n\n                        \"overlap check failed: %s\\n\", strerror(-ret));\n\n                res->check_errors++;\n\n                goto fail;\n\n            }\n\n\n\n            ret = bdrv_pwrite(bs->file, l2_offset, l2_table,\n\n                              s->cluster_size);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"ERROR: Could not write L2 table: %s\\n\",\n\n                        strerror(-ret));\n\n                res->check_errors++;\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_vfree(l2_table);\n\n    return ret;\n\n}\n", "idx": 13050, "_split": "test", "_hash": "227a8f546eb796cf1949e96ad41477d6"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void mainstone_common_init(MemoryRegion *address_space_mem,\n\n                                  MachineState *machine,\n\n                                  enum mainstone_model_e model, int arm_id)\n\n{\n\n    uint32_t sector_len = 256 * 1024;\n\n    hwaddr mainstone_flash_base[] = { MST_FLASH_0, MST_FLASH_1 };\n\n    PXA2xxState *mpu;\n\n    DeviceState *mst_irq;\n\n    DriveInfo *dinfo;\n\n    int i;\n\n    int be;\n\n    MemoryRegion *rom = g_new(MemoryRegion, 1);\n\n    const char *cpu_model = machine->cpu_model;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"pxa270-c5\";\n\n\n\n    /* Setup CPU & memory */\n\n    mpu = pxa270_init(address_space_mem, mainstone_binfo.ram_size, cpu_model);\n\n    memory_region_init_ram(rom, NULL, \"mainstone.rom\", MAINSTONE_ROM,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(rom);\n\n    memory_region_set_readonly(rom, true);\n\n    memory_region_add_subregion(address_space_mem, 0, rom);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    /* There are two 32MiB flash devices on the board */\n\n    for (i = 0; i < 2; i ++) {\n\n        dinfo = drive_get(IF_PFLASH, 0, i);\n\n        if (!dinfo) {\n\n            if (qtest_enabled()) {\n\n                break;\n\n            }\n\n            fprintf(stderr, \"Two flash images must be given with the \"\n\n                    \"'pflash' parameter\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        if (!pflash_cfi01_register(mainstone_flash_base[i], NULL,\n\n                                   i ? \"mainstone.flash1\" : \"mainstone.flash0\",\n\n                                   MAINSTONE_FLASH,\n\n                                   blk_bs(blk_by_legacy_dinfo(dinfo)),\n\n                                   sector_len, MAINSTONE_FLASH / sector_len,\n\n                                   4, 0, 0, 0, 0, be)) {\n\n            fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    mst_irq = sysbus_create_simple(\"mainstone-fpga\", MST_FPGA_PHYS,\n\n                    qdev_get_gpio_in(mpu->gpio, 0));\n\n\n\n    /* setup keypad */\n\n    pxa27x_register_keypad(mpu->kp, map, 0xe0);\n\n\n\n    /* MMC/SD host */\n\n    pxa2xx_mmci_handlers(mpu->mmc, NULL, qdev_get_gpio_in(mst_irq, MMC_IRQ));\n\n\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[0],\n\n            qdev_get_gpio_in(mst_irq, S0_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S0_CD_IRQ));\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[1],\n\n            qdev_get_gpio_in(mst_irq, S1_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S1_CD_IRQ));\n\n\n\n    smc91c111_init(&nd_table[0], MST_ETH_PHYS,\n\n                    qdev_get_gpio_in(mst_irq, ETHERNET_IRQ));\n\n\n\n    mainstone_binfo.kernel_filename = machine->kernel_filename;\n\n    mainstone_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    mainstone_binfo.initrd_filename = machine->initrd_filename;\n\n    mainstone_binfo.board_id = arm_id;\n\n    arm_load_kernel(mpu->cpu, &mainstone_binfo);\n\n}\n", "idx": 13051, "_split": "test", "_hash": "4ab85a96ad9269662729f0d2c4ad4c67"}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void puv3_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    CPUUniCore32State *env;\n\n    UniCore32CPU *cpu;\n\n\n\n    if (initrd_filename) {\n\n        error_report(\"Please use kernel built-in initramdisk\");\n\n        exit(1);\n\n    }\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"UniCore-II\";\n\n    }\n\n\n\n    cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));\n\n    if (!cpu) {\n\n        error_report(\"Unable to find CPU definition\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    puv3_soc_init(env);\n\n    puv3_board_init(env, ram_size);\n\n    puv3_load_kernel(kernel_filename);\n\n}\n", "idx": 13077, "_split": "test", "_hash": "61f5bc95b34d58ea8933174e68842cfa"}
{"project": "qemu", "commit_id": "2ebafc854d109ff09b66fb4dd62c2c53fc29754a", "target": 1, "func": "static int qcow2_read_extensions(BlockDriverState *bs, uint64_t start_offset,\n\n                                 uint64_t end_offset, void **p_feature_table,\n\n                                 Error **errp)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowExtension ext;\n\n    uint64_t offset;\n\n    int ret;\n\n\n\n#ifdef DEBUG_EXT\n\n    printf(\"qcow2_read_extensions: start=%ld end=%ld\\n\", start_offset, end_offset);\n\n#endif\n\n    offset = start_offset;\n\n    while (offset < end_offset) {\n\n\n\n#ifdef DEBUG_EXT\n\n        /* Sanity check */\n\n        if (offset > s->cluster_size)\n\n            printf(\"qcow2_read_extension: suspicious offset %lu\\n\", offset);\n\n\n\n        printf(\"attempting to read extended header in offset %lu\\n\", offset);\n\n#endif\n\n\n\n        ret = bdrv_pread(bs->file, offset, &ext, sizeof(ext));\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"qcow2_read_extension: ERROR: \"\n\n                             \"pread fail from offset %\" PRIu64, offset);\n\n            return 1;\n\n        }\n\n        be32_to_cpus(&ext.magic);\n\n        be32_to_cpus(&ext.len);\n\n        offset += sizeof(ext);\n\n#ifdef DEBUG_EXT\n\n        printf(\"ext.magic = 0x%x\\n\", ext.magic);\n\n#endif\n\n        if (ext.len > end_offset - offset) {\n\n            error_setg(errp, \"Header extension too large\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        switch (ext.magic) {\n\n        case QCOW2_EXT_MAGIC_END:\n\n            return 0;\n\n\n\n        case QCOW2_EXT_MAGIC_BACKING_FORMAT:\n\n            if (ext.len >= sizeof(bs->backing_format)) {\n\n                error_setg(errp, \"ERROR: ext_backing_format: len=%\" PRIu32\n\n                           \" too large (>=%zu)\", ext.len,\n\n                           sizeof(bs->backing_format));\n\n                return 2;\n\n            }\n\n            ret = bdrv_pread(bs->file, offset, bs->backing_format, ext.len);\n\n            if (ret < 0) {\n\n                error_setg_errno(errp, -ret, \"ERROR: ext_backing_format: \"\n\n                                 \"Could not read format name\");\n\n                return 3;\n\n            }\n\n            bs->backing_format[ext.len] = '\\0';\n\n#ifdef DEBUG_EXT\n\n            printf(\"Qcow2: Got format extension %s\\n\", bs->backing_format);\n\n#endif\n\n            break;\n\n\n\n        case QCOW2_EXT_MAGIC_FEATURE_TABLE:\n\n            if (p_feature_table != NULL) {\n\n                void* feature_table = g_malloc0(ext.len + 2 * sizeof(Qcow2Feature));\n\n                ret = bdrv_pread(bs->file, offset , feature_table, ext.len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: ext_feature_table: \"\n\n                                     \"Could not read table\");\n\n                    return ret;\n\n                }\n\n\n\n                *p_feature_table = feature_table;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            /* unknown magic - save it in case we need to rewrite the header */\n\n            {\n\n                Qcow2UnknownHeaderExtension *uext;\n\n\n\n                uext = g_malloc0(sizeof(*uext)  + ext.len);\n\n                uext->magic = ext.magic;\n\n                uext->len = ext.len;\n\n                QLIST_INSERT_HEAD(&s->unknown_header_ext, uext, next);\n\n\n\n                ret = bdrv_pread(bs->file, offset , uext->data, uext->len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: unknown extension: \"\n\n                                     \"Could not read data\");\n\n                    return ret;\n\n                }\n\n            }\n\n            break;\n\n        }\n\n\n\n        offset += ((ext.len + 7) & ~7);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 13097, "_split": "test", "_hash": "86f4dce1368011a381cbab69214856a3"}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "void pl011_init(uint32_t base, qemu_irq irq,\n\n                CharDriverState *chr)\n\n{\n\n    int iomemtype;\n\n    pl011_state *s;\n\n\n\n    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));\n\n    iomemtype = cpu_register_io_memory(0, pl011_readfn,\n\n                                       pl011_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->chr = chr;\n\n    s->read_trigger = 1;\n\n    s->ifl = 0x12;\n\n    s->cr = 0x300;\n\n    s->flags = 0x90;\n\n    if (chr){ \n\n        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,\n\n                              pl011_event, s);\n\n    }\n\n    /* ??? Save/restore.  */\n\n}\n", "idx": 13114, "_split": "test", "_hash": "39d16fc2a6dacaf5775bf435cc1ae876"}
{"project": "qemu", "commit_id": "dd09c36159858c66ab6e47c688e4177dd3912bf0", "target": 1, "func": "static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)\n\n{\n\n    gen_read_xer(cpu_gpr[gprn]);\n\n}\n", "idx": 13118, "_split": "test", "_hash": "0638564d36e933ec85ba7b0f4a1bafe5"}
{"project": "qemu", "commit_id": "f3c75d42adbba553eaf218a832d4fbea32c8f7b8", "target": 1, "func": "static int cpu_load_old(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    PowerPCCPU *cpu = opaque;\n\n    CPUPPCState *env = &cpu->env;\n\n    unsigned int i, j;\n\n    target_ulong sdr1;\n\n    uint32_t fpscr;\n\n    target_ulong xer;\n\n\n\n    for (i = 0; i < 32; i++)\n\n        qemu_get_betls(f, &env->gpr[i]);\n\n#if !defined(TARGET_PPC64)\n\n    for (i = 0; i < 32; i++)\n\n        qemu_get_betls(f, &env->gprh[i]);\n\n#endif\n\n    qemu_get_betls(f, &env->lr);\n\n    qemu_get_betls(f, &env->ctr);\n\n    for (i = 0; i < 8; i++)\n\n        qemu_get_be32s(f, &env->crf[i]);\n\n    qemu_get_betls(f, &xer);\n\n    cpu_write_xer(env, xer);\n\n    qemu_get_betls(f, &env->reserve_addr);\n\n    qemu_get_betls(f, &env->msr);\n\n    for (i = 0; i < 4; i++)\n\n        qemu_get_betls(f, &env->tgpr[i]);\n\n    for (i = 0; i < 32; i++) {\n\n        union {\n\n            float64 d;\n\n            uint64_t l;\n\n        } u;\n\n        u.l = qemu_get_be64(f);\n\n        env->fpr[i] = u.d;\n\n    }\n\n    qemu_get_be32s(f, &fpscr);\n\n    env->fpscr = fpscr;\n\n    qemu_get_sbe32s(f, &env->access_type);\n\n#if defined(TARGET_PPC64)\n\n    qemu_get_betls(f, &env->spr[SPR_ASR]);\n\n    qemu_get_sbe32s(f, &env->slb_nr);\n\n#endif\n\n    qemu_get_betls(f, &sdr1);\n\n    for (i = 0; i < 32; i++)\n\n        qemu_get_betls(f, &env->sr[i]);\n\n    for (i = 0; i < 2; i++)\n\n        for (j = 0; j < 8; j++)\n\n            qemu_get_betls(f, &env->DBAT[i][j]);\n\n    for (i = 0; i < 2; i++)\n\n        for (j = 0; j < 8; j++)\n\n            qemu_get_betls(f, &env->IBAT[i][j]);\n\n    qemu_get_sbe32s(f, &env->nb_tlb);\n\n    qemu_get_sbe32s(f, &env->tlb_per_way);\n\n    qemu_get_sbe32s(f, &env->nb_ways);\n\n    qemu_get_sbe32s(f, &env->last_way);\n\n    qemu_get_sbe32s(f, &env->id_tlbs);\n\n    qemu_get_sbe32s(f, &env->nb_pids);\n\n    if (env->tlb.tlb6) {\n\n        // XXX assumes 6xx\n\n        for (i = 0; i < env->nb_tlb; i++) {\n\n            qemu_get_betls(f, &env->tlb.tlb6[i].pte0);\n\n            qemu_get_betls(f, &env->tlb.tlb6[i].pte1);\n\n            qemu_get_betls(f, &env->tlb.tlb6[i].EPN);\n\n        }\n\n    }\n\n    for (i = 0; i < 4; i++)\n\n        qemu_get_betls(f, &env->pb[i]);\n\n    for (i = 0; i < 1024; i++)\n\n        qemu_get_betls(f, &env->spr[i]);\n\n    ppc_store_sdr1(env, sdr1);\n\n    qemu_get_be32s(f, &env->vscr);\n\n    qemu_get_be64s(f, &env->spe_acc);\n\n    qemu_get_be32s(f, &env->spe_fscr);\n\n    qemu_get_betls(f, &env->msr_mask);\n\n    qemu_get_be32s(f, &env->flags);\n\n    qemu_get_sbe32s(f, &env->error_code);\n\n    qemu_get_be32s(f, &env->pending_interrupts);\n\n    qemu_get_be32s(f, &env->irq_input_state);\n\n    for (i = 0; i < POWERPC_EXCP_NB; i++)\n\n        qemu_get_betls(f, &env->excp_vectors[i]);\n\n    qemu_get_betls(f, &env->excp_prefix);\n\n    qemu_get_betls(f, &env->ivor_mask);\n\n    qemu_get_betls(f, &env->ivpr_mask);\n\n    qemu_get_betls(f, &env->hreset_vector);\n\n    qemu_get_betls(f, &env->nip);\n\n    qemu_get_betls(f, &env->hflags);\n\n    qemu_get_betls(f, &env->hflags_nmsr);\n\n    qemu_get_sbe32s(f, &env->mmu_idx);\n\n    qemu_get_sbe32(f); /* Discard unused power_mode */\n\n\n\n    return 0;\n\n}\n", "idx": 13130, "_split": "test", "_hash": "38dec96863859b62beaf4d41df3f1438"}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtoul_invalid(void)\n\n{\n\n    const char *str = \"   xxxx  \\t abc\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 13136, "_split": "test", "_hash": "a5959e2f9f615e85e22d31aff18733fd"}
{"project": "qemu", "commit_id": "afcf905cff7971324c2706600ead35a1f41f417a", "target": 1, "func": "static void aml_free(gpointer data, gpointer user_data)\n\n{\n\n    Aml *var = data;\n\n    build_free_array(var->buf);\n\n\n}", "idx": 13140, "_split": "test", "_hash": "214af2eb5091541b99365f6c415c0b4b"}
{"project": "qemu", "commit_id": "36b15c79aa1bef5fe7543f9f2629b6413720bbfb", "target": 0, "func": "static void virtio_scsi_handle_cmd(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    /* use non-QOM casts in the data path */\n\n    VirtIOSCSI *s = (VirtIOSCSI *)vdev;\n\n    VirtIOSCSICommon *vs = &s->parent_obj;\n\n\n\n    VirtIOSCSIReq *req;\n\n    int n;\n\n\n\n    while ((req = virtio_scsi_pop_req(s, vq))) {\n\n        SCSIDevice *d;\n\n        int out_size, in_size;\n\n        if (req->elem.out_num < 1 || req->elem.in_num < 1) {\n\n            virtio_scsi_bad_req();\n\n        }\n\n\n\n        out_size = req->elem.out_sg[0].iov_len;\n\n        in_size = req->elem.in_sg[0].iov_len;\n\n        if (out_size < sizeof(VirtIOSCSICmdReq) + vs->cdb_size ||\n\n            in_size < sizeof(VirtIOSCSICmdResp) + vs->sense_size) {\n\n            virtio_scsi_bad_req();\n\n        }\n\n\n\n        if (req->elem.out_num > 1 && req->elem.in_num > 1) {\n\n            virtio_scsi_fail_cmd_req(req);\n\n            continue;\n\n        }\n\n\n\n        d = virtio_scsi_device_find(s, req->req.cmd->lun);\n\n        if (!d) {\n\n            req->resp.cmd->response = VIRTIO_SCSI_S_BAD_TARGET;\n\n            virtio_scsi_complete_req(req);\n\n            continue;\n\n        }\n\n        req->sreq = scsi_req_new(d, req->req.cmd->tag,\n\n                                 virtio_scsi_get_lun(req->req.cmd->lun),\n\n                                 req->req.cmd->cdb, req);\n\n\n\n        if (req->sreq->cmd.mode != SCSI_XFER_NONE) {\n\n            int req_mode =\n\n                (req->elem.in_num > 1 ? SCSI_XFER_FROM_DEV : SCSI_XFER_TO_DEV);\n\n\n\n            if (req->sreq->cmd.mode != req_mode ||\n\n                req->sreq->cmd.xfer > req->qsgl.size) {\n\n                req->resp.cmd->response = VIRTIO_SCSI_S_OVERRUN;\n\n                virtio_scsi_complete_req(req);\n\n                continue;\n\n            }\n\n        }\n\n\n\n        n = scsi_req_enqueue(req->sreq);\n\n        if (n) {\n\n            scsi_req_continue(req->sreq);\n\n        }\n\n    }\n\n}\n", "idx": 13149, "_split": "test", "_hash": "32e6359055c11a09fcccbe19b486570f"}
{"project": "qemu", "commit_id": "d82831dbc5471d72785c49b33710436af49bf9ca", "target": 0, "func": "CharDriverState *text_console_init(QemuOpts *opts)\n\n{\n\n    CharDriverState *chr;\n\n    QemuConsole *s;\n\n    unsigned width;\n\n    unsigned height;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n\n\n    width = qemu_opt_get_number(opts, \"width\", 0);\n\n    if (width == 0)\n\n        width = qemu_opt_get_number(opts, \"cols\", 0) * FONT_WIDTH;\n\n\n\n    height = qemu_opt_get_number(opts, \"height\", 0);\n\n    if (height == 0)\n\n        height = qemu_opt_get_number(opts, \"rows\", 0) * FONT_HEIGHT;\n\n\n\n    if (width == 0 || height == 0) {\n\n        s = new_console(NULL, TEXT_CONSOLE);\n\n    } else {\n\n        s = new_console(NULL, TEXT_CONSOLE_FIXED_SIZE);\n\n    }\n\n\n\n    if (!s) {\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n\n\n    s->chr = chr;\n\n    s->g_width = width;\n\n    s->g_height = height;\n\n    chr->opaque = s;\n\n    chr->chr_set_echo = text_console_set_echo;\n\n    return chr;\n\n}\n", "idx": 13154, "_split": "test", "_hash": "864e626a03ff2c58e58ff7d11d77b1ae"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    EEPRO100State *s = opaque;\n\n\n\n    switch (size) {\n\n    case 1: return eepro100_read1(s, addr);\n\n    case 2: return eepro100_read2(s, addr);\n\n    case 4: return eepro100_read4(s, addr);\n\n    default: abort();\n\n    }\n\n}\n", "idx": 13155, "_split": "test", "_hash": "846d335be4f42d59623f3ec0a8887ec5"}
{"project": "qemu", "commit_id": "ef546f1275f6563e8934dd5e338d29d9f9909ca6", "target": 0, "func": "bool vring_should_notify(VirtIODevice *vdev, Vring *vring)\n\n{\n\n    uint16_t old, new;\n\n    bool v;\n\n    /* Flush out used index updates. This is paired\n\n     * with the barrier that the Guest executes when enabling\n\n     * interrupts. */\n\n    smp_mb();\n\n\n\n    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&\n\n        unlikely(!vring_more_avail(vdev, vring))) {\n\n        return true;\n\n    }\n\n\n\n    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {\n\n        return !(vring_get_avail_flags(vdev, vring) &\n\n                 VRING_AVAIL_F_NO_INTERRUPT);\n\n    }\n\n    old = vring->signalled_used;\n\n    v = vring->signalled_used_valid;\n\n    new = vring->signalled_used = vring->last_used_idx;\n\n    vring->signalled_used_valid = true;\n\n\n\n    if (unlikely(!v)) {\n\n        return true;\n\n    }\n\n\n\n    return vring_need_event(vring_used_event(&vring->vr), new, old);\n\n}\n", "idx": 13156, "_split": "test", "_hash": "9464457aa67a9b3951a0f79f0adc413b"}
{"project": "qemu", "commit_id": "97f90cbfe810bb153fc44bde732d9639610783bb", "target": 0, "func": "void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,\n\n                          int is_asi, int size)\n\n{\n\n    CPUState *saved_env;\n\n    /* XXX: hack to restore env in all cases, even if not called from\n\n       generated code */\n\n    saved_env = env;\n\n    env = cpu_single_env;\n\n    qemu_log(\"Unassigned \" TARGET_FMT_plx \" wr=%d exe=%d\\n\",\n\n             addr, is_write, is_exec);\n\n    if (!(env->sregs[SR_MSR] & MSR_EE)) {\n\n        return;\n\n    }\n\n\n\n    if (is_exec) {\n\n        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {\n\n            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;\n\n            helper_raise_exception(EXCP_HW_EXCP);\n\n        }\n\n    } else {\n\n        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {\n\n            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;\n\n            helper_raise_exception(EXCP_HW_EXCP);\n\n        }\n\n    }\n\n}\n", "idx": 13172, "_split": "test", "_hash": "a6676de576f274cba51211b72ed98e11"}
{"project": "qemu", "commit_id": "f53c398aa603cea135ee58fd15249aeff7b9c7ea", "target": 1, "func": "static void ohci_async_cancel_device(OHCIState *ohci, USBDevice *dev)\n\n{\n\n    if (ohci->async_td &&\n\n        ohci->usb_packet.owner != NULL &&\n\n        ohci->usb_packet.owner->dev == dev) {\n\n        usb_cancel_packet(&ohci->usb_packet);\n\n        ohci->async_td = 0;\n\n    }\n\n}\n", "idx": 13236, "_split": "test", "_hash": "33ddecbbf7b656573764a19692394314"}
{"project": "qemu", "commit_id": "f678f671ba654d4610f0e43d175c8c1b2fad10df", "target": 1, "func": "static void decode_abs_store(CPUTriCoreState *env, DisasContext *ctx)\n\n{\n\n    int32_t op2;\n\n    int32_t r1;\n\n    uint32_t address;\n\n    TCGv temp;\n\n\n\n    r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n    address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n    op2 = MASK_OP_ABS_OP2(ctx->opcode);\n\n\n\n    temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n\n\n    switch (op2) {\n\n    case OPC2_32_ABS_ST_A:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], temp, ctx->mem_idx, MO_LESL);\n\n        break;\n\n    case OPC2_32_ABS_ST_D:\n\n        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);\n\n        break;\n\n    case OPC2_32_ABS_ST_DA:\n\n        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);\n\n        break;\n\n    case OPC2_32_ABS_ST_W:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LESL);\n\n        break;\n\n\n\n    }\n\n    tcg_temp_free(temp);\n\n}\n", "idx": 13347, "_split": "test", "_hash": "35a6a4a9752d7d31fd6348ba03502859"}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_readdir(void *opaque)\n\n{\n\n    int32_t fid;\n\n    V9fsFidState *fidp;\n\n    ssize_t retval = 0;\n\n    size_t offset = 7;\n\n    uint64_t initial_offset;\n\n    int32_t count;\n\n    uint32_t max_count;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dqd\", &fid, &initial_offset, &max_count);\n\n\n\n    trace_v9fs_readdir(pdu->tag, pdu->id, fid, initial_offset, max_count);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        retval = -EINVAL;\n\n        goto out_nofid;\n\n    }\n\n    if (!fidp->fs.dir) {\n\n        retval = -EINVAL;\n\n        goto out;\n\n    }\n\n    if (initial_offset == 0) {\n\n        v9fs_co_rewinddir(pdu, fidp);\n\n    } else {\n\n        v9fs_co_seekdir(pdu, fidp, initial_offset);\n\n    }\n\n    count = v9fs_do_readdir(pdu, fidp, max_count);\n\n    if (count < 0) {\n\n        retval = count;\n\n        goto out;\n\n    }\n\n    retval = offset;\n\n    retval += pdu_marshal(pdu, offset, \"d\", count);\n\n    retval += count;\n\n    trace_v9fs_readdir_return(pdu->tag, pdu->id, count, retval);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(s, pdu, retval);\n\n}\n", "idx": 13357, "_split": "test", "_hash": "1042793cf745fb85bb093572fe39ddde"}
{"project": "qemu", "commit_id": "e3e09d87c6e69c2da684d5aacabe3124ebcb6f8e", "target": 0, "func": "uint64_t HELPER(lra)(CPUS390XState *env, uint64_t addr)\n\n{\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    uint32_t cc = 0;\n\n    int old_exc = cs->exception_index;\n\n    uint64_t asc = env->psw.mask & PSW_MASK_ASC;\n\n    uint64_t ret;\n\n    int flags;\n\n\n\n    /* XXX incomplete - has more corner cases */\n\n    if (!(env->psw.mask & PSW_MASK_64) && (addr >> 32)) {\n\n        program_interrupt(env, PGM_SPECIAL_OP, 2);\n\n    }\n\n\n\n    cs->exception_index = old_exc;\n\n    if (mmu_translate(env, addr, 0, asc, &ret, &flags)) {\n\n        cc = 3;\n\n    }\n\n    if (cs->exception_index == EXCP_PGM) {\n\n        ret = env->int_pgm_code | 0x80000000;\n\n    } else {\n\n        ret |= addr & ~TARGET_PAGE_MASK;\n\n    }\n\n    cs->exception_index = old_exc;\n\n\n\n    env->cc_op = cc;\n\n    return ret;\n\n}\n", "idx": 13363, "_split": "test", "_hash": "be1dcdf2b22f28f1dd42f0ccd457fea9"}
{"project": "qemu", "commit_id": "46181129eac9a56d9a948667282dd03d5015f096", "target": 0, "func": "static int bdrv_check_update_perm(BlockDriverState *bs, uint64_t new_used_perm,\n\n                                  uint64_t new_shared_perm,\n\n                                  BdrvChild *ignore_child, Error **errp)\n\n{\n\n    BdrvChild *c;\n\n    uint64_t cumulative_perms = new_used_perm;\n\n    uint64_t cumulative_shared_perms = new_shared_perm;\n\n\n\n    /* There is no reason why anyone couldn't tolerate write_unchanged */\n\n    assert(new_shared_perm & BLK_PERM_WRITE_UNCHANGED);\n\n\n\n    QLIST_FOREACH(c, &bs->parents, next_parent) {\n\n        if (c == ignore_child) {\n\n            continue;\n\n        }\n\n\n\n        if ((new_used_perm & c->shared_perm) != new_used_perm) {\n\n            char *user = bdrv_child_user_desc(c);\n\n            char *perm_names = bdrv_perm_names(new_used_perm & ~c->shared_perm);\n\n            error_setg(errp, \"Conflicts with use by %s as '%s', which does not \"\n\n                             \"allow '%s' on %s\",\n\n                       user, c->name, perm_names, bdrv_get_node_name(c->bs));\n\n            g_free(user);\n\n            g_free(perm_names);\n\n            return -EPERM;\n\n        }\n\n\n\n        if ((c->perm & new_shared_perm) != c->perm) {\n\n            char *user = bdrv_child_user_desc(c);\n\n            char *perm_names = bdrv_perm_names(c->perm & ~new_shared_perm);\n\n            error_setg(errp, \"Conflicts with use by %s as '%s', which uses \"\n\n                             \"'%s' on %s\",\n\n                       user, c->name, perm_names, bdrv_get_node_name(c->bs));\n\n            g_free(user);\n\n            g_free(perm_names);\n\n            return -EPERM;\n\n        }\n\n\n\n        cumulative_perms |= c->perm;\n\n        cumulative_shared_perms &= c->shared_perm;\n\n    }\n\n\n\n    return bdrv_check_perm(bs, cumulative_perms, cumulative_shared_perms, errp);\n\n}\n", "idx": 13365, "_split": "test", "_hash": "93783c15aa80460a830cbcb64265b5ac"}
{"project": "qemu", "commit_id": "810f49b56a5d0cd6848856af51d3093ae9adc7b1", "target": 0, "func": "static void monitor_protocol_emitter(Monitor *mon, QObject *data)\n\n{\n\n    QDict *qmp;\n\n\n\n    qmp = qdict_new();\n\n\n\n    if (!monitor_has_error(mon)) {\n\n        /* success response */\n\n        if (data) {\n\n            assert(qobject_type(data) == QTYPE_QDICT);\n\n            qobject_incref(data);\n\n            qdict_put_obj(qmp, \"return\", data);\n\n        } else {\n\n            /* return an empty QDict by default */\n\n            qdict_put(qmp, \"return\", qdict_new());\n\n        }\n\n    } else {\n\n        /* error response */\n\n        qdict_put(mon->error->error, \"desc\", qerror_human(mon->error));\n\n        qdict_put(qmp, \"error\", mon->error->error);\n\n        QINCREF(mon->error->error);\n\n        QDECREF(mon->error);\n\n        mon->error = NULL;\n\n    }\n\n\n\n    if (mon->mc->id) {\n\n        qdict_put_obj(qmp, \"id\", mon->mc->id);\n\n        mon->mc->id = NULL;\n\n    }\n\n\n\n    monitor_json_emitter(mon, QOBJECT(qmp));\n\n    QDECREF(qmp);\n\n}\n", "idx": 13366, "_split": "test", "_hash": "77bd553bbba88a014a6110dded91b136"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,\n\n                          const uint8_t *buf, int nb_sectors)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    int ret;\n\n\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n    if (!drv->bdrv_write_compressed) {\n\n        return -ENOTSUP;\n\n    }\n\n    ret = bdrv_check_request(bs, sector_num, nb_sectors);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n\n\n    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);\n\n}\n", "idx": 13415, "_split": "test", "_hash": "240fb694924fe7d4aa4136a80b469da9"}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int usb_host_handle_control(USBDevice *dev, USBPacket *p,\n\n               int request, int value, int index, int length, uint8_t *data)\n\n{\n\n    USBHostDevice *s = DO_UPCAST(USBHostDevice, dev, dev);\n\n    struct usbdevfs_urb *urb;\n\n    AsyncURB *aurb;\n\n    int ret;\n\n\n\n    /*\n\n     * Process certain standard device requests.\n\n     * These are infrequent and are processed synchronously.\n\n     */\n\n\n\n    /* Note request is (bRequestType << 8) | bRequest */\n\n    trace_usb_host_req_control(s->bus_num, s->addr, request, value, index);\n\n\n\n    switch (request) {\n\n    case DeviceOutRequest | USB_REQ_SET_ADDRESS:\n\n        return usb_host_set_address(s, value);\n\n\n\n    case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:\n\n        return usb_host_set_config(s, value & 0xff);\n\n\n\n    case InterfaceOutRequest | USB_REQ_SET_INTERFACE:\n\n        return usb_host_set_interface(s, index, value);\n\n    }\n\n\n\n    /* The rest are asynchronous */\n\n\n\n    if (length > sizeof(dev->data_buf)) {\n\n        fprintf(stderr, \"husb: ctrl buffer too small (%d > %zu)\\n\",\n\n                length, sizeof(dev->data_buf));\n\n        return USB_RET_STALL;\n\n    }\n\n\n\n    aurb = async_alloc(s);\n\n    aurb->packet = p;\n\n\n\n    /*\n\n     * Setup ctrl transfer.\n\n     *\n\n     * s->ctrl is laid out such that data buffer immediately follows\n\n     * 'req' struct which is exactly what usbdevfs expects.\n\n     */\n\n    urb = &aurb->urb;\n\n\n\n    urb->type     = USBDEVFS_URB_TYPE_CONTROL;\n\n    urb->endpoint = p->devep;\n\n\n\n    urb->buffer        = &dev->setup_buf;\n\n    urb->buffer_length = length + 8;\n\n\n\n    urb->usercontext = s;\n\n\n\n    trace_usb_host_urb_submit(s->bus_num, s->addr, aurb,\n\n                              urb->buffer_length, aurb->more);\n\n    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);\n\n\n\n    DPRINTF(\"husb: submit ctrl. len %u aurb %p\\n\", urb->buffer_length, aurb);\n\n\n\n    if (ret < 0) {\n\n        DPRINTF(\"husb: submit failed. errno %d\\n\", errno);\n\n        async_free(aurb);\n\n\n\n        switch(errno) {\n\n        case ETIMEDOUT:\n\n            return USB_RET_NAK;\n\n        case EPIPE:\n\n        default:\n\n            return USB_RET_STALL;\n\n        }\n\n    }\n\n\n\n    return USB_RET_ASYNC;\n\n}\n", "idx": 13426, "_split": "test", "_hash": "c1f370e3da64b82a3023386bf658d20e"}
{"project": "qemu", "commit_id": "274250c30158f60aefb46088a7bb0d711061226c", "target": 1, "func": "static inline void s390_machine_initfn(Object *obj)\n\n{\n\n    object_property_add_bool(obj, \"aes-key-wrap\",\n\n                             machine_get_aes_key_wrap,\n\n                             machine_set_aes_key_wrap, NULL);\n\n    object_property_set_description(obj, \"aes-key-wrap\",\n\n            \"enable/disable AES key wrapping using the CPACF wrapping key\",\n\n\n    object_property_set_bool(obj, true, \"aes-key-wrap\", NULL);\n\n\n\n    object_property_add_bool(obj, \"dea-key-wrap\",\n\n                             machine_get_dea_key_wrap,\n\n                             machine_set_dea_key_wrap, NULL);\n\n    object_property_set_description(obj, \"dea-key-wrap\",\n\n            \"enable/disable DEA key wrapping using the CPACF wrapping key\",\n\n\n    object_property_set_bool(obj, true, \"dea-key-wrap\", NULL);\n\n    object_property_add_str(obj, \"loadparm\",\n\n            machine_get_loadparm, machine_set_loadparm, NULL);\n\n    object_property_set_description(obj, \"loadparm\",\n\n            \"Up to 8 chars in set of [A-Za-z0-9. ] (lower case chars converted\"\n\n            \" to upper case) to pass to machine loader, boot manager,\"\n\n            \" and guest kernel\",\n\n\n\n\n\n\n\n\n\n}", "idx": 13437, "_split": "test", "_hash": "eb02356e3313e114ed5d5ee95a625e5e"}
{"project": "qemu", "commit_id": "b5e751b51f14cffada6be647aa576b79f1755d7e", "target": 1, "func": "static void qemu_spice_display_init_one(QemuConsole *con)\n\n{\n\n    SimpleSpiceDisplay *ssd = g_new0(SimpleSpiceDisplay, 1);\n\n\n\n    qemu_spice_display_init_common(ssd);\n\n\n\n    ssd->qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_display_interface(&ssd->qxl, con);\n\n    assert(ssd->worker);\n\n\n\n    qemu_spice_create_host_memslot(ssd);\n\n\n\n    ssd->dcl.ops = &display_listener_ops;\n\n    ssd->dcl.con = con;\n\n    register_displaychangelistener(&ssd->dcl);\n\n}\n", "idx": 13448, "_split": "test", "_hash": "c85147231f13a8cd463a1e361a962afe"}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_in_native_list_int32(TestInputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    test_native_list_integer_helper(data, unused,\n\n                                    USER_DEF_NATIVE_LIST_UNION_KIND_S32);\n\n}\n", "idx": 13494, "_split": "test", "_hash": "0b3e325e860619ec16dffb679072181f"}
{"project": "qemu", "commit_id": "353ab969730742b7392414d62f4ba9632e8cf22c", "target": 0, "func": "static void nbd_trip(void *opaque)\n\n{\n\n    NBDClient *client = opaque;\n\n    NBDExport *exp = client->exp;\n\n    NBDRequest *req;\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n    uint32_t command;\n\n\n\n    TRACE(\"Reading request.\");\n\n    if (client->closing) {\n\n        return;\n\n    }\n\n\n\n    req = nbd_request_get(client);\n\n    ret = nbd_co_receive_request(req, &request);\n\n    if (ret == -EAGAIN) {\n\n        goto done;\n\n    }\n\n    if (ret == -EIO) {\n\n        goto out;\n\n    }\n\n\n\n    reply.handle = request.handle;\n\n    reply.error = 0;\n\n\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n        goto error_reply;\n\n    }\n\n    command = request.type & NBD_CMD_MASK_COMMAND;\n\n    if (command != NBD_CMD_DISC && (request.from + request.len) > exp->size) {\n\n            LOG(\"From: %\" PRIu64 \", Len: %u, Size: %\" PRIu64\n\n            \", Offset: %\" PRIu64 \"\\n\",\n\n                    request.from, request.len,\n\n                    (uint64_t)exp->size, (uint64_t)exp->dev_offset);\n\n        LOG(\"requested operation past EOF--bad client?\");\n\n        goto invalid_request;\n\n    }\n\n\n\n    if (client->closing) {\n\n        /*\n\n         * The client may be closed when we are blocked in\n\n         * nbd_co_receive_request()\n\n         */\n\n        goto done;\n\n    }\n\n\n\n    switch (command) {\n\n    case NBD_CMD_READ:\n\n        TRACE(\"Request type is READ\");\n\n\n\n        if (request.type & NBD_CMD_FLAG_FUA) {\n\n            ret = blk_co_flush(exp->blk);\n\n            if (ret < 0) {\n\n                LOG(\"flush failed\");\n\n                reply.error = -ret;\n\n                goto error_reply;\n\n            }\n\n        }\n\n\n\n        ret = blk_pread(exp->blk, request.from + exp->dev_offset,\n\n                        req->data, request.len);\n\n        if (ret < 0) {\n\n            LOG(\"reading from file failed\");\n\n            reply.error = -ret;\n\n            goto error_reply;\n\n        }\n\n\n\n        TRACE(\"Read %u byte(s)\", request.len);\n\n        if (nbd_co_send_reply(req, &reply, request.len) < 0)\n\n            goto out;\n\n        break;\n\n    case NBD_CMD_WRITE:\n\n        TRACE(\"Request type is WRITE\");\n\n\n\n        if (exp->nbdflags & NBD_FLAG_READ_ONLY) {\n\n            TRACE(\"Server is read-only, return error\");\n\n            reply.error = EROFS;\n\n            goto error_reply;\n\n        }\n\n\n\n        TRACE(\"Writing to device\");\n\n\n\n        ret = blk_pwrite(exp->blk, request.from + exp->dev_offset,\n\n                         req->data, request.len, 0);\n\n        if (ret < 0) {\n\n            LOG(\"writing to file failed\");\n\n            reply.error = -ret;\n\n            goto error_reply;\n\n        }\n\n\n\n        if (request.type & NBD_CMD_FLAG_FUA) {\n\n            ret = blk_co_flush(exp->blk);\n\n            if (ret < 0) {\n\n                LOG(\"flush failed\");\n\n                reply.error = -ret;\n\n                goto error_reply;\n\n            }\n\n        }\n\n\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    case NBD_CMD_DISC:\n\n        TRACE(\"Request type is DISCONNECT\");\n\n        errno = 0;\n\n        goto out;\n\n    case NBD_CMD_FLUSH:\n\n        TRACE(\"Request type is FLUSH\");\n\n\n\n        ret = blk_co_flush(exp->blk);\n\n        if (ret < 0) {\n\n            LOG(\"flush failed\");\n\n            reply.error = -ret;\n\n        }\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    case NBD_CMD_TRIM:\n\n        TRACE(\"Request type is TRIM\");\n\n        ret = blk_co_discard(exp->blk, (request.from + exp->dev_offset)\n\n                                       / BDRV_SECTOR_SIZE,\n\n                             request.len / BDRV_SECTOR_SIZE);\n\n        if (ret < 0) {\n\n            LOG(\"discard failed\");\n\n            reply.error = -ret;\n\n        }\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    default:\n\n        LOG(\"invalid request type (%u) received\", request.type);\n\n    invalid_request:\n\n        reply.error = EINVAL;\n\n    error_reply:\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    }\n\n\n\n    TRACE(\"Request/Reply complete\");\n\n\n\ndone:\n\n    nbd_request_put(req);\n\n    return;\n\n\n\nout:\n\n    nbd_request_put(req);\n\n    client_close(client);\n\n}\n", "idx": 13504, "_split": "test", "_hash": "a328aa8d0a44e3e662059c14aea50b30"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_register_reset(QEMUResetHandler *func, void *opaque)\n\n{\n\n    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));\n\n\n\n    re->func = func;\n\n    re->opaque = opaque;\n\n    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);\n\n}\n", "idx": 13513, "_split": "test", "_hash": "4a72628c4d9f153381e62c0e209a38cf"}
{"project": "qemu", "commit_id": "149f54b53b7666a3facd45e86eece60ce7d3b114", "target": 0, "func": "void stl_phys_notdirty(hwaddr addr, uint32_t val)\n\n{\n\n    uint8_t *ptr;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!memory_region_is_ram(section->mr) || section->readonly) {\n\n        addr = memory_region_section_addr(section, addr);\n\n        if (memory_region_is_ram(section->mr)) {\n\n            section = &phys_sections[phys_section_rom];\n\n        }\n\n        io_mem_write(section->mr, addr, val, 4);\n\n    } else {\n\n        unsigned long addr1 = (memory_region_get_ram_addr(section->mr)\n\n                               & TARGET_PAGE_MASK)\n\n            + memory_region_section_addr(section, addr);\n\n        ptr = qemu_get_ram_ptr(addr1);\n\n        stl_p(ptr, val);\n\n\n\n        if (unlikely(in_migration)) {\n\n            if (!cpu_physical_memory_is_dirty(addr1)) {\n\n                /* invalidate code */\n\n                tb_invalidate_phys_page_range(addr1, addr1 + 4, 0);\n\n                /* set dirty bit */\n\n                cpu_physical_memory_set_dirty_flags(\n\n                    addr1, (0xff & ~CODE_DIRTY_FLAG));\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 13517, "_split": "test", "_hash": "32a34bb8e301ee9dbc6a46970c82046f"}
{"project": "qemu", "commit_id": "97679527bf2f002225d08cfb93f840cef449ac0e", "target": 1, "func": "PCIBus *i440fx_init(PCII440FXState **pi440fx_state, int *piix3_devfn, qemu_irq *pic, int ram_size)\n\n{\n\n    DeviceState *dev;\n\n    PCIBus *b;\n\n    PCIDevice *d;\n\n    I440FXState *s;\n\n    PIIX3State *piix3;\n\n\n\n    dev = qdev_create(NULL, \"i440FX-pcihost\");\n\n    s = FROM_SYSBUS(I440FXState, sysbus_from_qdev(dev));\n\n    b = pci_bus_new(&s->busdev.qdev, NULL, 0);\n\n    s->bus = b;\n\n    qdev_init_nofail(dev);\n\n\n\n    d = pci_create_simple(b, 0, \"i440FX\");\n\n    *pi440fx_state = DO_UPCAST(PCII440FXState, dev, d);\n\n\n\n    piix3 = DO_UPCAST(PIIX3State, dev,\n\n                                 pci_create_simple(b, -1, \"PIIX3\"));\n\n    piix3->pic = pic;\n\n    pci_bus_irqs(b, piix3_set_irq, pci_slot_get_pirq, piix3, 4);\n\n    (*pi440fx_state)->piix3 = piix3;\n\n\n\n    *piix3_devfn = piix3->dev.devfn;\n\n\n\n    ram_size = ram_size / 8 / 1024 / 1024;\n\n    if (ram_size > 255)\n\n        ram_size = 255;\n\n    (*pi440fx_state)->dev.config[0x57]=ram_size;\n\n\n\n    return b;\n\n}\n", "idx": 13548, "_split": "test", "_hash": "1971973fa44c7b5309b8f80c2ea1cade"}
{"project": "qemu", "commit_id": "c24a8a0b6dad5a33d84f5fb846edb28c43312c71", "target": 1, "func": "uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)\n\n{\n\n    return inline_cvttq(env, a, float_round_to_zero, 0);\n\n}\n", "idx": 13554, "_split": "test", "_hash": "b2fec41a1f72cfd81205791cbab458fc"}
{"project": "qemu", "commit_id": "9745807191a81c45970f780166f44a7f93b18653", "target": 1, "func": "static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)\n\n{\n\n    TCGv sr_cy = tcg_temp_new();\n\n\n\n    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);\n\n    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);\n\n\n\n    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);\n\n\n\n    gen_ove_cy(dc, sr_cy);\n\n    tcg_temp_free(sr_cy);\n\n}\n", "idx": 13556, "_split": "test", "_hash": "e30ba30a9ddf6e9251b59de025c6523c"}
{"project": "qemu", "commit_id": "1acae9f22380a03b468a29a3cc035b280610b5e4", "target": 0, "func": "_syscall4(int,sys_utimensat,int,dirfd,const char *,pathname,\n\n          const struct timespec *,tsp,int,flags)\n\n#endif\n\n#endif /* CONFIG_UTIMENSAT  */\n\n\n\n#ifdef CONFIG_INOTIFY\n\n#include <sys/inotify.h>\n\n\n\n#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)\n\nstatic int sys_inotify_init(void)\n\n{\n\n  return (inotify_init());\n\n}\n", "idx": 13589, "_split": "test", "_hash": "730760eadb0153295b8a16b9d1ec94b0"}
{"project": "qemu", "commit_id": "8dc7a7725bd6db2aa7e3c09b49bc21a1a25f40cb", "target": 1, "func": "static void curl_readv_bh_cb(void *p)\n\n{\n\n    CURLState *state;\n\n    int running;\n\n\n\n    CURLAIOCB *acb = p;\n\n    BDRVCURLState *s = acb->common.bs->opaque;\n\n\n\n    qemu_bh_delete(acb->bh);\n\n    acb->bh = NULL;\n\n\n\n    size_t start = acb->sector_num * SECTOR_SIZE;\n\n    size_t end;\n\n\n\n    // In case we have the requested data already (e.g. read-ahead),\n\n    // we can just call the callback and be done.\n\n    switch (curl_find_buf(s, start, acb->nb_sectors * SECTOR_SIZE, acb)) {\n\n        case FIND_RET_OK:\n\n            qemu_aio_release(acb);\n\n            // fall through\n\n        case FIND_RET_WAIT:\n\n            return;\n\n        default:\n\n            break;\n\n    }\n\n\n\n    // No cache found, so let's start a new request\n\n    state = curl_init_state(s);\n\n    if (!state) {\n\n        acb->common.cb(acb->common.opaque, -EIO);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    acb->start = 0;\n\n    acb->end = (acb->nb_sectors * SECTOR_SIZE);\n\n\n\n    state->buf_off = 0;\n\n    g_free(state->orig_buf);\n\n    state->buf_start = start;\n\n    state->buf_len = acb->end + s->readahead_size;\n\n    end = MIN(start + state->buf_len, s->len) - 1;\n\n    state->orig_buf = g_malloc(state->buf_len);\n\n    state->acb[0] = acb;\n\n\n\n    snprintf(state->range, 127, \"%zd-%zd\", start, end);\n\n    DPRINTF(\"CURL (AIO): Reading %d at %zd (%s)\\n\",\n\n            (acb->nb_sectors * SECTOR_SIZE), start, state->range);\n\n    curl_easy_setopt(state->curl, CURLOPT_RANGE, state->range);\n\n\n\n    curl_multi_add_handle(s->multi, state->curl);\n\n\n\n    /* Tell curl it needs to kick things off */\n\n    curl_multi_socket_action(s->multi, CURL_SOCKET_TIMEOUT, 0, &running);\n\n}\n", "idx": 13604, "_split": "test", "_hash": "468fd76c1b59fd5ab59ffae7de4e95c5"}
{"project": "qemu", "commit_id": "b0f74c87a1dbd6b0c5e4de7f1c5cb40197e3fbe9", "target": 1, "func": "static inline void menelaus_rtc_stop(struct menelaus_s *s)\n\n{\n\n    qemu_del_timer(s->rtc.hz);\n\n    s->rtc.next =- qemu_get_clock(rt_clock);\n\n    if (s->rtc.next < 1)\n\n        s->rtc.next = 1;\n\n}\n", "idx": 13667, "_split": "test", "_hash": "37de8d125f6b15a9dc86db4268d1caec"}
{"project": "qemu", "commit_id": "8cf07dcbe7691dbe4f47563058659dba6ef66b05", "target": 1, "func": "int drive_init(struct drive_opt *arg, int snapshot, void *opaque)\n\n{\n\n    char buf[128];\n\n    char file[1024];\n\n    char devname[128];\n\n    char serial[21];\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriverState *bdrv;\n\n    BlockDriver *drv = NULL;\n\n    QEMUMachine *machine = opaque;\n\n    int max_devs;\n\n    int index;\n\n    int cache;\n\n    int bdrv_flags, onerror;\n\n    int drives_table_idx;\n\n    char *str = arg->opt;\n\n    static const char * const params[] = { \"bus\", \"unit\", \"if\", \"index\",\n\n                                           \"cyls\", \"heads\", \"secs\", \"trans\",\n\n                                           \"media\", \"snapshot\", \"file\",\n\n                                           \"cache\", \"format\", \"serial\", \"werror\",\n\n                                           NULL };\n\n\n\n    if (check_params(params, str) < 0) {\n\n         fprintf(stderr, \"qemu: unknown parameter '%s' in '%s'\\n\",\n\n                         buf, str);\n\n         return -1;\n\n    }\n\n\n\n    file[0] = 0;\n\n    cyls = heads = secs = 0;\n\n    bus_id = 0;\n\n    unit_id = -1;\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    index = -1;\n\n    cache = 3;\n\n\n\n    if (machine->use_scsi) {\n\n        type = IF_SCSI;\n\n        max_devs = MAX_SCSI_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"scsi\");\n\n    } else {\n\n        type = IF_IDE;\n\n        max_devs = MAX_IDE_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"ide\");\n\n    }\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"bus\", str)) {\n\n        bus_id = strtol(buf, NULL, 0);\n\n\tif (bus_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid bus id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"unit\", str)) {\n\n        unit_id = strtol(buf, NULL, 0);\n\n\tif (unit_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid unit id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", str)) {\n\n        pstrcpy(devname, sizeof(devname), buf);\n\n        if (!strcmp(buf, \"ide\")) {\n\n\t    type = IF_IDE;\n\n            max_devs = MAX_IDE_DEVS;\n\n        } else if (!strcmp(buf, \"scsi\")) {\n\n\t    type = IF_SCSI;\n\n            max_devs = MAX_SCSI_DEVS;\n\n        } else if (!strcmp(buf, \"floppy\")) {\n\n\t    type = IF_FLOPPY;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"pflash\")) {\n\n\t    type = IF_PFLASH;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"mtd\")) {\n\n\t    type = IF_MTD;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"sd\")) {\n\n\t    type = IF_SD;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"xen\")) {\n\n\t    type = IF_XEN;\n\n            max_devs = 0;\n\n\t} else {\n\n            fprintf(stderr, \"qemu: '%s' unsupported bus type '%s'\\n\", str, buf);\n\n            return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"index\", str)) {\n\n        index = strtol(buf, NULL, 0);\n\n\tif (index < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid index\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cyls\", str)) {\n\n        cyls = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"heads\", str)) {\n\n        heads = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"secs\", str)) {\n\n        secs = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1 || cyls > 16383) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical cyls number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (heads < 1 || heads > 16) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical heads number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (secs < 1 || secs > 63) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical secs number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"trans\", str)) {\n\n        if (!cyls) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' trans must be used with cyls,heads and secs\\n\",\n\n                    str);\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            fprintf(stderr, \"qemu: '%s' invalid translation type\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"media\", str)) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                fprintf(stderr,\n\n                        \"qemu: '%s' invalid physical CHS format\\n\", str);\n\n\t        return -1;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid media\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"snapshot\", str)) {\n\n        if (!strcmp(buf, \"on\"))\n\n\t    snapshot = 1;\n\n        else if (!strcmp(buf, \"off\"))\n\n\t    snapshot = 0;\n\n\telse {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid snapshot option\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cache\", str)) {\n\n        if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\"))\n\n            cache = 0;\n\n        else if (!strcmp(buf, \"writethrough\"))\n\n            cache = 1;\n\n        else if (!strcmp(buf, \"writeback\"))\n\n            cache = 2;\n\n        else {\n\n           fprintf(stderr, \"qemu: invalid cache option\\n\");\n\n           return -1;\n\n        }\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"format\", str)) {\n\n       if (strcmp(buf, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            fprintf(stderr, \"\\n\");\n\n\t    return -1;\n\n        }\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            fprintf(stderr, \"qemu: '%s' invalid format\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (arg->file == NULL)\n\n        get_param_value(file, sizeof(file), \"file\", str);\n\n    else\n\n        pstrcpy(file, sizeof(file), arg->file);\n\n\n\n    if (!get_param_value(serial, sizeof(serial), \"serial\", str))\n\n\t    memset(serial, 0,  sizeof(serial));\n\n\n\n    onerror = BLOCK_ERR_STOP_ENOSPC;\n\n    if (get_param_value(buf, sizeof(serial), \"werror\", str)) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n\n            fprintf(stderr, \"werror is no supported by this format\\n\");\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"ignore\"))\n\n            onerror = BLOCK_ERR_IGNORE;\n\n        else if (!strcmp(buf, \"enospc\"))\n\n            onerror = BLOCK_ERR_STOP_ENOSPC;\n\n        else if (!strcmp(buf, \"stop\"))\n\n            onerror = BLOCK_ERR_STOP_ANY;\n\n        else if (!strcmp(buf, \"report\"))\n\n            onerror = BLOCK_ERR_REPORT;\n\n        else {\n\n            fprintf(stderr, \"qemu: '%s' invalid write error action\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' index cannot be used with bus and unit\\n\", str);\n\n            return -1;\n\n        }\n\n        if (max_devs == 0)\n\n        {\n\n            unit_id = index;\n\n            bus_id = 0;\n\n        } else {\n\n            unit_id = index % max_devs;\n\n            bus_id = index / max_devs;\n\n        }\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get_index(type, bus_id, unit_id) != -1) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        fprintf(stderr, \"qemu: '%s' unit %d too big (max is %d)\\n\",\n\n                        str, unit_id, max_devs - 1);\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * ignore multiple definitions\n\n     */\n\n\n\n    if (drive_get_index(type, bus_id, unit_id) != -1)\n\n        return -2;\n\n\n\n    /* init */\n\n\n\n    if (type == IF_IDE || type == IF_SCSI)\n\n        mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n    if (max_devs)\n\n        snprintf(buf, sizeof(buf), \"%s%i%s%i\",\n\n                 devname, bus_id, mediastr, unit_id);\n\n    else\n\n        snprintf(buf, sizeof(buf), \"%s%s%i\",\n\n                 devname, mediastr, unit_id);\n\n    bdrv = bdrv_new(buf);\n\n    drives_table_idx = drive_get_free_idx();\n\n    drives_table[drives_table_idx].bdrv = bdrv;\n\n    drives_table[drives_table_idx].type = type;\n\n    drives_table[drives_table_idx].bus = bus_id;\n\n    drives_table[drives_table_idx].unit = unit_id;\n\n    drives_table[drives_table_idx].onerror = onerror;\n\n    drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt;\n\n    strncpy(drives_table[drives_table_idx].serial, serial, sizeof(serial));\n\n    nb_drives++;\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n    case IF_VIRTIO:\n\n        break;\n\n    case IF_COUNT:\n\n        abort();\n\n    }\n\n    if (!file[0])\n\n        return -2;\n\n    bdrv_flags = 0;\n\n    if (snapshot) {\n\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n\n        cache = 2; /* always use write-back with snapshot */\n\n    }\n\n    if (cache == 0) /* no caching */\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    else if (cache == 2) /* write-back */\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    else if (cache == 3) /* not specified */\n\n        bdrv_flags |= BDRV_O_CACHE_DEF;\n\n    if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) {\n\n        fprintf(stderr, \"qemu: could not open disk image %s\\n\",\n\n                        file);\n\n        return -1;\n\n    }\n\n    if (bdrv_key_required(bdrv))\n\n        autostart = 0;\n\n    return drives_table_idx;\n\n}\n", "idx": 13672, "_split": "test", "_hash": "c6359a6e93999e348f0d3fdbd8a43874"}
{"project": "qemu", "commit_id": "217bfb445b54db618a30f3a39170bebd9fd9dbf2", "target": 1, "func": "static void gic_complete_irq(gic_state * s, int cpu, int irq)\n\n{\n\n    int update = 0;\n\n    int cm = 1 << cpu;\n\n    DPRINTF(\"EOI %d\\n\", irq);\n\n    if (s->running_irq[cpu] == 1023)\n\n        return; /* No active IRQ.  */\n\n    if (irq != 1023) {\n\n        /* Mark level triggered interrupts as pending if they are still\n\n           raised.  */\n\n        if (!GIC_TEST_TRIGGER(irq) && GIC_TEST_ENABLED(irq, cm)\n\n                && GIC_TEST_LEVEL(irq, cm) && (GIC_TARGET(irq) & cm) != 0) {\n\n            DPRINTF(\"Set %d pending mask %x\\n\", irq, cm);\n\n            GIC_SET_PENDING(irq, cm);\n\n            update = 1;\n\n        }\n\n    }\n\n    if (irq != s->running_irq[cpu]) {\n\n        /* Complete an IRQ that is not currently running.  */\n\n        int tmp = s->running_irq[cpu];\n\n        while (s->last_active[tmp][cpu] != 1023) {\n\n            if (s->last_active[tmp][cpu] == irq) {\n\n                s->last_active[tmp][cpu] = s->last_active[irq][cpu];\n\n                break;\n\n            }\n\n            tmp = s->last_active[tmp][cpu];\n\n        }\n\n        if (update) {\n\n            gic_update(s);\n\n        }\n\n    } else {\n\n        /* Complete the current running IRQ.  */\n\n        gic_set_running_irq(s, cpu, s->last_active[s->running_irq[cpu]][cpu]);\n\n    }\n\n}\n", "idx": 13706, "_split": "test", "_hash": "554125cd0187a76e1d98c12ccc9a297d"}
{"project": "qemu", "commit_id": "9e0ff75e5158c7dbb65ee447382bbdf4cafbef8b", "target": 1, "func": "char *vnc_display_local_addr(const char *id)\n\n{\n\n    VncDisplay *vs = vnc_display_find(id);\n\n\n\n\n    return vnc_socket_local_addr(\"%s:%s\", vs->lsock);\n\n}", "idx": 13726, "_split": "test", "_hash": "8331e029c7ab3919373a7ba2435286f6"}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(set_T0)\n\n{\n\n    T0 = PARAM(1);\n\n    RETURN();\n\n}\n", "idx": 13728, "_split": "test", "_hash": "980050dd679671967533f32bb8cdf712"}
{"project": "qemu", "commit_id": "68ab47e4b4ecc1c4649362b8cc1e49794d1a6537", "target": 1, "func": "static void test_validate_fail_struct_nested(TestInputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    UserDefTwo *udp = NULL;\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string0': 'string0', 'dict1': { 'string1': 'string1', 'dict2': { 'userdef1': { 'integer': 42, 'string': 'string', 'extra': [42, 23, {'foo':'bar'}] }, 'string2': 'string2'}}}\");\n\n\n\n    visit_type_UserDefTwo(v, NULL, &udp, &err);\n\n    error_free_or_abort(&err);\n\n    qapi_free_UserDefTwo(udp);\n\n}\n", "idx": 13734, "_split": "test", "_hash": "3f69582001e4b67e99a920c1093a90de"}
{"project": "qemu", "commit_id": "595ab64169be9063d64c3b1aa1c249fbe2662221", "target": 1, "func": "static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n    ssize_t len;\n\n\n\n    do {\n\n        len = qemu_recv(s->fd, buf, size, 0);\n\n    } while (len == -1 && socket_error() == EINTR);\n\n\n\n    if (len == -1)\n\n        len = -socket_error();\n\n\n\n    return len;\n\n}\n", "idx": 13736, "_split": "test", "_hash": "026a6d4aa9f1fb5e6bca971437ecc3a5"}
{"project": "qemu", "commit_id": "b71706d122838d9656e1a6dae80e22401babdf37", "target": 1, "func": "static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,\n\n                                  size_t *count)\n\n{\n\n    GIOStatus status;\n\n    OVERLAPPED ov = {0};\n\n    BOOL ret;\n\n    DWORD written;\n\n\n\n    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);\n\n    ret = WriteFile(c->handle, buf, size, &written, &ov);\n\n    if (!ret) {\n\n        if (GetLastError() == ERROR_IO_PENDING) {\n\n            /* write is pending */\n\n            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);\n\n            if (!ret) {\n\n                if (!GetLastError()) {\n\n                    status = G_IO_STATUS_AGAIN;\n\n                } else {\n\n                    status = G_IO_STATUS_ERROR;\n\n\n            } else {\n\n                /* write is complete */\n\n                status = G_IO_STATUS_NORMAL;\n\n                *count = written;\n\n\n        } else {\n\n            status = G_IO_STATUS_ERROR;\n\n\n    } else {\n\n        /* write returned immediately */\n\n        status = G_IO_STATUS_NORMAL;\n\n        *count = written;\n\n\n\n\n\n\n\n\n    return status;\n", "idx": 13739, "_split": "test", "_hash": "1847168efbf3a3bcedadb52962c13753"}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void vscsi_command_complete(SCSIBus *bus, int reason, uint32_t tag,\n\n                                   uint32_t arg)\n\n{\n\n    VSCSIState *s = DO_UPCAST(VSCSIState, vdev.qdev, bus->qbus.parent);\n\n    vscsi_req *req = vscsi_find_req(s, tag);\n\n    SCSIDevice *sdev;\n\n    uint8_t *buf;\n\n    int32_t res_in = 0, res_out = 0;\n\n    int len, rc = 0;\n\n\n\n    dprintf(\"VSCSI: SCSI cmd complete, r=0x%x tag=0x%x arg=0x%x, req=%p\\n\",\n\n            reason, tag, arg, req);\n\n    if (req == NULL) {\n\n        fprintf(stderr, \"VSCSI: Can't find request for tag 0x%x\\n\", tag);\n\n        return;\n\n    }\n\n    sdev = req->sdev;\n\n\n\n    if (req->sensing) {\n\n        if (reason == SCSI_REASON_DONE) {\n\n            dprintf(\"VSCSI: Sense done !\\n\");\n\n            vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n            vscsi_put_req(s, req);\n\n        } else {\n\n            uint8_t *buf = sdev->info->get_buf(sdev, tag);\n\n\n\n            len = MIN(arg, SCSI_SENSE_BUF_SIZE);\n\n            dprintf(\"VSCSI: Sense data, %d bytes:\\n\", len);\n\n            dprintf(\"       %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x\\n\",\n\n                    buf[0], buf[1], buf[2], buf[3],\n\n                    buf[4], buf[5], buf[6], buf[7]);\n\n            dprintf(\"       %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x\\n\",\n\n                    buf[8], buf[9], buf[10], buf[11],\n\n                    buf[12], buf[13], buf[14], buf[15]);\n\n            memcpy(req->sense, buf, len);\n\n            req->senselen = len;\n\n            sdev->info->read_data(sdev, req->qtag);\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (reason == SCSI_REASON_DONE) {\n\n        dprintf(\"VSCSI: Command complete err=%d\\n\", arg);\n\n        if (arg == 0) {\n\n            /* We handle overflows, not underflows for normal commands,\n\n             * but hopefully nobody cares\n\n             */\n\n            if (req->writing) {\n\n                res_out = req->data_len;\n\n            } else {\n\n                res_in = req->data_len;\n\n            }\n\n            vscsi_send_rsp(s, req, 0, res_in, res_out);\n\n        } else if (arg == CHECK_CONDITION) {\n\n            dprintf(\"VSCSI: Got CHECK_CONDITION, requesting sense...\\n\");\n\n            vscsi_send_request_sense(s, req);\n\n            return;\n\n        } else {\n\n            vscsi_send_rsp(s, req, arg, 0, 0);\n\n        }\n\n        vscsi_put_req(s, req);\n\n        return;\n\n    }\n\n\n\n    /* \"arg\" is how much we have read for reads and how much we want\n\n     * to write for writes (ie, how much is to be DMA'd)\n\n     */\n\n    if (arg) {\n\n        buf = sdev->info->get_buf(sdev, tag);\n\n        rc = vscsi_srp_transfer_data(s, req, req->writing, buf, arg);\n\n    }\n\n    if (rc < 0) {\n\n        fprintf(stderr, \"VSCSI: RDMA error rc=%d!\\n\", rc);\n\n        sdev->info->cancel_io(sdev, req->qtag);\n\n        vscsi_makeup_sense(s, req, HARDWARE_ERROR, 0, 0);\n\n        vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n        vscsi_put_req(s, req);\n\n        return;\n\n    }\n\n\n\n    /* Start next chunk */\n\n    req->data_len -= rc;\n\n    if (req->writing) {\n\n        sdev->info->write_data(sdev, req->qtag);\n\n    } else {\n\n        sdev->info->read_data(sdev, req->qtag);\n\n    }\n\n}\n", "idx": 13748, "_split": "test", "_hash": "4b0ba977994d3549fe46b374246679f2"}
{"project": "qemu", "commit_id": "7d6250e3d1a145e5427f21f5664995e0056b34a6", "target": 0, "func": "void helper_store_sdr1(CPUPPCState *env, target_ulong val)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n\n\n    if (!env->external_htab) {\n\n        if (env->spr[SPR_SDR1] != val) {\n\n            ppc_store_sdr1(env, val);\n\n            tlb_flush(CPU(cpu));\n\n        }\n\n    }\n\n}\n", "idx": 13754, "_split": "test", "_hash": "e91fff97f8343a5b44a9c2bb8b7f1376"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size, bool is_write)\n\n{\n\n    return (size == 1) || (is_write && size == 2);\n\n}\n", "idx": 13768, "_split": "test", "_hash": "1e66ac666c576ab34440a793dc14eafe"}
{"project": "qemu", "commit_id": "6a81dd172cd5d03fce593741629cb4c78fff10cb", "target": 0, "func": "sPAPRTCETable *spapr_tce_new_table(DeviceState *owner, uint32_t liobn,\n\n                                   uint64_t bus_offset,\n\n                                   uint32_t page_shift,\n\n                                   uint32_t nb_table,\n\n                                   bool vfio_accel)\n\n{\n\n    sPAPRTCETable *tcet;\n\n    char tmp[64];\n\n\n\n    if (spapr_tce_find_by_liobn(liobn)) {\n\n        fprintf(stderr, \"Attempted to create TCE table with duplicate\"\n\n                \" LIOBN 0x%x\\n\", liobn);\n\n        return NULL;\n\n    }\n\n\n\n    if (!nb_table) {\n\n        return NULL;\n\n    }\n\n\n\n    tcet = SPAPR_TCE_TABLE(object_new(TYPE_SPAPR_TCE_TABLE));\n\n    tcet->liobn = liobn;\n\n    tcet->bus_offset = bus_offset;\n\n    tcet->page_shift = page_shift;\n\n    tcet->nb_table = nb_table;\n\n    tcet->vfio_accel = vfio_accel;\n\n\n\n    snprintf(tmp, sizeof(tmp), \"tce-table-%x\", liobn);\n\n    object_property_add_child(OBJECT(owner), tmp, OBJECT(tcet), NULL);\n\n\n\n    object_property_set_bool(OBJECT(tcet), true, \"realized\", NULL);\n\n\n\n    return tcet;\n\n}\n", "idx": 13772, "_split": "test", "_hash": "d5af7ffc01d29c97738ca7a656c9927e"}
{"project": "qemu", "commit_id": "192cf55cc02dc0838bbfa5ac17feb7f6c1651441", "target": 1, "func": "static void debug_print_fis(uint8_t *fis, int cmd_len)\n\n{\n\n#ifdef DEBUG_AHCI\n\n    int i;\n\n\n\n    fprintf(stderr, \"fis:\");\n\n    for (i = 0; i < cmd_len; i++) {\n\n        if ((i & 0xf) == 0) {\n\n            fprintf(stderr, \"\\n%02x:\",i);\n\n        }\n\n        fprintf(stderr, \"%02x \",fis[i]);\n\n    }\n\n    fprintf(stderr, \"\\n\");\n\n#endif\n\n}\n", "idx": 13784, "_split": "test", "_hash": "def735665b5f27e317cc638be9edc1e5"}
{"project": "qemu", "commit_id": "6a2a5aae02b9a0b53807b9ad91f15cd4988781f9", "target": 0, "func": "static void sm501_disp_ctrl_write(void *opaque, hwaddr addr,\n\n                                  uint64_t value, unsigned size)\n\n{\n\n    SM501State *s = (SM501State *)opaque;\n\n    SM501_DPRINTF(\"sm501 disp ctrl regs : write addr=%x, val=%x\\n\",\n\n                  (unsigned)addr, (unsigned)value);\n\n\n\n    switch (addr) {\n\n    case SM501_DC_PANEL_CONTROL:\n\n        s->dc_panel_control = value & 0x0FFF73FF;\n\n        break;\n\n    case SM501_DC_PANEL_PANNING_CONTROL:\n\n        s->dc_panel_panning_control = value & 0xFF3FFF3F;\n\n        break;\n\n    case SM501_DC_PANEL_FB_ADDR:\n\n        s->dc_panel_fb_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_PANEL_FB_OFFSET:\n\n        s->dc_panel_fb_offset = value & 0x3FF03FF0;\n\n        break;\n\n    case SM501_DC_PANEL_FB_WIDTH:\n\n        s->dc_panel_fb_width = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_FB_HEIGHT:\n\n        s->dc_panel_fb_height = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_TL_LOC:\n\n        s->dc_panel_tl_location = value & 0x07FF07FF;\n\n        break;\n\n    case SM501_DC_PANEL_BR_LOC:\n\n        s->dc_panel_br_location = value & 0x07FF07FF;\n\n        break;\n\n\n\n    case SM501_DC_PANEL_H_TOT:\n\n        s->dc_panel_h_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_H_SYNC:\n\n        s->dc_panel_h_sync = value & 0x00FF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_V_TOT:\n\n        s->dc_panel_v_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_V_SYNC:\n\n        s->dc_panel_v_sync = value & 0x003F0FFF;\n\n        break;\n\n\n\n    case SM501_DC_PANEL_HWC_ADDR:\n\n        s->dc_panel_hwc_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_PANEL_HWC_LOC:\n\n        s->dc_panel_hwc_location = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_HWC_COLOR_1_2:\n\n        s->dc_panel_hwc_color_1_2 = value;\n\n        break;\n\n    case SM501_DC_PANEL_HWC_COLOR_3:\n\n        s->dc_panel_hwc_color_3 = value & 0x0000FFFF;\n\n        break;\n\n\n\n    case SM501_DC_CRT_CONTROL:\n\n        s->dc_crt_control = value & 0x0003FFFF;\n\n        break;\n\n    case SM501_DC_CRT_FB_ADDR:\n\n        s->dc_crt_fb_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_CRT_FB_OFFSET:\n\n        s->dc_crt_fb_offset = value & 0x3FF03FF0;\n\n        break;\n\n    case SM501_DC_CRT_H_TOT:\n\n        s->dc_crt_h_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_H_SYNC:\n\n        s->dc_crt_h_sync = value & 0x00FF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_V_TOT:\n\n        s->dc_crt_v_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_V_SYNC:\n\n        s->dc_crt_v_sync = value & 0x003F0FFF;\n\n        break;\n\n\n\n    case SM501_DC_CRT_HWC_ADDR:\n\n        s->dc_crt_hwc_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_CRT_HWC_LOC:\n\n        s->dc_crt_hwc_location = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_HWC_COLOR_1_2:\n\n        s->dc_crt_hwc_color_1_2 = value;\n\n        break;\n\n    case SM501_DC_CRT_HWC_COLOR_3:\n\n        s->dc_crt_hwc_color_3 = value & 0x0000FFFF;\n\n        break;\n\n\n\n    case SM501_DC_PANEL_PALETTE ... SM501_DC_PANEL_PALETTE + 0x400 * 3 - 4:\n\n        sm501_palette_write(opaque, addr - SM501_DC_PANEL_PALETTE, value);\n\n        break;\n\n\n\n    default:\n\n        printf(\"sm501 disp ctrl : not implemented register write.\"\n\n               \" addr=%x, val=%x\\n\", (int)addr, (unsigned)value);\n\n        abort();\n\n    }\n\n}\n", "idx": 13829, "_split": "test", "_hash": "049aa6d0200739479fa10b32c467ff56"}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void xen_ram_init(PCMachineState *pcms,\n\n                         ram_addr_t ram_size, MemoryRegion **ram_memory_p)\n\n{\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    ram_addr_t block_len;\n\n    uint64_t user_lowmem = object_property_get_int(qdev_get_machine(),\n\n                                                   PC_MACHINE_MAX_RAM_BELOW_4G,\n\n                                                   &error_abort);\n\n\n\n    /* Handle the machine opt max-ram-below-4g.  It is basically doing\n\n     * min(xen limit, user limit).\n\n     */\n\n    if (HVM_BELOW_4G_RAM_END <= user_lowmem) {\n\n        user_lowmem = HVM_BELOW_4G_RAM_END;\n\n    }\n\n\n\n    if (ram_size >= user_lowmem) {\n\n        pcms->above_4g_mem_size = ram_size - user_lowmem;\n\n        pcms->below_4g_mem_size = user_lowmem;\n\n    } else {\n\n        pcms->above_4g_mem_size = 0;\n\n        pcms->below_4g_mem_size = ram_size;\n\n    }\n\n    if (!pcms->above_4g_mem_size) {\n\n        block_len = ram_size;\n\n    } else {\n\n        /*\n\n         * Xen does not allocate the memory continuously, it keeps a\n\n         * hole of the size computed above or passed in.\n\n         */\n\n        block_len = (1ULL << 32) + pcms->above_4g_mem_size;\n\n    }\n\n    memory_region_init_ram(&ram_memory, NULL, \"xen.ram\", block_len,\n\n                           &error_abort);\n\n    *ram_memory_p = &ram_memory;\n\n    vmstate_register_ram_global(&ram_memory);\n\n\n\n    memory_region_init_alias(&ram_640k, NULL, \"xen.ram.640k\",\n\n                             &ram_memory, 0, 0xa0000);\n\n    memory_region_add_subregion(sysmem, 0, &ram_640k);\n\n    /* Skip of the VGA IO memory space, it will be registered later by the VGA\n\n     * emulated device.\n\n     *\n\n     * The area between 0xc0000 and 0x100000 will be used by SeaBIOS to load\n\n     * the Options ROM, so it is registered here as RAM.\n\n     */\n\n    memory_region_init_alias(&ram_lo, NULL, \"xen.ram.lo\",\n\n                             &ram_memory, 0xc0000,\n\n                             pcms->below_4g_mem_size - 0xc0000);\n\n    memory_region_add_subregion(sysmem, 0xc0000, &ram_lo);\n\n    if (pcms->above_4g_mem_size > 0) {\n\n        memory_region_init_alias(&ram_hi, NULL, \"xen.ram.hi\",\n\n                                 &ram_memory, 0x100000000ULL,\n\n                                 pcms->above_4g_mem_size);\n\n        memory_region_add_subregion(sysmem, 0x100000000ULL, &ram_hi);\n\n    }\n\n}\n", "idx": 13890, "_split": "test", "_hash": "5552542c2634b477ca720ba3bcb2920e"}
{"project": "qemu", "commit_id": "caae58cba07efec5f0616f568531c9dfaf1e9179", "target": 1, "func": "static void pci_spapr_set_irq(void *opaque, int irq_num, int level)\n\n{\n\n    /*\n\n     * Here we use the number returned by pci_spapr_map_irq to find a\n\n     * corresponding qemu_irq.\n\n     */\n\n    sPAPRPHBState *phb = opaque;\n\n\n\n    trace_spapr_pci_lsi_set(phb->busname, irq_num, phb->lsi_table[irq_num].irq);\n\n    qemu_set_irq(spapr_phb_lsi_qirq(phb, irq_num), level);\n\n}\n", "idx": 13897, "_split": "test", "_hash": "e933e7d6a4c835ce4b6c687d9d8606b4"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void taihu_405ep_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    char *filename;\n\n    qemu_irq *pic;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *bios;\n\n    MemoryRegion *ram_memories = g_malloc(2 * sizeof(*ram_memories));\n\n    MemoryRegion *ram = g_malloc0(sizeof(*ram));\n\n    hwaddr ram_bases[2], ram_sizes[2];\n\n    long bios_size;\n\n    target_ulong kernel_base, initrd_base;\n\n    long kernel_size, initrd_size;\n\n    int linux_boot;\n\n    int fl_idx, fl_sectors;\n\n    DriveInfo *dinfo;\n\n\n\n    /* RAM is soldered to the board so the size cannot be changed */\n\n    ram_size = 0x08000000;\n\n    memory_region_allocate_system_memory(ram, NULL, \"taihu_405ep.ram\",\n\n                                         ram_size);\n\n\n\n    ram_bases[0] = 0;\n\n    ram_sizes[0] = 0x04000000;\n\n    memory_region_init_alias(&ram_memories[0], NULL,\n\n                             \"taihu_405ep.ram-0\", ram, ram_bases[0],\n\n                             ram_sizes[0]);\n\n    ram_bases[1] = 0x04000000;\n\n    ram_sizes[1] = 0x04000000;\n\n    memory_region_init_alias(&ram_memories[1], NULL,\n\n                             \"taihu_405ep.ram-1\", ram, ram_bases[1],\n\n                             ram_sizes[1]);\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register cpu\\n\", __func__);\n\n#endif\n\n    ppc405ep_init(sysmem, ram_memories, ram_bases, ram_sizes,\n\n                  33333333, &pic, kernel_filename == NULL ? 0 : 1);\n\n    /* allocate and load BIOS */\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register BIOS\\n\", __func__);\n\n#endif\n\n    fl_idx = 0;\n\n#if defined(USE_FLASH_BIOS)\n\n    dinfo = drive_get(IF_PFLASH, 0, fl_idx);\n\n    if (dinfo) {\n\n        BlockDriverState *bs = blk_bs(blk_by_legacy_dinfo(dinfo));\n\n\n\n        bios_size = bdrv_getlength(bs);\n\n        /* XXX: should check that size is 2MB */\n\n        //        bios_size = 2 * 1024 * 1024;\n\n        fl_sectors = (bios_size + 65535) >> 16;\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Register parallel flash %d size %lx\"\n\n               \" at addr %lx '%s' %d\\n\",\n\n               fl_idx, bios_size, -bios_size,\n\n               bdrv_get_device_name(bs), fl_sectors);\n\n#endif\n\n        pflash_cfi02_register((uint32_t)(-bios_size),\n\n                              NULL, \"taihu_405ep.bios\", bios_size,\n\n                              bs, 65536, fl_sectors, 1,\n\n                              4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA,\n\n                              1);\n\n        fl_idx++;\n\n    } else\n\n#endif\n\n    {\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Load BIOS from file\\n\");\n\n#endif\n\n        if (bios_name == NULL)\n\n            bios_name = BIOS_FILENAME;\n\n        bios = g_new(MemoryRegion, 1);\n\n        memory_region_init_ram(bios, NULL, \"taihu_405ep.bios\", BIOS_SIZE,\n\n                               &error_abort);\n\n        vmstate_register_ram_global(bios);\n\n        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (filename) {\n\n            bios_size = load_image(filename, memory_region_get_ram_ptr(bios));\n\n            g_free(filename);\n\n            if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n                error_report(\"Could not load PowerPC BIOS '%s'\", bios_name);\n\n                exit(1);\n\n            }\n\n            bios_size = (bios_size + 0xfff) & ~0xfff;\n\n            memory_region_add_subregion(sysmem, (uint32_t)(-bios_size), bios);\n\n        } else if (!qtest_enabled()) {\n\n            error_report(\"Could not load PowerPC BIOS '%s'\", bios_name);\n\n            exit(1);\n\n        }\n\n        memory_region_set_readonly(bios, true);\n\n    }\n\n    /* Register Linux flash */\n\n    dinfo = drive_get(IF_PFLASH, 0, fl_idx);\n\n    if (dinfo) {\n\n        BlockDriverState *bs = blk_bs(blk_by_legacy_dinfo(dinfo));\n\n\n\n        bios_size = bdrv_getlength(bs);\n\n        /* XXX: should check that size is 32MB */\n\n        bios_size = 32 * 1024 * 1024;\n\n        fl_sectors = (bios_size + 65535) >> 16;\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Register parallel flash %d size %lx\"\n\n               \" at addr \" TARGET_FMT_lx \" '%s'\\n\",\n\n               fl_idx, bios_size, (target_ulong)0xfc000000,\n\n               bdrv_get_device_name(bs));\n\n#endif\n\n        pflash_cfi02_register(0xfc000000, NULL, \"taihu_405ep.flash\", bios_size,\n\n                              bs, 65536, fl_sectors, 1,\n\n                              4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA,\n\n                              1);\n\n        fl_idx++;\n\n    }\n\n    /* Register CLPD & LCD display */\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register CPLD\\n\", __func__);\n\n#endif\n\n    taihu_cpld_init(sysmem, 0x50100000);\n\n    /* Load kernel */\n\n    linux_boot = (kernel_filename != NULL);\n\n    if (linux_boot) {\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"%s: load kernel\\n\", __func__);\n\n#endif\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* now we can load the kernel */\n\n        kernel_size = load_image_targphys(kernel_filename, kernel_base,\n\n                                          ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr,\n\n                        \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n    }\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: Done\\n\", __func__);\n\n#endif\n\n}\n", "idx": 13951, "_split": "test", "_hash": "c8dac0188ae4b1e63328a4d3f27774ac"}
{"project": "qemu", "commit_id": "2886be1b01c274570fa139748a402207482405bd", "target": 1, "func": "static void pm_ioport_read(IORange *ioport, uint64_t addr, unsigned width,\n\n                            uint64_t *data)\n\n{\n\n    PIIX4PMState *s = container_of(ioport, PIIX4PMState, ioport);\n\n    uint32_t val;\n\n\n\n    switch(addr) {\n\n    case 0x00:\n\n        val = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);\n\n        break;\n\n    case 0x02:\n\n        val = s->ar.pm1.evt.en;\n\n        break;\n\n    case 0x04:\n\n        val = s->ar.pm1.cnt.cnt;\n\n        break;\n\n    case 0x08:\n\n        val = acpi_pm_tmr_get(&s->ar);\n\n        break;\n\n    default:\n\n        val = 0;\n\n        break;\n\n    }\n\n    PIIX4_DPRINTF(\"PM readw port=0x%04x val=0x%04x\\n\", (unsigned int)addr, val);\n\n    *data = val;\n\n}\n", "idx": 13988, "_split": "test", "_hash": "51f924d64cde9c10e4d784b7eea617e0"}
{"project": "qemu", "commit_id": "01b05c66a3616d5a4adc39fc90962e9efaf791d1", "target": 1, "func": "int nbd_receive_reply(QIOChannel *ioc, NBDReply *reply, Error **errp)\n\n{\n\n    int ret;\n\n    const char *type;\n\n\n\n    ret = nbd_read_eof(ioc, &reply->magic, sizeof(reply->magic), errp);\n\n    if (ret <= 0) {\n\n        return ret;\n\n    }\n\n\n\n    be32_to_cpus(&reply->magic);\n\n\n\n    switch (reply->magic) {\n\n    case NBD_SIMPLE_REPLY_MAGIC:\n\n        ret = nbd_receive_simple_reply(ioc, &reply->simple, errp);\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n\n\n        trace_nbd_receive_simple_reply(reply->simple.error,\n\n                                       nbd_err_lookup(reply->simple.error),\n\n                                       reply->handle);\n\n        if (reply->simple.error == NBD_ESHUTDOWN) {\n\n            /* This works even on mingw which lacks a native ESHUTDOWN */\n\n            error_setg(errp, \"server shutting down\");\n\n            return -EINVAL;\n\n        }\n\n        break;\n\n    case NBD_STRUCTURED_REPLY_MAGIC:\n\n        ret = nbd_receive_structured_reply_chunk(ioc, &reply->structured, errp);\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n        type = nbd_reply_type_lookup(reply->structured.type);\n\n        trace_nbd_receive_structured_reply_chunk(reply->structured.flags,\n\n                                                 reply->structured.type, type,\n\n                                                 reply->structured.handle,\n\n                                                 reply->structured.length);\n\n        break;\n\n    default:\n\n        error_setg(errp, \"invalid magic (got 0x%\" PRIx32 \")\", reply->magic);\n\n        return -EINVAL;\n\n    }\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 14022, "_split": "test", "_hash": "268229a8aba3efdcc510d750b06090bc"}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static void ne2000_receive(void *opaque, const uint8_t *buf, int size)\n\n{\n\n    NE2000State *s = opaque;\n\n    uint8_t *p;\n\n    int total_len, next, avail, len, index, mcast_idx;\n\n    uint8_t buf1[60];\n\n    static const uint8_t broadcast_macaddr[6] = \n\n        { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n    \n\n#if defined(DEBUG_NE2000)\n\n    printf(\"NE2000: received len=%d\\n\", size);\n\n#endif\n\n\n\n    if (!ne2000_can_receive(s))\n\n        return;\n\n    \n\n    /* XXX: check this */\n\n    if (s->rxcr & 0x10) {\n\n        /* promiscuous: receive all */\n\n    } else {\n\n        if (!memcmp(buf,  broadcast_macaddr, 6)) {\n\n            /* broadcast address */\n\n            if (!(s->rxcr & 0x04))\n\n                return;\n\n        } else if (buf[0] & 0x01) {\n\n            /* multicast */\n\n            if (!(s->rxcr & 0x08))\n\n                return;\n\n            mcast_idx = compute_mcast_idx(buf);\n\n            if (!(s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7))))\n\n                return;\n\n        } else if (s->mem[0] == buf[0] &&\n\n                   s->mem[2] == buf[1] &&                   \n\n                   s->mem[4] == buf[2] &&            \n\n                   s->mem[6] == buf[3] &&            \n\n                   s->mem[8] == buf[4] &&            \n\n                   s->mem[10] == buf[5]) {\n\n            /* match */\n\n        } else {\n\n            return;\n\n        }\n\n    }\n\n\n\n\n\n    /* if too small buffer, then expand it */\n\n    if (size < MIN_BUF_SIZE) {\n\n        memcpy(buf1, buf, size);\n\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n\n        buf = buf1;\n\n        size = MIN_BUF_SIZE;\n\n    }\n\n\n\n    index = s->curpag << 8;\n\n    /* 4 bytes for header */\n\n    total_len = size + 4;\n\n    /* address for next packet (4 bytes for CRC) */\n\n    next = index + ((total_len + 4 + 255) & ~0xff);\n\n    if (next >= s->stop)\n\n        next -= (s->stop - s->start);\n\n    /* prepare packet header */\n\n    p = s->mem + index;\n\n    s->rsr = ENRSR_RXOK; /* receive status */\n\n    /* XXX: check this */\n\n    if (buf[0] & 0x01)\n\n        s->rsr |= ENRSR_PHY;\n\n    p[0] = s->rsr;\n\n    p[1] = next >> 8;\n\n    p[2] = total_len;\n\n    p[3] = total_len >> 8;\n\n    index += 4;\n\n\n\n    /* write packet data */\n\n    while (size > 0) {\n\n        avail = s->stop - index;\n\n        len = size;\n\n        if (len > avail)\n\n            len = avail;\n\n        memcpy(s->mem + index, buf, len);\n\n        buf += len;\n\n        index += len;\n\n        if (index == s->stop)\n\n            index = s->start;\n\n        size -= len;\n\n    }\n\n    s->curpag = next >> 8;\n\n\n\n    /* now we can signal we have receive something */\n\n    s->isr |= ENISR_RX;\n\n    ne2000_update_irq(s);\n\n}\n", "idx": 14023, "_split": "test", "_hash": "5c0b7213708a82f04d9216a77eef2124"}
{"project": "qemu", "commit_id": "ad2d30f79d3b0812f02c741be2189796b788d6d7", "target": 1, "func": "static void scsi_disk_purge_requests(SCSIDiskState *s)\n\n{\n\n    SCSIDiskReq *r;\n\n\n\n    while (!QTAILQ_EMPTY(&s->qdev.requests)) {\n\n        r = DO_UPCAST(SCSIDiskReq, req, QTAILQ_FIRST(&s->qdev.requests));\n\n        if (r->req.aiocb) {\n\n            bdrv_aio_cancel(r->req.aiocb);\n\n        }\n\n        scsi_remove_request(r);\n\n    }\n\n}\n", "idx": 14025, "_split": "test", "_hash": "4f32a620a179d2a0daf10cebd0a2d000"}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static int net_slirp_init(VLANState *vlan)\n\n{\n\n    if (!slirp_inited) {\n\n        slirp_inited = 1;\n\n        slirp_init();\n\n    }\n\n    slirp_vc = qemu_new_vlan_client(vlan, \n\n                                    slirp_receive, NULL);\n\n    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), \"user redirector\");\n\n    return 0;\n\n}\n", "idx": 14031, "_split": "test", "_hash": "d7077085df208ddf6defa006e61b3a94"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,\n\n                            int len, int is_write)\n\n{\n\n    return address_space_rw(&address_space_memory, addr, buf, len, is_write);\n\n}\n", "idx": 14076, "_split": "test", "_hash": "7cf680d2428e996c77adb576d2712879"}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_link(void *opaque)\n\n{\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n    int32_t dfid, oldfid;\n\n    V9fsFidState *dfidp, *oldfidp;\n\n    V9fsString name;\n\n    size_t offset = 7;\n\n    int err = 0;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n\n\n\n    dfidp = get_fid(pdu, dfid);\n\n    if (dfidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n\n\n    oldfidp = get_fid(pdu, oldfid);\n\n    if (oldfidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out;\n\n    }\n\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n\n    if (!err) {\n\n        err = offset;\n\n    }\n\nout:\n\n    put_fid(pdu, dfidp);\n\nout_nofid:\n\n    v9fs_string_free(&name);\n\n    complete_pdu(s, pdu, err);\n\n}\n", "idx": 14090, "_split": "test", "_hash": "17ce4e151c6bd7912f2b222bb529dac4"}
{"project": "qemu", "commit_id": "d4cd45028898a37afb45fb449954115b4960d4e9", "target": 0, "func": "static XenPTBarFlag xen_pt_bar_reg_parse(XenPCIPassthroughState *s,\n\n                                         XenPTRegInfo *reg)\n\n{\n\n    PCIDevice *d = &s->dev;\n\n    XenPTRegion *region = NULL;\n\n    PCIIORegion *r;\n\n    int index = 0;\n\n\n\n    /* check 64bit BAR */\n\n    index = xen_pt_bar_offset_to_index(reg->offset);\n\n    if ((0 < index) && (index < PCI_ROM_SLOT)) {\n\n        int type = s->real_device.io_regions[index - 1].type;\n\n\n\n        if ((type & XEN_HOST_PCI_REGION_TYPE_MEM)\n\n            && (type & XEN_HOST_PCI_REGION_TYPE_MEM_64)) {\n\n            region = &s->bases[index - 1];\n\n            if (region->bar_flag != XEN_PT_BAR_FLAG_UPPER) {\n\n                return XEN_PT_BAR_FLAG_UPPER;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* check unused BAR */\n\n    r = &d->io_regions[index];\n\n    if (!xen_pt_get_bar_size(r)) {\n\n        return XEN_PT_BAR_FLAG_UNUSED;\n\n    }\n\n\n\n    /* for ExpROM BAR */\n\n    if (index == PCI_ROM_SLOT) {\n\n        return XEN_PT_BAR_FLAG_MEM;\n\n    }\n\n\n\n    /* check BAR I/O indicator */\n\n    if (s->real_device.io_regions[index].type & XEN_HOST_PCI_REGION_TYPE_IO) {\n\n        return XEN_PT_BAR_FLAG_IO;\n\n    } else {\n\n        return XEN_PT_BAR_FLAG_MEM;\n\n    }\n\n}\n", "idx": 14126, "_split": "test", "_hash": "43a726b147aceced956feda299f87a2a"}
{"project": "qemu", "commit_id": "788d2599def0e26d92802593b07ec76e8701ccce", "target": 1, "func": "static void spapr_phb_hot_plug_child(HotplugHandler *plug_handler,\n\n                                     DeviceState *plugged_dev, Error **errp)\n\n{\n\n    sPAPRPHBState *phb = SPAPR_PCI_HOST_BRIDGE(DEVICE(plug_handler));\n\n    PCIDevice *pdev = PCI_DEVICE(plugged_dev);\n\n    sPAPRDRConnector *drc = spapr_phb_get_pci_drc(phb, pdev);\n\n    Error *local_err = NULL;\n\n\n\n    /* if DR is disabled we don't need to do anything in the case of\n\n     * hotplug or coldplug callbacks\n\n     */\n\n    if (!phb->dr_enabled) {\n\n        /* if this is a hotplug operation initiated by the user\n\n         * we need to let them know it's not enabled\n\n         */\n\n        if (plugged_dev->hotplugged) {\n\n            error_setg(errp, QERR_BUS_NO_HOTPLUG,\n\n                       object_get_typename(OBJECT(phb)));\n\n        }\n\n        return;\n\n    }\n\n\n\n    g_assert(drc);\n\n\n\n    spapr_phb_add_pci_device(drc, phb, pdev, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    if (plugged_dev->hotplugged) {\n\n        spapr_hotplug_req_add_by_index(drc);\n\n    }\n\n}\n", "idx": 14162, "_split": "test", "_hash": "78760b7b3010311d6a768ba299e960f8"}
{"project": "qemu", "commit_id": "6750e795b167e3defab36502e61b8c57ede119eb", "target": 0, "func": "static int add_old_style_options(const char *fmt, QemuOpts *opts,\n\n                                 const char *base_filename,\n\n                                 const char *base_fmt)\n\n{\n\n    if (base_filename) {\n\n        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {\n\n            error_report(\"Backing file not supported for file format '%s'\",\n\n                         fmt);\n\n            return -1;\n\n        }\n\n    }\n\n    if (base_fmt) {\n\n        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {\n\n            error_report(\"Backing file format not supported for file \"\n\n                         \"format '%s'\", fmt);\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 14220, "_split": "test", "_hash": "6c4fe80db3d031d1750c2ca6be7e771c"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_flush_queued_packets(VLANClientState *vc)\n\n{\n\n    while (!TAILQ_EMPTY(&vc->vlan->send_queue)) {\n\n        VLANPacket *packet;\n\n        int ret;\n\n\n\n        packet = TAILQ_FIRST(&vc->vlan->send_queue);\n\n        TAILQ_REMOVE(&vc->vlan->send_queue, packet, entry);\n\n\n\n        ret = qemu_deliver_packet(packet->sender, packet->data, packet->size);\n\n        if (ret == 0 && packet->sent_cb != NULL) {\n\n            TAILQ_INSERT_HEAD(&vc->vlan->send_queue, packet, entry);\n\n            break;\n\n        }\n\n\n\n        if (packet->sent_cb)\n\n            packet->sent_cb(packet->sender, ret);\n\n\n\n        qemu_free(packet);\n\n    }\n\n}\n", "idx": 14228, "_split": "test", "_hash": "9bf1a2612042d0ac6c2e95ed1039c5fa"}
{"project": "qemu", "commit_id": "1a9353d258aba69afd8a389bf5fb705caab12ce0", "target": 0, "func": "long do_syscall(void *cpu_env, int num, long arg1, long arg2, long arg3, \n\n                long arg4, long arg5, long arg6)\n\n{\n\n    long ret;\n\n    struct stat st;\n\n    struct kernel_statfs *stfs;\n\n    \n\n#ifdef DEBUG\n\n    gemu_log(\"syscall %d\\n\", num);\n\n#endif\n\n    switch(num) {\n\n    case TARGET_NR_exit:\n\n#ifdef HAVE_GPROF\n\n        _mcleanup();\n\n#endif\n\n        _exit(arg1);\n\n        ret = 0; /* avoid warning */\n\n        break;\n\n    case TARGET_NR_read:\n\n        ret = get_errno(read(arg1, (void *)arg2, arg3));\n\n        break;\n\n    case TARGET_NR_write:\n\n        ret = get_errno(write(arg1, (void *)arg2, arg3));\n\n        break;\n\n    case TARGET_NR_open:\n\n        ret = get_errno(open((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_close:\n\n        ret = get_errno(close(arg1));\n\n        break;\n\n    case TARGET_NR_brk:\n\n        ret = do_brk((char *)arg1);\n\n        break;\n\n    case TARGET_NR_fork:\n\n        ret = get_errno(fork());\n\n        break;\n\n    case TARGET_NR_waitpid:\n\n        {\n\n            int *status = (int *)arg2;\n\n            ret = get_errno(waitpid(arg1, status, arg3));\n\n            if (!is_error(ret) && status)\n\n                tswapls((long *)&status);\n\n        }\n\n        break;\n\n    case TARGET_NR_creat:\n\n        ret = get_errno(creat((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_link:\n\n        ret = get_errno(link((const char *)arg1, (const char *)arg2));\n\n        break;\n\n    case TARGET_NR_unlink:\n\n        ret = get_errno(unlink((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_execve:\n\n        ret = get_errno(execve((const char *)arg1, (void *)arg2, (void *)arg3));\n\n        break;\n\n    case TARGET_NR_chdir:\n\n        ret = get_errno(chdir((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_time:\n\n        {\n\n            int *time_ptr = (int *)arg1;\n\n            ret = get_errno(time((time_t *)time_ptr));\n\n            if (!is_error(ret) && time_ptr)\n\n                tswap32s(time_ptr);\n\n        }\n\n        break;\n\n    case TARGET_NR_mknod:\n\n        ret = get_errno(mknod((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_chmod:\n\n        ret = get_errno(chmod((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_lchown:\n\n        ret = get_errno(chown((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_break:\n\n        goto unimplemented;\n\n    case TARGET_NR_oldstat:\n\n        goto unimplemented;\n\n    case TARGET_NR_lseek:\n\n        ret = get_errno(lseek(arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_getpid:\n\n        ret = get_errno(getpid());\n\n        break;\n\n    case TARGET_NR_mount:\n\n        /* need to look at the data field */\n\n        goto unimplemented;\n\n    case TARGET_NR_umount:\n\n        ret = get_errno(umount((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_setuid:\n\n        ret = get_errno(setuid(arg1));\n\n        break;\n\n    case TARGET_NR_getuid:\n\n        ret = get_errno(getuid());\n\n        break;\n\n    case TARGET_NR_stime:\n\n        {\n\n            int *time_ptr = (int *)arg1;\n\n            if (time_ptr)\n\n                tswap32s(time_ptr);\n\n            ret = get_errno(stime((time_t *)time_ptr));\n\n        }\n\n        break;\n\n    case TARGET_NR_ptrace:\n\n        goto unimplemented;\n\n    case TARGET_NR_alarm:\n\n        ret = alarm(arg1);\n\n        break;\n\n    case TARGET_NR_oldfstat:\n\n        goto unimplemented;\n\n    case TARGET_NR_pause:\n\n        ret = get_errno(pause());\n\n        break;\n\n    case TARGET_NR_utime:\n\n        goto unimplemented;\n\n    case TARGET_NR_stty:\n\n        goto unimplemented;\n\n    case TARGET_NR_gtty:\n\n        goto unimplemented;\n\n    case TARGET_NR_access:\n\n        ret = get_errno(access((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_nice:\n\n        ret = get_errno(nice(arg1));\n\n        break;\n\n    case TARGET_NR_ftime:\n\n        goto unimplemented;\n\n    case TARGET_NR_sync:\n\n        ret = get_errno(sync());\n\n        break;\n\n    case TARGET_NR_kill:\n\n        ret = get_errno(kill(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_rename:\n\n        ret = get_errno(rename((const char *)arg1, (const char *)arg2));\n\n        break;\n\n    case TARGET_NR_mkdir:\n\n        ret = get_errno(mkdir((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_rmdir:\n\n        ret = get_errno(rmdir((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_dup:\n\n        ret = get_errno(dup(arg1));\n\n        break;\n\n    case TARGET_NR_pipe:\n\n        {\n\n            int *pipe_ptr = (int *)arg1;\n\n            ret = get_errno(pipe(pipe_ptr));\n\n            if (!is_error(ret)) {\n\n                tswap32s(&pipe_ptr[0]);\n\n                tswap32s(&pipe_ptr[1]);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_times:\n\n        goto unimplemented;\n\n    case TARGET_NR_prof:\n\n        goto unimplemented;\n\n    case TARGET_NR_setgid:\n\n        ret = get_errno(setgid(arg1));\n\n        break;\n\n    case TARGET_NR_getgid:\n\n        ret = get_errno(getgid());\n\n        break;\n\n    case TARGET_NR_signal:\n\n        goto unimplemented;\n\n    case TARGET_NR_geteuid:\n\n        ret = get_errno(geteuid());\n\n        break;\n\n    case TARGET_NR_getegid:\n\n        ret = get_errno(getegid());\n\n        break;\n\n    case TARGET_NR_acct:\n\n        goto unimplemented;\n\n    case TARGET_NR_umount2:\n\n        ret = get_errno(umount2((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_lock:\n\n        goto unimplemented;\n\n    case TARGET_NR_ioctl:\n\n        ret = do_ioctl(arg1, arg2, arg3);\n\n        break;\n\n    case TARGET_NR_fcntl:\n\n        switch(arg2) {\n\n        case F_GETLK:\n\n        case F_SETLK:\n\n        case F_SETLKW:\n\n            goto unimplemented;\n\n        default:\n\n            ret = get_errno(fcntl(arg1, arg2, arg3));\n\n            break;\n\n        }\n\n        break;\n\n    case TARGET_NR_mpx:\n\n        goto unimplemented;\n\n    case TARGET_NR_setpgid:\n\n        ret = get_errno(setpgid(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_ulimit:\n\n        goto unimplemented;\n\n    case TARGET_NR_oldolduname:\n\n        goto unimplemented;\n\n    case TARGET_NR_umask:\n\n        ret = get_errno(umask(arg1));\n\n        break;\n\n    case TARGET_NR_chroot:\n\n        ret = get_errno(chroot((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_ustat:\n\n        goto unimplemented;\n\n    case TARGET_NR_dup2:\n\n        ret = get_errno(dup2(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_getppid:\n\n        ret = get_errno(getppid());\n\n        break;\n\n    case TARGET_NR_getpgrp:\n\n        ret = get_errno(getpgrp());\n\n        break;\n\n    case TARGET_NR_setsid:\n\n        ret = get_errno(setsid());\n\n        break;\n\n    case TARGET_NR_sigaction:\n\n#if 0\n\n        {\n\n            int signum = arg1;\n\n            struct target_old_sigaction *tact = arg2, *toldact = arg3;\n\n            ret = get_errno(setsid());\n\n            \n\n\n\n        }\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sgetmask:\n\n        goto unimplemented;\n\n    case TARGET_NR_ssetmask:\n\n        goto unimplemented;\n\n    case TARGET_NR_setreuid:\n\n        ret = get_errno(setreuid(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setregid:\n\n        ret = get_errno(setregid(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_sigsuspend:\n\n        goto unimplemented;\n\n    case TARGET_NR_sigpending:\n\n        goto unimplemented;\n\n    case TARGET_NR_sethostname:\n\n        ret = get_errno(sethostname((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setrlimit:\n\n        goto unimplemented;\n\n    case TARGET_NR_getrlimit:\n\n        goto unimplemented;\n\n    case TARGET_NR_getrusage:\n\n        goto unimplemented;\n\n    case TARGET_NR_gettimeofday:\n\n        {\n\n            struct target_timeval *target_tv = (void *)arg1;\n\n            struct timeval tv;\n\n            ret = get_errno(gettimeofday(&tv, NULL));\n\n            if (!is_error(ret)) {\n\n                target_tv->tv_sec = tswapl(tv.tv_sec);\n\n                target_tv->tv_usec = tswapl(tv.tv_usec);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_settimeofday:\n\n        {\n\n            struct target_timeval *target_tv = (void *)arg1;\n\n            struct timeval tv;\n\n            tv.tv_sec = tswapl(target_tv->tv_sec);\n\n            tv.tv_usec = tswapl(target_tv->tv_usec);\n\n            ret = get_errno(settimeofday(&tv, NULL));\n\n        }\n\n        break;\n\n    case TARGET_NR_getgroups:\n\n        goto unimplemented;\n\n    case TARGET_NR_setgroups:\n\n        goto unimplemented;\n\n    case TARGET_NR_select:\n\n        goto unimplemented;\n\n    case TARGET_NR_symlink:\n\n        ret = get_errno(symlink((const char *)arg1, (const char *)arg2));\n\n        break;\n\n    case TARGET_NR_oldlstat:\n\n        goto unimplemented;\n\n    case TARGET_NR_readlink:\n\n        ret = get_errno(readlink((const char *)arg1, (char *)arg2, arg3));\n\n        break;\n\n    case TARGET_NR_uselib:\n\n        goto unimplemented;\n\n    case TARGET_NR_swapon:\n\n        ret = get_errno(swapon((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_reboot:\n\n        goto unimplemented;\n\n    case TARGET_NR_readdir:\n\n        goto unimplemented;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_mmap:\n\n        {\n\n            uint32_t v1, v2, v3, v4, v5, v6, *vptr;\n\n            vptr = (uint32_t *)arg1;\n\n            v1 = tswap32(vptr[0]);\n\n            v2 = tswap32(vptr[1]);\n\n            v3 = tswap32(vptr[2]);\n\n            v4 = tswap32(vptr[3]);\n\n            v5 = tswap32(vptr[4]);\n\n            v6 = tswap32(vptr[5]);\n\n            ret = get_errno((long)mmap((void *)v1, v2, v3, v4, v5, v6));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_mmap2:\n\n#else\n\n    case TARGET_NR_mmap:\n\n#endif\n\n        ret = get_errno((long)mmap((void *)arg1, arg2, arg3, arg4, arg5, arg6));\n\n        break;\n\n    case TARGET_NR_munmap:\n\n        ret = get_errno(munmap((void *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_truncate:\n\n        ret = get_errno(truncate((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_ftruncate:\n\n        ret = get_errno(ftruncate(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchmod:\n\n        ret = get_errno(fchmod(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchown:\n\n        ret = get_errno(fchown(arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_getpriority:\n\n        ret = get_errno(getpriority(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setpriority:\n\n        ret = get_errno(setpriority(arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_profil:\n\n        goto unimplemented;\n\n    case TARGET_NR_statfs:\n\n        stfs = (void *)arg2;\n\n        ret = get_errno(sys_statfs((const char *)arg1, stfs));\n\n    convert_statfs:\n\n        if (!is_error(ret)) {\n\n            tswap32s(&stfs->f_type);\n\n            tswap32s(&stfs->f_bsize);\n\n            tswap32s(&stfs->f_blocks);\n\n            tswap32s(&stfs->f_bfree);\n\n            tswap32s(&stfs->f_bavail);\n\n            tswap32s(&stfs->f_files);\n\n            tswap32s(&stfs->f_ffree);\n\n            tswap32s(&stfs->f_fsid.val[0]);\n\n            tswap32s(&stfs->f_fsid.val[1]);\n\n            tswap32s(&stfs->f_namelen);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs:\n\n        stfs = (void *)arg2;\n\n        ret = get_errno(sys_fstatfs(arg1, stfs));\n\n        goto convert_statfs;\n\n    case TARGET_NR_ioperm:\n\n        goto unimplemented;\n\n    case TARGET_NR_socketcall:\n\n        ret = do_socketcall(arg1, (long *)arg2);\n\n        break;\n\n    case TARGET_NR_syslog:\n\n        goto unimplemented;\n\n    case TARGET_NR_setitimer:\n\n        goto unimplemented;\n\n    case TARGET_NR_getitimer:\n\n        goto unimplemented;\n\n    case TARGET_NR_stat:\n\n        ret = get_errno(stat((const char *)arg1, &st));\n\n        goto do_stat;\n\n    case TARGET_NR_lstat:\n\n        ret = get_errno(lstat((const char *)arg1, &st));\n\n        goto do_stat;\n\n    case TARGET_NR_fstat:\n\n        {\n\n            ret = get_errno(fstat(arg1, &st));\n\n        do_stat:\n\n            if (!is_error(ret)) {\n\n                struct target_stat *target_st = (void *)arg2;\n\n                target_st->st_dev = tswap16(st.st_dev);\n\n                target_st->st_ino = tswapl(st.st_ino);\n\n                target_st->st_mode = tswap16(st.st_mode);\n\n                target_st->st_nlink = tswap16(st.st_nlink);\n\n                target_st->st_uid = tswap16(st.st_uid);\n\n                target_st->st_gid = tswap16(st.st_gid);\n\n                target_st->st_rdev = tswap16(st.st_rdev);\n\n                target_st->st_size = tswapl(st.st_size);\n\n                target_st->st_blksize = tswapl(st.st_blksize);\n\n                target_st->st_blocks = tswapl(st.st_blocks);\n\n                target_st->st_atime = tswapl(st.st_atime);\n\n                target_st->st_mtime = tswapl(st.st_mtime);\n\n                target_st->st_ctime = tswapl(st.st_ctime);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_olduname:\n\n        goto unimplemented;\n\n    case TARGET_NR_iopl:\n\n        goto unimplemented;\n\n    case TARGET_NR_vhangup:\n\n        ret = get_errno(vhangup());\n\n        break;\n\n    case TARGET_NR_idle:\n\n        goto unimplemented;\n\n    case TARGET_NR_vm86old:\n\n        goto unimplemented;\n\n    case TARGET_NR_wait4:\n\n        {\n\n            int status;\n\n            target_long *status_ptr = (void *)arg2;\n\n            struct rusage rusage, *rusage_ptr;\n\n            struct target_rusage *target_rusage = (void *)arg4;\n\n            if (target_rusage)\n\n                rusage_ptr = &rusage;\n\n            else\n\n                rusage_ptr = NULL;\n\n            ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr));\n\n            if (!is_error(ret)) {\n\n                if (status_ptr)\n\n                    *status_ptr = tswap32(status);\n\n                if (target_rusage) {\n\n                    target_rusage->ru_utime.tv_sec = tswapl(rusage.ru_utime.tv_sec);\n\n                    target_rusage->ru_utime.tv_usec = tswapl(rusage.ru_utime.tv_usec);\n\n                    target_rusage->ru_stime.tv_sec = tswapl(rusage.ru_stime.tv_sec);\n\n                    target_rusage->ru_stime.tv_usec = tswapl(rusage.ru_stime.tv_usec);\n\n                    target_rusage->ru_maxrss = tswapl(rusage.ru_maxrss);\n\n                    target_rusage->ru_ixrss = tswapl(rusage.ru_ixrss);\n\n                    target_rusage->ru_idrss = tswapl(rusage.ru_idrss);\n\n                    target_rusage->ru_isrss = tswapl(rusage.ru_isrss);\n\n                    target_rusage->ru_minflt = tswapl(rusage.ru_minflt);\n\n                    target_rusage->ru_majflt = tswapl(rusage.ru_majflt);\n\n                    target_rusage->ru_nswap = tswapl(rusage.ru_nswap);\n\n                    target_rusage->ru_inblock = tswapl(rusage.ru_inblock);\n\n                    target_rusage->ru_oublock = tswapl(rusage.ru_oublock);\n\n                    target_rusage->ru_msgsnd = tswapl(rusage.ru_msgsnd);\n\n                    target_rusage->ru_msgrcv = tswapl(rusage.ru_msgrcv);\n\n                    target_rusage->ru_nsignals = tswapl(rusage.ru_nsignals);\n\n                    target_rusage->ru_nvcsw = tswapl(rusage.ru_nvcsw);\n\n                    target_rusage->ru_nivcsw = tswapl(rusage.ru_nivcsw);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_swapoff:\n\n        ret = get_errno(swapoff((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_sysinfo:\n\n        goto unimplemented;\n\n    case TARGET_NR_ipc:\n\n        goto unimplemented;\n\n    case TARGET_NR_fsync:\n\n        ret = get_errno(fsync(arg1));\n\n        break;\n\n    case TARGET_NR_sigreturn:\n\n        goto unimplemented;\n\n    case TARGET_NR_clone:\n\n        goto unimplemented;\n\n    case TARGET_NR_setdomainname:\n\n        ret = get_errno(setdomainname((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_uname:\n\n        /* no need to transcode because we use the linux syscall */\n\n        ret = get_errno(sys_uname((struct new_utsname *)arg1));\n\n        break;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_modify_ldt:\n\n        ret = get_errno(gemu_modify_ldt(cpu_env, arg1, (void *)arg2, arg3));\n\n        break;\n\n#endif\n\n    case TARGET_NR_adjtimex:\n\n        goto unimplemented;\n\n    case TARGET_NR_mprotect:\n\n        ret = get_errno(mprotect((void *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n            target_ulong *pset = (void *)arg2, *poldset = (void *)arg3;\n\n            \n\n            switch(how) {\n\n            case TARGET_SIG_BLOCK:\n\n                how = SIG_BLOCK;\n\n                break;\n\n            case TARGET_SIG_UNBLOCK:\n\n                how = SIG_UNBLOCK;\n\n                break;\n\n            case TARGET_SIG_SETMASK:\n\n                how = SIG_SETMASK;\n\n                break;\n\n            default:\n\n                ret = -EINVAL;\n\n                goto fail;\n\n            }\n\n            \n\n            if (pset) {\n\n                target_to_host_old_sigset(&set, pset);\n\n                set_ptr = &set;\n\n            } else {\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(arg1, set_ptr, &oldset));\n\n            if (!is_error(ret) && poldset) {\n\n                host_to_target_old_sigset(poldset, &oldset);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_create_module:\n\n    case TARGET_NR_init_module:\n\n    case TARGET_NR_delete_module:\n\n    case TARGET_NR_get_kernel_syms:\n\n        goto unimplemented;\n\n    case TARGET_NR_quotactl:\n\n        goto unimplemented;\n\n    case TARGET_NR_getpgid:\n\n        ret = get_errno(getpgid(arg1));\n\n        break;\n\n    case TARGET_NR_fchdir:\n\n        ret = get_errno(fchdir(arg1));\n\n        break;\n\n    case TARGET_NR_bdflush:\n\n        goto unimplemented;\n\n    case TARGET_NR_sysfs:\n\n        goto unimplemented;\n\n    case TARGET_NR_personality:\n\n        ret = get_errno(mprotect((void *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_afs_syscall:\n\n        goto unimplemented;\n\n    case TARGET_NR_setfsuid:\n\n        goto unimplemented;\n\n    case TARGET_NR_setfsgid:\n\n        goto unimplemented;\n\n    case TARGET_NR__llseek:\n\n        {\n\n            int64_t res;\n\n            ret = get_errno(_llseek(arg1, arg2, arg3, &res, arg5));\n\n            *(int64_t *)arg4 = tswap64(res);\n\n        }\n\n        break;\n\n    case TARGET_NR_getdents:\n\n#if TARGET_LONG_SIZE != 4\n\n#error not supported\n\n#endif\n\n        {\n\n            struct dirent *dirp = (void *)arg2;\n\n            long count = arg3;\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct dirent *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = tswap16(de->d_reclen);\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = reclen;\n\n                    tswapls(&de->d_ino);\n\n                    tswapls(&de->d_off);\n\n                    de = (struct dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR__newselect:\n\n        ret = do_select(arg1, (void *)arg2, (void *)arg3, (void *)arg4, \n\n                        (void *)arg5);\n\n        break;\n\n    case TARGET_NR_flock:\n\n        goto unimplemented;\n\n    case TARGET_NR_msync:\n\n        ret = get_errno(msync((void *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_readv:\n\n        {\n\n            int count = arg3;\n\n            int i;\n\n            struct iovec *vec;\n\n            struct target_iovec *target_vec = (void *)arg2;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            for(i = 0;i < count; i++) {\n\n                vec[i].iov_base = (void *)tswapl(target_vec[i].iov_base);\n\n                vec[i].iov_len = tswapl(target_vec[i].iov_len);\n\n            }\n\n            ret = get_errno(readv(arg1, vec, count));\n\n        }\n\n        break;\n\n    case TARGET_NR_writev:\n\n        {\n\n            int count = arg3;\n\n            int i;\n\n            struct iovec *vec;\n\n            struct target_iovec *target_vec = (void *)arg2;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            for(i = 0;i < count; i++) {\n\n                vec[i].iov_base = (void *)tswapl(target_vec[i].iov_base);\n\n                vec[i].iov_len = tswapl(target_vec[i].iov_len);\n\n            }\n\n            ret = get_errno(writev(arg1, vec, count));\n\n        }\n\n        break;\n\n    case TARGET_NR_getsid:\n\n        ret = get_errno(getsid(arg1));\n\n        break;\n\n    case TARGET_NR_fdatasync:\n\n        goto unimplemented;\n\n    case TARGET_NR__sysctl:\n\n        goto unimplemented;\n\n    case TARGET_NR_mlock:\n\n        ret = get_errno(mlock((void *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_munlock:\n\n        ret = get_errno(munlock((void *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_mlockall:\n\n        ret = get_errno(mlockall(arg1));\n\n        break;\n\n    case TARGET_NR_munlockall:\n\n        ret = get_errno(munlockall());\n\n        break;\n\n    case TARGET_NR_sched_setparam:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_getparam:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_setscheduler:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_getscheduler:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_yield:\n\n        ret = get_errno(sched_yield());\n\n        break;\n\n    case TARGET_NR_sched_get_priority_max:\n\n    case TARGET_NR_sched_get_priority_min:\n\n    case TARGET_NR_sched_rr_get_interval:\n\n    case TARGET_NR_nanosleep:\n\n    case TARGET_NR_mremap:\n\n    case TARGET_NR_setresuid:\n\n    case TARGET_NR_getresuid:\n\n    case TARGET_NR_vm86:\n\n    case TARGET_NR_query_module:\n\n    case TARGET_NR_poll:\n\n    case TARGET_NR_nfsservctl:\n\n    case TARGET_NR_setresgid:\n\n    case TARGET_NR_getresgid:\n\n    case TARGET_NR_prctl:\n\n    case TARGET_NR_rt_sigreturn:\n\n    case TARGET_NR_rt_sigaction:\n\n    case TARGET_NR_rt_sigprocmask:\n\n    case TARGET_NR_rt_sigpending:\n\n    case TARGET_NR_rt_sigtimedwait:\n\n    case TARGET_NR_rt_sigqueueinfo:\n\n    case TARGET_NR_rt_sigsuspend:\n\n    case TARGET_NR_pread:\n\n    case TARGET_NR_pwrite:\n\n        goto unimplemented;\n\n    case TARGET_NR_chown:\n\n        ret = get_errno(chown((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_getcwd:\n\n        ret = get_errno(sys_getcwd1((char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_capget:\n\n    case TARGET_NR_capset:\n\n    case TARGET_NR_sigaltstack:\n\n    case TARGET_NR_sendfile:\n\n    case TARGET_NR_getpmsg:\n\n    case TARGET_NR_putpmsg:\n\n    case TARGET_NR_vfork:\n\n        ret = get_errno(vfork());\n\n        break;\n\n    case TARGET_NR_ugetrlimit:\n\n    case TARGET_NR_truncate64:\n\n    case TARGET_NR_ftruncate64:\n\n    case TARGET_NR_stat64:\n\n    case TARGET_NR_lstat64:\n\n    case TARGET_NR_fstat64:\n\n    case TARGET_NR_lchown32:\n\n    case TARGET_NR_getuid32:\n\n    case TARGET_NR_getgid32:\n\n    case TARGET_NR_geteuid32:\n\n    case TARGET_NR_getegid32:\n\n    case TARGET_NR_setreuid32:\n\n    case TARGET_NR_setregid32:\n\n    case TARGET_NR_getgroups32:\n\n    case TARGET_NR_setgroups32:\n\n    case TARGET_NR_fchown32:\n\n    case TARGET_NR_setresuid32:\n\n    case TARGET_NR_getresuid32:\n\n    case TARGET_NR_setresgid32:\n\n    case TARGET_NR_getresgid32:\n\n    case TARGET_NR_chown32:\n\n    case TARGET_NR_setuid32:\n\n    case TARGET_NR_setgid32:\n\n    case TARGET_NR_setfsuid32:\n\n    case TARGET_NR_setfsgid32:\n\n    case TARGET_NR_pivot_root:\n\n    case TARGET_NR_mincore:\n\n    case TARGET_NR_madvise:\n\n    case TARGET_NR_getdents64:\n\n    case TARGET_NR_fcntl64:\n\n    case TARGET_NR_security:\n\n        goto unimplemented;\n\n    case TARGET_NR_gettid:\n\n        ret = get_errno(gettid());\n\n        break;\n\n    case TARGET_NR_readahead:\n\n    case TARGET_NR_setxattr:\n\n    case TARGET_NR_lsetxattr:\n\n    case TARGET_NR_fsetxattr:\n\n    case TARGET_NR_getxattr:\n\n    case TARGET_NR_lgetxattr:\n\n    case TARGET_NR_fgetxattr:\n\n    case TARGET_NR_listxattr:\n\n    case TARGET_NR_llistxattr:\n\n    case TARGET_NR_flistxattr:\n\n    case TARGET_NR_removexattr:\n\n    case TARGET_NR_lremovexattr:\n\n    case TARGET_NR_fremovexattr:\n\n        goto unimplemented;\n\n    default:\n\n    unimplemented:\n\n        gemu_log(\"Unsupported syscall: %d\\n\", num);\n\n        ret = -ENOSYS;\n\n        break;\n\n    }\n\n fail:\n\n    return ret;\n\n}\n", "idx": 14289, "_split": "test", "_hash": "ad92bd5a9b8ee94130f7a879e95f0b5a"}
{"project": "qemu", "commit_id": "f80ac75d0e6e6e7481d61cdb86e5a741a442f100", "target": 1, "func": "static int rebuild_refcount_structure(BlockDriverState *bs,\n\n                                      BdrvCheckResult *res,\n\n                                      void **refcount_table,\n\n                                      int64_t *nb_clusters)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t first_free_cluster = 0, reftable_offset = -1, cluster = 0;\n\n    int64_t refblock_offset, refblock_start, refblock_index;\n\n    uint32_t reftable_size = 0;\n\n    uint64_t *on_disk_reftable = NULL;\n\n    void *on_disk_refblock;\n\n    int ret = 0;\n\n    struct {\n\n        uint64_t reftable_offset;\n\n        uint32_t reftable_clusters;\n\n    } QEMU_PACKED reftable_offset_and_clusters;\n\n\n\n    qcow2_cache_empty(bs, s->refcount_block_cache);\n\n\n\nwrite_refblocks:\n\n    for (; cluster < *nb_clusters; cluster++) {\n\n        if (!s->get_refcount(*refcount_table, cluster)) {\n\n            continue;\n\n        }\n\n\n\n        refblock_index = cluster >> s->refcount_block_bits;\n\n        refblock_start = refblock_index << s->refcount_block_bits;\n\n\n\n        /* Don't allocate a cluster in a refblock already written to disk */\n\n        if (first_free_cluster < refblock_start) {\n\n            first_free_cluster = refblock_start;\n\n        }\n\n        refblock_offset = alloc_clusters_imrt(bs, 1, refcount_table,\n\n                                              nb_clusters, &first_free_cluster);\n\n        if (refblock_offset < 0) {\n\n            fprintf(stderr, \"ERROR allocating refblock: %s\\n\",\n\n                    strerror(-refblock_offset));\n\n            res->check_errors++;\n\n            ret = refblock_offset;\n\n            goto fail;\n\n        }\n\n\n\n        if (reftable_size <= refblock_index) {\n\n            uint32_t old_reftable_size = reftable_size;\n\n            uint64_t *new_on_disk_reftable;\n\n\n\n            reftable_size = ROUND_UP((refblock_index + 1) * sizeof(uint64_t),\n\n                                     s->cluster_size) / sizeof(uint64_t);\n\n            new_on_disk_reftable = g_try_realloc(on_disk_reftable,\n\n                                                 reftable_size *\n\n                                                 sizeof(uint64_t));\n\n            if (!new_on_disk_reftable) {\n\n                res->check_errors++;\n\n                ret = -ENOMEM;\n\n                goto fail;\n\n            }\n\n            on_disk_reftable = new_on_disk_reftable;\n\n\n\n            memset(on_disk_reftable + old_reftable_size, 0,\n\n                   (reftable_size - old_reftable_size) * sizeof(uint64_t));\n\n\n\n            /* The offset we have for the reftable is now no longer valid;\n\n             * this will leak that range, but we can easily fix that by running\n\n             * a leak-fixing check after this rebuild operation */\n\n            reftable_offset = -1;\n\n        }\n\n        on_disk_reftable[refblock_index] = refblock_offset;\n\n\n\n        /* If this is apparently the last refblock (for now), try to squeeze the\n\n         * reftable in */\n\n        if (refblock_index == (*nb_clusters - 1) >> s->refcount_block_bits &&\n\n            reftable_offset < 0)\n\n        {\n\n            uint64_t reftable_clusters = size_to_clusters(s, reftable_size *\n\n                                                          sizeof(uint64_t));\n\n            reftable_offset = alloc_clusters_imrt(bs, reftable_clusters,\n\n                                                  refcount_table, nb_clusters,\n\n                                                  &first_free_cluster);\n\n            if (reftable_offset < 0) {\n\n                fprintf(stderr, \"ERROR allocating reftable: %s\\n\",\n\n                        strerror(-reftable_offset));\n\n                res->check_errors++;\n\n                ret = reftable_offset;\n\n                goto fail;\n\n            }\n\n        }\n\n\n\n        ret = qcow2_pre_write_overlap_check(bs, 0, refblock_offset,\n\n                                            s->cluster_size);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR writing refblock: %s\\n\", strerror(-ret));\n\n            goto fail;\n\n        }\n\n\n\n        /* The size of *refcount_table is always cluster-aligned, therefore the\n\n         * write operation will not overflow */\n\n        on_disk_refblock = (void *)((char *) *refcount_table +\n\n                                    refblock_index * s->cluster_size);\n\n\n\n        ret = bdrv_write(bs->file, refblock_offset / BDRV_SECTOR_SIZE,\n\n                         on_disk_refblock, s->cluster_sectors);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR writing refblock: %s\\n\", strerror(-ret));\n\n            goto fail;\n\n        }\n\n\n\n        /* Go to the end of this refblock */\n\n        cluster = refblock_start + s->refcount_block_size - 1;\n\n    }\n\n\n\n    if (reftable_offset < 0) {\n\n        uint64_t post_refblock_start, reftable_clusters;\n\n\n\n        post_refblock_start = ROUND_UP(*nb_clusters, s->refcount_block_size);\n\n        reftable_clusters = size_to_clusters(s,\n\n                                             reftable_size * sizeof(uint64_t));\n\n        /* Not pretty but simple */\n\n        if (first_free_cluster < post_refblock_start) {\n\n            first_free_cluster = post_refblock_start;\n\n        }\n\n        reftable_offset = alloc_clusters_imrt(bs, reftable_clusters,\n\n                                              refcount_table, nb_clusters,\n\n                                              &first_free_cluster);\n\n        if (reftable_offset < 0) {\n\n            fprintf(stderr, \"ERROR allocating reftable: %s\\n\",\n\n                    strerror(-reftable_offset));\n\n            res->check_errors++;\n\n            ret = reftable_offset;\n\n            goto fail;\n\n        }\n\n\n\n        goto write_refblocks;\n\n    }\n\n\n\n    assert(on_disk_reftable);\n\n\n\n    for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) {\n\n        cpu_to_be64s(&on_disk_reftable[refblock_index]);\n\n    }\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs, 0, reftable_offset,\n\n                                        reftable_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR writing reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    assert(reftable_size < INT_MAX / sizeof(uint64_t));\n\n    ret = bdrv_pwrite(bs->file, reftable_offset, on_disk_reftable,\n\n                      reftable_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR writing reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    /* Enter new reftable into the image header */\n\n    reftable_offset_and_clusters.reftable_offset = cpu_to_be64(reftable_offset);\n\n    reftable_offset_and_clusters.reftable_clusters =\n\n        cpu_to_be32(size_to_clusters(s, reftable_size * sizeof(uint64_t)));\n\n    ret = bdrv_pwrite_sync(bs->file,\n\n                           offsetof(QCowHeader, refcount_table_offset),\n\n                           &reftable_offset_and_clusters,\n\n                           sizeof(reftable_offset_and_clusters));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR setting reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) {\n\n        be64_to_cpus(&on_disk_reftable[refblock_index]);\n\n    }\n\n    s->refcount_table = on_disk_reftable;\n\n    s->refcount_table_offset = reftable_offset;\n\n    s->refcount_table_size = reftable_size;\n\n    update_max_refcount_table_index(s);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    g_free(on_disk_reftable);\n\n    return ret;\n\n}\n", "idx": 14300, "_split": "test", "_hash": "68e88bb4d4cb2d8360126a7a0379157d"}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static BlockAIOCB *bdrv_co_aio_rw_vector(BdrvChild *child,\n\n                                         int64_t sector_num,\n\n                                         QEMUIOVector *qiov,\n\n                                         int nb_sectors,\n\n                                         BdrvRequestFlags flags,\n\n                                         BlockCompletionFunc *cb,\n\n                                         void *opaque,\n\n                                         bool is_write)\n\n{\n\n    Coroutine *co;\n\n    BlockAIOCBCoroutine *acb;\n\n\n\n    acb = qemu_aio_get(&bdrv_em_co_aiocb_info, child->bs, cb, opaque);\n\n    acb->child = child;\n\n    acb->need_bh = true;\n\n    acb->req.error = -EINPROGRESS;\n\n    acb->req.sector = sector_num;\n\n    acb->req.nb_sectors = nb_sectors;\n\n    acb->req.qiov = qiov;\n\n    acb->req.flags = flags;\n\n    acb->is_write = is_write;\n\n\n\n    co = qemu_coroutine_create(bdrv_co_do_rw);\n\n    qemu_coroutine_enter(co, acb);\n\n\n\n    bdrv_co_maybe_schedule_bh(acb);\n\n    return &acb->common;\n\n}\n", "idx": 14324, "_split": "test", "_hash": "c65e7254590a567372e02ea90143cf27"}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "static void ccw_machine_class_init(ObjectClass *oc, void *data)\n\n{\n\n    MachineClass *mc = MACHINE_CLASS(oc);\n\n    NMIClass *nc = NMI_CLASS(oc);\n\n    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc);\n\n    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);\n\n\n\n    s390mc->ri_allowed = true;\n\n    s390mc->cpu_model_allowed = true;\n\n    s390mc->css_migration_enabled = true;\n\n    s390mc->gs_allowed = true;\n\n    mc->init = ccw_init;\n\n    mc->reset = s390_machine_reset;\n\n    mc->hot_add_cpu = s390_hot_add_cpu;\n\n    mc->block_default_type = IF_VIRTIO;\n\n    mc->no_cdrom = 1;\n\n    mc->no_floppy = 1;\n\n    mc->no_serial = 1;\n\n    mc->no_parallel = 1;\n\n    mc->no_sdcard = 1;\n\n    mc->use_sclp = 1;\n\n    mc->max_cpus = S390_MAX_CPUS;\n\n    mc->has_hotpluggable_cpus = true;\n\n    mc->get_hotplug_handler = s390_get_hotplug_handler;\n\n    mc->cpu_index_to_instance_props = s390_cpu_index_to_props;\n\n    mc->possible_cpu_arch_ids = s390_possible_cpu_arch_ids;\n\n    /* it is overridden with 'host' cpu *in kvm_arch_init* */\n\n    mc->default_cpu_type = S390_CPU_TYPE_NAME(\"qemu\");\n\n    hc->plug = s390_machine_device_plug;\n\n    hc->unplug_request = s390_machine_device_unplug_request;\n\n    nc->nmi_monitor_handler = s390_nmi;\n\n}\n", "idx": 14356, "_split": "test", "_hash": "b53beade524742b5cccb767df8126c8d"}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline void gen_arm_shift_im(TCGv var, int shiftop, int shift, int flags)\n\n{\n\n    switch (shiftop) {\n\n    case 0: /* LSL */\n\n        if (shift != 0) {\n\n            if (flags)\n\n                shifter_out_im(var, 32 - shift);\n\n            tcg_gen_shli_i32(var, var, shift);\n\n        }\n\n        break;\n\n    case 1: /* LSR */\n\n        if (shift == 0) {\n\n            if (flags) {\n\n                tcg_gen_shri_i32(var, var, 31);\n\n                gen_set_CF(var);\n\n            }\n\n            tcg_gen_movi_i32(var, 0);\n\n        } else {\n\n            if (flags)\n\n                shifter_out_im(var, shift - 1);\n\n            tcg_gen_shri_i32(var, var, shift);\n\n        }\n\n        break;\n\n    case 2: /* ASR */\n\n        if (shift == 0)\n\n            shift = 32;\n\n        if (flags)\n\n            shifter_out_im(var, shift - 1);\n\n        if (shift == 32)\n\n          shift = 31;\n\n        tcg_gen_sari_i32(var, var, shift);\n\n        break;\n\n    case 3: /* ROR/RRX */\n\n        if (shift != 0) {\n\n            if (flags)\n\n                shifter_out_im(var, shift - 1);\n\n            tcg_gen_rotri_i32(var, var, shift); break;\n\n        } else {\n\n            TCGv tmp = load_cpu_field(CF);\n\n            if (flags)\n\n                shifter_out_im(var, 0);\n\n            tcg_gen_shri_i32(var, var, 1);\n\n            tcg_gen_shli_i32(tmp, tmp, 31);\n\n            tcg_gen_or_i32(var, var, tmp);\n\n            dead_tmp(tmp);\n\n        }\n\n    }\n\n};\n", "idx": 14376, "_split": "test", "_hash": "544c46619ed0b76ffb601c81d82b4e12"}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static void vmxnet3_update_vlan_filters(VMXNET3State *s)\n\n{\n\n    int i;\n\n\n\n    /* Copy configuration from shared memory */\n\n    VMXNET3_READ_DRV_SHARED(s->drv_shmem,\n\n                            devRead.rxFilterConf.vfTable,\n\n                            s->vlan_table,\n\n                            sizeof(s->vlan_table));\n\n\n\n    /* Invert byte order when needed */\n\n    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {\n\n        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);\n\n    }\n\n\n\n    /* Dump configuration for debugging purposes */\n\n    VMW_CFPRN(\"Configured VLANs:\");\n\n    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {\n\n        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {\n\n            VMW_CFPRN(\"\\tVLAN %d is present\", i);\n\n        }\n\n    }\n\n}\n", "idx": 14379, "_split": "test", "_hash": "928ee716229e27272b5ff6ac03a53d9d"}
{"project": "qemu", "commit_id": "a9cf98d939c4f6539fad7e7d812ea16d96ba3dc9", "target": 0, "func": "static void arm_timer_recalibrate(arm_timer_state *s, int reload)\n\n{\n\n    uint32_t limit;\n\n\n\n    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {\n\n        /* Free running.  */\n\n        if (s->control & TIMER_CTRL_32BIT)\n\n            limit = 0xffffffff;\n\n        else\n\n            limit = 0xffff;\n\n    } else {\n\n          /* Periodic.  */\n\n          limit = s->limit;\n\n    }\n\n    ptimer_set_limit(s->timer, limit, reload);\n\n}\n", "idx": 14387, "_split": "test", "_hash": "805f53234d1d14ae20f0e86a41b359f1"}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_down_char(void)\n\n{\n\n    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)\n\n\treturn;\n\n    if (term_history[++term_hist_entry] != NULL) {\n\n\tpstrcpy(term_cmd_buf, sizeof(term_cmd_buf),\n\n                term_history[term_hist_entry]);\n\n    } else {\n\n\tterm_hist_entry = -1;\n\n    }\n\n    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);\n\n}\n", "idx": 14388, "_split": "test", "_hash": "e25412890950c95a5361a15c7c302af2"}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_log_start(target_phys_addr_t phys_addr, ram_addr_t size)\n\n{\n\n        return kvm_dirty_pages_log_change(phys_addr, size,\n\n                                          KVM_MEM_LOG_DIRTY_PAGES,\n\n                                          KVM_MEM_LOG_DIRTY_PAGES);\n\n}\n", "idx": 14393, "_split": "test", "_hash": "b768d0bb6e4496d66bf6330fdf50ed07"}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_log(int argc, const char **argv)\n\n{\n\n    int mask;\n\n    \n\n    if (argc != 2)\n\n        goto help;\n\n    if (!strcmp(argv[1], \"none\")) {\n\n        mask = 0;\n\n    } else {\n\n        mask = cpu_str_to_log_mask(argv[1]);\n\n        if (!mask) {\n\n        help:\n\n            help_cmd(argv[0]);\n\n            return;\n\n        }\n\n    }\n\n    cpu_set_log(mask);\n\n}\n", "idx": 14413, "_split": "test", "_hash": "4eb8345387d128db6e5be538477023e6"}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "static int kvm_client_migration_log(struct CPUPhysMemoryClient *client,\n\n\t\t\t\t    int enable)\n\n{\n\n\treturn kvm_set_migration_log(enable);\n\n}\n", "idx": 14476, "_split": "test", "_hash": "06f250fe9110620d81bfdffcac764692"}
{"project": "qemu", "commit_id": "1bf6beec8a012cae4bb6fbc89c465127e9650c92", "target": 1, "func": "float16 float32_to_float16(float32 a, flag ieee STATUS_PARAM)\n\n{\n\n    flag aSign;\n\n    int_fast16_t aExp;\n\n    uint32_t aSig;\n\n    uint32_t mask;\n\n    uint32_t increment;\n\n    int8 roundingMode;\n\n    a = float32_squash_input_denormal(a STATUS_VAR);\n\n\n\n    aSig = extractFloat32Frac( a );\n\n    aExp = extractFloat32Exp( a );\n\n    aSign = extractFloat32Sign( a );\n\n    if ( aExp == 0xFF ) {\n\n        if (aSig) {\n\n            /* Input is a NaN */\n\n            float16 r = commonNaNToFloat16( float32ToCommonNaN( a STATUS_VAR ) STATUS_VAR );\n\n            if (!ieee) {\n\n                return packFloat16(aSign, 0, 0);\n\n            }\n\n            return r;\n\n        }\n\n        /* Infinity */\n\n        if (!ieee) {\n\n            float_raise(float_flag_invalid STATUS_VAR);\n\n            return packFloat16(aSign, 0x1f, 0x3ff);\n\n        }\n\n        return packFloat16(aSign, 0x1f, 0);\n\n    }\n\n    if (aExp == 0 && aSig == 0) {\n\n        return packFloat16(aSign, 0, 0);\n\n    }\n\n    /* Decimal point between bits 22 and 23.  */\n\n    aSig |= 0x00800000;\n\n    aExp -= 0x7f;\n\n    if (aExp < -14) {\n\n        mask = 0x00ffffff;\n\n        if (aExp >= -24) {\n\n            mask >>= 25 + aExp;\n\n        }\n\n    } else {\n\n        mask = 0x00001fff;\n\n    }\n\n    if (aSig & mask) {\n\n        float_raise( float_flag_underflow STATUS_VAR );\n\n        roundingMode = STATUS(float_rounding_mode);\n\n        switch (roundingMode) {\n\n        case float_round_nearest_even:\n\n            increment = (mask + 1) >> 1;\n\n            if ((aSig & mask) == increment) {\n\n                increment = aSig & (increment << 1);\n\n            }\n\n            break;\n\n        case float_round_up:\n\n            increment = aSign ? 0 : mask;\n\n            break;\n\n        case float_round_down:\n\n            increment = aSign ? mask : 0;\n\n            break;\n\n        default: /* round_to_zero */\n\n            increment = 0;\n\n            break;\n\n        }\n\n        aSig += increment;\n\n        if (aSig >= 0x01000000) {\n\n            aSig >>= 1;\n\n            aExp++;\n\n        }\n\n    } else if (aExp < -14\n\n          && STATUS(float_detect_tininess) == float_tininess_before_rounding) {\n\n        float_raise( float_flag_underflow STATUS_VAR);\n\n    }\n\n\n\n    if (ieee) {\n\n        if (aExp > 15) {\n\n            float_raise( float_flag_overflow | float_flag_inexact STATUS_VAR);\n\n            return packFloat16(aSign, 0x1f, 0);\n\n        }\n\n    } else {\n\n        if (aExp > 16) {\n\n            float_raise(float_flag_invalid | float_flag_inexact STATUS_VAR);\n\n            return packFloat16(aSign, 0x1f, 0x3ff);\n\n        }\n\n    }\n\n    if (aExp < -24) {\n\n        return packFloat16(aSign, 0, 0);\n\n    }\n\n    if (aExp < -14) {\n\n        aSig >>= -14 - aExp;\n\n        aExp = -14;\n\n    }\n\n    return packFloat16(aSign, aExp + 14, aSig >> 13);\n\n}\n", "idx": 14521, "_split": "test", "_hash": "36c57dfeabfab3dd24cdd2cb98b0ba12"}
{"project": "qemu", "commit_id": "0d8d7690850eb0cf2b2b60933cf47669a6b6f18f", "target": 0, "func": "int virtqueue_avail_bytes(VirtQueue *vq, int in_bytes, int out_bytes)\n\n{\n\n    unsigned int idx;\n\n    unsigned int total_bufs, in_total, out_total;\n\n\n\n    idx = vq->last_avail_idx;\n\n\n\n    total_bufs = in_total = out_total = 0;\n\n    while (virtqueue_num_heads(vq, idx)) {\n\n        unsigned int max, num_bufs, indirect = 0;\n\n        target_phys_addr_t desc_pa;\n\n        int i;\n\n\n\n        max = vq->vring.num;\n\n        num_bufs = total_bufs;\n\n        i = virtqueue_get_head(vq, idx++);\n\n        desc_pa = vq->vring.desc;\n\n\n\n        if (vring_desc_flags(desc_pa, i) & VRING_DESC_F_INDIRECT) {\n\n            if (vring_desc_len(desc_pa, i) % sizeof(VRingDesc)) {\n\n                error_report(\"Invalid size for indirect buffer table\");\n\n                exit(1);\n\n            }\n\n\n\n            /* If we've got too many, that implies a descriptor loop. */\n\n            if (num_bufs >= max) {\n\n                error_report(\"Looped descriptor\");\n\n                exit(1);\n\n            }\n\n\n\n            /* loop over the indirect descriptor table */\n\n            indirect = 1;\n\n            max = vring_desc_len(desc_pa, i) / sizeof(VRingDesc);\n\n            num_bufs = i = 0;\n\n            desc_pa = vring_desc_addr(desc_pa, i);\n\n        }\n\n\n\n        do {\n\n            /* If we've got too many, that implies a descriptor loop. */\n\n            if (++num_bufs > max) {\n\n                error_report(\"Looped descriptor\");\n\n                exit(1);\n\n            }\n\n\n\n            if (vring_desc_flags(desc_pa, i) & VRING_DESC_F_WRITE) {\n\n                if (in_bytes > 0 &&\n\n                    (in_total += vring_desc_len(desc_pa, i)) >= in_bytes)\n\n                    return 1;\n\n            } else {\n\n                if (out_bytes > 0 &&\n\n                    (out_total += vring_desc_len(desc_pa, i)) >= out_bytes)\n\n                    return 1;\n\n            }\n\n        } while ((i = virtqueue_next_desc(desc_pa, i, max)) != max);\n\n\n\n        if (!indirect)\n\n            total_bufs = num_bufs;\n\n        else\n\n            total_bufs++;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14531, "_split": "test", "_hash": "1761da2954efc641b49e30859742b5cc"}
{"project": "qemu", "commit_id": "bd5c51ee6c4f1c79cae5ad2516d711a27b4ea8ec", "target": 0, "func": "static CharDriverState *qemu_chr_open_fd(int fd_in, int fd_out)\n\n{\n\n    CharDriverState *chr;\n\n    FDCharDriver *s;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    s = g_malloc0(sizeof(FDCharDriver));\n\n    s->fd_in = io_channel_from_fd(fd_in);\n\n    s->fd_out = io_channel_from_fd(fd_out);\n\n    fcntl(fd_out, F_SETFL, O_NONBLOCK);\n\n    s->chr = chr;\n\n    chr->opaque = s;\n\n    chr->chr_add_watch = fd_chr_add_watch;\n\n    chr->chr_write = fd_chr_write;\n\n    chr->chr_update_read_handler = fd_chr_update_read_handler;\n\n    chr->chr_close = fd_chr_close;\n\n\n\n    qemu_chr_be_generic_open(chr);\n\n\n\n    return chr;\n\n}\n", "idx": 14557, "_split": "test", "_hash": "1be8531614c8a90c232d86a4d4965e17"}
{"project": "qemu", "commit_id": "9c4bab2668e6b5a9b69f77e3533380b6fd79034e", "target": 0, "func": "static int openfile(char *name, int flags)\n\n{\n\n\tif (bs) {\n\n\t\tfprintf(stderr, \"file open already, try 'help close'\\n\");\n\n\t\treturn 1;\n\n\t}\n\n\n\n\tbs = bdrv_new(\"hda\");\n\n\tif (!bs)\n\n\t\treturn 1;\n\n\n\n\tif (bdrv_open(bs, name, flags) == -1) {\n\n\t\tfprintf(stderr, \"%s: can't open device %s\\n\", progname, name);\n\n\t\tbs = NULL;\n\n\t\treturn 1;\n\n\t}\n\n\n\n\treturn 0;\n\n}\n", "idx": 14589, "_split": "test", "_hash": "3a9bfd7edab8d246eab06a9100242b68"}
{"project": "qemu", "commit_id": "67113c03423a23e60915574275aed7d60e9f85e1", "target": 0, "func": "static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)\n\n{\n\n    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);\n\n    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),\n\n                                  \"/e500-ccsr\"));\n\n\n\n    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);\n\n    d->config[PCI_HEADER_TYPE] =\n\n        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |\n\n        PCI_HEADER_TYPE_BRIDGE;\n\n\n\n    memory_region_init_alias(&b->bar0, OBJECT(ccsr), \"e500-pci-bar0\", &ccsr->ccsr_space,\n\n                             0, int128_get64(ccsr->ccsr_space.size));\n\n    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);\n\n}\n", "idx": 14591, "_split": "test", "_hash": "42921fe3ee8f548ee74c6b10ae6fd81e"}
{"project": "qemu", "commit_id": "2e29bd04786003561303dcad940b38afe790fb9b", "target": 1, "func": "static void pci_unin_main_config_writel (void *opaque, target_phys_addr_t addr,\n\n                                         uint32_t val)\n\n{\n\n    UNINState *s = opaque;\n\n\n\n    UNIN_DPRINTF(\"config_writel addr \" TARGET_FMT_plx \" val %x\\n\", addr, val);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    val = bswap32(val);\n\n#endif\n\n\n\n    s->config_reg = val;\n\n}\n", "idx": 14679, "_split": "test", "_hash": "c14a9441152ad83c92986d23b2d1f45f"}
{"project": "qemu", "commit_id": "523b018dde3b7650fe5401d0499b30cf2f117515", "target": 1, "func": "vubr_set_vring_addr_exec(VubrDev *dev, VhostUserMsg *vmsg)\n{\n    struct vhost_vring_addr *vra = &vmsg->payload.addr;\n    unsigned int index = vra->index;\n    VubrVirtq *vq = &dev->vq[index];\n    DPRINT(\"vhost_vring_addr:\\n\");\n    DPRINT(\"    index:  %d\\n\", vra->index);\n    DPRINT(\"    flags:  %d\\n\", vra->flags);\n    DPRINT(\"    desc_user_addr:   0x%016llx\\n\", vra->desc_user_addr);\n    DPRINT(\"    used_user_addr:   0x%016llx\\n\", vra->used_user_addr);\n    DPRINT(\"    avail_user_addr:  0x%016llx\\n\", vra->avail_user_addr);\n    DPRINT(\"    log_guest_addr:   0x%016llx\\n\", vra->log_guest_addr);\n    vq->desc = (struct vring_desc *)(uintptr_t)qva_to_va(dev, vra->desc_user_addr);\n    vq->used = (struct vring_used *)(uintptr_t)qva_to_va(dev, vra->used_user_addr);\n    vq->avail = (struct vring_avail *)(uintptr_t)qva_to_va(dev, vra->avail_user_addr);\n    vq->log_guest_addr = vra->log_guest_addr;\n    DPRINT(\"Setting virtq addresses:\\n\");\n    DPRINT(\"    vring_desc  at %p\\n\", vq->desc);\n    DPRINT(\"    vring_used  at %p\\n\", vq->used);\n    DPRINT(\"    vring_avail at %p\\n\", vq->avail);\n    vq->last_used_index = vq->used->idx;\n    return 0;", "idx": 14680, "_split": "test", "_hash": "c13c0956279129ad5f92c8793fadccbc"}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static PCIBridgeWindows *pci_bridge_region_init(PCIBridge *br)\n\n{\n\n    PCIDevice *pd = PCI_DEVICE(br);\n\n    PCIBus *parent = pd->bus;\n\n    PCIBridgeWindows *w = g_new(PCIBridgeWindows, 1);\n\n    uint16_t cmd = pci_get_word(pd->config + PCI_COMMAND);\n\n\n\n    pci_bridge_init_alias(br, &w->alias_pref_mem,\n\n                          PCI_BASE_ADDRESS_MEM_PREFETCH,\n\n                          \"pci_bridge_pref_mem\",\n\n                          &br->address_space_mem,\n\n                          parent->address_space_mem,\n\n                          cmd & PCI_COMMAND_MEMORY);\n\n    pci_bridge_init_alias(br, &w->alias_mem,\n\n                          PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                          \"pci_bridge_mem\",\n\n                          &br->address_space_mem,\n\n                          parent->address_space_mem,\n\n                          cmd & PCI_COMMAND_MEMORY);\n\n    pci_bridge_init_alias(br, &w->alias_io,\n\n                          PCI_BASE_ADDRESS_SPACE_IO,\n\n                          \"pci_bridge_io\",\n\n                          &br->address_space_io,\n\n                          parent->address_space_io,\n\n                          cmd & PCI_COMMAND_IO);\n\n\n\n    pci_bridge_init_vga_aliases(br, parent, w->alias_vga);\n\n\n\n    return w;\n\n}\n", "idx": 14716, "_split": "test", "_hash": "9462e24e7bdef58b07e184fe4fb77ad9"}
{"project": "qemu", "commit_id": "1f3ddfcb258e6e0562467a9644daad3f28597da8", "target": 1, "func": "static void bdrv_qed_drain(BlockDriverState *bs)\n\n{\n\n    BDRVQEDState *s = bs->opaque;\n\n\n\n    /* Cancel timer and start doing I/O that were meant to happen as if it\n\n     * fired, that way we get bdrv_drain() taking care of the ongoing requests\n\n     * correctly. */\n\n    qed_cancel_need_check_timer(s);\n\n    qed_plug_allocating_write_reqs(s);\n\n    bdrv_aio_flush(s->bs, qed_clear_need_check, s);\n\n}\n", "idx": 14750, "_split": "test", "_hash": "a616326d827f52f274d21063a78a7828"}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtol_invalid(void)\n\n{\n\n    const char *str = \"   xxxx  \\t abc\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtol(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 14774, "_split": "test", "_hash": "958a68a95f8cfab4ae4aaf17cd2273a9"}
{"project": "qemu", "commit_id": "340849a9ff2a246bbc9a2da3f079c9fdbd2d5852", "target": 1, "func": "static int check_bind(const char *hostname, bool *has_proto)\n\n{\n\n    int fd = -1;\n\n    struct addrinfo ai, *res = NULL;\n\n    int rc;\n\n    int ret = -1;\n\n\n\n    memset(&ai, 0, sizeof(ai));\n\n    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;\n\n    ai.ai_family = AF_UNSPEC;\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    /* lookup */\n\n    rc = getaddrinfo(hostname, NULL, &ai, &res);\n\n    if (rc != 0) {\n\n        if (rc == EAI_ADDRFAMILY ||\n\n            rc == EAI_FAMILY) {\n\n            *has_proto = false;\n\n            goto done;\n\n        }\n\n        goto cleanup;\n\n    }\n\n\n\n    fd = qemu_socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n    if (fd < 0) {\n\n        goto cleanup;\n\n    }\n\n\n\n    if (bind(fd, res->ai_addr, res->ai_addrlen) < 0) {\n\n        if (errno == EADDRNOTAVAIL) {\n\n            *has_proto = false;\n\n            goto done;\n\n        }\n\n        goto cleanup;\n\n    }\n\n\n\n    *has_proto = true;\n\n done:\n\n    ret = 0;\n\n\n\n cleanup:\n\n    if (fd != -1) {\n\n        close(fd);\n\n    }\n\n    if (res) {\n\n        freeaddrinfo(res);\n\n    }\n\n    return ret;\n\n}\n", "idx": 14775, "_split": "test", "_hash": "caa460e953d68625f00758b8bd9ada61"}
{"project": "qemu", "commit_id": "684e508c23d28af8d6ed2c62738a0f60447c8274", "target": 1, "func": "static bool run_poll_handlers(AioContext *ctx, int64_t max_ns)\n\n{\n\n    bool progress = false;\n\n    int64_t end_time;\n\n\n\n    assert(ctx->notify_me);\n\n    assert(ctx->walking_handlers > 0);\n\n    assert(ctx->poll_disable_cnt == 0);\n\n\n\n    trace_run_poll_handlers_begin(ctx, max_ns);\n\n\n\n    end_time = qemu_clock_get_ns(QEMU_CLOCK_REALTIME) + max_ns;\n\n\n\n    do {\n\n        AioHandler *node;\n\n\n\n        QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n            if (!node->deleted && node->io_poll &&\n\n                node->io_poll(node->opaque)) {\n\n                progress = true;\n\n            }\n\n\n\n            /* Caller handles freeing deleted nodes.  Don't do it here. */\n\n        }\n\n    } while (!progress && qemu_clock_get_ns(QEMU_CLOCK_REALTIME) < end_time);\n\n\n\n    trace_run_poll_handlers_end(ctx, progress);\n\n\n\n    return progress;\n\n}\n", "idx": 14777, "_split": "test", "_hash": "55df62c15fb1f7fca80c5109a72c9ded"}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline TCGv iwmmxt_load_creg(int reg)\n\n{\n\n    TCGv var = new_tmp();\n\n    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));\n\n    return var;\n\n}\n", "idx": 14814, "_split": "test", "_hash": "50d1f2b84ba962593bf10b24bd81354e"}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)\n\n{\n\n    const ARMCPRegInfo *ri = rip;\n\n\n\n    ri->writefn(env, ri, value);\n\n}\n", "idx": 14816, "_split": "test", "_hash": "e8e20ff7407a1f881b91bdb0545d6986"}
{"project": "qemu", "commit_id": "0e22a2d18998fd183c8181663981eb681ca977e9", "target": 1, "func": "static void vhost_scsi_stop(VHostSCSI *s)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    int ret = 0;\n\n\n\n    if (!k->set_guest_notifiers) {\n\n        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);\n\n        if (ret < 0) {\n\n                error_report(\"vhost guest notifier cleanup failed: %d\\n\", ret);\n\n        }\n\n    }\n\n    assert(ret >= 0);\n\n\n\n    vhost_scsi_clear_endpoint(s);\n\n    vhost_dev_stop(&s->dev, vdev);\n\n    vhost_dev_disable_notifiers(&s->dev, vdev);\n\n}\n", "idx": 14822, "_split": "test", "_hash": "421b01531527e653d92f9dee796c4647"}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void start_tco(const TestData *d)\n\n{\n\n    uint32_t val;\n\n\n\n    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);\n\n    val &= ~TCO_TMR_HLT;\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);\n\n}\n", "idx": 14823, "_split": "test", "_hash": "6fc9d0c064df8551ff65358e72d40c17"}
{"project": "qemu", "commit_id": "1931076077254a2886daa7c830c7838ebd1f81ef", "target": 0, "func": "void memory_global_dirty_log_stop(void)\n\n{\n\n    global_dirty_log = false;\n\n\n\n    /* Refresh DIRTY_LOG_MIGRATION bit.  */\n\n    memory_region_transaction_begin();\n\n    memory_region_update_pending = true;\n\n    memory_region_transaction_commit();\n\n\n\n    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);\n\n}\n", "idx": 14840, "_split": "test", "_hash": "ed30ba843217d12fb3958ed7ce179a5b"}
{"project": "qemu", "commit_id": "77eec1b3f1493ca4813eae2fbf8702d1ef58f147", "target": 0, "func": "static inline int open_by_handle(int mountfd, const char *fh, int flags)\n\n{\n\n    errno = ENOSYS;\n\n    return -1;\n\n}\n", "idx": 14842, "_split": "test", "_hash": "6f2dade11f04d145d23dc8e969d59666"}
{"project": "qemu", "commit_id": "541dc0d47f10973c241e9955afc2aefc96adec51", "target": 0, "func": "static void cmd_get_event_status_notification(IDEState *s,\n\n                                              uint8_t *buf)\n\n{\n\n    const uint8_t *packet = buf;\n\n\n\n    struct {\n\n        uint8_t opcode;\n\n        uint8_t polled;        /* lsb bit is polled; others are reserved */\n\n        uint8_t reserved2[2];\n\n        uint8_t class;\n\n        uint8_t reserved3[2];\n\n        uint16_t len;\n\n        uint8_t control;\n\n    } __attribute__((packed)) *gesn_cdb;\n\n\n\n    struct {\n\n        uint16_t len;\n\n        uint8_t notification_class;\n\n        uint8_t supported_events;\n\n    } __attribute((packed)) *gesn_event_header;\n\n\n\n    enum notification_class_request_type {\n\n        NCR_RESERVED1 = 1 << 0,\n\n        NCR_OPERATIONAL_CHANGE = 1 << 1,\n\n        NCR_POWER_MANAGEMENT = 1 << 2,\n\n        NCR_EXTERNAL_REQUEST = 1 << 3,\n\n        NCR_MEDIA = 1 << 4,\n\n        NCR_MULTI_HOST = 1 << 5,\n\n        NCR_DEVICE_BUSY = 1 << 6,\n\n        NCR_RESERVED2 = 1 << 7,\n\n    };\n\n    enum event_notification_class_field {\n\n        ENC_NO_EVENTS = 0,\n\n        ENC_OPERATIONAL_CHANGE,\n\n        ENC_POWER_MANAGEMENT,\n\n        ENC_EXTERNAL_REQUEST,\n\n        ENC_MEDIA,\n\n        ENC_MULTIPLE_HOSTS,\n\n        ENC_DEVICE_BUSY,\n\n        ENC_RESERVED,\n\n    };\n\n    unsigned int max_len, used_len;\n\n\n\n    gesn_cdb = (void *)packet;\n\n    gesn_event_header = (void *)buf;\n\n\n\n    max_len = be16_to_cpu(gesn_cdb->len);\n\n\n\n    /* It is fine by the MMC spec to not support async mode operations */\n\n    if (!(gesn_cdb->polled & 0x01)) { /* asynchronous mode */\n\n        /* Only polling is supported, asynchronous mode is not. */\n\n        ide_atapi_cmd_error(s, SENSE_ILLEGAL_REQUEST,\n\n                            ASC_INV_FIELD_IN_CMD_PACKET);\n\n        return;\n\n    }\n\n\n\n    /* polling mode operation */\n\n\n\n    /*\n\n     * These are the supported events.\n\n     *\n\n     * We currently only support requests of the 'media' type.\n\n     */\n\n    gesn_event_header->supported_events = NCR_MEDIA;\n\n\n\n    /*\n\n     * We use |= below to set the class field; other bits in this byte\n\n     * are reserved now but this is useful to do if we have to use the\n\n     * reserved fields later.\n\n     */\n\n    gesn_event_header->notification_class = 0;\n\n\n\n    /*\n\n     * Responses to requests are to be based on request priority.  The\n\n     * notification_class_request_type enum above specifies the\n\n     * priority: upper elements are higher prio than lower ones.\n\n     */\n\n    if (gesn_cdb->class & NCR_MEDIA) {\n\n        gesn_event_header->notification_class |= ENC_MEDIA;\n\n        used_len = event_status_media(s, buf);\n\n    } else {\n\n        gesn_event_header->notification_class = 0x80; /* No event available */\n\n        used_len = sizeof(*gesn_event_header);\n\n    }\n\n    gesn_event_header->len = cpu_to_be16(used_len\n\n                                         - sizeof(*gesn_event_header));\n\n    ide_atapi_cmd_reply(s, used_len, max_len);\n\n}\n", "idx": 14846, "_split": "test", "_hash": "99252e5dff41d0243db5d2f09ef3444b"}
{"project": "qemu", "commit_id": "4d68e86bb10159099da0798f74e7512955f15eec", "target": 0, "func": "void qemu_coroutine_adjust_pool_size(int n)\n\n{\n\n    qemu_mutex_lock(&pool_lock);\n\n\n\n    pool_max_size += n;\n\n\n\n    /* Callers should never take away more than they added */\n\n    assert(pool_max_size >= POOL_DEFAULT_SIZE);\n\n\n\n    /* Trim oversized pool down to new max */\n\n    while (pool_size > pool_max_size) {\n\n        Coroutine *co = QSLIST_FIRST(&pool);\n\n        QSLIST_REMOVE_HEAD(&pool, pool_next);\n\n        pool_size--;\n\n        qemu_coroutine_delete(co);\n\n    }\n\n\n\n    qemu_mutex_unlock(&pool_lock);\n\n}\n", "idx": 14904, "_split": "test", "_hash": "50478492fe4f23754c7c417ab4d7bd4e"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void rndis_clear_responsequeue(USBNetState *s)\n\n{\n\n    struct rndis_response *r;\n\n\n\n    while ((r = s->rndis_resp.tqh_first)) {\n\n        TAILQ_REMOVE(&s->rndis_resp, r, entries);\n\n        qemu_free(r);\n\n    }\n\n}\n", "idx": 14911, "_split": "test", "_hash": "35fee9a486820102127cfaf647b05f2c"}
{"project": "qemu", "commit_id": "b769d8fef6c06ddb39ef0337882a4f8872b9c2bc", "target": 0, "func": "int cpu_ppc_handle_mmu_fault (CPUState *env, uint32_t address, int rw,\n\n                              int is_user, int is_softmmu)\n\n{\n\n    uint32_t physical;\n\n    int prot;\n\n    int exception = 0, error_code = 0;\n\n    int access_type;\n\n    int ret = 0;\n\n\n\n//    printf(\"%s 0\\n\", __func__);\n\n    access_type = env->access_type;\n\n    if (env->user_mode_only) {\n\n        /* user mode only emulation */\n\n        ret = -2;\n\n        goto do_fault;\n\n    }\n\n    /* NASTY BUG workaround */\n\n    if (access_type == ACCESS_CODE && rw) {\n\n\tprintf(\"%s: ERROR WRITE CODE ACCESS\\n\", __func__);\n\n\taccess_type = ACCESS_INT;\n\n    }\n\n    ret = get_physical_address(env, &physical, &prot,\n\n                               address, rw, access_type);\n\n    if (ret == 0) {\n\n\tret = tlb_set_page(env, address & ~0xFFF, physical, prot,\n\n\t\t\t   is_user, is_softmmu);\n\n    } else if (ret < 0) {\n\n    do_fault:\n\n#if defined (DEBUG_MMU)\n\n\tif (loglevel > 0)\n\n\t    cpu_ppc_dump_state(env, logfile, 0);\n\n#endif\n\n        if (access_type == ACCESS_CODE) {\n\n            exception = EXCP_ISI;\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables */\n\n                error_code = EXCP_ISI_TRANSLATE;\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                error_code = EXCP_ISI_PROT;\n\n                break;\n\n            case -3:\n\n\t\t/* No execute protection violation */\n\n                error_code = EXCP_ISI_NOEXEC;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                /* No code fetch is allowed in direct-store areas */\n\n                error_code = EXCP_ISI_DIRECT;\n\n                break;\n\n            }\n\n        } else {\n\n            exception = EXCP_DSI;\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables */\n\n                error_code = EXCP_DSI_TRANSLATE;\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                error_code = EXCP_DSI_PROT;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                switch (access_type) {\n\n                case ACCESS_FLOAT:\n\n                    /* Floating point load/store */\n\n                    exception = EXCP_ALIGN;\n\n                    error_code = EXCP_ALIGN_FP;\n\n                    break;\n\n                case ACCESS_RES:\n\n                    /* lwarx, ldarx or srwcx. */\n\n                    exception = EXCP_DSI;\n\n                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT;\n\n                    break;\n\n                case ACCESS_EXT:\n\n                    /* eciwx or ecowx */\n\n                    exception = EXCP_DSI;\n\n                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT |\n\n\t\t\tEXCP_DSI_ECXW;\n\n                    break;\n\n                default:\n\n\t\t    printf(\"DSI: invalid exception (%d)\\n\", ret);\n\n                    exception = EXCP_PROGRAM;\n\n                    error_code = EXCP_INVAL | EXCP_INVAL_INVAL;\n\n                    break;\n\n                }\n\n            }\n\n            if (rw)\n\n                error_code |= EXCP_DSI_STORE;\n\n\t    /* Store fault address */\n\n\t    env->spr[DAR] = address;\n\n        }\n\n#if 0\n\n        printf(\"%s: set exception to %d %02x\\n\",\n\n               __func__, exception, error_code);\n\n#endif\n\n        env->exception_index = exception;\n\n        env->error_code = error_code;\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 14936, "_split": "test", "_hash": "41e58e50b2c31947ebfa240afd3789d7"}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int sd_truncate(BlockDriverState *bs, int64_t offset)\n\n{\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    int ret, fd;\n\n    unsigned int datalen;\n\n\n\n    if (offset < s->inode.vdi_size) {\n\n        error_report(\"shrinking is not supported\");\n\n        return -EINVAL;\n\n    } else if (offset > SD_MAX_VDI_SIZE) {\n\n        error_report(\"too big image size\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        return fd;\n\n    }\n\n\n\n    /* we don't need to update entire object */\n\n    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);\n\n    s->inode.vdi_size = offset;\n\n    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n\n                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);\n\n    close(fd);\n\n\n\n    if (ret < 0) {\n\n        error_report(\"failed to update an inode.\");\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 14951, "_split": "test", "_hash": "68efee554d578056ef17df28ca2809ac"}
{"project": "qemu", "commit_id": "190563f9a90c9df8ad32fc7f3e4b166deda949a6", "target": 0, "func": "static int rndis_parse(USBNetState *s, uint8_t *data, int length)\n\n{\n\n    uint32_t msg_type;\n\n    le32 *tmp = (le32 *) data;\n\n\n\n    msg_type = le32_to_cpup(tmp);\n\n\n\n    switch (msg_type) {\n\n    case RNDIS_INITIALIZE_MSG:\n\n        s->rndis_state = RNDIS_INITIALIZED;\n\n        return rndis_init_response(s, (rndis_init_msg_type *) data);\n\n\n\n    case RNDIS_HALT_MSG:\n\n        s->rndis_state = RNDIS_UNINITIALIZED;\n\n        return 0;\n\n\n\n    case RNDIS_QUERY_MSG:\n\n        return rndis_query_response(s, (rndis_query_msg_type *) data, length);\n\n\n\n    case RNDIS_SET_MSG:\n\n        return rndis_set_response(s, (rndis_set_msg_type *) data, length);\n\n\n\n    case RNDIS_RESET_MSG:\n\n        rndis_clear_responsequeue(s);\n\n        s->out_ptr = s->in_ptr = s->in_len = 0;\n\n        return rndis_reset_response(s, (rndis_reset_msg_type *) data);\n\n\n\n    case RNDIS_KEEPALIVE_MSG:\n\n        /* For USB: host does this every 5 seconds */\n\n        return rndis_keepalive_response(s, (rndis_keepalive_msg_type *) data);\n\n    }\n\n\n\n    return USB_RET_STALL;\n\n}\n", "idx": 14982, "_split": "test", "_hash": "35085b00529abb9fc46d25e088e57732"}
{"project": "qemu", "commit_id": "2906cddfecff21af20eedab43288b485a679f9ac", "target": 0, "func": "static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtIOBlock *s = VIRTIO_BLK(vdev);\n\n    VirtIOBlockReq *req;\n\n    MultiReqBuffer mrb = {};\n\n\n\n    /* Some guests kick before setting VIRTIO_CONFIG_S_DRIVER_OK so start\n\n     * dataplane here instead of waiting for .set_status().\n\n     */\n\n    if (s->dataplane) {\n\n        virtio_blk_data_plane_start(s->dataplane);\n\n        return;\n\n    }\n\n\n\n    blk_io_plug(s->blk);\n\n\n\n    while ((req = virtio_blk_get_request(s))) {\n\n        virtio_blk_handle_request(req, &mrb);\n\n    }\n\n\n\n    if (mrb.num_reqs) {\n\n        virtio_blk_submit_multireq(s->blk, &mrb);\n\n    }\n\n\n\n    blk_io_unplug(s->blk);\n\n}\n", "idx": 15016, "_split": "test", "_hash": "b00220e4cf21be554206e587293c31d1"}
{"project": "qemu", "commit_id": "f5babeacc4abccbb32f318278135a43477bdaa20", "target": 0, "func": "static void realize(DeviceState *d, Error **errp)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);\n\n    Object *root_container;\n\n    char link_name[256];\n\n    gchar *child_name;\n\n    Error *err = NULL;\n\n\n\n    trace_spapr_drc_realize(spapr_drc_index(drc));\n\n    /* NOTE: we do this as part of realize/unrealize due to the fact\n\n     * that the guest will communicate with the DRC via RTAS calls\n\n     * referencing the global DRC index. By unlinking the DRC\n\n     * from DRC_CONTAINER_PATH/<drc_index> we effectively make it\n\n     * inaccessible by the guest, since lookups rely on this path\n\n     * existing in the composition tree\n\n     */\n\n    root_container = container_get(object_get_root(), DRC_CONTAINER_PATH);\n\n    snprintf(link_name, sizeof(link_name), \"%x\", spapr_drc_index(drc));\n\n    child_name = object_get_canonical_path_component(OBJECT(drc));\n\n    trace_spapr_drc_realize_child(spapr_drc_index(drc), child_name);\n\n    object_property_add_alias(root_container, link_name,\n\n                              drc->owner, child_name, &err);\n\n    g_free(child_name);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n    vmstate_register(DEVICE(drc), spapr_drc_index(drc), &vmstate_spapr_drc,\n\n                     drc);\n\n    qemu_register_reset(drc_reset, drc);\n\n    trace_spapr_drc_realize_complete(spapr_drc_index(drc));\n\n}\n", "idx": 15055, "_split": "test", "_hash": "45e9c956862422217127666fbe857910"}
{"project": "qemu", "commit_id": "7ec1e5ea4bd0700fa48da86bffa2fcc6146c410a", "target": 0, "func": "static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,\n\n                       int insn, int size, int sign)\n\n{\n\n    TCGv_i32 r_asi, r_size, r_sign;\n\n\n\n    r_asi = gen_get_asi(dc, insn);\n\n    r_size = tcg_const_i32(size);\n\n    r_sign = tcg_const_i32(sign);\n\n#ifdef TARGET_SPARC64\n\n    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);\n\n#else\n\n    {\n\n        TCGv_i64 t64 = tcg_temp_new_i64();\n\n        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);\n\n        tcg_gen_trunc_i64_tl(dst, t64);\n\n        tcg_temp_free_i64(t64);\n\n    }\n\n#endif\n\n    tcg_temp_free_i32(r_sign);\n\n    tcg_temp_free_i32(r_size);\n\n    tcg_temp_free_i32(r_asi);\n\n}\n", "idx": 15061, "_split": "test", "_hash": "437053f8f64ed6f0a58648aa70c408ff"}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "static inline float64 ucf64_itod(uint64_t i)\n\n{\n\n    union {\n\n        uint64_t i;\n\n        float64 d;\n\n    } v;\n\n\n\n    v.i = i;\n\n    return v.d;\n\n}\n", "idx": 15066, "_split": "test", "_hash": "353707c9985fd3f4d5e16fd1db30de06"}
{"project": "qemu", "commit_id": "23dceda62a3643f734b7aa474fa6052593ae1a70", "target": 0, "func": "int tcg_gen_code(TCGContext *s, tcg_insn_unit *gen_code_buf)\n\n{\n\n    int i, oi, oi_next, num_insns;\n\n\n\n#ifdef CONFIG_PROFILER\n\n    {\n\n        int n;\n\n\n\n        n = s->gen_last_op_idx + 1;\n\n        s->op_count += n;\n\n        if (n > s->op_count_max) {\n\n            s->op_count_max = n;\n\n        }\n\n\n\n        n = s->nb_temps;\n\n        s->temp_count += n;\n\n        if (n > s->temp_count_max) {\n\n            s->temp_count_max = n;\n\n        }\n\n    }\n\n#endif\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP))) {\n\n        qemu_log(\"OP:\\n\");\n\n        tcg_dump_ops(s);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n\n\n#ifdef CONFIG_PROFILER\n\n    s->opt_time -= profile_getclock();\n\n#endif\n\n\n\n#ifdef USE_TCG_OPTIMIZATIONS\n\n    tcg_optimize(s);\n\n#endif\n\n\n\n#ifdef CONFIG_PROFILER\n\n    s->opt_time += profile_getclock();\n\n    s->la_time -= profile_getclock();\n\n#endif\n\n\n\n    tcg_liveness_analysis(s);\n\n\n\n#ifdef CONFIG_PROFILER\n\n    s->la_time += profile_getclock();\n\n#endif\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP_OPT))) {\n\n        qemu_log(\"OP after optimization and liveness analysis:\\n\");\n\n        tcg_dump_ops(s);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n\n\n    tcg_reg_alloc_start(s);\n\n\n\n    s->code_buf = gen_code_buf;\n\n    s->code_ptr = gen_code_buf;\n\n\n\n    tcg_out_tb_init(s);\n\n\n\n    num_insns = -1;\n\n    for (oi = s->gen_first_op_idx; oi >= 0; oi = oi_next) {\n\n        TCGOp * const op = &s->gen_op_buf[oi];\n\n        TCGArg * const args = &s->gen_opparam_buf[op->args];\n\n        TCGOpcode opc = op->opc;\n\n        const TCGOpDef *def = &tcg_op_defs[opc];\n\n        uint16_t dead_args = s->op_dead_args[oi];\n\n        uint8_t sync_args = s->op_sync_args[oi];\n\n\n\n        oi_next = op->next;\n\n#ifdef CONFIG_PROFILER\n\n        tcg_table_op_count[opc]++;\n\n#endif\n\n\n\n        switch (opc) {\n\n        case INDEX_op_mov_i32:\n\n        case INDEX_op_mov_i64:\n\n            tcg_reg_alloc_mov(s, def, args, dead_args, sync_args);\n\n            break;\n\n        case INDEX_op_movi_i32:\n\n        case INDEX_op_movi_i64:\n\n            tcg_reg_alloc_movi(s, args, dead_args, sync_args);\n\n            break;\n\n        case INDEX_op_insn_start:\n\n            if (num_insns >= 0) {\n\n                s->gen_insn_end_off[num_insns] = tcg_current_code_size(s);\n\n            }\n\n            num_insns++;\n\n            for (i = 0; i < TARGET_INSN_START_WORDS; ++i) {\n\n                target_ulong a;\n\n#if TARGET_LONG_BITS > TCG_TARGET_REG_BITS\n\n                a = ((target_ulong)args[i * 2 + 1] << 32) | args[i * 2];\n\n#else\n\n                a = args[i];\n\n#endif\n\n                s->gen_insn_data[num_insns][i] = a;\n\n            }\n\n            break;\n\n        case INDEX_op_discard:\n\n            temp_dead(s, args[0]);\n\n            break;\n\n        case INDEX_op_set_label:\n\n            tcg_reg_alloc_bb_end(s, s->reserved_regs);\n\n            tcg_out_label(s, arg_label(args[0]), s->code_ptr);\n\n            break;\n\n        case INDEX_op_call:\n\n            tcg_reg_alloc_call(s, op->callo, op->calli, args,\n\n                               dead_args, sync_args);\n\n            break;\n\n        default:\n\n            /* Sanity check that we've not introduced any unhandled opcodes. */\n\n            if (def->flags & TCG_OPF_NOT_PRESENT) {\n\n                tcg_abort();\n\n            }\n\n            /* Note: in order to speed up the code, it would be much\n\n               faster to have specialized register allocator functions for\n\n               some common argument patterns */\n\n            tcg_reg_alloc_op(s, def, opc, args, dead_args, sync_args);\n\n            break;\n\n        }\n\n#ifndef NDEBUG\n\n        check_regs(s);\n\n#endif\n\n        /* Test for (pending) buffer overflow.  The assumption is that any\n\n           one operation beginning below the high water mark cannot overrun\n\n           the buffer completely.  Thus we can test for overflow after\n\n           generating code without having to check during generation.  */\n\n        if (unlikely((void *)s->code_ptr > s->code_gen_highwater)) {\n\n            return -1;\n\n        }\n\n    }\n\n    tcg_debug_assert(num_insns >= 0);\n\n    s->gen_insn_end_off[num_insns] = tcg_current_code_size(s);\n\n\n\n    /* Generate TB finalization at the end of block */\n\n    tcg_out_tb_finalize(s);\n\n\n\n    /* flush instruction cache */\n\n    flush_icache_range((uintptr_t)s->code_buf, (uintptr_t)s->code_ptr);\n\n\n\n    return tcg_current_code_size(s);\n\n}\n", "idx": 15067, "_split": "test", "_hash": "b84199f9e67585045dbf3aee3644c33a"}
{"project": "qemu", "commit_id": "68d553587c0aa271c3eb2902921b503740d775b6", "target": 0, "func": "static int ehci_process_itd(EHCIState *ehci,\n\n                            EHCIitd *itd)\n\n{\n\n    USBPort *port;\n\n    USBDevice *dev;\n\n    int ret;\n\n    uint32_t i, j, len, pid, dir, devaddr, endp;\n\n    uint32_t pg, off, ptr1, ptr2, max, mult;\n\n\n\n    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);\n\n    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);\n\n    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);\n\n    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);\n\n    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);\n\n\n\n    for(i = 0; i < 8; i++) {\n\n        if (itd->transact[i] & ITD_XACT_ACTIVE) {\n\n            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);\n\n            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;\n\n            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);\n\n            ptr2 = (itd->bufptr[pg+1] & ITD_BUFPTR_MASK);\n\n            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);\n\n\n\n            if (len > max * mult) {\n\n                len = max * mult;\n\n            }\n\n\n\n            if (len > BUFF_SIZE) {\n\n                return USB_RET_PROCERR;\n\n            }\n\n\n\n            qemu_sglist_init(&ehci->isgl, 2);\n\n            if (off + len > 4096) {\n\n                /* transfer crosses page border */\n\n                uint32_t len2 = off + len - 4096;\n\n                uint32_t len1 = len - len2;\n\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);\n\n                qemu_sglist_add(&ehci->isgl, ptr2, len2);\n\n            } else {\n\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);\n\n            }\n\n\n\n            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;\n\n\n\n            usb_packet_setup(&ehci->ipacket, pid, devaddr, endp);\n\n            usb_packet_map(&ehci->ipacket, &ehci->isgl);\n\n\n\n            ret = USB_RET_NODEV;\n\n            for (j = 0; j < NB_PORTS; j++) {\n\n                port = &ehci->ports[j];\n\n                dev = port->dev;\n\n\n\n                if (!(ehci->portsc[j] &(PORTSC_CONNECT))) {\n\n                    continue;\n\n                }\n\n\n\n                ret = usb_handle_packet(dev, &ehci->ipacket);\n\n\n\n                if (ret != USB_RET_NODEV) {\n\n                    break;\n\n                }\n\n            }\n\n\n\n            usb_packet_unmap(&ehci->ipacket);\n\n            qemu_sglist_destroy(&ehci->isgl);\n\n\n\n#if 0\n\n            /*  In isoch, there is no facility to indicate a NAK so let's\n\n             *  instead just complete a zero-byte transaction.  Setting\n\n             *  DBERR seems too draconian.\n\n             */\n\n\n\n            if (ret == USB_RET_NAK) {\n\n                if (ehci->isoch_pause > 0) {\n\n                    DPRINTF(\"ISOCH: received a NAK but paused so returning\\n\");\n\n                    ehci->isoch_pause--;\n\n                    return 0;\n\n                } else if (ehci->isoch_pause == -1) {\n\n                    DPRINTF(\"ISOCH: recv NAK & isoch pause inactive, setting\\n\");\n\n                    // Pause frindex for up to 50 msec waiting for data from\n\n                    // remote\n\n                    ehci->isoch_pause = 50;\n\n                    return 0;\n\n                } else {\n\n                    DPRINTF(\"ISOCH: isoch pause timeout! return 0\\n\");\n\n                    ret = 0;\n\n                }\n\n            } else {\n\n                DPRINTF(\"ISOCH: received ACK, clearing pause\\n\");\n\n                ehci->isoch_pause = -1;\n\n            }\n\n#else\n\n            if (ret == USB_RET_NAK) {\n\n                ret = 0;\n\n            }\n\n#endif\n\n\n\n            if (ret >= 0) {\n\n                if (!dir) {\n\n                    /* OUT */\n\n                    set_field(&itd->transact[i], len - ret, ITD_XACT_LENGTH);\n\n                } else {\n\n                    /* IN */\n\n                    set_field(&itd->transact[i], ret, ITD_XACT_LENGTH);\n\n                }\n\n\n\n                if (itd->transact[i] & ITD_XACT_IOC) {\n\n                    ehci_record_interrupt(ehci, USBSTS_INT);\n\n                }\n\n            }\n\n            itd->transact[i] &= ~ITD_XACT_ACTIVE;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 15077, "_split": "test", "_hash": "d624bd5001427d2fa684ee6fa821e895"}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_input_pop(Visitor *v, void **obj)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    StackObject *tos = QSLIST_FIRST(&qiv->stack);\n\n\n\n    assert(tos && tos->qapi == obj);\n\n    QSLIST_REMOVE_HEAD(&qiv->stack, node);\n\n    qmp_input_stack_object_free(tos);\n\n}\n", "idx": 15082, "_split": "test", "_hash": "3d88608e5fa824344391b2edefa2a9ac"}
{"project": "qemu", "commit_id": "4a1cba3802554a3b077d436002519ff1fb0c18bf", "target": 1, "func": "bool aio_poll(AioContext *ctx, bool blocking)\n\n{\n\n    AioHandler *node;\n\n    int i, ret;\n\n    bool progress;\n\n    int64_t timeout;\n\n\n\n    aio_context_acquire(ctx);\n\n    progress = false;\n\n\n\n    /* aio_notify can avoid the expensive event_notifier_set if\n\n     * everything (file descriptors, bottom halves, timers) will\n\n     * be re-evaluated before the next blocking poll().  This is\n\n     * already true when aio_poll is called with blocking == false;\n\n     * if blocking == true, it is only true after poll() returns,\n\n     * so disable the optimization now.\n\n     */\n\n    if (blocking) {\n\n        atomic_add(&ctx->notify_me, 2);\n\n    }\n\n\n\n    ctx->walking_handlers++;\n\n\n\n    assert(npfd == 0);\n\n\n\n    /* fill pollfds */\n\n\n\n    if (!aio_epoll_enabled(ctx)) {\n\n        QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n            if (!node->deleted && node->pfd.events\n\n                && aio_node_check(ctx, node->is_external)) {\n\n                add_pollfd(node);\n\n            }\n\n        }\n\n    }\n\n\n\n    timeout = blocking ? aio_compute_timeout(ctx) : 0;\n\n\n\n    /* wait until next event */\n\n    if (timeout) {\n\n        aio_context_release(ctx);\n\n    }\n\n    if (aio_epoll_check_poll(ctx, pollfds, npfd, timeout)) {\n\n        AioHandler epoll_handler;\n\n\n\n        epoll_handler.pfd.fd = ctx->epollfd;\n\n        epoll_handler.pfd.events = G_IO_IN | G_IO_OUT | G_IO_HUP | G_IO_ERR;\n\n        npfd = 0;\n\n        add_pollfd(&epoll_handler);\n\n        ret = aio_epoll(ctx, pollfds, npfd, timeout);\n\n    } else  {\n\n        ret = qemu_poll_ns(pollfds, npfd, timeout);\n\n    }\n\n    if (blocking) {\n\n        atomic_sub(&ctx->notify_me, 2);\n\n    }\n\n    if (timeout) {\n\n        aio_context_acquire(ctx);\n\n    }\n\n\n\n    aio_notify_accept(ctx);\n\n\n\n    /* if we have any readable fds, dispatch event */\n\n    if (ret > 0) {\n\n        for (i = 0; i < npfd; i++) {\n\n            nodes[i]->pfd.revents = pollfds[i].revents;\n\n        }\n\n    }\n\n\n\n    npfd = 0;\n\n    ctx->walking_handlers--;\n\n\n\n    /* Run dispatch even if there were no readable fds to run timers */\n\n    if (aio_dispatch(ctx, ret > 0)) {\n\n        progress = true;\n\n    }\n\n\n\n    aio_context_release(ctx);\n\n\n\n    return progress;\n\n}\n", "idx": 15115, "_split": "test", "_hash": "ef2bb710902a3c72bd123e0f35ad31e9"}
{"project": "qemu", "commit_id": "9e559533bd825a3e371497875576137a8586c831", "target": 1, "func": "static void aio_read_done(void *opaque, int ret)\n\n{\n\n    struct aio_ctx *ctx = opaque;\n\n    struct timeval t2;\n\n\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"readv failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->Pflag) {\n\n        void *cmp_buf = g_malloc(ctx->qiov.size);\n\n\n\n        memset(cmp_buf, ctx->pattern, ctx->qiov.size);\n\n        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {\n\n            printf(\"Pattern verification failed at offset %\"\n\n                   PRId64 \", %zd bytes\\n\", ctx->offset, ctx->qiov.size);\n\n        }\n\n        g_free(cmp_buf);\n\n    }\n\n\n\n    if (ctx->qflag) {\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->vflag) {\n\n        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, ctx->t1);\n\n    print_report(\"read\", &t2, ctx->offset, ctx->qiov.size,\n\n                 ctx->qiov.size, 1, ctx->Cflag);\n\nout:\n\n    qemu_io_free(ctx->buf);\n\n\n    g_free(ctx);\n\n}", "idx": 15132, "_split": "test", "_hash": "07410052dbbd766e947cce92b2fc2393"}
{"project": "qemu", "commit_id": "3f2cbf0d1a1340bed4a63e05b044c46df93f4768", "target": 1, "func": "target_phys_addr_t cpu_get_phys_page_debug(CPUState *env, target_ulong addr)\n\n{\n\n    target_ulong pde_addr, pte_addr;\n\n    uint64_t pte;\n\n    target_phys_addr_t paddr;\n\n    uint32_t page_offset;\n\n    int page_size;\n\n\n\n    if (env->cr[4] & CR4_PAE_MASK) {\n\n        target_ulong pdpe_addr;\n\n        uint64_t pde, pdpe;\n\n\n\n#ifdef TARGET_X86_64\n\n        if (env->hflags & HF_LMA_MASK) {\n\n            uint64_t pml4e_addr, pml4e;\n\n            int32_t sext;\n\n\n\n            /* test virtual address sign extension */\n\n            sext = (int64_t)addr >> 47;\n\n            if (sext != 0 && sext != -1)\n\n                return -1;\n\n\n\n            pml4e_addr = ((env->cr[3] & ~0xfff) + (((addr >> 39) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            pml4e = ldq_phys(pml4e_addr);\n\n            if (!(pml4e & PG_PRESENT_MASK))\n\n                return -1;\n\n\n\n            pdpe_addr = ((pml4e & ~0xfff) + (((addr >> 30) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            pdpe = ldq_phys(pdpe_addr);\n\n            if (!(pdpe & PG_PRESENT_MASK))\n\n                return -1;\n\n        } else\n\n#endif\n\n        {\n\n            pdpe_addr = ((env->cr[3] & ~0x1f) + ((addr >> 27) & 0x18)) &\n\n                env->a20_mask;\n\n            pdpe = ldq_phys(pdpe_addr);\n\n            if (!(pdpe & PG_PRESENT_MASK))\n\n                return -1;\n\n        }\n\n\n\n        pde_addr = ((pdpe & ~0xfff) + (((addr >> 21) & 0x1ff) << 3)) &\n\n            env->a20_mask;\n\n        pde = ldq_phys(pde_addr);\n\n        if (!(pde & PG_PRESENT_MASK)) {\n\n            return -1;\n\n        }\n\n        if (pde & PG_PSE_MASK) {\n\n            /* 2 MB page */\n\n            page_size = 2048 * 1024;\n\n            pte = pde & ~( (page_size - 1) & ~0xfff); /* align to page_size */\n\n        } else {\n\n            /* 4 KB page */\n\n            pte_addr = ((pde & ~0xfff) + (((addr >> 12) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            page_size = 4096;\n\n            pte = ldq_phys(pte_addr);\n\n        }\n\n        if (!(pte & PG_PRESENT_MASK))\n\n            return -1;\n\n    } else {\n\n        uint32_t pde;\n\n\n\n        if (!(env->cr[0] & CR0_PG_MASK)) {\n\n            pte = addr;\n\n            page_size = 4096;\n\n        } else {\n\n            /* page directory entry */\n\n            pde_addr = ((env->cr[3] & ~0xfff) + ((addr >> 20) & 0xffc)) & env->a20_mask;\n\n            pde = ldl_phys(pde_addr);\n\n            if (!(pde & PG_PRESENT_MASK))\n\n                return -1;\n\n            if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {\n\n                pte = pde & ~0x003ff000; /* align to 4MB */\n\n                page_size = 4096 * 1024;\n\n            } else {\n\n                /* page directory entry */\n\n                pte_addr = ((pde & ~0xfff) + ((addr >> 10) & 0xffc)) & env->a20_mask;\n\n                pte = ldl_phys(pte_addr);\n\n                if (!(pte & PG_PRESENT_MASK))\n\n                    return -1;\n\n                page_size = 4096;\n\n            }\n\n        }\n\n        pte = pte & env->a20_mask;\n\n    }\n\n\n\n    page_offset = (addr & TARGET_PAGE_MASK) & (page_size - 1);\n\n    paddr = (pte & TARGET_PAGE_MASK) + page_offset;\n\n    return paddr;\n\n}\n", "idx": 15136, "_split": "test", "_hash": "1ff0133c13f26c2f125c9c89b0e53bea"}
{"project": "qemu", "commit_id": "3a3b8502e6f0c8d30865c5f36d2c3ae4114000b5", "target": 1, "func": "void spapr_pci_rtas_init(void)\n\n{\n\n    spapr_rtas_register(\"read-pci-config\", rtas_read_pci_config);\n\n    spapr_rtas_register(\"write-pci-config\", rtas_write_pci_config);\n\n    spapr_rtas_register(\"ibm,read-pci-config\", rtas_ibm_read_pci_config);\n\n    spapr_rtas_register(\"ibm,write-pci-config\", rtas_ibm_write_pci_config);\n\n    if (msi_supported) {\n\n        spapr_rtas_register(\"ibm,query-interrupt-source-number\",\n\n                            rtas_ibm_query_interrupt_source_number);\n\n        spapr_rtas_register(\"ibm,change-msi\", rtas_ibm_change_msi);\n\n    }\n\n}\n", "idx": 15147, "_split": "test", "_hash": "67d405bae877a8dffc8e86fd928c6da7"}
{"project": "qemu", "commit_id": "8ec14402029d783720f4312ed8a925548e1dad61", "target": 0, "func": "static void compare_sec_rs_finalize(SocketReadState *sec_rs)\n\n{\n\n    CompareState *s = container_of(sec_rs, CompareState, sec_rs);\n\n\n\n    if (packet_enqueue(s, SECONDARY_IN)) {\n\n        trace_colo_compare_main(\"secondary: unsupported packet in\");\n\n    } else {\n\n        /* compare connection */\n\n        g_queue_foreach(&s->conn_list, colo_compare_connection, s);\n\n    }\n\n}\n", "idx": 15173, "_split": "test", "_hash": "4b75af8b164f07dbf84e23e2656a34fc"}
{"project": "qemu", "commit_id": "b47b35250fbfa062aedf6ab6e5faab84c4a76f4f", "target": 1, "func": "FDCtrl *fdctrl_init_isa(DriveInfo **fds)\n\n{\n\n    ISADevice *dev;\n\n\n\n    dev = isa_create(\"isa-fdc\");\n\n    if (fds[0]) {\n\n        qdev_prop_set_drive_nofail(&dev->qdev, \"driveA\", fds[0]->bdrv);\n\n    }\n\n    if (fds[1]) {\n\n        qdev_prop_set_drive_nofail(&dev->qdev, \"driveB\", fds[1]->bdrv);\n\n    }\n\n    if (qdev_init(&dev->qdev) < 0)\n\n        return NULL;\n\n    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);\n\n}\n", "idx": 15201, "_split": "test", "_hash": "c5b7ffe7951f130785953114cb3b81cc"}
{"project": "qemu", "commit_id": "c0f4af171999eda4e49de5169906ce98246457f0", "target": 1, "func": "void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)\n{\n    const ARMCPRegInfo *ri = rip;\n    switch (ri->accessfn(env, ri)) {\n    case CP_ACCESS_OK:\n    case CP_ACCESS_TRAP:\n        break;\n    case CP_ACCESS_TRAP_UNCATEGORIZED:\n        env->exception.syndrome = syn_uncategorized();\n        break;\n    default:\n        g_assert_not_reached();", "idx": 15209, "_split": "test", "_hash": "985ec0026309aeb82a908d7b631e0db5"}
{"project": "qemu", "commit_id": "b7c8c35f0afb62efcacd18a64067fe164e3206b6", "target": 1, "func": "static char *scsibus_get_dev_path(DeviceState *dev)\n\n{\n\n    SCSIDevice *d = DO_UPCAST(SCSIDevice, qdev, dev);\n\n    DeviceState *hba = dev->parent_bus->parent;\n\n    char *id = NULL;\n\n\n\n    if (hba && hba->parent_bus && hba->parent_bus->info->get_dev_path) {\n\n        id = hba->parent_bus->info->get_dev_path(hba);\n\n    }\n\n    if (id) {\n\n        return g_strdup_printf(\"%s/%d:%d:%d\", id, d->channel, d->id, d->lun);\n\n    } else {\n\n        return g_strdup_printf(\"%d:%d:%d\", d->channel, d->id, d->lun);\n\n    }\n\n}\n", "idx": 15239, "_split": "test", "_hash": "484e2c17ed962643e3cd647744c1a3c1"}
{"project": "qemu", "commit_id": "8de433cb0820dc1f387a2d580d255744aacd60cc", "target": 1, "func": "void pc_hot_add_cpu(const int64_t id, Error **errp)\n{\n    DeviceState *icc_bridge;\n    int64_t apic_id = x86_cpu_apic_id_from_index(id);\n    if (cpu_exists(apic_id)) {\n        error_setg(errp, \"Unable to add CPU: %\" PRIi64\n                   \", it already exists\", id);\n    if (id >= max_cpus) {\n        error_setg(errp, \"Unable to add CPU: %\" PRIi64\n                   \", max allowed: %d\", id, max_cpus - 1);\n    icc_bridge = DEVICE(object_resolve_path_type(\"icc-bridge\",\n                                                 TYPE_ICC_BRIDGE, NULL));\n    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);", "idx": 15260, "_split": "test", "_hash": "69fa2024c7c09cfc3c3469b211e75d7a"}
{"project": "qemu", "commit_id": "5b4a047fbe8ceb68ad1a78d51f0fadbe2bb12af7", "target": 1, "func": "static void xlnx_ep108_init(MachineState *machine)\n\n{\n\n    XlnxEP108 *s = g_new0(XlnxEP108, 1);\n\n    Error *err = NULL;\n\n\n\n    object_initialize(&s->soc, sizeof(s->soc), TYPE_XLNX_ZYNQMP);\n\n    object_property_add_child(OBJECT(machine), \"soc\", OBJECT(&s->soc),\n\n                              &error_abort);\n\n\n\n    object_property_set_bool(OBJECT(&s->soc), true, \"realized\", &err);\n\n    if (err) {\n\n        error_report(\"%s\", error_get_pretty(err));\n\n        exit(1);\n\n    }\n\n\n\n    if (machine->ram_size > EP108_MAX_RAM_SIZE) {\n\n        error_report(\"WARNING: RAM size \" RAM_ADDR_FMT \" above max supported, \"\n\n                     \"reduced to %llx\", machine->ram_size, EP108_MAX_RAM_SIZE);\n\n        machine->ram_size = EP108_MAX_RAM_SIZE;\n\n    }\n\n\n\n    if (machine->ram_size <= 0x08000000) {\n\n        qemu_log(\"WARNING: RAM size \" RAM_ADDR_FMT \" is small for EP108\",\n\n                 machine->ram_size);\n\n    }\n\n\n\n    memory_region_allocate_system_memory(&s->ddr_ram, NULL, \"ddr-ram\",\n\n                                         machine->ram_size);\n\n    memory_region_add_subregion(get_system_memory(), 0, &s->ddr_ram);\n\n\n\n    xlnx_ep108_binfo.ram_size = machine->ram_size;\n\n    xlnx_ep108_binfo.kernel_filename = machine->kernel_filename;\n\n    xlnx_ep108_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    xlnx_ep108_binfo.initrd_filename = machine->initrd_filename;\n\n    xlnx_ep108_binfo.loader_start = 0;\n\n    arm_load_kernel(s->soc.boot_cpu_ptr, &xlnx_ep108_binfo);\n\n}\n", "idx": 15288, "_split": "test", "_hash": "59b9c6433c084e3f156958686679c48f"}
{"project": "qemu", "commit_id": "a5cf8262e4eb9c4646434e2c6211ef8608db3233", "target": 0, "func": "static char *pcibus_get_fw_dev_path(DeviceState *dev)\n\n{\n\n    PCIDevice *d = (PCIDevice *)dev;\n\n    char path[50], name[33];\n\n    int off;\n\n\n\n    off = snprintf(path, sizeof(path), \"%s@%x\",\n\n                   pci_dev_fw_name(dev, name, sizeof name),\n\n                   PCI_SLOT(d->devfn));\n\n    if (PCI_FUNC(d->devfn))\n\n        snprintf(path + off, sizeof(path) + off, \",%x\", PCI_FUNC(d->devfn));\n\n    return strdup(path);\n\n}\n", "idx": 15341, "_split": "test", "_hash": "1e5af9b229d4ec7686049f5814f91349"}
{"project": "qemu", "commit_id": "f69a8bde29354493ff8aea64cc9cb3b531d16337", "target": 1, "func": "static int qio_channel_websock_handshake_send_response(QIOChannelWebsock *ioc,\n\n                                                       const char *key,\n\n                                                       Error **errp)\n\n{\n\n    char combined_key[QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +\n\n                      QIO_CHANNEL_WEBSOCK_GUID_LEN + 1];\n\n    char *accept = NULL, *response = NULL;\n\n    size_t responselen;\n\n\n\n    g_strlcpy(combined_key, key, QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN + 1);\n\n    g_strlcat(combined_key, QIO_CHANNEL_WEBSOCK_GUID,\n\n              QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +\n\n              QIO_CHANNEL_WEBSOCK_GUID_LEN + 1);\n\n\n\n    /* hash and encode it */\n\n    if (qcrypto_hash_base64(QCRYPTO_HASH_ALG_SHA1,\n\n                            combined_key,\n\n                            QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +\n\n                            QIO_CHANNEL_WEBSOCK_GUID_LEN,\n\n                            &accept,\n\n                            errp) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    response = g_strdup_printf(QIO_CHANNEL_WEBSOCK_HANDSHAKE_RESPONSE, accept);\n\n    responselen = strlen(response);\n\n    buffer_reserve(&ioc->encoutput, responselen);\n\n    buffer_append(&ioc->encoutput, response, responselen);\n\n\n\n    g_free(accept);\n\n    g_free(response);\n\n\n\n    return 0;\n\n}\n", "idx": 15368, "_split": "test", "_hash": "64c8685a2bada22d1f649981d34f49bc"}
{"project": "qemu", "commit_id": "50628d3479e4f9aa97e323506856e394fe7ad7a6", "target": 1, "func": "void dpy_gfx_copy(QemuConsole *con, int src_x, int src_y,\n\n                  int dst_x, int dst_y, int w, int h)\n\n{\n\n    DisplayState *s = con->ds;\n\n    DisplayChangeListener *dcl;\n\n\n\n    if (!qemu_console_is_visible(con)) {\n\n        return;\n\n    }\n\n    QLIST_FOREACH(dcl, &s->listeners, next) {\n\n        if (con != (dcl->con ? dcl->con : active_console)) {\n\n            continue;\n\n        }\n\n        if (dcl->ops->dpy_gfx_copy) {\n\n            dcl->ops->dpy_gfx_copy(dcl, src_x, src_y, dst_x, dst_y, w, h);\n\n        } else { /* TODO */\n\n            dcl->ops->dpy_gfx_update(dcl, dst_x, dst_y, w, h);\n\n        }\n\n    }\n\n}\n", "idx": 15373, "_split": "test", "_hash": "d8d8fda278dd8844dd3903240d02668b"}
{"project": "qemu", "commit_id": "3c94193e0bbdd855bcbedabd27e3cbe1e6bc6242", "target": 1, "func": "static TCGArg *tcg_constant_folding(TCGContext *s, uint16_t *tcg_opc_ptr,\n                                    TCGArg *args, TCGOpDef *tcg_op_defs)\n{\n    int i, nb_ops, op_index, nb_temps, nb_globals, nb_call_args;\n    TCGOpcode op;\n    const TCGOpDef *def;\n    TCGArg *gen_args;\n    TCGArg tmp;\n    TCGCond cond;\n    /* Array VALS has an element for each temp.\n       If this temp holds a constant then its value is kept in VALS' element.\n       If this temp is a copy of other ones then the other copies are\n       available through the doubly linked circular list. */\n    nb_temps = s->nb_temps;\n    nb_globals = s->nb_globals;\n    memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n    nb_ops = tcg_opc_ptr - gen_opc_buf;\n    gen_args = args;\n    for (op_index = 0; op_index < nb_ops; op_index++) {\n        op = gen_opc_buf[op_index];\n        def = &tcg_op_defs[op];\n        /* Do copy propagation */\n        if (op == INDEX_op_call) {\n            int nb_oargs = args[0] >> 16;\n            int nb_iargs = args[0] & 0xffff;\n            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {\n                if (temps[args[i]].state == TCG_TEMP_COPY) {\n                    args[i] = find_better_copy(s, args[i]);\n        } else {\n            for (i = def->nb_oargs; i < def->nb_oargs + def->nb_iargs; i++) {\n                if (temps[args[i]].state == TCG_TEMP_COPY) {\n                    args[i] = find_better_copy(s, args[i]);\n        /* For commutative operations make constant second argument */\n        CASE_OP_32_64(add):\n        CASE_OP_32_64(mul):\n        CASE_OP_32_64(and):\n        CASE_OP_32_64(or):\n        CASE_OP_32_64(eqv):\n        CASE_OP_32_64(nand):\n        CASE_OP_32_64(nor):\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n                tmp = args[1];\n                args[1] = args[2];\n                args[2] = tmp;\n        CASE_OP_32_64(brcond):\n            if (temps[args[0]].state == TCG_TEMP_CONST\n                && temps[args[1]].state != TCG_TEMP_CONST) {\n                tmp = args[0];\n                args[0] = args[1];\n                args[1] = tmp;\n                args[2] = tcg_swap_cond(args[2]);\n        CASE_OP_32_64(setcond):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state != TCG_TEMP_CONST) {\n                tmp = args[1];\n                args[1] = args[2];\n                args[2] = tmp;\n                args[3] = tcg_swap_cond(args[3]);\n        CASE_OP_32_64(movcond):\n            cond = args[5];\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state != TCG_TEMP_CONST) {\n                tmp = args[1];\n                args[1] = args[2];\n                args[2] = tmp;\n                cond = tcg_swap_cond(cond);\n            /* For movcond, we canonicalize the \"false\" input reg to match\n               the destination reg so that the tcg backend can implement\n               a \"move if true\" operation.  */\n            if (args[0] == args[3]) {\n                tmp = args[3];\n                args[3] = args[4];\n                args[4] = tmp;\n                cond = tcg_invert_cond(cond);\n            args[5] = cond;\n        /* Simplify expressions for \"shift/rot r, 0, a => movi r, 0\" */\n        CASE_OP_32_64(shl):\n        CASE_OP_32_64(shr):\n        CASE_OP_32_64(sar):\n        CASE_OP_32_64(rotl):\n        CASE_OP_32_64(rotr):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[1]].val == 0) {\n        /* Simplify expression for \"op r, a, 0 => mov r, a\" cases */\n        CASE_OP_32_64(add):\n        CASE_OP_32_64(shl):\n        CASE_OP_32_64(shr):\n        CASE_OP_32_64(sar):\n        CASE_OP_32_64(rotl):\n        CASE_OP_32_64(rotr):\n        CASE_OP_32_64(or):\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n                /* Proceed with possible constant folding. */\n            if (temps[args[2]].state == TCG_TEMP_CONST\n                && temps[args[2]].val == 0) {\n                if (temps_are_copies(args[0], args[1])) {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n                } else {\n                    gen_opc_buf[op_index] = op_to_mov(op);\n                    tcg_opt_gen_mov(s, gen_args, args[0], args[1]);\n        /* Simplify expression for \"op r, a, 0 => movi r, 0\" cases */\n        CASE_OP_32_64(and):\n        CASE_OP_32_64(mul):\n            if ((temps[args[2]].state == TCG_TEMP_CONST\n                && temps[args[2]].val == 0)) {\n        /* Simplify expression for \"op r, a, a => mov r, a\" cases */\n        CASE_OP_32_64(or):\n        CASE_OP_32_64(and):\n                if (temps_are_copies(args[0], args[1])) {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n                } else {\n                    gen_opc_buf[op_index] = op_to_mov(op);\n                    tcg_opt_gen_mov(s, gen_args, args[0], args[1]);\n        /* Propagate constants through copy operations and do constant\n           folding.  Constants will be substituted to arguments by register\n           allocator where needed and possible.  Also detect copies. */\n        CASE_OP_32_64(mov):\n            if (temps_are_copies(args[0], args[1])) {\n                args += 2;\n                gen_opc_buf[op_index] = INDEX_op_nop;\n            if (temps[args[1]].state != TCG_TEMP_CONST) {\n                tcg_opt_gen_mov(s, gen_args, args[0], args[1]);\n                args += 2;\n            /* Source argument is constant.  Rewrite the operation and\n               let movi case handle it. */\n            op = op_to_movi(op);\n            gen_opc_buf[op_index] = op;\n            args[1] = temps[args[1]].val;\n            /* fallthrough */\n        CASE_OP_32_64(movi):\n            tcg_opt_gen_movi(gen_args, args[0], args[1]);\n            args += 2;\n        CASE_OP_32_64(not):\n        CASE_OP_32_64(neg):\n        CASE_OP_32_64(ext8s):\n        CASE_OP_32_64(ext8u):\n        CASE_OP_32_64(ext16s):\n        CASE_OP_32_64(ext16u):\n        case INDEX_op_ext32s_i64:\n        case INDEX_op_ext32u_i64:\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding(op, temps[args[1]].val, 0);\n                tcg_opt_gen_movi(gen_args, args[0], tmp);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n            args += 2;\n        CASE_OP_32_64(add):\n        CASE_OP_32_64(mul):\n        CASE_OP_32_64(or):\n        CASE_OP_32_64(and):\n        CASE_OP_32_64(shl):\n        CASE_OP_32_64(shr):\n        CASE_OP_32_64(sar):\n        CASE_OP_32_64(rotl):\n        CASE_OP_32_64(rotr):\n        CASE_OP_32_64(andc):\n        CASE_OP_32_64(orc):\n        CASE_OP_32_64(eqv):\n        CASE_OP_32_64(nand):\n        CASE_OP_32_64(nor):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding(op, temps[args[1]].val,\n                                          temps[args[2]].val);\n                tcg_opt_gen_movi(gen_args, args[0], tmp);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args += 3;\n        CASE_OP_32_64(setcond):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding_cond(op, temps[args[1]].val,\n                                               temps[args[2]].val, args[3]);\n                tcg_opt_gen_movi(gen_args, args[0], tmp);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args[3] = args[3];\n                gen_args += 4;\n            args += 4;\n        CASE_OP_32_64(brcond):\n            if (temps[args[0]].state == TCG_TEMP_CONST\n                && temps[args[1]].state == TCG_TEMP_CONST) {\n                if (do_constant_folding_cond(op, temps[args[0]].val,\n                                             temps[args[1]].val, args[2])) {\n                    memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n                    gen_opc_buf[op_index] = INDEX_op_br;\n                    gen_args[0] = args[3];\n                    gen_args += 1;\n                } else {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n            } else {\n                memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args[3] = args[3];\n                gen_args += 4;\n            args += 4;\n        CASE_OP_32_64(movcond):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding_cond(op, temps[args[1]].val,\n                                               temps[args[2]].val, args[5]);\n                if (temps_are_copies(args[0], args[4-tmp])) {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n                } else if (temps[args[4-tmp]].state == TCG_TEMP_CONST) {\n                    tcg_opt_gen_movi(gen_args, args[0], temps[args[4-tmp]].val);\n                } else {\n                    gen_opc_buf[op_index] = op_to_mov(op);\n                    tcg_opt_gen_mov(s, gen_args, args[0], args[4-tmp]);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args[3] = args[3];\n                gen_args[4] = args[4];\n                gen_args[5] = args[5];\n                gen_args += 6;\n            args += 6;\n        case INDEX_op_call:\n            nb_call_args = (args[0] >> 16) + (args[0] & 0xffff);\n            if (!(args[nb_call_args + 1] & (TCG_CALL_CONST | TCG_CALL_PURE))) {\n                for (i = 0; i < nb_globals; i++) {\n                    reset_temp(i);\n            for (i = 0; i < (args[0] >> 16); i++) {\n                reset_temp(args[i + 1]);\n            i = nb_call_args + 3;\n            while (i) {\n                *gen_args = *args;\n                args++;\n                gen_args++;\n                i--;\n            /* Default case: we do know nothing about operation so no\n               propagation is done.  We trash everything if the operation\n               is the end of a basic block, otherwise we only trash the\n               output args.  */\n            if (def->flags & TCG_OPF_BB_END) {\n                memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n            } else {\n                for (i = 0; i < def->nb_oargs; i++) {\n                    reset_temp(args[i]);\n            for (i = 0; i < def->nb_args; i++) {\n                gen_args[i] = args[i];\n            args += def->nb_args;\n            gen_args += def->nb_args;\n    return gen_args;", "idx": 15388, "_split": "test", "_hash": "cdcb3c85bb75b04ce0a850d711255800"}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "static void vnc_connect(VncDisplay *vd, int csock,\n\n                        bool skipauth, bool websocket)\n\n{\n\n    VncState *vs = g_malloc0(sizeof(VncState));\n\n    int i;\n\n\n\n    vs->csock = csock;\n\n    vs->vd = vd;\n\n\n\n    if (skipauth) {\n\n\tvs->auth = VNC_AUTH_NONE;\n\n\tvs->subauth = VNC_AUTH_INVALID;\n\n    } else {\n\n        if (websocket) {\n\n            vs->auth = vd->ws_auth;\n\n            vs->subauth = VNC_AUTH_INVALID;\n\n        } else {\n\n            vs->auth = vd->auth;\n\n            vs->subauth = vd->subauth;\n\n        }\n\n    }\n\n    VNC_DEBUG(\"Client sock=%d ws=%d auth=%d subauth=%d\\n\",\n\n              csock, websocket, vs->auth, vs->subauth);\n\n\n\n    vs->lossy_rect = g_malloc0(VNC_STAT_ROWS * sizeof (*vs->lossy_rect));\n\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n\n        vs->lossy_rect[i] = g_malloc0(VNC_STAT_COLS * sizeof (uint8_t));\n\n    }\n\n\n\n    VNC_DEBUG(\"New client on socket %d\\n\", csock);\n\n    update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n\n    qemu_set_nonblock(vs->csock);\n\n    if (websocket) {\n\n        vs->websocket = 1;\n\n        if (vd->ws_tls) {\n\n            qemu_set_fd_handler(vs->csock, vncws_tls_handshake_io, NULL, vs);\n\n        } else {\n\n            qemu_set_fd_handler(vs->csock, vncws_handshake_read, NULL, vs);\n\n        }\n\n    } else\n\n    {\n\n        qemu_set_fd_handler(vs->csock, vnc_client_read, NULL, vs);\n\n    }\n\n\n\n    vnc_client_cache_addr(vs);\n\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_CONNECTED);\n\n    vnc_set_share_mode(vs, VNC_SHARE_MODE_CONNECTING);\n\n\n\n    if (!vs->websocket) {\n\n        vnc_init_state(vs);\n\n    }\n\n\n\n    if (vd->num_connecting > vd->connections_limit) {\n\n        QTAILQ_FOREACH(vs, &vd->clients, next) {\n\n            if (vs->share_mode == VNC_SHARE_MODE_CONNECTING) {\n\n                vnc_disconnect_start(vs);\n\n                return;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 15389, "_split": "test", "_hash": "ce5ff761c24ad4a46bdaccb3a10665f2"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opts_print(QemuOpts *opts, void *dummy)\n\n{\n\n    QemuOpt *opt;\n\n\n\n    fprintf(stderr, \"%s: %s:\", opts->list->name,\n\n            opts->id ? opts->id : \"<noid>\");\n\n    TAILQ_FOREACH(opt, &opts->head, next) {\n\n        fprintf(stderr, \" %s=\\\"%s\\\"\", opt->name, opt->str);\n\n    }\n\n    fprintf(stderr, \"\\n\");\n\n    return 0;\n\n}\n", "idx": 15411, "_split": "test", "_hash": "020a4dee4e1cf369ff8f8bd67cdb83b4"}
{"project": "qemu", "commit_id": "158fd3ce98afd21f2e2639600f6414ea703a9121", "target": 0, "func": "void qemu_run_all_timers(void)\n\n{\n\n    alarm_timer->pending = 0;\n\n\n\n    /* rearm timer, if not periodic */\n\n    if (alarm_timer->expired) {\n\n        alarm_timer->expired = 0;\n\n        qemu_rearm_alarm_timer(alarm_timer);\n\n    }\n\n\n\n    /* vm time timers */\n\n    qemu_run_timers(vm_clock);\n\n    qemu_run_timers(rt_clock);\n\n    qemu_run_timers(host_clock);\n\n}\n", "idx": 15434, "_split": "test", "_hash": "ce0527993ae99a2c26eae4b8140747d4"}
{"project": "qemu", "commit_id": "a2db2a1edd06a50b8a862c654cf993368cf9f1d9", "target": 0, "func": "static struct XenDevice *xen_be_get_xendev(const char *type, int dom, int dev,\n\n                                           struct XenDevOps *ops)\n\n{\n\n    struct XenDevice *xendev;\n\n\n\n    xendev = xen_be_find_xendev(type, dom, dev);\n\n    if (xendev) {\n\n        return xendev;\n\n    }\n\n\n\n    /* init new xendev */\n\n    xendev = g_malloc0(ops->size);\n\n    xendev->type  = type;\n\n    xendev->dom   = dom;\n\n    xendev->dev   = dev;\n\n    xendev->ops   = ops;\n\n\n\n    snprintf(xendev->be, sizeof(xendev->be), \"backend/%s/%d/%d\",\n\n             xendev->type, xendev->dom, xendev->dev);\n\n    snprintf(xendev->name, sizeof(xendev->name), \"%s-%d\",\n\n             xendev->type, xendev->dev);\n\n\n\n    xendev->debug      = debug;\n\n    xendev->local_port = -1;\n\n\n\n    xendev->evtchndev = xen_xc_evtchn_open(NULL, 0);\n\n    if (xendev->evtchndev == XC_HANDLER_INITIAL_VALUE) {\n\n        xen_be_printf(NULL, 0, \"can't open evtchn device\\n\");\n\n        g_free(xendev);\n\n        return NULL;\n\n    }\n\n    fcntl(xc_evtchn_fd(xendev->evtchndev), F_SETFD, FD_CLOEXEC);\n\n\n\n    if (ops->flags & DEVOPS_FLAG_NEED_GNTDEV) {\n\n        xendev->gnttabdev = xen_xc_gnttab_open(NULL, 0);\n\n        if (xendev->gnttabdev == XC_HANDLER_INITIAL_VALUE) {\n\n            xen_be_printf(NULL, 0, \"can't open gnttab device\\n\");\n\n            xc_evtchn_close(xendev->evtchndev);\n\n            g_free(xendev);\n\n            return NULL;\n\n        }\n\n    } else {\n\n        xendev->gnttabdev = XC_HANDLER_INITIAL_VALUE;\n\n    }\n\n\n\n    QTAILQ_INSERT_TAIL(&xendevs, xendev, next);\n\n\n\n    if (xendev->ops->alloc) {\n\n        xendev->ops->alloc(xendev);\n\n    }\n\n\n\n    return xendev;\n\n}\n", "idx": 15449, "_split": "test", "_hash": "9dfb842f7d353e3cfd1debc3da1f26e9"}
{"project": "qemu", "commit_id": "c54616608af442edf4cfb7397a1909c2653efba0", "target": 0, "func": "static void json_message_process_token(JSONLexer *lexer, QString *token, JSONTokenType type, int x, int y)\n\n{\n\n    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);\n\n    QDict *dict;\n\n\n\n    if (type == JSON_OPERATOR) {\n\n        switch (qstring_get_str(token)[0]) {\n\n        case '{':\n\n            parser->brace_count++;\n\n            break;\n\n        case '}':\n\n            parser->brace_count--;\n\n            break;\n\n        case '[':\n\n            parser->bracket_count++;\n\n            break;\n\n        case ']':\n\n            parser->bracket_count--;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n\n\n    dict = qdict_new();\n\n    qdict_put(dict, \"type\", qint_from_int(type));\n\n    QINCREF(token);\n\n    qdict_put(dict, \"token\", token);\n\n    qdict_put(dict, \"x\", qint_from_int(x));\n\n    qdict_put(dict, \"y\", qint_from_int(y));\n\n\n\n    parser->token_size += token->length;\n\n\n\n    qlist_append(parser->tokens, dict);\n\n\n\n    if (type == JSON_ERROR) {\n\n        goto out_emit_bad;\n\n    } else if (parser->brace_count < 0 ||\n\n        parser->bracket_count < 0 ||\n\n        (parser->brace_count == 0 &&\n\n         parser->bracket_count == 0)) {\n\n        goto out_emit;\n\n    } else if (parser->token_size > MAX_TOKEN_SIZE ||\n\n               parser->bracket_count + parser->brace_count > MAX_NESTING) {\n\n        /* Security consideration, we limit total memory allocated per object\n\n         * and the maximum recursion depth that a message can force.\n\n         */\n\n        goto out_emit_bad;\n\n    }\n\n\n\n    return;\n\n\n\nout_emit_bad:\n\n    /*\n\n     * Clear out token list and tell the parser to emit an error\n\n     * indication by passing it a NULL list\n\n     */\n\n    QDECREF(parser->tokens);\n\n    parser->tokens = NULL;\n\nout_emit:\n\n    /* send current list of tokens to parser and reset tokenizer */\n\n    parser->brace_count = 0;\n\n    parser->bracket_count = 0;\n\n    parser->emit(parser, parser->tokens);\n\n    if (parser->tokens) {\n\n        QDECREF(parser->tokens);\n\n    }\n\n    parser->tokens = qlist_new();\n\n    parser->token_size = 0;\n\n}\n", "idx": 15457, "_split": "test", "_hash": "fdf6eb34bcaa05d9da514a772d813612"}
{"project": "qemu", "commit_id": "076b35b5a56bca57c4aa41044ed304fe9c45d6c5", "target": 0, "func": "static void set_memory_options(uint64_t *ram_slots, ram_addr_t *maxram_size)\n\n{\n\n    uint64_t sz;\n\n    const char *mem_str;\n\n    const char *maxmem_str, *slots_str;\n\n    const ram_addr_t default_ram_size = (ram_addr_t)DEFAULT_RAM_SIZE *\n\n                                        1024 * 1024;\n\n    QemuOpts *opts = qemu_find_opts_singleton(\"memory\");\n\n\n\n    sz = 0;\n\n    mem_str = qemu_opt_get(opts, \"size\");\n\n    if (mem_str) {\n\n        if (!*mem_str) {\n\n            error_report(\"missing 'size' option value\");\n\n            exit(EXIT_FAILURE);\n\n        }\n\n\n\n        sz = qemu_opt_get_size(opts, \"size\", ram_size);\n\n\n\n        /* Fix up legacy suffix-less format */\n\n        if (g_ascii_isdigit(mem_str[strlen(mem_str) - 1])) {\n\n            uint64_t overflow_check = sz;\n\n\n\n            sz <<= 20;\n\n            if ((sz >> 20) != overflow_check) {\n\n                error_report(\"too large 'size' option value\");\n\n                exit(EXIT_FAILURE);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* backward compatibility behaviour for case \"-m 0\" */\n\n    if (sz == 0) {\n\n        sz = default_ram_size;\n\n    }\n\n\n\n    sz = QEMU_ALIGN_UP(sz, 8192);\n\n    ram_size = sz;\n\n    if (ram_size != sz) {\n\n        error_report(\"ram size too large\");\n\n        exit(EXIT_FAILURE);\n\n    }\n\n\n\n    /* store value for the future use */\n\n    qemu_opt_set_number(opts, \"size\", ram_size, &error_abort);\n\n    *maxram_size = ram_size;\n\n\n\n    maxmem_str = qemu_opt_get(opts, \"maxmem\");\n\n    slots_str = qemu_opt_get(opts, \"slots\");\n\n    if (maxmem_str && slots_str) {\n\n        uint64_t slots;\n\n\n\n        sz = qemu_opt_get_size(opts, \"maxmem\", 0);\n\n        slots = qemu_opt_get_number(opts, \"slots\", 0);\n\n        if (sz < ram_size) {\n\n            error_report(\"invalid value of -m option maxmem: \"\n\n                         \"maximum memory size (0x%\" PRIx64 \") must be at least \"\n\n                         \"the initial memory size (0x\" RAM_ADDR_FMT \")\",\n\n                         sz, ram_size);\n\n            exit(EXIT_FAILURE);\n\n        } else if (sz > ram_size) {\n\n            if (!slots) {\n\n                error_report(\"invalid value of -m option: maxmem was \"\n\n                             \"specified, but no hotplug slots were specified\");\n\n                exit(EXIT_FAILURE);\n\n            }\n\n        } else if (slots) {\n\n            error_report(\"invalid value of -m option maxmem: \"\n\n                         \"memory slots were specified but maximum memory size \"\n\n                         \"(0x%\" PRIx64 \") is equal to the initial memory size \"\n\n                         \"(0x\" RAM_ADDR_FMT \")\", sz, ram_size);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n\n\n        *maxram_size = sz;\n\n        *ram_slots = slots;\n\n    } else if ((!maxmem_str && slots_str) ||\n\n            (maxmem_str && !slots_str)) {\n\n        error_report(\"invalid -m option value: missing \"\n\n                \"'%s' option\", slots_str ? \"maxmem\" : \"slots\");\n\n        exit(EXIT_FAILURE);\n\n    }\n\n}\n", "idx": 15482, "_split": "test", "_hash": "aceec26184c3907c1c32e7cffbc93639"}
{"project": "qemu", "commit_id": "b9f7855a50a7cbf04454fa84e9d1f333151f2259", "target": 0, "func": "static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    /* We don't actually refresh here, but just return data queried in\n\n     * iscsi_open(): iscsi targets don't change their limits. */\n\n\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;\n\n\n\n    bs->request_alignment = iscsilun->block_size;\n\n\n\n    if (iscsilun->bl.max_xfer_len) {\n\n        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);\n\n    }\n\n\n\n    if (max_xfer_len * iscsilun->block_size < INT_MAX) {\n\n        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->lbp.lbpu) {\n\n        if (iscsilun->bl.max_unmap < 0xffffffff) {\n\n            bs->bl.max_discard =\n\n                sector_limits_lun2qemu(iscsilun->bl.max_unmap, iscsilun);\n\n        }\n\n        bs->bl.discard_alignment =\n\n            sector_limits_lun2qemu(iscsilun->bl.opt_unmap_gran, iscsilun);\n\n    } else {\n\n        bs->bl.discard_alignment = iscsilun->block_size >> BDRV_SECTOR_BITS;\n\n    }\n\n\n\n    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {\n\n        bs->bl.max_pwrite_zeroes =\n\n            iscsilun->bl.max_ws_len * iscsilun->block_size;\n\n    }\n\n    if (iscsilun->lbp.lbpws) {\n\n        bs->bl.pwrite_zeroes_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;\n\n    }\n\n    if (iscsilun->bl.opt_xfer_len &&\n\n        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {\n\n        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *\n\n                                        iscsilun->block_size);\n\n    }\n\n}\n", "idx": 15486, "_split": "test", "_hash": "fefa3d517a5189b72f09d10dac3a7e24"}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *m)\n\n{\n\n    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);\n\n}\n", "idx": 15492, "_split": "test", "_hash": "caed18978afcf5cbd3ff882c8a2494b0"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void ide_atapi_cmd(IDEState *s)\n\n{\n\n    uint8_t *buf;\n\n\n\n    buf = s->io_buffer;\n\n#ifdef DEBUG_IDE_ATAPI\n\n    {\n\n        int i;\n\n        printf(\"ATAPI limit=0x%x packet:\", s->lcyl | (s->hcyl << 8));\n\n        for(i = 0; i < ATAPI_PACKET_SIZE; i++) {\n\n            printf(\" %02x\", buf[i]);\n\n        }\n\n        printf(\"\\n\");\n\n    }\n\n#endif\n\n    /*\n\n     * If there's a UNIT_ATTENTION condition pending, only command flagged with\n\n     * ALLOW_UA are allowed to complete. with other commands getting a CHECK\n\n     * condition response unless a higher priority status, defined by the drive\n\n     * here, is pending.\n\n     */\n\n    if (s->sense_key == UNIT_ATTENTION &&\n\n        !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) {\n\n        ide_atapi_cmd_check_status(s);\n\n        return;\n\n    }\n\n    /*\n\n     * When a CD gets changed, we have to report an ejected state and\n\n     * then a loaded state to guests so that they detect tray\n\n     * open/close and media change events.  Guests that do not use\n\n     * GET_EVENT_STATUS_NOTIFICATION to detect such tray open/close\n\n     * states rely on this behavior.\n\n     */\n\n    if (!(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA) &&\n\n        !s->tray_open && bdrv_is_inserted(s->bs) && s->cdrom_changed) {\n\n\n\n        if (s->cdrom_changed == 1) {\n\n            ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n\n            s->cdrom_changed = 2;\n\n        } else {\n\n            ide_atapi_cmd_error(s, UNIT_ATTENTION, ASC_MEDIUM_MAY_HAVE_CHANGED);\n\n            s->cdrom_changed = 0;\n\n        }\n\n\n\n        return;\n\n    }\n\n\n\n    /* Report a Not Ready condition if appropriate for the command */\n\n    if ((atapi_cmd_table[s->io_buffer[0]].flags & CHECK_READY) &&\n\n        (!media_present(s) || !bdrv_is_inserted(s->bs)))\n\n    {\n\n        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n\n        return;\n\n    }\n\n\n\n    /* Execute the command */\n\n    if (atapi_cmd_table[s->io_buffer[0]].handler) {\n\n        atapi_cmd_table[s->io_buffer[0]].handler(s, buf);\n\n        return;\n\n    }\n\n\n\n    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);\n\n}\n", "idx": 15495, "_split": "test", "_hash": "3fbada8d01986c58d6d944e11d112f16"}
{"project": "qemu", "commit_id": "5f706fdc164b20b48254eadf7bd413edace34499", "target": 1, "func": "int s390_cpu_write_elf64_note(WriteCoreDumpFunction f, CPUState *cs,\n\n                              int cpuid, void *opaque)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    return s390x_write_all_elf64_notes(\"CORE\", f, cpu, cpuid, opaque);\n\n}\n", "idx": 15517, "_split": "test", "_hash": "0fb8a476e88cbfb71e92072fd80c039e"}
{"project": "qemu", "commit_id": "aea390e4be652d5b5457771d25eded0dba14fe37", "target": 0, "func": "static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,\n\n                                       target_ulong *pte1p,\n\n                                       int ret, int rw)\n\n{\n\n    int store = 0;\n\n\n\n    /* Update page flags */\n\n    if (!(*pte1p & HPTE64_R_R)) {\n\n        /* Update accessed flag */\n\n        *pte1p |= HPTE64_R_R;\n\n        store = 1;\n\n    }\n\n    if (!(*pte1p & HPTE64_R_C)) {\n\n        if (rw == 1 && ret == 0) {\n\n            /* Update changed flag */\n\n            *pte1p |= HPTE64_R_C;\n\n            store = 1;\n\n        } else {\n\n            /* Force page fault for first write access */\n\n            ctx->prot &= ~PAGE_WRITE;\n\n        }\n\n    }\n\n\n\n    return store;\n\n}\n", "idx": 15521, "_split": "test", "_hash": "680dd62339d0a6e20a5866b6a72bb528"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,\n\n                           QEMUSGList *sg, uint64_t sector,\n\n                           void (*cb)(void *opaque, int ret), void *opaque)\n\n{\n\n    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb, opaque,\n\n                       DMA_DIRECTION_TO_DEVICE);\n\n}\n", "idx": 15524, "_split": "test", "_hash": "572058afed705a78b295bf0be2816254"}
{"project": "qemu", "commit_id": "b6d36def6d9e9fd187327182d0abafc9b7085d8f", "target": 0, "func": "static int discard_single_l2(BlockDriverState *bs, uint64_t offset,\n\n    unsigned int nb_clusters, enum qcow2_discard_type type, bool full_discard)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t *l2_table;\n\n    int l2_index;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Limit nb_clusters to one L2 table */\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t old_l2_entry;\n\n\n\n        old_l2_entry = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        /*\n\n         * If full_discard is false, make sure that a discarded area reads back\n\n         * as zeroes for v3 images (we cannot do it for v2 without actually\n\n         * writing a zero-filled buffer). We can skip the operation if the\n\n         * cluster is already marked as zero, or if it's unallocated and we\n\n         * don't have a backing file.\n\n         *\n\n         * TODO We might want to use bdrv_get_block_status(bs) here, but we're\n\n         * holding s->lock, so that doesn't work today.\n\n         *\n\n         * If full_discard is true, the sector should not read back as zeroes,\n\n         * but rather fall through to the backing file.\n\n         */\n\n        switch (qcow2_get_cluster_type(old_l2_entry)) {\n\n            case QCOW2_CLUSTER_UNALLOCATED:\n\n                if (full_discard || !bs->backing_hd) {\n\n                    continue;\n\n                }\n\n                break;\n\n\n\n            case QCOW2_CLUSTER_ZERO:\n\n                if (!full_discard) {\n\n                    continue;\n\n                }\n\n                break;\n\n\n\n            case QCOW2_CLUSTER_NORMAL:\n\n            case QCOW2_CLUSTER_COMPRESSED:\n\n                break;\n\n\n\n            default:\n\n                abort();\n\n        }\n\n\n\n        /* First remove L2 entries */\n\n        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n\n        if (!full_discard && s->qcow_version >= 3) {\n\n            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);\n\n        } else {\n\n            l2_table[l2_index + i] = cpu_to_be64(0);\n\n        }\n\n\n\n        /* Then decrease the refcount */\n\n        qcow2_free_any_clusters(bs, old_l2_entry, 1, type);\n\n    }\n\n\n\n    qcow2_cache_put(bs, s->l2_table_cache, (void **) &l2_table);\n\n\n\n    return nb_clusters;\n\n}\n", "idx": 15530, "_split": "test", "_hash": "da2788be74e25e9565d094dc3148caaf"}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static int64_t qemu_archipelago_getlength(BlockDriverState *bs)\n\n{\n\n    int64_t ret;\n\n    BDRVArchipelagoState *s = bs->opaque;\n\n\n\n    ret = archipelago_volume_info(s);\n\n    return ret;\n\n}\n", "idx": 15534, "_split": "test", "_hash": "991c87bbcfe6ba48efe66718070c975f"}
{"project": "qemu", "commit_id": "47445c80fb57035331574ac1ac0bcee67fb84aeb", "target": 0, "func": "static void rtas_ibm_set_eeh_option(PowerPCCPU *cpu,\n\n                                    sPAPRMachineState *spapr,\n\n                                    uint32_t token, uint32_t nargs,\n\n                                    target_ulong args, uint32_t nret,\n\n                                    target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    sPAPRPHBClass *spc;\n\n    PCIDevice *pdev;\n\n    uint32_t addr, option;\n\n    uint64_t buid;\n\n    int ret;\n\n\n\n    if ((nargs != 4) || (nret != 1)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = rtas_ldq(args, 1);\n\n    addr = rtas_ld(args, 0);\n\n    option = rtas_ld(args, 3);\n\n\n\n    sphb = spapr_pci_find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    pdev = pci_find_device(PCI_HOST_BRIDGE(sphb)->bus,\n\n                           (addr >> 16) & 0xFF, (addr >> 8) & 0xFF);\n\n    if (!pdev || !object_dynamic_cast(OBJECT(pdev), \"vfio-pci\")) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);\n\n    if (!spc->eeh_set_option) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    ret = spc->eeh_set_option(sphb, addr, option);\n\n    rtas_st(rets, 0, ret);\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 15535, "_split": "test", "_hash": "f133534c74cee0c71dc09ff62beef16b"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_acl_remove(qemu_acl *acl,\n\n                    const char *match)\n\n{\n\n    qemu_acl_entry *entry;\n\n    int i = 0;\n\n\n\n    TAILQ_FOREACH(entry, &acl->entries, next) {\n\n        i++;\n\n        if (strcmp(entry->match, match) == 0) {\n\n            TAILQ_REMOVE(&acl->entries, entry, next);\n\n            return i;\n\n        }\n\n    }\n\n    return -1;\n\n}\n", "idx": 15537, "_split": "test", "_hash": "06d5377a80e28d622fa78eb0d135e4ab"}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void ac97_initfn (PCIDevice *dev)\n\n{\n\n    PCIAC97LinkState *d = DO_UPCAST (PCIAC97LinkState, dev, dev);\n\n    AC97LinkState *s = &d->ac97;\n\n    uint8_t *c = d->dev.config;\n\n\n\n    s->pci_dev = &d->dev;\n\n    pci_config_set_vendor_id (c, PCI_VENDOR_ID_INTEL); /* ro */\n\n    pci_config_set_device_id (c, PCI_DEVICE_ID_INTEL_82801AA_5); /* ro */\n\n\n\n    c[0x04] = 0x00;      /* pcicmd pci command rw, ro */\n\n    c[0x05] = 0x00;\n\n\n\n    c[0x06] = 0x80;      /* pcists pci status rwc, ro */\n\n    c[0x07] = 0x02;\n\n\n\n    c[0x08] = 0x01;      /* rid revision ro */\n\n    c[0x09] = 0x00;      /* pi programming interface ro */\n\n    pci_config_set_class (c, PCI_CLASS_MULTIMEDIA_AUDIO); /* ro */\n\n    c[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; /* headtyp header type ro */\n\n\n\n    c[0x10] = 0x01;      /* nabmar native audio mixer base\n\n                            address rw */\n\n    c[0x11] = 0x00;\n\n    c[0x12] = 0x00;\n\n    c[0x13] = 0x00;\n\n\n\n    c[0x14] = 0x01;      /* nabmbar native audio bus mastering\n\n                            base address rw */\n\n    c[0x15] = 0x00;\n\n    c[0x16] = 0x00;\n\n    c[0x17] = 0x00;\n\n\n\n    c[0x2c] = 0x86;      /* svid subsystem vendor id rwo */\n\n    c[0x2d] = 0x80;\n\n\n\n    c[0x2e] = 0x00;      /* sid subsystem id rwo */\n\n    c[0x2f] = 0x00;\n\n\n\n    c[0x3c] = 0x00;      /* intr_ln interrupt line rw */\n\n    c[0x3d] = 0x01;      /* intr_pn interrupt pin ro */\n\n\n\n    pci_register_bar (&d->dev, 0, 256 * 4, PCI_ADDRESS_SPACE_IO, ac97_map);\n\n    pci_register_bar (&d->dev, 1, 64 * 4, PCI_ADDRESS_SPACE_IO, ac97_map);\n\n    register_savevm (\"ac97\", 0, 2, ac97_save, ac97_load, s);\n\n    qemu_register_reset (ac97_on_reset, s);\n\n    AUD_register_card (\"ac97\", &s->card);\n\n    ac97_on_reset (s);\n\n}\n", "idx": 15549, "_split": "test", "_hash": "0850b45f2be73cfd83efc56adbcf0f21"}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "static void qmp_output_end_struct(Visitor *v, Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    QObject *value = qmp_output_pop(qov);\n\n    assert(qobject_type(value) == QTYPE_QDICT);\n\n}\n", "idx": 15582, "_split": "test", "_hash": "bffb5eb1347564c9569f11f68ae7634a"}
{"project": "qemu", "commit_id": "0dacea92d26c31d453c58de2e99c178fee554166", "target": 1, "func": "putsum(uint8_t *data, uint32_t n, uint32_t sloc, uint32_t css, uint32_t cse)\n\n{\n\n    uint32_t sum;\n\n\n\n    if (cse && cse < n)\n\n        n = cse + 1;\n\n    if (sloc < n-1) {\n\n        sum = net_checksum_add(n-css, data+css);\n\n        stw_be_p(data + sloc, net_checksum_finish(sum));\n\n    }\n\n}\n", "idx": 15594, "_split": "test", "_hash": "b9a0972c2601b551e4a9e1a59bb3ccac"}
{"project": "qemu", "commit_id": "84aa07f109f0afaeeec63c159f3a578b955c3de9", "target": 0, "func": "uint32_t HELPER(clcle)(CPUS390XState *env, uint32_t r1, uint64_t a2,\n\n                       uint32_t r3)\n\n{\n\n    uintptr_t ra = GETPC();\n\n    uint64_t destlen = get_length(env, r1 + 1);\n\n    uint64_t dest = get_address(env, r1);\n\n    uint64_t srclen = get_length(env, r3 + 1);\n\n    uint64_t src = get_address(env, r3);\n\n    uint8_t pad = a2 & 0xff;\n\n    uint32_t cc = 0;\n\n\n\n    if (!(destlen || srclen)) {\n\n        return cc;\n\n    }\n\n\n\n    if (srclen > destlen) {\n\n        srclen = destlen;\n\n    }\n\n\n\n    for (; destlen || srclen; src++, dest++, destlen--, srclen--) {\n\n        uint8_t v1 = srclen ? cpu_ldub_data_ra(env, src, ra) : pad;\n\n        uint8_t v2 = destlen ? cpu_ldub_data_ra(env, dest, ra) : pad;\n\n        if (v1 != v2) {\n\n            cc = (v1 < v2) ? 1 : 2;\n\n            break;\n\n        }\n\n    }\n\n\n\n    set_length(env, r1 + 1, destlen);\n\n    /* can't use srclen here, we trunc'ed it */\n\n    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);\n\n    set_address(env, r1, dest);\n\n    set_address(env, r3, src);\n\n\n\n    return cc;\n\n}\n", "idx": 15615, "_split": "test", "_hash": "9b939ad9054fc9c1764b320d1f3da9ad"}
{"project": "qemu", "commit_id": "0e9b9edae7bebfd31fdbead4ccbbce03876a7edd", "target": 0, "func": "void *bios_linker_loader_cleanup(GArray *linker)\n\n{\n\n    return g_array_free(linker, false);\n\n}\n", "idx": 15634, "_split": "test", "_hash": "eb415525bf95bbc237d7fcdf417271a6"}
{"project": "qemu", "commit_id": "36778660d7fd0748a6129916e47ecedd67bdb758", "target": 0, "func": "const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,\n\n                                             hwaddr ptex, int n)\n\n{\n\n    ppc_hash_pte64_t *hptes = NULL;\n\n    hwaddr pte_offset = ptex * HASH_PTE_SIZE_64;\n\n\n\n    if (cpu->env.external_htab == MMU_HASH64_KVM_MANAGED_HPT) {\n\n        /*\n\n         * HTAB is controlled by KVM. Fetch into temporary buffer\n\n         */\n\n        hptes = g_malloc(HASH_PTEG_SIZE_64);\n\n        kvmppc_read_hptes(hptes, ptex, n);\n\n    } else if (cpu->env.external_htab) {\n\n        /*\n\n         * HTAB is controlled by QEMU. Just point to the internally\n\n         * accessible PTEG.\n\n         */\n\n        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + pte_offset);\n\n    } else if (cpu->env.htab_base) {\n\n        hwaddr plen = n * HASH_PTE_SIZE_64;\n\n        hptes = address_space_map(CPU(cpu)->as, cpu->env.htab_base + pte_offset,\n\n                                 &plen, false);\n\n        if (plen < (n * HASH_PTE_SIZE_64)) {\n\n            hw_error(\"%s: Unable to map all requested HPTEs\\n\", __func__);\n\n        }\n\n    }\n\n    return hptes;\n\n}\n", "idx": 15644, "_split": "test", "_hash": "17c1b9e5c6f7f860fe2dcdfeeed6fdeb"}
{"project": "qemu", "commit_id": "ecf5e8eae8b0b5fa41f00b53d67747b42fd1b8b9", "target": 0, "func": "static inline bool regime_translation_disabled(CPUARMState *env,\n\n                                               ARMMMUIdx mmu_idx)\n\n{\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        switch (env->v7m.mpu_ctrl &\n\n                (R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK)) {\n\n        case R_V7M_MPU_CTRL_ENABLE_MASK:\n\n            /* Enabled, but not for HardFault and NMI */\n\n            return mmu_idx == ARMMMUIdx_MNegPri ||\n\n                mmu_idx == ARMMMUIdx_MSNegPri;\n\n        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:\n\n            /* Enabled for all cases */\n\n            return false;\n\n        case 0:\n\n        default:\n\n            /* HFNMIENA set and ENABLE clear is UNPREDICTABLE, but\n\n             * we warned about that in armv7m_nvic.c when the guest set it.\n\n             */\n\n            return true;\n\n        }\n\n    }\n\n\n\n    if (mmu_idx == ARMMMUIdx_S2NS) {\n\n        return (env->cp15.hcr_el2 & HCR_VM) == 0;\n\n    }\n\n    return (regime_sctlr(env, mmu_idx) & SCTLR_M) == 0;\n\n}\n", "idx": 15653, "_split": "test", "_hash": "8d79fbf319df4bdbe6249ef04dc59e4d"}
{"project": "qemu", "commit_id": "2adba0a18a7950d14827e82d8068c1142ee87789", "target": 0, "func": "static void build_processor_devices(Aml *sb_scope, unsigned acpi_cpus,\n\n                                    AcpiCpuInfo *cpu, AcpiPmInfo *pm)\n\n{\n\n    int i;\n\n    Aml *dev;\n\n    Aml *crs;\n\n    Aml *pkg;\n\n    Aml *field;\n\n    Aml *ifctx;\n\n    Aml *method;\n\n\n\n    /* The current AML generator can cover the APIC ID range [0..255],\n\n     * inclusive, for VCPU hotplug. */\n\n    QEMU_BUILD_BUG_ON(ACPI_CPU_HOTPLUG_ID_LIMIT > 256);\n\n    g_assert(acpi_cpus <= ACPI_CPU_HOTPLUG_ID_LIMIT);\n\n\n\n    /* create PCI0.PRES device and its _CRS to reserve CPU hotplug MMIO */\n\n    dev = aml_device(\"PCI0.\" stringify(CPU_HOTPLUG_RESOURCE_DEVICE));\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A06\")));\n\n    aml_append(dev,\n\n        aml_name_decl(\"_UID\", aml_string(\"CPU Hotplug resources\"))\n\n    );\n\n    /* device present, functioning, decoding, not shown in UI */\n\n    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_io(AML_DECODE16, pm->cpu_hp_io_base, pm->cpu_hp_io_base, 1,\n\n               pm->cpu_hp_io_len)\n\n    );\n\n    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n    aml_append(sb_scope, dev);\n\n    /* declare CPU hotplug MMIO region and PRS field to access it */\n\n    aml_append(sb_scope, aml_operation_region(\n\n        \"PRST\", AML_SYSTEM_IO, aml_int(pm->cpu_hp_io_base), pm->cpu_hp_io_len));\n\n    field = aml_field(\"PRST\", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);\n\n    aml_append(field, aml_named_field(\"PRS\", 256));\n\n    aml_append(sb_scope, field);\n\n\n\n    /* build Processor object for each processor */\n\n    for (i = 0; i < acpi_cpus; i++) {\n\n        dev = aml_processor(i, 0, 0, \"CP%.02X\", i);\n\n\n\n        method = aml_method(\"_MAT\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method,\n\n            aml_return(aml_call1(CPU_MAT_METHOD, aml_int(i))));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"_STA\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method,\n\n            aml_return(aml_call1(CPU_STATUS_METHOD, aml_int(i))));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"_EJ0\", 1, AML_NOTSERIALIZED);\n\n        aml_append(method,\n\n            aml_return(aml_call2(CPU_EJECT_METHOD, aml_int(i), aml_arg(0)))\n\n        );\n\n        aml_append(dev, method);\n\n\n\n        aml_append(sb_scope, dev);\n\n    }\n\n\n\n    /* build this code:\n\n     *   Method(NTFY, 2) {If (LEqual(Arg0, 0x00)) {Notify(CP00, Arg1)} ...}\n\n     */\n\n    /* Arg0 = Processor ID = APIC ID */\n\n    method = aml_method(AML_NOTIFY_METHOD, 2, AML_NOTSERIALIZED);\n\n    for (i = 0; i < acpi_cpus; i++) {\n\n        ifctx = aml_if(aml_equal(aml_arg(0), aml_int(i)));\n\n        aml_append(ifctx,\n\n            aml_notify(aml_name(\"CP%.02X\", i), aml_arg(1))\n\n        );\n\n        aml_append(method, ifctx);\n\n    }\n\n    aml_append(sb_scope, method);\n\n\n\n    /* build \"Name(CPON, Package() { One, One, ..., Zero, Zero, ... })\"\n\n     *\n\n     * Note: The ability to create variable-sized packages was first\n\n     * introduced in ACPI 2.0. ACPI 1.0 only allowed fixed-size packages\n\n     * ith up to 255 elements. Windows guests up to win2k8 fail when\n\n     * VarPackageOp is used.\n\n     */\n\n    pkg = acpi_cpus <= 255 ? aml_package(acpi_cpus) :\n\n                             aml_varpackage(acpi_cpus);\n\n\n\n    for (i = 0; i < acpi_cpus; i++) {\n\n        uint8_t b = test_bit(i, cpu->found_cpus) ? 0x01 : 0x00;\n\n        aml_append(pkg, aml_int(b));\n\n    }\n\n    aml_append(sb_scope, aml_name_decl(CPU_ON_BITMAP, pkg));\n\n}\n", "idx": 15654, "_split": "test", "_hash": "5b269df41b65608b18289d64a4c85f1a"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "e1000_mmio_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    E1000State *s = opaque;\n\n    unsigned int index = (addr & 0x1ffff) >> 2;\n\n\n\n    if (index < NREADOPS && macreg_readops[index])\n\n    {\n\n        return macreg_readops[index](s, index);\n\n    }\n\n    DBGOUT(UNKNOWN, \"MMIO unknown read addr=0x%08x\\n\", index<<2);\n\n    return 0;\n\n}\n", "idx": 15655, "_split": "test", "_hash": "efd687d38051f18ba20de91246d308a1"}
{"project": "qemu", "commit_id": "c7dfbf322595ded4e70b626bf83158a9f3807c6a", "target": 1, "func": "static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)\n\n{\n\n    uint32_t len;\n\n\n\n    if (ccid_card_status(s) != ICC_STATUS_PRESENT_ACTIVE) {\n\n        DPRINTF(s, 1,\n\n                \"usb-ccid: not sending apdu to client, no card connected\\n\");\n\n        ccid_write_data_block_error(s, recv->hdr.bSlot, recv->hdr.bSeq);\n\n        return;\n\n    }\n\n    len = le32_to_cpu(recv->hdr.dwLength);\n\n    DPRINTF(s, 1, \"%s: seq %d, len %d\\n\", __func__,\n\n                recv->hdr.bSeq, len);\n\n    ccid_add_pending_answer(s, (CCID_Header *)recv);\n\n    if (s->card) {\n\n        ccid_card_apdu_from_guest(s->card, recv->abData, len);\n\n    } else {\n\n        DPRINTF(s, D_WARN, \"warning: discarded apdu\\n\");\n\n    }\n\n}\n", "idx": 15664, "_split": "test", "_hash": "284879123c9068e275e0c5dda163bcef"}
{"project": "qemu", "commit_id": "c7e35da348e2e4df072e6979c48fa5283e07d1db", "target": 1, "func": "static inline abi_long target_to_host_timespec(struct timespec *host_ts,\n\n                                               abi_ulong target_addr)\n\n{\n\n    struct target_timespec *target_ts;\n\n\n\n    if (!lock_user_struct(VERIFY_READ, target_ts, target_addr, 1))\n\n        return -TARGET_EFAULT;\n\n    host_ts->tv_sec = tswapal(target_ts->tv_sec);\n\n    host_ts->tv_nsec = tswapal(target_ts->tv_nsec);\n\n    unlock_user_struct(target_ts, target_addr, 0);\n\n    return 0;\n\n}\n", "idx": 15690, "_split": "test", "_hash": "87423b22515988b38f29f1f9ca2fe110"}
{"project": "qemu", "commit_id": "5039d6e23586fe6bbedc5e4fe302b48a66890ade", "target": 0, "func": "void DMA_init(int high_page_enable, qemu_irq *cpu_request_exit)\n\n{\n\n}\n", "idx": 15696, "_split": "test", "_hash": "a451ffe992b92016de3b2427d26bbd2b"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void intel_hda_mmio_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    intel_hda_reg_write(d, reg, val, 0xff);\n\n}\n", "idx": 15728, "_split": "test", "_hash": "b70c760d50d483ef82713a93045a4c9d"}
{"project": "qemu", "commit_id": "1a29cc8f5ebd657e159dbe4be340102595846d42", "target": 0, "func": "void serial_realize_core(SerialState *s, Error **errp)\n\n{\n\n    if (!qemu_chr_fe_backend_connected(&s->chr)) {\n\n        error_setg(errp, \"Can't create serial device, empty char device\");\n\n        return;\n\n    }\n\n\n\n    s->modem_status_poll = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) serial_update_msl, s);\n\n\n\n    s->fifo_timeout_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, s);\n\n    qemu_register_reset(serial_reset, s);\n\n\n\n    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,\n\n                             serial_event, NULL, s, NULL, true);\n\n    fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);\n\n    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);\n\n    serial_reset(s);\n\n}\n", "idx": 15775, "_split": "test", "_hash": "d1b554fb4b17daa77b340873c3365400"}
{"project": "qemu", "commit_id": "44bc910794eff956ceba0030f0751a26bed748b5", "target": 0, "func": "static int get_physical_address(CPUPPCState *env, mmu_ctx_t *ctx,\n\n                                target_ulong eaddr, int rw, int access_type)\n\n{\n\n    int ret;\n\n\n\n#if 0\n\n    qemu_log(\"%s\\n\", __func__);\n\n#endif\n\n    if ((access_type == ACCESS_CODE && msr_ir == 0) ||\n\n        (access_type != ACCESS_CODE && msr_dr == 0)) {\n\n        if (env->mmu_model == POWERPC_MMU_BOOKE) {\n\n            /* The BookE MMU always performs address translation. The\n\n               IS and DS bits only affect the address space.  */\n\n            ret = mmubooke_get_physical_address(env, ctx, eaddr,\n\n                                                rw, access_type);\n\n        } else if (env->mmu_model == POWERPC_MMU_BOOKE206) {\n\n            ret = mmubooke206_get_physical_address(env, ctx, eaddr, rw,\n\n                                                   access_type);\n\n        } else {\n\n            /* No address translation.  */\n\n            ret = check_physical(env, ctx, eaddr, rw);\n\n        }\n\n    } else {\n\n        ret = -1;\n\n        switch (env->mmu_model) {\n\n        case POWERPC_MMU_32B:\n\n        case POWERPC_MMU_601:\n\n            /* Try to find a BAT */\n\n            if (env->nb_BATs != 0) {\n\n                ret = get_bat(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            if (ret < 0) {\n\n                /* We didn't match any BAT entry or don't have BATs */\n\n                ret = get_segment32(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            break;\n\n\n\n        case POWERPC_MMU_SOFT_6xx:\n\n        case POWERPC_MMU_SOFT_74xx:\n\n            /* Try to find a BAT */\n\n            if (env->nb_BATs != 0) {\n\n                ret = get_bat(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            if (ret < 0) {\n\n                /* We didn't match any BAT entry or don't have BATs */\n\n                ret = get_segment_6xx_tlb(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            break;\n\n\n\n#if defined(TARGET_PPC64)\n\n        case POWERPC_MMU_64B:\n\n        case POWERPC_MMU_2_06:\n\n        case POWERPC_MMU_2_06d:\n\n            ret = get_segment64(env, ctx, eaddr, rw, access_type);\n\n            break;\n\n#endif\n\n\n\n        case POWERPC_MMU_SOFT_4xx:\n\n        case POWERPC_MMU_SOFT_4xx_Z:\n\n            ret = mmu40x_get_physical_address(env, ctx, eaddr,\n\n                                              rw, access_type);\n\n            break;\n\n        case POWERPC_MMU_BOOKE:\n\n            ret = mmubooke_get_physical_address(env, ctx, eaddr,\n\n                                                rw, access_type);\n\n            break;\n\n        case POWERPC_MMU_BOOKE206:\n\n            ret = mmubooke206_get_physical_address(env, ctx, eaddr, rw,\n\n                                               access_type);\n\n            break;\n\n        case POWERPC_MMU_MPC8xx:\n\n            /* XXX: TODO */\n\n            cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n            break;\n\n        case POWERPC_MMU_REAL:\n\n            cpu_abort(env, \"PowerPC in real mode do not do any translation\\n\");\n\n            return -1;\n\n        default:\n\n            cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n#if 0\n\n    qemu_log(\"%s address \" TARGET_FMT_lx \" => %d \" TARGET_FMT_plx \"\\n\",\n\n             __func__, eaddr, ret, ctx->raddr);\n\n#endif\n\n\n\n    return ret;\n\n}\n", "idx": 15779, "_split": "test", "_hash": "aae6fac893078271e4ca7eddd1a1bdc5"}
{"project": "qemu", "commit_id": "35c648078aa493c3b976840eb7cf2e53ab5b7a2d", "target": 0, "func": "static uint8_t eeprom24c0x_read(void)\n\n{\n\n    logout(\"%u: scl = %u, sda = %u, data = 0x%02x\\n\",\n\n        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);\n\n    return eeprom.sda;\n\n}\n", "idx": 15788, "_split": "test", "_hash": "423eb5094d8d22c606793d1496f41343"}
{"project": "qemu", "commit_id": "6a8f9661dc3c088ed0d2f5b41d940190407cbdc5", "target": 0, "func": "static void blockdev_do_action(int kind, void *data, Error **errp)\n\n{\n\n    TransactionAction action;\n\n    TransactionActionList list;\n\n\n\n    action.kind = kind;\n\n    action.data = data;\n\n    list.value = &action;\n\n    list.next = NULL;\n\n    qmp_transaction(&list, errp);\n\n}\n", "idx": 15791, "_split": "test", "_hash": "00a32f0fff967544e35de0b7fa094d04"}
{"project": "qemu", "commit_id": "b63c7f6b77145c109d66a62bb3b6efe12b80d62b", "target": 0, "func": "static void bootp_reply(struct bootp_t *bp)\n\n{\n\n    BOOTPClient *bc;\n\n    struct mbuf *m;\n\n    struct bootp_t *rbp;\n\n    struct sockaddr_in saddr, daddr;\n\n    struct in_addr dns_addr;\n\n    int dhcp_msg_type, val;\n\n    uint8_t *q;\n\n\n\n    /* extract exact DHCP msg type */\n\n    dhcp_decode(bp->bp_vend, DHCP_OPT_LEN, &dhcp_msg_type);\n\n    dprintf(\"bootp packet op=%d msgtype=%d\\n\", bp->bp_op, dhcp_msg_type);\n\n\n\n    if (dhcp_msg_type == 0)\n\n        dhcp_msg_type = DHCPREQUEST; /* Force reply for old BOOTP clients */\n\n\n\n    if (dhcp_msg_type != DHCPDISCOVER &&\n\n        dhcp_msg_type != DHCPREQUEST)\n\n        return;\n\n    /* XXX: this is a hack to get the client mac address */\n\n    memcpy(client_ethaddr, bp->bp_hwaddr, 6);\n\n\n\n    if ((m = m_get()) == NULL)\n\n        return;\n\n    m->m_data += IF_MAXLINKHDR;\n\n    rbp = (struct bootp_t *)m->m_data;\n\n    m->m_data += sizeof(struct udpiphdr);\n\n    memset(rbp, 0, sizeof(struct bootp_t));\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER) {\n\n    new_addr:\n\n        bc = get_new_addr(&daddr.sin_addr);\n\n        if (!bc) {\n\n            dprintf(\"no address left\\n\");\n\n            return;\n\n        }\n\n        memcpy(bc->macaddr, client_ethaddr, 6);\n\n    } else {\n\n        bc = find_addr(&daddr.sin_addr, bp->bp_hwaddr);\n\n        if (!bc) {\n\n            /* if never assigned, behaves as if it was already\n\n               assigned (windows fix because it remembers its address) */\n\n            goto new_addr;\n\n        }\n\n    }\n\n\n\n    if (bootp_filename)\n\n        snprintf((char *)rbp->bp_file, sizeof(rbp->bp_file), \"%s\",\n\n                 bootp_filename);\n\n\n\n    dprintf(\"offered addr=%08x\\n\", ntohl(daddr.sin_addr.s_addr));\n\n\n\n    saddr.sin_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_ALIAS);\n\n    saddr.sin_port = htons(BOOTP_SERVER);\n\n\n\n    daddr.sin_port = htons(BOOTP_CLIENT);\n\n\n\n    rbp->bp_op = BOOTP_REPLY;\n\n    rbp->bp_xid = bp->bp_xid;\n\n    rbp->bp_htype = 1;\n\n    rbp->bp_hlen = 6;\n\n    memcpy(rbp->bp_hwaddr, bp->bp_hwaddr, 6);\n\n\n\n    rbp->bp_yiaddr = daddr.sin_addr; /* Client IP address */\n\n    rbp->bp_siaddr = saddr.sin_addr; /* Server IP address */\n\n\n\n    daddr.sin_addr.s_addr = 0xffffffffu;\n\n\n\n    q = rbp->bp_vend;\n\n    memcpy(q, rfc1533_cookie, 4);\n\n    q += 4;\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER) {\n\n        *q++ = RFC2132_MSG_TYPE;\n\n        *q++ = 1;\n\n        *q++ = DHCPOFFER;\n\n    } else if (dhcp_msg_type == DHCPREQUEST) {\n\n        *q++ = RFC2132_MSG_TYPE;\n\n        *q++ = 1;\n\n        *q++ = DHCPACK;\n\n    }\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER ||\n\n        dhcp_msg_type == DHCPREQUEST) {\n\n        *q++ = RFC2132_SRV_ID;\n\n        *q++ = 4;\n\n        memcpy(q, &saddr.sin_addr, 4);\n\n        q += 4;\n\n\n\n        *q++ = RFC1533_NETMASK;\n\n        *q++ = 4;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0x00;\n\n\n\n        if (!slirp_restrict) {\n\n            *q++ = RFC1533_GATEWAY;\n\n            *q++ = 4;\n\n            memcpy(q, &saddr.sin_addr, 4);\n\n            q += 4;\n\n\n\n            *q++ = RFC1533_DNS;\n\n            *q++ = 4;\n\n            dns_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_DNS);\n\n            memcpy(q, &dns_addr, 4);\n\n            q += 4;\n\n        }\n\n\n\n        *q++ = RFC2132_LEASE_TIME;\n\n        *q++ = 4;\n\n        val = htonl(LEASE_TIME);\n\n        memcpy(q, &val, 4);\n\n        q += 4;\n\n\n\n        if (*slirp_hostname) {\n\n            val = strlen(slirp_hostname);\n\n            *q++ = RFC1533_HOSTNAME;\n\n            *q++ = val;\n\n            memcpy(q, slirp_hostname, val);\n\n            q += val;\n\n        }\n\n    }\n\n    *q++ = RFC1533_END;\n\n\n\n    m->m_len = sizeof(struct bootp_t) -\n\n        sizeof(struct ip) - sizeof(struct udphdr);\n\n    udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);\n\n}\n", "idx": 15811, "_split": "test", "_hash": "a63842d36dffa828dcd74f4419479121"}
{"project": "qemu", "commit_id": "4445b1d27ee65ceee12b71bc20242996c8eb5cf8", "target": 0, "func": "static uint32_t drc_isolate_physical(sPAPRDRConnector *drc)\n\n{\n\n    switch (drc->state) {\n\n    case SPAPR_DRC_STATE_PHYSICAL_POWERON:\n\n        return RTAS_OUT_SUCCESS; /* Nothing to do */\n\n    case SPAPR_DRC_STATE_PHYSICAL_CONFIGURED:\n\n        break; /* see below */\n\n    case SPAPR_DRC_STATE_PHYSICAL_UNISOLATE:\n\n        return RTAS_OUT_PARAM_ERROR; /* not allowed */\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    /* if the guest is configuring a device attached to this DRC, we\n\n     * should reset the configuration state at this point since it may\n\n     * no longer be reliable (guest released device and needs to start\n\n     * over, or unplug occurred so the FDT is no longer valid)\n\n     */\n\n    g_free(drc->ccs);\n\n    drc->ccs = NULL;\n\n\n\n    drc->state = SPAPR_DRC_STATE_PHYSICAL_POWERON;\n\n\n\n    if (drc->unplug_requested) {\n\n        uint32_t drc_index = spapr_drc_index(drc);\n\n        trace_spapr_drc_set_isolation_state_finalizing(drc_index);\n\n        spapr_drc_detach(drc);\n\n    }\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}\n", "idx": 15818, "_split": "test", "_hash": "6d8852f598a8e634662835adc459e0d6"}
{"project": "qemu", "commit_id": "2e6a64cb8d7506ad27d3b6c8000bc8d773936932", "target": 0, "func": "static void input_linux_event_mouse(void *opaque)\n\n{\n\n    InputLinux *il = opaque;\n\n    struct input_event event;\n\n    int rc;\n\n\n\n    for (;;) {\n\n        rc = read(il->fd, &event, sizeof(event));\n\n        if (rc != sizeof(event)) {\n\n            if (rc < 0 && errno != EAGAIN) {\n\n                fprintf(stderr, \"%s: read: %s\\n\", __func__, strerror(errno));\n\n                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);\n\n                close(il->fd);\n\n            }\n\n            break;\n\n        }\n\n\n\n        input_linux_handle_mouse(il, &event);\n\n    }\n\n}\n", "idx": 15823, "_split": "test", "_hash": "c1eb1febd6bb7f5d18f0d81c0f71d860"}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "int float64_eq( float64 a, float64 b STATUS_PARAM )\n\n{\n\n\n\n    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )\n\n         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )\n\n       ) {\n\n        if ( float64_is_signaling_nan( a ) || float64_is_signaling_nan( b ) ) {\n\n            float_raise( float_flag_invalid STATUS_VAR);\n\n        }\n\n        return 0;\n\n    }\n\n    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );\n\n\n\n}\n", "idx": 15833, "_split": "test", "_hash": "177c7f8b43580a8b27744c3e4abf5d44"}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static always_inline void gen_cmp(TCGCond cond,\n\n                                  int ra, int rb, int rc,\n\n                                  int islit, uint8_t lit)\n\n{\n\n    int l1, l2;\n\n    TCGv tmp;\n\n\n\n    if (unlikely(rc == 31))\n\n    return;\n\n\n\n    l1 = gen_new_label();\n\n    l2 = gen_new_label();\n\n\n\n    if (ra != 31) {\n\n        tmp = tcg_temp_new(TCG_TYPE_I64);\n\n        tcg_gen_mov_i64(tmp, cpu_ir[ra]);\n\n    } else\n\n        tmp = tcg_const_i64(0);\n\n    if (islit)\n\n        tcg_gen_brcondi_i64(cond, tmp, lit, l1);\n\n    else\n\n        tcg_gen_brcond_i64(cond, tmp, cpu_ir[rb], l1);\n\n\n\n    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_movi_i64(cpu_ir[rc], 1);\n\n    gen_set_label(l2);\n\n}\n", "idx": 15840, "_split": "test", "_hash": "39649201673073b4e610406157461cf3"}
{"project": "qemu", "commit_id": "e3c9d76acc984218264bbc6435b0c09f959ed9b8", "target": 1, "func": "static int virtio_scsi_device_exit(DeviceState *qdev)\n\n{\n\n    VirtIOSCSI *s = VIRTIO_SCSI(qdev);\n\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);\n\n\n\n    unregister_savevm(qdev, \"virtio-scsi\", s);\n\n    return virtio_scsi_common_exit(vs);\n\n}\n", "idx": 15846, "_split": "test", "_hash": "9694c7e08c03e88082a01963a71fd7c0"}
{"project": "qemu", "commit_id": "7d6e771f49c36f4388798ce25bde1dede40cda74", "target": 0, "func": "static int pci_vpb_init(SysBusDevice *dev)\n\n{\n\n    PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);\n\n    PCIBus *bus;\n\n    int i;\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        sysbus_init_irq(dev, &s->irq[i]);\n\n    }\n\n    bus = pci_register_bus(&dev->qdev, \"pci\",\n\n                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,\n\n                           get_system_memory(), get_system_io(),\n\n                           PCI_DEVFN(11, 0), 4);\n\n\n\n    /* ??? Register memory space.  */\n\n\n\n    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,\n\n                          \"pci-vpb-selfconfig\", 0x1000000);\n\n    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,\n\n                          \"pci-vpb-config\", 0x1000000);\n\n    if (s->realview) {\n\n        isa_mmio_setup(&s->isa, 0x0100000);\n\n    }\n\n\n\n    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);\n\n\n\n    pci_create_simple(bus, -1, \"versatile_pci_host\");\n\n    return 0;\n\n}\n", "idx": 15879, "_split": "test", "_hash": "c94fc01709ebced109270fbb1891274f"}
{"project": "qemu", "commit_id": "feced894fb6c474eb56daeb2b2d1f99bae87677f", "target": 0, "func": "static void rng_random_set_filename(Object *obj, const char *filename,\n\n                                 Error **errp)\n\n{\n\n    RngBackend *b = RNG_BACKEND(obj);\n\n    RndRandom *s = RNG_RANDOM(obj);\n\n\n\n    if (b->opened) {\n\n        error_set(errp, QERR_PERMISSION_DENIED);\n\n        return;\n\n    }\n\n\n\n    if (s->filename) {\n\n        g_free(s->filename);\n\n    }\n\n\n\n    s->filename = g_strdup(filename);\n\n}\n", "idx": 15883, "_split": "test", "_hash": "be76fbbb6546928729ca70dcccbecfd9"}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static void rtas_ibm_get_config_addr_info2(PowerPCCPU *cpu,\n\n                                           sPAPRMachineState *spapr,\n\n                                           uint32_t token, uint32_t nargs,\n\n                                           target_ulong args, uint32_t nret,\n\n                                           target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    PCIDevice *pdev;\n\n    uint32_t addr, option;\n\n    uint64_t buid;\n\n\n\n    if ((nargs != 4) || (nret != 2)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = rtas_ldq(args, 1);\n\n    sphb = spapr_pci_find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    if (!spapr_phb_eeh_available(sphb)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    /*\n\n     * We always have PE address of form \"00BB0001\". \"BB\"\n\n     * represents the bus number of PE's primary bus.\n\n     */\n\n    option = rtas_ld(args, 3);\n\n    switch (option) {\n\n    case RTAS_GET_PE_ADDR:\n\n        addr = rtas_ld(args, 0);\n\n        pdev = spapr_pci_find_dev(spapr, buid, addr);\n\n        if (!pdev) {\n\n            goto param_error_exit;\n\n        }\n\n\n\n        rtas_st(rets, 1, (pci_bus_num(pdev->bus) << 16) + 1);\n\n        break;\n\n    case RTAS_GET_PE_MODE:\n\n        rtas_st(rets, 1, RTAS_PE_MODE_SHARED);\n\n        break;\n\n    default:\n\n        goto param_error_exit;\n\n    }\n\n\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 15885, "_split": "test", "_hash": "ced46a80b418072553e6a706879b3bea"}
{"project": "qemu", "commit_id": "a3fa1d78cbae2259491b17689812edcb643a3b30", "target": 0, "func": "static void migrate_fd_completed(MigrationState *s)\n\n{\n\n    DPRINTF(\"setting completed state\\n\");\n\n    migrate_fd_cleanup(s);\n\n    if (s->state == MIG_STATE_ACTIVE) {\n\n        s->state = MIG_STATE_COMPLETED;\n\n        runstate_set(RUN_STATE_POSTMIGRATE);\n\n    }\n\n    notifier_list_notify(&migration_state_notifiers, s);\n\n}\n", "idx": 15890, "_split": "test", "_hash": "0bf6a67e42a35b7b4c6ae2621ffb2f4b"}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_adds_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tint size = memsize_z(dc);\n\n\tDIS(fprintf (logfile, \"adds.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(size),\n\n\t\t    dc->op1, dc->op2));\n\n\n\n\tcris_cc_mask(dc, CC_MASK_NZVC);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\t/* Size can only be qi or hi.  */\n\n\tt_gen_sext(t0, cpu_R[dc->op1], size);\n\n\tcris_alu(dc, CC_OP_ADD,\n\n\t\t    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n", "idx": 15897, "_split": "test", "_hash": "57ab4df1a4bfe6b961dfab13db812146"}
{"project": "qemu", "commit_id": "b6866fee58bc25b01485dcfcf8be44a915c5f573", "target": 0, "func": "static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,\n\n                                  VirtIOSCSIReq *req)\n\n{\n\n    assert(req->elem.out_num && req->elem.in_num);\n\n    req->vq = vq;\n\n    req->dev = s;\n\n    req->sreq = NULL;\n\n    req->req.buf = req->elem.out_sg[0].iov_base;\n\n    req->resp.buf = req->elem.in_sg[0].iov_base;\n\n\n\n    if (req->elem.out_num > 1) {\n\n        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],\n\n                               &req->elem.out_addr[1],\n\n                               req->elem.out_num - 1);\n\n    } else {\n\n        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],\n\n                               &req->elem.in_addr[1],\n\n                               req->elem.in_num - 1);\n\n    }\n\n}\n", "idx": 15911, "_split": "test", "_hash": "3891e2f0e90fa95ee4af69433381690f"}
{"project": "qemu", "commit_id": "5eb6d9e3ef1fac096ab5b3f5c14e1f4079dd7367", "target": 0, "func": "static void usb_uas_task(UASDevice *uas, uas_ui *ui)\n\n{\n\n    uint16_t tag = be16_to_cpu(ui->hdr.tag);\n\n    uint64_t lun64 = be64_to_cpu(ui->task.lun);\n\n    SCSIDevice *dev = usb_uas_get_dev(uas, lun64);\n\n    int lun = usb_uas_get_lun(lun64);\n\n    UASRequest *req;\n\n    uint16_t task_tag;\n\n\n\n    req = usb_uas_find_request(uas, be16_to_cpu(ui->hdr.tag));\n\n    if (req) {\n\n        goto overlapped_tag;\n\n    }\n\n\n\n    switch (ui->task.function) {\n\n    case UAS_TMF_ABORT_TASK:\n\n        task_tag = be16_to_cpu(ui->task.task_tag);\n\n        trace_usb_uas_tmf_abort_task(uas->dev.addr, tag, task_tag);\n\n        if (dev == NULL) {\n\n            goto bad_target;\n\n        }\n\n        if (dev->lun != lun) {\n\n            goto incorrect_lun;\n\n        }\n\n        req = usb_uas_find_request(uas, task_tag);\n\n        if (req && req->dev == dev) {\n\n            scsi_req_cancel(req->req);\n\n        }\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_COMPLETE, 0);\n\n        break;\n\n\n\n    case UAS_TMF_LOGICAL_UNIT_RESET:\n\n        trace_usb_uas_tmf_logical_unit_reset(uas->dev.addr, tag, lun);\n\n        if (dev == NULL) {\n\n            goto bad_target;\n\n        }\n\n        if (dev->lun != lun) {\n\n            goto incorrect_lun;\n\n        }\n\n        qdev_reset_all(&dev->qdev);\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_COMPLETE, 0);\n\n        break;\n\n\n\n    default:\n\n        trace_usb_uas_tmf_unsupported(uas->dev.addr, tag, ui->task.function);\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_NOT_SUPPORTED, 0);\n\n        break;\n\n    }\n\n    return;\n\n\n\noverlapped_tag:\n\n    usb_uas_queue_response(uas, req->tag, UAS_RC_OVERLAPPED_TAG, 0);\n\n    return;\n\n\n\nbad_target:\n\n    /* FIXME: correct?  [see long comment in usb_uas_command()] */\n\n    usb_uas_queue_response(uas, tag, UAS_RC_INVALID_INFO_UNIT, 0);\n\n    return;\n\n\n\nincorrect_lun:\n\n    usb_uas_queue_response(uas, tag, UAS_RC_INCORRECT_LUN, 0);\n\n}\n", "idx": 15924, "_split": "test", "_hash": "a34ed1c98596f818ca5900dcb7b27652"}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)\n\n{\n\n    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);\n\n    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);\n\n    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);\n\n\n\n    if (!dev->conf.dinfo) {\n\n        fprintf(stderr, \"%s: no drive specified\\n\", qdev->info->name);\n\n        goto err;\n\n    }\n\n    if (dev->unit == -1) {\n\n        dev->unit = bus->master ? 1 : 0;\n\n    }\n\n    switch (dev->unit) {\n\n    case 0:\n\n        if (bus->master) {\n\n            fprintf(stderr, \"ide: tried to assign master twice\\n\");\n\n            goto err;\n\n        }\n\n        bus->master = dev;\n\n        break;\n\n    case 1:\n\n        if (bus->slave) {\n\n            fprintf(stderr, \"ide: tried to assign slave twice\\n\");\n\n            goto err;\n\n        }\n\n        bus->slave = dev;\n\n        break;\n\n    default:\n\n        goto err;\n\n    }\n\n    return info->init(dev);\n\n\n\nerr:\n\n    return -1;\n\n}\n", "idx": 15929, "_split": "test", "_hash": "ef51f348175ea275c3b0c9eb432ff65d"}
{"project": "qemu", "commit_id": "b2c98d9d392c87c9b9e975d30f79924719d9cbbe", "target": 0, "func": "static int tcg_match_ori(TCGType type, tcg_target_long val)\n\n{\n\n    if (facilities & FACILITY_EXT_IMM) {\n\n        if (type == TCG_TYPE_I32) {\n\n            /* All 32-bit ORs can be performed with 1 48-bit insn.  */\n\n            return 1;\n\n        }\n\n    }\n\n\n\n    /* Look for negative values.  These are best to load with LGHI.  */\n\n    if (val < 0) {\n\n        if (val == (int16_t)val) {\n\n            return 0;\n\n        }\n\n        if (facilities & FACILITY_EXT_IMM) {\n\n            if (val == (int32_t)val) {\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 15943, "_split": "test", "_hash": "6419d1f891fea7b6308107ee8b9f51cc"}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "void OPPROTO op_addq_EDI_T0(void)\n\n{\n\n    EDI = (EDI + T0);\n\n}\n", "idx": 15962, "_split": "test", "_hash": "9c6d8a3fb310a22137bbc82db61f1a69"}
{"project": "qemu", "commit_id": "af08a58f0ca338eafee855921859a8c1ace0175b", "target": 0, "func": "static void hypercall_register_types(void)\n\n{\n\n    /* hcall-pft */\n\n    spapr_register_hypercall(H_ENTER, h_enter);\n\n    spapr_register_hypercall(H_REMOVE, h_remove);\n\n    spapr_register_hypercall(H_PROTECT, h_protect);\n\n    spapr_register_hypercall(H_READ, h_read);\n\n\n\n    /* hcall-bulk */\n\n    spapr_register_hypercall(H_BULK_REMOVE, h_bulk_remove);\n\n\n\n    /* hcall-dabr */\n\n    spapr_register_hypercall(H_SET_DABR, h_set_dabr);\n\n\n\n    /* hcall-splpar */\n\n    spapr_register_hypercall(H_REGISTER_VPA, h_register_vpa);\n\n    spapr_register_hypercall(H_CEDE, h_cede);\n\n\n\n    /* processor register resource access h-calls */\n\n    spapr_register_hypercall(H_SET_SPRG0, h_set_sprg0);\n\n    spapr_register_hypercall(H_SET_MODE, h_set_mode);\n\n\n\n    /* \"debugger\" hcalls (also used by SLOF). Note: We do -not- differenciate\n\n     * here between the \"CI\" and the \"CACHE\" variants, they will use whatever\n\n     * mapping attributes qemu is using. When using KVM, the kernel will\n\n     * enforce the attributes more strongly\n\n     */\n\n    spapr_register_hypercall(H_LOGICAL_CI_LOAD, h_logical_load);\n\n    spapr_register_hypercall(H_LOGICAL_CI_STORE, h_logical_store);\n\n    spapr_register_hypercall(H_LOGICAL_CACHE_LOAD, h_logical_load);\n\n    spapr_register_hypercall(H_LOGICAL_CACHE_STORE, h_logical_store);\n\n    spapr_register_hypercall(H_LOGICAL_ICBI, h_logical_icbi);\n\n    spapr_register_hypercall(H_LOGICAL_DCBF, h_logical_dcbf);\n\n    spapr_register_hypercall(KVMPPC_H_LOGICAL_MEMOP, h_logical_memop);\n\n\n\n    /* qemu/KVM-PPC specific hcalls */\n\n    spapr_register_hypercall(KVMPPC_H_RTAS, h_rtas);\n\n\n\n    /* ibm,client-architecture-support support */\n\n    spapr_register_hypercall(KVMPPC_H_CAS, h_client_architecture_support);\n\n}\n", "idx": 15965, "_split": "test", "_hash": "acfc3f459f9f53fcb8df29afcb33ed67"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void virtio_blk_update_config(VirtIODevice *vdev, uint8_t *config)\n\n{\n\n    VirtIOBlock *s = VIRTIO_BLK(vdev);\n\n    BlockConf *conf = &s->conf.conf;\n\n    struct virtio_blk_config blkcfg;\n\n    uint64_t capacity;\n\n    int blk_size = conf->logical_block_size;\n\n\n\n    bdrv_get_geometry(s->bs, &capacity);\n\n    memset(&blkcfg, 0, sizeof(blkcfg));\n\n    virtio_stq_p(vdev, &blkcfg.capacity, capacity);\n\n    virtio_stl_p(vdev, &blkcfg.seg_max, 128 - 2);\n\n    virtio_stw_p(vdev, &blkcfg.cylinders, conf->cyls);\n\n    virtio_stl_p(vdev, &blkcfg.blk_size, blk_size);\n\n    virtio_stw_p(vdev, &blkcfg.min_io_size, conf->min_io_size / blk_size);\n\n    virtio_stw_p(vdev, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);\n\n    blkcfg.heads = conf->heads;\n\n    /*\n\n     * We must ensure that the block device capacity is a multiple of\n\n     * the logical block size. If that is not the case, let's use\n\n     * sector_mask to adopt the geometry to have a correct picture.\n\n     * For those devices where the capacity is ok for the given geometry\n\n     * we don't touch the sector value of the geometry, since some devices\n\n     * (like s390 dasd) need a specific value. Here the capacity is already\n\n     * cyls*heads*secs*blk_size and the sector value is not block size\n\n     * divided by 512 - instead it is the amount of blk_size blocks\n\n     * per track (cylinder).\n\n     */\n\n    if (bdrv_getlength(s->bs) /  conf->heads / conf->secs % blk_size) {\n\n        blkcfg.sectors = conf->secs & ~s->sector_mask;\n\n    } else {\n\n        blkcfg.sectors = conf->secs;\n\n    }\n\n    blkcfg.size_max = 0;\n\n    blkcfg.physical_block_exp = get_physical_block_exp(conf);\n\n    blkcfg.alignment_offset = 0;\n\n    blkcfg.wce = bdrv_enable_write_cache(s->bs);\n\n    memcpy(config, &blkcfg, sizeof(struct virtio_blk_config));\n\n}\n", "idx": 15977, "_split": "test", "_hash": "aadeaa5aa17dcdee1d082e3c48c5fac6"}
{"project": "qemu", "commit_id": "aea14095ea91f792ee43ee52fe6032cd8cdd7190", "target": 0, "func": "static void decode_opc (CPUMIPSState *env, DisasContext *ctx)\n\n{\n\n    int32_t offset;\n\n    int rs, rt, rd, sa;\n\n    uint32_t op, op1;\n\n    int16_t imm;\n\n\n\n    /* make sure instructions are on a word boundary */\n\n    if (ctx->pc & 0x3) {\n\n        env->CP0_BadVAddr = ctx->pc;\n\n        generate_exception(ctx, EXCP_AdEL);\n\n        return;\n\n    }\n\n\n\n    /* Handle blikely not taken case */\n\n    if ((ctx->hflags & MIPS_HFLAG_BMASK_BASE) == MIPS_HFLAG_BL) {\n\n        int l1 = gen_new_label();\n\n\n\n        MIPS_DEBUG(\"blikely condition (\" TARGET_FMT_lx \")\", ctx->pc + 4);\n\n        tcg_gen_brcondi_tl(TCG_COND_NE, bcond, 0, l1);\n\n        tcg_gen_movi_i32(hflags, ctx->hflags & ~MIPS_HFLAG_BMASK);\n\n        gen_goto_tb(ctx, 1, ctx->pc + 4);\n\n        gen_set_label(l1);\n\n    }\n\n\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n        tcg_gen_debug_insn_start(ctx->pc);\n\n    }\n\n\n\n    op = MASK_OP_MAJOR(ctx->opcode);\n\n    rs = (ctx->opcode >> 21) & 0x1f;\n\n    rt = (ctx->opcode >> 16) & 0x1f;\n\n    rd = (ctx->opcode >> 11) & 0x1f;\n\n    sa = (ctx->opcode >> 6) & 0x1f;\n\n    imm = (int16_t)ctx->opcode;\n\n    switch (op) {\n\n    case OPC_SPECIAL:\n\n        decode_opc_special(env, ctx);\n\n        break;\n\n    case OPC_SPECIAL2:\n\n        decode_opc_special2_legacy(env, ctx);\n\n        break;\n\n    case OPC_SPECIAL3:\n\n        decode_opc_special3(env, ctx);\n\n        break;\n\n    case OPC_REGIMM:\n\n        op1 = MASK_REGIMM(ctx->opcode);\n\n        switch (op1) {\n\n        case OPC_BLTZL: /* REGIMM branches */\n\n        case OPC_BGEZL:\n\n        case OPC_BLTZALL:\n\n        case OPC_BGEZALL:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        case OPC_BLTZ:\n\n        case OPC_BGEZ:\n\n            gen_compute_branch(ctx, op1, 4, rs, -1, imm << 2, 4);\n\n            break;\n\n        case OPC_BLTZAL:\n\n        case OPC_BGEZAL:\n\n            if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                if (rs == 0) {\n\n                    /* OPC_NAL, OPC_BAL */\n\n                    gen_compute_branch(ctx, op1, 4, 0, -1, imm << 2, 4);\n\n                } else {\n\n                    generate_exception(ctx, EXCP_RI);\n\n                }\n\n            } else {\n\n                gen_compute_branch(ctx, op1, 4, rs, -1, imm << 2, 4);\n\n            }\n\n            break;\n\n        case OPC_TGEI ... OPC_TEQI: /* REGIMM traps */\n\n        case OPC_TNEI:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            gen_trap(ctx, op1, rs, -1, imm);\n\n            break;\n\n        case OPC_SYNCI:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            /* Break the TB to be able to sync copied instructions\n\n               immediately */\n\n            ctx->bstate = BS_STOP;\n\n            break;\n\n        case OPC_BPOSGE32:    /* MIPS DSP branch */\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_BPOSGE64:\n\n#endif\n\n            check_dsp(ctx);\n\n            gen_compute_branch(ctx, op1, 4, -1, -2, (int32_t)imm << 2, 4);\n\n            break;\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_DAHI:\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            check_mips_64(ctx);\n\n            if (rs != 0) {\n\n                tcg_gen_addi_tl(cpu_gpr[rs], cpu_gpr[rs], (int64_t)imm << 32);\n\n            }\n\n            MIPS_DEBUG(\"dahi %s, %04x\", regnames[rs], imm);\n\n            break;\n\n        case OPC_DATI:\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            check_mips_64(ctx);\n\n            if (rs != 0) {\n\n                tcg_gen_addi_tl(cpu_gpr[rs], cpu_gpr[rs], (int64_t)imm << 48);\n\n            }\n\n            MIPS_DEBUG(\"dati %s, %04x\", regnames[rs], imm);\n\n            break;\n\n#endif\n\n        default:            /* Invalid */\n\n            MIPS_INVAL(\"regimm\");\n\n            generate_exception(ctx, EXCP_RI);\n\n            break;\n\n        }\n\n        break;\n\n    case OPC_CP0:\n\n        check_cp0_enabled(ctx);\n\n        op1 = MASK_CP0(ctx->opcode);\n\n        switch (op1) {\n\n        case OPC_MFC0:\n\n        case OPC_MTC0:\n\n        case OPC_MFTR:\n\n        case OPC_MTTR:\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_DMFC0:\n\n        case OPC_DMTC0:\n\n#endif\n\n#ifndef CONFIG_USER_ONLY\n\n            gen_cp0(env, ctx, op1, rt, rd);\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_C0_FIRST ... OPC_C0_LAST:\n\n#ifndef CONFIG_USER_ONLY\n\n            gen_cp0(env, ctx, MASK_C0(ctx->opcode), rt, rd);\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_MFMC0:\n\n#ifndef CONFIG_USER_ONLY\n\n            {\n\n                uint32_t op2;\n\n                TCGv t0 = tcg_temp_new();\n\n\n\n                op2 = MASK_MFMC0(ctx->opcode);\n\n                switch (op2) {\n\n                case OPC_DMT:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_dmt(t0);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_EMT:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_emt(t0);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_DVPE:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_dvpe(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_EVPE:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_evpe(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_DI:\n\n                    check_insn(ctx, ISA_MIPS32R2);\n\n                    save_cpu_state(ctx, 1);\n\n                    gen_helper_di(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    /* Stop translation as we may have switched the execution mode */\n\n                    ctx->bstate = BS_STOP;\n\n                    break;\n\n                case OPC_EI:\n\n                    check_insn(ctx, ISA_MIPS32R2);\n\n                    save_cpu_state(ctx, 1);\n\n                    gen_helper_ei(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    /* Stop translation as we may have switched the execution mode */\n\n                    ctx->bstate = BS_STOP;\n\n                    break;\n\n                default:            /* Invalid */\n\n                    MIPS_INVAL(\"mfmc0\");\n\n                    generate_exception(ctx, EXCP_RI);\n\n                    break;\n\n                }\n\n                tcg_temp_free(t0);\n\n            }\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_RDPGPR:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_load_srsgpr(rt, rd);\n\n            break;\n\n        case OPC_WRPGPR:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_store_srsgpr(rt, rd);\n\n            break;\n\n        default:\n\n            MIPS_INVAL(\"cp0\");\n\n            generate_exception(ctx, EXCP_RI);\n\n            break;\n\n        }\n\n        break;\n\n    case OPC_BOVC: /* OPC_BEQZALC, OPC_BEQC, OPC_ADDI */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BOVC, OPC_BEQZALC, OPC_BEQC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_ADDI */\n\n            /* Arithmetic with immediate opcode */\n\n            gen_arith_imm(ctx, op, rt, rs, imm);\n\n        }\n\n        break;\n\n    case OPC_ADDIU:\n\n         gen_arith_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SLTI: /* Set on less than with immediate opcode */\n\n    case OPC_SLTIU:\n\n         gen_slt_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_ANDI: /* Arithmetic with immediate opcode */\n\n    case OPC_LUI: /* OPC_AUI */\n\n    case OPC_ORI:\n\n    case OPC_XORI:\n\n         gen_logic_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_J ... OPC_JAL: /* Jump */\n\n         offset = (int32_t)(ctx->opcode & 0x3FFFFFF) << 2;\n\n         gen_compute_branch(ctx, op, 4, rs, rt, offset, 4);\n\n         break;\n\n    /* Branch */\n\n    case OPC_BLEZC: /* OPC_BGEZC, OPC_BGEC, OPC_BLEZL */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rt == 0) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                break;\n\n            }\n\n            /* OPC_BLEZC, OPC_BGEZC, OPC_BGEC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_BLEZL */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        }\n\n        break;\n\n    case OPC_BGTZC: /* OPC_BLTZC, OPC_BLTC, OPC_BGTZL */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rt == 0) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                break;\n\n            }\n\n            /* OPC_BGTZC, OPC_BLTZC, OPC_BLTC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_BGTZL */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        }\n\n        break;\n\n    case OPC_BLEZALC: /* OPC_BGEZALC, OPC_BGEUC, OPC_BLEZ */\n\n        if (rt == 0) {\n\n            /* OPC_BLEZ */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        } else {\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            /* OPC_BLEZALC, OPC_BGEZALC, OPC_BGEUC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        }\n\n        break;\n\n    case OPC_BGTZALC: /* OPC_BLTZALC, OPC_BLTUC, OPC_BGTZ */\n\n        if (rt == 0) {\n\n            /* OPC_BGTZ */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        } else {\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            /* OPC_BGTZALC, OPC_BLTZALC, OPC_BLTUC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        }\n\n        break;\n\n    case OPC_BEQL:\n\n    case OPC_BNEL:\n\n         check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_BEQ:\n\n    case OPC_BNE:\n\n         gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n         break;\n\n    case OPC_LWL: /* Load and stores */\n\n    case OPC_LWR:\n\n    case OPC_LL:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_LB ... OPC_LH:\n\n    case OPC_LW ... OPC_LHU:\n\n         gen_ld(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SWL:\n\n    case OPC_SWR:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_SB ... OPC_SH:\n\n    case OPC_SW:\n\n         gen_st(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SC:\n\n         check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n         gen_st_cond(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_CACHE:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_cp0_enabled(ctx);\n\n        check_insn(ctx, ISA_MIPS3 | ISA_MIPS32);\n\n        /* Treat as NOP. */\n\n        break;\n\n    case OPC_PREF:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_insn(ctx, ISA_MIPS4 | ISA_MIPS32);\n\n        /* Treat as NOP. */\n\n        break;\n\n\n\n    /* Floating point (COP1). */\n\n    case OPC_LWC1:\n\n    case OPC_LDC1:\n\n    case OPC_SWC1:\n\n    case OPC_SDC1:\n\n        gen_cop1_ldst(ctx, op, rt, rs, imm);\n\n        break;\n\n\n\n    case OPC_CP1:\n\n        if (ctx->CP0_Config1 & (1 << CP0C1_FP)) {\n\n            check_cp1_enabled(ctx);\n\n            op1 = MASK_CP1(ctx->opcode);\n\n            switch (op1) {\n\n            case OPC_MFHC1:\n\n            case OPC_MTHC1:\n\n                check_insn(ctx, ISA_MIPS32R2);\n\n            case OPC_MFC1:\n\n            case OPC_CFC1:\n\n            case OPC_MTC1:\n\n            case OPC_CTC1:\n\n                gen_cp1(ctx, op1, rt, rd);\n\n                break;\n\n#if defined(TARGET_MIPS64)\n\n            case OPC_DMFC1:\n\n            case OPC_DMTC1:\n\n                check_insn(ctx, ISA_MIPS3);\n\n                gen_cp1(ctx, op1, rt, rd);\n\n                break;\n\n#endif\n\n            case OPC_BC1EQZ: /* OPC_BC1ANY2 */\n\n                if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                    /* OPC_BC1EQZ */\n\n                    gen_compute_branch1_r6(ctx, MASK_CP1(ctx->opcode),\n\n                                    rt, imm << 2);\n\n                } else {\n\n                    /* OPC_BC1ANY2 */\n\n                    check_cop1x(ctx);\n\n                    check_insn(ctx, ASE_MIPS3D);\n\n                    gen_compute_branch1(ctx, MASK_BC1(ctx->opcode),\n\n                                    (rt >> 2) & 0x7, imm << 2);\n\n                }\n\n                break;\n\n            case OPC_BC1NEZ:\n\n                check_insn(ctx, ISA_MIPS32R6);\n\n                gen_compute_branch1_r6(ctx, MASK_CP1(ctx->opcode),\n\n                                rt, imm << 2);\n\n                break;\n\n            case OPC_BC1ANY4:\n\n                check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n                check_cop1x(ctx);\n\n                check_insn(ctx, ASE_MIPS3D);\n\n                /* fall through */\n\n            case OPC_BC1:\n\n                check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n                gen_compute_branch1(ctx, MASK_BC1(ctx->opcode),\n\n                                    (rt >> 2) & 0x7, imm << 2);\n\n                break;\n\n            case OPC_PS_FMT:\n\n                check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            case OPC_S_FMT:\n\n            case OPC_D_FMT:\n\n                gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,\n\n                           (imm >> 8) & 0x7);\n\n                break;\n\n            case OPC_W_FMT:\n\n            case OPC_L_FMT:\n\n            {\n\n                int r6_op = ctx->opcode & FOP(0x3f, 0x1f);\n\n                if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                    switch (r6_op) {\n\n                    case R6_OPC_CMP_AF_S:\n\n                    case R6_OPC_CMP_UN_S:\n\n                    case R6_OPC_CMP_EQ_S:\n\n                    case R6_OPC_CMP_UEQ_S:\n\n                    case R6_OPC_CMP_LT_S:\n\n                    case R6_OPC_CMP_ULT_S:\n\n                    case R6_OPC_CMP_LE_S:\n\n                    case R6_OPC_CMP_ULE_S:\n\n                    case R6_OPC_CMP_SAF_S:\n\n                    case R6_OPC_CMP_SUN_S:\n\n                    case R6_OPC_CMP_SEQ_S:\n\n                    case R6_OPC_CMP_SEUQ_S:\n\n                    case R6_OPC_CMP_SLT_S:\n\n                    case R6_OPC_CMP_SULT_S:\n\n                    case R6_OPC_CMP_SLE_S:\n\n                    case R6_OPC_CMP_SULE_S:\n\n                    case R6_OPC_CMP_OR_S:\n\n                    case R6_OPC_CMP_UNE_S:\n\n                    case R6_OPC_CMP_NE_S:\n\n                    case R6_OPC_CMP_SOR_S:\n\n                    case R6_OPC_CMP_SUNE_S:\n\n                    case R6_OPC_CMP_SNE_S:\n\n                        gen_r6_cmp_s(ctx, ctx->opcode & 0x1f, rt, rd, sa);\n\n                        break;\n\n                    case R6_OPC_CMP_AF_D:\n\n                    case R6_OPC_CMP_UN_D:\n\n                    case R6_OPC_CMP_EQ_D:\n\n                    case R6_OPC_CMP_UEQ_D:\n\n                    case R6_OPC_CMP_LT_D:\n\n                    case R6_OPC_CMP_ULT_D:\n\n                    case R6_OPC_CMP_LE_D:\n\n                    case R6_OPC_CMP_ULE_D:\n\n                    case R6_OPC_CMP_SAF_D:\n\n                    case R6_OPC_CMP_SUN_D:\n\n                    case R6_OPC_CMP_SEQ_D:\n\n                    case R6_OPC_CMP_SEUQ_D:\n\n                    case R6_OPC_CMP_SLT_D:\n\n                    case R6_OPC_CMP_SULT_D:\n\n                    case R6_OPC_CMP_SLE_D:\n\n                    case R6_OPC_CMP_SULE_D:\n\n                    case R6_OPC_CMP_OR_D:\n\n                    case R6_OPC_CMP_UNE_D:\n\n                    case R6_OPC_CMP_NE_D:\n\n                    case R6_OPC_CMP_SOR_D:\n\n                    case R6_OPC_CMP_SUNE_D:\n\n                    case R6_OPC_CMP_SNE_D:\n\n                        gen_r6_cmp_d(ctx, ctx->opcode & 0x1f, rt, rd, sa);\n\n                        break;\n\n                    default:\n\n                        gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,\n\n                                                       (imm >> 8) & 0x7);\n\n                        break;\n\n                    }\n\n                } else {\n\n                    gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,\n\n                               (imm >> 8) & 0x7);\n\n                }\n\n                break;\n\n            }\n\n            default:\n\n                MIPS_INVAL(\"cp1\");\n\n                generate_exception (ctx, EXCP_RI);\n\n                break;\n\n            }\n\n        } else {\n\n            generate_exception_err(ctx, EXCP_CpU, 1);\n\n        }\n\n        break;\n\n\n\n    /* Compact branches [R6] and COP2 [non-R6] */\n\n    case OPC_BC: /* OPC_LWC2 */\n\n    case OPC_BALC: /* OPC_SWC2 */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BC, OPC_BALC */\n\n            gen_compute_compact_branch(ctx, op, 0, 0,\n\n                                       sextract32(ctx->opcode << 2, 0, 28));\n\n        } else {\n\n            /* OPC_LWC2, OPC_SWC2 */\n\n            /* COP2: Not implemented. */\n\n            generate_exception_err(ctx, EXCP_CpU, 2);\n\n        }\n\n        break;\n\n    case OPC_BEQZC: /* OPC_JIC, OPC_LDC2 */\n\n    case OPC_BNEZC: /* OPC_JIALC, OPC_SDC2 */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rs != 0) {\n\n                /* OPC_BEQZC, OPC_BNEZC */\n\n                gen_compute_compact_branch(ctx, op, rs, 0,\n\n                                           sextract32(ctx->opcode << 2, 0, 23));\n\n            } else {\n\n                /* OPC_JIC, OPC_JIALC */\n\n                gen_compute_compact_branch(ctx, op, 0, rt, imm);\n\n            }\n\n        } else {\n\n            /* OPC_LWC2, OPC_SWC2 */\n\n            /* COP2: Not implemented. */\n\n            generate_exception_err(ctx, EXCP_CpU, 2);\n\n        }\n\n        break;\n\n    case OPC_CP2:\n\n        check_insn(ctx, INSN_LOONGSON2F);\n\n        /* Note that these instructions use different fields.  */\n\n        gen_loongson_multimedia(ctx, sa, rd, rt);\n\n        break;\n\n\n\n    case OPC_CP3:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        if (ctx->CP0_Config1 & (1 << CP0C1_FP)) {\n\n            check_cp1_enabled(ctx);\n\n            op1 = MASK_CP3(ctx->opcode);\n\n            switch (op1) {\n\n            case OPC_LWXC1:\n\n            case OPC_LDXC1:\n\n            case OPC_LUXC1:\n\n            case OPC_SWXC1:\n\n            case OPC_SDXC1:\n\n            case OPC_SUXC1:\n\n                gen_flt3_ldst(ctx, op1, sa, rd, rs, rt);\n\n                break;\n\n            case OPC_PREFX:\n\n                /* Treat as NOP. */\n\n                break;\n\n            case OPC_ALNV_PS:\n\n            case OPC_MADD_S:\n\n            case OPC_MADD_D:\n\n            case OPC_MADD_PS:\n\n            case OPC_MSUB_S:\n\n            case OPC_MSUB_D:\n\n            case OPC_MSUB_PS:\n\n            case OPC_NMADD_S:\n\n            case OPC_NMADD_D:\n\n            case OPC_NMADD_PS:\n\n            case OPC_NMSUB_S:\n\n            case OPC_NMSUB_D:\n\n            case OPC_NMSUB_PS:\n\n                gen_flt3_arith(ctx, op1, sa, rs, rd, rt);\n\n                break;\n\n            default:\n\n                MIPS_INVAL(\"cp3\");\n\n                generate_exception (ctx, EXCP_RI);\n\n                break;\n\n            }\n\n        } else {\n\n            generate_exception_err(ctx, EXCP_CpU, 1);\n\n        }\n\n        break;\n\n\n\n#if defined(TARGET_MIPS64)\n\n    /* MIPS64 opcodes */\n\n    case OPC_LDL ... OPC_LDR:\n\n    case OPC_LLD:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_LWU:\n\n    case OPC_LD:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_ld(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_SDL ... OPC_SDR:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_SD:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_st(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_SCD:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_st_cond(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_BNVC: /* OPC_BNEZALC, OPC_BNEC, OPC_DADDI */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BNVC, OPC_BNEZALC, OPC_BNEC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_DADDI */\n\n            check_insn(ctx, ISA_MIPS3);\n\n            check_mips_64(ctx);\n\n            gen_arith_imm(ctx, op, rt, rs, imm);\n\n        }\n\n        break;\n\n    case OPC_DADDIU:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_arith_imm(ctx, op, rt, rs, imm);\n\n        break;\n\n#else\n\n    case OPC_BNVC: /* OPC_BNEZALC, OPC_BNEC */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            MIPS_INVAL(\"major opcode\");\n\n            generate_exception(ctx, EXCP_RI);\n\n        }\n\n        break;\n\n#endif\n\n    case OPC_DAUI: /* OPC_JALX */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n#if defined(TARGET_MIPS64)\n\n            /* OPC_DAUI */\n\n            check_mips_64(ctx);\n\n            if (rt != 0) {\n\n                TCGv t0 = tcg_temp_new();\n\n                gen_load_gpr(t0, rs);\n\n                tcg_gen_addi_tl(cpu_gpr[rt], t0, imm << 16);\n\n                tcg_temp_free(t0);\n\n            }\n\n            MIPS_DEBUG(\"daui %s, %s, %04x\", regnames[rt], regnames[rs], imm);\n\n#else\n\n            generate_exception(ctx, EXCP_RI);\n\n            MIPS_INVAL(\"major opcode\");\n\n#endif\n\n        } else {\n\n            /* OPC_JALX */\n\n            check_insn(ctx, ASE_MIPS16 | ASE_MICROMIPS);\n\n            offset = (int32_t)(ctx->opcode & 0x3FFFFFF) << 2;\n\n            gen_compute_branch(ctx, op, 4, rs, rt, offset, 4);\n\n        }\n\n        break;\n\n    case OPC_MDMX:\n\n        check_insn(ctx, ASE_MDMX);\n\n        /* MDMX: Not implemented. */\n\n        break;\n\n    case OPC_PCREL:\n\n        check_insn(ctx, ISA_MIPS32R6);\n\n        gen_pcrel(ctx, rs, imm);\n\n        break;\n\n    default:            /* Invalid */\n\n        MIPS_INVAL(\"major opcode\");\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n}\n", "idx": 15980, "_split": "test", "_hash": "db8ab0a059a17d16b6446aa3e24a78b1"}
{"project": "qemu", "commit_id": "8f3a73bc57ea83e5b3930d14fc596ea51859987a", "target": 0, "func": "bool blk_dev_is_tray_open(BlockBackend *blk)\n\n{\n\n    if (blk->dev_ops && blk->dev_ops->is_tray_open) {\n\n        return blk->dev_ops->is_tray_open(blk->dev_opaque);\n\n    }\n\n    return false;\n\n}\n", "idx": 15985, "_split": "test", "_hash": "00d5b7c547eb2fb54db45241f76c2593"}
{"project": "qemu", "commit_id": "3010460fb99776bdf0a8b170555f2ab076382f9c", "target": 1, "func": "int hvf_vcpu_exec(CPUState *cpu)\n\n{\n\n    X86CPU *x86_cpu = X86_CPU(cpu);\n\n    CPUX86State *env = &x86_cpu->env;\n\n    int ret = 0;\n\n    uint64_t rip = 0;\n\n\n\n    cpu->halted = 0;\n\n\n\n    if (hvf_process_events(cpu)) {\n\n        return EXCP_HLT;\n\n    }\n\n\n\n    do {\n\n        if (cpu->vcpu_dirty) {\n\n            hvf_put_registers(cpu);\n\n            cpu->vcpu_dirty = false;\n\n        }\n\n\n\n        if (hvf_inject_interrupts(cpu)) {\n\n            return EXCP_INTERRUPT;\n\n        }\n\n        vmx_update_tpr(cpu);\n\n\n\n        qemu_mutex_unlock_iothread();\n\n        if (!cpu_is_bsp(X86_CPU(cpu)) && cpu->halted) {\n\n            qemu_mutex_lock_iothread();\n\n            return EXCP_HLT;\n\n        }\n\n\n\n        hv_return_t r  = hv_vcpu_run(cpu->hvf_fd);\n\n        assert_hvf_ok(r);\n\n\n\n        /* handle VMEXIT */\n\n        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);\n\n        uint64_t exit_qual = rvmcs(cpu->hvf_fd, VMCS_EXIT_QUALIFICATION);\n\n        uint32_t ins_len = (uint32_t)rvmcs(cpu->hvf_fd,\n\n                                           VMCS_EXIT_INSTRUCTION_LENGTH);\n\n\n\n        uint64_t idtvec_info = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n\n\n\n        hvf_store_events(cpu, ins_len, idtvec_info);\n\n        rip = rreg(cpu->hvf_fd, HV_X86_RIP);\n\n        RFLAGS(env) = rreg(cpu->hvf_fd, HV_X86_RFLAGS);\n\n        env->eflags = RFLAGS(env);\n\n\n\n        qemu_mutex_lock_iothread();\n\n\n\n        update_apic_tpr(cpu);\n\n        current_cpu = cpu;\n\n\n\n        ret = 0;\n\n        switch (exit_reason) {\n\n        case EXIT_REASON_HLT: {\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            if (!((cpu->interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                (EFLAGS(env) & IF_MASK))\n\n                && !(cpu->interrupt_request & CPU_INTERRUPT_NMI) &&\n\n                !(idtvec_info & VMCS_IDT_VEC_VALID)) {\n\n                cpu->halted = 1;\n\n                ret = EXCP_HLT;\n\n            }\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n        case EXIT_REASON_MWAIT: {\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n            /* Need to check if MMIO or unmmaped fault */\n\n        case EXIT_REASON_EPT_FAULT:\n\n        {\n\n            hvf_slot *slot;\n\n            addr_t gpa = rvmcs(cpu->hvf_fd, VMCS_GUEST_PHYSICAL_ADDRESS);\n\n\n\n            if (((idtvec_info & VMCS_IDT_VEC_VALID) == 0) &&\n\n                ((exit_qual & EXIT_QUAL_NMIUDTI) != 0)) {\n\n                vmx_set_nmi_blocking(cpu);\n\n            }\n\n\n\n            slot = hvf_find_overlap_slot(gpa, gpa);\n\n            /* mmio */\n\n            if (ept_emulation_fault(slot, gpa, exit_qual)) {\n\n                struct x86_decode decode;\n\n\n\n                load_regs(cpu);\n\n                env->hvf_emul->fetch_rip = rip;\n\n\n\n                decode_instruction(env, &decode);\n\n                exec_instruction(env, &decode);\n\n                store_regs(cpu);\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n        case EXIT_REASON_INOUT:\n\n        {\n\n            uint32_t in = (exit_qual & 8) != 0;\n\n            uint32_t size =  (exit_qual & 7) + 1;\n\n            uint32_t string =  (exit_qual & 16) != 0;\n\n            uint32_t port =  exit_qual >> 16;\n\n            /*uint32_t rep = (exit_qual & 0x20) != 0;*/\n\n\n\n#if 1\n\n            if (!string && in) {\n\n                uint64_t val = 0;\n\n                load_regs(cpu);\n\n                hvf_handle_io(env, port, &val, 0, size, 1);\n\n                if (size == 1) {\n\n                    AL(env) = val;\n\n                } else if (size == 2) {\n\n                    AX(env) = val;\n\n                } else if (size == 4) {\n\n                    RAX(env) = (uint32_t)val;\n\n                } else {\n\n                    VM_PANIC(\"size\");\n\n                }\n\n                RIP(env) += ins_len;\n\n                store_regs(cpu);\n\n                break;\n\n            } else if (!string && !in) {\n\n                RAX(env) = rreg(cpu->hvf_fd, HV_X86_RAX);\n\n                hvf_handle_io(env, port, &RAX(env), 1, size, 1);\n\n                macvm_set_rip(cpu, rip + ins_len);\n\n                break;\n\n            }\n\n#endif\n\n            struct x86_decode decode;\n\n\n\n            load_regs(cpu);\n\n            env->hvf_emul->fetch_rip = rip;\n\n\n\n            decode_instruction(env, &decode);\n\n            VM_PANIC_ON(ins_len != decode.len);\n\n            exec_instruction(env, &decode);\n\n            store_regs(cpu);\n\n\n\n            break;\n\n        }\n\n        case EXIT_REASON_CPUID: {\n\n            uint32_t rax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);\n\n            uint32_t rbx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RBX);\n\n            uint32_t rcx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);\n\n            uint32_t rdx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);\n\n\n\n            cpu_x86_cpuid(env, rax, rcx, &rax, &rbx, &rcx, &rdx);\n\n\n\n            wreg(cpu->hvf_fd, HV_X86_RAX, rax);\n\n            wreg(cpu->hvf_fd, HV_X86_RBX, rbx);\n\n            wreg(cpu->hvf_fd, HV_X86_RCX, rcx);\n\n            wreg(cpu->hvf_fd, HV_X86_RDX, rdx);\n\n\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        }\n\n        case EXIT_REASON_XSETBV: {\n\n            X86CPU *x86_cpu = X86_CPU(cpu);\n\n            CPUX86State *env = &x86_cpu->env;\n\n            uint32_t eax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);\n\n            uint32_t ecx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);\n\n            uint32_t edx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);\n\n\n\n            if (ecx) {\n\n                macvm_set_rip(cpu, rip + ins_len);\n\n                break;\n\n            }\n\n            env->xcr0 = ((uint64_t)edx << 32) | eax;\n\n            wreg(cpu->hvf_fd, HV_X86_XCR0, env->xcr0 | 1);\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        }\n\n        case EXIT_REASON_INTR_WINDOW:\n\n            vmx_clear_int_window_exiting(cpu);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_NMI_WINDOW:\n\n            vmx_clear_nmi_window_exiting(cpu);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_EXT_INTR:\n\n            /* force exit and allow io handling */\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_RDMSR:\n\n        case EXIT_REASON_WRMSR:\n\n        {\n\n            load_regs(cpu);\n\n            if (exit_reason == EXIT_REASON_RDMSR) {\n\n                simulate_rdmsr(cpu);\n\n            } else {\n\n                simulate_wrmsr(cpu);\n\n            }\n\n            RIP(env) += rvmcs(cpu->hvf_fd, VMCS_EXIT_INSTRUCTION_LENGTH);\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_CR_ACCESS: {\n\n            int cr;\n\n            int reg;\n\n\n\n            load_regs(cpu);\n\n            cr = exit_qual & 15;\n\n            reg = (exit_qual >> 8) & 15;\n\n\n\n            switch (cr) {\n\n            case 0x0: {\n\n                macvm_set_cr0(cpu->hvf_fd, RRX(env, reg));\n\n                break;\n\n            }\n\n            case 4: {\n\n                macvm_set_cr4(cpu->hvf_fd, RRX(env, reg));\n\n                break;\n\n            }\n\n            case 8: {\n\n                X86CPU *x86_cpu = X86_CPU(cpu);\n\n                if (exit_qual & 0x10) {\n\n                    RRX(env, reg) = cpu_get_apic_tpr(x86_cpu->apic_state);\n\n                } else {\n\n                    int tpr = RRX(env, reg);\n\n                    cpu_set_apic_tpr(x86_cpu->apic_state, tpr);\n\n                    ret = EXCP_INTERRUPT;\n\n                }\n\n                break;\n\n            }\n\n            default:\n\n                error_report(\"Unrecognized CR %d\\n\", cr);\n\n                abort();\n\n            }\n\n            RIP(env) += ins_len;\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_APIC_ACCESS: { /* TODO */\n\n            struct x86_decode decode;\n\n\n\n            load_regs(cpu);\n\n            env->hvf_emul->fetch_rip = rip;\n\n\n\n            decode_instruction(env, &decode);\n\n            exec_instruction(env, &decode);\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_TPR: {\n\n            ret = 1;\n\n            break;\n\n        }\n\n        case EXIT_REASON_TASK_SWITCH: {\n\n            uint64_t vinfo = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n\n            x68_segment_selector sel = {.sel = exit_qual & 0xffff};\n\n            vmx_handle_task_switch(cpu, sel, (exit_qual >> 30) & 0x3,\n\n             vinfo & VMCS_INTR_VALID, vinfo & VECTORING_INFO_VECTOR_MASK, vinfo\n\n             & VMCS_INTR_T_MASK);\n\n            break;\n\n        }\n\n        case EXIT_REASON_TRIPLE_FAULT: {\n\n            qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n        case EXIT_REASON_RDPMC:\n\n            wreg(cpu->hvf_fd, HV_X86_RAX, 0);\n\n            wreg(cpu->hvf_fd, HV_X86_RDX, 0);\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        case VMX_REASON_VMCALL:\n\n            /* TODO: inject #GP fault */\n\n            break;\n\n        default:\n\n            error_report(\"%llx: unhandled exit %llx\\n\", rip, exit_reason);\n\n        }\n\n    } while (ret == 0);\n\n\n\n    return ret;\n\n}\n", "idx": 15999, "_split": "test", "_hash": "2d84a36070c55b547b0c4a2d4c3a45e2"}
{"project": "qemu", "commit_id": "b5eff355460643d09e533024360fe0522f368c07", "target": 1, "func": "int bdrv_pwrite(BlockDriverState *bs, int64_t offset,\n\n                const void *buf1, int count1)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n    if (!drv->bdrv_pwrite)\n\n        return bdrv_pwrite_em(bs, offset, buf1, count1);\n\n    if (bdrv_wr_badreq_bytes(bs, offset, count1))\n\n        return -EDOM;\n\n    return drv->bdrv_pwrite(bs, offset, buf1, count1);\n\n}\n", "idx": 16047, "_split": "test", "_hash": "51492fc823507244b8a9815a647fbca6"}
{"project": "qemu", "commit_id": "ac125d993b461d4dee4d6df4d93ac3f2eb959d1d", "target": 1, "func": "static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)\n\n{\n\n    char *buffer;\n\n    int ret;\n\n    char *path = fs_path->data;\n\n\n\n    buffer = rpath(ctx, path);\n\n    ret = truncate(buffer, size);\n\n    g_free(buffer);\n\n    return ret;\n\n}\n", "idx": 16057, "_split": "test", "_hash": "9d231d2b42a16ed481916c0c58074993"}
{"project": "qemu", "commit_id": "8ba2aae32c40f544def6be7ae82be9bcb781e01d", "target": 0, "func": "void uuid_unparse(const uuid_t uu, char *out)\n\n{\n\n    snprintf(out, 37, UUID_FMT,\n\n            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],\n\n            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);\n\n}\n", "idx": 16068, "_split": "test", "_hash": "923c7b4c4d654a254fadf43b75509230"}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static int stellaris_enet_can_receive(void *opaque)\n\n{\n\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n\n\n\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n\n        return 1;\n\n\n\n    return (s->np < 31);\n\n}\n", "idx": 16083, "_split": "test", "_hash": "352ad13c92f8419bf4b588c2a480e19b"}
{"project": "qemu", "commit_id": "75f27498220e6ff6f78bf08fbe2cc662ec76ba89", "target": 0, "func": "void acpi_memory_unplug_cb(MemHotplugState *mem_st,\n\n                           DeviceState *dev, Error **errp)\n\n{\n\n    MemStatus *mdev;\n\n\n\n    mdev = acpi_memory_slot_status(mem_st, dev, errp);\n\n    if (!mdev) {\n\n        return;\n\n    }\n\n\n\n    /* nvdimm device hot unplug is not supported yet. */\n\n    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));\n\n    mdev->is_enabled = false;\n\n    mdev->dimm = NULL;\n\n}\n", "idx": 16089, "_split": "test", "_hash": "4f1929949196d9d9d7e6c386be1b83c8"}
{"project": "qemu", "commit_id": "a7824a886ed50eb4fe3c6fcd6afd8814a6973583", "target": 0, "func": "alloc_f(int argc, char **argv)\n\n{\n\n\tint64_t offset;\n\n\tint nb_sectors;\n\n\tchar s1[64];\n\n\tint num;\n\n\tint ret;\n\n\tconst char *retstr;\n\n\n\n\toffset = cvtnum(argv[1]);\n\n\tif (offset & 0x1ff) {\n\n\t\tprintf(\"offset %lld is not sector aligned\\n\",\n\n\t\t\t(long long)offset);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tif (argc == 3)\n\n\t\tnb_sectors = cvtnum(argv[2]);\n\n\telse\n\n\t\tnb_sectors = 1;\n\n\n\n\tret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);\n\n\n\n\tcvtstr(offset, s1, sizeof(s1));\n\n\n\n\tretstr = ret ? \"allocated\" : \"not allocated\";\n\n\tif (nb_sectors == 1)\n\n\t\tprintf(\"sector %s at offset %s\\n\", retstr, s1);\n\n\telse\n\n\t\tprintf(\"%d/%d sectors %s at offset %s\\n\",\n\n\t\t\tnum, nb_sectors, retstr, s1);\n\n\treturn 0;\n\n}\n", "idx": 16090, "_split": "test", "_hash": "751dfd5e41fcc56fd02999eb7a426d1b"}
{"project": "qemu", "commit_id": "788cf9f8c8cbda53843e060540f3e91a060eb744", "target": 1, "func": "static void hmp_cont_cb(void *opaque, int err)\n\n{\n\n    if (!err) {\n\n        qmp_cont(NULL);\n\n    }\n\n}\n", "idx": 16093, "_split": "test", "_hash": "fbcb0fe85242d043d3ac049fd0ec55c6"}
{"project": "qemu", "commit_id": "36fef36b91f7ec0435215860f1458b5342ce2811", "target": 1, "func": "static int megasas_ctrl_get_info(MegasasState *s, MegasasCmd *cmd)\n\n{\n\n    PCIDevice *pci_dev = PCI_DEVICE(s);\n\n    PCIDeviceClass *pci_class = PCI_DEVICE_GET_CLASS(pci_dev);\n\n    MegasasBaseClass *base_class = MEGASAS_DEVICE_GET_CLASS(s);\n\n    struct mfi_ctrl_info info;\n\n    size_t dcmd_size = sizeof(info);\n\n    BusChild *kid;\n\n    int num_pd_disks = 0;\n\n\n\n    memset(&info, 0x0, cmd->iov_size);\n\n    if (cmd->iov_size < dcmd_size) {\n\n        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,\n\n                                            dcmd_size);\n\n        return MFI_STAT_INVALID_PARAMETER;\n\n    }\n\n\n\n    info.pci.vendor = cpu_to_le16(pci_class->vendor_id);\n\n    info.pci.device = cpu_to_le16(pci_class->device_id);\n\n    info.pci.subvendor = cpu_to_le16(pci_class->subsystem_vendor_id);\n\n    info.pci.subdevice = cpu_to_le16(pci_class->subsystem_id);\n\n\n\n    /*\n\n     * For some reason the firmware supports\n\n     * only up to 8 device ports.\n\n     * Despite supporting a far larger number\n\n     * of devices for the physical devices.\n\n     * So just display the first 8 devices\n\n     * in the device port list, independent\n\n     * of how many logical devices are actually\n\n     * present.\n\n     */\n\n    info.host.type = MFI_INFO_HOST_PCIE;\n\n    info.device.type = MFI_INFO_DEV_SAS3G;\n\n    info.device.port_count = 8;\n\n    QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {\n\n        SCSIDevice *sdev = DO_UPCAST(SCSIDevice, qdev, kid->child);\n\n        uint16_t pd_id;\n\n\n\n        if (num_pd_disks < 8) {\n\n            pd_id = ((sdev->id & 0xFF) << 8) | (sdev->lun & 0xFF);\n\n            info.device.port_addr[num_pd_disks] =\n\n                cpu_to_le64(megasas_get_sata_addr(pd_id));\n\n        }\n\n        num_pd_disks++;\n\n    }\n\n\n\n    memcpy(info.product_name, base_class->product_name, 24);\n\n    snprintf(info.serial_number, 32, \"%s\", s->hba_serial);\n\n    snprintf(info.package_version, 0x60, \"%s-QEMU\", qemu_hw_version());\n\n    memcpy(info.image_component[0].name, \"APP\", 3);\n\n    snprintf(info.image_component[0].version, 10, \"%s-QEMU\",\n\n             base_class->product_version);\n\n    memcpy(info.image_component[0].build_date, \"Apr  1 2014\", 11);\n\n    memcpy(info.image_component[0].build_time, \"12:34:56\", 8);\n\n    info.image_component_count = 1;\n\n    if (pci_dev->has_rom) {\n\n        uint8_t biosver[32];\n\n        uint8_t *ptr;\n\n\n\n        ptr = memory_region_get_ram_ptr(&pci_dev->rom);\n\n        memcpy(biosver, ptr + 0x41, 31);\n\n        memcpy(info.image_component[1].name, \"BIOS\", 4);\n\n        memcpy(info.image_component[1].version, biosver,\n\n               strlen((const char *)biosver));\n\n        info.image_component_count++;\n\n    }\n\n    info.current_fw_time = cpu_to_le32(megasas_fw_time());\n\n    info.max_arms = 32;\n\n    info.max_spans = 8;\n\n    info.max_arrays = MEGASAS_MAX_ARRAYS;\n\n    info.max_lds = MFI_MAX_LD;\n\n    info.max_cmds = cpu_to_le16(s->fw_cmds);\n\n    info.max_sg_elements = cpu_to_le16(s->fw_sge);\n\n    info.max_request_size = cpu_to_le32(MEGASAS_MAX_SECTORS);\n\n    if (!megasas_is_jbod(s))\n\n        info.lds_present = cpu_to_le16(num_pd_disks);\n\n    info.pd_present = cpu_to_le16(num_pd_disks);\n\n    info.pd_disks_present = cpu_to_le16(num_pd_disks);\n\n    info.hw_present = cpu_to_le32(MFI_INFO_HW_NVRAM |\n\n                                   MFI_INFO_HW_MEM |\n\n                                   MFI_INFO_HW_FLASH);\n\n    info.memory_size = cpu_to_le16(512);\n\n    info.nvram_size = cpu_to_le16(32);\n\n    info.flash_size = cpu_to_le16(16);\n\n    info.raid_levels = cpu_to_le32(MFI_INFO_RAID_0);\n\n    info.adapter_ops = cpu_to_le32(MFI_INFO_AOPS_RBLD_RATE |\n\n                                    MFI_INFO_AOPS_SELF_DIAGNOSTIC |\n\n                                    MFI_INFO_AOPS_MIXED_ARRAY);\n\n    info.ld_ops = cpu_to_le32(MFI_INFO_LDOPS_DISK_CACHE_POLICY |\n\n                               MFI_INFO_LDOPS_ACCESS_POLICY |\n\n                               MFI_INFO_LDOPS_IO_POLICY |\n\n                               MFI_INFO_LDOPS_WRITE_POLICY |\n\n                               MFI_INFO_LDOPS_READ_POLICY);\n\n    info.max_strips_per_io = cpu_to_le16(s->fw_sge);\n\n    info.stripe_sz_ops.min = 3;\n\n    info.stripe_sz_ops.max = ctz32(MEGASAS_MAX_SECTORS + 1);\n\n    info.properties.pred_fail_poll_interval = cpu_to_le16(300);\n\n    info.properties.intr_throttle_cnt = cpu_to_le16(16);\n\n    info.properties.intr_throttle_timeout = cpu_to_le16(50);\n\n    info.properties.rebuild_rate = 30;\n\n    info.properties.patrol_read_rate = 30;\n\n    info.properties.bgi_rate = 30;\n\n    info.properties.cc_rate = 30;\n\n    info.properties.recon_rate = 30;\n\n    info.properties.cache_flush_interval = 4;\n\n    info.properties.spinup_drv_cnt = 2;\n\n    info.properties.spinup_delay = 6;\n\n    info.properties.ecc_bucket_size = 15;\n\n    info.properties.ecc_bucket_leak_rate = cpu_to_le16(1440);\n\n    info.properties.expose_encl_devices = 1;\n\n    info.properties.OnOffProperties = cpu_to_le32(MFI_CTRL_PROP_EnableJBOD);\n\n    info.pd_ops = cpu_to_le32(MFI_INFO_PDOPS_FORCE_ONLINE |\n\n                               MFI_INFO_PDOPS_FORCE_OFFLINE);\n\n    info.pd_mix_support = cpu_to_le32(MFI_INFO_PDMIX_SAS |\n\n                                       MFI_INFO_PDMIX_SATA |\n\n                                       MFI_INFO_PDMIX_LD);\n\n\n\n    cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);\n\n    return MFI_STAT_OK;\n\n}\n", "idx": 16112, "_split": "test", "_hash": "901bc619dac3b7df84be17cc08bb3833"}
{"project": "qemu", "commit_id": "fa3aad24d94a6cf894db52d83f72a399324a17bb", "target": 0, "func": "int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,\n\n                       void *opaque, int version_id)\n\n{\n\n    VMStateField *field = vmsd->fields;\n\n\n\n    if (version_id > vmsd->version_id) {\n\n        return -EINVAL;\n\n    }\n\n    if (version_id < vmsd->minimum_version_id_old) {\n\n        return -EINVAL;\n\n    }\n\n    if  (version_id < vmsd->minimum_version_id) {\n\n        return vmsd->load_state_old(f, opaque, version_id);\n\n    }\n\n    while(field->name) {\n\n        if (field->version_id <= version_id) {\n\n            void *base_addr = opaque + field->offset;\n\n            int ret, i, n_elems = 1;\n\n\n\n            if (field->flags & VMS_ARRAY) {\n\n                n_elems = field->num;\n\n            } else if (field->flags & VMS_VARRAY) {\n\n                n_elems = *(size_t *)(opaque+field->num_offset);\n\n            }\n\n            if (field->flags & VMS_POINTER) {\n\n                base_addr = *(void **)base_addr;\n\n            }\n\n            for (i = 0; i < n_elems; i++) {\n\n                void *addr = base_addr + field->size * i;\n\n\n\n                if (field->flags & VMS_STRUCT) {\n\n                    ret = vmstate_load_state(f, field->vmsd, addr, version_id);\n\n                } else {\n\n                    ret = field->info->get(f, addr, field->size);\n\n\n\n                }\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n            }\n\n        }\n\n        field++;\n\n    }\n\n    if (vmsd->run_after_load)\n\n        return vmsd->run_after_load(opaque);\n\n    return 0;\n\n}\n", "idx": 16147, "_split": "test", "_hash": "29186c547a4b46d0b234d0c0d46a766a"}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_setcond2(TCGContext *s, TCGCond cond, TCGReg ret,\n\n                             TCGReg al, TCGReg ah, TCGReg bl, TCGReg bh)\n\n{\n\n    TCGReg tmp0 = TCG_TMP0;\n\n    TCGReg tmp1 = ret;\n\n\n\n    assert(ret != TCG_TMP0);\n\n    if (ret == ah || ret == bh) {\n\n        assert(ret != TCG_TMP1);\n\n        tmp1 = TCG_TMP1;\n\n    }\n\n\n\n    switch (cond) {\n\n    case TCG_COND_EQ:\n\n    case TCG_COND_NE:\n\n        tmp1 = tcg_out_reduce_eq2(s, tmp0, tmp1, al, ah, bl, bh);\n\n        tcg_out_setcond(s, cond, ret, tmp1, TCG_REG_ZERO);\n\n        break;\n\n\n\n    default:\n\n        tcg_out_setcond(s, TCG_COND_EQ, tmp0, ah, bh);\n\n        tcg_out_setcond(s, tcg_unsigned_cond(cond), tmp1, al, bl);\n\n        tcg_out_opc_reg(s, OPC_AND, tmp1, tmp1, tmp0);\n\n        tcg_out_setcond(s, tcg_high_cond(cond), tmp0, ah, bh);\n\n        tcg_out_opc_reg(s, OPC_OR, ret, tmp1, tmp0);\n\n        break;\n\n    }\n\n}\n", "idx": 16155, "_split": "test", "_hash": "887962bfe1ade4099211dcd115abb0f9"}
{"project": "qemu", "commit_id": "28f4a7083dcca084243e313ab18fcdb20d60334e", "target": 0, "func": "static void display_mouse_define(DisplayChangeListener *dcl,\n\n                                 QEMUCursor *c)\n\n{\n\n    SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);\n\n\n\n    qemu_mutex_lock(&ssd->lock);\n\n    if (c) {\n\n        cursor_get(c);\n\n    }\n\n    cursor_put(ssd->cursor);\n\n    ssd->cursor = c;\n\n    ssd->hot_x = c->hot_x;\n\n    ssd->hot_y = c->hot_y;\n\n    g_free(ssd->ptr_move);\n\n    ssd->ptr_move = NULL;\n\n    g_free(ssd->ptr_define);\n\n    ssd->ptr_define = qemu_spice_create_cursor_update(ssd, c, 0);\n\n    qemu_mutex_unlock(&ssd->lock);\n\n}\n", "idx": 16163, "_split": "test", "_hash": "8ae40f613fd4e3068a59045553e115ec"}
{"project": "qemu", "commit_id": "149f54b53b7666a3facd45e86eece60ce7d3b114", "target": 0, "func": "static inline void stw_phys_internal(hwaddr addr, uint32_t val,\n\n                                     enum device_endian endian)\n\n{\n\n    uint8_t *ptr;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!memory_region_is_ram(section->mr) || section->readonly) {\n\n        addr = memory_region_section_addr(section, addr);\n\n        if (memory_region_is_ram(section->mr)) {\n\n            section = &phys_sections[phys_section_rom];\n\n        }\n\n#if defined(TARGET_WORDS_BIGENDIAN)\n\n        if (endian == DEVICE_LITTLE_ENDIAN) {\n\n            val = bswap16(val);\n\n        }\n\n#else\n\n        if (endian == DEVICE_BIG_ENDIAN) {\n\n            val = bswap16(val);\n\n        }\n\n#endif\n\n        io_mem_write(section->mr, addr, val, 2);\n\n    } else {\n\n        unsigned long addr1;\n\n        addr1 = (memory_region_get_ram_addr(section->mr) & TARGET_PAGE_MASK)\n\n            + memory_region_section_addr(section, addr);\n\n        /* RAM case */\n\n        ptr = qemu_get_ram_ptr(addr1);\n\n        switch (endian) {\n\n        case DEVICE_LITTLE_ENDIAN:\n\n            stw_le_p(ptr, val);\n\n            break;\n\n        case DEVICE_BIG_ENDIAN:\n\n            stw_be_p(ptr, val);\n\n            break;\n\n        default:\n\n            stw_p(ptr, val);\n\n            break;\n\n        }\n\n        invalidate_and_set_dirty(addr1, 2);\n\n    }\n\n}\n", "idx": 16164, "_split": "test", "_hash": "f04f3909bcf1d3546629cdac8c637c77"}
{"project": "qemu", "commit_id": "4ed7b2c3a78f785a1bcbe575e08c379b166723e3", "target": 1, "func": "static int local_open2(FsContext *fs_ctx, V9fsPath *dir_path, const char *name,\n\n                       int flags, FsCred *credp, V9fsFidOpenState *fs)\n\n{\n\n    char *path;\n\n    int fd = -1;\n\n    int err = -1;\n\n    int serrno = 0;\n\n    V9fsString fullname;\n\n    char *buffer;\n\n\n\n    /*\n\n     * Mark all the open to not follow symlinks\n\n     */\n\n    flags |= O_NOFOLLOW;\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    path = fullname.data;\n\n\n\n    /* Determine the security model */\n\n    if (fs_ctx->export_flags & V9FS_SM_MAPPED) {\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set cleint credentials in xattr */\n\n        err = local_set_xattr(buffer, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set client credentials in .virtfs_metadata directory files */\n\n        err = local_set_mapped_file_attr(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if ((fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||\n\n               (fs_ctx->export_flags & V9FS_SM_NONE)) {\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, flags, credp->fc_mode);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        err = local_post_create_passthrough(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    }\n\n    err = fd;\n\n    fs->fd = fd;\n\n    goto out;\n\n\n\nerr_end:\n\n    close(fd);\n\n    remove(buffer);\n\n    errno = serrno;\n\n    g_free(buffer);\n\nout:\n\n    v9fs_string_free(&fullname);\n\n    return err;\n\n}\n", "idx": 16204, "_split": "test", "_hash": "804b8969ec18e4a2d518ecc688863385"}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mtdcrx(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],\n\n                         cpu_gpr[rS(ctx->opcode)]);\n\n    /* Note: Rc update flag set leads to undefined state of Rc0 */\n\n#endif\n\n}\n", "idx": 16207, "_split": "test", "_hash": "b6c90cf778090806f33a2dd3f6c664dd"}
{"project": "qemu", "commit_id": "e2f89926f19d2940eda070542501f39f51a8c81f", "target": 1, "func": "int usb_packet_map(USBPacket *p, QEMUSGList *sgl)\n\n{\n\n    int is_write = (p->pid == USB_TOKEN_IN);\n\n    target_phys_addr_t len;\n\n    void *mem;\n\n    int i;\n\n\n\n    for (i = 0; i < sgl->nsg; i++) {\n\n        len = sgl->sg[i].len;\n\n        mem = cpu_physical_memory_map(sgl->sg[i].base, &len,\n\n                                      is_write);\n\n        if (!mem) {\n\n            goto err;\n\n        }\n\n        qemu_iovec_add(&p->iov, mem, len);\n\n        if (len != sgl->sg[i].len) {\n\n            goto err;\n\n        }\n\n    }\n\n    return 0;\n\n\n\nerr:\n\n    usb_packet_unmap(p);\n\n    return -1;\n\n}\n", "idx": 16211, "_split": "test", "_hash": "29f6c7746c6f2baa1679071834719992"}
{"project": "qemu", "commit_id": "73d60fa5fae60c8e07e1f295d8c7fd5d04320160", "target": 1, "func": "static void get_sensor_evt_status(IPMIBmcSim *ibs,\n\n                                  uint8_t *cmd, unsigned int cmd_len,\n\n                                  uint8_t *rsp, unsigned int *rsp_len,\n\n                                  unsigned int max_rsp_len)\n\n{\n\n    IPMISensor *sens;\n\n\n\n    IPMI_CHECK_CMD_LEN(3);\n\n    if ((cmd[2] > MAX_SENSORS) ||\n\n        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {\n\n        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;\n\n        return;\n\n    }\n\n    sens = ibs->sensors + cmd[2];\n\n    IPMI_ADD_RSP_DATA(sens->reading);\n\n    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));\n\n    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);\n\n    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);\n\n}\n", "idx": 16216, "_split": "test", "_hash": "06986346c9cb522e39b66e3bf2715da5"}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,\n\n                     int ret, int rw)\n\n{\n\n    int store = 0;\n\n\n\n    /* Update page flags */\n\n    if (!(*pte1p & 0x00000100)) {\n\n        /* Update accessed flag */\n\n        *pte1p |= 0x00000100;\n\n        store = 1;\n\n    }\n\n    if (!(*pte1p & 0x00000080)) {\n\n        if (rw == 1 && ret == 0) {\n\n            /* Update changed flag */\n\n            *pte1p |= 0x00000080;\n\n            store = 1;\n\n        } else {\n\n            /* Force page fault for first write access */\n\n            ctx->prot &= ~PAGE_WRITE;\n\n        }\n\n    }\n\n\n\n    return store;\n\n}\n", "idx": 16237, "_split": "test", "_hash": "1589e5c70a94894af3fe6b19c5c2b3de"}
{"project": "qemu", "commit_id": "5a2223ca26b1a34e131b5b9a63599d9426d2c25c", "target": 0, "func": "static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)\n\n{\n\n    s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);\n\n}\n", "idx": 16246, "_split": "test", "_hash": "417b8da73d097f3e62f371f8b60bbc89"}
{"project": "qemu", "commit_id": "22d5cd82e98b61b1dbd791fab9f4ae0f77c0ed14", "target": 0, "func": "static int raw_inactivate(BlockDriverState *bs)\n\n{\n\n    int ret;\n\n    uint64_t perm = 0;\n\n    uint64_t shared = BLK_PERM_ALL;\n\n\n\n    ret = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, NULL);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);\n\n    return 0;\n\n}\n", "idx": 16274, "_split": "test", "_hash": "f1fa9b2a299b5148362043f79dde5656"}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,\n\n                                Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    qobject_incref(*obj);\n\n    qmp_output_add_obj(qov, name, *obj);\n\n}\n", "idx": 16276, "_split": "test", "_hash": "608f8234f240f2ba15b4083be35c8d30"}
{"project": "qemu", "commit_id": "41ecc72ba5932381208e151bf2d2149a0342beff", "target": 0, "func": "static int setup_sigcontext(struct target_sigcontext *sc,\n\n                            CPUSH4State *regs, unsigned long mask)\n\n{\n\n    int err = 0;\n\n    int i;\n\n\n\n#define COPY(x)         __put_user(regs->x, &sc->sc_##x)\n\n    COPY(gregs[0]); COPY(gregs[1]);\n\n    COPY(gregs[2]); COPY(gregs[3]);\n\n    COPY(gregs[4]); COPY(gregs[5]);\n\n    COPY(gregs[6]); COPY(gregs[7]);\n\n    COPY(gregs[8]); COPY(gregs[9]);\n\n    COPY(gregs[10]); COPY(gregs[11]);\n\n    COPY(gregs[12]); COPY(gregs[13]);\n\n    COPY(gregs[14]); COPY(gregs[15]);\n\n    COPY(gbr); COPY(mach);\n\n    COPY(macl); COPY(pr);\n\n    COPY(sr); COPY(pc);\n\n#undef COPY\n\n\n\n    for (i=0; i<16; i++) {\n\n        __put_user(regs->fregs[i], &sc->sc_fpregs[i]);\n\n    }\n\n    __put_user(regs->fpscr, &sc->sc_fpscr);\n\n    __put_user(regs->fpul, &sc->sc_fpul);\n\n\n\n    /* non-iBCS2 extensions.. */\n\n    __put_user(mask, &sc->oldmask);\n\n\n\n    return err;\n\n}\n", "idx": 16281, "_split": "test", "_hash": "971529d38020be859b04891fccd35c3d"}
{"project": "qemu", "commit_id": "7c4228b4771acddcb8815079bc116007cec8a1ff", "target": 1, "func": "static void vfio_unmap_bar(VFIODevice *vdev, int nr)\n\n{\n\n    VFIOBAR *bar = &vdev->bars[nr];\n\n\n\n    if (!bar->size) {\n\n        return;\n\n    }\n\n\n\n    vfio_bar_quirk_teardown(vdev, nr);\n\n\n\n    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);\n\n    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));\n\n\n\n\n    if (vdev->msix && vdev->msix->table_bar == nr) {\n\n        memory_region_del_subregion(&bar->mem, &vdev->msix->mmap_mem);\n\n        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));\n\n\n    }\n\n\n\n    memory_region_destroy(&bar->mem);\n\n}", "idx": 16293, "_split": "test", "_hash": "320ab9bbab9bdbe12087cf984335cded"}
{"project": "qemu", "commit_id": "babfa20ca4721e950d8096f32b1dc091763a8837", "target": 0, "func": "static bool ept_emulation_fault(uint64_t ept_qual)\n\n{\n\n    int read, write;\n\n\n\n    /* EPT fault on an instruction fetch doesn't make sense here */\n\n    if (ept_qual & EPT_VIOLATION_INST_FETCH) {\n\n        return false;\n\n    }\n\n\n\n    /* EPT fault must be a read fault or a write fault */\n\n    read = ept_qual & EPT_VIOLATION_DATA_READ ? 1 : 0;\n\n    write = ept_qual & EPT_VIOLATION_DATA_WRITE ? 1 : 0;\n\n    if ((read | write) == 0) {\n\n        return false;\n\n    }\n\n\n\n    /*\n\n     * The EPT violation must have been caused by accessing a\n\n     * guest-physical address that is a translation of a guest-linear\n\n     * address.\n\n     */\n\n    if ((ept_qual & EPT_VIOLATION_GLA_VALID) == 0 ||\n\n        (ept_qual & EPT_VIOLATION_XLAT_VALID) == 0) {\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 16318, "_split": "test", "_hash": "53c18b296fa0a56071fa9c2c6f246918"}
{"project": "qemu", "commit_id": "cca1af8c4d2ef6449fd61494ba2cb087b838011c", "target": 1, "func": "static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args,\n\n                            int opc)\n\n{\n\n    int addr_regl, addr_reg1, addr_meml;\n\n    int data_regl, data_regh, data_reg1, data_reg2;\n\n    int mem_index, s_bits;\n\n#if defined(CONFIG_SOFTMMU)\n\n    void *label1_ptr, *label2_ptr;\n\n    int sp_args;\n\n#endif\n\n#if TARGET_LONG_BITS == 64\n\n# if defined(CONFIG_SOFTMMU)\n\n    uint8_t *label3_ptr;\n\n# endif\n\n    int addr_regh, addr_reg2, addr_memh;\n\n#endif\n\n    data_regl = *args++;\n\n    if (opc == 3)\n\n        data_regh = *args++;\n\n    else\n\n        data_regh = 0;\n\n    addr_regl = *args++;\n\n#if TARGET_LONG_BITS == 64\n\n    addr_regh = *args++;\n\n#endif\n\n    mem_index = *args;\n\n    s_bits = opc & 3;\n\n\n\n    if (opc == 3) {\n\n#if defined(TCG_TARGET_WORDS_BIGENDIAN)\n\n        data_reg1 = data_regh;\n\n        data_reg2 = data_regl;\n\n#else\n\n        data_reg1 = data_regl;\n\n        data_reg2 = data_regh;\n\n#endif\n\n    } else {\n\n        data_reg1 = data_regl;\n\n        data_reg2 = 0;\n\n    }\n\n#if TARGET_LONG_BITS == 64\n\n# if defined(TCG_TARGET_WORDS_BIGENDIAN)\n\n    addr_reg1 = addr_regh;\n\n    addr_reg2 = addr_regl;\n\n    addr_memh = 0;\n\n    addr_meml = 4;\n\n# else\n\n    addr_reg1 = addr_regl;\n\n    addr_reg2 = addr_regh;\n\n    addr_memh = 4;\n\n    addr_meml = 0;\n\n# endif\n\n#else\n\n    addr_reg1 = addr_regl;\n\n    addr_meml = 0;\n\n#endif\n\n\n\n#if defined(CONFIG_SOFTMMU)\n\n    tcg_out_opc_sa(s, OPC_SRL, TCG_REG_A0, addr_regl, TARGET_PAGE_BITS - CPU_TLB_ENTRY_BITS);\n\n    tcg_out_opc_imm(s, OPC_ANDI, TCG_REG_A0, TCG_REG_A0, (CPU_TLB_SIZE - 1) << CPU_TLB_ENTRY_BITS);\n\n    tcg_out_opc_reg(s, OPC_ADDU, TCG_REG_A0, TCG_REG_A0, TCG_AREG0);\n\n    tcg_out_opc_imm(s, OPC_LW, TCG_REG_AT, TCG_REG_A0,\n\n                    offsetof(CPUState, tlb_table[mem_index][0].addr_read) + addr_meml);\n\n    tcg_out_movi(s, TCG_TYPE_I32, TCG_REG_T0, TARGET_PAGE_MASK | ((1 << s_bits) - 1));\n\n    tcg_out_opc_reg(s, OPC_AND, TCG_REG_T0, TCG_REG_T0, addr_regl);\n\n\n\n# if TARGET_LONG_BITS == 64\n\n    label3_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BNE, TCG_REG_T0, TCG_REG_AT, 0);\n\n    tcg_out_nop(s);\n\n\n\n    tcg_out_opc_imm(s, OPC_LW, TCG_REG_AT, TCG_REG_A0,\n\n                    offsetof(CPUState, tlb_table[mem_index][0].addr_read) + addr_memh);\n\n\n\n    label1_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BEQ, addr_regh, TCG_REG_AT, 0);\n\n    tcg_out_nop(s);\n\n\n\n    reloc_pc16(label3_ptr, (tcg_target_long) s->code_ptr);\n\n# else\n\n    label1_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BEQ, TCG_REG_T0, TCG_REG_AT, 0);\n\n    tcg_out_nop(s);\n\n# endif\n\n\n\n    /* slow path */\n\n    sp_args = TCG_REG_A0;\n\n    tcg_out_mov(s, sp_args++, addr_reg1);\n\n# if TARGET_LONG_BITS == 64\n\n    tcg_out_mov(s, sp_args++, addr_reg2);\n\n# endif\n\n    tcg_out_movi(s, TCG_TYPE_I32, sp_args++, mem_index);\n\n    tcg_out_movi(s, TCG_TYPE_I32, TCG_REG_T9, (tcg_target_long)qemu_ld_helpers[s_bits]);\n\n    tcg_out_opc_reg(s, OPC_JALR, TCG_REG_RA, TCG_REG_T9, 0);\n\n    tcg_out_nop(s);\n\n\n\n    switch(opc) {\n\n    case 0:\n\n        tcg_out_opc_imm(s, OPC_ANDI, data_reg1, TCG_REG_V0, 0xff);\n\n        break;\n\n    case 0 | 4:\n\n        tcg_out_opc_sa(s, OPC_SLL, TCG_REG_V0, TCG_REG_V0, 24);\n\n        tcg_out_opc_sa(s, OPC_SRA, data_reg1, TCG_REG_V0, 24);\n\n        break;\n\n    case 1:\n\n        tcg_out_opc_imm(s, OPC_ANDI, data_reg1, TCG_REG_V0, 0xffff);\n\n        break;\n\n    case 1 | 4:\n\n        tcg_out_opc_sa(s, OPC_SLL, TCG_REG_V0, TCG_REG_V0, 16);\n\n        tcg_out_opc_sa(s, OPC_SRA, data_reg1, TCG_REG_V0, 16);\n\n        break;\n\n    case 2:\n\n        tcg_out_mov(s, data_reg1, TCG_REG_V0);\n\n        break;\n\n    case 3:\n\n        tcg_out_mov(s, data_reg2, TCG_REG_V1);\n\n        tcg_out_mov(s, data_reg1, TCG_REG_V0);\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n\n\n    label2_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BEQ, TCG_REG_ZERO, TCG_REG_ZERO, 0);\n\n    tcg_out_nop(s);\n\n\n\n    /* label1: fast path */\n\n    reloc_pc16(label1_ptr, (tcg_target_long) s->code_ptr);\n\n\n\n    tcg_out_opc_imm(s, OPC_LW, TCG_REG_V0, TCG_REG_A0,\n\n                    offsetof(CPUState, tlb_table[mem_index][0].addend) + addr_meml);\n\n    tcg_out_opc_reg(s, OPC_ADDU, TCG_REG_V0, TCG_REG_V0, addr_regl);\n\n\n\n    addr_reg1 = TCG_REG_V0;\n\n#endif\n\n\n\n    switch(opc) {\n\n    case 0:\n\n        tcg_out_opc_imm(s, OPC_LBU, data_reg1, addr_reg1, 0);\n\n        break;\n\n    case 0 | 4:\n\n        tcg_out_opc_imm(s, OPC_LB, data_reg1, addr_reg1, 0);\n\n        break;\n\n    case 1:\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LHU, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap16(s, data_reg1, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LHU, data_reg1, addr_reg1, 0);\n\n        }\n\n        break;\n\n    case 1 | 4:\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LHU, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap16s(s, data_reg1, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LH, data_reg1, addr_reg1, 0);\n\n        }\n\n        break;\n\n    case 2:\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap32(s, data_reg1, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg1, addr_reg1, 0);\n\n        }\n\n        break;\n\n    case 3:\n\n#if !defined(CONFIG_SOFTMMU)\n\n        tcg_out_mov(s, TCG_REG_V0, addr_reg1);\n\n        addr_reg1 = TCG_REG_V0;\n\n#endif\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 4);\n\n            tcg_out_bswap32(s, data_reg1, TCG_REG_T0);\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap32(s, data_reg2, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg1, addr_reg1, 0);\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg2, addr_reg1, 4);\n\n        }\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n\n\n#if defined(CONFIG_SOFTMMU)\n\n    reloc_pc16(label2_ptr, (tcg_target_long) s->code_ptr);\n\n#endif\n\n}\n", "idx": 16352, "_split": "test", "_hash": "6be88f5e51353dc44e22fd7686d2a97d"}
{"project": "qemu", "commit_id": "9ecaa27e7123211f45ca723a736ffae14f6c1f42", "target": 1, "func": "static void dec_calc(DisasContext *dc, uint32_t insn)\n\n{\n\n    uint32_t op0, op1, op2;\n\n    uint32_t ra, rb, rd;\n\n    op0 = extract32(insn, 0, 4);\n\n    op1 = extract32(insn, 8, 2);\n\n    op2 = extract32(insn, 6, 2);\n\n    ra = extract32(insn, 16, 5);\n\n    rb = extract32(insn, 11, 5);\n\n    rd = extract32(insn, 21, 5);\n\n\n\n    switch (op0) {\n\n    case 0x0000:\n\n        switch (op1) {\n\n        case 0x00:    /* l.add */\n\n            LOG_DIS(\"l.add r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_extrl_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0001:    /* l.addc */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.addc r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 tcy = tcg_temp_local_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_cy = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_andi_i32(sr_cy, cpu_sr, SR_CY);\n\n                tcg_gen_extu_i32_i64(tcy, sr_cy);\n\n                tcg_gen_shri_i64(tcy, tcy, 10);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_add_i64(td, td, tcy);\n\n                tcg_gen_extrl_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 32);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(tcy);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_cy);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0002:    /* l.sub */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.sub r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_sub_i64(td, ta, tb);\n\n                tcg_gen_extrl_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0003:    /* l.and */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.and r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_and_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0004:    /* l.or */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.or r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_or_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0005:\n\n        switch (op1) {\n\n        case 0x00:    /* l.xor */\n\n            LOG_DIS(\"l.xor r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_xor_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0006:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mul */\n\n            LOG_DIS(\"l.mul r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (ra != 0 && rb != 0) {\n\n                gen_helper_mul32(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0x0);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0009:\n\n        switch (op1) {\n\n        case 0x03:    /* l.div */\n\n            LOG_DIS(\"l.div r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab0 = gen_new_label();\n\n                TCGLabel *lab1 = gen_new_label();\n\n                TCGLabel *lab2 = gen_new_label();\n\n                TCGLabel *lab3 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[ra],\n\n                                       0x80000000, lab2);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0xffffffff, lab2);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab3);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab2);\n\n                    tcg_gen_div_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab3);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000a:\n\n        switch (op1) {\n\n        case 0x03:    /* l.divu */\n\n            LOG_DIS(\"l.divu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab0 = gen_new_label();\n\n                TCGLabel *lab1 = gen_new_label();\n\n                TCGLabel *lab2 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab2);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_divu_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab2);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000b:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mulu */\n\n            LOG_DIS(\"l.mulu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (rb != 0 && ra != 0) {\n\n                TCGv_i64 result = tcg_temp_local_new_i64();\n\n                TCGv_i64 tra = tcg_temp_local_new_i64();\n\n                TCGv_i64 trb = tcg_temp_local_new_i64();\n\n                TCGv_i64 high = tcg_temp_new_i64();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                TCGLabel *lab = gen_new_label();\n\n                /* Calculate each result. */\n\n                tcg_gen_extu_i32_i64(tra, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(trb, cpu_R[rb]);\n\n                tcg_gen_mul_i64(result, tra, trb);\n\n                tcg_temp_free_i64(tra);\n\n                tcg_temp_free_i64(trb);\n\n                tcg_gen_shri_i64(high, result, TARGET_LONG_BITS);\n\n                /* Overflow or not. */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, high, 0x00000000, lab);\n\n                tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_temp_free_i64(high);\n\n                tcg_gen_trunc_i64_tl(cpu_R[rd], result);\n\n                tcg_temp_free_i64(result);\n\n                tcg_temp_free_i32(sr_ove);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000e:\n\n        switch (op1) {\n\n        case 0x00:    /* l.cmov */\n\n            LOG_DIS(\"l.cmov r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv res = tcg_temp_local_new();\n\n                TCGv sr_f = tcg_temp_new();\n\n                tcg_gen_andi_tl(sr_f, cpu_sr, SR_F);\n\n                tcg_gen_mov_tl(res, cpu_R[rb]);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_f, SR_F, lab);\n\n                tcg_gen_mov_tl(res, cpu_R[ra]);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_tl(cpu_R[rd], res);\n\n                tcg_temp_free(sr_f);\n\n                tcg_temp_free(res);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000f:\n\n        switch (op1) {\n\n        case 0x00:    /* l.ff1 */\n\n            LOG_DIS(\"l.ff1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_ctzi_tl(cpu_R[rd], cpu_R[ra], -1);\n\n            tcg_gen_addi_tl(cpu_R[rd], cpu_R[rd], 1);\n\n            break;\n\n        case 0x01:    /* l.fl1 */\n\n            LOG_DIS(\"l.fl1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_clzi_tl(cpu_R[rd], cpu_R[ra], TARGET_LONG_BITS);\n\n            tcg_gen_subfi_tl(cpu_R[rd], TARGET_LONG_BITS, cpu_R[rd]);\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0008:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.sll */\n\n                LOG_DIS(\"l.sll r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shl_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x01:    /* l.srl */\n\n                LOG_DIS(\"l.srl r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x02:    /* l.sra */\n\n                LOG_DIS(\"l.sra r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_sar_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x03:    /* l.ror */\n\n                LOG_DIS(\"l.ror r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_rotr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000c:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.exths */\n\n                LOG_DIS(\"l.exths r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extbs */\n\n                LOG_DIS(\"l.extbs r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x02:    /* l.exthz */\n\n                LOG_DIS(\"l.exthz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x03:    /* l.extbz */\n\n                LOG_DIS(\"l.extbz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000d:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.extws */\n\n                LOG_DIS(\"l.extws r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extwz */\n\n                LOG_DIS(\"l.extwz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        gen_illegal_exception(dc);\n\n        break;\n\n    }\n\n}\n", "idx": 16360, "_split": "test", "_hash": "036fb9fb6e4f20b9b27768b9c55105ec"}
{"project": "qemu", "commit_id": "225d02cd1a34d5d87e8acefbf8e244a5d12f5f8c", "target": 1, "func": "int qemu_calculate_timeout(void)\n\n{\n\n#ifndef CONFIG_IOTHREAD\n\n    int timeout;\n\n\n\n    if (!vm_running)\n\n        timeout = 5000;\n\n    else {\n\n     /* XXX: use timeout computed from timers */\n\n        int64_t add;\n\n        int64_t delta;\n\n        /* Advance virtual time to the next event.  */\n\n\tdelta = qemu_icount_delta();\n\n        if (delta > 0) {\n\n            /* If virtual time is ahead of real time then just\n\n               wait for IO.  */\n\n            timeout = (delta + 999999) / 1000000;\n\n        } else {\n\n            /* Wait for either IO to occur or the next\n\n               timer event.  */\n\n            add = qemu_next_deadline();\n\n            /* We advance the timer before checking for IO.\n\n               Limit the amount we advance so that early IO\n\n               activity won't get the guest too far ahead.  */\n\n            if (add > 10000000)\n\n                add = 10000000;\n\n            delta += add;\n\n            qemu_icount += qemu_icount_round (add);\n\n            timeout = delta / 1000000;\n\n            if (timeout < 0)\n\n                timeout = 0;\n\n        }\n\n    }\n\n\n\n    return timeout;\n\n#else /* CONFIG_IOTHREAD */\n\n    return 1000;\n\n#endif\n\n}\n", "idx": 16365, "_split": "test", "_hash": "dbb55cbbc8197312d3dc833adf595851"}
{"project": "qemu", "commit_id": "6fedcaa1c5419fa89c31fd34dabbd71861c615d2", "target": 0, "func": "void eeprom93xx_write(eeprom_t *eeprom, int eecs, int eesk, int eedi)\n\n{\n\n    uint8_t tick = eeprom->tick;\n\n    uint8_t eedo = eeprom->eedo;\n\n    uint16_t address = eeprom->address;\n\n    uint8_t command = eeprom->command;\n\n\n\n    logout(\"CS=%u SK=%u DI=%u DO=%u, tick = %u\\n\",\n\n           eecs, eesk, eedi, eedo, tick);\n\n\n\n    if (! eeprom->eecs && eecs) {\n\n        /* Start chip select cycle. */\n\n        logout(\"Cycle start, waiting for 1st start bit (0)\\n\");\n\n        tick = 0;\n\n        command = 0x0;\n\n        address = 0x0;\n\n    } else if (eeprom->eecs && ! eecs) {\n\n        /* End chip select cycle. This triggers write / erase. */\n\n        if (eeprom->writable) {\n\n            uint8_t subcommand = address >> (eeprom->addrbits - 2);\n\n            if (command == 0 && subcommand == 2) {\n\n                /* Erase all. */\n\n                for (address = 0; address < eeprom->size; address++) {\n\n                    eeprom->contents[address] = 0xffff;\n\n                }\n\n            } else if (command == 3) {\n\n                /* Erase word. */\n\n                eeprom->contents[address] = 0xffff;\n\n            } else if (tick >= 2 + 2 + eeprom->addrbits + 16) {\n\n                if (command == 1) {\n\n                    /* Write word. */\n\n                    eeprom->contents[address] &= eeprom->data;\n\n                } else if (command == 0 && subcommand == 1) {\n\n                    /* Write all. */\n\n                    for (address = 0; address < eeprom->size; address++) {\n\n                        eeprom->contents[address] &= eeprom->data;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        /* Output DO is tristate, read results in 1. */\n\n        eedo = 1;\n\n    } else if (eecs && ! eeprom->eesk && eesk) {\n\n        /* Raising edge of clock shifts data in. */\n\n        if (tick == 0) {\n\n            /* Wait for 1st start bit. */\n\n            if (eedi == 0) {\n\n                logout(\"Got correct 1st start bit, waiting for 2nd start bit (1)\\n\");\n\n                tick++;\n\n            } else {\n\n                logout(\"wrong 1st start bit (is 1, should be 0)\\n\");\n\n                tick = 2;\n\n                //~ assert(!\"wrong start bit\");\n\n            }\n\n        } else if (tick == 1) {\n\n            /* Wait for 2nd start bit. */\n\n            if (eedi != 0) {\n\n                logout(\"Got correct 2nd start bit, getting command + address\\n\");\n\n                tick++;\n\n            } else {\n\n                logout(\"1st start bit is longer than needed\\n\");\n\n            }\n\n        } else if (tick < 2 + 2) {\n\n            /* Got 2 start bits, transfer 2 opcode bits. */\n\n            tick++;\n\n            command <<= 1;\n\n            if (eedi) {\n\n                command += 1;\n\n            }\n\n        } else if (tick < 2 + 2 + eeprom->addrbits) {\n\n            /* Got 2 start bits and 2 opcode bits, transfer all address bits. */\n\n            tick++;\n\n            address = ((address << 1) | eedi);\n\n            if (tick == 2 + 2 + eeprom->addrbits) {\n\n                logout(\"%s command, address = 0x%02x (value 0x%04x)\\n\",\n\n                       opstring[command], address, eeprom->contents[address]);\n\n                if (command == 2) {\n\n                    eedo = 0;\n\n                }\n\n                address = address % eeprom->size;\n\n                if (command == 0) {\n\n                    /* Command code in upper 2 bits of address. */\n\n                    switch (address >> (eeprom->addrbits - 2)) {\n\n                        case 0:\n\n                            logout(\"write disable command\\n\");\n\n                            eeprom->writable = 0;\n\n                            break;\n\n                        case 1:\n\n                            logout(\"write all command\\n\");\n\n                            break;\n\n                        case 2:\n\n                            logout(\"erase all command\\n\");\n\n                            break;\n\n                        case 3:\n\n                            logout(\"write enable command\\n\");\n\n                            eeprom->writable = 1;\n\n                            break;\n\n                    }\n\n                } else {\n\n                    /* Read, write or erase word. */\n\n                    eeprom->data = eeprom->contents[address];\n\n                }\n\n            }\n\n        } else if (tick < 2 + 2 + eeprom->addrbits + 16) {\n\n            /* Transfer 16 data bits. */\n\n            tick++;\n\n            if (command == 2) {\n\n                /* Read word. */\n\n                eedo = ((eeprom->data & 0x8000) != 0);\n\n            }\n\n            eeprom->data <<= 1;\n\n            eeprom->data += eedi;\n\n        } else {\n\n            logout(\"additional unneeded tick, not processed\\n\");\n\n        }\n\n    }\n\n    /* Save status of EEPROM. */\n\n    eeprom->tick = tick;\n\n    eeprom->eecs = eecs;\n\n    eeprom->eesk = eesk;\n\n    eeprom->eedo = eedo;\n\n    eeprom->address = address;\n\n    eeprom->command = command;\n\n}\n", "idx": 16406, "_split": "test", "_hash": "45bfb2e0208a5502b4925a5a06dd8ee4"}
{"project": "qemu", "commit_id": "acfb23ad3dd8d0ab385a10e483776ba7dcf927ad", "target": 0, "func": "static void *iothread_run(void *opaque)\n\n{\n\n    IOThread *iothread = opaque;\n\n\n\n    qemu_mutex_lock(&iothread->init_done_lock);\n\n    iothread->thread_id = qemu_get_thread_id();\n\n    qemu_cond_signal(&iothread->init_done_cond);\n\n    qemu_mutex_unlock(&iothread->init_done_lock);\n\n\n\n    while (!iothread->stopping) {\n\n        aio_context_acquire(iothread->ctx);\n\n        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {\n\n            /* Progress was made, keep going */\n\n        }\n\n        aio_context_release(iothread->ctx);\n\n    }\n\n    return NULL;\n\n}\n", "idx": 16410, "_split": "test", "_hash": "4fe881d2e30d34f20eaae74e936acc79"}
{"project": "qemu", "commit_id": "3c3e88a814ef4eb8b2f8bf81863baec24838d998", "target": 0, "func": "static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,\n\n                             void *opaque, Error **errp)\n\n{\n\n    int64_t value;\n\n    MemoryRegion *mr;\n\n    PCDIMMDevice *dimm = PC_DIMM(obj);\n\n\n\n    mr = host_memory_backend_get_memory(dimm->hostmem, errp);\n\n    value = memory_region_size(mr);\n\n\n\n    visit_type_int(v, name, &value, errp);\n\n}\n", "idx": 16415, "_split": "test", "_hash": "8fb210d89d0d8e865a3407626e10d77a"}
{"project": "qemu", "commit_id": "d0e7605ee0d91c3737052127a79199ddab3ff653", "target": 0, "func": "pflash_t *pflash_cfi02_register(target_phys_addr_t base, ram_addr_t off,\n\n                                BlockDriverState *bs, uint32_t sector_len,\n\n                                int nb_blocs, int nb_mappings, int width,\n\n                                uint16_t id0, uint16_t id1,\n\n                                uint16_t id2, uint16_t id3,\n\n                                uint16_t unlock_addr0, uint16_t unlock_addr1)\n\n{\n\n    pflash_t *pfl;\n\n    int32_t chip_len;\n\n\n\n    chip_len = sector_len * nb_blocs;\n\n    /* XXX: to be fixed */\n\n#if 0\n\n    if (total_len != (8 * 1024 * 1024) && total_len != (16 * 1024 * 1024) &&\n\n        total_len != (32 * 1024 * 1024) && total_len != (64 * 1024 * 1024))\n\n        return NULL;\n\n#endif\n\n    pfl = qemu_mallocz(sizeof(pflash_t));\n\n    /* FIXME: Allocate ram ourselves.  */\n\n    pfl->storage = qemu_get_ram_ptr(off);\n\n    pfl->fl_mem = cpu_register_io_memory(pflash_read_ops, pflash_write_ops,\n\n                                         pfl);\n\n    pfl->off = off;\n\n    pfl->base = base;\n\n    pfl->chip_len = chip_len;\n\n    pfl->mappings = nb_mappings;\n\n    pflash_register_memory(pfl, 1);\n\n    pfl->bs = bs;\n\n    if (pfl->bs) {\n\n        /* read the initial flash content */\n\n        bdrv_read(pfl->bs, 0, pfl->storage, chip_len >> 9);\n\n    }\n\n#if 0 /* XXX: there should be a bit to set up read-only,\n\n       *      the same way the hardware does (with WP pin).\n\n       */\n\n    pfl->ro = 1;\n\n#else\n\n    pfl->ro = 0;\n\n#endif\n\n    pfl->timer = qemu_new_timer(vm_clock, pflash_timer, pfl);\n\n    pfl->sector_len = sector_len;\n\n    pfl->width = width;\n\n    pfl->wcycle = 0;\n\n    pfl->cmd = 0;\n\n    pfl->status = 0;\n\n    pfl->ident[0] = id0;\n\n    pfl->ident[1] = id1;\n\n    pfl->ident[2] = id2;\n\n    pfl->ident[3] = id3;\n\n    pfl->unlock_addr[0] = unlock_addr0;\n\n    pfl->unlock_addr[1] = unlock_addr1;\n\n    /* Hardcoded CFI table (mostly from SG29 Spansion flash) */\n\n    pfl->cfi_len = 0x52;\n\n    /* Standard \"QRY\" string */\n\n    pfl->cfi_table[0x10] = 'Q';\n\n    pfl->cfi_table[0x11] = 'R';\n\n    pfl->cfi_table[0x12] = 'Y';\n\n    /* Command set (AMD/Fujitsu) */\n\n    pfl->cfi_table[0x13] = 0x02;\n\n    pfl->cfi_table[0x14] = 0x00;\n\n    /* Primary extended table address */\n\n    pfl->cfi_table[0x15] = 0x31;\n\n    pfl->cfi_table[0x16] = 0x00;\n\n    /* Alternate command set (none) */\n\n    pfl->cfi_table[0x17] = 0x00;\n\n    pfl->cfi_table[0x18] = 0x00;\n\n    /* Alternate extended table (none) */\n\n    pfl->cfi_table[0x19] = 0x00;\n\n    pfl->cfi_table[0x1A] = 0x00;\n\n    /* Vcc min */\n\n    pfl->cfi_table[0x1B] = 0x27;\n\n    /* Vcc max */\n\n    pfl->cfi_table[0x1C] = 0x36;\n\n    /* Vpp min (no Vpp pin) */\n\n    pfl->cfi_table[0x1D] = 0x00;\n\n    /* Vpp max (no Vpp pin) */\n\n    pfl->cfi_table[0x1E] = 0x00;\n\n    /* Reserved */\n\n    pfl->cfi_table[0x1F] = 0x07;\n\n    /* Timeout for min size buffer write (NA) */\n\n    pfl->cfi_table[0x20] = 0x00;\n\n    /* Typical timeout for block erase (512 ms) */\n\n    pfl->cfi_table[0x21] = 0x09;\n\n    /* Typical timeout for full chip erase (4096 ms) */\n\n    pfl->cfi_table[0x22] = 0x0C;\n\n    /* Reserved */\n\n    pfl->cfi_table[0x23] = 0x01;\n\n    /* Max timeout for buffer write (NA) */\n\n    pfl->cfi_table[0x24] = 0x00;\n\n    /* Max timeout for block erase */\n\n    pfl->cfi_table[0x25] = 0x0A;\n\n    /* Max timeout for chip erase */\n\n    pfl->cfi_table[0x26] = 0x0D;\n\n    /* Device size */\n\n    pfl->cfi_table[0x27] = ctz32(chip_len);\n\n    /* Flash device interface (8 & 16 bits) */\n\n    pfl->cfi_table[0x28] = 0x02;\n\n    pfl->cfi_table[0x29] = 0x00;\n\n    /* Max number of bytes in multi-bytes write */\n\n    /* XXX: disable buffered write as it's not supported */\n\n    //    pfl->cfi_table[0x2A] = 0x05;\n\n    pfl->cfi_table[0x2A] = 0x00;\n\n    pfl->cfi_table[0x2B] = 0x00;\n\n    /* Number of erase block regions (uniform) */\n\n    pfl->cfi_table[0x2C] = 0x01;\n\n    /* Erase block region 1 */\n\n    pfl->cfi_table[0x2D] = nb_blocs - 1;\n\n    pfl->cfi_table[0x2E] = (nb_blocs - 1) >> 8;\n\n    pfl->cfi_table[0x2F] = sector_len >> 8;\n\n    pfl->cfi_table[0x30] = sector_len >> 16;\n\n\n\n    /* Extended */\n\n    pfl->cfi_table[0x31] = 'P';\n\n    pfl->cfi_table[0x32] = 'R';\n\n    pfl->cfi_table[0x33] = 'I';\n\n\n\n    pfl->cfi_table[0x34] = '1';\n\n    pfl->cfi_table[0x35] = '0';\n\n\n\n    pfl->cfi_table[0x36] = 0x00;\n\n    pfl->cfi_table[0x37] = 0x00;\n\n    pfl->cfi_table[0x38] = 0x00;\n\n    pfl->cfi_table[0x39] = 0x00;\n\n\n\n    pfl->cfi_table[0x3a] = 0x00;\n\n\n\n    pfl->cfi_table[0x3b] = 0x00;\n\n    pfl->cfi_table[0x3c] = 0x00;\n\n\n\n    return pfl;\n\n}\n", "idx": 16419, "_split": "test", "_hash": "22719145e2b0d919dd2813bf9c54c7e5"}
{"project": "qemu", "commit_id": "e95ead32efc48157de12e0a257ea1c52541a6ce1", "target": 0, "func": "static int v9fs_do_chmod(V9fsState *s, V9fsString *path, mode_t mode)\n\n{\n\n    return s->ops->chmod(&s->ctx, path->data, mode);\n\n}\n", "idx": 16422, "_split": "test", "_hash": "2c0f857f0518fb05053a2748b624d44c"}
{"project": "qemu", "commit_id": "12de9a396acbc95e25c5d60ed097cc55777eaaed", "target": 1, "func": "static int check_physical (CPUState *env, mmu_ctx_t *ctx,\n\n                           target_ulong eaddr, int rw)\n\n{\n\n    int in_plb, ret;\n\n\n\n    ctx->raddr = eaddr;\n\n    ctx->prot = PAGE_READ;\n\n    ret = 0;\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n    case POWERPC_MMU_601:\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_REAL_4xx:\n\n    case POWERPC_MMU_BOOKE:\n\n        ctx->prot |= PAGE_WRITE;\n\n        break;\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_64BRIDGE:\n\n        /* Real address are 60 bits long */\n\n        ctx->raddr &= 0x0FFFFFFFFFFFFFFFULL;\n\n        ctx->prot |= PAGE_WRITE;\n\n        break;\n\n#endif\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        if (unlikely(msr_pe != 0)) {\n\n            /* 403 family add some particular protections,\n\n             * using PBL/PBU registers for accesses with no translation.\n\n             */\n\n            in_plb =\n\n                /* Check PLB validity */\n\n                (env->pb[0] < env->pb[1] &&\n\n                 /* and address in plb area */\n\n                 eaddr >= env->pb[0] && eaddr < env->pb[1]) ||\n\n                (env->pb[2] < env->pb[3] &&\n\n                 eaddr >= env->pb[2] && eaddr < env->pb[3]) ? 1 : 0;\n\n            if (in_plb ^ msr_px) {\n\n                /* Access in protected area */\n\n                if (rw == 1) {\n\n                    /* Access is not allowed */\n\n                    ret = -2;\n\n                }\n\n            } else {\n\n                /* Read-write access is allowed */\n\n                ctx->prot |= PAGE_WRITE;\n\n            }\n\n        }\n\n        break;\n\n    case POWERPC_MMU_BOOKE_FSL:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"BookE FSL MMU model not implemented\\n\");\n\n        break;\n\n    default:\n\n        cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 16431, "_split": "test", "_hash": "f8adfa886f75d2915bef28655013b266"}
{"project": "qemu", "commit_id": "8786db7cb96f8ce5c75c6e1e074319c9dca8d356", "target": 1, "func": "void set_system_memory_map(MemoryRegion *mr)\n\n{\n\n    memory_region_transaction_begin();\n\n    address_space_memory.root = mr;\n\n    memory_region_transaction_commit();\n\n}\n", "idx": 16449, "_split": "test", "_hash": "27072eabd87d64d683d88065f1993a3b"}
{"project": "qemu", "commit_id": "231bb267644ee3a9ebfd9c7f42d5d41610194b45", "target": 1, "func": "int qcow2_write_l1_entry(BlockDriverState *bs, int l1_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t buf[L1_ENTRIES_PER_SECTOR];\n\n    int l1_start_index;\n\n    int i, ret;\n\n\n\n    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);\n\n    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {\n\n        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);\n\n    }\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs,\n\n            QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,\n\n            s->l1_table_offset + 8 * l1_start_index, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);\n\n    ret = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,\n\n        buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 16465, "_split": "test", "_hash": "4e4d7a1048a6b170df18b8ddb9718a26"}
{"project": "qemu", "commit_id": "f46e9a0b9911fcfbc13f85f3a8808067990a0f5c", "target": 0, "func": "static void zero_bss(abi_ulong elf_bss, abi_ulong last_bss, int prot)\n\n{\n\n    uintptr_t host_start, host_map_start, host_end;\n\n\n\n    last_bss = TARGET_PAGE_ALIGN(last_bss);\n\n\n\n    /* ??? There is confusion between qemu_real_host_page_size and\n\n       qemu_host_page_size here and elsewhere in target_mmap, which\n\n       may lead to the end of the data section mapping from the file\n\n       not being mapped.  At least there was an explicit test and\n\n       comment for that here, suggesting that \"the file size must\n\n       be known\".  The comment probably pre-dates the introduction\n\n       of the fstat system call in target_mmap which does in fact\n\n       find out the size.  What isn't clear is if the workaround\n\n       here is still actually needed.  For now, continue with it,\n\n       but merge it with the \"normal\" mmap that would allocate the bss.  */\n\n\n\n    host_start = (uintptr_t) g2h(elf_bss);\n\n    host_end = (uintptr_t) g2h(last_bss);\n\n    host_map_start = (host_start + qemu_real_host_page_size - 1);\n\n    host_map_start &= -qemu_real_host_page_size;\n\n\n\n    if (host_map_start < host_end) {\n\n        void *p = mmap((void *)host_map_start, host_end - host_map_start,\n\n                       prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n        if (p == MAP_FAILED) {\n\n            perror(\"cannot mmap brk\");\n\n            exit(-1);\n\n        }\n\n\n\n        /* Since we didn't use target_mmap, make sure to record\n\n           the validity of the pages with qemu.  */\n\n        page_set_flags(elf_bss & TARGET_PAGE_MASK, last_bss, prot|PAGE_VALID);\n\n    }\n\n\n\n    if (host_start < host_map_start) {\n\n        memset((void *)host_start, 0, host_map_start - host_start);\n\n    }\n\n}\n", "idx": 16483, "_split": "test", "_hash": "0f09f3f213b57ebae4b39a77ead99399"}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static inline void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret,\n\n                              TCGReg arg1, intptr_t arg2)\n\n{\n\n    int opi, opx;\n\n\n\n    assert(TCG_TARGET_REG_BITS == 64 || type == TCG_TYPE_I32);\n\n    if (type == TCG_TYPE_I32) {\n\n        opi = LWZ, opx = LWZX;\n\n    } else {\n\n        opi = LD, opx = LDX;\n\n    }\n\n    tcg_out_mem_long(s, opi, opx, ret, arg1, arg2);\n\n}\n", "idx": 16501, "_split": "test", "_hash": "cbc2c02681e0bd54b5e56c6eb4da1be7"}
{"project": "qemu", "commit_id": "af957387547b05ed6dc4d84c10cca42700a7aeda", "target": 0, "func": "void do_delvm(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockDriverState *bs, *bs1;\n\n    Error *err = NULL;\n\n    const char *name = qdict_get_str(qdict, \"name\");\n\n\n\n    bs = find_vmstate_bs();\n\n    if (!bs) {\n\n        monitor_printf(mon, \"No block device supports snapshots\\n\");\n\n        return;\n\n    }\n\n\n\n    bs1 = NULL;\n\n    while ((bs1 = bdrv_next(bs1))) {\n\n        if (bdrv_can_snapshot(bs1)) {\n\n            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);\n\n            if (err) {\n\n                monitor_printf(mon,\n\n                               \"Error while deleting snapshot on device '%s':\"\n\n                               \" %s\\n\",\n\n                               bdrv_get_device_name(bs),\n\n                               error_get_pretty(err));\n\n                error_free(err);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 16507, "_split": "test", "_hash": "9425682f0fb75cb7ca99263a13da4a1b"}
{"project": "qemu", "commit_id": "64607d088132abdb25bf30d93e97d0c8df7b364c", "target": 0, "func": "void object_property_add(Object *obj, const char *name, const char *type,\n\n                         ObjectPropertyAccessor *get,\n\n                         ObjectPropertyAccessor *set,\n\n                         ObjectPropertyRelease *release,\n\n                         void *opaque, Error **errp)\n\n{\n\n    ObjectProperty *prop;\n\n\n\n    QTAILQ_FOREACH(prop, &obj->properties, node) {\n\n        if (strcmp(prop->name, name) == 0) {\n\n            error_setg(errp, \"attempt to add duplicate property '%s'\"\n\n                       \" to object (type '%s')\", name,\n\n                       object_get_typename(obj));\n\n            return;\n\n        }\n\n    }\n\n\n\n    prop = g_malloc0(sizeof(*prop));\n\n\n\n    prop->name = g_strdup(name);\n\n    prop->type = g_strdup(type);\n\n\n\n    prop->get = get;\n\n    prop->set = set;\n\n    prop->release = release;\n\n    prop->opaque = opaque;\n\n\n\n    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);\n\n}\n", "idx": 16521, "_split": "test", "_hash": "52861b3ce6ca6d48cd200997ad5b1b86"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void collie_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    StrongARMState *s;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"sa1110\";\n\n    }\n\n\n\n    s = sa1110_init(sysmem, collie_binfo.ram_size, cpu_model);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    pflash_cfi01_register(SA_CS0, NULL, \"collie.fl1\", 0x02000000,\n\n                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 1);\n\n    pflash_cfi01_register(SA_CS1, NULL, \"collie.fl2\", 0x02000000,\n\n                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);\n\n\n\n    sysbus_create_simple(\"scoop\", 0x40800000, NULL);\n\n\n\n    collie_binfo.kernel_filename = kernel_filename;\n\n    collie_binfo.kernel_cmdline = kernel_cmdline;\n\n    collie_binfo.initrd_filename = initrd_filename;\n\n    collie_binfo.board_id = 0x208;\n\n    arm_load_kernel(s->cpu, &collie_binfo);\n\n}\n", "idx": 16524, "_split": "test", "_hash": "cd76adab84a210ab9d57586468feb5ed"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void blk_send_response_all(struct XenBlkDev *blkdev)\n\n{\n\n    struct ioreq *ioreq;\n\n    int send_notify = 0;\n\n\n\n    while (!LIST_EMPTY(&blkdev->finished)) {\n\n        ioreq = LIST_FIRST(&blkdev->finished);\n\n\tsend_notify += blk_send_response_one(ioreq);\n\n\tioreq_release(ioreq);\n\n    }\n\n    if (send_notify)\n\n\txen_be_send_notify(&blkdev->xendev);\n\n}\n", "idx": 16542, "_split": "test", "_hash": "0bfed55d0cef24d436d85b78a9265af1"}
{"project": "qemu", "commit_id": "6c7565028c272c4c6f2a83c3a90b044eeaf2804a", "target": 0, "func": "static int interface_client_monitors_config(QXLInstance *sin,\n\n                                        VDAgentMonitorsConfig *monitors_config)\n\n{\n\n    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);\n\n    QXLRom *rom = memory_region_get_ram_ptr(&qxl->rom_bar);\n\n    int i;\n\n    unsigned max_outputs = ARRAY_SIZE(rom->client_monitors_config.heads);\n\n\n\n    if (qxl->revision < 4) {\n\n        trace_qxl_client_monitors_config_unsupported_by_device(qxl->id,\n\n                                                               qxl->revision);\n\n        return 0;\n\n    }\n\n    /*\n\n     * Older windows drivers set int_mask to 0 when their ISR is called,\n\n     * then later set it to ~0. So it doesn't relate to the actual interrupts\n\n     * handled. However, they are old, so clearly they don't support this\n\n     * interrupt\n\n     */\n\n    if (qxl->ram->int_mask == 0 || qxl->ram->int_mask == ~0 ||\n\n        !(qxl->ram->int_mask & QXL_INTERRUPT_CLIENT_MONITORS_CONFIG)) {\n\n        trace_qxl_client_monitors_config_unsupported_by_guest(qxl->id,\n\n                                                            qxl->ram->int_mask,\n\n                                                            monitors_config);\n\n        return 0;\n\n    }\n\n    if (!monitors_config) {\n\n        return 1;\n\n    }\n\n\n\n#if SPICE_SERVER_VERSION >= 0x000c06 /* release 0.12.6 */\n\n    /* limit number of outputs based on setting limit */\n\n    if (qxl->max_outputs && qxl->max_outputs <= max_outputs) {\n\n        max_outputs = qxl->max_outputs;\n\n    }\n\n#endif\n\n\n\n    memset(&rom->client_monitors_config, 0,\n\n           sizeof(rom->client_monitors_config));\n\n    rom->client_monitors_config.count = monitors_config->num_of_monitors;\n\n    /* monitors_config->flags ignored */\n\n    if (rom->client_monitors_config.count >= max_outputs) {\n\n        trace_qxl_client_monitors_config_capped(qxl->id,\n\n                                monitors_config->num_of_monitors,\n\n                                max_outputs);\n\n        rom->client_monitors_config.count = max_outputs;\n\n    }\n\n    for (i = 0 ; i < rom->client_monitors_config.count ; ++i) {\n\n        VDAgentMonConfig *monitor = &monitors_config->monitors[i];\n\n        QXLURect *rect = &rom->client_monitors_config.heads[i];\n\n        /* monitor->depth ignored */\n\n        rect->left = monitor->x;\n\n        rect->top = monitor->y;\n\n        rect->right = monitor->x + monitor->width;\n\n        rect->bottom = monitor->y + monitor->height;\n\n    }\n\n    rom->client_monitors_config_crc = qxl_crc32(\n\n            (const uint8_t *)&rom->client_monitors_config,\n\n            sizeof(rom->client_monitors_config));\n\n    trace_qxl_client_monitors_config_crc(qxl->id,\n\n            sizeof(rom->client_monitors_config),\n\n            rom->client_monitors_config_crc);\n\n\n\n    trace_qxl_interrupt_client_monitors_config(qxl->id,\n\n                        rom->client_monitors_config.count,\n\n                        rom->client_monitors_config.heads);\n\n    qxl_send_events(qxl, QXL_INTERRUPT_CLIENT_MONITORS_CONFIG);\n\n    return 1;\n\n}\n", "idx": 16566, "_split": "test", "_hash": "2ef663cfc4a805bf8a1f58a24d362e68"}
{"project": "qemu", "commit_id": "9a4c0e220d8a4f82b5665d0ee95ef94d8e1509d5", "target": 0, "func": "static void virtio_pci_realize(PCIDevice *pci_dev, Error **errp)\n\n{\n\n    VirtIOPCIProxy *proxy = VIRTIO_PCI(pci_dev);\n\n    VirtioPCIClass *k = VIRTIO_PCI_GET_CLASS(pci_dev);\n\n\n\n    /*\n\n     * virtio pci bar layout used by default.\n\n     * subclasses can re-arrange things if needed.\n\n     *\n\n     *   region 0   --  virtio legacy io bar\n\n     *   region 1   --  msi-x bar\n\n     *   region 4+5 --  virtio modern memory (64bit) bar\n\n     *\n\n     */\n\n    proxy->legacy_io_bar  = 0;\n\n    proxy->msix_bar       = 1;\n\n    proxy->modern_io_bar  = 2;\n\n    proxy->modern_mem_bar = 4;\n\n\n\n    proxy->common.offset = 0x0;\n\n    proxy->common.size = 0x1000;\n\n    proxy->common.type = VIRTIO_PCI_CAP_COMMON_CFG;\n\n\n\n    proxy->isr.offset = 0x1000;\n\n    proxy->isr.size = 0x1000;\n\n    proxy->isr.type = VIRTIO_PCI_CAP_ISR_CFG;\n\n\n\n    proxy->device.offset = 0x2000;\n\n    proxy->device.size = 0x1000;\n\n    proxy->device.type = VIRTIO_PCI_CAP_DEVICE_CFG;\n\n\n\n    proxy->notify.offset = 0x3000;\n\n    proxy->notify.size =\n\n        QEMU_VIRTIO_PCI_QUEUE_MEM_MULT * VIRTIO_QUEUE_MAX;\n\n    proxy->notify.type = VIRTIO_PCI_CAP_NOTIFY_CFG;\n\n\n\n    proxy->notify_pio.offset = 0x0;\n\n    proxy->notify_pio.size = 0x4;\n\n    proxy->notify_pio.type = VIRTIO_PCI_CAP_NOTIFY_CFG;\n\n\n\n    /* subclasses can enforce modern, so do this unconditionally */\n\n    memory_region_init(&proxy->modern_bar, OBJECT(proxy), \"virtio-pci\",\n\n                       2 * QEMU_VIRTIO_PCI_QUEUE_MEM_MULT *\n\n                       VIRTIO_QUEUE_MAX);\n\n\n\n    memory_region_init_alias(&proxy->modern_cfg,\n\n                             OBJECT(proxy),\n\n                             \"virtio-pci-cfg\",\n\n                             &proxy->modern_bar,\n\n                             0,\n\n                             memory_region_size(&proxy->modern_bar));\n\n\n\n    address_space_init(&proxy->modern_as, &proxy->modern_cfg, \"virtio-pci-cfg-as\");\n\n\n\n    if (pci_is_express(pci_dev) && pci_bus_is_express(pci_dev->bus) &&\n\n        !pci_bus_is_root(pci_dev->bus)) {\n\n        int pos;\n\n\n\n        pos = pcie_endpoint_cap_init(pci_dev, 0);\n\n        assert(pos > 0);\n\n\n\n        pos = pci_add_capability(pci_dev, PCI_CAP_ID_PM, 0, PCI_PM_SIZEOF);\n\n        assert(pos > 0);\n\n\n\n        /*\n\n         * Indicates that this function complies with revision 1.2 of the\n\n         * PCI Power Management Interface Specification.\n\n         */\n\n        pci_set_word(pci_dev->config + pos + PCI_PM_PMC, 0x3);\n\n    } else {\n\n        /*\n\n         * make future invocations of pci_is_express() return false\n\n         * and pci_config_size() return PCI_CONFIG_SPACE_SIZE.\n\n         */\n\n        pci_dev->cap_present &= ~QEMU_PCI_CAP_EXPRESS;\n\n    }\n\n\n\n    virtio_pci_bus_new(&proxy->bus, sizeof(proxy->bus), proxy);\n\n    if (k->realize) {\n\n        k->realize(proxy, errp);\n\n    }\n\n}\n", "idx": 16585, "_split": "test", "_hash": "dde0e101263f4194e3955f015ab93806"}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void save_native_fp_fsave(CPUState *env)\n\n{\n\n    int fptag, i, j;\n\n    uint16_t fpuc;\n\n    struct fpstate fp1, *fp = &fp1;\n\n\n\n    asm volatile (\"fsave %0\" : : \"m\" (*fp));\n\n    env->fpuc = fp->fpuc;\n\n    env->fpstt = (fp->fpus >> 11) & 7;\n\n    env->fpus = fp->fpus & ~0x3800;\n\n    fptag = fp->fptag;\n\n    for(i = 0;i < 8; i++) {\n\n        env->fptags[i] = ((fptag & 3) == 3);\n\n        fptag >>= 2;\n\n    }\n\n    j = env->fpstt;\n\n    for(i = 0;i < 8; i++) {\n\n        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);\n\n        j = (j + 1) & 7;\n\n    }\n\n    /* we must restore the default rounding state */\n\n    fpuc = 0x037f | (env->fpuc & (3 << 10));\n\n    asm volatile(\"fldcw %0\" : : \"m\" (fpuc));\n\n}\n", "idx": 16628, "_split": "test", "_hash": "51bee43c48f8efaf34e8d6df26e70f56"}
{"project": "qemu", "commit_id": "a38648290ee277c7cb8a53eabdcdb08bb7a9f23f", "target": 1, "func": "static void cpu_ioreq_pio(ioreq_t *req)\n\n{\n\n    int i, sign;\n\n\n\n    sign = req->df ? -1 : 1;\n\n\n\n    if (req->dir == IOREQ_READ) {\n\n        if (!req->data_is_ptr) {\n\n            req->data = do_inp(req->addr, req->size);\n\n        } else {\n\n            uint32_t tmp;\n\n\n\n            for (i = 0; i < req->count; i++) {\n\n                tmp = do_inp(req->addr, req->size);\n\n                cpu_physical_memory_write(\n\n                        req->data + (sign * i * (int64_t)req->size),\n\n                        (uint8_t *) &tmp, req->size);\n\n            }\n\n        }\n\n    } else if (req->dir == IOREQ_WRITE) {\n\n        if (!req->data_is_ptr) {\n\n            do_outp(req->addr, req->size, req->data);\n\n        } else {\n\n            for (i = 0; i < req->count; i++) {\n\n                uint32_t tmp = 0;\n\n\n\n                cpu_physical_memory_read(\n\n                        req->data + (sign * i * (int64_t)req->size),\n\n                        (uint8_t*) &tmp, req->size);\n\n                do_outp(req->addr, req->size, tmp);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 16666, "_split": "test", "_hash": "cecc4b06b729c066f8bcc1576ef43153"}
{"project": "qemu", "commit_id": "6982d6647ea98544f76d5ef40ddc23115ff44a77", "target": 1, "func": "static uint32_t hpet_ram_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    HPETState *s = (HPETState *)opaque;\n\n    uint64_t cur_tick, index;\n\n\n\n    DPRINTF(\"qemu: Enter hpet_ram_readl at %\" PRIx64 \"\\n\", addr);\n\n    index = addr;\n\n    /*address range of all TN regs*/\n\n    if (index >= 0x100 && index <= 0x3ff) {\n\n        uint8_t timer_id = (addr - 0x100) / 0x20;\n\n        if (timer_id > HPET_NUM_TIMERS - 1) {\n\n            printf(\"qemu: timer id out of range\\n\");\n\n            return 0;\n\n        }\n\n        HPETTimer *timer = &s->timer[timer_id];\n\n\n\n        switch ((addr - 0x100) % 0x20) {\n\n            case HPET_TN_CFG:\n\n                return timer->config;\n\n            case HPET_TN_CFG + 4: // Interrupt capabilities\n\n                return timer->config >> 32;\n\n            case HPET_TN_CMP: // comparator register\n\n                return timer->cmp;\n\n            case HPET_TN_CMP + 4:\n\n                return timer->cmp >> 32;\n\n            case HPET_TN_ROUTE:\n\n                return timer->fsb >> 32;\n\n            default:\n\n                DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n                break;\n\n        }\n\n    } else {\n\n        switch (index) {\n\n            case HPET_ID:\n\n                return s->capability;\n\n            case HPET_PERIOD:\n\n                return s->capability >> 32;\n\n            case HPET_CFG:\n\n                return s->config;\n\n            case HPET_CFG + 4:\n\n                DPRINTF(\"qemu: invalid HPET_CFG + 4 hpet_ram_readl \\n\");\n\n                return 0;\n\n            case HPET_COUNTER:\n\n                if (hpet_enabled())\n\n                    cur_tick = hpet_get_ticks();\n\n                else\n\n                    cur_tick = s->hpet_counter;\n\n                DPRINTF(\"qemu: reading counter  = %\" PRIx64 \"\\n\", cur_tick);\n\n                return cur_tick;\n\n            case HPET_COUNTER + 4:\n\n                if (hpet_enabled())\n\n                    cur_tick = hpet_get_ticks();\n\n                else\n\n                    cur_tick = s->hpet_counter;\n\n                DPRINTF(\"qemu: reading counter + 4  = %\" PRIx64 \"\\n\", cur_tick);\n\n                return cur_tick >> 32;\n\n            case HPET_STATUS:\n\n                return s->isr;\n\n            default:\n\n                DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n                break;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 16708, "_split": "test", "_hash": "8de9ad3659629839ede836c293b4f574"}
{"project": "qemu", "commit_id": "bd8b92d5c8387c2c94f06665514c05000169fafd", "target": 1, "func": "void usb_claim_port(USBDevice *dev, Error **errp)\n\n{\n\n    USBBus *bus = usb_bus_from_device(dev);\n\n    USBPort *port;\n\n\n\n    assert(dev->port == NULL);\n\n\n\n    if (dev->port_path) {\n\n        QTAILQ_FOREACH(port, &bus->free, next) {\n\n            if (strcmp(port->path, dev->port_path) == 0) {\n\n                break;\n\n            }\n\n        }\n\n        if (port == NULL) {\n\n            error_setg(errp, \"usb port %s (bus %s) not found (in use?)\",\n\n                       dev->port_path, bus->qbus.name);\n\n            return;\n\n        }\n\n    } else {\n\n        if (bus->nfree == 1 && strcmp(object_get_typename(OBJECT(dev)), \"usb-hub\") != 0) {\n\n            /* Create a new hub and chain it on */\n\n            usb_create_simple(bus, \"usb-hub\");\n\n        }\n\n        if (bus->nfree == 0) {\n\n            error_setg(errp, \"tried to attach usb device %s to a bus \"\n\n                       \"with no free ports\", dev->product_desc);\n\n            return;\n\n        }\n\n        port = QTAILQ_FIRST(&bus->free);\n\n    }\n\n    trace_usb_port_claim(bus->busnr, port->path);\n\n\n\n    QTAILQ_REMOVE(&bus->free, port, next);\n\n    bus->nfree--;\n\n\n\n    dev->port = port;\n\n    port->dev = dev;\n\n\n\n    QTAILQ_INSERT_TAIL(&bus->used, port, next);\n\n    bus->nused++;\n\n}\n", "idx": 16717, "_split": "test", "_hash": "9fce448ff440d5dbeaa69e2c23f4eb47"}
{"project": "qemu", "commit_id": "d6085e3ace20bc9b0fa625d8d79b22668710e217", "target": 0, "func": "static void vmxnet3_update_features(VMXNET3State *s)\n\n{\n\n    uint32_t guest_features;\n\n    int rxcso_supported;\n\n\n\n    guest_features = VMXNET3_READ_DRV_SHARED32(s->drv_shmem,\n\n                                               devRead.misc.uptFeatures);\n\n\n\n    rxcso_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXCSUM);\n\n    s->rx_vlan_stripping = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXVLAN);\n\n    s->lro_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_LRO);\n\n\n\n    VMW_CFPRN(\"Features configuration: LRO: %d, RXCSUM: %d, VLANSTRIP: %d\",\n\n              s->lro_supported, rxcso_supported,\n\n              s->rx_vlan_stripping);\n\n    if (s->peer_has_vhdr) {\n\n        qemu_peer_set_offload(qemu_get_queue(s->nic),\n\n                        rxcso_supported,\n\n                        s->lro_supported,\n\n                        s->lro_supported,\n\n                        0,\n\n                        0);\n\n    }\n\n}\n", "idx": 16723, "_split": "test", "_hash": "08bebc0d6064543707478951080fb23c"}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "static int virtio_blk_exit_pci(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n\n\n    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);\n\n    return virtio_exit_pci(pci_dev);\n\n}\n", "idx": 16724, "_split": "test", "_hash": "f7ef7cde4ac88009d7da110e835e00c0"}
{"project": "qemu", "commit_id": "8e65b7c04965c8355e4ce43211582b6b83054e3d", "target": 0, "func": "static void uhci_async_complete(USBPacket *packet, void *opaque)\n\n{\n\n    UHCIState *s = opaque;\n\n    UHCIAsync *async = (UHCIAsync *) packet;\n\n\n\n    DPRINTF(\"uhci: async complete. td 0x%x token 0x%x\\n\", async->td, async->token);\n\n\n\n    async->done = 1;\n\n\n\n    uhci_process_frame(s);\n\n}\n", "idx": 16728, "_split": "test", "_hash": "34562c5ab5a12e24b6020cdde0027ec8"}
{"project": "qemu", "commit_id": "02acedf93da420713a0c4bbeaf32ce9d734a4332", "target": 0, "func": "static void gen_neon_unzip(int reg, int q, int tmp, int size)\n\n{\n\n    int n;\n\n    TCGv t0, t1;\n\n\n\n    for (n = 0; n < q + 1; n += 2) {\n\n        t0 = neon_load_reg(reg, n);\n\n        t1 = neon_load_reg(reg, n + 1);\n\n        switch (size) {\n\n        case 0: gen_neon_unzip_u8(t0, t1); break;\n\n        case 1: gen_neon_zip_u16(t0, t1); break; /* zip and unzip are the same.  */\n\n        case 2: /* no-op */; break;\n\n        default: abort();\n\n        }\n\n        neon_store_scratch(tmp + n, t0);\n\n        neon_store_scratch(tmp + n + 1, t1);\n\n    }\n\n}\n", "idx": 16735, "_split": "test", "_hash": "79f856bcf9960acadb981ecd4a8e5cd1"}
{"project": "qemu", "commit_id": "f892291eee376505cfec8b6cade7ccf952a6d3e0", "target": 0, "func": "static void parse_numa_distance(NumaDistOptions *dist, Error **errp)\n\n{\n\n    uint16_t src = dist->src;\n\n    uint16_t dst = dist->dst;\n\n    uint8_t val = dist->val;\n\n\n\n    if (src >= MAX_NODES || dst >= MAX_NODES) {\n\n        error_setg(errp,\n\n                   \"Invalid node %\" PRIu16\n\n                   \", max possible could be %\" PRIu16,\n\n                   MAX(src, dst), MAX_NODES);\n\n        return;\n\n    }\n\n\n\n    if (!numa_info[src].present || !numa_info[dst].present) {\n\n        error_setg(errp, \"Source/Destination NUMA node is missing. \"\n\n                   \"Please use '-numa node' option to declare it first.\");\n\n        return;\n\n    }\n\n\n\n    if (val < NUMA_DISTANCE_MIN) {\n\n        error_setg(errp, \"NUMA distance (%\" PRIu8 \") is invalid, \"\n\n                   \"it shouldn't be less than %d.\",\n\n                   val, NUMA_DISTANCE_MIN);\n\n        return;\n\n    }\n\n\n\n    if (src == dst && val != NUMA_DISTANCE_MIN) {\n\n        error_setg(errp, \"Local distance of node %d should be %d.\",\n\n                   src, NUMA_DISTANCE_MIN);\n\n        return;\n\n    }\n\n\n\n    numa_info[src].distance[dst] = val;\n\n    have_numa_distance = true;\n\n}\n", "idx": 16752, "_split": "test", "_hash": "42ba5591bed536c9ca7084df7139ff5f"}
{"project": "qemu", "commit_id": "94a8d39afd8ccfdbf578af04c3385fdb5f545af1", "target": 1, "func": "uint32_t kvm_arch_get_supported_cpuid(CPUState *env, uint32_t function,\n\n                                      uint32_t index, int reg)\n\n{\n\n    struct kvm_cpuid2 *cpuid;\n\n    int i, max;\n\n    uint32_t ret = 0;\n\n    uint32_t cpuid_1_edx;\n\n\n\n    if (!kvm_check_extension(env->kvm_state, KVM_CAP_EXT_CPUID)) {\n\n        return -1U;\n\n    }\n\n\n\n    max = 1;\n\n    while ((cpuid = try_get_cpuid(env->kvm_state, max)) == NULL) {\n\n        max *= 2;\n\n    }\n\n\n\n    for (i = 0; i < cpuid->nent; ++i) {\n\n        if (cpuid->entries[i].function == function &&\n\n            cpuid->entries[i].index == index) {\n\n            switch (reg) {\n\n            case R_EAX:\n\n                ret = cpuid->entries[i].eax;\n\n                break;\n\n            case R_EBX:\n\n                ret = cpuid->entries[i].ebx;\n\n                break;\n\n            case R_ECX:\n\n                ret = cpuid->entries[i].ecx;\n\n                break;\n\n            case R_EDX:\n\n                ret = cpuid->entries[i].edx;\n\n                switch (function) {\n\n                case 1:\n\n                    /* KVM before 2.6.30 misreports the following features */\n\n                    ret |= CPUID_MTRR | CPUID_PAT | CPUID_MCE | CPUID_MCA;\n\n                    break;\n\n                case 0x80000001:\n\n                    /* On Intel, kvm returns cpuid according to the Intel spec,\n\n                     * so add missing bits according to the AMD spec:\n\n                     */\n\n                    cpuid_1_edx = kvm_arch_get_supported_cpuid(env, 1, 0, R_EDX);\n\n                    ret |= cpuid_1_edx & 0x183f7ff;\n\n                    break;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    qemu_free(cpuid);\n\n\n\n    return ret;\n\n}\n", "idx": 16771, "_split": "test", "_hash": "b2d635dfa73efe435ac13b5f84b507be"}
{"project": "qemu", "commit_id": "2f859f80c2077e00237ea1dfae2523ebd8377f5f", "target": 0, "func": "static bool get_next_page(GuestPhysBlock **blockptr, uint64_t *pfnptr,\n\n                          uint8_t **bufptr, DumpState *s)\n\n{\n\n    GuestPhysBlock *block = *blockptr;\n\n    hwaddr addr;\n\n    uint8_t *buf;\n\n\n\n    /* block == NULL means the start of the iteration */\n\n    if (!block) {\n\n        block = QTAILQ_FIRST(&s->guest_phys_blocks.head);\n\n        *blockptr = block;\n\n        assert(block->target_start % s->page_size == 0);\n\n        assert(block->target_end % s->page_size == 0);\n\n        *pfnptr = paddr_to_pfn(block->target_start);\n\n        if (bufptr) {\n\n            *bufptr = block->host_addr;\n\n        }\n\n        return true;\n\n    }\n\n\n\n    *pfnptr = *pfnptr + 1;\n\n    addr = pfn_to_paddr(*pfnptr);\n\n\n\n    if ((addr >= block->target_start) &&\n\n        (addr + s->page_size <= block->target_end)) {\n\n        buf = block->host_addr + (addr - block->target_start);\n\n    } else {\n\n        /* the next page is in the next block */\n\n        block = QTAILQ_NEXT(block, next);\n\n        *blockptr = block;\n\n        if (!block) {\n\n            return false;\n\n        }\n\n        assert(block->target_start % s->page_size == 0);\n\n        assert(block->target_end % s->page_size == 0);\n\n        *pfnptr = paddr_to_pfn(block->target_start);\n\n        buf = block->host_addr;\n\n    }\n\n\n\n    if (bufptr) {\n\n        *bufptr = buf;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 16780, "_split": "test", "_hash": "0f99a04615c8d07753f5f8e9c4ccc98e"}
{"project": "qemu", "commit_id": "280d373579558f73a8b70e329d9a6206933d3809", "target": 0, "func": "static coroutine_fn int qcow2_co_writev(BlockDriverState *bs,\n\n                           int64_t sector_num,\n\n                           int remaining_sectors,\n\n                           QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    int n_end;\n\n    int ret;\n\n    int cur_nr_sectors; /* number of sectors in current iteration */\n\n    uint64_t cluster_offset;\n\n    QEMUIOVector hd_qiov;\n\n    uint64_t bytes_done = 0;\n\n    uint8_t *cluster_data = NULL;\n\n    QCowL2Meta *l2meta;\n\n\n\n    trace_qcow2_writev_start_req(qemu_coroutine_self(), sector_num,\n\n                                 remaining_sectors);\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    s->cluster_cache_offset = -1; /* disable compressed cache */\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (remaining_sectors != 0) {\n\n\n\n        l2meta = NULL;\n\n\n\n        trace_qcow2_writev_start_part(qemu_coroutine_self());\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n_end = index_in_cluster + remaining_sectors;\n\n        if (s->crypt_method &&\n\n            n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) {\n\n            n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n        }\n\n\n\n        ret = qcow2_alloc_cluster_offset(bs, sector_num << 9,\n\n            index_in_cluster, n_end, &cur_nr_sectors, &cluster_offset, &l2meta);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        if (l2meta->nb_clusters > 0 &&\n\n            (s->compatible_features & QCOW2_COMPAT_LAZY_REFCOUNTS)) {\n\n            qcow2_mark_dirty(bs);\n\n        }\n\n\n\n        assert((cluster_offset & 511) == 0);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_concat(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (s->crypt_method) {\n\n            if (!cluster_data) {\n\n                cluster_data = qemu_blockalign(bs, QCOW_MAX_CRYPT_CLUSTERS *\n\n                                                 s->cluster_size);\n\n            }\n\n\n\n            assert(hd_qiov.size <=\n\n                   QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n            qemu_iovec_to_buf(&hd_qiov, 0, cluster_data, hd_qiov.size);\n\n\n\n            qcow2_encrypt_sectors(s, sector_num, cluster_data,\n\n                cluster_data, cur_nr_sectors, 1, &s->aes_encrypt_key);\n\n\n\n            qemu_iovec_reset(&hd_qiov);\n\n            qemu_iovec_add(&hd_qiov, cluster_data,\n\n                cur_nr_sectors * 512);\n\n        }\n\n\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n        trace_qcow2_writev_data(qemu_coroutine_self(),\n\n                                (cluster_offset >> 9) + index_in_cluster);\n\n        ret = bdrv_co_writev(bs->file,\n\n                             (cluster_offset >> 9) + index_in_cluster,\n\n                             cur_nr_sectors, &hd_qiov);\n\n        qemu_co_mutex_lock(&s->lock);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        if (l2meta != NULL) {\n\n            ret = qcow2_alloc_cluster_link_l2(bs, l2meta);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            run_dependent_requests(s, l2meta);\n\n            g_free(l2meta);\n\n            l2meta = NULL;\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n        trace_qcow2_writev_done_part(qemu_coroutine_self(), cur_nr_sectors);\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    if (l2meta != NULL) {\n\n        run_dependent_requests(s, l2meta);\n\n        g_free(l2meta);\n\n    }\n\n\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n    qemu_vfree(cluster_data);\n\n    trace_qcow2_writev_done_req(qemu_coroutine_self(), ret);\n\n\n\n    return ret;\n\n}\n", "idx": 16783, "_split": "test", "_hash": "49433d6ab8c933e97ad16067f669ee90"}
{"project": "qemu", "commit_id": "a980a065fb5e86d6dec337e6cb6ff432f1a143c9", "target": 0, "func": "int usb_desc_get_descriptor(USBDevice *dev, int value, uint8_t *dest, size_t len)\n\n{\n\n    const USBDesc *desc = dev->info->usb_desc;\n\n    uint8_t buf[256];\n\n    uint8_t type = value >> 8;\n\n    uint8_t index = value & 0xff;\n\n    int ret = -1;\n\n\n\n    switch(type) {\n\n    case USB_DT_DEVICE:\n\n        ret = usb_desc_device(&desc->id, desc->full, buf, sizeof(buf));\n\n        trace_usb_desc_device(dev->addr, len, ret);\n\n        break;\n\n    case USB_DT_CONFIG:\n\n        if (index < desc->full->bNumConfigurations) {\n\n            ret = usb_desc_config(desc->full->confs + index, buf, sizeof(buf));\n\n        }\n\n        trace_usb_desc_config(dev->addr, index, len, ret);\n\n        break;\n\n    case USB_DT_STRING:\n\n        ret = usb_desc_string(dev, index, buf, sizeof(buf));\n\n        trace_usb_desc_string(dev->addr, index, len, ret);\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: %d unknown type %d (len %zd)\\n\", __FUNCTION__,\n\n                dev->addr, type, len);\n\n        break;\n\n    }\n\n\n\n    if (ret > 0) {\n\n        if (ret > len) {\n\n            ret = len;\n\n        }\n\n        memcpy(dest, buf, ret);\n\n    }\n\n    return ret;\n\n}\n", "idx": 16787, "_split": "test", "_hash": "dc5a9ebed1ae339b5b4df98d1f00701a"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void connex_init(MachineState *machine)\n\n{\n\n    PXA2xxState *cpu;\n\n    DriveInfo *dinfo;\n\n    int be;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n\n\n    uint32_t connex_rom = 0x01000000;\n\n    uint32_t connex_ram = 0x04000000;\n\n\n\n    cpu = pxa255_init(address_space_mem, connex_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    if (!dinfo && !qtest_enabled()) {\n\n        fprintf(stderr, \"A flash image must be given with the \"\n\n                \"'pflash' parameter\\n\");\n\n        exit(1);\n\n    }\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    if (!pflash_cfi01_register(0x00000000, NULL, \"connext.rom\", connex_rom,\n\n                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                               sector_len, connex_rom / sector_len,\n\n                               2, 0, 0, 0, 0, be)) {\n\n        fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Interrupt line of NIC is connected to GPIO line 36 */\n\n    smc91c111_init(&nd_table[0], 0x04000300,\n\n                    qdev_get_gpio_in(cpu->gpio, 36));\n\n}\n", "idx": 16792, "_split": "test", "_hash": "e1be170c07334ff1894bfe230f13e671"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_set_event_notifier(AioContext *ctx,\n\n                            EventNotifier *notifier,\n\n                            bool is_external,\n\n                            EventNotifierHandler *io_read,\n\n                            AioPollFn *io_poll)\n\n{\n\n    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,\n\n                       (IOHandler *)io_read, NULL, io_poll, notifier);\n\n}\n", "idx": 16794, "_split": "test", "_hash": "56a80e21ee752f7418b740bc8b9e3905"}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void kqemu_modify_page(CPUState *env, ram_addr_t ram_addr)\n\n{\n\n    unsigned long page_index;\n\n    int ret;\n\n#ifdef _WIN32\n\n    DWORD temp;\n\n#endif\n\n\n\n    page_index = ram_addr >> TARGET_PAGE_BITS;\n\n    if (!modified_ram_pages_table[page_index]) {\n\n#if 0\n\n        printf(\"%d: modify_page=%08lx\\n\", nb_modified_ram_pages, ram_addr);\n\n#endif\n\n        modified_ram_pages_table[page_index] = 1;\n\n        modified_ram_pages[nb_modified_ram_pages++] = ram_addr;\n\n        if (nb_modified_ram_pages >= KQEMU_MAX_MODIFIED_RAM_PAGES) {\n\n            /* flush */\n\n#ifdef _WIN32\n\n            ret = DeviceIoControl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,\n\n                                  &nb_modified_ram_pages,\n\n                                  sizeof(nb_modified_ram_pages),\n\n                                  NULL, 0, &temp, NULL);\n\n#else\n\n            ret = ioctl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,\n\n                        &nb_modified_ram_pages);\n\n#endif\n\n            kqemu_reset_modified_ram_pages();\n\n        }\n\n    }\n\n}\n", "idx": 16812, "_split": "test", "_hash": "03b996d3171dbf3dfd91ac86775e322b"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,\n\n                                 unsigned npfd, int64_t timeout)\n\n{\n\n    if (!ctx->epoll_available) {\n\n        return false;\n\n    }\n\n    if (aio_epoll_enabled(ctx)) {\n\n        return true;\n\n    }\n\n    if (npfd >= EPOLL_ENABLE_THRESHOLD) {\n\n        if (aio_epoll_try_enable(ctx)) {\n\n            return true;\n\n        } else {\n\n            aio_epoll_disable(ctx);\n\n        }\n\n    }\n\n    return false;\n\n}\n", "idx": 16829, "_split": "test", "_hash": "6028f17b380fa36e3110928f28d4e22c"}
{"project": "qemu", "commit_id": "83e6813a93e38976391b8c382c3375e3e188df3e", "target": 0, "func": "static void aarch64_cpu_register_types(void)\n\n{\n\n    int i;\n\n\n\n    type_register_static(&aarch64_cpu_type_info);\n\n    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {\n\n        aarch64_cpu_register(&aarch64_cpus[i]);\n\n    }\n\n}\n", "idx": 16842, "_split": "test", "_hash": "1a60ed1a9fa27fd9eedd8a4fad29ae71"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void musicpal_lcd_write(void *opaque, target_phys_addr_t offset,\n\n                               uint64_t value, unsigned size)\n\n{\n\n    musicpal_lcd_state *s = opaque;\n\n\n\n    switch (offset) {\n\n    case MP_LCD_IRQCTRL:\n\n        s->irqctrl = value;\n\n        break;\n\n\n\n    case MP_LCD_SPICTRL:\n\n        if (value == MP_LCD_SPI_DATA || value == MP_LCD_SPI_CMD) {\n\n            s->mode = value;\n\n        } else {\n\n            s->mode = MP_LCD_SPI_INVALID;\n\n        }\n\n        break;\n\n\n\n    case MP_LCD_INST:\n\n        if (value >= MP_LCD_INST_SETPAGE0 && value <= MP_LCD_INST_SETPAGE7) {\n\n            s->page = value - MP_LCD_INST_SETPAGE0;\n\n            s->page_off = 0;\n\n        }\n\n        break;\n\n\n\n    case MP_LCD_DATA:\n\n        if (s->mode == MP_LCD_SPI_CMD) {\n\n            if (value >= MP_LCD_INST_SETPAGE0 &&\n\n                value <= MP_LCD_INST_SETPAGE7) {\n\n                s->page = value - MP_LCD_INST_SETPAGE0;\n\n                s->page_off = 0;\n\n            }\n\n        } else if (s->mode == MP_LCD_SPI_DATA) {\n\n            s->video_ram[s->page*128 + s->page_off] = value;\n\n            s->page_off = (s->page_off + 1) & 127;\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 16862, "_split": "test", "_hash": "d8d29bbd0a666a903df548ea4e6a823b"}
{"project": "qemu", "commit_id": "3b2e934463121f06d04e4d17658a9a7cdc3717b0", "target": 0, "func": "static inline uint32_t nvic_gprio_mask(NVICState *s)\n\n{\n\n    return ~0U << (s->prigroup + 1);\n\n}\n", "idx": 16870, "_split": "test", "_hash": "3ae3fb63fdabd4d8c618608ca17d7d61"}
{"project": "qemu", "commit_id": "cbcfa0418f0c196afa765f5c9837b9344d1adcf3", "target": 0, "func": "int qemu_eventfd(int fds[2])\n\n{\n\n#ifdef CONFIG_EVENTFD\n\n    int ret;\n\n\n\n    ret = eventfd(0, 0);\n\n    if (ret >= 0) {\n\n        fds[0] = ret;\n\n        qemu_set_cloexec(ret);\n\n        if ((fds[1] = dup(ret)) == -1) {\n\n            close(ret);\n\n            return -1;\n\n        }\n\n        qemu_set_cloexec(fds[1]);\n\n        return 0;\n\n    }\n\n\n\n    if (errno != ENOSYS) {\n\n        return -1;\n\n    }\n\n#endif\n\n\n\n    return qemu_pipe(fds);\n\n}\n", "idx": 16879, "_split": "test", "_hash": "d682d29ae370cc87d4e1e79c22387729"}
{"project": "qemu", "commit_id": "77a5a0001bd9eaee9da7dc8f0b69702d56b0cc67", "target": 0, "func": "static int bdrv_qed_truncate(BlockDriverState *bs, int64_t offset)\n\n{\n\n    return -ENOTSUP;\n\n}\n", "idx": 16888, "_split": "test", "_hash": "562896cf68097770cb0d1ae9da2aa641"}
{"project": "qemu", "commit_id": "3d0be8a5c135dadcfbd68ed354007a8cece98849", "target": 0, "func": "void HELPER(wsr_ibreakenable)(uint32_t v)\n\n{\n\n    uint32_t change = v ^ env->sregs[IBREAKENABLE];\n\n    unsigned i;\n\n\n\n    for (i = 0; i < env->config->nibreak; ++i) {\n\n        if (change & (1 << i)) {\n\n            tb_invalidate_phys_page_range(\n\n                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);\n\n        }\n\n    }\n\n    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);\n\n}\n", "idx": 16890, "_split": "test", "_hash": "a154b421aa1a56d4b6e9d9d87d99e9ad"}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void openrisc_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    OpenRISCCPUClass *occ = OPENRISC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(occ);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    occ->parent_realize = dc->realize;\n\n    dc->realize = openrisc_cpu_realizefn;\n\n\n\n    occ->parent_reset = cc->reset;\n\n    cc->reset = openrisc_cpu_reset;\n\n\n\n    cc->class_by_name = openrisc_cpu_class_by_name;\n\n    cc->has_work = openrisc_cpu_has_work;\n\n    cc->do_interrupt = openrisc_cpu_do_interrupt;\n\n    cc->cpu_exec_interrupt = openrisc_cpu_exec_interrupt;\n\n    cc->dump_state = openrisc_cpu_dump_state;\n\n    cc->set_pc = openrisc_cpu_set_pc;\n\n    cc->gdb_read_register = openrisc_cpu_gdb_read_register;\n\n    cc->gdb_write_register = openrisc_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = openrisc_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_phys_page_debug = openrisc_cpu_get_phys_page_debug;\n\n    dc->vmsd = &vmstate_openrisc_cpu;\n\n#endif\n\n    cc->gdb_num_core_regs = 32 + 3;\n\n\n\n    /*\n\n     * Reason: openrisc_cpu_initfn() calls cpu_exec_init(), which saves\n\n     * the object in cpus -> dangling pointer after final\n\n     * object_unref().\n\n     */\n\n    dc->cannot_destroy_with_object_finalize_yet = true;\n\n}\n", "idx": 16924, "_split": "test", "_hash": "8b15116210117ea03fc805faf22db2c0"}
{"project": "qemu", "commit_id": "d99598cc9929ad6993ad3d19d9b1ec1d891f0d7f", "target": 1, "func": "static void tcp_accept_incoming_migration(void *opaque)\n\n{\n\n    struct sockaddr_in addr;\n\n    socklen_t addrlen = sizeof(addr);\n\n    int s = (intptr_t)opaque;\n\n    QEMUFile *f;\n\n    int c;\n\n\n\n    do {\n\n        c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);\n\n    } while (c == -1 && socket_error() == EINTR);\n\n    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);\n\n    closesocket(s);\n\n\n\n    DPRINTF(\"accepted migration\\n\");\n\n\n\n    if (c == -1) {\n\n        fprintf(stderr, \"could not accept migration connection\\n\");\n\n        goto out;\n\n    }\n\n\n\n    f = qemu_fopen_socket(c, \"rb\");\n\n    if (f == NULL) {\n\n        fprintf(stderr, \"could not qemu_fopen socket\\n\");\n\n        goto out;\n\n    }\n\n\n\n    process_incoming_migration(f);\n\n    return;\n\n\n\nout:\n\n    closesocket(c);\n\n}\n", "idx": 16930, "_split": "test", "_hash": "965a1ad4e274439f6b9f62347b9fd94a"}
{"project": "qemu", "commit_id": "a9db86b223030bd40bdd81b160788196bc95fe6f", "target": 1, "func": "static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)\n\n{\n\n    int i;\n\n    assert(dest->niov == source->niov);\n\n    assert(dest->size == source->size);\n\n    for (i = 0; i < source->niov; i++) {\n\n        assert(dest->iov[i].iov_len == source->iov[i].iov_len);\n\n        memcpy(dest->iov[i].iov_base,\n\n               source->iov[i].iov_base,\n\n               source->iov[i].iov_len);\n\n    }\n\n}\n", "idx": 16933, "_split": "test", "_hash": "44501c8609a926eaccbc137775edae8c"}
{"project": "qemu", "commit_id": "6877cff044cdf6da66885eab62363baf98bb39ee", "target": 0, "func": "static int assigned_initfn(struct PCIDevice *pci_dev)\n\n{\n\n    AssignedDevice *dev = DO_UPCAST(AssignedDevice, dev, pci_dev);\n\n    uint8_t e_intx;\n\n    int r;\n\n    Error *local_err = NULL;\n\n\n\n    if (!kvm_enabled()) {\n\n        error_report(\"pci-assign: error: requires KVM support\");\n\n        return -1;\n\n    }\n\n\n\n    if (!dev->host.domain && !dev->host.bus && !dev->host.slot &&\n\n        !dev->host.function) {\n\n        error_report(\"pci-assign: error: no host device specified\");\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * Set up basic config space access control. Will be further refined during\n\n     * device initialization.\n\n     */\n\n    assigned_dev_emulate_config_read(dev, 0, PCI_CONFIG_SPACE_SIZE);\n\n    assigned_dev_direct_config_read(dev, PCI_STATUS, 2);\n\n    assigned_dev_direct_config_read(dev, PCI_REVISION_ID, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_CLASS_PROG, 3);\n\n    assigned_dev_direct_config_read(dev, PCI_CACHE_LINE_SIZE, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_LATENCY_TIMER, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_BIST, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_CARDBUS_CIS, 4);\n\n    assigned_dev_direct_config_read(dev, PCI_SUBSYSTEM_VENDOR_ID, 2);\n\n    assigned_dev_direct_config_read(dev, PCI_SUBSYSTEM_ID, 2);\n\n    assigned_dev_direct_config_read(dev, PCI_CAPABILITY_LIST + 1, 7);\n\n    assigned_dev_direct_config_read(dev, PCI_MIN_GNT, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_MAX_LAT, 1);\n\n    memcpy(dev->emulate_config_write, dev->emulate_config_read,\n\n           sizeof(dev->emulate_config_read));\n\n\n\n    get_real_device(dev, &local_err);\n\n    if (local_err) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    if (assigned_device_pci_cap_init(pci_dev, &local_err) < 0) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    /* intercept MSI-X entry page in the MMIO */\n\n    if (dev->cap.available & ASSIGNED_DEVICE_CAP_MSIX) {\n\n        assigned_dev_register_msix_mmio(dev, &local_err);\n\n        if (local_err) {\n\n            qerror_report_err(local_err);\n\n            error_free(local_err);\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    /* handle real device's MMIO/PIO BARs */\n\n    assigned_dev_register_regions(dev->real_device.regions,\n\n                                  dev->real_device.region_number, dev,\n\n                                  &local_err);\n\n    if (local_err) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    /* handle interrupt routing */\n\n    e_intx = dev->dev.config[PCI_INTERRUPT_PIN] - 1;\n\n    dev->intpin = e_intx;\n\n    dev->intx_route.mode = PCI_INTX_DISABLED;\n\n    dev->intx_route.irq = -1;\n\n\n\n    /* assign device to guest */\n\n    r = assign_device(dev);\n\n    if (r < 0) {\n\n        goto out;\n\n    }\n\n\n\n    /* assign legacy INTx to the device */\n\n    r = assign_intx(dev);\n\n    if (r < 0) {\n\n        goto assigned_out;\n\n    }\n\n\n\n    assigned_dev_load_option_rom(dev);\n\n\n\n    add_boot_device_path(dev->bootindex, &pci_dev->qdev, NULL);\n\n\n\n    return 0;\n\n\n\nassigned_out:\n\n    deassign_device(dev);\n\nout:\n\n    free_assigned_device(dev);\n\n    return -1;\n\n}\n", "idx": 16999, "_split": "test", "_hash": "c2b2383c71338b765965bce30c175a25"}
{"project": "qemu", "commit_id": "a2db2a1edd06a50b8a862c654cf993368cf9f1d9", "target": 0, "func": "int xen_be_send_notify(struct XenDevice *xendev)\n\n{\n\n    return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);\n\n}\n", "idx": 17004, "_split": "test", "_hash": "b0be9159a61cf6b406f55c210f9d4645"}
{"project": "qemu", "commit_id": "41a2b9596c9ed2a827e16e749632752dd2686647", "target": 0, "func": "static void ide_atapi_cmd_reply_end(IDEState *s)\n\n{\n\n    int byte_count_limit, size, ret;\n\n#ifdef DEBUG_IDE_ATAPI\n\n    printf(\"reply: tx_size=%d elem_tx_size=%d index=%d\\n\",\n\n           s->packet_transfer_size,\n\n           s->elementary_transfer_size,\n\n           s->io_buffer_index);\n\n#endif\n\n    if (s->packet_transfer_size <= 0) {\n\n        /* end of transfer */\n\n        ide_transfer_stop(s);\n\n        s->status = READY_STAT;\n\n        s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO | ATAPI_INT_REASON_CD;\n\n        ide_set_irq(s);\n\n#ifdef DEBUG_IDE_ATAPI\n\n        printf(\"status=0x%x\\n\", s->status);\n\n#endif\n\n    } else {\n\n        /* see if a new sector must be read */\n\n        if (s->lba != -1 && s->io_buffer_index >= s->cd_sector_size) {\n\n            ret = cd_read_sector(s->bs, s->lba, s->io_buffer, s->cd_sector_size);\n\n            if (ret < 0) {\n\n                ide_transfer_stop(s);\n\n                ide_atapi_io_error(s, ret);\n\n                return;\n\n            }\n\n            s->lba++;\n\n            s->io_buffer_index = 0;\n\n        }\n\n        if (s->elementary_transfer_size > 0) {\n\n            /* there are some data left to transmit in this elementary\n\n               transfer */\n\n            size = s->cd_sector_size - s->io_buffer_index;\n\n            if (size > s->elementary_transfer_size)\n\n                size = s->elementary_transfer_size;\n\n            ide_transfer_start(s, s->io_buffer + s->io_buffer_index,\n\n                               size, ide_atapi_cmd_reply_end);\n\n            s->packet_transfer_size -= size;\n\n            s->elementary_transfer_size -= size;\n\n            s->io_buffer_index += size;\n\n        } else {\n\n            /* a new transfer is needed */\n\n            s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO;\n\n            byte_count_limit = s->lcyl | (s->hcyl << 8);\n\n#ifdef DEBUG_IDE_ATAPI\n\n            printf(\"byte_count_limit=%d\\n\", byte_count_limit);\n\n#endif\n\n            if (byte_count_limit == 0xffff)\n\n                byte_count_limit--;\n\n            size = s->packet_transfer_size;\n\n            if (size > byte_count_limit) {\n\n                /* byte count limit must be even if this case */\n\n                if (byte_count_limit & 1)\n\n                    byte_count_limit--;\n\n                size = byte_count_limit;\n\n            }\n\n            s->lcyl = size;\n\n            s->hcyl = size >> 8;\n\n            s->elementary_transfer_size = size;\n\n            /* we cannot transmit more than one sector at a time */\n\n            if (s->lba != -1) {\n\n                if (size > (s->cd_sector_size - s->io_buffer_index))\n\n                    size = (s->cd_sector_size - s->io_buffer_index);\n\n            }\n\n            ide_transfer_start(s, s->io_buffer + s->io_buffer_index,\n\n                               size, ide_atapi_cmd_reply_end);\n\n            s->packet_transfer_size -= size;\n\n            s->elementary_transfer_size -= size;\n\n            s->io_buffer_index += size;\n\n            ide_set_irq(s);\n\n#ifdef DEBUG_IDE_ATAPI\n\n            printf(\"status=0x%x\\n\", s->status);\n\n#endif\n\n        }\n\n    }\n\n}\n", "idx": 17012, "_split": "test", "_hash": "9f4d708baa0e29e5b37607a7aba0d464"}
{"project": "qemu", "commit_id": "7c560456707bfe53eb1728fcde759be7d9418b62", "target": 0, "func": "static void slavio_led_mem_writes(void *opaque, target_phys_addr_t addr,\n\n                                  uint32_t val)\n\n{\n\n    MiscState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = addr & LED_MAXADDR;\n\n    MISC_DPRINTF(\"Write diagnostic LED reg 0x\" TARGET_FMT_plx \" =  %x\\n\", addr,\n\n                 val);\n\n    switch (saddr) {\n\n    case 0:\n\n        s->leds = val;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 17021, "_split": "test", "_hash": "7a1d6b4fb7be899a9c54072f2c46ffac"}
{"project": "qemu", "commit_id": "7ce21016b69b512bf4777965a4292318f2bc7544", "target": 0, "func": "int coroutine_fn bdrv_co_discard(BlockDriverState *bs, int64_t sector_num,\n\n                                 int nb_sectors)\n\n{\n\n    int max_discard;\n\n\n\n    if (!bs->drv) {\n\n        return -ENOMEDIUM;\n\n    } else if (bdrv_check_request(bs, sector_num, nb_sectors)) {\n\n        return -EIO;\n\n    } else if (bs->read_only) {\n\n        return -EROFS;\n\n    }\n\n\n\n    bdrv_reset_dirty(bs, sector_num, nb_sectors);\n\n\n\n    /* Do nothing if disabled.  */\n\n    if (!(bs->open_flags & BDRV_O_UNMAP)) {\n\n        return 0;\n\n    }\n\n\n\n    if (!bs->drv->bdrv_co_discard && !bs->drv->bdrv_aio_discard) {\n\n        return 0;\n\n    }\n\n\n\n    max_discard = bs->bl.max_discard ?  bs->bl.max_discard : MAX_DISCARD_DEFAULT;\n\n    while (nb_sectors > 0) {\n\n        int ret;\n\n        int num = nb_sectors;\n\n\n\n        /* align request */\n\n        if (bs->bl.discard_alignment &&\n\n            num >= bs->bl.discard_alignment &&\n\n            sector_num % bs->bl.discard_alignment) {\n\n            if (num > bs->bl.discard_alignment) {\n\n                num = bs->bl.discard_alignment;\n\n            }\n\n            num -= sector_num % bs->bl.discard_alignment;\n\n        }\n\n\n\n        /* limit request size */\n\n        if (num > max_discard) {\n\n            num = max_discard;\n\n        }\n\n\n\n        if (bs->drv->bdrv_co_discard) {\n\n            ret = bs->drv->bdrv_co_discard(bs, sector_num, num);\n\n        } else {\n\n            BlockDriverAIOCB *acb;\n\n            CoroutineIOCompletion co = {\n\n                .coroutine = qemu_coroutine_self(),\n\n            };\n\n\n\n            acb = bs->drv->bdrv_aio_discard(bs, sector_num, nb_sectors,\n\n                                            bdrv_co_io_em_complete, &co);\n\n            if (acb == NULL) {\n\n                return -EIO;\n\n            } else {\n\n                qemu_coroutine_yield();\n\n                ret = co.ret;\n\n            }\n\n        }\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        sector_num += num;\n\n        nb_sectors -= num;\n\n    }\n\n    return 0;\n\n}\n", "idx": 17030, "_split": "test", "_hash": "d5d18b4dfb22c3f5832301260fe95a71"}
{"project": "qemu", "commit_id": "aff3f0f150769ec4f97c6e2cefe91c4a0377b548", "target": 0, "func": "static void xlnx_ep108_machine_init(MachineClass *mc)\n\n{\n\n    mc->desc = \"Xilinx ZynqMP EP108 board\";\n\n    mc->init = xlnx_ep108_init;\n\n    mc->block_default_type = IF_IDE;\n\n    mc->units_per_default_bus = 1;\n\n    mc->ignore_memory_transaction_failures = true;\n\n}\n", "idx": 17043, "_split": "test", "_hash": "e6237e9e492c750bb4935a23769295c1"}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType ext,\n\n                             TCGReg rd, TCGReg rn, uint64_t limm)\n\n{\n\n    unsigned h, l, r, c;\n\n\n\n    assert(is_limm(limm));\n\n\n\n    h = clz64(limm);\n\n    l = ctz64(limm);\n\n    if (l == 0) {\n\n        r = 0;                  /* form 0....01....1 */\n\n        c = ctz64(~limm) - 1;\n\n        if (h == 0) {\n\n            r = clz64(~limm);   /* form 1..10..01..1 */\n\n            c += r;\n\n        }\n\n    } else {\n\n        r = 64 - l;             /* form 1....10....0 or 0..01..10..0 */\n\n        c = r - h - 1;\n\n    }\n\n    if (ext == TCG_TYPE_I32) {\n\n        r &= 31;\n\n        c &= 31;\n\n    }\n\n\n\n    tcg_out_insn_3404(s, insn, ext, rd, rn, ext, r, c);\n\n}\n", "idx": 17048, "_split": "test", "_hash": "6ed3d0d92c8b81565deac9f8480b6369"}
{"project": "qemu", "commit_id": "80db0e7822962554c91bef05d784c898e8ab1c3c", "target": 0, "func": "void ich9_pm_init(PCIDevice *lpc_pci, ICH9LPCPMRegs *pm,\n\n                  bool smm_enabled,\n\n                  qemu_irq sci_irq)\n\n{\n\n    memory_region_init(&pm->io, OBJECT(lpc_pci), \"ich9-pm\", ICH9_PMIO_SIZE);\n\n    memory_region_set_enabled(&pm->io, false);\n\n    memory_region_add_subregion(pci_address_space_io(lpc_pci),\n\n                                0, &pm->io);\n\n\n\n    acpi_pm_tmr_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_evt_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_cnt_init(&pm->acpi_regs, &pm->io, pm->disable_s3, pm->disable_s4,\n\n                      pm->s4_val);\n\n\n\n    acpi_gpe_init(&pm->acpi_regs, ICH9_PMIO_GPE0_LEN);\n\n    memory_region_init_io(&pm->io_gpe, OBJECT(lpc_pci), &ich9_gpe_ops, pm,\n\n                          \"acpi-gpe0\", ICH9_PMIO_GPE0_LEN);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_GPE0_STS, &pm->io_gpe);\n\n\n\n    memory_region_init_io(&pm->io_smi, OBJECT(lpc_pci), &ich9_smi_ops, pm,\n\n                          \"acpi-smi\", 8);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_SMI_EN, &pm->io_smi);\n\n\n\n    pm->smm_enabled = smm_enabled;\n\n\n\n    pm->enable_tco = true;\n\n    acpi_pm_tco_init(&pm->tco_regs, &pm->io);\n\n\n\n    pm->irq = sci_irq;\n\n    qemu_register_reset(pm_reset, pm);\n\n    pm->powerdown_notifier.notify = pm_powerdown_req;\n\n    qemu_register_powerdown_notifier(&pm->powerdown_notifier);\n\n\n\n    legacy_acpi_cpu_hotplug_init(pci_address_space_io(lpc_pci),\n\n        OBJECT(lpc_pci), &pm->gpe_cpu, ICH9_CPU_HOTPLUG_IO_BASE);\n\n\n\n    if (pm->acpi_memory_hotplug.is_enabled) {\n\n        acpi_memory_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),\n\n                                 &pm->acpi_memory_hotplug);\n\n    }\n\n}\n", "idx": 17072, "_split": "test", "_hash": "d2f2678f23d807132e9c49e1ce7deeff"}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static void handle_sys(DisasContext *s, uint32_t insn, bool isread,\n\n                       unsigned int op0, unsigned int op1, unsigned int op2,\n\n                       unsigned int crn, unsigned int crm, unsigned int rt)\n\n{\n\n    const ARMCPRegInfo *ri;\n\n    TCGv_i64 tcg_rt;\n\n\n\n    ri = get_arm_cp_reginfo(s->cp_regs,\n\n                            ENCODE_AA64_CP_REG(CP_REG_ARM64_SYSREG_CP,\n\n                                               crn, crm, op0, op1, op2));\n\n\n\n    if (!ri) {\n\n        /* Unknown register; this might be a guest error or a QEMU\n\n         * unimplemented feature.\n\n         */\n\n        qemu_log_mask(LOG_UNIMP, \"%s access to unsupported AArch64 \"\n\n                      \"system register op0:%d op1:%d crn:%d crm:%d op2:%d\\n\",\n\n                      isread ? \"read\" : \"write\", op0, op1, crn, crm, op2);\n\n        unallocated_encoding(s);\n\n        return;\n\n    }\n\n\n\n    /* Check access permissions */\n\n    if (!cp_access_ok(s->current_el, ri, isread)) {\n\n        unallocated_encoding(s);\n\n        return;\n\n    }\n\n\n\n    if (ri->accessfn) {\n\n        /* Emit code to perform further access permissions checks at\n\n         * runtime; this may result in an exception.\n\n         */\n\n        TCGv_ptr tmpptr;\n\n        TCGv_i32 tcg_syn;\n\n        uint32_t syndrome;\n\n\n\n        gen_a64_set_pc_im(s->pc - 4);\n\n        tmpptr = tcg_const_ptr(ri);\n\n        syndrome = syn_aa64_sysregtrap(op0, op1, op2, crn, crm, rt, isread);\n\n        tcg_syn = tcg_const_i32(syndrome);\n\n        gen_helper_access_check_cp_reg(cpu_env, tmpptr, tcg_syn);\n\n        tcg_temp_free_ptr(tmpptr);\n\n        tcg_temp_free_i32(tcg_syn);\n\n    }\n\n\n\n    /* Handle special cases first */\n\n    switch (ri->type & ~(ARM_CP_FLAG_MASK & ~ARM_CP_SPECIAL)) {\n\n    case ARM_CP_NOP:\n\n        return;\n\n    case ARM_CP_NZCV:\n\n        tcg_rt = cpu_reg(s, rt);\n\n        if (isread) {\n\n            gen_get_nzcv(tcg_rt);\n\n        } else {\n\n            gen_set_nzcv(tcg_rt);\n\n        }\n\n        return;\n\n    case ARM_CP_CURRENTEL:\n\n        /* Reads as current EL value from pstate, which is\n\n         * guaranteed to be constant by the tb flags.\n\n         */\n\n        tcg_rt = cpu_reg(s, rt);\n\n        tcg_gen_movi_i64(tcg_rt, s->current_el << 2);\n\n        return;\n\n    case ARM_CP_DC_ZVA:\n\n        /* Writes clear the aligned block of memory which rt points into. */\n\n        tcg_rt = cpu_reg(s, rt);\n\n        gen_helper_dc_zva(cpu_env, tcg_rt);\n\n        return;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    if (use_icount && (ri->type & ARM_CP_IO)) {\n\n        gen_io_start();\n\n    }\n\n\n\n    tcg_rt = cpu_reg(s, rt);\n\n\n\n    if (isread) {\n\n        if (ri->type & ARM_CP_CONST) {\n\n            tcg_gen_movi_i64(tcg_rt, ri->resetvalue);\n\n        } else if (ri->readfn) {\n\n            TCGv_ptr tmpptr;\n\n            tmpptr = tcg_const_ptr(ri);\n\n            gen_helper_get_cp_reg64(tcg_rt, cpu_env, tmpptr);\n\n            tcg_temp_free_ptr(tmpptr);\n\n        } else {\n\n            tcg_gen_ld_i64(tcg_rt, cpu_env, ri->fieldoffset);\n\n        }\n\n    } else {\n\n        if (ri->type & ARM_CP_CONST) {\n\n            /* If not forbidden by access permissions, treat as WI */\n\n            return;\n\n        } else if (ri->writefn) {\n\n            TCGv_ptr tmpptr;\n\n            tmpptr = tcg_const_ptr(ri);\n\n            gen_helper_set_cp_reg64(cpu_env, tmpptr, tcg_rt);\n\n            tcg_temp_free_ptr(tmpptr);\n\n        } else {\n\n            tcg_gen_st_i64(tcg_rt, cpu_env, ri->fieldoffset);\n\n        }\n\n    }\n\n\n\n    if (use_icount && (ri->type & ARM_CP_IO)) {\n\n        /* I/O operations must end the TB here (whether read or write) */\n\n        gen_io_end();\n\n        s->is_jmp = DISAS_UPDATE;\n\n    } else if (!isread && !(ri->type & ARM_CP_SUPPRESS_TB_END)) {\n\n        /* We default to ending the TB on a coprocessor register write,\n\n         * but allow this to be suppressed by the register definition\n\n         * (usually only necessary to work around guest bugs).\n\n         */\n\n        s->is_jmp = DISAS_UPDATE;\n\n    }\n\n}\n", "idx": 17082, "_split": "test", "_hash": "c7daf59ad48b31a04c3d831f32fb3b60"}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,\n\n                                            const char *json_string)\n\n{\n\n    return visitor_input_test_init_internal(data, json_string, NULL);\n\n}\n", "idx": 17085, "_split": "test", "_hash": "abe538133e12330b3c54ae83b71994d0"}
{"project": "qemu", "commit_id": "4a19f1eced611e7c3a0fba07d13515cbc73da09f", "target": 0, "func": "static void do_info_version(Monitor *mon)\n\n{\n\n    monitor_printf(mon, \"%s\\n\", QEMU_VERSION);\n\n}\n", "idx": 17092, "_split": "test", "_hash": "4ea66e0c3775de8e2c12109e1e165175"}
{"project": "qemu", "commit_id": "0072d2a9fce4835ab2b9ee70aaca0169fb25fa0c", "target": 1, "func": "static int qcrypto_ivgen_essiv_init(QCryptoIVGen *ivgen,\n\n                                    const uint8_t *key, size_t nkey,\n\n                                    Error **errp)\n\n{\n\n    uint8_t *salt;\n\n    size_t nhash;\n\n    size_t nsalt;\n\n    QCryptoIVGenESSIV *essiv = g_new0(QCryptoIVGenESSIV, 1);\n\n\n\n    /* Not necessarily the same as nkey */\n\n    nsalt = qcrypto_cipher_get_key_len(ivgen->cipher);\n\n\n\n    nhash = qcrypto_hash_digest_len(ivgen->hash);\n\n    /* Salt must be larger of hash size or key size */\n\n    salt = g_new0(uint8_t, MAX(nhash, nsalt));\n\n\n\n    if (qcrypto_hash_bytes(ivgen->hash, (const gchar *)key, nkey,\n\n                           &salt, &nhash,\n\n                           errp) < 0) {\n\n        g_free(essiv);\n\n\n        return -1;\n\n    }\n\n\n\n    /* Now potentially truncate salt to match cipher key len */\n\n    essiv->cipher = qcrypto_cipher_new(ivgen->cipher,\n\n                                       QCRYPTO_CIPHER_MODE_ECB,\n\n                                       salt, MIN(nhash, nsalt),\n\n                                       errp);\n\n    if (!essiv->cipher) {\n\n        g_free(essiv);\n\n\n        return -1;\n\n    }\n\n\n\n\n    ivgen->private = essiv;\n\n\n\n    return 0;\n\n}", "idx": 17101, "_split": "test", "_hash": "35bbeda88655db0a1e6f3eaba9f03a5e"}
{"project": "qemu", "commit_id": "0d6ff71ae3c7ac3a446d295ef71884a05093b37c", "target": 0, "func": "void if_start(Slirp *slirp)\n\n{\n\n    uint64_t now = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n    bool from_batchq, next_from_batchq;\n\n    struct mbuf *ifm, *ifm_next, *ifqt;\n\n\n\n    DEBUG_CALL(\"if_start\");\n\n\n\n    if (slirp->if_start_busy) {\n\n        return;\n\n    }\n\n    slirp->if_start_busy = true;\n\n\n\n    if (slirp->if_fastq.ifq_next != &slirp->if_fastq) {\n\n        ifm_next = slirp->if_fastq.ifq_next;\n\n        next_from_batchq = false;\n\n    } else if (slirp->next_m != &slirp->if_batchq) {\n\n        /* Nothing on fastq, pick up from batchq via next_m */\n\n        ifm_next = slirp->next_m;\n\n        next_from_batchq = true;\n\n    } else {\n\n        ifm_next = NULL;\n\n    }\n\n\n\n    while (ifm_next) {\n\n        ifm = ifm_next;\n\n        from_batchq = next_from_batchq;\n\n\n\n        ifm_next = ifm->ifq_next;\n\n        if (ifm_next == &slirp->if_fastq) {\n\n            /* No more packets in fastq, switch to batchq */\n\n            ifm_next = slirp->next_m;\n\n            next_from_batchq = true;\n\n        }\n\n        if (ifm_next == &slirp->if_batchq) {\n\n            /* end of batchq */\n\n            ifm_next = NULL;\n\n        }\n\n\n\n        /* Try to send packet unless it already expired */\n\n        if (ifm->expiration_date >= now && !if_encap(slirp, ifm)) {\n\n            /* Packet is delayed due to pending ARP resolution */\n\n            continue;\n\n        }\n\n\n\n        if (ifm == slirp->next_m) {\n\n            /* Set which packet to send on next iteration */\n\n            slirp->next_m = ifm->ifq_next;\n\n        }\n\n\n\n        /* Remove it from the queue */\n\n        ifqt = ifm->ifq_prev;\n\n        remque(ifm);\n\n\n\n        /* If there are more packets for this session, re-queue them */\n\n        if (ifm->ifs_next != ifm) {\n\n            struct mbuf *next = ifm->ifs_next;\n\n\n\n            insque(next, ifqt);\n\n            ifs_remque(ifm);\n\n\n\n            if (!from_batchq) {\n\n                /* Next packet in fastq is from the same session */\n\n                ifm_next = next;\n\n                next_from_batchq = false;\n\n            } else if (slirp->next_m == &slirp->if_batchq) {\n\n                /* Set next_m and ifm_next if the session packet is now the\n\n                 * only one on batchq */\n\n                slirp->next_m = ifm_next = next;\n\n            }\n\n        }\n\n\n\n        /* Update so_queued */\n\n        if (ifm->ifq_so && --ifm->ifq_so->so_queued == 0) {\n\n            /* If there's no more queued, reset nqueued */\n\n            ifm->ifq_so->so_nqueued = 0;\n\n        }\n\n\n\n        m_free(ifm);\n\n    }\n\n\n\n    slirp->if_start_busy = false;\n\n}\n", "idx": 17133, "_split": "test", "_hash": "1bb21448060482eb3a6f8af3f4a9762d"}
{"project": "qemu", "commit_id": "926cde5f3e4d2504ed161ed0cb771ac7cad6fd11", "target": 0, "func": "static void handle_ti(ESPState *s)\n\n{\n\n    uint32_t dmalen, minlen;\n\n\n\n    if (s->dma && !s->dma_enabled) {\n\n        s->dma_cb = handle_ti;\n\n        return;\n\n    }\n\n\n\n    dmalen = s->rregs[ESP_TCLO];\n\n    dmalen |= s->rregs[ESP_TCMID] << 8;\n\n    dmalen |= s->rregs[ESP_TCHI] << 16;\n\n    if (dmalen==0) {\n\n      dmalen=0x10000;\n\n    }\n\n    s->dma_counter = dmalen;\n\n\n\n    if (s->do_cmd)\n\n        minlen = (dmalen < 32) ? dmalen : 32;\n\n    else if (s->ti_size < 0)\n\n        minlen = (dmalen < -s->ti_size) ? dmalen : -s->ti_size;\n\n    else\n\n        minlen = (dmalen < s->ti_size) ? dmalen : s->ti_size;\n\n    trace_esp_handle_ti(minlen);\n\n    if (s->dma) {\n\n        s->dma_left = minlen;\n\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n\n        esp_do_dma(s);\n\n    }\n\n    if (s->do_cmd) {\n\n        trace_esp_handle_ti_cmd(s->cmdlen);\n\n        s->ti_size = 0;\n\n        s->cmdlen = 0;\n\n        s->do_cmd = 0;\n\n        do_cmd(s, s->cmdbuf);\n\n    }\n\n}\n", "idx": 17141, "_split": "test", "_hash": "cc08b701de264abc2eff3e5ec6d6d929"}
{"project": "qemu", "commit_id": "6acbe4c6f18e7de00481ff30574262b58526de45", "target": 0, "func": "static void lsi53c895a_register_devices(void)\n\n{\n\n    type_register_static(&lsi_info);\n\n    type_register_static_alias(&lsi_info, \"lsi\");\n\n}\n", "idx": 17152, "_split": "test", "_hash": "c30b8412933c6e26600618626d7bf58e"}
{"project": "qemu", "commit_id": "b074e6220542107afb9fad480a184775be591d2a", "target": 1, "func": "static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,\n\n                                   int size)\n\n{\n\n    /* read data must fit into current buffer */\n\n    assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);\n\n\n\n    /* put byte-stream from character layer into buffer */\n\n    memcpy(&scon->iov[scon->iov_bs], buf, size);\n\n    scon->iov_data_len += size;\n\n    scon->iov_sclp_rest += size;\n\n    scon->iov_bs += size;\n\n    scon->event.event_pending = true;\n\n}\n", "idx": 17172, "_split": "test", "_hash": "3521cd76eef43a820c076c36a07adeb5"}
{"project": "qemu", "commit_id": "d3aea641a4002e0abe940c65d318ef38eda245df", "target": 1, "func": "static void usbredir_do_attach(void *opaque)\n\n{\n\n    USBRedirDevice *dev = opaque;\n\n\n\n    /* In order to work properly with XHCI controllers we need these caps */\n\n    if ((dev->dev.port->speedmask & USB_SPEED_MASK_SUPER) && !(\n\n\n                                    usb_redir_cap_ep_info_max_packet_size) &&\n\n\n\n\n                                    usb_redir_cap_64bits_ids))) {\n\n        ERROR(\"usb-redir-host lacks capabilities needed for use with XHCI\\n\");\n\n        usbredir_reject_device(dev);\n\n        return;\n\n    }\n\n\n\n    if (usb_device_attach(&dev->dev) != 0) {\n\n        WARNING(\"rejecting device due to speed mismatch\\n\");\n\n        usbredir_reject_device(dev);\n\n    }\n\n}", "idx": 17199, "_split": "test", "_hash": "18112d10864b197f29f851064c6823d2"}
{"project": "qemu", "commit_id": "68931a4082812f56657b39168e815c48f0ab0a8c", "target": 0, "func": "static void xtensa_kc705_init(MachineState *machine)\n\n{\n\n    static const LxBoardDesc kc705_board = {\n\n        .flash_base = 0xf0000000,\n\n        .flash_size = 0x08000000,\n\n        .flash_boot_base = 0x06000000,\n\n        .flash_sector_size = 0x20000,\n\n        .sram_size = 0x2000000,\n\n    };\n\n    lx_init(&kc705_board, machine);\n\n}\n", "idx": 17240, "_split": "test", "_hash": "36a47a796736730c8c0672fabbc050b1"}
{"project": "qemu", "commit_id": "8607f5c3072caeebbe0217df28651fffd3a79fd9", "target": 0, "func": "static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,\n\n                               unsigned int len)\n\n{\n\n    unsigned int offset;\n\n    int i;\n\n\n\n    offset = 0;\n\n    for (i = 0; i < elem->in_num; i++) {\n\n        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);\n\n\n\n        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,\n\n                                  elem->in_sg[i].iov_len,\n\n                                  1, size);\n\n\n\n        offset += size;\n\n    }\n\n\n\n    for (i = 0; i < elem->out_num; i++)\n\n        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,\n\n                                  elem->out_sg[i].iov_len,\n\n                                  0, elem->out_sg[i].iov_len);\n\n}\n", "idx": 17242, "_split": "test", "_hash": "196499733d58c826f13a7bc03df8291d"}
{"project": "qemu", "commit_id": "67251a311371c4d22e803f151f47fe817175b6c3", "target": 0, "func": "static int vmdk_reopen_prepare(BDRVReopenState *state,\n\n                               BlockReopenQueue *queue, Error **errp)\n\n{\n\n    BDRVVmdkState *s;\n\n    int ret = -1;\n\n    int i;\n\n    VmdkExtent *e;\n\n\n\n    assert(state != NULL);\n\n    assert(state->bs != NULL);\n\n\n\n    if (queue == NULL) {\n\n        error_setg(errp, \"No reopen queue for VMDK extents\");\n\n        goto exit;\n\n    }\n\n\n\n    s = state->bs->opaque;\n\n\n\n    assert(s != NULL);\n\n\n\n    for (i = 0; i < s->num_extents; i++) {\n\n        e = &s->extents[i];\n\n        if (e->file != state->bs->file) {\n\n            bdrv_reopen_queue(queue, e->file, state->flags);\n\n        }\n\n    }\n\n    ret = 0;\n\n\n\nexit:\n\n    return ret;\n\n}\n", "idx": 17246, "_split": "test", "_hash": "bebfada74ccf3bda0f4c9a39c24cfe11"}
{"project": "qemu", "commit_id": "bec1631100323fac0900aea71043d5c4e22fc2fa", "target": 0, "func": "static inline void tcg_out_goto_label(TCGContext *s, int label_index)\n\n{\n\n    TCGLabel *l = &s->labels[label_index];\n\n\n\n    if (!l->has_value) {\n\n        tcg_out_reloc(s, s->code_ptr, R_AARCH64_JUMP26, label_index, 0);\n\n        tcg_out_goto_noaddr(s);\n\n    } else {\n\n        tcg_out_goto(s, l->u.value_ptr);\n\n    }\n\n}\n", "idx": 17258, "_split": "test", "_hash": "ad19c846166053eef1ff775635c89d82"}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void ac97_map (PCIDevice *pci_dev, int region_num,\n\n                      uint32_t addr, uint32_t size, int type)\n\n{\n\n    PCIAC97LinkState *d = (PCIAC97LinkState *) pci_dev;\n\n    AC97LinkState *s = &d->ac97;\n\n\n\n    if (!region_num) {\n\n        s->base[0] = addr;\n\n        register_ioport_read (addr, 256 * 1, 1, nam_readb, d);\n\n        register_ioport_read (addr, 256 * 2, 2, nam_readw, d);\n\n        register_ioport_read (addr, 256 * 4, 4, nam_readl, d);\n\n        register_ioport_write (addr, 256 * 1, 1, nam_writeb, d);\n\n        register_ioport_write (addr, 256 * 2, 2, nam_writew, d);\n\n        register_ioport_write (addr, 256 * 4, 4, nam_writel, d);\n\n    }\n\n    else {\n\n        s->base[1] = addr;\n\n        register_ioport_read (addr, 64 * 1, 1, nabm_readb, d);\n\n        register_ioport_read (addr, 64 * 2, 2, nabm_readw, d);\n\n        register_ioport_read (addr, 64 * 4, 4, nabm_readl, d);\n\n        register_ioport_write (addr, 64 * 1, 1, nabm_writeb, d);\n\n        register_ioport_write (addr, 64 * 2, 2, nabm_writew, d);\n\n        register_ioport_write (addr, 64 * 4, 4, nabm_writel, d);\n\n    }\n\n}\n", "idx": 17266, "_split": "test", "_hash": "a844d859d69d50b376ee2ce393bdcced"}
{"project": "qemu", "commit_id": "ef1e1e0782e99c9dcf2b35e5310cdd8ca9211374", "target": 0, "func": "void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd,\n\n                        void *opaque)\n\n{\n\n    SaveStateEntry *se, *new_se;\n\n\n\n    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {\n\n        if (se->vmsd == vmsd && se->opaque == opaque) {\n\n            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);\n\n            if (se->compat) {\n\n                g_free(se->compat);\n\n            }\n\n            g_free(se);\n\n        }\n\n    }\n\n}\n", "idx": 17267, "_split": "test", "_hash": "36373e53239774dfec9fe425fdd51813"}
{"project": "qemu", "commit_id": "47d3df2387ed6927732584ffa4159c26d9f4dee8", "target": 0, "func": "static int xenfb_send_motion(struct XenInput *xenfb,\n\n\t\t\t     int rel_x, int rel_y, int rel_z)\n\n{\n\n    union xenkbd_in_event event;\n\n\n\n    memset(&event, 0, XENKBD_IN_EVENT_SIZE);\n\n    event.type = XENKBD_TYPE_MOTION;\n\n    event.motion.rel_x = rel_x;\n\n    event.motion.rel_y = rel_y;\n\n#if __XEN_LATEST_INTERFACE_VERSION__ >= 0x00030207\n\n    event.motion.rel_z = rel_z;\n\n#endif\n\n\n\n    return xenfb_kbd_event(xenfb, &event);\n\n}\n", "idx": 17274, "_split": "test", "_hash": "746e1fb6f8a7534905468c738daa5de7"}
{"project": "qemu", "commit_id": "eaf136f9a21e02a2f55346e44d2d88df37b2cde3", "target": 0, "func": "static int slirp_socket_load(QEMUFile *f, struct socket *so)\n\n{\n\n    if (tcp_attach(so) < 0)\n\n        return -ENOMEM;\n\n\n\n    so->so_urgc = qemu_get_be32(f);\n\n    so->so_ffamily = qemu_get_be16(f);\n\n    switch (so->so_ffamily) {\n\n    case AF_INET:\n\n        so->so_faddr.s_addr = qemu_get_be32(f);\n\n        so->so_fport = qemu_get_be16(f);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to restore so_faddr and so_lport\\n\");\n\n    }\n\n    so->so_lfamily = qemu_get_be16(f);\n\n    switch (so->so_lfamily) {\n\n    case AF_INET:\n\n        so->so_laddr.s_addr = qemu_get_be32(f);\n\n        so->so_lport = qemu_get_be16(f);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to restore so_laddr and so_lport\\n\");\n\n    }\n\n    so->so_iptos = qemu_get_byte(f);\n\n    so->so_emu = qemu_get_byte(f);\n\n    so->so_type = qemu_get_byte(f);\n\n    so->so_state = qemu_get_be32(f);\n\n    if (slirp_sbuf_load(f, &so->so_rcv) < 0)\n\n        return -ENOMEM;\n\n    if (slirp_sbuf_load(f, &so->so_snd) < 0)\n\n        return -ENOMEM;\n\n    slirp_tcp_load(f, so->so_tcpcb);\n\n\n\n    return 0;\n\n}\n", "idx": 17301, "_split": "test", "_hash": "e03e48299b630d1990214aece1920eaa"}
{"project": "qemu", "commit_id": "22f2e344748370b2e13888ba1057ebea2579970c", "target": 0, "func": "static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)\n\n{\n\n    int pos = 0;\n\n\n\n    pos += snprintf(dest+pos, len-pos, \"name \\\"%s\\\", bus %s\",\n\n                    info->name, info->bus_info->name);\n\n    if (info->alias)\n\n        pos += snprintf(dest+pos, len-pos, \", alias \\\"%s\\\"\", info->alias);\n\n    if (info->desc)\n\n        pos += snprintf(dest+pos, len-pos, \", desc \\\"%s\\\"\", info->desc);\n\n    if (info->no_user)\n\n        pos += snprintf(dest+pos, len-pos, \", no-user\");\n\n    return pos;\n\n}\n", "idx": 17307, "_split": "test", "_hash": "87019ca6968a9f887324cf1ed9573f73"}
{"project": "qemu", "commit_id": "e514fc7e1231c6d95011e448e6c626f2bb6f3cd8", "target": 0, "func": "e1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,\n\n                             const E1000E_RxRing *rxr,\n\n                             const E1000E_RSSInfo *rss_info)\n\n{\n\n    PCIDevice *d = core->owner;\n\n    dma_addr_t base;\n\n    uint8_t desc[E1000_MAX_RX_DESC_LEN];\n\n    size_t desc_size;\n\n    size_t desc_offset = 0;\n\n    size_t iov_ofs = 0;\n\n\n\n    struct iovec *iov = net_rx_pkt_get_iovec(pkt);\n\n    size_t size = net_rx_pkt_get_total_len(pkt);\n\n    size_t total_size = size + e1000x_fcs_len(core->mac);\n\n    const E1000E_RingInfo *rxi;\n\n    size_t ps_hdr_len = 0;\n\n    bool do_ps = e1000e_do_ps(core, pkt, &ps_hdr_len);\n\n\n\n    rxi = rxr->i;\n\n\n\n    do {\n\n        hwaddr ba[MAX_PS_BUFFERS];\n\n        e1000e_ba_state bastate = { { 0 } };\n\n        bool is_last = false;\n\n        bool is_first = true;\n\n\n\n        desc_size = total_size - desc_offset;\n\n\n\n        if (desc_size > core->rx_desc_buf_size) {\n\n            desc_size = core->rx_desc_buf_size;\n\n        }\n\n\n\n        base = e1000e_ring_head_descr(core, rxi);\n\n\n\n        pci_dma_read(d, base, &desc, core->rx_desc_len);\n\n\n\n        trace_e1000e_rx_descr(rxi->idx, base, core->rx_desc_len);\n\n\n\n        e1000e_read_rx_descr(core, desc, &ba);\n\n\n\n        if (ba[0]) {\n\n            if (desc_offset < size) {\n\n                static const uint32_t fcs_pad;\n\n                size_t iov_copy;\n\n                size_t copy_size = size - desc_offset;\n\n                if (copy_size > core->rx_desc_buf_size) {\n\n                    copy_size = core->rx_desc_buf_size;\n\n                }\n\n\n\n                /* For PS mode copy the packet header first */\n\n                if (do_ps) {\n\n                    if (is_first) {\n\n                        size_t ps_hdr_copied = 0;\n\n                        do {\n\n                            iov_copy = MIN(ps_hdr_len - ps_hdr_copied,\n\n                                           iov->iov_len - iov_ofs);\n\n\n\n                            e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n\n                                                      iov->iov_base, iov_copy);\n\n\n\n                            copy_size -= iov_copy;\n\n                            ps_hdr_copied += iov_copy;\n\n\n\n                            iov_ofs += iov_copy;\n\n                            if (iov_ofs == iov->iov_len) {\n\n                                iov++;\n\n                                iov_ofs = 0;\n\n                            }\n\n                        } while (ps_hdr_copied < ps_hdr_len);\n\n\n\n                        is_first = false;\n\n                    } else {\n\n                        /* Leave buffer 0 of each descriptor except first */\n\n                        /* empty as per spec 7.1.5.1                      */\n\n                        e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n\n                                                       NULL, 0);\n\n                    }\n\n                }\n\n\n\n                /* Copy packet payload */\n\n                while (copy_size) {\n\n                    iov_copy = MIN(copy_size, iov->iov_len - iov_ofs);\n\n\n\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n\n                                            iov->iov_base + iov_ofs, iov_copy);\n\n\n\n                    copy_size -= iov_copy;\n\n                    iov_ofs += iov_copy;\n\n                    if (iov_ofs == iov->iov_len) {\n\n                        iov++;\n\n                        iov_ofs = 0;\n\n                    }\n\n                }\n\n\n\n                if (desc_offset + desc_size >= total_size) {\n\n                    /* Simulate FCS checksum presence in the last descriptor */\n\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n\n                          (const char *) &fcs_pad, e1000x_fcs_len(core->mac));\n\n                }\n\n            }\n\n            desc_offset += desc_size;\n\n            if (desc_offset >= total_size) {\n\n                is_last = true;\n\n            }\n\n        } else { /* as per intel docs; skip descriptors with null buf addr */\n\n            trace_e1000e_rx_null_descriptor();\n\n        }\n\n\n\n        e1000e_write_rx_descr(core, desc, is_last ? core->rx_pkt : NULL,\n\n                           rss_info, do_ps ? ps_hdr_len : 0, &bastate.written);\n\n        pci_dma_write(d, base, &desc, core->rx_desc_len);\n\n\n\n        e1000e_ring_advance(core, rxi,\n\n                            core->rx_desc_len / E1000_MIN_RX_DESC_LEN);\n\n\n\n    } while (desc_offset < total_size);\n\n\n\n    e1000e_update_rx_stats(core, size, total_size);\n\n}\n", "idx": 17314, "_split": "test", "_hash": "e54725e11b641cbbc715382c530acf4f"}
{"project": "qemu", "commit_id": "026aeffcb4752054830ba203020ed6eb05bcaba8", "target": 0, "func": "static int cirrus_do_copy(CirrusVGAState *s, int dst, int src, int w, int h)\n\n{\n\n    int sx = 0, sy = 0;\n\n    int dx = 0, dy = 0;\n\n    int depth = 0;\n\n    int notify = 0;\n\n\n\n    /* make sure to only copy if it's a plain copy ROP */\n\n    if (*s->cirrus_rop == cirrus_bitblt_rop_fwd_src ||\n\n        *s->cirrus_rop == cirrus_bitblt_rop_bkwd_src) {\n\n\n\n        int width, height;\n\n\n\n        depth = s->vga.get_bpp(&s->vga) / 8;\n\n        if (!depth) {\n\n            return 0;\n\n        }\n\n        s->vga.get_resolution(&s->vga, &width, &height);\n\n\n\n        /* extra x, y */\n\n        sx = (src % ABS(s->cirrus_blt_srcpitch)) / depth;\n\n        sy = (src / ABS(s->cirrus_blt_srcpitch));\n\n        dx = (dst % ABS(s->cirrus_blt_dstpitch)) / depth;\n\n        dy = (dst / ABS(s->cirrus_blt_dstpitch));\n\n\n\n        /* normalize width */\n\n        w /= depth;\n\n\n\n        /* if we're doing a backward copy, we have to adjust\n\n           our x/y to be the upper left corner (instead of the lower\n\n           right corner) */\n\n        if (s->cirrus_blt_dstpitch < 0) {\n\n            sx -= (s->cirrus_blt_width / depth) - 1;\n\n            dx -= (s->cirrus_blt_width / depth) - 1;\n\n            sy -= s->cirrus_blt_height - 1;\n\n            dy -= s->cirrus_blt_height - 1;\n\n        }\n\n\n\n        /* are we in the visible portion of memory? */\n\n        if (sx >= 0 && sy >= 0 && dx >= 0 && dy >= 0 &&\n\n            (sx + w) <= width && (sy + h) <= height &&\n\n            (dx + w) <= width && (dy + h) <= height) {\n\n            notify = 1;\n\n        }\n\n    }\n\n\n\n    (*s->cirrus_rop) (s, s->vga.vram_ptr + s->cirrus_blt_dstaddr,\n\n                      s->vga.vram_ptr + s->cirrus_blt_srcaddr,\n\n\t\t      s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\n\t\t      s->cirrus_blt_width, s->cirrus_blt_height);\n\n\n\n    if (notify) {\n\n        dpy_gfx_update(s->vga.con, dx, dy,\n\n                       s->cirrus_blt_width / depth,\n\n                       s->cirrus_blt_height);\n\n    }\n\n\n\n    /* we don't have to notify the display that this portion has\n\n       changed since qemu_console_copy implies this */\n\n\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n\t\t\t\ts->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n\t\t\t\ts->cirrus_blt_height);\n\n\n\n    return 1;\n\n}\n", "idx": 17325, "_split": "test", "_hash": "98e76ee4111d23b282fc917657ed66c5"}
{"project": "qemu", "commit_id": "8b3b720620a1137a1b794fc3ed64734236f94e06", "target": 1, "func": "static int write_l1_entry(BlockDriverState *bs, int l1_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t buf[L1_ENTRIES_PER_SECTOR];\n\n    int l1_start_index;\n\n    int i, ret;\n\n\n\n    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);\n\n    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {\n\n        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);\n\n    ret = bdrv_pwrite(bs->file, s->l1_table_offset + 8 * l1_start_index,\n\n        buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 17328, "_split": "test", "_hash": "34a53638fd042116a1d80574257345c4"}
{"project": "qemu", "commit_id": "2ce68e4cf5be9b5176a3c3c372948d6340724d2d", "target": 1, "func": "int vhost_dev_init(struct vhost_dev *hdev, void *opaque,\n                   VhostBackendType backend_type)\n{\n    uint64_t features;\n    int i, r;\n    if (vhost_set_backend_type(hdev, backend_type) < 0) {\n        close((uintptr_t)opaque);\n        return -1;\n    }\n    if (hdev->vhost_ops->vhost_backend_init(hdev, opaque) < 0) {\n        close((uintptr_t)opaque);\n        return -errno;\n    }\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_OWNER, NULL);\n    if (r < 0) {\n        goto fail;\n    }\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_GET_FEATURES, &features);\n    if (r < 0) {\n        goto fail;\n    }\n    for (i = 0; i < hdev->nvqs; ++i) {\n        r = vhost_virtqueue_init(hdev, hdev->vqs + i, hdev->vq_index + i);\n        if (r < 0) {\n            goto fail_vq;\n        }\n    }\n    hdev->features = features;\n    hdev->memory_listener = (MemoryListener) {\n        .begin = vhost_begin,\n        .commit = vhost_commit,\n        .region_add = vhost_region_add,\n        .region_del = vhost_region_del,\n        .region_nop = vhost_region_nop,\n        .log_start = vhost_log_start,\n        .log_stop = vhost_log_stop,\n        .log_sync = vhost_log_sync,\n        .log_global_start = vhost_log_global_start,\n        .log_global_stop = vhost_log_global_stop,\n        .eventfd_add = vhost_eventfd_add,\n        .eventfd_del = vhost_eventfd_del,\n        .priority = 10\n    };\n    hdev->migration_blocker = NULL;\n    if (!(hdev->features & (0x1ULL << VHOST_F_LOG_ALL))) {\n        error_setg(&hdev->migration_blocker,\n                   \"Migration disabled: vhost lacks VHOST_F_LOG_ALL feature.\");\n        migrate_add_blocker(hdev->migration_blocker);\n    }\n    hdev->mem = g_malloc0(offsetof(struct vhost_memory, regions));\n    hdev->n_mem_sections = 0;\n    hdev->mem_sections = NULL;\n    hdev->log = NULL;\n    hdev->log_size = 0;\n    hdev->log_enabled = false;\n    hdev->started = false;\n    hdev->memory_changed = false;\n    memory_listener_register(&hdev->memory_listener, &address_space_memory);\n    return 0;\nfail_vq:\n    while (--i >= 0) {\n        vhost_virtqueue_cleanup(hdev->vqs + i);\n    }\nfail:\n    r = -errno;\n    hdev->vhost_ops->vhost_backend_cleanup(hdev);\n    QLIST_REMOVE(hdev, entry);\n    return r;\n}", "idx": 17329, "_split": "test", "_hash": "814261caf8a56105ed78de6eef92fb9b"}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "int bdrv_read(BlockDriverState *bs, int64_t sector_num,\n\n              uint8_t *buf, int nb_sectors)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n\n\n\n\n    if (drv->bdrv_pread) {\n\n        int ret, len;\n\n        len = nb_sectors * 512;\n\n        ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);\n\n        if (ret < 0)\n\n            return ret;\n\n        else if (ret != len)\n\n            return -EINVAL;\n\n        else {\n\n\t    bs->rd_bytes += (unsigned) len;\n\n\t    bs->rd_ops ++;\n\n            return 0;\n\n\t}\n\n    } else {\n\n        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);\n\n    }\n\n}", "idx": 17337, "_split": "test", "_hash": "a96633df20a7020ff853fe9168dcfc6b"}
{"project": "qemu", "commit_id": "fb506e701e9bafa3e0685747c1c98962c52d1962", "target": 1, "func": "static bool vtd_decide_config(IntelIOMMUState *s, Error **errp)\n\n{\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(s);\n\n\n\n    /* Currently Intel IOMMU IR only support \"kernel-irqchip={off|split}\" */\n\n    if (x86_iommu->intr_supported && kvm_irqchip_in_kernel() &&\n\n        !kvm_irqchip_is_split()) {\n\n        error_setg(errp, \"Intel Interrupt Remapping cannot work with \"\n\n                         \"kernel-irqchip=on, please use 'split|off'.\");\n\n        return false;\n\n    }\n\n    if (s->intr_eim == ON_OFF_AUTO_ON && !x86_iommu->intr_supported) {\n\n        error_setg(errp, \"eim=on cannot be selected without intremap=on\");\n\n        return false;\n\n    }\n\n\n\n    if (s->intr_eim == ON_OFF_AUTO_AUTO) {\n\n        s->intr_eim = x86_iommu->intr_supported ?\n\n                                              ON_OFF_AUTO_ON : ON_OFF_AUTO_OFF;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 17362, "_split": "test", "_hash": "cb20c04b0bce6082c6b7ae902b88ea61"}
{"project": "qemu", "commit_id": "5706db1deb061ee9affdcea81e59c4c2cad7c41e", "target": 1, "func": "static int no_init_in (HWVoiceIn *hw, struct audsettings *as)\n\n{\n\n    audio_pcm_init_info (&hw->info, as);\n\n    hw->samples = 1024;\n\n    return 0;\n\n}\n", "idx": 17370, "_split": "test", "_hash": "ac2aa7a9938a3f0832f84fd3f8a786c6"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int block_save_complete(QEMUFile *f, void *opaque)\n\n{\n\n    int ret;\n\n\n\n    DPRINTF(\"Enter save live complete submitted %d transferred %d\\n\",\n\n            block_mig_state.submitted, block_mig_state.transferred);\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    blk_mig_reset_dirty_cursor();\n\n\n\n    /* we know for sure that save bulk is completed and\n\n       all async read completed */\n\n    blk_mig_lock();\n\n    assert(block_mig_state.submitted == 0);\n\n    blk_mig_unlock();\n\n\n\n    do {\n\n        ret = blk_mig_save_dirty_block(f, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    } while (ret == 0);\n\n\n\n    /* report completion */\n\n    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);\n\n\n\n    DPRINTF(\"Block migration completed\\n\");\n\n\n\n    qemu_put_be64(f, BLK_MIG_FLAG_EOS);\n\n\n\n    blk_mig_cleanup();\n\n    return 0;\n\n}\n", "idx": 17411, "_split": "test", "_hash": "6c86a6f0e906a3b67bb796cde67da34b"}
{"project": "qemu", "commit_id": "f897bf751fbd95e4015b95d202c706548586813a", "target": 1, "func": "int vring_pop(VirtIODevice *vdev, Vring *vring,\n\n              VirtQueueElement **p_elem)\n\n{\n\n    struct vring_desc desc;\n\n    unsigned int i, head, found = 0, num = vring->vr.num;\n\n    uint16_t avail_idx, last_avail_idx;\n\n    VirtQueueElement *elem = NULL;\n\n    int ret;\n\n\n\n    /* If there was a fatal error then refuse operation */\n\n    if (vring->broken) {\n\n        ret = -EFAULT;\n\n        goto out;\n\n    }\n\n\n\n    /* Check it isn't doing very strange things with descriptor numbers. */\n\n    last_avail_idx = vring->last_avail_idx;\n\n    avail_idx = vring->vr.avail->idx;\n\n    barrier(); /* load indices now and not again later */\n\n\n\n    if (unlikely((uint16_t)(avail_idx - last_avail_idx) > num)) {\n\n        error_report(\"Guest moved used index from %u to %u\",\n\n                     last_avail_idx, avail_idx);\n\n        ret = -EFAULT;\n\n        goto out;\n\n    }\n\n\n\n    /* If there's nothing new since last we looked. */\n\n    if (avail_idx == last_avail_idx) {\n\n        ret = -EAGAIN;\n\n        goto out;\n\n    }\n\n\n\n    /* Only get avail ring entries after they have been exposed by guest. */\n\n    smp_rmb();\n\n\n\n    /* Grab the next descriptor number they're advertising, and increment\n\n     * the index we've seen. */\n\n    head = vring->vr.avail->ring[last_avail_idx % num];\n\n\n\n    elem = g_slice_new(VirtQueueElement);\n\n    elem->index = head;\n\n    elem->in_num = elem->out_num = 0;\n\n    \n\n    /* If their number is silly, that's an error. */\n\n    if (unlikely(head >= num)) {\n\n        error_report(\"Guest says index %u > %u is available\", head, num);\n\n        ret = -EFAULT;\n\n        goto out;\n\n    }\n\n\n\n    if (vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\n        vring_avail_event(&vring->vr) = vring->vr.avail->idx;\n\n    }\n\n\n\n    i = head;\n\n    do {\n\n        if (unlikely(i >= num)) {\n\n            error_report(\"Desc index is %u > %u, head = %u\", i, num, head);\n\n            ret = -EFAULT;\n\n            goto out;\n\n        }\n\n        if (unlikely(++found > num)) {\n\n            error_report(\"Loop detected: last one at %u vq size %u head %u\",\n\n                         i, num, head);\n\n            ret = -EFAULT;\n\n            goto out;\n\n        }\n\n        desc = vring->vr.desc[i];\n\n\n\n        /* Ensure descriptor is loaded before accessing fields */\n\n        barrier();\n\n\n\n        if (desc.flags & VRING_DESC_F_INDIRECT) {\n\n            ret = get_indirect(vring, elem, &desc);\n\n            if (ret < 0) {\n\n                goto out;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        ret = get_desc(vring, elem, &desc);\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n\n\n        i = desc.next;\n\n    } while (desc.flags & VRING_DESC_F_NEXT);\n\n\n\n    /* On success, increment avail index. */\n\n    vring->last_avail_idx++;\n\n    *p_elem = elem;\n\n    return head;\n\n\n\nout:\n\n    assert(ret < 0);\n\n    if (ret == -EFAULT) {\n\n        vring->broken = true;\n\n    }\n\n    if (elem) {\n\n        vring_unmap_element(elem);\n\n        g_slice_free(VirtQueueElement, elem);\n\n    }\n\n    *p_elem = NULL;\n\n    return ret;\n\n}\n", "idx": 17428, "_split": "test", "_hash": "7055e6362d966ffb22c882f1207a155e"}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)\n\n{\n\n    uintptr_t addr = (uintptr_t)data;\n\n\n\n    g_assert(addr >= QPCI_PIO_LIMIT);\n\n    dev->bus->memread(dev->bus, addr, buf, len);\n\n}\n", "idx": 17449, "_split": "test", "_hash": "fc64cac75c5c405ebad1b96a6f45b5d2"}
{"project": "qemu", "commit_id": "6e5d97d01d9da6f295f9888d4b34e29fd737861a", "target": 1, "func": "void qemu_aio_flush(void)\n\n{\n\n    AioHandler *node;\n\n    int ret;\n\n\n\n    do {\n\n        ret = 0;\n\n\n\n\t/*\n\n\t * If there are pending emulated aio start them now so flush\n\n\t * will be able to return 1.\n\n\t */\n\n        qemu_aio_wait();\n\n\n\n        LIST_FOREACH(node, &aio_handlers, node) {\n\n            ret |= node->io_flush(node->opaque);\n\n        }\n\n    } while (ret > 0);\n\n}\n", "idx": 17482, "_split": "test", "_hash": "bf91f827b0ce9275b5c5f4b33db9ab9f"}
{"project": "qemu", "commit_id": "dbb7405d8caad0814ceddd568cb49f163a847561", "target": 1, "func": "static int xen_platform_initfn(PCIDevice *dev)\n{\n    PCIXenPlatformState *d = XEN_PLATFORM(dev);\n    uint8_t *pci_conf;\n    pci_conf = dev->config;\n    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n    pci_config_set_prog_interface(pci_conf, 0);\n    pci_conf[PCI_INTERRUPT_PIN] = 1;\n    platform_ioport_bar_setup(d);\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &d->bar);\n    /* reserve 16MB mmio address for share memory*/\n    platform_mmio_setup(d);\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_MEM_PREFETCH,\n                     &d->mmio_bar);\n    platform_fixed_ioport_init(d);\n    return 0;\n}", "idx": 17518, "_split": "test", "_hash": "e1be63ffdd474c15ca5f189425cc8b97"}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void coroutine_fn c1_fn(void *opaque)\n\n{\n\n    Coroutine *c2 = opaque;\n\n    qemu_coroutine_enter(c2, NULL);\n\n}\n", "idx": 17548, "_split": "test", "_hash": "1f0fa0a02bef4cdd4352372d0e7c237e"}
{"project": "qemu", "commit_id": "9217e26f43df4aab7deaea35b21caacc1f1f854b", "target": 1, "func": "static int write_target_commit(BlockDriverState *bs, int64_t sector_num,\n\n\tconst uint8_t* buffer, int nb_sectors) {\n\n    BDRVVVFATState* s = bs->opaque;\n\n    return try_commit(s);\n\n}\n", "idx": 17553, "_split": "test", "_hash": "5dff93a80d45a68f25681752c5b7b71a"}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)\n\n{\n\n    unsigned i;\n\n\n\n    /* Check that there is free space left in a buffer */\n\n    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {\n\n        ERRPRINT(\"Can't write to data buffer: buffer full\\n\");\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < size; i++) {\n\n        s->fifo_buffer[s->data_count] = value & 0xFF;\n\n        s->data_count++;\n\n        value >>= 8;\n\n        if (s->data_count >= (s->blksize & 0x0fff)) {\n\n            DPRINT_L2(\"write buffer filled with %u bytes of data\\n\",\n\n                    s->data_count);\n\n            s->data_count = 0;\n\n            s->prnsts &= ~SDHC_SPACE_AVAILABLE;\n\n            if (s->prnsts & SDHC_DOING_WRITE) {\n\n                SDHCI_GET_CLASS(s)->write_block_to_card(s);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 17576, "_split": "test", "_hash": "c6971e7717eddbb7b3c2192fd696c06f"}
{"project": "qemu", "commit_id": "0919ac787641db11024912651f3bc5764d4f1286", "target": 0, "func": "static uint64_t omap_ulpd_pm_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque;\n\n    uint16_t ret;\n\n\n\n    if (size != 2) {\n\n        return omap_badwidth_read16(opaque, addr);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x14:\t/* IT_STATUS */\n\n        ret = s->ulpd_pm_regs[addr >> 2];\n\n        s->ulpd_pm_regs[addr >> 2] = 0;\n\n        qemu_irq_lower(s->irq[1][OMAP_INT_GAUGE_32K]);\n\n        return ret;\n\n\n\n    case 0x18:\t/* Reserved */\n\n    case 0x1c:\t/* Reserved */\n\n    case 0x20:\t/* Reserved */\n\n    case 0x28:\t/* Reserved */\n\n    case 0x2c:\t/* Reserved */\n\n        OMAP_BAD_REG(addr);\n\n    case 0x00:\t/* COUNTER_32_LSB */\n\n    case 0x04:\t/* COUNTER_32_MSB */\n\n    case 0x08:\t/* COUNTER_HIGH_FREQ_LSB */\n\n    case 0x0c:\t/* COUNTER_HIGH_FREQ_MSB */\n\n    case 0x10:\t/* GAUGING_CTRL */\n\n    case 0x24:\t/* SETUP_ANALOG_CELL3_ULPD1 */\n\n    case 0x30:\t/* CLOCK_CTRL */\n\n    case 0x34:\t/* SOFT_REQ */\n\n    case 0x38:\t/* COUNTER_32_FIQ */\n\n    case 0x3c:\t/* DPLL_CTRL */\n\n    case 0x40:\t/* STATUS_REQ */\n\n        /* XXX: check clk::usecount state for every clock */\n\n    case 0x48:\t/* LOCL_TIME */\n\n    case 0x4c:\t/* APLL_CTRL */\n\n    case 0x50:\t/* POWER_CTRL */\n\n        return s->ulpd_pm_regs[addr >> 2];\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 17581, "_split": "test", "_hash": "f08ade521eb6ecfbe7b25e587e7efdbc"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int milkymist_memcard_init(SysBusDevice *dev)\n\n{\n\n    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);\n\n    DriveInfo *dinfo;\n\n    BlockDriverState *bs;\n\n\n\n    dinfo = drive_get_next(IF_SD);\n\n    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;\n\n    s->card = sd_init(bs, false);\n\n    if (s->card == NULL) {\n\n        return -1;\n\n    }\n\n\n\n    s->enabled = bs && bdrv_is_inserted(bs);\n\n\n\n    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,\n\n            \"milkymist-memcard\", R_MAX * 4);\n\n    sysbus_init_mmio(dev, &s->regs_region);\n\n\n\n    return 0;\n\n}\n", "idx": 17587, "_split": "test", "_hash": "2da71e96b816d0352445e822a98d4335"}
{"project": "qemu", "commit_id": "3b098d56979d2f7fd707c5be85555d114353a28d", "target": 0, "func": "static void visitor_output_setup_internal(TestOutputVisitorData *data,\n\n                                          bool human)\n\n{\n\n    data->human = human;\n\n    data->sov = string_output_visitor_new(human);\n\n    g_assert(data->sov);\n\n    data->ov = string_output_get_visitor(data->sov);\n\n    g_assert(data->ov);\n\n}\n", "idx": 17596, "_split": "test", "_hash": "58273f92141927067cb073fc70840c87"}
{"project": "qemu", "commit_id": "b2caa3b82edca29ccb5e7d6311ffcf841b9b7786", "target": 1, "func": "_eth_get_rss_ex_src_addr(const struct iovec *pkt, int pkt_frags,\n\n                        size_t dsthdr_offset,\n\n                        struct ip6_ext_hdr *ext_hdr,\n\n                        struct in6_address *src_addr)\n\n{\n\n    size_t bytes_left = (ext_hdr->ip6r_len + 1) * 8 - sizeof(*ext_hdr);\n\n    struct ip6_option_hdr opthdr;\n\n    size_t opt_offset = dsthdr_offset + sizeof(*ext_hdr);\n\n\n\n    while (bytes_left > sizeof(opthdr)) {\n\n        size_t input_size = iov_size(pkt, pkt_frags);\n\n        size_t bytes_read, optlen;\n\n\n\n        if (input_size < opt_offset) {\n\n            return false;\n\n        }\n\n\n\n        bytes_read = iov_to_buf(pkt, pkt_frags, opt_offset,\n\n                                &opthdr, sizeof(opthdr));\n\n\n\n        if (bytes_read != sizeof(opthdr)) {\n\n            return false;\n\n        }\n\n\n\n        optlen = (opthdr.type == IP6_OPT_PAD1) ? 1\n\n                                               : (opthdr.len + sizeof(opthdr));\n\n\n\n        if (optlen > bytes_left) {\n\n            return false;\n\n        }\n\n\n\n        if (opthdr.type == IP6_OPT_HOME) {\n\n            size_t input_size = iov_size(pkt, pkt_frags);\n\n\n\n            if (input_size < opt_offset + sizeof(opthdr)) {\n\n                return false;\n\n            }\n\n\n\n            bytes_read = iov_to_buf(pkt, pkt_frags,\n\n                                    opt_offset + sizeof(opthdr),\n\n                                    src_addr, sizeof(*src_addr));\n\n\n\n            return bytes_read == sizeof(src_addr);\n\n        }\n\n\n\n        opt_offset += optlen;\n\n        bytes_left -= optlen;\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 17611, "_split": "test", "_hash": "ed18585e25532bc367e083f032ee8512"}
{"project": "qemu", "commit_id": "713d9675e0e31c627d08b6a33d3a92e4b8505b40", "target": 0, "func": "static void inc_refcounts(BlockDriverState *bs,\n\n                          BdrvCheckResult *res,\n\n                          uint16_t *refcount_table,\n\n                          int refcount_table_size,\n\n                          int64_t offset, int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t start, last, cluster_offset, k;\n\n\n\n    if (size <= 0)\n\n        return;\n\n\n\n    start = start_of_cluster(s, offset);\n\n    last = start_of_cluster(s, offset + size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size) {\n\n        k = cluster_offset >> s->cluster_bits;\n\n        if (k >= refcount_table_size) {\n\n            fprintf(stderr, \"Warning: cluster offset=0x%\" PRIx64 \" is after \"\n\n                \"the end of the image file, can't properly check refcounts.\\n\",\n\n                cluster_offset);\n\n            res->check_errors++;\n\n        } else {\n\n            if (++refcount_table[k] == 0) {\n\n                fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n\n                    \"\\n\", cluster_offset);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 17627, "_split": "test", "_hash": "24f5fe2e6368a987824df7e905e429a7"}
{"project": "qemu", "commit_id": "733f0b02c80c3a7106d8327a83948ab68db10ea7", "target": 0, "func": "void stw_phys(target_phys_addr_t addr, uint32_t val)\n\n{\n\n    uint16_t v = tswap16(val);\n\n    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);\n\n}\n", "idx": 17641, "_split": "test", "_hash": "bd8d81f164e37a1e5a96b88ea8b072cf"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_branch(DisasContext *ctx, int insn_bytes)\n\n{\n\n    if (ctx->hflags & MIPS_HFLAG_BMASK) {\n\n        int proc_hflags = ctx->hflags & MIPS_HFLAG_BMASK;\n\n        /* Branches completion */\n\n        ctx->hflags &= ~MIPS_HFLAG_BMASK;\n\n        ctx->bstate = BS_BRANCH;\n\n        save_cpu_state(ctx, 0);\n\n        /* FIXME: Need to clear can_do_io.  */\n\n        switch (proc_hflags & MIPS_HFLAG_BMASK_BASE) {\n\n        case MIPS_HFLAG_FBNSLOT:\n\n            MIPS_DEBUG(\"forbidden slot\");\n\n            gen_goto_tb(ctx, 0, ctx->pc + insn_bytes);\n\n            break;\n\n        case MIPS_HFLAG_B:\n\n            /* unconditional branch */\n\n            MIPS_DEBUG(\"unconditional branch\");\n\n            if (proc_hflags & MIPS_HFLAG_BX) {\n\n                tcg_gen_xori_i32(hflags, hflags, MIPS_HFLAG_M16);\n\n            }\n\n            gen_goto_tb(ctx, 0, ctx->btarget);\n\n            break;\n\n        case MIPS_HFLAG_BL:\n\n            /* blikely taken case */\n\n            MIPS_DEBUG(\"blikely branch taken\");\n\n            gen_goto_tb(ctx, 0, ctx->btarget);\n\n            break;\n\n        case MIPS_HFLAG_BC:\n\n            /* Conditional branch */\n\n            MIPS_DEBUG(\"conditional branch\");\n\n            {\n\n                int l1 = gen_new_label();\n\n\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, bcond, 0, l1);\n\n                gen_goto_tb(ctx, 1, ctx->pc + insn_bytes);\n\n                gen_set_label(l1);\n\n                gen_goto_tb(ctx, 0, ctx->btarget);\n\n            }\n\n            break;\n\n        case MIPS_HFLAG_BR:\n\n            /* unconditional branch to register */\n\n            MIPS_DEBUG(\"branch to register\");\n\n            if (ctx->insn_flags & (ASE_MIPS16 | ASE_MICROMIPS)) {\n\n                TCGv t0 = tcg_temp_new();\n\n                TCGv_i32 t1 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_andi_tl(t0, btarget, 0x1);\n\n                tcg_gen_trunc_tl_i32(t1, t0);\n\n                tcg_temp_free(t0);\n\n                tcg_gen_andi_i32(hflags, hflags, ~(uint32_t)MIPS_HFLAG_M16);\n\n                tcg_gen_shli_i32(t1, t1, MIPS_HFLAG_M16_SHIFT);\n\n                tcg_gen_or_i32(hflags, hflags, t1);\n\n                tcg_temp_free_i32(t1);\n\n\n\n                tcg_gen_andi_tl(cpu_PC, btarget, ~(target_ulong)0x1);\n\n            } else {\n\n                tcg_gen_mov_tl(cpu_PC, btarget);\n\n            }\n\n            if (ctx->singlestep_enabled) {\n\n                save_cpu_state(ctx, 0);\n\n                gen_helper_0e0i(raise_exception, EXCP_DEBUG);\n\n            }\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        default:\n\n            MIPS_DEBUG(\"unknown branch\");\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 17653, "_split": "test", "_hash": "e6a1bce56100f27021bcdacd7f7c9310"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void slirp_cleanup(Slirp *slirp)\n\n{\n\n    TAILQ_REMOVE(&slirp_instances, slirp, entry);\n\n\n\n    unregister_savevm(\"slirp\", slirp);\n\n\n\n    qemu_free(slirp->tftp_prefix);\n\n    qemu_free(slirp->bootp_filename);\n\n    qemu_free(slirp);\n\n}\n", "idx": 17664, "_split": "test", "_hash": "dd066188140c549caf7a73658490d6e7"}
{"project": "qemu", "commit_id": "eda470e41a753070e057380a9a71e2ad7347f667", "target": 0, "func": "void scsi_req_abort(SCSIRequest *req, int status)\n\n{\n\n    if (!req->enqueued) {\n\n        return;\n\n    }\n\n    scsi_req_ref(req);\n\n    scsi_req_dequeue(req);\n\n    req->io_canceled = true;\n\n    if (req->ops->cancel_io) {\n\n        req->ops->cancel_io(req);\n\n    }\n\n    scsi_req_complete(req, status);\n\n    scsi_req_unref(req);\n\n}\n", "idx": 17670, "_split": "test", "_hash": "ea5abe641f9e938759567d4ef0b124ad"}
{"project": "qemu", "commit_id": "0e9b9edae7bebfd31fdbead4ccbbce03876a7edd", "target": 0, "func": "build_dsdt(GArray *table_data, GArray *linker,\n\n           AcpiPmInfo *pm, AcpiMiscInfo *misc,\n\n           PcPciInfo *pci, MachineState *machine)\n\n{\n\n    CrsRangeEntry *entry;\n\n    Aml *dsdt, *sb_scope, *scope, *dev, *method, *field, *pkg, *crs;\n\n    GPtrArray *mem_ranges = g_ptr_array_new_with_free_func(crs_range_free);\n\n    GPtrArray *io_ranges = g_ptr_array_new_with_free_func(crs_range_free);\n\n    PCMachineState *pcms = PC_MACHINE(machine);\n\n    uint32_t nr_mem = machine->ram_slots;\n\n    int root_bus_limit = 0xFF;\n\n    PCIBus *bus = NULL;\n\n    int i;\n\n\n\n    dsdt = init_aml_allocator();\n\n\n\n    /* Reserve space for header */\n\n    acpi_data_push(dsdt->buf, sizeof(AcpiTableHeader));\n\n\n\n    build_dbg_aml(dsdt);\n\n    if (misc->is_piix4) {\n\n        sb_scope = aml_scope(\"_SB\");\n\n        dev = aml_device(\"PCI0\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n\n        aml_append(sb_scope, dev);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        build_hpet_aml(dsdt);\n\n        build_piix4_pm(dsdt);\n\n        build_piix4_isa_bridge(dsdt);\n\n        build_isa_devices_aml(dsdt);\n\n        build_piix4_pci_hotplug(dsdt);\n\n        build_piix4_pci0_int(dsdt);\n\n    } else {\n\n        sb_scope = aml_scope(\"_SB\");\n\n        aml_append(sb_scope,\n\n            aml_operation_region(\"PCST\", AML_SYSTEM_IO, aml_int(0xae00), 0x0c));\n\n        aml_append(sb_scope,\n\n            aml_operation_region(\"PCSB\", AML_SYSTEM_IO, aml_int(0xae0c), 0x01));\n\n        field = aml_field(\"PCSB\", AML_ANY_ACC, AML_NOLOCK, AML_WRITE_AS_ZEROS);\n\n        aml_append(field, aml_named_field(\"PCIB\", 8));\n\n        aml_append(sb_scope, field);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        sb_scope = aml_scope(\"_SB\");\n\n        dev = aml_device(\"PCI0\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A08\")));\n\n        aml_append(dev, aml_name_decl(\"_CID\", aml_eisaid(\"PNP0A03\")));\n\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n\n        aml_append(dev, aml_name_decl(\"SUPP\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"CTRL\", aml_int(0)));\n\n        aml_append(dev, build_q35_osc_method());\n\n        aml_append(sb_scope, dev);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        build_hpet_aml(dsdt);\n\n        build_q35_isa_bridge(dsdt);\n\n        build_isa_devices_aml(dsdt);\n\n        build_q35_pci0_int(dsdt);\n\n    }\n\n\n\n    build_legacy_cpu_hotplug_aml(dsdt, machine, pm->cpu_hp_io_base);\n\n    build_memory_hotplug_aml(dsdt, nr_mem, pm->mem_hp_io_base,\n\n                             pm->mem_hp_io_len);\n\n\n\n    scope =  aml_scope(\"_GPE\");\n\n    {\n\n        aml_append(scope, aml_name_decl(\"_HID\", aml_string(\"ACPI0006\")));\n\n\n\n        if (misc->is_piix4) {\n\n            method = aml_method(\"_E01\", 0, AML_NOTSERIALIZED);\n\n            aml_append(method,\n\n                aml_acquire(aml_name(\"\\\\_SB.PCI0.BLCK\"), 0xFFFF));\n\n            aml_append(method, aml_call0(\"\\\\_SB.PCI0.PCNT\"));\n\n            aml_append(method, aml_release(aml_name(\"\\\\_SB.PCI0.BLCK\")));\n\n            aml_append(scope, method);\n\n        }\n\n\n\n        method = aml_method(\"_E03\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_call0(MEMORY_HOTPLUG_HANDLER_PATH));\n\n        aml_append(scope, method);\n\n    }\n\n    aml_append(dsdt, scope);\n\n\n\n    bus = PC_MACHINE(machine)->bus;\n\n    if (bus) {\n\n        QLIST_FOREACH(bus, &bus->child, sibling) {\n\n            uint8_t bus_num = pci_bus_num(bus);\n\n            uint8_t numa_node = pci_bus_numa_node(bus);\n\n\n\n            /* look only for expander root buses */\n\n            if (!pci_bus_is_root(bus)) {\n\n                continue;\n\n            }\n\n\n\n            if (bus_num < root_bus_limit) {\n\n                root_bus_limit = bus_num - 1;\n\n            }\n\n\n\n            scope = aml_scope(\"\\\\_SB\");\n\n            dev = aml_device(\"PC%.02X\", bus_num);\n\n            aml_append(dev, aml_name_decl(\"_UID\", aml_int(bus_num)));\n\n            aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n\n            aml_append(dev, aml_name_decl(\"_BBN\", aml_int(bus_num)));\n\n\n\n            if (numa_node != NUMA_NODE_UNASSIGNED) {\n\n                aml_append(dev, aml_name_decl(\"_PXM\", aml_int(numa_node)));\n\n            }\n\n\n\n            aml_append(dev, build_prt(false));\n\n            crs = build_crs(PCI_HOST_BRIDGE(BUS(bus)->parent),\n\n                            io_ranges, mem_ranges);\n\n            aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n            aml_append(scope, dev);\n\n            aml_append(dsdt, scope);\n\n        }\n\n    }\n\n\n\n    scope = aml_scope(\"\\\\_SB.PCI0\");\n\n    /* build PCI0._CRS */\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                            0x0000, 0x0, root_bus_limit,\n\n                            0x0000, root_bus_limit + 1));\n\n    aml_append(crs, aml_io(AML_DECODE16, 0x0CF8, 0x0CF8, 0x01, 0x08));\n\n\n\n    aml_append(crs,\n\n        aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                    AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                    0x0000, 0x0000, 0x0CF7, 0x0000, 0x0CF8));\n\n\n\n    crs_replace_with_free_ranges(io_ranges, 0x0D00, 0xFFFF);\n\n    for (i = 0; i < io_ranges->len; i++) {\n\n        entry = g_ptr_array_index(io_ranges, i);\n\n        aml_append(crs,\n\n            aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                        AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                        0x0000, entry->base, entry->limit,\n\n                        0x0000, entry->limit - entry->base + 1));\n\n    }\n\n\n\n    aml_append(crs,\n\n        aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                         AML_CACHEABLE, AML_READ_WRITE,\n\n                         0, 0x000A0000, 0x000BFFFF, 0, 0x00020000));\n\n\n\n    crs_replace_with_free_ranges(mem_ranges, pci->w32.begin, pci->w32.end - 1);\n\n    for (i = 0; i < mem_ranges->len; i++) {\n\n        entry = g_ptr_array_index(mem_ranges, i);\n\n        aml_append(crs,\n\n            aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_NON_CACHEABLE, AML_READ_WRITE,\n\n                             0, entry->base, entry->limit,\n\n                             0, entry->limit - entry->base + 1));\n\n    }\n\n\n\n    if (pci->w64.begin) {\n\n        aml_append(crs,\n\n            aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_CACHEABLE, AML_READ_WRITE,\n\n                             0, pci->w64.begin, pci->w64.end - 1, 0,\n\n                             pci->w64.end - pci->w64.begin));\n\n    }\n\n\n\n    if (misc->tpm_version != TPM_VERSION_UNSPEC) {\n\n        aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,\n\n                   TPM_TIS_ADDR_SIZE, AML_READ_WRITE));\n\n    }\n\n    aml_append(scope, aml_name_decl(\"_CRS\", crs));\n\n\n\n    /* reserve GPE0 block resources */\n\n    dev = aml_device(\"GPE0\");\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n\n    aml_append(dev, aml_name_decl(\"_UID\", aml_string(\"GPE0 resources\")));\n\n    /* device present, functioning, decoding, not shown in UI */\n\n    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_io(AML_DECODE16, pm->gpe0_blk, pm->gpe0_blk, 1, pm->gpe0_blk_len)\n\n    );\n\n    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n    aml_append(scope, dev);\n\n\n\n    g_ptr_array_free(io_ranges, true);\n\n    g_ptr_array_free(mem_ranges, true);\n\n\n\n    /* reserve PCIHP resources */\n\n    if (pm->pcihp_io_len) {\n\n        dev = aml_device(\"PHPR\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n\n        aml_append(dev,\n\n            aml_name_decl(\"_UID\", aml_string(\"PCI Hotplug resources\")));\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, pm->pcihp_io_base, pm->pcihp_io_base, 1,\n\n                   pm->pcihp_io_len)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n        aml_append(scope, dev);\n\n    }\n\n    aml_append(dsdt, scope);\n\n\n\n    /*  create S3_ / S4_ / S5_ packages if necessary */\n\n    scope = aml_scope(\"\\\\\");\n\n    if (!pm->s3_disabled) {\n\n        pkg = aml_package(4);\n\n        aml_append(pkg, aml_int(1)); /* PM1a_CNT.SLP_TYP */\n\n        aml_append(pkg, aml_int(1)); /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(scope, aml_name_decl(\"_S3\", pkg));\n\n    }\n\n\n\n    if (!pm->s4_disabled) {\n\n        pkg = aml_package(4);\n\n        aml_append(pkg, aml_int(pm->s4_val)); /* PM1a_CNT.SLP_TYP */\n\n        /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n\n        aml_append(pkg, aml_int(pm->s4_val));\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(scope, aml_name_decl(\"_S4\", pkg));\n\n    }\n\n\n\n    pkg = aml_package(4);\n\n    aml_append(pkg, aml_int(0)); /* PM1a_CNT.SLP_TYP */\n\n    aml_append(pkg, aml_int(0)); /* PM1b_CNT.SLP_TYP not impl. */\n\n    aml_append(pkg, aml_int(0)); /* reserved */\n\n    aml_append(pkg, aml_int(0)); /* reserved */\n\n    aml_append(scope, aml_name_decl(\"_S5\", pkg));\n\n    aml_append(dsdt, scope);\n\n\n\n    /* create fw_cfg node, unconditionally */\n\n    {\n\n        /* when using port i/o, the 8-bit data register *always* overlaps\n\n         * with half of the 16-bit control register. Hence, the total size\n\n         * of the i/o region used is FW_CFG_CTL_SIZE; when using DMA, the\n\n         * DMA control register is located at FW_CFG_DMA_IO_BASE + 4 */\n\n        uint8_t io_size = object_property_get_bool(OBJECT(pcms->fw_cfg),\n\n                                                   \"dma_enabled\", NULL) ?\n\n                          ROUND_UP(FW_CFG_CTL_SIZE, 4) + sizeof(dma_addr_t) :\n\n                          FW_CFG_CTL_SIZE;\n\n\n\n        scope = aml_scope(\"\\\\_SB.PCI0\");\n\n        dev = aml_device(\"FWCF\");\n\n\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0002\")));\n\n\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, FW_CFG_IO_BASE, FW_CFG_IO_BASE, 0x01, io_size)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    if (misc->applesmc_io_base) {\n\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n\n        dev = aml_device(\"SMC\");\n\n\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"APP0001\")));\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, misc->applesmc_io_base, misc->applesmc_io_base,\n\n                   0x01, APPLESMC_MAX_DATA_LENGTH)\n\n        );\n\n        aml_append(crs, aml_irq_no_flags(6));\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    if (misc->pvpanic_port) {\n\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n\n\n\n        dev = aml_device(\"PEVT\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0001\")));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, misc->pvpanic_port, misc->pvpanic_port, 1, 1)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(dev, aml_operation_region(\"PEOR\", AML_SYSTEM_IO,\n\n                                              aml_int(misc->pvpanic_port), 1));\n\n        field = aml_field(\"PEOR\", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);\n\n        aml_append(field, aml_named_field(\"PEPT\", 8));\n\n        aml_append(dev, field);\n\n\n\n        /* device present, functioning, decoding, shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n\n\n        method = aml_method(\"RDPT\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_store(aml_name(\"PEPT\"), aml_local(0)));\n\n        aml_append(method, aml_return(aml_local(0)));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"WRPT\", 1, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_store(aml_arg(0), aml_name(\"PEPT\")));\n\n        aml_append(dev, method);\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    sb_scope = aml_scope(\"\\\\_SB\");\n\n    {\n\n        build_memory_devices(sb_scope, nr_mem, pm->mem_hp_io_base,\n\n                             pm->mem_hp_io_len);\n\n\n\n        {\n\n            Object *pci_host;\n\n            PCIBus *bus = NULL;\n\n\n\n            pci_host = acpi_get_i386_pci_host();\n\n            if (pci_host) {\n\n                bus = PCI_HOST_BRIDGE(pci_host)->bus;\n\n            }\n\n\n\n            if (bus) {\n\n                Aml *scope = aml_scope(\"PCI0\");\n\n                /* Scan all PCI buses. Generate tables to support hotplug. */\n\n                build_append_pci_bus_devices(scope, bus, pm->pcihp_bridge_en);\n\n\n\n                if (misc->tpm_version != TPM_VERSION_UNSPEC) {\n\n                    dev = aml_device(\"ISA.TPM\");\n\n                    aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0C31\")));\n\n                    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n                    crs = aml_resource_template();\n\n                    aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,\n\n                               TPM_TIS_ADDR_SIZE, AML_READ_WRITE));\n\n                    /*\n\n                        FIXME: TPM_TIS_IRQ=5 conflicts with PNP0C0F irqs,\n\n                        Rewrite to take IRQ from TPM device model and\n\n                        fix default IRQ value there to use some unused IRQ\n\n                     */\n\n                    /* aml_append(crs, aml_irq_no_flags(TPM_TIS_IRQ)); */\n\n                    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n                    aml_append(scope, dev);\n\n                }\n\n\n\n                aml_append(sb_scope, scope);\n\n            }\n\n        }\n\n        aml_append(dsdt, sb_scope);\n\n    }\n\n\n\n    /* copy AML table into ACPI tables blob and patch header there */\n\n    g_array_append_vals(table_data, dsdt->buf->data, dsdt->buf->len);\n\n    build_header(linker, table_data,\n\n        (void *)(table_data->data + table_data->len - dsdt->buf->len),\n\n        \"DSDT\", dsdt->buf->len, 1, NULL, NULL);\n\n    free_aml_allocator();\n\n}\n", "idx": 17682, "_split": "test", "_hash": "fc6c9a8db26c4036969fb2e8dc73d217"}
{"project": "qemu", "commit_id": "3d6f761713745dfed7d2ccfe98077d213a6a6eba", "target": 0, "func": "static void arm_cpu_do_interrupt_aarch64(CPUState *cs)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    unsigned int new_el = env->exception.target_el;\n\n    target_ulong addr = env->cp15.vbar_el[new_el];\n\n    unsigned int new_mode = aarch64_pstate_mode(new_el, true);\n\n\n\n    if (arm_current_el(env) < new_el) {\n\n        if (env->aarch64) {\n\n            addr += 0x400;\n\n        } else {\n\n            addr += 0x600;\n\n        }\n\n    } else if (pstate_read(env) & PSTATE_SP) {\n\n        addr += 0x200;\n\n    }\n\n\n\n    switch (cs->exception_index) {\n\n    case EXCP_PREFETCH_ABORT:\n\n    case EXCP_DATA_ABORT:\n\n        env->cp15.far_el[new_el] = env->exception.vaddress;\n\n        qemu_log_mask(CPU_LOG_INT, \"...with FAR 0x%\" PRIx64 \"\\n\",\n\n                      env->cp15.far_el[new_el]);\n\n        /* fall through */\n\n    case EXCP_BKPT:\n\n    case EXCP_UDEF:\n\n    case EXCP_SWI:\n\n    case EXCP_HVC:\n\n    case EXCP_HYP_TRAP:\n\n    case EXCP_SMC:\n\n        env->cp15.esr_el[new_el] = env->exception.syndrome;\n\n        break;\n\n    case EXCP_IRQ:\n\n    case EXCP_VIRQ:\n\n        addr += 0x80;\n\n        break;\n\n    case EXCP_FIQ:\n\n    case EXCP_VFIQ:\n\n        addr += 0x100;\n\n        break;\n\n    case EXCP_SEMIHOST:\n\n        qemu_log_mask(CPU_LOG_INT,\n\n                      \"...handling as semihosting call 0x%\" PRIx64 \"\\n\",\n\n                      env->xregs[0]);\n\n        env->xregs[0] = do_arm_semihosting(env);\n\n        return;\n\n    default:\n\n        cpu_abort(cs, \"Unhandled exception 0x%x\\n\", cs->exception_index);\n\n    }\n\n\n\n    if (is_a64(env)) {\n\n        env->banked_spsr[aarch64_banked_spsr_index(new_el)] = pstate_read(env);\n\n        aarch64_save_sp(env, arm_current_el(env));\n\n        env->elr_el[new_el] = env->pc;\n\n    } else {\n\n        env->banked_spsr[aarch64_banked_spsr_index(new_el)] = cpsr_read(env);\n\n        if (!env->thumb) {\n\n            env->cp15.esr_el[new_el] |= 1 << 25;\n\n        }\n\n        env->elr_el[new_el] = env->regs[15];\n\n\n\n        aarch64_sync_32_to_64(env);\n\n\n\n        env->condexec_bits = 0;\n\n    }\n\n    qemu_log_mask(CPU_LOG_INT, \"...with ELR 0x%\" PRIx64 \"\\n\",\n\n                  env->elr_el[new_el]);\n\n\n\n    pstate_write(env, PSTATE_DAIF | new_mode);\n\n    env->aarch64 = 1;\n\n    aarch64_restore_sp(env, new_el);\n\n\n\n    env->pc = addr;\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"...to EL%d PC 0x%\" PRIx64 \" PSTATE 0x%x\\n\",\n\n                  new_el, env->pc, pstate_read(env));\n\n}\n", "idx": 17699, "_split": "test", "_hash": "99219f0915849c81d0ba6174ff25d900"}
{"project": "qemu", "commit_id": "5fe79386ba3cdc86fd808dde301bfc5bb7e9bded", "target": 0, "func": "static bool pc_machine_get_nvdimm(Object *obj, Error **errp)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(obj);\n\n\n\n    return pcms->nvdimm;\n\n}\n", "idx": 17700, "_split": "test", "_hash": "5ba79631ef341d7b18262c2b2d830189"}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_header(GArray *linker, GArray *table_data,\n\n             AcpiTableHeader *h, const char *sig, int len, uint8_t rev,\n\n             const char *oem_table_id)\n\n{\n\n    memcpy(&h->signature, sig, 4);\n\n    h->length = cpu_to_le32(len);\n\n    h->revision = rev;\n\n    memcpy(h->oem_id, ACPI_BUILD_APPNAME6, 6);\n\n\n\n    if (oem_table_id) {\n\n        strncpy((char *)h->oem_table_id, oem_table_id, sizeof(h->oem_table_id));\n\n    } else {\n\n        memcpy(h->oem_table_id, ACPI_BUILD_APPNAME4, 4);\n\n        memcpy(h->oem_table_id + 4, sig, 4);\n\n    }\n\n\n\n    h->oem_revision = cpu_to_le32(1);\n\n    memcpy(h->asl_compiler_id, ACPI_BUILD_APPNAME4, 4);\n\n    h->asl_compiler_revision = cpu_to_le32(1);\n\n    h->checksum = 0;\n\n    /* Checksum to be filled in by Guest linker */\n\n    bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,\n\n                                    table_data->data, h, len, &h->checksum);\n\n}\n", "idx": 17710, "_split": "test", "_hash": "e048e447b8715d9b5f9a3a2962f53a8a"}
{"project": "qemu", "commit_id": "096685fc2a955ea17d5363ab452e301be2b43873", "target": 1, "func": "static uint64_t omap2_inth_read(void *opaque, target_phys_addr_t addr,\n\n                                unsigned size)\n\n{\n\n    struct omap_intr_handler_s *s = (struct omap_intr_handler_s *) opaque;\n\n    int offset = addr;\n\n    int bank_no, line_no;\n\n    struct omap_intr_handler_bank_s *bank = NULL;\n\n\n\n    if ((offset & 0xf80) == 0x80) {\n\n        bank_no = (offset & 0x60) >> 5;\n\n        if (bank_no < s->nbanks) {\n\n            offset &= ~0x60;\n\n            bank = &s->bank[bank_no];\n\n\n\n\n        }\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* INTC_REVISION */\n\n        return s->revision;\n\n\n\n    case 0x10:\t/* INTC_SYSCONFIG */\n\n        return (s->autoidle >> 2) & 1;\n\n\n\n    case 0x14:\t/* INTC_SYSSTATUS */\n\n        return 1;\t\t\t\t\t\t/* RESETDONE */\n\n\n\n    case 0x40:\t/* INTC_SIR_IRQ */\n\n        return s->sir_intr[0];\n\n\n\n    case 0x44:\t/* INTC_SIR_FIQ */\n\n        return s->sir_intr[1];\n\n\n\n    case 0x48:\t/* INTC_CONTROL */\n\n        return (!s->mask) << 2;\t\t\t\t\t/* GLOBALMASK */\n\n\n\n    case 0x4c:\t/* INTC_PROTECTION */\n\n\n\n\n    case 0x50:\t/* INTC_IDLE */\n\n        return s->autoidle & 3;\n\n\n\n    /* Per-bank registers */\n\n    case 0x80:\t/* INTC_ITR */\n\n        return bank->inputs;\n\n\n\n    case 0x84:\t/* INTC_MIR */\n\n        return bank->mask;\n\n\n\n    case 0x88:\t/* INTC_MIR_CLEAR */\n\n    case 0x8c:\t/* INTC_MIR_SET */\n\n\n\n\n    case 0x90:\t/* INTC_ISR_SET */\n\n        return bank->swi;\n\n\n\n    case 0x94:\t/* INTC_ISR_CLEAR */\n\n\n\n\n    case 0x98:\t/* INTC_PENDING_IRQ */\n\n        return bank->irqs & ~bank->mask & ~bank->fiq;\n\n\n\n    case 0x9c:\t/* INTC_PENDING_FIQ */\n\n        return bank->irqs & ~bank->mask & bank->fiq;\n\n\n\n    /* Per-line registers */\n\n    case 0x100 ... 0x300:\t/* INTC_ILR */\n\n        bank_no = (offset - 0x100) >> 7;\n\n        if (bank_no > s->nbanks)\n\n            break;\n\n        bank = &s->bank[bank_no];\n\n        line_no = (offset & 0x7f) >> 2;\n\n        return (bank->priority[line_no] << 2) |\n\n                ((bank->fiq >> line_no) & 1);\n\n    }\n\n\n\n}", "idx": 17805, "_split": "test", "_hash": "af846f9fe80219c2b5d8a2d22ae1b722"}
{"project": "qemu", "commit_id": "2f0772c5b4818d4b2078be9dace0036d1030faee", "target": 1, "func": "static void lsi_soft_reset(LSIState *s)\n\n{\n\n    lsi_request *p;\n\n\n\n    DPRINTF(\"Reset\\n\");\n\n    s->carry = 0;\n\n\n\n    s->msg_action = 0;\n\n    s->msg_len = 0;\n\n    s->waiting = 0;\n\n    s->dsa = 0;\n\n    s->dnad = 0;\n\n    s->dbc = 0;\n\n    s->temp = 0;\n\n    memset(s->scratch, 0, sizeof(s->scratch));\n\n    s->istat0 = 0;\n\n    s->istat1 = 0;\n\n    s->dcmd = 0x40;\n\n    s->dstat = LSI_DSTAT_DFE;\n\n    s->dien = 0;\n\n    s->sist0 = 0;\n\n    s->sist1 = 0;\n\n    s->sien0 = 0;\n\n    s->sien1 = 0;\n\n    s->mbox0 = 0;\n\n    s->mbox1 = 0;\n\n    s->dfifo = 0;\n\n    s->ctest2 = LSI_CTEST2_DACK;\n\n    s->ctest3 = 0;\n\n    s->ctest4 = 0;\n\n    s->ctest5 = 0;\n\n    s->ccntl0 = 0;\n\n    s->ccntl1 = 0;\n\n    s->dsp = 0;\n\n    s->dsps = 0;\n\n    s->dmode = 0;\n\n    s->dcntl = 0;\n\n    s->scntl0 = 0xc0;\n\n    s->scntl1 = 0;\n\n    s->scntl2 = 0;\n\n    s->scntl3 = 0;\n\n    s->sstat0 = 0;\n\n    s->sstat1 = 0;\n\n    s->scid = 7;\n\n    s->sxfer = 0;\n\n    s->socl = 0;\n\n    s->sdid = 0;\n\n    s->ssid = 0;\n\n    s->stest1 = 0;\n\n    s->stest2 = 0;\n\n    s->stest3 = 0;\n\n    s->sidl = 0;\n\n    s->stime0 = 0;\n\n    s->respid0 = 0x80;\n\n    s->respid1 = 0;\n\n    s->mmrs = 0;\n\n    s->mmws = 0;\n\n    s->sfs = 0;\n\n    s->drs = 0;\n\n    s->sbms = 0;\n\n    s->dbms = 0;\n\n    s->dnad64 = 0;\n\n    s->pmjad1 = 0;\n\n    s->pmjad2 = 0;\n\n    s->rbc = 0;\n\n    s->ua = 0;\n\n    s->ia = 0;\n\n    s->sbc = 0;\n\n    s->csbc = 0;\n\n    s->sbr = 0;\n\n    while (!QTAILQ_EMPTY(&s->queue)) {\n\n        p = QTAILQ_FIRST(&s->queue);\n\n        QTAILQ_REMOVE(&s->queue, p, next);\n\n        g_free(p);\n\n    }\n\n    if (s->current) {\n\n        g_free(s->current);\n\n        s->current = NULL;\n\n    }\n\n}\n", "idx": 17833, "_split": "test", "_hash": "caf017635dfc145fb8dcda5fe22b22d7"}
{"project": "qemu", "commit_id": "198a0039c5fca224a77e9761e2350dd9cc102ad0", "target": 1, "func": "static void vnc_dpy_copy(DisplayState *ds, int src_x, int src_y, int dst_x, int dst_y, int w, int h)\n\n{\n\n    VncDisplay *vd = ds->opaque;\n\n    VncState *vs = vd->clients;\n\n    while (vs != NULL) {\n\n        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT))\n\n            vnc_copy(vs, src_x, src_y, dst_x, dst_y, w, h);\n\n        else /* TODO */\n\n            vnc_update(vs, dst_x, dst_y, w, h);\n\n        vs = vs->next;\n\n    }\n\n}\n", "idx": 17883, "_split": "test", "_hash": "bb3178e959c0c99b00e9969c4592ad7e"}
{"project": "qemu", "commit_id": "da5361cc685c004d8bb4e7c5e7b3a52c7aca2c56", "target": 1, "func": "static int emulated_exitfn(CCIDCardState *base)\n\n{\n\n    EmulatedState *card = DO_UPCAST(EmulatedState, base, base);\n\n    VEvent *vevent = vevent_new(VEVENT_LAST, NULL, NULL);\n\n\n\n    vevent_queue_vevent(vevent); /* stop vevent thread */\n\n    qemu_mutex_lock(&card->apdu_thread_quit_mutex);\n\n    card->quit_apdu_thread = 1; /* stop handle_apdu thread */\n\n    qemu_cond_signal(&card->handle_apdu_cond);\n\n    qemu_cond_wait(&card->apdu_thread_quit_cond,\n\n                      &card->apdu_thread_quit_mutex);\n\n    /* handle_apdu thread stopped, can destroy all of it's mutexes */\n\n    qemu_cond_destroy(&card->handle_apdu_cond);\n\n    qemu_cond_destroy(&card->apdu_thread_quit_cond);\n\n    qemu_mutex_destroy(&card->apdu_thread_quit_mutex);\n\n    qemu_mutex_destroy(&card->handle_apdu_mutex);\n\n    qemu_mutex_destroy(&card->vreader_mutex);\n\n    qemu_mutex_destroy(&card->event_list_mutex);\n\n    return 0;\n\n}\n", "idx": 17885, "_split": "test", "_hash": "a38bec6c6dcb3835ebc93b73f99b999e"}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qvirtio_pci_device_enable(QVirtioPCIDevice *d)\n\n{\n\n    qpci_device_enable(d->pdev);\n\n    d->addr = qpci_iomap(d->pdev, 0, NULL);\n\n    g_assert(d->addr != NULL);\n\n}\n", "idx": 17909, "_split": "test", "_hash": "9eb915b035a1a6a83c00a0c04c60bee2"}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "static int bdrv_qed_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp)\n\n{\n\n    BDRVQEDState *s = bs->opaque;\n\n    QEDHeader le_header;\n\n    int64_t file_size;\n\n    int ret;\n\n\n\n    s->bs = bs;\n\n    QSIMPLEQ_INIT(&s->allocating_write_reqs);\n\n\n\n    ret = bdrv_pread(bs->file, 0, &le_header, sizeof(le_header));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    qed_header_le_to_cpu(&le_header, &s->header);\n\n\n\n    if (s->header.magic != QED_MAGIC) {\n\n        error_setg(errp, \"Image not in QED format\");\n\n        return -EINVAL;\n\n    }\n\n    if (s->header.features & ~QED_FEATURE_MASK) {\n\n        /* image uses unsupported feature bits */\n\n        char buf[64];\n\n        snprintf(buf, sizeof(buf), \"%\" PRIx64,\n\n            s->header.features & ~QED_FEATURE_MASK);\n\n        error_set(errp, QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,\n\n            bdrv_get_device_name(bs), \"QED\", buf);\n\n        return -ENOTSUP;\n\n    }\n\n    if (!qed_is_cluster_size_valid(s->header.cluster_size)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Round down file size to the last cluster */\n\n    file_size = bdrv_getlength(bs->file);\n\n    if (file_size < 0) {\n\n        return file_size;\n\n    }\n\n    s->file_size = qed_start_of_cluster(s, file_size);\n\n\n\n    if (!qed_is_table_size_valid(s->header.table_size)) {\n\n        return -EINVAL;\n\n    }\n\n    if (!qed_is_image_size_valid(s->header.image_size,\n\n                                 s->header.cluster_size,\n\n                                 s->header.table_size)) {\n\n        return -EINVAL;\n\n    }\n\n    if (!qed_check_table_offset(s, s->header.l1_table_offset)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    s->table_nelems = (s->header.cluster_size * s->header.table_size) /\n\n                      sizeof(uint64_t);\n\n    s->l2_shift = ffs(s->header.cluster_size) - 1;\n\n    s->l2_mask = s->table_nelems - 1;\n\n    s->l1_shift = s->l2_shift + ffs(s->table_nelems) - 1;\n\n\n\n    /* Header size calculation must not overflow uint32_t */\n\n    if (s->header.header_size > UINT32_MAX / s->header.cluster_size) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if ((s->header.features & QED_F_BACKING_FILE)) {\n\n        if ((uint64_t)s->header.backing_filename_offset +\n\n            s->header.backing_filename_size >\n\n            s->header.cluster_size * s->header.header_size) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        ret = qed_read_string(bs->file, s->header.backing_filename_offset,\n\n                              s->header.backing_filename_size, bs->backing_file,\n\n                              sizeof(bs->backing_file));\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        if (s->header.features & QED_F_BACKING_FORMAT_NO_PROBE) {\n\n            pstrcpy(bs->backing_format, sizeof(bs->backing_format), \"raw\");\n\n        }\n\n    }\n\n\n\n    /* Reset unknown autoclear feature bits.  This is a backwards\n\n     * compatibility mechanism that allows images to be opened by older\n\n     * programs, which \"knock out\" unknown feature bits.  When an image is\n\n     * opened by a newer program again it can detect that the autoclear\n\n     * feature is no longer valid.\n\n     */\n\n    if ((s->header.autoclear_features & ~QED_AUTOCLEAR_FEATURE_MASK) != 0 &&\n\n        !bdrv_is_read_only(bs->file) && !(flags & BDRV_O_INCOMING)) {\n\n        s->header.autoclear_features &= QED_AUTOCLEAR_FEATURE_MASK;\n\n\n\n        ret = qed_write_header_sync(s);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        /* From here on only known autoclear feature bits are valid */\n\n        bdrv_flush(bs->file);\n\n    }\n\n\n\n    s->l1_table = qed_alloc_table(s);\n\n    qed_init_l2_cache(&s->l2_cache);\n\n\n\n    ret = qed_read_l1_table_sync(s);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    /* If image was not closed cleanly, check consistency */\n\n    if (!(flags & BDRV_O_CHECK) && (s->header.features & QED_F_NEED_CHECK)) {\n\n        /* Read-only images cannot be fixed.  There is no risk of corruption\n\n         * since write operations are not possible.  Therefore, allow\n\n         * potentially inconsistent images to be opened read-only.  This can\n\n         * aid data recovery from an otherwise inconsistent image.\n\n         */\n\n        if (!bdrv_is_read_only(bs->file) &&\n\n            !(flags & BDRV_O_INCOMING)) {\n\n            BdrvCheckResult result = {0};\n\n\n\n            ret = qed_check(s, &result, true);\n\n            if (ret) {\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\n    bdrv_qed_attach_aio_context(bs, bdrv_get_aio_context(bs));\n\n\n\nout:\n\n    if (ret) {\n\n        qed_free_l2_cache(&s->l2_cache);\n\n        qemu_vfree(s->l1_table);\n\n    }\n\n    return ret;\n\n}\n", "idx": 17953, "_split": "test", "_hash": "57fda2e51a499da3ecea0246f48c127a"}
{"project": "qemu", "commit_id": "d0d7708ba29cbcc343364a46bff981e0ff88366f", "target": 0, "func": "static CharDriverState *qemu_chr_open_pipe(const char *id,\n\n                                           ChardevBackend *backend,\n\n                                           ChardevReturn *ret,\n\n                                           Error **errp)\n\n{\n\n    ChardevHostdev *opts = backend->u.pipe;\n\n    const char *filename = opts->device;\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = qemu_chr_alloc();\n\n    s = g_new0(WinCharState, 1);\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    chr->chr_close = win_chr_close;\n\n\n\n    if (win_chr_pipe_init(chr, filename, errp) < 0) {\n\n        g_free(s);\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n    return chr;\n\n}\n", "idx": 17972, "_split": "test", "_hash": "038dc7fb69facae37475413b7a930506"}
{"project": "qemu", "commit_id": "7bbcb0afe715c36545bbbd872441c473927c1a4e", "target": 0, "func": "uint32_t HELPER(clz)(uint32_t x)\n\n{\n\n    int count;\n\n    for (count = 32; x; count--)\n\n        x >>= 1;\n\n    return count;\n\n}\n", "idx": 17981, "_split": "test", "_hash": "e14c25afe5e45fa07135c7112e322354"}
{"project": "qemu", "commit_id": "96c9cff0ab986f3a0606e1a96c5b00e6a7c675c6", "target": 0, "func": "static void kvm_get_fallback_smmu_info(PowerPCCPU *cpu,\n\n                                       struct kvm_ppc_smmu_info *info)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    CPUState *cs = CPU(cpu);\n\n\n\n    memset(info, 0, sizeof(*info));\n\n\n\n    /* We don't have the new KVM_PPC_GET_SMMU_INFO ioctl, so\n\n     * need to \"guess\" what the supported page sizes are.\n\n     *\n\n     * For that to work we make a few assumptions:\n\n     *\n\n     * - If KVM_CAP_PPC_GET_PVINFO is supported we are running \"PR\"\n\n     *   KVM which only supports 4K and 16M pages, but supports them\n\n     *   regardless of the backing store characteritics. We also don't\n\n     *   support 1T segments.\n\n     *\n\n     *   This is safe as if HV KVM ever supports that capability or PR\n\n     *   KVM grows supports for more page/segment sizes, those versions\n\n     *   will have implemented KVM_CAP_PPC_GET_SMMU_INFO and thus we\n\n     *   will not hit this fallback\n\n     *\n\n     * - Else we are running HV KVM. This means we only support page\n\n     *   sizes that fit in the backing store. Additionally we only\n\n     *   advertize 64K pages if the processor is ARCH 2.06 and we assume\n\n     *   P7 encodings for the SLB and hash table. Here too, we assume\n\n     *   support for any newer processor will mean a kernel that\n\n     *   implements KVM_CAP_PPC_GET_SMMU_INFO and thus doesn't hit\n\n     *   this fallback.\n\n     */\n\n    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO)) {\n\n        /* No flags */\n\n        info->flags = 0;\n\n        info->slb_size = 64;\n\n\n\n        /* Standard 4k base page size segment */\n\n        info->sps[0].page_shift = 12;\n\n        info->sps[0].slb_enc = 0;\n\n        info->sps[0].enc[0].page_shift = 12;\n\n        info->sps[0].enc[0].pte_enc = 0;\n\n\n\n        /* Standard 16M large page size segment */\n\n        info->sps[1].page_shift = 24;\n\n        info->sps[1].slb_enc = SLB_VSID_L;\n\n        info->sps[1].enc[0].page_shift = 24;\n\n        info->sps[1].enc[0].pte_enc = 0;\n\n    } else {\n\n        int i = 0;\n\n\n\n        /* HV KVM has backing store size restrictions */\n\n        info->flags = KVM_PPC_PAGE_SIZES_REAL;\n\n\n\n        if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n            info->flags |= KVM_PPC_1T_SEGMENTS;\n\n        }\n\n\n\n        if (env->mmu_model == POWERPC_MMU_2_06 ||\n\n            env->mmu_model == POWERPC_MMU_2_07) {\n\n            info->slb_size = 32;\n\n        } else {\n\n            info->slb_size = 64;\n\n        }\n\n\n\n        /* Standard 4k base page size segment */\n\n        info->sps[i].page_shift = 12;\n\n        info->sps[i].slb_enc = 0;\n\n        info->sps[i].enc[0].page_shift = 12;\n\n        info->sps[i].enc[0].pte_enc = 0;\n\n        i++;\n\n\n\n        /* 64K on MMU 2.06 and later */\n\n        if (env->mmu_model == POWERPC_MMU_2_06 ||\n\n            env->mmu_model == POWERPC_MMU_2_07) {\n\n            info->sps[i].page_shift = 16;\n\n            info->sps[i].slb_enc = 0x110;\n\n            info->sps[i].enc[0].page_shift = 16;\n\n            info->sps[i].enc[0].pte_enc = 1;\n\n            i++;\n\n        }\n\n\n\n        /* Standard 16M large page size segment */\n\n        info->sps[i].page_shift = 24;\n\n        info->sps[i].slb_enc = SLB_VSID_L;\n\n        info->sps[i].enc[0].page_shift = 24;\n\n        info->sps[i].enc[0].pte_enc = 0;\n\n    }\n\n}\n", "idx": 18015, "_split": "test", "_hash": "7e5cf1b2771d1b48e23d04afb2ab12de"}
{"project": "qemu", "commit_id": "7e84c2498f0ff3999937d18d1e9abaa030400000", "target": 0, "func": "void helper_iret_protected(int shift)\n\n{\n\n    helper_ret_protected(shift, 1, 0);\n\n}\n", "idx": 18020, "_split": "test", "_hash": "85521fb8ccd0714f3e987d9dce6d0e17"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void qemu_bh_schedule(QEMUBH *bh)\n\n{\n\n    AioContext *ctx;\n\n\n\n    ctx = bh->ctx;\n\n    bh->idle = 0;\n\n    /* The memory barrier implicit in atomic_xchg makes sure that:\n\n     * 1. idle & any writes needed by the callback are done before the\n\n     *    locations are read in the aio_bh_poll.\n\n     * 2. ctx is loaded before scheduled is set and the callback has a chance\n\n     *    to execute.\n\n     */\n\n    if (atomic_xchg(&bh->scheduled, 1) == 0) {\n\n        aio_notify(ctx);\n\n    }\n\n}\n", "idx": 18038, "_split": "test", "_hash": "4a170f9721ba0f8c65c8ff88b7632143"}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)\n\n{\n\n    SpiceTimer *timer;\n\n\n\n    timer = qemu_mallocz(sizeof(*timer));\n\n    timer->timer = qemu_new_timer(rt_clock, func, opaque);\n\n    QTAILQ_INSERT_TAIL(&timers, timer, next);\n\n    return timer;\n\n}\n", "idx": 18044, "_split": "test", "_hash": "ca4845fbf7d24d9b5386aab7f84ea8a6"}
{"project": "qemu", "commit_id": "b131c74a0e485b084ddaffc8214c8a19af492be7", "target": 0, "func": "static int kvm_virtio_pci_vq_vector_use(VirtIOPCIProxy *proxy,\n\n                                        unsigned int queue_no,\n\n                                        unsigned int vector,\n\n                                        MSIMessage msg)\n\n{\n\n    VirtQueue *vq = virtio_get_queue(proxy->vdev, queue_no);\n\n    EventNotifier *n = virtio_queue_get_guest_notifier(vq);\n\n    VirtIOIRQFD *irqfd = &proxy->vector_irqfd[vector];\n\n    int ret;\n\n\n\n    if (irqfd->users == 0) {\n\n        ret = kvm_irqchip_add_msi_route(kvm_state, msg);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        irqfd->virq = ret;\n\n    }\n\n    irqfd->users++;\n\n\n\n    ret = kvm_irqchip_add_irq_notifier(kvm_state, n, irqfd->virq);\n\n    if (ret < 0) {\n\n        if (--irqfd->users == 0) {\n\n            kvm_irqchip_release_virq(kvm_state, irqfd->virq);\n\n        }\n\n        return ret;\n\n    }\n\n\n\n    virtio_queue_set_guest_notifier_fd_handler(vq, true, true);\n\n    return 0;\n\n}\n", "idx": 18067, "_split": "test", "_hash": "d5b9675e108dde081d0fbab19796c2d3"}
{"project": "qemu", "commit_id": "fef6070eff233400015cede968b0afe46c80bb0f", "target": 0, "func": "static int create_fixed_disk(int fd, uint8_t *buf, int64_t total_size)\n\n{\n\n    int ret = -EIO;\n\n\n\n    /* Add footer to total size */\n\n    total_size += 512;\n\n    if (ftruncate(fd, total_size) != 0) {\n\n        ret = -errno;\n\n        goto fail;\n\n    }\n\n    if (lseek(fd, -512, SEEK_END) < 0) {\n\n        goto fail;\n\n    }\n\n    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {\n\n        goto fail;\n\n    }\n\n\n\n    ret = 0;\n\n\n\n fail:\n\n    return ret;\n\n}\n", "idx": 18138, "_split": "test", "_hash": "da3f8dfa4bae2652fb621b565cffa3a2"}
{"project": "qemu", "commit_id": "2c30dd744aa02d31a8a3b87daaba0b2cb774f346", "target": 0, "func": "static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,\n\n                           struct dirent *entry,\n\n                           struct dirent **result)\n\n{\n\n    return readdir_r(fs->dir, entry, result);\n\n}\n", "idx": 18142, "_split": "test", "_hash": "3ec98505929a3175dfe60d924d8282fc"}
{"project": "qemu", "commit_id": "368d25881c94f9e09ef19a3d93e8fec797dbcd05", "target": 0, "func": "static int zrle_send_framebuffer_update(VncState *vs, int x, int y,\n\n                                        int w, int h)\n\n{\n\n    bool be = !!(vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG);\n\n    size_t bytes;\n\n    int zywrle_level;\n\n\n\n    if (vs->zrle.type == VNC_ENCODING_ZYWRLE) {\n\n        if (!vs->vd->lossy || vs->tight.quality < 0 || vs->tight.quality == 9) {\n\n            zywrle_level = 0;\n\n            vs->zrle.type = VNC_ENCODING_ZRLE;\n\n        } else if (vs->tight.quality < 3) {\n\n            zywrle_level = 3;\n\n        } else if (vs->tight.quality < 6) {\n\n            zywrle_level = 2;\n\n        } else {\n\n            zywrle_level = 1;\n\n        }\n\n    } else {\n\n        zywrle_level = 0;\n\n    }\n\n\n\n    vnc_zrle_start(vs);\n\n\n\n    switch(vs->clientds.pf.bytes_per_pixel) {\n\n    case 1:\n\n        zrle_encode_8ne(vs, x, y, w, h, zywrle_level);\n\n        break;\n\n\n\n    case 2:\n\n        if (vs->clientds.pf.gmax > 0x1F) {\n\n            if (be) {\n\n                zrle_encode_16be(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_16le(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        } else {\n\n            if (be) {\n\n                zrle_encode_15be(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_15le(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 4:\n\n    {\n\n        bool fits_in_ls3bytes;\n\n        bool fits_in_ms3bytes;\n\n\n\n        fits_in_ls3bytes =\n\n            ((vs->clientds.pf.rmax << vs->clientds.pf.rshift) < (1 << 24) &&\n\n             (vs->clientds.pf.gmax << vs->clientds.pf.gshift) < (1 << 24) &&\n\n             (vs->clientds.pf.bmax << vs->clientds.pf.bshift) < (1 << 24));\n\n\n\n        fits_in_ms3bytes = (vs->clientds.pf.rshift > 7 &&\n\n                            vs->clientds.pf.gshift > 7 &&\n\n                            vs->clientds.pf.bshift > 7);\n\n\n\n        if ((fits_in_ls3bytes && !be) || (fits_in_ms3bytes && be)) {\n\n            if (be) {\n\n                zrle_encode_24abe(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_24ale(vs, x, y, w, h, zywrle_level);\n\n          }\n\n        } else if ((fits_in_ls3bytes && be) || (fits_in_ms3bytes && !be)) {\n\n            if (be) {\n\n                zrle_encode_24bbe(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_24ble(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        } else {\n\n            if (be) {\n\n                zrle_encode_32be(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_32le(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        }\n\n    }\n\n    break;\n\n    }\n\n\n\n    vnc_zrle_stop(vs);\n\n    bytes = zrle_compress_data(vs, Z_DEFAULT_COMPRESSION);\n\n    vnc_framebuffer_update(vs, x, y, w, h, vs->zrle.type);\n\n    vnc_write_u32(vs, bytes);\n\n    vnc_write(vs, vs->zrle.zlib.buffer, vs->zrle.zlib.offset);\n\n    return 1;\n\n}\n", "idx": 18150, "_split": "test", "_hash": "d11c485aa8f4665f799416cffb84cc8e"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t addr,\n\n                                     unsigned size)\n\n{\n\n    MMIOState *s= opaque;\n\n    return ide_status_read(&s->bus, 0);\n\n}\n", "idx": 18159, "_split": "test", "_hash": "7bc99568545639bb2fa71074c0a86579"}
{"project": "qemu", "commit_id": "e37e6ee6e100ebc355b4a48ae9a7802b38b8dac0", "target": 0, "func": "void tlb_flush_page(CPUState *env, target_ulong addr)\n\n{\n\n    int i;\n\n\n\n#if defined(DEBUG_TLB)\n\n    printf(\"tlb_flush_page: \" TARGET_FMT_lx \"\\n\", addr);\n\n#endif\n\n    /* must reset current TB so that interrupts cannot modify the\n\n       links while we are modifying them */\n\n    env->current_tb = NULL;\n\n\n\n    addr &= TARGET_PAGE_MASK;\n\n    i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    tlb_flush_entry(&env->tlb_table[0][i], addr);\n\n    tlb_flush_entry(&env->tlb_table[1][i], addr);\n\n#if (NB_MMU_MODES >= 3)\n\n    tlb_flush_entry(&env->tlb_table[2][i], addr);\n\n#if (NB_MMU_MODES == 4)\n\n    tlb_flush_entry(&env->tlb_table[3][i], addr);\n\n#endif\n\n#endif\n\n\n\n    tlb_flush_jmp_cache(env, addr);\n\n\n\n#ifdef USE_KQEMU\n\n    if (env->kqemu_enabled) {\n\n        kqemu_flush_page(env, addr);\n\n    }\n\n#endif\n\n}\n", "idx": 18161, "_split": "test", "_hash": "e0b8a774bd3488cbe7c230ae13e14be9"}
{"project": "qemu", "commit_id": "5e003f17ec518cd96f5d2ac23ce9e14144426235", "target": 1, "func": "static int init_blk_migration(QEMUFile *f)\n\n{\n\n    BlockDriverState *bs;\n\n    BlkMigDevState *bmds;\n\n    int64_t sectors;\n\n    BdrvNextIterator it;\n\n    int i, num_bs = 0;\n\n    struct {\n\n        BlkMigDevState *bmds;\n\n        BlockDriverState *bs;\n\n    } *bmds_bs;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    block_mig_state.submitted = 0;\n\n    block_mig_state.read_done = 0;\n\n    block_mig_state.transferred = 0;\n\n    block_mig_state.total_sector_sum = 0;\n\n    block_mig_state.prev_progress = -1;\n\n    block_mig_state.bulk_completed = 0;\n\n    block_mig_state.zero_blocks = migrate_zero_blocks();\n\n\n\n    for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {\n\n        num_bs++;\n\n    }\n\n    bmds_bs = g_malloc0(num_bs * sizeof(*bmds_bs));\n\n\n\n    for (i = 0, bs = bdrv_first(&it); bs; bs = bdrv_next(&it), i++) {\n\n        if (bdrv_is_read_only(bs)) {\n\n            continue;\n\n        }\n\n\n\n        sectors = bdrv_nb_sectors(bs);\n\n        if (sectors <= 0) {\n\n            ret = sectors;\n\n\n            goto out;\n\n        }\n\n\n\n        bmds = g_new0(BlkMigDevState, 1);\n\n        bmds->blk = blk_new(BLK_PERM_CONSISTENT_READ, BLK_PERM_ALL);\n\n        bmds->blk_name = g_strdup(bdrv_get_device_name(bs));\n\n        bmds->bulk_completed = 0;\n\n        bmds->total_sectors = sectors;\n\n        bmds->completed_sectors = 0;\n\n        bmds->shared_base = migrate_use_block_incremental();\n\n\n\n        assert(i < num_bs);\n\n        bmds_bs[i].bmds = bmds;\n\n        bmds_bs[i].bs = bs;\n\n\n\n        block_mig_state.total_sector_sum += sectors;\n\n\n\n        if (bmds->shared_base) {\n\n            DPRINTF(\"Start migration for %s with shared base image\\n\",\n\n                    bdrv_get_device_name(bs));\n\n        } else {\n\n            DPRINTF(\"Start full migration for %s\\n\", bdrv_get_device_name(bs));\n\n        }\n\n\n\n        QSIMPLEQ_INSERT_TAIL(&block_mig_state.bmds_list, bmds, entry);\n\n    }\n\n\n\n    /* Can only insert new BDSes now because doing so while iterating block\n\n     * devices may end up in a deadlock (iterating the new BDSes, too). */\n\n    for (i = 0; i < num_bs; i++) {\n\n        BlkMigDevState *bmds = bmds_bs[i].bmds;\n\n        BlockDriverState *bs = bmds_bs[i].bs;\n\n\n\n        if (bmds) {\n\n            ret = blk_insert_bs(bmds->blk, bs, &local_err);\n\n            if (ret < 0) {\n\n                error_report_err(local_err);\n\n                goto out;\n\n            }\n\n\n\n            alloc_aio_bitmap(bmds);\n\n            error_setg(&bmds->blocker, \"block device is in use by migration\");\n\n            bdrv_op_block_all(bs, bmds->blocker);\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    g_free(bmds_bs);\n\n    return ret;\n\n}", "idx": 18187, "_split": "test", "_hash": "fc08c012635278f32164e7e8ed2bd238"}
{"project": "qemu", "commit_id": "6baebed7698a37a0ac5168faf26023426b0ac940", "target": 1, "func": "static int find_dirty_height(VncState *vs, int y, int last_x, int x)\n\n{\n\n    int h;\n\n\n\n    for (h = 1; h < (vs->serverds.height - y); h++) {\n\n        int tmp_x;\n\n        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))\n\n            break;\n\n        for (tmp_x = last_x; tmp_x < x; tmp_x++)\n\n            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);\n\n    }\n\n\n\n    return h;\n\n}\n", "idx": 18194, "_split": "test", "_hash": "bb38ead8750611158e95a83524c69882"}
{"project": "qemu", "commit_id": "a0067da1577e3eb0c60758384282568f4b2328fe", "target": 1, "func": "static void test_dispatch_cmd_failure(void)\n\n{\n\n    QDict *req = qdict_new();\n\n\n    QObject *resp;\n\n\n\n    qdict_put_obj(req, \"execute\", QOBJECT(qstring_from_str(\"user_def_cmd2\")));\n\n\n\n    resp = qmp_dispatch(QOBJECT(req));\n\n    assert(resp != NULL);\n\n    assert(qdict_haskey(qobject_to_qdict(resp), \"error\"));\n\n\n\n    qobject_decref(resp);\n\n    QDECREF(req);\n\n\n\n    /* check that with extra arguments it throws an error */\n\n    req = qdict_new();\n\n    qdict_put(args, \"a\", qint_from_int(66));\n\n    qdict_put(req, \"arguments\", args);\n\n\n\n    qdict_put_obj(req, \"execute\", QOBJECT(qstring_from_str(\"user_def_cmd\")));\n\n\n\n    resp = qmp_dispatch(QOBJECT(req));\n\n    assert(resp != NULL);\n\n    assert(qdict_haskey(qobject_to_qdict(resp), \"error\"));\n\n\n\n    qobject_decref(resp);\n\n    QDECREF(req);\n\n}", "idx": 18195, "_split": "test", "_hash": "cb46d88e57b56062d1187687d80199fb"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_uint64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint64_t *v = pv;\n\n    qemu_put_be64s(f, v);\n\n}\n", "idx": 18211, "_split": "test", "_hash": "0097146c77da495f3002961f35b78202"}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "QJSON *qjson_new(void)\n\n{\n\n    QJSON *json = QJSON(object_new(TYPE_QJSON));\n\n    return json;\n\n}\n", "idx": 18220, "_split": "test", "_hash": "c1d0c612a712889164575c8ba3dd2204"}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void kqemu_record_dump(void)\n\n{\n\n    PCRecord **pr, *r;\n\n    int i, h;\n\n    FILE *f;\n\n    int64_t total, sum;\n\n\n\n    pr = malloc(sizeof(PCRecord *) * nb_pc_records);\n\n    i = 0;\n\n    total = 0;\n\n    for(h = 0; h < PC_REC_HASH_SIZE; h++) {\n\n        for(r = pc_rec_hash[h]; r != NULL; r = r->next) {\n\n            pr[i++] = r;\n\n            total += r->count;\n\n        }\n\n    }\n\n    qsort(pr, nb_pc_records, sizeof(PCRecord *), pc_rec_cmp);\n\n\n\n    f = fopen(\"/tmp/kqemu.stats\", \"w\");\n\n    if (!f) {\n\n        perror(\"/tmp/kqemu.stats\");\n\n        exit(1);\n\n    }\n\n    fprintf(f, \"total: %\" PRId64 \"\\n\", total);\n\n    sum = 0;\n\n    for(i = 0; i < nb_pc_records; i++) {\n\n        r = pr[i];\n\n        sum += r->count;\n\n        fprintf(f, \"%08lx: %\" PRId64 \" %0.2f%% %0.2f%%\\n\",\n\n                r->pc,\n\n                r->count,\n\n                (double)r->count / (double)total * 100.0,\n\n                (double)sum / (double)total * 100.0);\n\n    }\n\n    fclose(f);\n\n    free(pr);\n\n\n\n    kqemu_record_flush();\n\n}\n", "idx": 18231, "_split": "test", "_hash": "81886ec0d3227480ed884605f49efc4f"}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void pcnet_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    PCNetState *s = opaque;\n\n    int is_padr = 0, is_bcast = 0, is_ladr = 0;\n\n    uint8_t buf1[60];\n\n    int remaining;\n\n    int crc_err = 0;\n\n\n\n    if (CSR_DRX(s) || CSR_STOP(s) || CSR_SPND(s) || !size)\n\n        return;\n\n\n\n#ifdef PCNET_DEBUG\n\n    printf(\"pcnet_receive size=%d\\n\", size);\n\n#endif\n\n\n\n    /* if too small buffer, then expand it */\n\n    if (size < MIN_BUF_SIZE) {\n\n        memcpy(buf1, buf, size);\n\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n\n        buf = buf1;\n\n        size = MIN_BUF_SIZE;\n\n    }\n\n\n\n    if (CSR_PROM(s)\n\n        || (is_padr=padr_match(s, buf, size))\n\n        || (is_bcast=padr_bcast(s, buf, size))\n\n        || (is_ladr=ladr_match(s, buf, size))) {\n\n\n\n        pcnet_rdte_poll(s);\n\n\n\n        if (!(CSR_CRST(s) & 0x8000) && s->rdra) {\n\n            struct pcnet_RMD rmd;\n\n            int rcvrc = CSR_RCVRC(s)-1,i;\n\n            target_phys_addr_t nrda;\n\n            for (i = CSR_RCVRL(s)-1; i > 0; i--, rcvrc--) {\n\n                if (rcvrc <= 1)\n\n                    rcvrc = CSR_RCVRL(s);\n\n                nrda = s->rdra +\n\n                    (CSR_RCVRL(s) - rcvrc) *\n\n                    (BCR_SWSTYLE(s) ? 16 : 8 );\n\n                RMDLOAD(&rmd, nrda);\n\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n#ifdef PCNET_DEBUG_RMD\n\n                    printf(\"pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d\\n\",\n\n                                rcvrc, CSR_RCVRC(s));\n\n#endif\n\n                    CSR_RCVRC(s) = rcvrc;\n\n                    pcnet_rdte_poll(s);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (!(CSR_CRST(s) & 0x8000)) {\n\n#ifdef PCNET_DEBUG_RMD\n\n            printf(\"pcnet - no buffer: RCVRC=%d\\n\", CSR_RCVRC(s));\n\n#endif\n\n            s->csr[0] |= 0x1000; /* Set MISS flag */\n\n            CSR_MISSC(s)++;\n\n        } else {\n\n            uint8_t *src = s->buffer;\n\n            target_phys_addr_t crda = CSR_CRDA(s);\n\n            struct pcnet_RMD rmd;\n\n            int pktcount = 0;\n\n\n\n            if (!s->looptest) {\n\n                memcpy(src, buf, size);\n\n                /* no need to compute the CRC */\n\n                src[size] = 0;\n\n                src[size + 1] = 0;\n\n                src[size + 2] = 0;\n\n                src[size + 3] = 0;\n\n                size += 4;\n\n            } else if (s->looptest == PCNET_LOOPTEST_CRC ||\n\n                       !CSR_DXMTFCS(s) || size < MIN_BUF_SIZE+4) {\n\n                uint32_t fcs = ~0;\n\n                uint8_t *p = src;\n\n\n\n                while (p != &src[size])\n\n                    CRC(fcs, *p++);\n\n                *(uint32_t *)p = htonl(fcs);\n\n                size += 4;\n\n            } else {\n\n                uint32_t fcs = ~0;\n\n                uint8_t *p = src;\n\n\n\n                while (p != &src[size-4])\n\n                    CRC(fcs, *p++);\n\n                crc_err = (*(uint32_t *)p != htonl(fcs));\n\n            }\n\n\n\n#ifdef PCNET_DEBUG_MATCH\n\n            PRINT_PKTHDR(buf);\n\n#endif\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            /*if (!CSR_LAPPEN(s))*/\n\n                SET_FIELD(&rmd.status, RMDS, STP, 1);\n\n\n\n#define PCNET_RECV_STORE() do {                                 \\\n\n    int count = MIN(4096 - GET_FIELD(rmd.buf_length, RMDL, BCNT),remaining); \\\n\n    target_phys_addr_t rbadr = PHYSADDR(s, rmd.rbadr);          \\\n\n    s->phys_mem_write(s->dma_opaque, rbadr, src, count, CSR_BSWP(s)); \\\n\n    src += count; remaining -= count;                           \\\n\n    SET_FIELD(&rmd.status, RMDS, OWN, 0);                       \\\n\n    RMDSTORE(&rmd, PHYSADDR(s,crda));                           \\\n\n    pktcount++;                                                 \\\n\n} while (0)\n\n\n\n            remaining = size;\n\n            PCNET_RECV_STORE();\n\n            if ((remaining > 0) && CSR_NRDA(s)) {\n\n                target_phys_addr_t nrda = CSR_NRDA(s);\n\n#ifdef PCNET_DEBUG_RMD\n\n                PRINT_RMD(&rmd);\n\n#endif\n\n                RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n                    crda = nrda;\n\n                    PCNET_RECV_STORE();\n\n#ifdef PCNET_DEBUG_RMD\n\n                    PRINT_RMD(&rmd);\n\n#endif\n\n                    if ((remaining > 0) && (nrda=CSR_NNRD(s))) {\n\n                        RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                        if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n                            crda = nrda;\n\n                            PCNET_RECV_STORE();\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n\n\n#undef PCNET_RECV_STORE\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            if (remaining == 0) {\n\n                SET_FIELD(&rmd.msg_length, RMDM, MCNT, size);\n\n                SET_FIELD(&rmd.status, RMDS, ENP, 1);\n\n                SET_FIELD(&rmd.status, RMDS, PAM, !CSR_PROM(s) && is_padr);\n\n                SET_FIELD(&rmd.status, RMDS, LFAM, !CSR_PROM(s) && is_ladr);\n\n                SET_FIELD(&rmd.status, RMDS, BAM, !CSR_PROM(s) && is_bcast);\n\n                if (crc_err) {\n\n                    SET_FIELD(&rmd.status, RMDS, CRC, 1);\n\n                    SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n                }\n\n            } else {\n\n                SET_FIELD(&rmd.status, RMDS, OFLO, 1);\n\n                SET_FIELD(&rmd.status, RMDS, BUFF, 1);\n\n                SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n            }\n\n            RMDSTORE(&rmd, PHYSADDR(s,crda));\n\n            s->csr[0] |= 0x0400;\n\n\n\n#ifdef PCNET_DEBUG\n\n            printf(\"RCVRC=%d CRDA=0x%08x BLKS=%d\\n\",\n\n                CSR_RCVRC(s), PHYSADDR(s,CSR_CRDA(s)), pktcount);\n\n#endif\n\n#ifdef PCNET_DEBUG_RMD\n\n            PRINT_RMD(&rmd);\n\n#endif\n\n\n\n            while (pktcount--) {\n\n                if (CSR_RCVRC(s) <= 1)\n\n                    CSR_RCVRC(s) = CSR_RCVRL(s);\n\n                else\n\n                    CSR_RCVRC(s)--;\n\n            }\n\n\n\n            pcnet_rdte_poll(s);\n\n\n\n        }\n\n    }\n\n\n\n    pcnet_poll(s);\n\n    pcnet_update_irq(s);\n\n}\n", "idx": 18254, "_split": "test", "_hash": "788bef4a1452bf7004873d5b54c725fc"}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static void nbd_reply_ready(void *opaque)\n\n{\n\n    NbdClientSession *s = opaque;\n\n    uint64_t i;\n\n    int ret;\n\n\n\n    if (s->reply.handle == 0) {\n\n        /* No reply already in flight.  Fetch a header.  It is possible\n\n         * that another thread has done the same thing in parallel, so\n\n         * the socket is not readable anymore.\n\n         */\n\n        ret = nbd_receive_reply(s->sock, &s->reply);\n\n        if (ret == -EAGAIN) {\n\n            return;\n\n        }\n\n        if (ret < 0) {\n\n            s->reply.handle = 0;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* There's no need for a mutex on the receive side, because the\n\n     * handler acts as a synchronization point and ensures that only\n\n     * one coroutine is called until the reply finishes.  */\n\n    i = HANDLE_TO_INDEX(s, s->reply.handle);\n\n    if (i >= MAX_NBD_REQUESTS) {\n\n        goto fail;\n\n    }\n\n\n\n    if (s->recv_coroutine[i]) {\n\n        qemu_coroutine_enter(s->recv_coroutine[i], NULL);\n\n        return;\n\n    }\n\n\n\nfail:\n\n    nbd_teardown_connection(s);\n\n}\n", "idx": 18267, "_split": "test", "_hash": "8fc3753c9c912133d7aa6e4462c24229"}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,\n\n                struct vmsvga_cursor_definition_s *c)\n\n{\n\n    QEMUCursor *qc;\n\n    int i, pixels;\n\n\n\n    qc = cursor_alloc(c->width, c->height);\n\n    qc->hot_x = c->hot_x;\n\n    qc->hot_y = c->hot_y;\n\n    switch (c->bpp) {\n\n    case 1:\n\n        cursor_set_mono(qc, 0xffffff, 0x000000, (void*)c->image,\n\n                        1, (void*)c->mask);\n\n#ifdef DEBUG\n\n        cursor_print_ascii_art(qc, \"vmware/mono\");\n\n#endif\n\n        break;\n\n    case 32:\n\n        /* fill alpha channel from mask, set color to zero */\n\n        cursor_set_mono(qc, 0x000000, 0x000000, (void*)c->mask,\n\n                        1, (void*)c->mask);\n\n        /* add in rgb values */\n\n        pixels = c->width * c->height;\n\n        for (i = 0; i < pixels; i++) {\n\n            qc->data[i] |= c->image[i] & 0xffffff;\n\n        }\n\n#ifdef DEBUG\n\n        cursor_print_ascii_art(qc, \"vmware/32bit\");\n\n#endif\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: unhandled bpp %d, using fallback cursor\\n\",\n\n                __FUNCTION__, c->bpp);\n\n        cursor_put(qc);\n\n        qc = cursor_builtin_left_ptr();\n\n    }\n\n\n\n    dpy_cursor_define(s->vga.ds, qc);\n\n    cursor_put(qc);\n\n}\n", "idx": 18272, "_split": "test", "_hash": "13d807e2344080a566eeaead898cc98c"}
{"project": "qemu", "commit_id": "6ca8d0fd51154c37b571ea74dd0b3e7a60ab847a", "target": 0, "func": "static void set_proc_name(const char *s)\n\n{\n\n#ifdef __linux__\n\n    char name[16];\n\n    if (!s)\n\n        return;\n\n    name[sizeof(name) - 1] = 0;\n\n    strncpy(name, s, sizeof(name));\n\n    /* Could rewrite argv[0] too, but that's a bit more complicated.\n\n       This simple way is enough for `top'. */\n\n    prctl(PR_SET_NAME, name);\n\n#endif    \t\n\n}\n", "idx": 18282, "_split": "test", "_hash": "46ca6eea082f33ec3877c6ff1e283aa7"}
{"project": "qemu", "commit_id": "b1b27b64262fdace45e5ab134c4438338076cb98", "target": 1, "func": "int nbd_client_session_co_flush(NbdClientSession *client)\n\n{\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n\n\n    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {\n\n        return 0;\n\n    }\n\n\n\n    request.type = NBD_CMD_FLUSH;\n\n    if (client->nbdflags & NBD_FLAG_SEND_FUA) {\n\n        request.type |= NBD_CMD_FLAG_FUA;\n\n    }\n\n\n\n    request.from = 0;\n\n    request.len = 0;\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(client, &request, NULL, 0);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, NULL, 0);\n\n    }\n\n    nbd_coroutine_end(client, &request);\n\n    return -reply.error;\n\n}\n", "idx": 18285, "_split": "test", "_hash": "67b4fed6925b3772d8b54463e8768dbb"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)\n\n{\n\n    f->xfer_limit = limit;\n\n}\n", "idx": 18326, "_split": "test", "_hash": "91a6563edb45ec2e482a9b2cf3b34de3"}
{"project": "qemu", "commit_id": "a9fc37f6bc3f2ab90585cb16493da9f6dcfbfbcf", "target": 1, "func": "static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,\n\n                                    Error **errp)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    QBool *qbool;\n\n\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    qbool = qobject_to_qbool(qobj);\n\n    if (!qbool) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"boolean\");\n\n        return;\n\n    }\n\n\n\n    *obj = qbool_get_bool(qbool);\n\n}\n", "idx": 18329, "_split": "test", "_hash": "6cdd3fbd8c0503acee372b47a79519e8"}
{"project": "qemu", "commit_id": "860643bc5aa902f9b736c57b66e301ef08a2b68e", "target": 0, "func": "int kvm_arch_get_registers(CPUState *cs)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    CPUS390XState *env = &cpu->env;\n\n    struct kvm_one_reg reg;\n\n    struct kvm_sregs sregs;\n\n    struct kvm_regs regs;\n\n    int i, r;\n\n\n\n    /* get the PSW */\n\n    env->psw.addr = cs->kvm_run->psw_addr;\n\n    env->psw.mask = cs->kvm_run->psw_mask;\n\n\n\n    /* the GPRS */\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_GPRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            env->regs[i] = cs->kvm_run->s.regs.gprs[i];\n\n        }\n\n    } else {\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_REGS, &regs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n         for (i = 0; i < 16; i++) {\n\n            env->regs[i] = regs.gprs[i];\n\n        }\n\n    }\n\n\n\n    /* The ACRS and CRS */\n\n    if (cap_sync_regs &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_ACRS &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_CRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            env->aregs[i] = cs->kvm_run->s.regs.acrs[i];\n\n            env->cregs[i] = cs->kvm_run->s.regs.crs[i];\n\n        }\n\n    } else {\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_SREGS, &sregs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n         for (i = 0; i < 16; i++) {\n\n            env->aregs[i] = sregs.acrs[i];\n\n            env->cregs[i] = sregs.crs[i];\n\n        }\n\n    }\n\n\n\n    /* The prefix */\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_PREFIX) {\n\n        env->psa = cs->kvm_run->s.regs.prefix;\n\n    }\n\n\n\n    /* One Regs */\n\n    reg.id = KVM_REG_S390_CPU_TIMER;\n\n    reg.addr = (__u64)&(env->cputm);\n\n    r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    reg.id = KVM_REG_S390_CLOCK_COMP;\n\n    reg.addr = (__u64)&(env->ckc);\n\n    r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    reg.id = KVM_REG_S390_TODPR;\n\n    reg.addr = (__u64)&(env->todpr);\n\n    r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    if (cap_async_pf) {\n\n        reg.id = KVM_REG_S390_PFTOKEN;\n\n        reg.addr = (__u64)&(env->pfault_token);\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n\n\n        reg.id = KVM_REG_S390_PFCOMPARE;\n\n        reg.addr = (__u64)&(env->pfault_compare);\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n\n\n        reg.id = KVM_REG_S390_PFSELECT;\n\n        reg.addr = (__u64)&(env->pfault_select);\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 18344, "_split": "test", "_hash": "d4a6e5477bf55a747359d3bd8b3ba1f7"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int select_watchdog(const char *p)\n\n{\n\n    WatchdogTimerModel *model;\n\n    QemuOpts *opts;\n\n\n\n    /* -watchdog ? lists available devices and exits cleanly. */\n\n    if (strcmp(p, \"?\") == 0) {\n\n        LIST_FOREACH(model, &watchdog_list, entry) {\n\n            fprintf(stderr, \"\\t%s\\t%s\\n\",\n\n                     model->wdt_name, model->wdt_description);\n\n        }\n\n        return 2;\n\n    }\n\n\n\n    LIST_FOREACH(model, &watchdog_list, entry) {\n\n        if (strcasecmp(model->wdt_name, p) == 0) {\n\n            /* add the device */\n\n            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);\n\n            qemu_opt_set(opts, \"driver\", p);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    fprintf(stderr, \"Unknown -watchdog device. Supported devices are:\\n\");\n\n    LIST_FOREACH(model, &watchdog_list, entry) {\n\n        fprintf(stderr, \"\\t%s\\t%s\\n\",\n\n                 model->wdt_name, model->wdt_description);\n\n    }\n\n    return 1;\n\n}\n", "idx": 18345, "_split": "test", "_hash": "35637e022b08518a1e472d845266c2e5"}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtIOBalloon *s = VIRTIO_BALLOON(vdev);\n\n    VirtQueueElement elem;\n\n    MemoryRegionSection section;\n\n\n\n    while (virtqueue_pop(vq, &elem)) {\n\n        size_t offset = 0;\n\n        uint32_t pfn;\n\n\n\n        while (iov_to_buf(elem.out_sg, elem.out_num, offset, &pfn, 4) == 4) {\n\n            ram_addr_t pa;\n\n            ram_addr_t addr;\n\n            int p = virtio_ldl_p(vdev, &pfn);\n\n\n\n            pa = (ram_addr_t) p << VIRTIO_BALLOON_PFN_SHIFT;\n\n            offset += 4;\n\n\n\n            /* FIXME: remove get_system_memory(), but how? */\n\n            section = memory_region_find(get_system_memory(), pa, 1);\n\n            if (!int128_nz(section.size) || !memory_region_is_ram(section.mr))\n\n                continue;\n\n\n\n            trace_virtio_balloon_handle_output(memory_region_name(section.mr),\n\n                                               pa);\n\n            /* Using memory_region_get_ram_ptr is bending the rules a bit, but\n\n               should be OK because we only want a single page.  */\n\n            addr = section.offset_within_region;\n\n            balloon_page(memory_region_get_ram_ptr(section.mr) + addr,\n\n                         !!(vq == s->dvq));\n\n            memory_region_unref(section.mr);\n\n        }\n\n\n\n        virtqueue_push(vq, &elem, offset);\n\n        virtio_notify(vdev, vq);\n\n    }\n\n}\n", "idx": 18351, "_split": "test", "_hash": "4e80d61676b06bfd7d2ec74c1afec3de"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void blk_send(QEMUFile *f, BlkMigBlock * blk)\n\n{\n\n    int len;\n\n    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;\n\n\n\n    if (block_mig_state.zero_blocks &&\n\n        buffer_is_zero(blk->buf, BLOCK_SIZE)) {\n\n        flags |= BLK_MIG_FLAG_ZERO_BLOCK;\n\n    }\n\n\n\n    /* sector number and flags */\n\n    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)\n\n                     | flags);\n\n\n\n    /* device name */\n\n    len = strlen(bdrv_get_device_name(blk->bmds->bs));\n\n    qemu_put_byte(f, len);\n\n    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);\n\n\n\n    /* if a block is zero we need to flush here since the network\n\n     * bandwidth is now a lot higher than the storage device bandwidth.\n\n     * thus if we queue zero blocks we slow down the migration */\n\n    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {\n\n        qemu_fflush(f);\n\n        return;\n\n    }\n\n\n\n    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);\n\n}\n", "idx": 18384, "_split": "test", "_hash": "17bcaeb20d128ebfe894a2ce0db6ac68"}
{"project": "qemu", "commit_id": "e5d9adbdab972a2172815c1174aed3fabcc448f1", "target": 1, "func": "int64_t qmp_guest_fsfreeze_freeze(Error **err)\n\n{\n\n    int ret = 0, i = 0;\n\n    FsMountList mounts;\n\n    struct FsMount *mount;\n\n    Error *local_err = NULL;\n\n    int fd;\n\n\n\n    slog(\"guest-fsfreeze called\");\n\n\n\n    execute_fsfreeze_hook(FSFREEZE_HOOK_FREEZE, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(err, local_err);\n\n        return -1;\n\n    }\n\n\n\n    QTAILQ_INIT(&mounts);\n\n    build_fs_mount_list(&mounts, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(err, local_err);\n\n        return -1;\n\n    }\n\n\n\n    /* cannot risk guest agent blocking itself on a write in this state */\n\n    ga_set_frozen(ga_state);\n\n\n\n    QTAILQ_FOREACH(mount, &mounts, next) {\n\n        fd = qemu_open(mount->dirname, O_RDONLY);\n\n        if (fd == -1) {\n\n            error_setg_errno(err, errno, \"failed to open %s\", mount->dirname);\n\n            goto error;\n\n        }\n\n\n\n        /* we try to cull filesytems we know won't work in advance, but other\n\n         * filesytems may not implement fsfreeze for less obvious reasons.\n\n         * these will report EOPNOTSUPP. we simply ignore these when tallying\n\n         * the number of frozen filesystems.\n\n         *\n\n         * any other error means a failure to freeze a filesystem we\n\n         * expect to be freezable, so return an error in those cases\n\n         * and return system to thawed state.\n\n         */\n\n        ret = ioctl(fd, FIFREEZE);\n\n        if (ret == -1) {\n\n            if (errno != EOPNOTSUPP) {\n\n                error_setg_errno(err, errno, \"failed to freeze %s\",\n\n                                 mount->dirname);\n\n                close(fd);\n\n                goto error;\n\n            }\n\n        } else {\n\n            i++;\n\n        }\n\n        close(fd);\n\n    }\n\n\n\n    free_fs_mount_list(&mounts);\n\n    return i;\n\n\n\nerror:\n\n    free_fs_mount_list(&mounts);\n\n    qmp_guest_fsfreeze_thaw(NULL);\n\n    return 0;\n\n}\n", "idx": 18409, "_split": "test", "_hash": "fe253a42c3101ec647271e4712ccafbc"}
{"project": "qemu", "commit_id": "ccbcfedd17fd2d13521fcee66810d0df464ec1cc", "target": 1, "func": "int qemu_devtree_setprop_string(void *fdt, const char *node_path,\n\n                                const char *property, const char *string)\n\n{\n\n    int offset;\n\n\n\n    offset = fdt_path_offset(fdt, node_path);\n\n    if (offset < 0)\n\n        return offset;\n\n\n\n    return fdt_setprop_string(fdt, offset, property, string);\n\n}\n", "idx": 18412, "_split": "test", "_hash": "350fd36de701b027ba7c09603d58d0d3"}
{"project": "qemu", "commit_id": "4c8449832c0add27b898e657a9e7e8603f44157c", "target": 1, "func": "static void external_snapshot_commit(BlkActionState *common)\n\n{\n\n    ExternalSnapshotState *state =\n\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n\n\n\n    bdrv_set_aio_context(state->new_bs, state->aio_context);\n\n\n\n    /* This removes our old bs and adds the new bs */\n\n    bdrv_append(state->new_bs, state->old_bs);\n\n    /* We don't need (or want) to use the transactional\n\n     * bdrv_reopen_multiple() across all the entries at once, because we\n\n     * don't want to abort all of them if one of them fails the reopen */\n\n    bdrv_reopen(state->old_bs, state->old_bs->open_flags & ~BDRV_O_RDWR,\n\n                NULL);\n\n}\n", "idx": 18437, "_split": "test", "_hash": "9616fdf09ed2394734645f04cb5a03bf"}
{"project": "qemu", "commit_id": "c627e7526a902dd5bb1907dbbd5cf961679dfa68", "target": 1, "func": "static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)\n\n{\n\n    if (index < MAX_TL_ENTRIES) {\n\n        memory_region_set_enabled(&s->dma_mrs[index], false);\n\n    }\n\n\n\n    if (!frame) {\n\n        return;\n\n    }\n\n\n\n    if (index >= MAX_TL_ENTRIES) {\n\n        qemu_log_mask(LOG_UNIMP,\n\n                      \"rc4030: trying to use too high \"\n\n                      \"translation table entry %d (max allowed=%d)\",\n\n                      index, MAX_TL_ENTRIES);\n\n        return;\n\n    }\n\n    memory_region_set_alias_offset(&s->dma_mrs[index], frame);\n\n    memory_region_set_enabled(&s->dma_mrs[index], true);\n\n}\n", "idx": 18439, "_split": "test", "_hash": "53bf29fbc913e8cc84c7f6b3b4018e48"}
{"project": "qemu", "commit_id": "71407786054cad26de7ef66718b2a57a4bcb49b5", "target": 1, "func": "static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,\n\n                                              VirtQueue *vq)\n\n{\n\n    VirtIOSCSI *s = (VirtIOSCSI *)vdev;\n\n\n\n    assert(s->ctx && s->dataplane_started);\n\n    return virtio_scsi_handle_cmd_vq(s, vq);\n\n}\n", "idx": 18447, "_split": "test", "_hash": "f9d4f15f6861f473846322279ab57245"}
{"project": "qemu", "commit_id": "1a20a032ccbb5800bfdfc75accfcff2ac67f5bcb", "target": 1, "func": "USBDevice *usb_host_device_open(const char *devname)\n\n{\n\n    struct usb_device_info bus_info, dev_info;\n\n    USBDevice *d = NULL;\n\n    USBHostDevice *dev;\n\n    char ctlpath[PATH_MAX + 1];\n\n    char buspath[PATH_MAX + 1];\n\n    int bfd, dfd, bus, address, i;\n\n    int ugendebug = UGEN_DEBUG_LEVEL;\n\n\n\n    if (usb_host_find_device(&bus, &address, devname) < 0)\n\n        return NULL;\n\n\n\n    snprintf(buspath, PATH_MAX, \"/dev/usb%d\", bus);\n\n\n\n    bfd = open(buspath, O_RDWR);\n\n    if (bfd < 0) {\n\n#ifdef DEBUG\n\n        printf(\"usb_host_device_open: failed to open usb bus - %s\\n\",\n\n               strerror(errno));\n\n#endif\n\n        return NULL;\n\n    }\n\n\n\n    bus_info.udi_addr = address;\n\n    if (ioctl(bfd, USB_DEVICEINFO, &bus_info) < 0) {\n\n#ifdef DEBUG\n\n        printf(\"usb_host_device_open: failed to grab bus information - %s\\n\",\n\n               strerror(errno));\n\n#endif\n\n        return NULL;\n\n    }\n\n\n\n#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)\n\n    snprintf(ctlpath, PATH_MAX, \"/dev/%s\", bus_info.udi_devnames[0]);\n\n#else\n\n    snprintf(ctlpath, PATH_MAX, \"/dev/%s.00\", bus_info.udi_devnames[0]);\n\n#endif\n\n\n\n    dfd  = open(ctlpath, O_RDWR);\n\n    if (dfd < 0) {\n\n        dfd = open(ctlpath, O_RDONLY);\n\n        if (dfd < 0) {\n\n#ifdef DEBUG\n\n            printf(\"usb_host_device_open: failed to open usb device %s - %s\\n\",\n\n                   ctlpath, strerror(errno));\n\n#endif\n\n        }\n\n    }\n\n\n\n    if (dfd >= 0) {\n\n        if (ioctl(dfd, USB_GET_DEVICEINFO, &dev_info) < 0) {\n\n#ifdef DEBUG\n\n            printf(\"usb_host_device_open: failed to grab device info - %s\\n\",\n\n                   strerror(errno));\n\n#endif\n\n            goto fail;\n\n        }\n\n\n\n        d = usb_create(NULL /* FIXME */, \"usb-host\");\n\n        dev = DO_UPCAST(USBHostDevice, dev, d);\n\n\n\n        if (dev_info.udi_speed == 1)\n\n            dev->dev.speed = USB_SPEED_LOW - 1;\n\n        else\n\n            dev->dev.speed = USB_SPEED_FULL - 1;\n\n\n\n        if (strncmp(dev_info.udi_product, \"product\", 7) != 0)\n\n            pstrcpy(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                    dev_info.udi_product);\n\n        else\n\n            snprintf(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                     \"host:%s\", devname);\n\n\n\n        pstrcpy(dev->devpath, sizeof(dev->devpath), \"/dev/\");\n\n        pstrcat(dev->devpath, sizeof(dev->devpath), dev_info.udi_devnames[0]);\n\n\n\n        /* Mark the endpoints as not yet open */\n\n        for (i = 0; i < USB_MAX_ENDPOINTS; i++)\n\n           dev->ep_fd[i] = -1;\n\n\n\n        ioctl(dfd, USB_SETDEBUG, &ugendebug);\n\n\n\n        return (USBDevice *)dev;\n\n    }\n\n\n\nfail:\n\n    return NULL;\n\n}\n", "idx": 18457, "_split": "test", "_hash": "e75f65d134554c0cbcc7100026d2acd7"}
{"project": "qemu", "commit_id": "ef4c9fc8542e06b1d567172c04b0c0377c7ab0c5", "target": 1, "func": "int trace_record_start(TraceBufferRecord *rec, TraceEventID event, size_t datasize)\n\n{\n\n    unsigned int idx, rec_off, old_idx, new_idx;\n\n    uint32_t rec_len = sizeof(TraceRecord) + datasize;\n\n    uint64_t event_u64 = event;\n\n    uint64_t timestamp_ns = get_clock();\n\n\n\n    do {\n\n        old_idx = g_atomic_int_get(&trace_idx);\n\n        smp_rmb();\n\n        new_idx = old_idx + rec_len;\n\n\n\n        if (new_idx - writeout_idx > TRACE_BUF_LEN) {\n\n            /* Trace Buffer Full, Event dropped ! */\n\n            g_atomic_int_inc(&dropped_events);\n\n            return -ENOSPC;\n\n        }\n\n    } while (!g_atomic_int_compare_and_exchange(&trace_idx, old_idx, new_idx));\n\n\n\n    idx = old_idx % TRACE_BUF_LEN;\n\n\n\n    rec_off = idx;\n\n    rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));\n\n    rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));\n\n    rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));\n\n    rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));\n\n\n\n    rec->tbuf_idx = idx;\n\n    rec->rec_off  = (idx + sizeof(TraceRecord)) % TRACE_BUF_LEN;\n\n    return 0;\n\n}\n", "idx": 18477, "_split": "test", "_hash": "c029036118ca06a32a08c7c844616bbd"}
{"project": "qemu", "commit_id": "e6afc87f804abee7d0479be5e8e31c56d885fafb", "target": 1, "func": "static float64 roundAndPackFloat64( flag zSign, int16 zExp, uint64_t zSig STATUS_PARAM)\n\n{\n\n    int8 roundingMode;\n\n    flag roundNearestEven;\n\n    int16 roundIncrement, roundBits;\n\n    flag isTiny;\n\n\n\n    roundingMode = STATUS(float_rounding_mode);\n\n    roundNearestEven = ( roundingMode == float_round_nearest_even );\n\n    roundIncrement = 0x200;\n\n    if ( ! roundNearestEven ) {\n\n        if ( roundingMode == float_round_to_zero ) {\n\n            roundIncrement = 0;\n\n        }\n\n        else {\n\n            roundIncrement = 0x3FF;\n\n            if ( zSign ) {\n\n                if ( roundingMode == float_round_up ) roundIncrement = 0;\n\n            }\n\n            else {\n\n                if ( roundingMode == float_round_down ) roundIncrement = 0;\n\n            }\n\n        }\n\n    }\n\n    roundBits = zSig & 0x3FF;\n\n    if ( 0x7FD <= (uint16_t) zExp ) {\n\n        if (    ( 0x7FD < zExp )\n\n             || (    ( zExp == 0x7FD )\n\n                  && ( (int64_t) ( zSig + roundIncrement ) < 0 ) )\n\n           ) {\n\n            float_raise( float_flag_overflow | float_flag_inexact STATUS_VAR);\n\n            return packFloat64( zSign, 0x7FF, - ( roundIncrement == 0 ));\n\n        }\n\n        if ( zExp < 0 ) {\n\n            if ( STATUS(flush_to_zero) ) return packFloat64( zSign, 0, 0 );\n\n            isTiny =\n\n                   ( STATUS(float_detect_tininess) == float_tininess_before_rounding )\n\n                || ( zExp < -1 )\n\n                || ( zSig + roundIncrement < LIT64( 0x8000000000000000 ) );\n\n            shift64RightJamming( zSig, - zExp, &zSig );\n\n            zExp = 0;\n\n            roundBits = zSig & 0x3FF;\n\n            if ( isTiny && roundBits ) float_raise( float_flag_underflow STATUS_VAR);\n\n        }\n\n    }\n\n    if ( roundBits ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n    zSig = ( zSig + roundIncrement )>>10;\n\n    zSig &= ~ ( ( ( roundBits ^ 0x200 ) == 0 ) & roundNearestEven );\n\n    if ( zSig == 0 ) zExp = 0;\n\n    return packFloat64( zSign, zExp, zSig );\n\n\n\n}\n", "idx": 18493, "_split": "test", "_hash": "ab53ff10df4f9365cae28984cbea275e"}
{"project": "qemu", "commit_id": "e0cb42ae4bc4438ba4ec0760df2d830b8759b255", "target": 1, "func": "static void xen_remap_bucket(MapCacheEntry *entry,\n\n                             hwaddr size,\n\n                             hwaddr address_index)\n\n{\n\n    uint8_t *vaddr_base;\n\n    xen_pfn_t *pfns;\n\n    int *err;\n\n    unsigned int i;\n\n    hwaddr nb_pfn = size >> XC_PAGE_SHIFT;\n\n\n\n    trace_xen_remap_bucket(address_index);\n\n\n\n    pfns = g_malloc0(nb_pfn * sizeof (xen_pfn_t));\n\n    err = g_malloc0(nb_pfn * sizeof (int));\n\n\n\n    if (entry->vaddr_base != NULL) {\n\n        if (munmap(entry->vaddr_base, entry->size) != 0) {\n\n            perror(\"unmap fails\");\n\n            exit(-1);\n\n        }\n\n    }\n\n    g_free(entry->valid_mapping);\n\n    entry->valid_mapping = NULL;\n\n\n\n    for (i = 0; i < nb_pfn; i++) {\n\n        pfns[i] = (address_index << (MCACHE_BUCKET_SHIFT-XC_PAGE_SHIFT)) + i;\n\n    }\n\n\n\n    vaddr_base = xc_map_foreign_bulk(xen_xc, xen_domid, PROT_READ|PROT_WRITE,\n\n                                     pfns, err, nb_pfn);\n\n    if (vaddr_base == NULL) {\n\n        perror(\"xc_map_foreign_bulk\");\n\n        exit(-1);\n\n    }\n\n\n\n    entry->vaddr_base = vaddr_base;\n\n    entry->paddr_index = address_index;\n\n    entry->size = size;\n\n    entry->valid_mapping = (unsigned long *) g_malloc0(sizeof(unsigned long) *\n\n            BITS_TO_LONGS(size >> XC_PAGE_SHIFT));\n\n\n\n    bitmap_zero(entry->valid_mapping, nb_pfn);\n\n    for (i = 0; i < nb_pfn; i++) {\n\n        if (!err[i]) {\n\n            bitmap_set(entry->valid_mapping, i, 1);\n\n        }\n\n    }\n\n\n\n    g_free(pfns);\n\n    g_free(err);\n\n}\n", "idx": 18512, "_split": "test", "_hash": "5ab07ab51d355b2e2b2f59f816b0103c"}
{"project": "qemu", "commit_id": "5ac2731cf821a7ecae90786d9052891afb09dfc2", "target": 1, "func": "void usb_packet_complete(USBDevice *dev, USBPacket *p)\n\n{\n\n    USBEndpoint *ep = p->ep;\n\n    int ret;\n\n\n\n    assert(p->state == USB_PACKET_ASYNC);\n\n    assert(QTAILQ_FIRST(&ep->queue) == p);\n\n    usb_packet_set_state(p, USB_PACKET_COMPLETE);\n\n    QTAILQ_REMOVE(&ep->queue, p, queue);\n\n    dev->port->ops->complete(dev->port, p);\n\n\n\n    while (!QTAILQ_EMPTY(&ep->queue)) {\n\n        p = QTAILQ_FIRST(&ep->queue);\n\n        if (p->state == USB_PACKET_ASYNC) {\n\n            break;\n\n        }\n\n        assert(p->state == USB_PACKET_QUEUED);\n\n        ret = usb_process_one(p);\n\n        if (ret == USB_RET_ASYNC) {\n\n            usb_packet_set_state(p, USB_PACKET_ASYNC);\n\n            break;\n\n        }\n\n        p->result = ret;\n\n        usb_packet_set_state(p, USB_PACKET_COMPLETE);\n\n        QTAILQ_REMOVE(&ep->queue, p, queue);\n\n        dev->port->ops->complete(dev->port, p);\n\n    }\n\n}\n", "idx": 18513, "_split": "test", "_hash": "2175fa15edf7fd216b1f1383c3e8b382"}
{"project": "qemu", "commit_id": "ff472a5badf8e6d964455de39ca67ea3a7758dea", "target": 1, "func": "static void cuda_receive_packet(CUDAState *s,\n\n                                const uint8_t *data, int len)\n\n{\n\n    uint8_t obuf[16] = { CUDA_PACKET, 0, data[0] };\n\n    int autopoll;\n\n    uint32_t ti;\n\n\n\n    switch(data[0]) {\n\n    case CUDA_AUTOPOLL:\n\n        autopoll = (data[1] != 0);\n\n        if (autopoll != s->autopoll) {\n\n            s->autopoll = autopoll;\n\n            if (autopoll) {\n\n                timer_mod(s->adb_poll_timer,\n\n                               qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) +\n\n                               (get_ticks_per_sec() / CUDA_ADB_POLL_FREQ));\n\n            } else {\n\n                timer_del(s->adb_poll_timer);\n\n            }\n\n        }\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_GET_6805_ADDR:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_SET_TIME:\n\n        ti = (((uint32_t)data[1]) << 24) + (((uint32_t)data[2]) << 16) + (((uint32_t)data[3]) << 8) + data[4];\n\n        s->tick_offset = ti - (qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) / get_ticks_per_sec());\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_GET_TIME:\n\n        ti = s->tick_offset + (qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) / get_ticks_per_sec());\n\n        obuf[3] = ti >> 24;\n\n        obuf[4] = ti >> 16;\n\n        obuf[5] = ti >> 8;\n\n        obuf[6] = ti;\n\n        cuda_send_packet_to_host(s, obuf, 7);\n\n        break;\n\n    case CUDA_FILE_SERVER_FLAG:\n\n    case CUDA_SET_DEVICE_LIST:\n\n    case CUDA_SET_AUTO_RATE:\n\n    case CUDA_SET_POWER_MESSAGES:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_POWERDOWN:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        qemu_system_shutdown_request();\n\n        break;\n\n    case CUDA_RESET_SYSTEM:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        qemu_system_reset_request();\n\n        break;\n\n    case CUDA_COMBINED_FORMAT_IIC:\n\n\n        obuf[1] = 0x5;\n\n\n\n\n        break;\n\n    case CUDA_GET_SET_IIC:\n\n        if (len == 4) {\n\n            cuda_send_packet_to_host(s, obuf, 3);\n\n        } else {\n\n\n\n\n\n\n        }\n\n        break;\n\n    default:\n\n\n\n\n\n\n        break;\n\n    }\n\n}", "idx": 18559, "_split": "test", "_hash": "9b0248bb9a44d9533ffbfd7c78ea76f8"}
{"project": "qemu", "commit_id": "b6b75a99dab760c902c3d355519e0dc2616872e1", "target": 1, "func": "static void bitmap_free(Qcow2Bitmap *bm)\n{\n    g_free(bm->name);\n    g_free(bm);", "idx": 18562, "_split": "test", "_hash": "a212b46ed4d6b46e47bffe527682d94c"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void qemu_enqueue_packet(VLANClientState *sender,\n\n                                const uint8_t *buf, int size,\n\n                                NetPacketSent *sent_cb)\n\n{\n\n    VLANPacket *packet;\n\n\n\n    packet = qemu_malloc(sizeof(VLANPacket) + size);\n\n    packet->sender = sender;\n\n    packet->size = size;\n\n    packet->sent_cb = sent_cb;\n\n    memcpy(packet->data, buf, size);\n\n\n\n    TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);\n\n}\n", "idx": 18596, "_split": "test", "_hash": "f6d64d22f98f47d19c5a41607e91d3bb"}
{"project": "qemu", "commit_id": "7d6b1daedd00b35e50ce87ea835f662b36a23160", "target": 0, "func": "static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)\n\n{\n\n    /* TO FIX */\n\n    return 0;\n\n}\n", "idx": 18597, "_split": "test", "_hash": "b7a348b5aa01df274a1c4e650c4cfb7b"}
{"project": "qemu", "commit_id": "22156ab498acf5f8104801148732ae8e83f336a0", "target": 0, "func": "uint16_t net_checksum_tcpudp(uint16_t length, uint16_t proto,\n\n                             uint8_t *addrs, uint8_t *buf)\n\n{\n\n    uint32_t sum = 0;\n\n\n\n    sum += net_checksum_add(length, buf);         // payload\n\n    sum += net_checksum_add(8, addrs);            // src + dst address\n\n    sum += proto + length;                        // protocol & length\n\n    return net_checksum_finish(sum);\n\n}\n", "idx": 18598, "_split": "test", "_hash": "e05fb2f42e3f85b7d4c27c8a7a39f362"}
{"project": "qemu", "commit_id": "cea5f9a28faa528b6b1b117c9ab2d8828f473fef", "target": 0, "func": "void cpu_loop_exit(CPUState *env1)\n\n{\n\n    env1->current_tb = NULL;\n\n    longjmp(env1->jmp_env, 1);\n\n}\n", "idx": 18614, "_split": "test", "_hash": "273a7b257c025a44845ccf9bfa6b860a"}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void ppc_hw_interrupt (CPUPPCState *env)\n\n{\n\n    int raised = 0;\n\n\n\n#if 1\n\n    if (loglevel & CPU_LOG_INT) {\n\n        fprintf(logfile, \"%s: %p pending %08x req %08x me %d ee %d\\n\",\n\n                __func__, env, env->pending_interrupts,\n\n                env->interrupt_request, msr_me, msr_ee);\n\n    }\n\n#endif\n\n    /* Raise it */\n\n    if (env->pending_interrupts & (1 << PPC_INTERRUPT_RESET)) {\n\n        /* External reset / critical input */\n\n        /* XXX: critical input should be handled another way.\n\n         *      This code is not correct !\n\n         */\n\n        env->exception_index = EXCP_RESET;\n\n        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_RESET);\n\n        raised = 1;\n\n    }\n\n    if (raised == 0 && msr_me != 0) {\n\n        /* Machine check exception */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_MCK)) {\n\n            env->exception_index = EXCP_MACHINE_CHECK;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_MCK);\n\n            raised = 1;\n\n        }\n\n    }\n\n    if (raised == 0 && msr_ee != 0) {\n\n#if defined(TARGET_PPC64H) /* PowerPC 64 with hypervisor mode support */\n\n        /* Hypervisor decrementer exception */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_HDECR)) {\n\n            env->exception_index = EXCP_HDECR;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_HDECR);\n\n            raised = 1;\n\n        } else\n\n#endif\n\n        /* Decrementer exception */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_DECR)) {\n\n            env->exception_index = EXCP_DECR;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DECR);\n\n            raised = 1;\n\n        /* Programmable interval timer on embedded PowerPC */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_PIT)) {\n\n            env->exception_index = EXCP_40x_PIT;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_PIT);\n\n            raised = 1;\n\n        /* Fixed interval timer on embedded PowerPC */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_FIT)) {\n\n            env->exception_index = EXCP_40x_FIT;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_FIT);\n\n            raised = 1;\n\n        /* Watchdog timer on embedded PowerPC */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_WDT)) {\n\n            env->exception_index = EXCP_40x_WATCHDOG;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_WDT);\n\n            raised = 1;\n\n        /* External interrupt */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_EXT)) {\n\n            env->exception_index = EXCP_EXTERNAL;\n\n            /* Taking an external interrupt does not clear the external\n\n             * interrupt status\n\n             */\n\n#if 0\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_EXT);\n\n#endif\n\n            raised = 1;\n\n#if 0 // TODO\n\n        /* Thermal interrupt */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_THERM)) {\n\n            env->exception_index = EXCP_970_THRM;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_THERM);\n\n            raised = 1;\n\n#endif\n\n        }\n\n#if 0 // TODO\n\n    /* External debug exception */\n\n    } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_DEBUG)) {\n\n        env->exception_index = EXCP_xxx;\n\n        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DEBUG);\n\n        raised = 1;\n\n#endif\n\n    }\n\n    if (raised != 0) {\n\n        env->error_code = 0;\n\n        do_interrupt(env);\n\n    }\n\n}\n", "idx": 18619, "_split": "test", "_hash": "bede3902270b1dadac6fceb7f688c4fe"}
{"project": "qemu", "commit_id": "23979dc5411befabe9049e37075b2b6320debc4e", "target": 0, "func": "gen_intermediate_code_internal(CPUState *env, TranslationBlock *tb,\n\n                               int search_pc)\n\n{\n\n    uint16_t *gen_opc_end;\n\n    uint32_t pc_start;\n\n    int j, lj;\n\n    struct DisasContext ctx;\n\n    struct DisasContext *dc = &ctx;\n\n    uint32_t next_page_start, org_flags;\n\n    target_ulong npc;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    qemu_log_try_set_file(stderr);\n\n\n\n    pc_start = tb->pc;\n\n    dc->env = env;\n\n    dc->tb = tb;\n\n    org_flags = dc->synced_flags = dc->tb_flags = tb->flags;\n\n\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->jmp = 0;\n\n    dc->delayed_branch = !!(dc->tb_flags & D_FLAG);\n\n    dc->pc = pc_start;\n\n    dc->singlestep_enabled = env->singlestep_enabled;\n\n    dc->cpustate_changed = 0;\n\n    dc->abort_at_next_insn = 0;\n\n    dc->nr_nops = 0;\n\n\n\n    if (pc_start & 3)\n\n        cpu_abort(env, \"Microblaze: unaligned PC=%x\\n\", pc_start);\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n#if !SIM_COMPAT\n\n        qemu_log(\"--------------\\n\");\n\n        log_cpu_state(env, 0);\n\n#endif\n\n    }\n\n\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    lj = -1;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n\n\n    gen_icount_start();\n\n    do\n\n    {\n\n#if SIM_COMPAT\n\n        if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n            tcg_gen_movi_tl(cpu_SR[SR_PC], dc->pc);\n\n            gen_helper_debug();\n\n        }\n\n#endif\n\n        check_breakpoint(env, dc);\n\n\n\n        if (search_pc) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n            }\n\n            gen_opc_pc[lj] = dc->pc;\n\n            gen_opc_instr_start[lj] = 1;\n\n                        gen_opc_icount[lj] = num_insns;\n\n        }\n\n\n\n        /* Pretty disas.  */\n\n        LOG_DIS(\"%8.8x:\\t\", dc->pc);\n\n\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n\n\n        dc->clear_imm = 1;\n\n\tdecode(dc);\n\n        if (dc->clear_imm)\n\n            dc->tb_flags &= ~IMM_FLAG;\n\n        dc->pc += 4;\n\n        num_insns++;\n\n\n\n        if (dc->delayed_branch) {\n\n            dc->delayed_branch--;\n\n            if (!dc->delayed_branch) {\n\n                if (dc->tb_flags & DRTI_FLAG)\n\n                    do_rti(dc);\n\n                 if (dc->tb_flags & DRTB_FLAG)\n\n                    do_rtb(dc);\n\n                if (dc->tb_flags & DRTE_FLAG)\n\n                    do_rte(dc);\n\n                /* Clear the delay slot flag.  */\n\n                dc->tb_flags &= ~D_FLAG;\n\n                /* If it is a direct jump, try direct chaining.  */\n\n                if (dc->jmp != JMP_DIRECT) {\n\n                    eval_cond_jmp(dc, env_btarget, tcg_const_tl(dc->pc));\n\n                    dc->is_jmp = DISAS_JUMP;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        if (env->singlestep_enabled)\n\n            break;\n\n    } while (!dc->is_jmp && !dc->cpustate_changed\n\n         && gen_opc_ptr < gen_opc_end\n\n                 && !singlestep\n\n         && (dc->pc < next_page_start)\n\n                 && num_insns < max_insns);\n\n\n\n    npc = dc->pc;\n\n    if (dc->jmp == JMP_DIRECT) {\n\n        if (dc->tb_flags & D_FLAG) {\n\n            dc->is_jmp = DISAS_UPDATE;\n\n            tcg_gen_movi_tl(cpu_SR[SR_PC], npc);\n\n            sync_jmpstate(dc);\n\n        } else\n\n            npc = dc->jmp_pc;\n\n    }\n\n\n\n    if (tb->cflags & CF_LAST_IO)\n\n        gen_io_end();\n\n    /* Force an update if the per-tb cpu state has changed.  */\n\n    if (dc->is_jmp == DISAS_NEXT\n\n        && (dc->cpustate_changed || org_flags != dc->tb_flags)) {\n\n        dc->is_jmp = DISAS_UPDATE;\n\n        tcg_gen_movi_tl(cpu_SR[SR_PC], npc);\n\n    }\n\n    t_sync_flags(dc);\n\n\n\n    if (unlikely(env->singlestep_enabled)) {\n\n        t_gen_raise_exception(dc, EXCP_DEBUG);\n\n        if (dc->is_jmp == DISAS_NEXT)\n\n            tcg_gen_movi_tl(cpu_SR[SR_PC], npc);\n\n    } else {\n\n        switch(dc->is_jmp) {\n\n            case DISAS_NEXT:\n\n                gen_goto_tb(dc, 1, npc);\n\n                break;\n\n            default:\n\n            case DISAS_JUMP:\n\n            case DISAS_UPDATE:\n\n                /* indicate that the hash table must be used\n\n                   to find the next TB */\n\n                tcg_gen_exit_tb(0);\n\n                break;\n\n            case DISAS_TB_JUMP:\n\n                /* nothing more to generate */\n\n                break;\n\n        }\n\n    }\n\n    gen_icount_end(tb, num_insns);\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = dc->pc - pc_start;\n\n                tb->icount = num_insns;\n\n    }\n\n\n\n#ifdef DEBUG_DISAS\n\n#if !SIM_COMPAT\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"\\n\");\n\n#if DISAS_GNU\n\n        log_target_disas(pc_start, dc->pc - pc_start, 0);\n\n#endif\n\n        qemu_log(\"\\nisize=%d osize=%td\\n\",\n\n            dc->pc - pc_start, gen_opc_ptr - gen_opc_buf);\n\n    }\n\n#endif\n\n#endif\n\n    assert(!dc->abort_at_next_insn);\n\n}\n", "idx": 18620, "_split": "test", "_hash": "03283bebb2d76f945154ad5667038a64"}
{"project": "qemu", "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194", "target": 1, "func": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                               BdrvCheckMode fix, bool *rebuild,\n\n                               uint16_t **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    if (!*refcount_table) {\n\n        int64_t old_size = 0;\n\n        ret = realloc_refcount_array(s, refcount_table,\n\n                                     &old_size, *nb_clusters);\n\n        if (ret < 0) {\n\n            res->check_errors++;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* header */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* snapshots */\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* refcount data */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);\n\n}\n", "idx": 18629, "_split": "test", "_hash": "09300993e1163edb1a507b3d935dc2b3"}
{"project": "qemu", "commit_id": "40545f84cfcbe4b73cca040b3043a1c2de935762", "target": 1, "func": "static void ne2000_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    NE2000State *s = opaque;\n\n    int offset, page;\n\n\n\n    addr &= 0xf;\n\n#ifdef DEBUG_NE2000\n\n    printf(\"NE2000: write addr=0x%x val=0x%02x\\n\", addr, val);\n\n#endif\n\n    if (addr == E8390_CMD) {\n\n        /* control register */\n\n        s->cmd = val;\n\n        if (val & E8390_START) {\n\n            s->isr &= ~ENISR_RESET;\n\n            /* test specific case: zero length transfert */\n\n            if ((val & (E8390_RREAD | E8390_RWRITE)) &&\n\n                s->rcnt == 0) {\n\n                s->isr |= ENISR_RDC;\n\n                ne2000_update_irq(s);\n\n            }\n\n            if (val & E8390_TRANS) {\n\n                qemu_send_packet(s->nd, s->mem + (s->tpsr << 8), s->tcnt);\n\n                /* signal end of transfert */\n\n                s->tsr = ENTSR_PTX;\n\n                s->isr |= ENISR_TX;\n\n                ne2000_update_irq(s);\n\n            }\n\n        }\n\n    } else {\n\n        page = s->cmd >> 6;\n\n        offset = addr | (page << 4);\n\n        switch(offset) {\n\n        case EN0_STARTPG:\n\n            s->start = val << 8;\n\n            break;\n\n        case EN0_STOPPG:\n\n            s->stop = val << 8;\n\n            break;\n\n        case EN0_BOUNDARY:\n\n            s->boundary = val;\n\n            break;\n\n        case EN0_IMR:\n\n            s->imr = val;\n\n            ne2000_update_irq(s);\n\n            break;\n\n        case EN0_TPSR:\n\n            s->tpsr = val;\n\n            break;\n\n        case EN0_TCNTLO:\n\n            s->tcnt = (s->tcnt & 0xff00) | val;\n\n            break;\n\n        case EN0_TCNTHI:\n\n            s->tcnt = (s->tcnt & 0x00ff) | (val << 8);\n\n            break;\n\n        case EN0_RSARLO:\n\n            s->rsar = (s->rsar & 0xff00) | val;\n\n            break;\n\n        case EN0_RSARHI:\n\n            s->rsar = (s->rsar & 0x00ff) | (val << 8);\n\n            break;\n\n        case EN0_RCNTLO:\n\n            s->rcnt = (s->rcnt & 0xff00) | val;\n\n            break;\n\n        case EN0_RCNTHI:\n\n            s->rcnt = (s->rcnt & 0x00ff) | (val << 8);\n\n            break;\n\n        case EN0_DCFG:\n\n            s->dcfg = val;\n\n            break;\n\n        case EN0_ISR:\n\n            s->isr &= ~(val & 0x7f);\n\n            ne2000_update_irq(s);\n\n            break;\n\n        case EN1_PHYS ... EN1_PHYS + 5:\n\n            s->phys[offset - EN1_PHYS] = val;\n\n            break;\n\n        case EN1_CURPAG:\n\n            s->curpag = val;\n\n            break;\n\n        case EN1_MULT ... EN1_MULT + 7:\n\n            s->mult[offset - EN1_MULT] = val;\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 18640, "_split": "test", "_hash": "f23e3ada6948b1885aa2641106a3a9e6"}
{"project": "qemu", "commit_id": "92dcc234ec1f266fb5d59bed77d66320c2c75965", "target": 0, "func": "static int tpm_passthrough_unix_transfer(int tpm_fd,\n\n                                         const TPMLocality *locty_data)\n\n{\n\n    return tpm_passthrough_unix_tx_bufs(tpm_fd,\n\n                                        locty_data->w_buffer.buffer,\n\n                                        locty_data->w_offset,\n\n                                        locty_data->r_buffer.buffer,\n\n                                        locty_data->r_buffer.size);\n\n}\n", "idx": 18673, "_split": "test", "_hash": "3c14ced42d78de1ab893b30d905d9306"}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void do_tw (int flags)\n\n{\n\n    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||\n\n                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||\n\n                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||\n\n                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||\n\n                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);\n\n    }\n\n}\n", "idx": 18675, "_split": "test", "_hash": "044158de42a1071ab335e44a72e6775b"}
{"project": "qemu", "commit_id": "f85da3081d001909929a19e530e69cea0487f00e", "target": 1, "func": "void sh4_translate_init(void)\n\n{\n\n    int i;\n\n    static const char * const gregnames[24] = {\n\n        \"R0_BANK0\", \"R1_BANK0\", \"R2_BANK0\", \"R3_BANK0\",\n\n        \"R4_BANK0\", \"R5_BANK0\", \"R6_BANK0\", \"R7_BANK0\",\n\n        \"R8\", \"R9\", \"R10\", \"R11\", \"R12\", \"R13\", \"R14\", \"R15\",\n\n        \"R0_BANK1\", \"R1_BANK1\", \"R2_BANK1\", \"R3_BANK1\",\n\n        \"R4_BANK1\", \"R5_BANK1\", \"R6_BANK1\", \"R7_BANK1\"\n\n    };\n\n    static const char * const fregnames[32] = {\n\n         \"FPR0_BANK0\",  \"FPR1_BANK0\",  \"FPR2_BANK0\",  \"FPR3_BANK0\",\n\n         \"FPR4_BANK0\",  \"FPR5_BANK0\",  \"FPR6_BANK0\",  \"FPR7_BANK0\",\n\n         \"FPR8_BANK0\",  \"FPR9_BANK0\", \"FPR10_BANK0\", \"FPR11_BANK0\",\n\n        \"FPR12_BANK0\", \"FPR13_BANK0\", \"FPR14_BANK0\", \"FPR15_BANK0\",\n\n         \"FPR0_BANK1\",  \"FPR1_BANK1\",  \"FPR2_BANK1\",  \"FPR3_BANK1\",\n\n         \"FPR4_BANK1\",  \"FPR5_BANK1\",  \"FPR6_BANK1\",  \"FPR7_BANK1\",\n\n         \"FPR8_BANK1\",  \"FPR9_BANK1\", \"FPR10_BANK1\", \"FPR11_BANK1\",\n\n        \"FPR12_BANK1\", \"FPR13_BANK1\", \"FPR14_BANK1\", \"FPR15_BANK1\",\n\n    };\n\n\n\n    for (i = 0; i < 24; i++) {\n\n        cpu_gregs[i] = tcg_global_mem_new_i32(cpu_env,\n\n                                              offsetof(CPUSH4State, gregs[i]),\n\n                                              gregnames[i]);\n\n    }\n\n    memcpy(cpu_gregs + 24, cpu_gregs + 8, 8 * sizeof(TCGv));\n\n\n\n    cpu_pc = tcg_global_mem_new_i32(cpu_env,\n\n                                    offsetof(CPUSH4State, pc), \"PC\");\n\n    cpu_sr = tcg_global_mem_new_i32(cpu_env,\n\n                                    offsetof(CPUSH4State, sr), \"SR\");\n\n    cpu_sr_m = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, sr_m), \"SR_M\");\n\n    cpu_sr_q = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, sr_q), \"SR_Q\");\n\n    cpu_sr_t = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, sr_t), \"SR_T\");\n\n    cpu_ssr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, ssr), \"SSR\");\n\n    cpu_spc = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, spc), \"SPC\");\n\n    cpu_gbr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, gbr), \"GBR\");\n\n    cpu_vbr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, vbr), \"VBR\");\n\n    cpu_sgr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, sgr), \"SGR\");\n\n    cpu_dbr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, dbr), \"DBR\");\n\n    cpu_mach = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, mach), \"MACH\");\n\n    cpu_macl = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, macl), \"MACL\");\n\n    cpu_pr = tcg_global_mem_new_i32(cpu_env,\n\n                                    offsetof(CPUSH4State, pr), \"PR\");\n\n    cpu_fpscr = tcg_global_mem_new_i32(cpu_env,\n\n                                       offsetof(CPUSH4State, fpscr), \"FPSCR\");\n\n    cpu_fpul = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, fpul), \"FPUL\");\n\n\n\n    cpu_flags = tcg_global_mem_new_i32(cpu_env,\n\n\t\t\t\t       offsetof(CPUSH4State, flags), \"_flags_\");\n\n    cpu_delayed_pc = tcg_global_mem_new_i32(cpu_env,\n\n\t\t\t\t\t    offsetof(CPUSH4State, delayed_pc),\n\n\t\t\t\t\t    \"_delayed_pc_\");\n\n    cpu_delayed_cond = tcg_global_mem_new_i32(cpu_env,\n\n                                              offsetof(CPUSH4State,\n\n                                                       delayed_cond),\n\n                                              \"_delayed_cond_\");\n\n    cpu_ldst = tcg_global_mem_new_i32(cpu_env,\n\n\t\t\t\t      offsetof(CPUSH4State, ldst), \"_ldst_\");\n\n\n\n    for (i = 0; i < 32; i++)\n\n        cpu_fregs[i] = tcg_global_mem_new_i32(cpu_env,\n\n                                              offsetof(CPUSH4State, fregs[i]),\n\n                                              fregnames[i]);\n\n}\n", "idx": 18696, "_split": "test", "_hash": "acc8de5f52504effc8e352310379a7b4"}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "static inline unsigned int msi_nr_vectors(uint16_t flags)\n\n{\n\n    return 1U <<\n\n        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));\n\n}\n", "idx": 18724, "_split": "test", "_hash": "807d8e11556317df6f773707b3b32010"}
{"project": "qemu", "commit_id": "13f1c773640171efa8175b1ba6dcd624c1ad68c1", "target": 0, "func": "static void openrisc_sim_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    OpenRISCCPU *cpu = NULL;\n\n    MemoryRegion *ram;\n\n    int n;\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"or1200\";\n\n    }\n\n\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        cpu = OPENRISC_CPU(cpu_generic_init(TYPE_OPENRISC_CPU, cpu_model));\n\n        qemu_register_reset(main_cpu_reset, cpu);\n\n        main_cpu_reset(cpu);\n\n    }\n\n\n\n    ram = g_malloc(sizeof(*ram));\n\n    memory_region_init_ram(ram, NULL, \"openrisc.ram\", ram_size, &error_fatal);\n\n    memory_region_add_subregion(get_system_memory(), 0, ram);\n\n\n\n    cpu_openrisc_pic_init(cpu);\n\n    cpu_openrisc_clock_init(cpu);\n\n\n\n    serial_mm_init(get_system_memory(), 0x90000000, 0, cpu->env.irq[2],\n\n                   115200, serial_hds[0], DEVICE_NATIVE_ENDIAN);\n\n\n\n    if (nd_table[0].used) {\n\n        openrisc_sim_net_init(get_system_memory(), 0x92000000,\n\n                              0x92000400, cpu->env.irq[4], nd_table);\n\n    }\n\n\n\n    cpu_openrisc_load_kernel(ram_size, kernel_filename, cpu);\n\n}\n", "idx": 18727, "_split": "test", "_hash": "2e7ec6f97444047a9c3148d600ed6ad0"}
{"project": "qemu", "commit_id": "891fb2cd4592b6fe76106a69e0ca40efbf82726a", "target": 0, "func": "static void ohci_reset(void *opaque)\n\n{\n\n    OHCIState *ohci = opaque;\n\n    OHCIPort *port;\n\n    int i;\n\n\n\n    ohci_bus_stop(ohci);\n\n    ohci->ctl = 0;\n\n    ohci->old_ctl = 0;\n\n    ohci->status = 0;\n\n    ohci->intr_status = 0;\n\n    ohci->intr = OHCI_INTR_MIE;\n\n\n\n    ohci->hcca = 0;\n\n    ohci->ctrl_head = ohci->ctrl_cur = 0;\n\n    ohci->bulk_head = ohci->bulk_cur = 0;\n\n    ohci->per_cur = 0;\n\n    ohci->done = 0;\n\n    ohci->done_count = 7;\n\n\n\n    /* FSMPS is marked TBD in OCHI 1.0, what gives ffs?\n\n     * I took the value linux sets ...\n\n     */\n\n    ohci->fsmps = 0x2778;\n\n    ohci->fi = 0x2edf;\n\n    ohci->fit = 0;\n\n    ohci->frt = 0;\n\n    ohci->frame_number = 0;\n\n    ohci->pstart = 0;\n\n    ohci->lst = OHCI_LS_THRESH;\n\n\n\n    ohci->rhdesc_a = OHCI_RHA_NPS | ohci->num_ports;\n\n    ohci->rhdesc_b = 0x0; /* Impl. specific */\n\n    ohci->rhstatus = 0;\n\n\n\n    for (i = 0; i < ohci->num_ports; i++)\n\n      {\n\n        port = &ohci->rhport[i];\n\n        port->ctrl = 0;\n\n        if (port->port.dev) {\n\n            usb_attach(&port->port, port->port.dev);\n\n        }\n\n      }\n\n    if (ohci->async_td) {\n\n        usb_cancel_packet(&ohci->usb_packet);\n\n        ohci->async_td = 0;\n\n    }\n\n    DPRINTF(\"usb-ohci: Reset %s\\n\", ohci->name);\n\n}\n", "idx": 18741, "_split": "test", "_hash": "db79b818380feba2e767b81fb1b7a763"}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2)\n\n{\n\n    CPU_DoubleU farg1, farg2;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n\n\n    if (unlikely(float64_is_infinity(farg1.d) && float64_is_infinity(farg2.d) &&\n\n                 float64_is_neg(farg1.d) == float64_is_neg(farg2.d))) {\n\n        /* Magnitude subtraction of infinities */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d))) {\n\n            /* sNaN subtraction */\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        farg1.d = float64_sub(farg1.d, farg2.d, &env->fp_status);\n\n    }\n\n\n\n    return farg1.ll;\n\n}\n", "idx": 18744, "_split": "test", "_hash": "c5fcf57ec734070e1f375b3988c2000d"}
{"project": "qemu", "commit_id": "0f8c289ad539feb5135c545bea947b310a893f4b", "target": 1, "func": "static int net_socket_connect_init(NetClientState *peer,\n\n                                   const char *model,\n\n                                   const char *name,\n\n                                   const char *host_str)\n\n{\n\n    NetSocketState *s;\n\n    int fd, connected, ret;\n\n    struct sockaddr_in saddr;\n\n\n\n    if (parse_host_port(&saddr, host_str) < 0)\n\n        return -1;\n\n\n\n    fd = qemu_socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        return -1;\n\n    }\n\n    qemu_set_nonblock(fd);\n\n\n\n    connected = 0;\n\n    for(;;) {\n\n        ret = connect(fd, (struct sockaddr *)&saddr, sizeof(saddr));\n\n        if (ret < 0) {\n\n            if (errno == EINTR || errno == EWOULDBLOCK) {\n\n                /* continue */\n\n            } else if (errno == EINPROGRESS ||\n\n                       errno == EALREADY ||\n\n                       errno == EINVAL) {\n\n                break;\n\n            } else {\n\n                perror(\"connect\");\n\n                closesocket(fd);\n\n                return -1;\n\n            }\n\n        } else {\n\n            connected = 1;\n\n            break;\n\n        }\n\n    }\n\n    s = net_socket_fd_init(peer, model, name, fd, connected);\n\n    if (!s)\n\n        return -1;\n\n    snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n             \"socket: connect to %s:%d\",\n\n             inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));\n\n    return 0;\n\n}\n", "idx": 18759, "_split": "test", "_hash": "f76b4b4d700afa16ca566f1bb9cc3824"}
{"project": "qemu", "commit_id": "3ad9fd5a257794d516db515c217c78a5806112fe", "target": 1, "func": "static int64_t load_kernel (void)\n\n{\n\n    int64_t kernel_entry, kernel_high;\n\n    long initrd_size;\n\n    ram_addr_t initrd_offset;\n\n    int big_endian;\n\n    uint32_t *prom_buf;\n\n    long prom_size;\n\n    int prom_index = 0;\n\n    uint64_t (*xlate_to_kseg0) (void *opaque, uint64_t addr);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    big_endian = 1;\n\n#else\n\n    big_endian = 0;\n\n#endif\n\n\n\n    if (load_elf(loaderparams.kernel_filename, cpu_mips_kseg0_to_phys, NULL,\n\n                 (uint64_t *)&kernel_entry, NULL, (uint64_t *)&kernel_high,\n\n                 big_endian, ELF_MACHINE, 1) < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                loaderparams.kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    /* Sanity check where the kernel has been linked */\n\n    if (kvm_enabled()) {\n\n        if (kernel_entry & 0x80000000ll) {\n\n            error_report(\"KVM guest kernels must be linked in useg. \"\n\n                         \"Did you forget to enable CONFIG_KVM_GUEST?\");\n\n            exit(1);\n\n        }\n\n\n\n        xlate_to_kseg0 = cpu_mips_kvm_um_phys_to_kseg0;\n\n    } else {\n\n        if (!(kernel_entry & 0x80000000ll)) {\n\n            error_report(\"KVM guest kernels aren't supported with TCG. \"\n\n                         \"Did you unintentionally enable CONFIG_KVM_GUEST?\");\n\n            exit(1);\n\n        }\n\n\n\n        xlate_to_kseg0 = cpu_mips_phys_to_kseg0;\n\n    }\n\n\n\n    /* load initrd */\n\n    initrd_size = 0;\n\n    initrd_offset = 0;\n\n    if (loaderparams.initrd_filename) {\n\n        initrd_size = get_image_size (loaderparams.initrd_filename);\n\n        if (initrd_size > 0) {\n\n            initrd_offset = (kernel_high + ~INITRD_PAGE_MASK) & INITRD_PAGE_MASK;\n\n            if (initrd_offset + initrd_size > ram_size) {\n\n                fprintf(stderr,\n\n                        \"qemu: memory too small for initial ram disk '%s'\\n\",\n\n                        loaderparams.initrd_filename);\n\n                exit(1);\n\n            }\n\n            initrd_size = load_image_targphys(loaderparams.initrd_filename,\n\n                                              initrd_offset,\n\n                                              ram_size - initrd_offset);\n\n        }\n\n        if (initrd_size == (target_ulong) -1) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    loaderparams.initrd_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Setup prom parameters. */\n\n    prom_size = ENVP_NB_ENTRIES * (sizeof(int32_t) + ENVP_ENTRY_SIZE);\n\n    prom_buf = g_malloc(prom_size);\n\n\n\n    prom_set(prom_buf, prom_index++, \"%s\", loaderparams.kernel_filename);\n\n    if (initrd_size > 0) {\n\n        prom_set(prom_buf, prom_index++, \"rd_start=0x%\" PRIx64 \" rd_size=%li %s\",\n\n                 xlate_to_kseg0(NULL, initrd_offset), initrd_size,\n\n                 loaderparams.kernel_cmdline);\n\n    } else {\n\n        prom_set(prom_buf, prom_index++, \"%s\", loaderparams.kernel_cmdline);\n\n    }\n\n\n\n    prom_set(prom_buf, prom_index++, \"memsize\");\n\n    prom_set(prom_buf, prom_index++, \"%i\",\n\n             MIN(loaderparams.ram_size, 256 << 20));\n\n\n\n    prom_set(prom_buf, prom_index++, \"modetty0\");\n\n    prom_set(prom_buf, prom_index++, \"38400n8r\");\n\n    prom_set(prom_buf, prom_index++, NULL);\n\n\n\n    rom_add_blob_fixed(\"prom\", prom_buf, prom_size,\n\n                       cpu_mips_kseg0_to_phys(NULL, ENVP_ADDR));\n\n\n\n\n    return kernel_entry;\n\n}", "idx": 18773, "_split": "test", "_hash": "f3b2ba2cebbc1029bbf6305cd192f1ac"}
{"project": "qemu", "commit_id": "0fb6395c0cb5046432a80d608ddde7a3b2f8a9ae", "target": 0, "func": "static void test_validate_fail_union_anon(TestInputVisitorData *data,\n\n                                          const void *unused)\n\n{\n\n    UserDefAnonUnion *tmp = NULL;\n\n    Visitor *v;\n\n    Error *errp = NULL;\n\n\n\n    v = validate_test_init(data, \"3.14\");\n\n\n\n    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);\n\n    g_assert(error_is_set(&errp));\n\n    qapi_free_UserDefAnonUnion(tmp);\n\n}\n", "idx": 18781, "_split": "test", "_hash": "190fb54ca5076694dddd7f4e04fefa48"}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static int vhost_virtqueue_init(struct vhost_dev *dev,\n\n                                struct vhost_virtqueue *vq, int n)\n\n{\n\n    struct vhost_vring_file file = {\n\n        .index = n,\n\n    };\n\n    int r = event_notifier_init(&vq->masked_notifier, 0);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    file.fd = event_notifier_get_fd(&vq->masked_notifier);\n\n    r = dev->vhost_ops->vhost_call(dev, VHOST_SET_VRING_CALL, &file);\n\n    if (r) {\n\n        r = -errno;\n\n        goto fail_call;\n\n    }\n\n    return 0;\n\nfail_call:\n\n    event_notifier_cleanup(&vq->masked_notifier);\n\n    return r;\n\n}\n", "idx": 18799, "_split": "test", "_hash": "4ea6de23fefb39c9a7ecac6621d29b87"}
{"project": "qemu", "commit_id": "1e7398a140f7a6bd9f5a438e7ad0f1ef50990e25", "target": 1, "func": "struct vhost_net *vhost_net_init(VhostNetOptions *options)\n\n{\n\n    int r;\n\n    bool backend_kernel = options->backend_type == VHOST_BACKEND_TYPE_KERNEL;\n\n    struct vhost_net *net = g_malloc(sizeof *net);\n\n\n\n    if (!options->net_backend) {\n\n        fprintf(stderr, \"vhost-net requires net backend to be setup\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    if (backend_kernel) {\n\n        r = vhost_net_get_fd(options->net_backend);\n\n        if (r < 0) {\n\n            goto fail;\n\n        }\n\n        net->dev.backend_features = qemu_has_vnet_hdr(options->net_backend)\n\n            ? 0 : (1ULL << VHOST_NET_F_VIRTIO_NET_HDR);\n\n        net->backend = r;\n\n    } else {\n\n        net->dev.backend_features = 0;\n\n        net->backend = -1;\n\n    }\n\n    net->nc = options->net_backend;\n\n\n\n    net->dev.nvqs = 2;\n\n    net->dev.vqs = net->vqs;\n\n    net->dev.vq_index = net->nc->queue_index;\n\n\n\n    r = vhost_dev_init(&net->dev, options->opaque,\n\n                       options->backend_type, options->force);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n    if (backend_kernel) {\n\n        if (!qemu_has_vnet_hdr_len(options->net_backend,\n\n                               sizeof(struct virtio_net_hdr_mrg_rxbuf))) {\n\n            net->dev.features &= ~(1ULL << VIRTIO_NET_F_MRG_RXBUF);\n\n        }\n\n        if (~net->dev.features & net->dev.backend_features) {\n\n            fprintf(stderr, \"vhost lacks feature mask %\" PRIu64\n\n                   \" for backend\\n\",\n\n                   (uint64_t)(~net->dev.features & net->dev.backend_features));\n\n            vhost_dev_cleanup(&net->dev);\n\n            goto fail;\n\n        }\n\n    }\n\n    /* Set sane init value. Override when guest acks. */\n\n    vhost_net_ack_features(net, 0);\n\n    return net;\n\nfail:\n\n    g_free(net);\n\n    return NULL;\n\n}\n", "idx": 18819, "_split": "test", "_hash": "f3887257c28c0ac4f0a323a55505e5c9"}
{"project": "qemu", "commit_id": "d44168fffa07fc57e61a37da65e9348661dec887", "target": 1, "func": "static USBDevice *usb_msd_init(const char *filename)\n\n{\n\n    static int nr=0;\n\n    char id[8];\n\n    QemuOpts *opts;\n\n    DriveInfo *dinfo;\n\n    USBDevice *dev;\n\n    int fatal_error;\n\n    const char *p1;\n\n    char fmt[32];\n\n\n\n    /* parse -usbdevice disk: syntax into drive opts */\n\n    snprintf(id, sizeof(id), \"usb%d\", nr++);\n\n    opts = qemu_opts_create(&qemu_drive_opts, id, 0);\n\n\n\n    p1 = strchr(filename, ':');\n\n    if (p1++) {\n\n        const char *p2;\n\n\n\n        if (strstart(filename, \"format=\", &p2)) {\n\n            int len = MIN(p1 - p2, sizeof(fmt));\n\n            pstrcpy(fmt, len, p2);\n\n            qemu_opt_set(opts, \"format\", fmt);\n\n        } else if (*filename != ':') {\n\n            printf(\"unrecognized USB mass-storage option %s\\n\", filename);\n\n\n\n        filename = p1;\n\n\n    if (!*filename) {\n\n        printf(\"block device specification needed\\n\");\n\n\n\n    qemu_opt_set(opts, \"file\", filename);\n\n    qemu_opt_set(opts, \"if\", \"none\");\n\n\n\n    /* create host drive */\n\n    dinfo = drive_init(opts, NULL, &fatal_error);\n\n    if (!dinfo) {\n\n        qemu_opts_del(opts);\n\n\n\n\n\n    /* create guest device */\n\n    dev = usb_create(NULL /* FIXME */, \"usb-storage\");\n\n\n\n\n    qdev_prop_set_drive(&dev->qdev, \"drive\", dinfo);\n\n    if (qdev_init(&dev->qdev) < 0)\n\n\n\n\n    return dev;\n", "idx": 18820, "_split": "test", "_hash": "6fb953c91733f3d05b792fa847e21308"}
{"project": "qemu", "commit_id": "9287ac271d83166f99e050a0e0a4ebd462f7eb2b", "target": 1, "func": "void migrate_fd_connect(MigrationState *s)\n\n{\n\n    s->state = MIG_STATE_SETUP;\n\n    trace_migrate_set_state(MIG_STATE_SETUP);\n\n\n\n    /* This is a best 1st approximation. ns to ms */\n\n    s->expected_downtime = max_downtime/1000000;\n\n    s->cleanup_bh = qemu_bh_new(migrate_fd_cleanup, s);\n\n\n\n    qemu_file_set_rate_limit(s->file,\n\n                             s->bandwidth_limit / XFER_LIMIT_RATIO);\n\n\n\n    qemu_thread_create(&s->thread, migration_thread, s,\n\n                       QEMU_THREAD_JOINABLE);\n\n    notifier_list_notify(&migration_state_notifiers, s);\n\n}\n", "idx": 18833, "_split": "test", "_hash": "492c9e31c600e0227976162c9896ba01"}
{"project": "qemu", "commit_id": "fb6971c110387cf597b58c411658e3d15cc6c6fb", "target": 1, "func": "static void ppc405cr_clk_setup (ppc405cr_cpc_t *cpc)\n\n{\n\n    uint64_t VCO_out, PLL_out;\n\n    uint32_t CPU_clk, TMR_clk, SDRAM_clk, PLB_clk, OPB_clk, EXT_clk, UART_clk;\n\n    int M, D0, D1, D2;\n\n\n\n    D0 = ((cpc->pllmr >> 26) & 0x3) + 1; /* CBDV */\n\n    if (cpc->pllmr & 0x80000000) {\n\n        D1 = (((cpc->pllmr >> 20) - 1) & 0xF) + 1; /* FBDV */\n\n        D2 = 8 - ((cpc->pllmr >> 16) & 0x7); /* FWDVA */\n\n        M = D0 * D1 * D2;\n\n        VCO_out = cpc->sysclk * M;\n\n        if (VCO_out < 400000000 || VCO_out > 800000000) {\n\n            /* PLL cannot lock */\n\n            cpc->pllmr &= ~0x80000000;\n\n            goto bypass_pll;\n\n        }\n\n        PLL_out = VCO_out / D2;\n\n    } else {\n\n        /* Bypass PLL */\n\n    bypass_pll:\n\n        M = D0;\n\n        PLL_out = cpc->sysclk * M;\n\n    }\n\n    CPU_clk = PLL_out;\n\n    if (cpc->cr1 & 0x00800000)\n\n        TMR_clk = cpc->sysclk; /* Should have a separate clock */\n\n    else\n\n        TMR_clk = CPU_clk;\n\n    PLB_clk = CPU_clk / D0;\n\n    SDRAM_clk = PLB_clk;\n\n    D0 = ((cpc->pllmr >> 10) & 0x3) + 1;\n\n    OPB_clk = PLB_clk / D0;\n\n    D0 = ((cpc->pllmr >> 24) & 0x3) + 2;\n\n    EXT_clk = PLB_clk / D0;\n\n    D0 = ((cpc->cr0 >> 1) & 0x1F) + 1;\n\n    UART_clk = CPU_clk / D0;\n\n    /* Setup CPU clocks */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_CPU_CLK], CPU_clk);\n\n    /* Setup time-base clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_TMR_CLK], TMR_clk);\n\n    /* Setup PLB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_PLB_CLK], PLB_clk);\n\n    /* Setup SDRAM clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_SDRAM_CLK], SDRAM_clk);\n\n    /* Setup OPB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_OPB_CLK], OPB_clk);\n\n    /* Setup external clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_EXT_CLK], EXT_clk);\n\n    /* Setup UART clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_UART_CLK], UART_clk);\n\n}\n", "idx": 18838, "_split": "test", "_hash": "c1cd4c91e716d61072be25274315f398"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t cmd646_cmd_read(void *opaque, target_phys_addr_t addr,\n\n                                unsigned size)\n\n{\n\n    CMD646BAR *cmd646bar = opaque;\n\n\n\n    if (addr != 2 || size != 1) {\n\n        return ((uint64_t)1 << (size * 8)) - 1;\n\n    }\n\n    return ide_status_read(cmd646bar->bus, addr + 2);\n\n}\n", "idx": 18853, "_split": "test", "_hash": "57dc148108d734cc43bcee197910398a"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t hpet_ram_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    HPETState *s = opaque;\n\n    uint64_t cur_tick, index;\n\n\n\n    DPRINTF(\"qemu: Enter hpet_ram_readl at %\" PRIx64 \"\\n\", addr);\n\n    index = addr;\n\n    /*address range of all TN regs*/\n\n    if (index >= 0x100 && index <= 0x3ff) {\n\n        uint8_t timer_id = (addr - 0x100) / 0x20;\n\n        HPETTimer *timer = &s->timer[timer_id];\n\n\n\n        if (timer_id > s->num_timers) {\n\n            DPRINTF(\"qemu: timer id out of range\\n\");\n\n            return 0;\n\n        }\n\n\n\n        switch ((addr - 0x100) % 0x20) {\n\n        case HPET_TN_CFG:\n\n            return timer->config;\n\n        case HPET_TN_CFG + 4: // Interrupt capabilities\n\n            return timer->config >> 32;\n\n        case HPET_TN_CMP: // comparator register\n\n            return timer->cmp;\n\n        case HPET_TN_CMP + 4:\n\n            return timer->cmp >> 32;\n\n        case HPET_TN_ROUTE:\n\n            return timer->fsb;\n\n        case HPET_TN_ROUTE + 4:\n\n            return timer->fsb >> 32;\n\n        default:\n\n            DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n            break;\n\n        }\n\n    } else {\n\n        switch (index) {\n\n        case HPET_ID:\n\n            return s->capability;\n\n        case HPET_PERIOD:\n\n            return s->capability >> 32;\n\n        case HPET_CFG:\n\n            return s->config;\n\n        case HPET_CFG + 4:\n\n            DPRINTF(\"qemu: invalid HPET_CFG + 4 hpet_ram_readl\\n\");\n\n            return 0;\n\n        case HPET_COUNTER:\n\n            if (hpet_enabled(s)) {\n\n                cur_tick = hpet_get_ticks(s);\n\n            } else {\n\n                cur_tick = s->hpet_counter;\n\n            }\n\n            DPRINTF(\"qemu: reading counter  = %\" PRIx64 \"\\n\", cur_tick);\n\n            return cur_tick;\n\n        case HPET_COUNTER + 4:\n\n            if (hpet_enabled(s)) {\n\n                cur_tick = hpet_get_ticks(s);\n\n            } else {\n\n                cur_tick = s->hpet_counter;\n\n            }\n\n            DPRINTF(\"qemu: reading counter + 4  = %\" PRIx64 \"\\n\", cur_tick);\n\n            return cur_tick >> 32;\n\n        case HPET_STATUS:\n\n            return s->isr;\n\n        default:\n\n            DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n            break;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 18892, "_split": "test", "_hash": "ae9bb9f4421acd13196ee3fa6a13d356"}
{"project": "qemu", "commit_id": "e75ccf2c033fb0503d6cb7ddd0fd1dfa0aa4fc16", "target": 0, "func": "static void virtio_init_pci(VirtIOPCIProxy *proxy, VirtIODevice *vdev,\n\n                            uint16_t vendor, uint16_t device,\n\n                            uint16_t class_code, uint8_t pif)\n\n{\n\n    uint8_t *config;\n\n    uint32_t size;\n\n\n\n    proxy->vdev = vdev;\n\n\n\n    config = proxy->pci_dev.config;\n\n    pci_config_set_vendor_id(config, vendor);\n\n    pci_config_set_device_id(config, device);\n\n\n\n    config[0x08] = VIRTIO_PCI_ABI_VERSION;\n\n\n\n    config[0x09] = pif;\n\n    pci_config_set_class(config, class_code);\n\n\n\n    config[0x2c] = vendor & 0xFF;\n\n    config[0x2d] = (vendor >> 8) & 0xFF;\n\n    config[0x2e] = vdev->device_id & 0xFF;\n\n    config[0x2f] = (vdev->device_id >> 8) & 0xFF;\n\n\n\n    config[0x3d] = 1;\n\n\n\n    if (vdev->nvectors && !msix_init(&proxy->pci_dev, vdev->nvectors, 1, 0)) {\n\n        pci_register_bar(&proxy->pci_dev, 1,\n\n                         msix_bar_size(&proxy->pci_dev),\n\n                         PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                         msix_mmio_map);\n\n    } else\n\n        vdev->nvectors = 0;\n\n\n\n    proxy->pci_dev.config_write = virtio_write_config;\n\n\n\n    size = VIRTIO_PCI_REGION_SIZE(&proxy->pci_dev) + vdev->config_len;\n\n    if (size & (size-1))\n\n        size = 1 << qemu_fls(size);\n\n\n\n    pci_register_bar(&proxy->pci_dev, 0, size, PCI_BASE_ADDRESS_SPACE_IO,\n\n                           virtio_map);\n\n\n\n    if (!kvm_has_many_ioeventfds()) {\n\n        proxy->flags &= ~VIRTIO_PCI_FLAG_USE_IOEVENTFD;\n\n    }\n\n\n\n    virtio_bind_device(vdev, &virtio_pci_bindings, proxy);\n\n    proxy->host_features |= 0x1 << VIRTIO_F_NOTIFY_ON_EMPTY;\n\n    proxy->host_features |= 0x1 << VIRTIO_F_BAD_FEATURE;\n\n    proxy->host_features = vdev->get_features(vdev, proxy->host_features);\n\n}\n", "idx": 18893, "_split": "test", "_hash": "001d6c9bd329673c13226d01853d2a5a"}
{"project": "qemu", "commit_id": "bb5fc20f7c1c65e95030da3629dd0d7a0cce38cd", "target": 0, "func": "static int usb_device_add(const char *devname, int is_hotplug)\n\n{\n\n    const char *p;\n\n    USBDevice *dev;\n\n\n\n    if (!free_usb_ports)\n\n        return -1;\n\n\n\n    if (strstart(devname, \"host:\", &p)) {\n\n        dev = usb_host_device_open(p);\n\n    } else if (!strcmp(devname, \"mouse\")) {\n\n        dev = usb_mouse_init();\n\n    } else if (!strcmp(devname, \"tablet\")) {\n\n        dev = usb_tablet_init();\n\n    } else if (!strcmp(devname, \"keyboard\")) {\n\n        dev = usb_keyboard_init();\n\n    } else if (strstart(devname, \"disk:\", &p)) {\n\n        BlockDriverState *bs;\n\n\n\n        dev = usb_msd_init(p, &bs);\n\n        if (!dev)\n\n            return -1;\n\n        if (bdrv_key_required(bs)) {\n\n            autostart = 0;\n\n            if (is_hotplug && monitor_read_bdrv_key(bs) < 0) {\n\n                dev->handle_destroy(dev);\n\n                return -1;\n\n            }\n\n        }\n\n    } else if (!strcmp(devname, \"wacom-tablet\")) {\n\n        dev = usb_wacom_init();\n\n    } else if (strstart(devname, \"serial:\", &p)) {\n\n        dev = usb_serial_init(p);\n\n#ifdef CONFIG_BRLAPI\n\n    } else if (!strcmp(devname, \"braille\")) {\n\n        dev = usb_baum_init();\n\n#endif\n\n    } else if (strstart(devname, \"net:\", &p)) {\n\n        int nic = nb_nics;\n\n\n\n        if (net_client_init(\"nic\", p) < 0)\n\n            return -1;\n\n        nd_table[nic].model = \"usb\";\n\n        dev = usb_net_init(&nd_table[nic]);\n\n    } else if (!strcmp(devname, \"bt\") || strstart(devname, \"bt:\", &p)) {\n\n        dev = usb_bt_init(devname[2] ? hci_init(p) :\n\n                        bt_new_hci(qemu_find_bt_vlan(0)));\n\n    } else {\n\n        return -1;\n\n    }\n\n    if (!dev)\n\n        return -1;\n\n\n\n    return usb_device_add_dev(dev);\n\n}\n", "idx": 18915, "_split": "test", "_hash": "fd3211e749d22fee6685250526b8c7ee"}
{"project": "qemu", "commit_id": "7e01376daea75e888c370aab521a7d4aeaf2ffd1", "target": 0, "func": "void ioinst_handle_msch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)\n\n{\n\n    int cssid, ssid, schid, m;\n\n    SubchDev *sch;\n\n    SCHIB schib;\n\n    uint64_t addr;\n\n    int ret = -ENODEV;\n\n    int cc;\n\n    CPUS390XState *env = &cpu->env;\n\n    uint8_t ar;\n\n\n\n    addr = decode_basedisp_s(env, ipb, &ar);\n\n    if (addr & 3) {\n\n        program_interrupt(env, PGM_SPECIFICATION, 2);\n\n        return;\n\n    }\n\n    if (s390_cpu_virt_mem_read(cpu, addr, ar, &schib, sizeof(schib))) {\n\n        return;\n\n    }\n\n    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid) ||\n\n        !ioinst_schib_valid(&schib)) {\n\n        program_interrupt(env, PGM_OPERAND, 2);\n\n        return;\n\n    }\n\n    trace_ioinst_sch_id(\"msch\", cssid, ssid, schid);\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (sch && css_subch_visible(sch)) {\n\n        ret = css_do_msch(sch, &schib);\n\n    }\n\n    switch (ret) {\n\n    case -ENODEV:\n\n        cc = 3;\n\n        break;\n\n    case -EBUSY:\n\n        cc = 2;\n\n        break;\n\n    case 0:\n\n        cc = 0;\n\n        break;\n\n    default:\n\n        cc = 1;\n\n        break;\n\n    }\n\n    setcc(cpu, cc);\n\n}\n", "idx": 18931, "_split": "test", "_hash": "486b6df2fd315ddffe08e0a7048198ea"}
{"project": "qemu", "commit_id": "7e5f90fa3ff32ea31548666d57a78005555ecf34", "target": 1, "func": "int load_uimage(const char *filename, target_ulong *ep, target_ulong *loadaddr,\n\n                int *is_linux)\n\n{\n\n    int fd;\n\n    int size;\n\n    uboot_image_header_t h;\n\n    uboot_image_header_t *hdr = &h;\n\n    uint8_t *data = NULL;\n\n    int ret = -1;\n\n\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n\n    if (fd < 0)\n\n        return -1;\n\n\n\n    size = read(fd, hdr, sizeof(uboot_image_header_t));\n\n    if (size < 0)\n\n        goto out;\n\n\n\n    bswap_uboot_header(hdr);\n\n\n\n    if (hdr->ih_magic != IH_MAGIC)\n\n        goto out;\n\n\n\n    /* TODO: Implement Multi-File images.  */\n\n    if (hdr->ih_type == IH_TYPE_MULTI) {\n\n        fprintf(stderr, \"Unable to load multi-file u-boot images\\n\");\n\n        goto out;\n\n    }\n\n\n\n    switch (hdr->ih_comp) {\n\n    case IH_COMP_NONE:\n\n    case IH_COMP_GZIP:\n\n        break;\n\n    default:\n\n        fprintf(stderr,\n\n                \"Unable to load u-boot images with compression type %d\\n\",\n\n                hdr->ih_comp);\n\n        goto out;\n\n    }\n\n\n\n    /* TODO: Check CPU type.  */\n\n    if (is_linux) {\n\n        if (hdr->ih_type == IH_TYPE_KERNEL && hdr->ih_os == IH_OS_LINUX)\n\n            *is_linux = 1;\n\n        else\n\n            *is_linux = 0;\n\n    }\n\n\n\n    *ep = hdr->ih_ep;\n\n    data = qemu_malloc(hdr->ih_size);\n\n    if (!data)\n\n        goto out;\n\n\n\n    if (read(fd, data, hdr->ih_size) != hdr->ih_size) {\n\n        fprintf(stderr, \"Error reading file\\n\");\n\n        goto out;\n\n    }\n\n\n\n    if (hdr->ih_comp == IH_COMP_GZIP) {\n\n        uint8_t *compressed_data;\n\n        size_t max_bytes;\n\n        ssize_t bytes;\n\n\n\n        compressed_data = data;\n\n        max_bytes = UBOOT_MAX_GUNZIP_BYTES;\n\n        data = qemu_malloc(max_bytes);\n\n\n\n        bytes = gunzip(data, max_bytes, compressed_data, hdr->ih_size);\n\n        qemu_free(compressed_data);\n\n        if (bytes < 0) {\n\n            fprintf(stderr, \"Unable to decompress gzipped image!\\n\");\n\n            goto out;\n\n        }\n\n        hdr->ih_size = bytes;\n\n    }\n\n\n\n    cpu_physical_memory_write_rom(hdr->ih_load, data, hdr->ih_size);\n\n\n\n    if (loadaddr)\n\n        *loadaddr = hdr->ih_load;\n\n\n\n    ret = hdr->ih_size;\n\n\n\nout:\n\n    if (data)\n\n        qemu_free(data);\n\n    close(fd);\n\n    return ret;\n\n}\n", "idx": 18942, "_split": "test", "_hash": "c907ce3b612b17b7dd1901165c1e8457"}
{"project": "qemu", "commit_id": "27bb0b2d6f80f058bdb6fcc8fcdfa69b0c8a6d71", "target": 1, "func": "static void hpet_ram_writel(void *opaque, target_phys_addr_t addr,\n\n                            uint32_t value)\n\n{\n\n    int i;\n\n    HPETState *s = (HPETState *)opaque;\n\n    uint64_t old_val, new_val, val, index;\n\n\n\n    DPRINTF(\"qemu: Enter hpet_ram_writel at %\" PRIx64 \" = %#x\\n\", addr, value);\n\n    index = addr;\n\n    old_val = hpet_ram_readl(opaque, addr);\n\n    new_val = value;\n\n\n\n    /*address range of all TN regs*/\n\n    if (index >= 0x100 && index <= 0x3ff) {\n\n        uint8_t timer_id = (addr - 0x100) / 0x20;\n\n        DPRINTF(\"qemu: hpet_ram_writel timer_id = %#x \\n\", timer_id);\n\n        HPETTimer *timer = &s->timer[timer_id];\n\n\n\n        if (timer_id > HPET_NUM_TIMERS - 1) {\n\n            DPRINTF(\"qemu: timer id out of range\\n\");\n\n            return;\n\n        }\n\n        switch ((addr - 0x100) % 0x20) {\n\n            case HPET_TN_CFG:\n\n                DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CFG\\n\");\n\n                val = hpet_fixup_reg(new_val, old_val, HPET_TN_CFG_WRITE_MASK);\n\n                timer->config = (timer->config & 0xffffffff00000000ULL) | val;\n\n                if (new_val & HPET_TN_32BIT) {\n\n                    timer->cmp = (uint32_t)timer->cmp;\n\n                    timer->period = (uint32_t)timer->period;\n\n                }\n\n                if (new_val & HPET_TIMER_TYPE_LEVEL) {\n\n                    printf(\"qemu: level-triggered hpet not supported\\n\");\n\n                    exit (-1);\n\n                }\n\n\n\n                break;\n\n            case HPET_TN_CFG + 4: // Interrupt capabilities\n\n                DPRINTF(\"qemu: invalid HPET_TN_CFG+4 write\\n\");\n\n                break;\n\n            case HPET_TN_CMP: // comparator register\n\n                DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CMP \\n\");\n\n                if (timer->config & HPET_TN_32BIT)\n\n                    new_val = (uint32_t)new_val;\n\n                if (!timer_is_periodic(timer) ||\n\n                           (timer->config & HPET_TN_SETVAL))\n\n                    timer->cmp = (timer->cmp & 0xffffffff00000000ULL)\n\n                                  | new_val;\n\n                if (timer_is_periodic(timer)) {\n\n                    /*\n\n                     * FIXME: Clamp period to reasonable min value?\n\n                     * Clamp period to reasonable max value\n\n                     */\n\n                    new_val &= (timer->config & HPET_TN_32BIT ? ~0u : ~0ull) >> 1;\n\n                    timer->period = (timer->period & 0xffffffff00000000ULL)\n\n                                     | new_val;\n\n                }\n\n                timer->config &= ~HPET_TN_SETVAL;\n\n                if (hpet_enabled())\n\n                    hpet_set_timer(timer);\n\n                break;\n\n            case HPET_TN_CMP + 4: // comparator register high order\n\n                DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CMP + 4\\n\");\n\n                if (!timer_is_periodic(timer) ||\n\n                           (timer->config & HPET_TN_SETVAL))\n\n                    timer->cmp = (timer->cmp & 0xffffffffULL)\n\n                                  | new_val << 32;\n\n                else {\n\n                    /*\n\n                     * FIXME: Clamp period to reasonable min value?\n\n                     * Clamp period to reasonable max value\n\n                     */\n\n                    new_val &= (timer->config\n\n                                & HPET_TN_32BIT ? ~0u : ~0ull) >> 1;\n\n                    timer->period = (timer->period & 0xffffffffULL)\n\n                                     | new_val << 32;\n\n                }\n\n                timer->config &= ~HPET_TN_SETVAL;\n\n                if (hpet_enabled())\n\n                    hpet_set_timer(timer);\n\n                break;\n\n            case HPET_TN_ROUTE + 4:\n\n                DPRINTF(\"qemu: hpet_ram_writel HPET_TN_ROUTE + 4\\n\");\n\n                break;\n\n            default:\n\n                DPRINTF(\"qemu: invalid hpet_ram_writel\\n\");\n\n                break;\n\n        }\n\n        return;\n\n    } else {\n\n        switch (index) {\n\n            case HPET_ID:\n\n                return;\n\n            case HPET_CFG:\n\n                val = hpet_fixup_reg(new_val, old_val, HPET_CFG_WRITE_MASK);\n\n                s->config = (s->config & 0xffffffff00000000ULL) | val;\n\n                if (activating_bit(old_val, new_val, HPET_CFG_ENABLE)) {\n\n                    /* Enable main counter and interrupt generation. */\n\n                    s->hpet_offset = ticks_to_ns(s->hpet_counter)\n\n                                     - qemu_get_clock(vm_clock);\n\n                    for (i = 0; i < HPET_NUM_TIMERS; i++)\n\n                        if ((&s->timer[i])->cmp != ~0ULL)\n\n                            hpet_set_timer(&s->timer[i]);\n\n                }\n\n                else if (deactivating_bit(old_val, new_val, HPET_CFG_ENABLE)) {\n\n                    /* Halt main counter and disable interrupt generation. */\n\n                    s->hpet_counter = hpet_get_ticks();\n\n                    for (i = 0; i < HPET_NUM_TIMERS; i++)\n\n                        hpet_del_timer(&s->timer[i]);\n\n                }\n\n                /* i8254 and RTC are disabled when HPET is in legacy mode */\n\n                if (activating_bit(old_val, new_val, HPET_CFG_LEGACY)) {\n\n                    hpet_pit_disable();\n\n                } else if (deactivating_bit(old_val, new_val, HPET_CFG_LEGACY)) {\n\n                    hpet_pit_enable();\n\n                }\n\n                break;\n\n            case HPET_CFG + 4:\n\n                DPRINTF(\"qemu: invalid HPET_CFG+4 write \\n\");\n\n                break;\n\n            case HPET_STATUS:\n\n                /* FIXME: need to handle level-triggered interrupts */\n\n                break;\n\n            case HPET_COUNTER:\n\n               if (hpet_enabled())\n\n                   printf(\"qemu: Writing counter while HPET enabled!\\n\");\n\n               s->hpet_counter = (s->hpet_counter & 0xffffffff00000000ULL)\n\n                                  | value;\n\n               DPRINTF(\"qemu: HPET counter written. ctr = %#x -> %\" PRIx64 \"\\n\",\n\n                        value, s->hpet_counter);\n\n               break;\n\n            case HPET_COUNTER + 4:\n\n               if (hpet_enabled())\n\n                   printf(\"qemu: Writing counter while HPET enabled!\\n\");\n\n               s->hpet_counter = (s->hpet_counter & 0xffffffffULL)\n\n                                  | (((uint64_t)value) << 32);\n\n               DPRINTF(\"qemu: HPET counter + 4 written. ctr = %#x -> %\" PRIx64 \"\\n\",\n\n                        value, s->hpet_counter);\n\n               break;\n\n            default:\n\n               DPRINTF(\"qemu: invalid hpet_ram_writel\\n\");\n\n               break;\n\n        }\n\n    }\n\n}\n", "idx": 18969, "_split": "test", "_hash": "63b29d5ec0842c7c049944b87b168f4b"}
{"project": "qemu", "commit_id": "2af3da91839c04a5d73643b4eacce4cd93b9d428", "target": 0, "func": "void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,\n\n        int flags)\n\n{\n\n    int i;\n\n\n\n    cpu_fprintf(f, \"PC=%08x\\n\", env->pc);\n\n\n\n    for (i = 0; i < 16; ++i) {\n\n        cpu_fprintf(f, \"A%02d=%08x%c\", i, env->regs[i],\n\n                (i % 4) == 3 ? '\\n' : ' ');\n\n    }\n\n}\n", "idx": 18988, "_split": "test", "_hash": "5db69473c9907ce237753344502d996f"}
{"project": "qemu", "commit_id": "8d0bcba8370a4e8606dee602393a14d0c48e8bfc", "target": 0, "func": "int net_init_socket(const NetClientOptions *opts, const char *name,\n\n                    NetClientState *peer, Error **errp)\n\n{\n\n    /* FIXME error_setg(errp, ...) on failure */\n\n    Error *err = NULL;\n\n    const NetdevSocketOptions *sock;\n\n\n\n    assert(opts->kind == NET_CLIENT_OPTIONS_KIND_SOCKET);\n\n    sock = opts->socket;\n\n\n\n    if (sock->has_fd + sock->has_listen + sock->has_connect + sock->has_mcast +\n\n        sock->has_udp != 1) {\n\n        error_report(\"exactly one of fd=, listen=, connect=, mcast= or udp=\"\n\n                     \" is required\");\n\n        return -1;\n\n    }\n\n\n\n    if (sock->has_localaddr && !sock->has_mcast && !sock->has_udp) {\n\n        error_report(\"localaddr= is only valid with mcast= or udp=\");\n\n        return -1;\n\n    }\n\n\n\n    if (sock->has_fd) {\n\n        int fd;\n\n\n\n        fd = monitor_fd_param(cur_mon, sock->fd, &err);\n\n        if (fd == -1) {\n\n            error_report_err(err);\n\n            return -1;\n\n        }\n\n        qemu_set_nonblock(fd);\n\n        if (!net_socket_fd_init(peer, \"socket\", name, fd, 1)) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_listen) {\n\n        if (net_socket_listen_init(peer, \"socket\", name, sock->listen) == -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_connect) {\n\n        if (net_socket_connect_init(peer, \"socket\", name, sock->connect) ==\n\n            -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_mcast) {\n\n        /* if sock->localaddr is missing, it has been initialized to \"all bits\n\n         * zero\" */\n\n        if (net_socket_mcast_init(peer, \"socket\", name, sock->mcast,\n\n            sock->localaddr) == -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    assert(sock->has_udp);\n\n    if (!sock->has_localaddr) {\n\n        error_report(\"localaddr= is mandatory with udp=\");\n\n        return -1;\n\n    }\n\n    if (net_socket_udp_init(peer, \"socket\", name, sock->udp, sock->localaddr) ==\n\n        -1) {\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 19003, "_split": "test", "_hash": "e81454fbbdb7898c17c8f55a0fc77c2d"}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_bool(v, obj, name, errp);\n\n    }\n\n}\n", "idx": 19005, "_split": "test", "_hash": "7822f261871d33157d87370a8cbf9ae0"}
{"project": "qemu", "commit_id": "7364dbdabb7824d5bde1e341bb6d928282f01c83", "target": 1, "func": "static int protocol_version(VncState *vs, uint8_t *version, size_t len)\n\n{\n\n    char local[13];\n\n\n\n    memcpy(local, version, 12);\n\n    local[12] = 0;\n\n\n\n    if (sscanf(local, \"RFB %03d.%03d\\n\", &vs->major, &vs->minor) != 2) {\n\n        VNC_DEBUG(\"Malformed protocol version %s\\n\", local);\n\n        vnc_client_error(vs);\n\n        return 0;\n\n    }\n\n    VNC_DEBUG(\"Client request protocol version %d.%d\\n\", vs->major, vs->minor);\n\n    if (vs->major != 3 ||\n\n        (vs->minor != 3 &&\n\n         vs->minor != 4 &&\n\n         vs->minor != 5 &&\n\n         vs->minor != 7 &&\n\n         vs->minor != 8)) {\n\n        VNC_DEBUG(\"Unsupported client version\\n\");\n\n        vnc_write_u32(vs, VNC_AUTH_INVALID);\n\n        vnc_flush(vs);\n\n        vnc_client_error(vs);\n\n        return 0;\n\n    }\n\n    /* Some broken clients report v3.4 or v3.5, which spec requires to be treated\n\n     * as equivalent to v3.3 by servers\n\n     */\n\n    if (vs->minor == 4 || vs->minor == 5)\n\n        vs->minor = 3;\n\n\n\n    if (vs->minor == 3) {\n\n        if (vs->auth == VNC_AUTH_NONE) {\n\n            VNC_DEBUG(\"Tell client auth none\\n\");\n\n            vnc_write_u32(vs, vs->auth);\n\n            vnc_flush(vs);\n\n            start_client_init(vs);\n\n       } else if (vs->auth == VNC_AUTH_VNC) {\n\n            VNC_DEBUG(\"Tell client VNC auth\\n\");\n\n            vnc_write_u32(vs, vs->auth);\n\n            vnc_flush(vs);\n\n            start_auth_vnc(vs);\n\n       } else {\n\n            VNC_DEBUG(\"Unsupported auth %d for protocol 3.3\\n\", vs->auth);\n\n            vnc_write_u32(vs, VNC_AUTH_INVALID);\n\n            vnc_flush(vs);\n\n            vnc_client_error(vs);\n\n       }\n\n    } else {\n\n        VNC_DEBUG(\"Telling client we support auth %d\\n\", vs->auth);\n\n        vnc_write_u8(vs, 1); /* num auth */\n\n        vnc_write_u8(vs, vs->auth);\n\n        vnc_read_when(vs, protocol_client_auth, 1);\n\n        vnc_flush(vs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 19023, "_split": "test", "_hash": "f173ea16d4719bf1c3b475ec95efe06c"}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)\n\n{\n\n    struct pxa2xx_pic_state_s *s;\n\n    int iomemtype;\n\n    qemu_irq *qi;\n\n\n\n    s = (struct pxa2xx_pic_state_s *)\n\n            qemu_mallocz(sizeof(struct pxa2xx_pic_state_s));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->cpu_env = env;\n\n    s->base = base;\n\n\n\n    s->int_pending[0] = 0;\n\n    s->int_pending[1] = 0;\n\n    s->int_enabled[0] = 0;\n\n    s->int_enabled[1] = 0;\n\n    s->is_fiq[0] = 0;\n\n    s->is_fiq[1] = 0;\n\n\n\n    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);\n\n\n\n    /* Enable IC memory-mapped registers access.  */\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_pic_readfn,\n\n                    pxa2xx_pic_writefn, s);\n\n    cpu_register_physical_memory(base, 0x000fffff, iomemtype);\n\n\n\n    /* Enable IC coprocessor access.  */\n\n    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);\n\n\n\n    register_savevm(\"pxa2xx_pic\", 0, 0, pxa2xx_pic_save, pxa2xx_pic_load, s);\n\n\n\n    return qi;\n\n}\n", "idx": 19027, "_split": "test", "_hash": "8cfeccda6a595cdfc3e5944a77379470"}
{"project": "qemu", "commit_id": "129c7d1c536d0c67a8781cb09fb5bdb3d0f6a2d0", "target": 1, "func": "static InetSocketAddress *ssh_config(QDict *options, Error **errp)\n\n{\n\n    InetSocketAddress *inet = NULL;\n\n    QDict *addr = NULL;\n\n    QObject *crumpled_addr = NULL;\n\n    Visitor *iv = NULL;\n\n    Error *local_error = NULL;\n\n\n\n    qdict_extract_subqdict(options, &addr, \"server.\");\n\n    if (!qdict_size(addr)) {\n\n        error_setg(errp, \"SSH server address missing\");\n\n        goto out;\n\n    }\n\n\n\n    crumpled_addr = qdict_crumple(addr, errp);\n\n    if (!crumpled_addr) {\n\n        goto out;\n\n    }\n\n\n\n\n\n\n\n\n\n\n\n    iv = qobject_input_visitor_new(crumpled_addr);\n\n    visit_type_InetSocketAddress(iv, NULL, &inet, &local_error);\n\n    if (local_error) {\n\n        error_propagate(errp, local_error);\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    QDECREF(addr);\n\n    qobject_decref(crumpled_addr);\n\n    visit_free(iv);\n\n    return inet;\n\n}", "idx": 19075, "_split": "test", "_hash": "b666044bbab45a6feab2f4477e3996f5"}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "sdhci_buff_access_is_sequential(SDHCIState *s, unsigned byte_num)\n\n{\n\n    if ((s->data_count & 0x3) != byte_num) {\n\n        ERRPRINT(\"Non-sequential access to Buffer Data Port register\"\n\n                \"is prohibited\\n\");\n\n        return false;\n\n    }\n\n    return true;\n\n}\n", "idx": 19082, "_split": "test", "_hash": "e2ac9aeeda7d73aa6d5fb57a6fa6b2e9"}
{"project": "qemu", "commit_id": "d1fdf257d52822695f5ace6c586e059aa17d4b79", "target": 0, "func": "static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)\n\n{\n\n    ssize_t ret;\n\n    guint watch;\n\n\n\n    assert(qemu_in_coroutine());\n\n    /* Negotiation are always in main loop. */\n\n    watch = qio_channel_add_watch(ioc,\n\n                                  G_IO_OUT,\n\n                                  nbd_negotiate_continue,\n\n                                  qemu_coroutine_self(),\n\n                                  NULL);\n\n    ret = write_sync(ioc, buffer, size, NULL);\n\n    g_source_remove(watch);\n\n    return ret;\n\n}\n", "idx": 19090, "_split": "test", "_hash": "7ef6be1cc97980b898970e254f25cd8d"}
{"project": "qemu", "commit_id": "031380d8770d2df6c386e4aeabd412007d3ebd54", "target": 0, "func": "static void aio_read_done(void *opaque, int ret)\n\n{\n\n    struct aio_ctx *ctx = opaque;\n\n    struct timeval t2;\n\n\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"readv failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->Pflag) {\n\n        void *cmp_buf = malloc(ctx->qiov.size);\n\n\n\n        memset(cmp_buf, ctx->pattern, ctx->qiov.size);\n\n        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {\n\n            printf(\"Pattern verification failed at offset %\"\n\n                   PRId64 \", %zd bytes\\n\", ctx->offset, ctx->qiov.size);\n\n        }\n\n        free(cmp_buf);\n\n    }\n\n\n\n    if (ctx->qflag) {\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->vflag) {\n\n        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, ctx->t1);\n\n    print_report(\"read\", &t2, ctx->offset, ctx->qiov.size,\n\n                 ctx->qiov.size, 1, ctx->Cflag);\n\nout:\n\n    qemu_io_free(ctx->buf);\n\n    free(ctx);\n\n}\n", "idx": 19102, "_split": "test", "_hash": "866f5fc3b95e57e00f8a37c2eee1e5c6"}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static void spr_read_tbu (DisasContext *ctx, int gprn, int sprn)\n\n{\n\n    if (use_icount) {\n\n        gen_io_start();\n\n    }\n\n    gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);\n\n    if (use_icount) {\n\n        gen_io_end();\n\n        gen_stop_exception(ctx);\n\n    }\n\n}\n", "idx": 19108, "_split": "test", "_hash": "646852170e554b715dec98bb7d45ad5d"}
{"project": "qemu", "commit_id": "732b530c1bd064bdcc29975c0b78fc6de8c47e7f", "target": 0, "func": "static void nvdimm_build_common_dsm(Aml *dev)\n\n{\n\n    Aml *method, *ifctx, *function, *dsm_mem, *unpatched, *result_size;\n\n    uint8_t byte_list[1];\n\n\n\n    method = aml_method(NVDIMM_COMMON_DSM, 4, AML_SERIALIZED);\n\n    function = aml_arg(2);\n\n    dsm_mem = aml_name(NVDIMM_ACPI_MEM_ADDR);\n\n\n\n    /*\n\n     * do not support any method if DSM memory address has not been\n\n     * patched.\n\n     */\n\n    unpatched = aml_if(aml_equal(dsm_mem, aml_int(0x0)));\n\n\n\n    /*\n\n     * function 0 is called to inquire what functions are supported by\n\n     * OSPM\n\n     */\n\n    ifctx = aml_if(aml_equal(function, aml_int(0)));\n\n    byte_list[0] = 0 /* No function Supported */;\n\n    aml_append(ifctx, aml_return(aml_buffer(1, byte_list)));\n\n    aml_append(unpatched, ifctx);\n\n\n\n    /* No function is supported yet. */\n\n    byte_list[0] = 1 /* Not Supported */;\n\n    aml_append(unpatched, aml_return(aml_buffer(1, byte_list)));\n\n    aml_append(method, unpatched);\n\n\n\n    /*\n\n     * The HDLE indicates the DSM function is issued from which device,\n\n     * it is not used at this time as no function is supported yet.\n\n     * Currently we make it always be 0 for all the devices and will set\n\n     * the appropriate value once real function is implemented.\n\n     */\n\n    aml_append(method, aml_store(aml_int(0x0), aml_name(\"HDLE\")));\n\n    aml_append(method, aml_store(aml_arg(1), aml_name(\"REVS\")));\n\n    aml_append(method, aml_store(aml_arg(2), aml_name(\"FUNC\")));\n\n\n\n    /*\n\n     * tell QEMU about the real address of DSM memory, then QEMU\n\n     * gets the control and fills the result in DSM memory.\n\n     */\n\n    aml_append(method, aml_store(dsm_mem, aml_name(\"NTFI\")));\n\n\n\n    result_size = aml_local(1);\n\n    aml_append(method, aml_store(aml_name(\"RLEN\"), result_size));\n\n    aml_append(method, aml_store(aml_shiftleft(result_size, aml_int(3)),\n\n                                 result_size));\n\n    aml_append(method, aml_create_field(aml_name(\"ODAT\"), aml_int(0),\n\n                                        result_size, \"OBUF\"));\n\n    aml_append(method, aml_concatenate(aml_buffer(0, NULL), aml_name(\"OBUF\"),\n\n                                       aml_arg(6)));\n\n    aml_append(method, aml_return(aml_arg(6)));\n\n    aml_append(dev, method);\n\n}\n", "idx": 19115, "_split": "test", "_hash": "330c4df864c1506e609f3c465dcf818d"}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static gnutls_anon_server_credentials vnc_tls_initialize_anon_cred(void)\n\n{\n\n    gnutls_anon_server_credentials anon_cred;\n\n    int ret;\n\n\n\n    if ((ret = gnutls_anon_allocate_server_credentials(&anon_cred)) < 0) {\n\n\tVNC_DEBUG(\"Cannot allocate credentials %s\\n\", gnutls_strerror(ret));\n\n\treturn NULL;\n\n    }\n\n\n\n    gnutls_anon_set_server_dh_params(anon_cred, dh_params);\n\n\n\n    return anon_cred;\n\n}\n", "idx": 19116, "_split": "test", "_hash": "a45609cf277d5474977142c8218f7837"}
{"project": "qemu", "commit_id": "a3f1afb43a09e4577571c044c48f2ba9e6e4ad06", "target": 0, "func": "static int zero_single_l2(BlockDriverState *bs, uint64_t offset,\n\n    unsigned int nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l2_table;\n\n    int l2_index;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Limit nb_clusters to one L2 table */\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t old_offset;\n\n\n\n        old_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        /* Update L2 entries */\n\n        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n\n        if (old_offset & QCOW_OFLAG_COMPRESSED) {\n\n            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);\n\n            qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST);\n\n        } else {\n\n            l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO);\n\n        }\n\n    }\n\n\n\n    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return nb_clusters;\n\n}\n", "idx": 19119, "_split": "test", "_hash": "9dbb1b86130f035e68fe1937e8ab2da8"}
{"project": "qemu", "commit_id": "67d5cd9722b230027d3d4267ae6069c5d8a65463", "target": 0, "func": "static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)\n\n{\n\n    S390pciState *s = opaque;\n\n\n\n    return &s->pbdev[PCI_SLOT(devfn)].as;\n\n}\n", "idx": 19126, "_split": "test", "_hash": "856738aab6e5e116b9a4200cabe3385f"}
{"project": "qemu", "commit_id": "7b899f4dd596dbb7d271f7fab36fbfffec84868e", "target": 0, "func": "static void test_info_commands(void)\n\n{\n\n    char *resp, *info, *info_buf, *endp;\n\n\n\n    info_buf = info = hmp(\"help info\");\n\n\n\n    while (*info) {\n\n        /* Extract the info command, ignore parameters and description */\n\n        g_assert(strncmp(info, \"info \", 5) == 0);\n\n        endp = strchr(&info[5], ' ');\n\n        g_assert(endp != NULL);\n\n        *endp = '\\0';\n\n        /* Now run the info command */\n\n        if (verbose) {\n\n            fprintf(stderr, \"\\t%s\\n\", info);\n\n        }\n\n        resp = hmp(info);\n\n        g_free(resp);\n\n        /* And move forward to the next line */\n\n        info = strchr(endp + 1, '\\n');\n\n        if (!info) {\n\n            break;\n\n        }\n\n        info += 1;\n\n    }\n\n\n\n    g_free(info_buf);\n\n}\n", "idx": 19128, "_split": "test", "_hash": "080ea7ee6a287d88046c7844a5764f7a"}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)\n\n{\n\n    uint8_t *old_code_ptr = s->code_ptr;\n\n    assert(ret != arg);\n\n#if TCG_TARGET_REG_BITS == 32\n\n    tcg_out_op_t(s, INDEX_op_mov_i32);\n\n#else\n\n    tcg_out_op_t(s, INDEX_op_mov_i64);\n\n#endif\n\n    tcg_out_r(s, ret);\n\n    tcg_out_r(s, arg);\n\n    old_code_ptr[1] = s->code_ptr - old_code_ptr;\n\n}\n", "idx": 19129, "_split": "test", "_hash": "6621470a54cf845b66fd6a1f8d441ea1"}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int do_token_in(USBDevice *s, USBPacket *p)\n\n{\n\n    int request, value, index;\n\n    int ret = 0;\n\n\n\n    assert(p->devep == 0);\n\n\n\n    request = (s->setup_buf[0] << 8) | s->setup_buf[1];\n\n    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];\n\n    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];\n\n \n\n    switch(s->setup_state) {\n\n    case SETUP_STATE_ACK:\n\n        if (!(s->setup_buf[0] & USB_DIR_IN)) {\n\n            ret = usb_device_handle_control(s, p, request, value, index,\n\n                                            s->setup_len, s->data_buf);\n\n            if (ret == USB_RET_ASYNC) {\n\n                return USB_RET_ASYNC;\n\n            }\n\n            s->setup_state = SETUP_STATE_IDLE;\n\n            if (ret > 0)\n\n                return 0;\n\n            return ret;\n\n        }\n\n\n\n        /* return 0 byte */\n\n        return 0;\n\n\n\n    case SETUP_STATE_DATA:\n\n        if (s->setup_buf[0] & USB_DIR_IN) {\n\n            int len = s->setup_len - s->setup_index;\n\n            if (len > p->iov.size) {\n\n                len = p->iov.size;\n\n            }\n\n            usb_packet_copy(p, s->data_buf + s->setup_index, len);\n\n            s->setup_index += len;\n\n            if (s->setup_index >= s->setup_len)\n\n                s->setup_state = SETUP_STATE_ACK;\n\n            return len;\n\n        }\n\n\n\n        s->setup_state = SETUP_STATE_IDLE;\n\n        return USB_RET_STALL;\n\n\n\n    default:\n\n        return USB_RET_STALL;\n\n    }\n\n}\n", "idx": 19133, "_split": "test", "_hash": "ab98e32e92619868e6687eb0e52b82b1"}
{"project": "qemu", "commit_id": "a193b0f0a8d7735f4eb2ff863fd0902a5fa5eec6", "target": 0, "func": "static int coroutine_fn backup_do_cow(BackupBlockJob *job,\n\n                                      int64_t offset, uint64_t bytes,\n\n                                      bool *error_is_read,\n\n                                      bool is_write_notifier)\n\n{\n\n    BlockBackend *blk = job->common.blk;\n\n    CowRequest cow_request;\n\n    struct iovec iov;\n\n    QEMUIOVector bounce_qiov;\n\n    void *bounce_buffer = NULL;\n\n    int ret = 0;\n\n    int64_t start, end; /* bytes */\n\n    int n; /* bytes */\n\n\n\n    qemu_co_rwlock_rdlock(&job->flush_rwlock);\n\n\n\n    start = QEMU_ALIGN_DOWN(offset, job->cluster_size);\n\n    end = QEMU_ALIGN_UP(bytes + offset, job->cluster_size);\n\n\n\n    trace_backup_do_cow_enter(job, start, offset, bytes);\n\n\n\n    wait_for_overlapping_requests(job, start, end);\n\n    cow_request_begin(&cow_request, job, start, end);\n\n\n\n    for (; start < end; start += job->cluster_size) {\n\n        if (test_bit(start / job->cluster_size, job->done_bitmap)) {\n\n            trace_backup_do_cow_skip(job, start);\n\n            continue; /* already copied */\n\n        }\n\n\n\n        trace_backup_do_cow_process(job, start);\n\n\n\n        n = MIN(job->cluster_size, job->common.len - start);\n\n\n\n        if (!bounce_buffer) {\n\n            bounce_buffer = blk_blockalign(blk, job->cluster_size);\n\n        }\n\n        iov.iov_base = bounce_buffer;\n\n        iov.iov_len = n;\n\n        qemu_iovec_init_external(&bounce_qiov, &iov, 1);\n\n\n\n        ret = blk_co_preadv(blk, start, bounce_qiov.size, &bounce_qiov,\n\n                            is_write_notifier ? BDRV_REQ_NO_SERIALISING : 0);\n\n        if (ret < 0) {\n\n            trace_backup_do_cow_read_fail(job, start, ret);\n\n            if (error_is_read) {\n\n                *error_is_read = true;\n\n            }\n\n            goto out;\n\n        }\n\n\n\n        if (buffer_is_zero(iov.iov_base, iov.iov_len)) {\n\n            ret = blk_co_pwrite_zeroes(job->target, start,\n\n                                       bounce_qiov.size, BDRV_REQ_MAY_UNMAP);\n\n        } else {\n\n            ret = blk_co_pwritev(job->target, start,\n\n                                 bounce_qiov.size, &bounce_qiov,\n\n                                 job->compress ? BDRV_REQ_WRITE_COMPRESSED : 0);\n\n        }\n\n        if (ret < 0) {\n\n            trace_backup_do_cow_write_fail(job, start, ret);\n\n            if (error_is_read) {\n\n                *error_is_read = false;\n\n            }\n\n            goto out;\n\n        }\n\n\n\n        set_bit(start / job->cluster_size, job->done_bitmap);\n\n\n\n        /* Publish progress, guest I/O counts as progress too.  Note that the\n\n         * offset field is an opaque progress value, it is not a disk offset.\n\n         */\n\n        job->bytes_read += n;\n\n        job->common.offset += n;\n\n    }\n\n\n\nout:\n\n    if (bounce_buffer) {\n\n        qemu_vfree(bounce_buffer);\n\n    }\n\n\n\n    cow_request_end(&cow_request);\n\n\n\n    trace_backup_do_cow_return(job, offset, bytes, ret);\n\n\n\n    qemu_co_rwlock_unlock(&job->flush_rwlock);\n\n\n\n    return ret;\n\n}\n", "idx": 19160, "_split": "test", "_hash": "1c9dbea5a22323a5ffc5ce429dc7fc70"}
{"project": "qemu", "commit_id": "d157ed5f7235f3d2d5596a514ad7507b18e24b88", "target": 0, "func": "static int inject_error(BlockDriverState *bs, BlkdebugRule *rule)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    int error = rule->options.inject.error;\n\n    bool immediately = rule->options.inject.immediately;\n\n\n\n    if (rule->options.inject.once) {\n\n        QSIMPLEQ_REMOVE(&s->active_rules, rule, BlkdebugRule, active_next);\n\n        remove_rule(rule);\n\n    }\n\n\n\n    if (!immediately) {\n\n        aio_co_schedule(qemu_get_current_aio_context(), qemu_coroutine_self());\n\n        qemu_coroutine_yield();\n\n    }\n\n\n\n    return -error;\n\n}\n", "idx": 19184, "_split": "test", "_hash": "c62d501e4acd6b9b7419ceaaaafbe67b"}
{"project": "qemu", "commit_id": "5d79b80b335c5f65f148d1bb1672d9d534ace73b", "target": 0, "func": "static void pflash_write(pflash_t *pfl, hwaddr offset,\n\n                         uint32_t value, int width, int be)\n\n{\n\n    uint8_t *p;\n\n    uint8_t cmd;\n\n\n\n    cmd = value;\n\n\n\n    DPRINTF(\"%s: writing offset \" TARGET_FMT_plx \" value %08x width %d wcycle 0x%x\\n\",\n\n            __func__, offset, value, width, pfl->wcycle);\n\n\n\n    if (!pfl->wcycle) {\n\n        /* Set the device in I/O access mode */\n\n        memory_region_rom_device_set_readable(&pfl->mem, false);\n\n    }\n\n\n\n    switch (pfl->wcycle) {\n\n    case 0:\n\n        /* read mode */\n\n        switch (cmd) {\n\n        case 0x00: /* ??? */\n\n            goto reset_flash;\n\n        case 0x10: /* Single Byte Program */\n\n        case 0x40: /* Single Byte Program */\n\n            DPRINTF(\"%s: Single Byte Program\\n\", __func__);\n\n            break;\n\n        case 0x20: /* Block erase */\n\n            p = pfl->storage;\n\n            offset &= ~(pfl->sector_len - 1);\n\n\n\n            DPRINTF(\"%s: block erase at \" TARGET_FMT_plx \" bytes %x\\n\",\n\n                    __func__, offset, (unsigned)pfl->sector_len);\n\n\n\n            if (!pfl->ro) {\n\n                memset(p + offset, 0xff, pfl->sector_len);\n\n                pflash_update(pfl, offset, pfl->sector_len);\n\n            } else {\n\n                pfl->status |= 0x20; /* Block erase error */\n\n            }\n\n            pfl->status |= 0x80; /* Ready! */\n\n            break;\n\n        case 0x50: /* Clear status bits */\n\n            DPRINTF(\"%s: Clear status bits\\n\", __func__);\n\n            pfl->status = 0x0;\n\n            goto reset_flash;\n\n        case 0x60: /* Block (un)lock */\n\n            DPRINTF(\"%s: Block unlock\\n\", __func__);\n\n            break;\n\n        case 0x70: /* Status Register */\n\n            DPRINTF(\"%s: Read status register\\n\", __func__);\n\n            pfl->cmd = cmd;\n\n            return;\n\n        case 0x90: /* Read Device ID */\n\n            DPRINTF(\"%s: Read Device information\\n\", __func__);\n\n            pfl->cmd = cmd;\n\n            return;\n\n        case 0x98: /* CFI query */\n\n            DPRINTF(\"%s: CFI query\\n\", __func__);\n\n            break;\n\n        case 0xe8: /* Write to buffer */\n\n            DPRINTF(\"%s: Write to buffer\\n\", __func__);\n\n            pfl->status |= 0x80; /* Ready! */\n\n            break;\n\n        case 0xf0: /* Probe for AMD flash */\n\n            DPRINTF(\"%s: Probe for AMD flash\\n\", __func__);\n\n            goto reset_flash;\n\n        case 0xff: /* Read array mode */\n\n            DPRINTF(\"%s: Read array mode\\n\", __func__);\n\n            goto reset_flash;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        pfl->wcycle++;\n\n        pfl->cmd = cmd;\n\n        break;\n\n    case 1:\n\n        switch (pfl->cmd) {\n\n        case 0x10: /* Single Byte Program */\n\n        case 0x40: /* Single Byte Program */\n\n            DPRINTF(\"%s: Single Byte Program\\n\", __func__);\n\n            if (!pfl->ro) {\n\n                pflash_data_write(pfl, offset, value, width, be);\n\n                pflash_update(pfl, offset, width);\n\n            } else {\n\n                pfl->status |= 0x10; /* Programming error */\n\n            }\n\n            pfl->status |= 0x80; /* Ready! */\n\n            pfl->wcycle = 0;\n\n        break;\n\n        case 0x20: /* Block erase */\n\n        case 0x28:\n\n            if (cmd == 0xd0) { /* confirm */\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0xff) { /* read array mode */\n\n                goto reset_flash;\n\n            } else\n\n                goto error_flash;\n\n\n\n            break;\n\n        case 0xe8:\n\n            DPRINTF(\"%s: block write of %x bytes\\n\", __func__, value);\n\n            pfl->counter = value;\n\n            pfl->wcycle++;\n\n            break;\n\n        case 0x60:\n\n            if (cmd == 0xd0) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0x01) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0xff) {\n\n                goto reset_flash;\n\n            } else {\n\n                DPRINTF(\"%s: Unknown (un)locking command\\n\", __func__);\n\n                goto reset_flash;\n\n            }\n\n            break;\n\n        case 0x98:\n\n            if (cmd == 0xff) {\n\n                goto reset_flash;\n\n            } else {\n\n                DPRINTF(\"%s: leaving query mode\\n\", __func__);\n\n            }\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    case 2:\n\n        switch (pfl->cmd) {\n\n        case 0xe8: /* Block write */\n\n            if (!pfl->ro) {\n\n                pflash_data_write(pfl, offset, value, width, be);\n\n            } else {\n\n                pfl->status |= 0x10; /* Programming error */\n\n            }\n\n\n\n            pfl->status |= 0x80;\n\n\n\n            if (!pfl->counter) {\n\n                hwaddr mask = pfl->writeblock_size - 1;\n\n                mask = ~mask;\n\n\n\n                DPRINTF(\"%s: block write finished\\n\", __func__);\n\n                pfl->wcycle++;\n\n                if (!pfl->ro) {\n\n                    /* Flush the entire write buffer onto backing storage.  */\n\n                    pflash_update(pfl, offset & mask, pfl->writeblock_size);\n\n                } else {\n\n                    pfl->status |= 0x10; /* Programming error */\n\n                }\n\n            }\n\n\n\n            pfl->counter--;\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    case 3: /* Confirm mode */\n\n        switch (pfl->cmd) {\n\n        case 0xe8: /* Block write */\n\n            if (cmd == 0xd0) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else {\n\n                DPRINTF(\"%s: unknown command for \\\"write block\\\"\\n\", __func__);\n\n                PFLASH_BUG(\"Write block confirm\");\n\n                goto reset_flash;\n\n            }\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    default:\n\n        /* Should never happen */\n\n        DPRINTF(\"%s: invalid write state\\n\",  __func__);\n\n        goto reset_flash;\n\n    }\n\n    return;\n\n\n\n error_flash:\n\n    qemu_log_mask(LOG_UNIMP, \"%s: Unimplemented flash cmd sequence \"\n\n                  \"(offset \" TARGET_FMT_plx \", wcycle 0x%x cmd 0x%x value 0x%x)\"\n\n                  \"\\n\", __func__, offset, pfl->wcycle, pfl->cmd, value);\n\n\n\n reset_flash:\n\n    memory_region_rom_device_set_readable(&pfl->mem, true);\n\n\n\n    pfl->bypass = 0;\n\n    pfl->wcycle = 0;\n\n    pfl->cmd = 0;\n\n}\n", "idx": 19198, "_split": "test", "_hash": "b399d93a0fbb53a39b102264fbfdb22a"}
{"project": "qemu", "commit_id": "4c055ab54fae39b6329c57bcb5334d59b920463e", "target": 0, "func": "int kvm_init_vcpu(CPUState *cpu)\n\n{\n\n    KVMState *s = kvm_state;\n\n    long mmap_size;\n\n    int ret;\n\n\n\n    DPRINTF(\"kvm_init_vcpu\\n\");\n\n\n\n    ret = kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)kvm_arch_vcpu_id(cpu));\n\n    if (ret < 0) {\n\n        DPRINTF(\"kvm_create_vcpu failed\\n\");\n\n        goto err;\n\n    }\n\n\n\n    cpu->kvm_fd = ret;\n\n    cpu->kvm_state = s;\n\n    cpu->kvm_vcpu_dirty = true;\n\n\n\n    mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);\n\n    if (mmap_size < 0) {\n\n        ret = mmap_size;\n\n        DPRINTF(\"KVM_GET_VCPU_MMAP_SIZE failed\\n\");\n\n        goto err;\n\n    }\n\n\n\n    cpu->kvm_run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,\n\n                        cpu->kvm_fd, 0);\n\n    if (cpu->kvm_run == MAP_FAILED) {\n\n        ret = -errno;\n\n        DPRINTF(\"mmap'ing vcpu state failed\\n\");\n\n        goto err;\n\n    }\n\n\n\n    if (s->coalesced_mmio && !s->coalesced_mmio_ring) {\n\n        s->coalesced_mmio_ring =\n\n            (void *)cpu->kvm_run + s->coalesced_mmio * PAGE_SIZE;\n\n    }\n\n\n\n    ret = kvm_arch_init_vcpu(cpu);\n\nerr:\n\n    return ret;\n\n}\n", "idx": 19204, "_split": "test", "_hash": "42da848b4982ebcf83122cc1b1babf9e"}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void arm_cpu_do_interrupt(CPUState *cs)\n{\n    ARMCPU *cpu = ARM_CPU(cs);\n    CPUARMState *env = &cpu->env;\n    unsigned int new_el = env->exception.target_el;\n    assert(!arm_feature(env, ARM_FEATURE_M));\n    arm_log_exception(cs->exception_index);\n    qemu_log_mask(CPU_LOG_INT, \"...from EL%d to EL%d\\n\", arm_current_el(env),\n                  new_el);\n    if (qemu_loglevel_mask(CPU_LOG_INT)\n        && !excp_is_internal(cs->exception_index)) {\n        qemu_log_mask(CPU_LOG_INT, \"...with ESR %x/0x%\" PRIx32 \"\\n\",\n                      env->exception.syndrome >> ARM_EL_EC_SHIFT,\n                      env->exception.syndrome);\n    }\n    if (arm_is_psci_call(cpu, cs->exception_index)) {\n        arm_handle_psci_call(cpu);\n        qemu_log_mask(CPU_LOG_INT, \"...handled as PSCI call\\n\");\n        return;\n    }\n    /* Semihosting semantics depend on the register width of the\n     * code that caused the exception, not the target exception level,\n     * so must be handled here.\n    if (check_for_semihosting(cs)) {\n        return;\n    }\n    assert(!excp_is_internal(cs->exception_index));\n    if (arm_el_is_aa64(env, new_el)) {\n        arm_cpu_do_interrupt_aarch64(cs);\n    } else {\n        arm_cpu_do_interrupt_aarch32(cs);\n    }\n    arm_call_el_change_hook(cpu);\n    if (!kvm_enabled()) {\n        cs->interrupt_request |= CPU_INTERRUPT_EXITTB;\n    }\n}", "idx": 19216, "_split": "test", "_hash": "f6423fee8e3f7e32ed6629cdd4652a78"}
{"project": "qemu", "commit_id": "e3f30488e5f802547b3a60e40cebaef3b4ec16a3", "target": 1, "func": "static void virtio_net_flush_tx(VirtIONet *n, VirtQueue *vq)\n\n{\n\n    VirtQueueElement elem;\n\n\n\n    if (!(n->vdev.status & VIRTIO_CONFIG_S_DRIVER_OK))\n\n        return;\n\n\n\n    if (n->async_tx.elem.out_num) {\n\n        virtio_queue_set_notification(n->tx_vq, 0);\n\n        return;\n\n    }\n\n\n\n    while (virtqueue_pop(vq, &elem)) {\n\n        ssize_t ret, len = 0;\n\n        unsigned int out_num = elem.out_num;\n\n        struct iovec *out_sg = &elem.out_sg[0];\n\n        unsigned hdr_len;\n\n\n\n        /* hdr_len refers to the header received from the guest */\n\n        hdr_len = n->mergeable_rx_bufs ?\n\n            sizeof(struct virtio_net_hdr_mrg_rxbuf) :\n\n            sizeof(struct virtio_net_hdr);\n\n\n\n        if (out_num < 1 || out_sg->iov_len != hdr_len) {\n\n            fprintf(stderr, \"virtio-net header not in first element\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        /* ignore the header if GSO is not supported */\n\n        if (!n->has_vnet_hdr) {\n\n            out_num--;\n\n            out_sg++;\n\n            len += hdr_len;\n\n        } else if (n->mergeable_rx_bufs) {\n\n            /* tapfd expects a struct virtio_net_hdr */\n\n            hdr_len -= sizeof(struct virtio_net_hdr);\n\n            out_sg->iov_len -= hdr_len;\n\n            len += hdr_len;\n\n        }\n\n\n\n        ret = qemu_sendv_packet_async(&n->nic->nc, out_sg, out_num,\n\n                                      virtio_net_tx_complete);\n\n        if (ret == 0) {\n\n            virtio_queue_set_notification(n->tx_vq, 0);\n\n            n->async_tx.elem = elem;\n\n            n->async_tx.len  = len;\n\n            return;\n\n        }\n\n\n\n        len += ret;\n\n\n\n        virtqueue_push(vq, &elem, len);\n\n        virtio_notify(&n->vdev, vq);\n\n    }\n\n}\n", "idx": 19223, "_split": "test", "_hash": "4eca5804dddfe8971e80aff280a69946"}
{"project": "qemu", "commit_id": "a1c5975270f2335e1d7129c084a6e562d7b99bdd", "target": 1, "func": "static void flush_queued_data(VirtIOSerialPort *port, bool discard)\n\n{\n\n    assert(port || discard);\n\n\n\n    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);\n\n}\n", "idx": 19237, "_split": "test", "_hash": "6e7cfecc71f629b7a806e56edcb74cf8"}
{"project": "qemu", "commit_id": "129c7d1c536d0c67a8781cb09fb5bdb3d0f6a2d0", "target": 1, "func": "static int hdev_open(BlockDriverState *bs, QDict *options, int flags,\n\n                     Error **errp)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n#if defined(__APPLE__) && defined(__MACH__)\n\n\n\n\n\n\n\n    const char *filename = qdict_get_str(options, \"filename\");\n\n    char bsd_path[MAXPATHLEN] = \"\";\n\n    bool error_occurred = false;\n\n\n\n    /* If using a real cdrom */\n\n    if (strcmp(filename, \"/dev/cdrom\") == 0) {\n\n        char *mediaType = NULL;\n\n        kern_return_t ret_val;\n\n        io_iterator_t mediaIterator = 0;\n\n\n\n        mediaType = FindEjectableOpticalMedia(&mediaIterator);\n\n        if (mediaType == NULL) {\n\n            error_setg(errp, \"Please make sure your CD/DVD is in the optical\"\n\n                       \" drive\");\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        ret_val = GetBSDPath(mediaIterator, bsd_path, sizeof(bsd_path), flags);\n\n        if (ret_val != KERN_SUCCESS) {\n\n            error_setg(errp, \"Could not get BSD path for optical drive\");\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        /* If a real optical drive was not found */\n\n        if (bsd_path[0] == '\\0') {\n\n            error_setg(errp, \"Failed to obtain bsd path for optical drive\");\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        /* If using a cdrom disc and finding a partition on the disc failed */\n\n        if (strncmp(mediaType, kIOCDMediaClass, 9) == 0 &&\n\n            setup_cdrom(bsd_path, errp) == false) {\n\n            print_unmounting_directions(bsd_path);\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        qdict_put(options, \"filename\", qstring_from_str(bsd_path));\n\n\n\nhdev_open_Mac_error:\n\n        g_free(mediaType);\n\n        if (mediaIterator) {\n\n            IOObjectRelease(mediaIterator);\n\n        }\n\n        if (error_occurred) {\n\n            return -ENOENT;\n\n        }\n\n    }\n\n#endif /* defined(__APPLE__) && defined(__MACH__) */\n\n\n\n    s->type = FTYPE_FILE;\n\n\n\n    ret = raw_open_common(bs, options, flags, 0, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n#if defined(__APPLE__) && defined(__MACH__)\n\n        if (*bsd_path) {\n\n            filename = bsd_path;\n\n        }\n\n        /* if a physical device experienced an error while being opened */\n\n        if (strncmp(filename, \"/dev/\", 5) == 0) {\n\n            print_unmounting_directions(filename);\n\n        }\n\n#endif /* defined(__APPLE__) && defined(__MACH__) */\n\n        return ret;\n\n    }\n\n\n\n    /* Since this does ioctl the device must be already opened */\n\n    bs->sg = hdev_is_sg(bs);\n\n\n\n    if (flags & BDRV_O_RDWR) {\n\n        ret = check_hdev_writable(s);\n\n        if (ret < 0) {\n\n            raw_close(bs);\n\n            error_setg_errno(errp, -ret, \"The device is not writable\");\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}", "idx": 19238, "_split": "test", "_hash": "bde884823fd7df12d0e4e078bb3ea05a"}
{"project": "qemu", "commit_id": "d3d250bddb3f6aa6c26e9dadf10e82d9fd8bfce3", "target": 1, "func": "int scsi_bus_legacy_handle_cmdline(SCSIBus *bus)\n\n{\n\n    Location loc;\n\n    DriveInfo *dinfo;\n\n    int res = 0, unit;\n\n\n\n    loc_push_none(&loc);\n\n    for (unit = 0; unit < bus->info->max_target; unit++) {\n\n        dinfo = drive_get(IF_SCSI, bus->busnr, unit);\n\n        if (dinfo == NULL) {\n\n            continue;\n\n        }\n\n        qemu_opts_loc_restore(dinfo->opts);\n\n        if (!scsi_bus_legacy_add_drive(bus, dinfo->bdrv, unit, false, -1)) {\n\n            res = -1;\n\n            break;\n\n        }\n\n    }\n\n    loc_pop(&loc);\n\n    return res;\n\n}\n", "idx": 19243, "_split": "test", "_hash": "9ef13568a8c050edb886b610be697956"}
{"project": "qemu", "commit_id": "46232aaacb66733d3e16dcbd0d26c32ec388801d", "target": 0, "func": "static void x86_cpu_common_class_init(ObjectClass *oc, void *data)\n\n{\n\n    X86CPUClass *xcc = X86_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    xcc->parent_realize = dc->realize;\n\n    dc->realize = x86_cpu_realizefn;\n\n    dc->bus_type = TYPE_ICC_BUS;\n\n    dc->props = x86_cpu_properties;\n\n\n\n    xcc->parent_reset = cc->reset;\n\n    cc->reset = x86_cpu_reset;\n\n    cc->reset_dump_flags = CPU_DUMP_FPU | CPU_DUMP_CCOP;\n\n\n\n    cc->class_by_name = x86_cpu_class_by_name;\n\n    cc->parse_features = x86_cpu_parse_featurestr;\n\n    cc->has_work = x86_cpu_has_work;\n\n    cc->do_interrupt = x86_cpu_do_interrupt;\n\n    cc->cpu_exec_interrupt = x86_cpu_exec_interrupt;\n\n    cc->dump_state = x86_cpu_dump_state;\n\n    cc->set_pc = x86_cpu_set_pc;\n\n    cc->synchronize_from_tb = x86_cpu_synchronize_from_tb;\n\n    cc->gdb_read_register = x86_cpu_gdb_read_register;\n\n    cc->gdb_write_register = x86_cpu_gdb_write_register;\n\n    cc->get_arch_id = x86_cpu_get_arch_id;\n\n    cc->get_paging_enabled = x86_cpu_get_paging_enabled;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = x86_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_memory_mapping = x86_cpu_get_memory_mapping;\n\n    cc->get_phys_page_debug = x86_cpu_get_phys_page_debug;\n\n    cc->write_elf64_note = x86_cpu_write_elf64_note;\n\n    cc->write_elf64_qemunote = x86_cpu_write_elf64_qemunote;\n\n    cc->write_elf32_note = x86_cpu_write_elf32_note;\n\n    cc->write_elf32_qemunote = x86_cpu_write_elf32_qemunote;\n\n    cc->vmsd = &vmstate_x86_cpu;\n\n#endif\n\n    cc->gdb_num_core_regs = CPU_NB_REGS * 2 + 25;\n\n#ifndef CONFIG_USER_ONLY\n\n    cc->debug_excp_handler = breakpoint_handler;\n\n#endif\n\n    cc->cpu_exec_enter = x86_cpu_exec_enter;\n\n    cc->cpu_exec_exit = x86_cpu_exec_exit;\n\n}\n", "idx": 19253, "_split": "test", "_hash": "824b93034d4505c9f095f93e758d5e93"}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static int qpa_init_in (HWVoiceIn *hw, audsettings_t *as)\n\n{\n\n    int error;\n\n    static pa_sample_spec ss;\n\n    audsettings_t obt_as = *as;\n\n    PAVoiceIn *pa = (PAVoiceIn *) hw;\n\n\n\n    ss.format = audfmt_to_pa (as->fmt, as->endianness);\n\n    ss.channels = as->nchannels;\n\n    ss.rate = as->freq;\n\n\n\n    obt_as.fmt = pa_to_audfmt (ss.format, &obt_as.endianness);\n\n\n\n    pa->s = pa_simple_new (\n\n        conf.server,\n\n        \"qemu\",\n\n        PA_STREAM_RECORD,\n\n        conf.source,\n\n        \"pcm.capture\",\n\n        &ss,\n\n        NULL,                   /* channel map */\n\n        NULL,                   /* buffering attributes */\n\n        &error\n\n        );\n\n    if (!pa->s) {\n\n        qpa_logerr (error, \"pa_simple_new for capture failed\\n\");\n\n        goto fail1;\n\n    }\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    hw->samples = conf.samples;\n\n    pa->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    if (!pa->pcm_buf) {\n\n        dolog (\"Could not allocate buffer (%d bytes)\\n\",\n\n               hw->samples << hw->info.shift);\n\n        goto fail2;\n\n    }\n\n\n\n    if (audio_pt_init (&pa->pt, qpa_thread_in, hw, AUDIO_CAP, AUDIO_FUNC)) {\n\n        goto fail3;\n\n    }\n\n\n\n    return 0;\n\n\n\n fail3:\n\n    free (pa->pcm_buf);\n\n    pa->pcm_buf = NULL;\n\n fail2:\n\n    pa_simple_free (pa->s);\n\n    pa->s = NULL;\n\n fail1:\n\n    return -1;\n\n}\n", "idx": 19256, "_split": "test", "_hash": "26592d280a39c48ad0a39d9c34ceee0a"}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint32_t helper_compute_fprf (uint64_t arg, uint32_t set_fprf)\n\n{\n\n    CPU_DoubleU farg;\n\n    int isneg;\n\n    int ret;\n\n    farg.ll = arg;\n\n    isneg = float64_is_neg(farg.d);\n\n    if (unlikely(float64_is_nan(farg.d))) {\n\n        if (float64_is_signaling_nan(farg.d)) {\n\n            /* Signaling NaN: flags are undefined */\n\n            ret = 0x00;\n\n        } else {\n\n            /* Quiet NaN */\n\n            ret = 0x11;\n\n        }\n\n    } else if (unlikely(float64_is_infinity(farg.d))) {\n\n        /* +/- infinity */\n\n        if (isneg)\n\n            ret = 0x09;\n\n        else\n\n            ret = 0x05;\n\n    } else {\n\n        if (float64_is_zero(farg.d)) {\n\n            /* +/- zero */\n\n            if (isneg)\n\n                ret = 0x12;\n\n            else\n\n                ret = 0x02;\n\n        } else {\n\n            if (isden(farg.d)) {\n\n                /* Denormalized numbers */\n\n                ret = 0x10;\n\n            } else {\n\n                /* Normalized numbers */\n\n                ret = 0x00;\n\n            }\n\n            if (isneg) {\n\n                ret |= 0x08;\n\n            } else {\n\n                ret |= 0x04;\n\n            }\n\n        }\n\n    }\n\n    if (set_fprf) {\n\n        /* We update FPSCR_FPRF */\n\n        env->fpscr &= ~(0x1F << FPSCR_FPRF);\n\n        env->fpscr |= ret << FPSCR_FPRF;\n\n    }\n\n    /* We just need fpcc to update Rc1 */\n\n    return ret & 0xF;\n\n}\n", "idx": 19274, "_split": "test", "_hash": "c3247be313d7b99c8cf0f5d9eb5703e0"}
{"project": "qemu", "commit_id": "df8002103c3e262dc40d7b5e0eb2171ba28b1d63", "target": 0, "func": "void vga_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    VGACommonState *s = opaque;\n\n    int index;\n\n\n\n    /* check port range access depending on color/monochrome mode */\n\n    if (vga_ioport_invalid(s, addr)) {\n\n        return;\n\n    }\n\n#ifdef DEBUG_VGA\n\n    printf(\"VGA: write addr=0x%04x data=0x%02x\\n\", addr, val);\n\n#endif\n\n\n\n    switch(addr) {\n\n    case VGA_ATT_W:\n\n        if (s->ar_flip_flop == 0) {\n\n            val &= 0x3f;\n\n            s->ar_index = val;\n\n        } else {\n\n            index = s->ar_index & 0x1f;\n\n            switch(index) {\n\n            case VGA_ATC_PALETTE0 ... VGA_ATC_PALETTEF:\n\n                s->ar[index] = val & 0x3f;\n\n                break;\n\n            case VGA_ATC_MODE:\n\n                s->ar[index] = val & ~0x10;\n\n                break;\n\n            case VGA_ATC_OVERSCAN:\n\n                s->ar[index] = val;\n\n                break;\n\n            case VGA_ATC_PLANE_ENABLE:\n\n                s->ar[index] = val & ~0xc0;\n\n                break;\n\n            case VGA_ATC_PEL:\n\n                s->ar[index] = val & ~0xf0;\n\n                break;\n\n            case VGA_ATC_COLOR_PAGE:\n\n                s->ar[index] = val & ~0xf0;\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n        }\n\n        s->ar_flip_flop ^= 1;\n\n        break;\n\n    case VGA_MIS_W:\n\n        s->msr = val & ~0x10;\n\n        s->update_retrace_info(s);\n\n        break;\n\n    case VGA_SEQ_I:\n\n        s->sr_index = val & 7;\n\n        break;\n\n    case VGA_SEQ_D:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write SR%x = 0x%02x\\n\", s->sr_index, val);\n\n#endif\n\n        s->sr[s->sr_index] = val & sr_mask[s->sr_index];\n\n        if (s->sr_index == VGA_SEQ_CLOCK_MODE) {\n\n            s->update_retrace_info(s);\n\n        }\n\n        vga_update_memory_access(s);\n\n        break;\n\n    case VGA_PEL_IR:\n\n        s->dac_read_index = val;\n\n        s->dac_sub_index = 0;\n\n        s->dac_state = 3;\n\n        break;\n\n    case VGA_PEL_IW:\n\n        s->dac_write_index = val;\n\n        s->dac_sub_index = 0;\n\n        s->dac_state = 0;\n\n        break;\n\n    case VGA_PEL_D:\n\n        s->dac_cache[s->dac_sub_index] = val;\n\n        if (++s->dac_sub_index == 3) {\n\n            memcpy(&s->palette[s->dac_write_index * 3], s->dac_cache, 3);\n\n            s->dac_sub_index = 0;\n\n            s->dac_write_index++;\n\n        }\n\n        break;\n\n    case VGA_GFX_I:\n\n        s->gr_index = val & 0x0f;\n\n        break;\n\n    case VGA_GFX_D:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write GR%x = 0x%02x\\n\", s->gr_index, val);\n\n#endif\n\n        s->gr[s->gr_index] = val & gr_mask[s->gr_index];\n\n        vga_update_memory_access(s);\n\n        break;\n\n    case VGA_CRT_IM:\n\n    case VGA_CRT_IC:\n\n        s->cr_index = val;\n\n        break;\n\n    case VGA_CRT_DM:\n\n    case VGA_CRT_DC:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write CR%x = 0x%02x\\n\", s->cr_index, val);\n\n#endif\n\n        /* handle CR0-7 protection */\n\n        if (s->cr[VGA_CRTC_V_SYNC_END] & VGA_CR11_LOCK_CR0_CR7) {\n\n            if (s->cr_index <= VGA_CRTC_OVERFLOW) {\n\n                /* can always write bit 4 of CR7 */\n\n                if (s->cr_index == VGA_CRTC_OVERFLOW) {\n\n                    s->cr[VGA_CRTC_OVERFLOW] =\n\n                        (s->cr[VGA_CRTC_OVERFLOW] & ~0x10) | (val & 0x10);\n\n                }\n\n                return;\n\n            } else if ((vga_cga_hacks & VGA_CGA_HACK_FONT_HEIGHT) &&\n\n                       !(s->sr[VGA_SEQ_CLOCK_MODE] & VGA_SR01_CHAR_CLK_8DOTS)) {\n\n                /* extra CGA compatibility hacks (not in standard VGA) */\n\n                if (s->cr_index == VGA_CRTC_MAX_SCAN &&\n\n                    val == 7 &&\n\n                    (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    return;\n\n                } else if (s->cr_index == VGA_CRTC_CURSOR_START &&\n\n                           val == 6 &&\n\n                           (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    val = 0xd;\n\n                } else if (s->cr_index == VGA_CRTC_CURSOR_END &&\n\n                           val == 7 &&\n\n                           (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    val = 0xe;\n\n                }\n\n            }\n\n        }\n\n        s->cr[s->cr_index] = val;\n\n\n\n        switch(s->cr_index) {\n\n        case VGA_CRTC_H_TOTAL:\n\n        case VGA_CRTC_H_SYNC_START:\n\n        case VGA_CRTC_H_SYNC_END:\n\n        case VGA_CRTC_V_TOTAL:\n\n        case VGA_CRTC_OVERFLOW:\n\n        case VGA_CRTC_V_SYNC_END:\n\n        case VGA_CRTC_MODE:\n\n            s->update_retrace_info(s);\n\n            break;\n\n        }\n\n        break;\n\n    case VGA_IS1_RM:\n\n    case VGA_IS1_RC:\n\n        s->fcr = val & 0x10;\n\n        break;\n\n    }\n\n}\n", "idx": 19290, "_split": "test", "_hash": "817c2149e29db440119d7d448205e559"}
{"project": "qemu", "commit_id": "913440249ea2e697177e9d43167ac325a8dfe907", "target": 0, "func": "static int usbnet_can_receive(NetClientState *nc)\n\n{\n\n    USBNetState *s = qemu_get_nic_opaque(nc);\n\n\n\n    if (!s->dev.config) {\n\n        return 0;\n\n    }\n\n\n\n    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {\n\n        return 1;\n\n    }\n\n\n\n    return !s->in_len;\n\n}\n", "idx": 19291, "_split": "test", "_hash": "fbd5b1c3cea98a3e6bf59d5fe23ac866"}
{"project": "qemu", "commit_id": "b63c7f6b77145c109d66a62bb3b6efe12b80d62b", "target": 0, "func": "static void dhcp_decode(const uint8_t *buf, int size,\n\n                        int *pmsg_type)\n\n{\n\n    const uint8_t *p, *p_end;\n\n    int len, tag;\n\n\n\n    *pmsg_type = 0;\n\n\n\n    p = buf;\n\n    p_end = buf + size;\n\n    if (size < 5)\n\n        return;\n\n    if (memcmp(p, rfc1533_cookie, 4) != 0)\n\n        return;\n\n    p += 4;\n\n    while (p < p_end) {\n\n        tag = p[0];\n\n        if (tag == RFC1533_PAD) {\n\n            p++;\n\n        } else if (tag == RFC1533_END) {\n\n            break;\n\n        } else {\n\n            p++;\n\n            if (p >= p_end)\n\n                break;\n\n            len = *p++;\n\n            dprintf(\"dhcp: tag=0x%02x len=%d\\n\", tag, len);\n\n\n\n            switch(tag) {\n\n            case RFC2132_MSG_TYPE:\n\n                if (len >= 1)\n\n                    *pmsg_type = p[0];\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n            p += len;\n\n        }\n\n    }\n\n}\n", "idx": 19301, "_split": "test", "_hash": "b6ffdab146b28d2c645e25261df6bd48"}
{"project": "qemu", "commit_id": "ddb603ab6c981c1d67cb42266fc700c33e5b2d8f", "target": 0, "func": "static int xhci_fire_ctl_transfer(XHCIState *xhci, XHCITransfer *xfer)\n\n{\n\n    XHCITRB *trb_setup, *trb_status;\n\n    uint8_t bmRequestType;\n\n\n\n    trb_setup = &xfer->trbs[0];\n\n    trb_status = &xfer->trbs[xfer->trb_count-1];\n\n\n\n    trace_usb_xhci_xfer_start(xfer, xfer->epctx->slotid,\n\n                              xfer->epctx->epid, xfer->streamid);\n\n\n\n    /* at most one Event Data TRB allowed after STATUS */\n\n    if (TRB_TYPE(*trb_status) == TR_EVDATA && xfer->trb_count > 2) {\n\n        trb_status--;\n\n    }\n\n\n\n    /* do some sanity checks */\n\n    if (TRB_TYPE(*trb_setup) != TR_SETUP) {\n\n        DPRINTF(\"xhci: ep0 first TD not SETUP: %d\\n\",\n\n                TRB_TYPE(*trb_setup));\n\n        return -1;\n\n    }\n\n    if (TRB_TYPE(*trb_status) != TR_STATUS) {\n\n        DPRINTF(\"xhci: ep0 last TD not STATUS: %d\\n\",\n\n                TRB_TYPE(*trb_status));\n\n        return -1;\n\n    }\n\n    if (!(trb_setup->control & TRB_TR_IDT)) {\n\n        DPRINTF(\"xhci: Setup TRB doesn't have IDT set\\n\");\n\n        return -1;\n\n    }\n\n    if ((trb_setup->status & 0x1ffff) != 8) {\n\n        DPRINTF(\"xhci: Setup TRB has bad length (%d)\\n\",\n\n                (trb_setup->status & 0x1ffff));\n\n        return -1;\n\n    }\n\n\n\n    bmRequestType = trb_setup->parameter;\n\n\n\n    xfer->in_xfer = bmRequestType & USB_DIR_IN;\n\n    xfer->iso_xfer = false;\n\n    xfer->timed_xfer = false;\n\n\n\n    if (xhci_setup_packet(xfer) < 0) {\n\n        return -1;\n\n    }\n\n    xfer->packet.parameter = trb_setup->parameter;\n\n\n\n    usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n\n\n    xhci_try_complete_packet(xfer);\n\n    if (!xfer->running_async && !xfer->running_retry) {\n\n        xhci_kick_epctx(xfer->epctx, 0);\n\n    }\n\n    return 0;\n\n}\n", "idx": 19307, "_split": "test", "_hash": "73ae78209054ea27b2b6f35ce7b1022a"}
{"project": "qemu", "commit_id": "cbcfa0418f0c196afa765f5c9837b9344d1adcf3", "target": 0, "func": "void qemu_free_timer(QEMUTimer *ts)\n\n{\n\n    g_free(ts);\n\n}\n", "idx": 19322, "_split": "test", "_hash": "190f5e277ebae30eb213e6c2a485aed1"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    int start_track, format, msf, toclen;\n\n    uint64_t nb_sectors;\n\n\n\n    msf = req->cmd.buf[1] & 2;\n\n    format = req->cmd.buf[2] & 0xf;\n\n    start_track = req->cmd.buf[6];\n\n    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n    DPRINTF(\"Read TOC (track %d format %d msf %d)\\n\", start_track, format, msf >> 1);\n\n    nb_sectors /= s->qdev.blocksize / 512;\n\n    switch (format) {\n\n    case 0:\n\n        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);\n\n        break;\n\n    case 1:\n\n        /* multi session : only a single session defined */\n\n        toclen = 12;\n\n        memset(outbuf, 0, 12);\n\n        outbuf[1] = 0x0a;\n\n        outbuf[2] = 0x01;\n\n        outbuf[3] = 0x01;\n\n        break;\n\n    case 2:\n\n        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    return toclen;\n\n}\n", "idx": 19373, "_split": "test", "_hash": "24cdbaa7721d04cbe5dd3f93f4c4aa57"}
{"project": "qemu", "commit_id": "0d1c5c91607d1c55a8f5db39c57c6e5c76e21131", "target": 0, "func": "void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    if (!bs->drv)  {\n\n        return;\n\n    }\n\n\n\n    if (!(bs->open_flags & BDRV_O_INACTIVE)) {\n\n        return;\n\n    }\n\n    bs->open_flags &= ~BDRV_O_INACTIVE;\n\n\n\n    if (bs->drv->bdrv_invalidate_cache) {\n\n        bs->drv->bdrv_invalidate_cache(bs, &local_err);\n\n    } else if (bs->file) {\n\n        bdrv_invalidate_cache(bs->file->bs, &local_err);\n\n    }\n\n    if (local_err) {\n\n        bs->open_flags |= BDRV_O_INACTIVE;\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    ret = refresh_total_sectors(bs, bs->total_sectors);\n\n    if (ret < 0) {\n\n        bs->open_flags |= BDRV_O_INACTIVE;\n\n        error_setg_errno(errp, -ret, \"Could not refresh total sector count\");\n\n        return;\n\n    }\n\n}\n", "idx": 19380, "_split": "test", "_hash": "39d6f561f8a3cccb29457f1e8ffa17e7"}
{"project": "qemu", "commit_id": "dc638fadb54c911019227ae37656560c49a209b9", "target": 0, "func": "static int usb_uhci_vt82c686b_initfn(PCIDevice *dev)\n\n{\n\n    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);\n\n    uint8_t *pci_conf = s->dev.config;\n\n\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_VIA);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_VIA_UHCI);\n\n\n\n    /* USB misc control 1/2 */\n\n    pci_set_long(pci_conf + 0x40,0x00001000);\n\n    /* PM capability */\n\n    pci_set_long(pci_conf + 0x80,0x00020001);\n\n    /* USB legacy support  */\n\n    pci_set_long(pci_conf + 0xc0,0x00002000);\n\n\n\n    return usb_uhci_common_initfn(s);\n\n}\n", "idx": 19389, "_split": "test", "_hash": "031d897a0ff74c0458473ab20032445d"}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)\n\n{\n\n    int rd = (insn >> 0) & 0xf;\n\n    TCGv tmp;\n\n\n\n    if (insn & (1 << 8)) {\n\n        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {\n\n            return 1;\n\n        } else {\n\n            tmp = iwmmxt_load_creg(rd);\n\n        }\n\n    } else {\n\n        tmp = new_tmp();\n\n        iwmmxt_load_reg(cpu_V0, rd);\n\n        tcg_gen_trunc_i64_i32(tmp, cpu_V0);\n\n    }\n\n    tcg_gen_andi_i32(tmp, tmp, mask);\n\n    tcg_gen_mov_i32(dest, tmp);\n\n    dead_tmp(tmp);\n\n    return 0;\n\n}\n", "idx": 19403, "_split": "test", "_hash": "f556aa431d60c79b5fd768f252dd62b2"}
{"project": "qemu", "commit_id": "bdd81addf4033ce26e6cd180b060f63095f3ded9", "target": 1, "func": "static void vfio_vga_probe_nvidia_3d0_quirk(VFIOPCIDevice *vdev)\n\n{\n\n    VFIOQuirk *quirk;\n\n    VFIONvidia3d0Quirk *data;\n\n\n\n    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID) ||\n\n        !vdev->bars[1].region.size) {\n\n        return;\n\n    }\n\n\n\n    quirk = g_malloc0(sizeof(*quirk));\n\n    quirk->data = data = g_malloc0(sizeof(*data));\n\n    quirk->mem = g_malloc0(sizeof(MemoryRegion) * 2);\n\n    quirk->nr_mem = 2;\n\n    data->vdev = vdev;\n\n\n\n    memory_region_init_io(&quirk->mem[0], OBJECT(vdev), &vfio_nvidia_3d4_quirk,\n\n                          data, \"vfio-nvidia-3d4-quirk\", 2);\n\n    memory_region_add_subregion(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].mem,\n\n                                0x14 /* 0x3c0 + 0x14 */, &quirk->mem[0]);\n\n\n\n    memory_region_init_io(&quirk->mem[1], OBJECT(vdev), &vfio_nvidia_3d0_quirk,\n\n                          data, \"vfio-nvidia-3d0-quirk\", 2);\n\n    memory_region_add_subregion(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].mem,\n\n                                0x10 /* 0x3c0 + 0x10 */, &quirk->mem[1]);\n\n\n\n    QLIST_INSERT_HEAD(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].quirks,\n\n                      quirk, next);\n\n\n\n    trace_vfio_quirk_nvidia_3d0_probe(vdev->vbasedev.name);\n\n}\n", "idx": 19408, "_split": "test", "_hash": "81440c28e325c8fef01af4b6dc803d68"}
{"project": "qemu", "commit_id": "9fbf4a58c90183b30bb2c8ad971ccce7e6716a16", "target": 1, "func": "static int get_physical_address (CPUMIPSState *env, hwaddr *physical,\n\n                                int *prot, target_ulong real_address,\n\n                                int rw, int access_type)\n\n{\n\n    /* User mode can only access useg/xuseg */\n\n    int user_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_UM;\n\n    int supervisor_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_SM;\n\n    int kernel_mode = !user_mode && !supervisor_mode;\n\n#if defined(TARGET_MIPS64)\n\n    int UX = (env->CP0_Status & (1 << CP0St_UX)) != 0;\n\n    int SX = (env->CP0_Status & (1 << CP0St_SX)) != 0;\n\n    int KX = (env->CP0_Status & (1 << CP0St_KX)) != 0;\n\n#endif\n\n    int ret = TLBRET_MATCH;\n\n    /* effective address (modified for KVM T&E kernel segments) */\n\n    target_ulong address = real_address;\n\n\n\n#define USEG_LIMIT      0x7FFFFFFFUL\n\n#define KSEG0_BASE      0x80000000UL\n\n#define KSEG1_BASE      0xA0000000UL\n\n#define KSEG2_BASE      0xC0000000UL\n\n#define KSEG3_BASE      0xE0000000UL\n\n\n\n#define KVM_KSEG0_BASE  0x40000000UL\n\n#define KVM_KSEG2_BASE  0x60000000UL\n\n\n\n    if (kvm_enabled()) {\n\n        /* KVM T&E adds guest kernel segments in useg */\n\n        if (real_address >= KVM_KSEG0_BASE) {\n\n            if (real_address < KVM_KSEG2_BASE) {\n\n                /* kseg0 */\n\n                address += KSEG0_BASE - KVM_KSEG0_BASE;\n\n            } else if (real_address <= USEG_LIMIT) {\n\n                /* kseg2/3 */\n\n                address += KSEG2_BASE - KVM_KSEG2_BASE;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (address <= USEG_LIMIT) {\n\n        /* useg */\n\n        if (env->CP0_Status & (1 << CP0St_ERL)) {\n\n            *physical = address & 0xFFFFFFFF;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        }\n\n#if defined(TARGET_MIPS64)\n\n    } else if (address < 0x4000000000000000ULL) {\n\n        /* xuseg */\n\n        if (UX && address <= (0x3FFFFFFFFFFFFFFFULL & env->SEGMask)) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < 0x8000000000000000ULL) {\n\n        /* xsseg */\n\n        if ((supervisor_mode || kernel_mode) &&\n\n            SX && address <= (0x7FFFFFFFFFFFFFFFULL & env->SEGMask)) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < 0xC000000000000000ULL) {\n\n        /* xkphys */\n\n        if (kernel_mode && KX &&\n\n            (address & 0x07FFFFFFFFFFFFFFULL) <= env->PAMask) {\n\n            *physical = address & env->PAMask;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < 0xFFFFFFFF80000000ULL) {\n\n        /* xkseg */\n\n        if (kernel_mode && KX &&\n\n            address <= (0xFFFFFFFF7FFFFFFFULL & env->SEGMask)) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n#endif\n\n    } else if (address < (int32_t)KSEG1_BASE) {\n\n        /* kseg0 */\n\n        if (kernel_mode) {\n\n            *physical = address - (int32_t)KSEG0_BASE;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < (int32_t)KSEG2_BASE) {\n\n        /* kseg1 */\n\n        if (kernel_mode) {\n\n            *physical = address - (int32_t)KSEG1_BASE;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < (int32_t)KSEG3_BASE) {\n\n        /* sseg (kseg2) */\n\n        if (supervisor_mode || kernel_mode) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else {\n\n        /* kseg3 */\n\n        /* XXX: debug segment is not emulated */\n\n        if (kernel_mode) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 19431, "_split": "test", "_hash": "257b6a4bf7b22a523cbab6b8646f7bbf"}
{"project": "qemu", "commit_id": "82be8e7394b31fd2d740651365b8ebdd0c847529", "target": 1, "func": "static int get_htab_fd(sPAPRMachineState *spapr)\n\n{\n\n    if (spapr->htab_fd >= 0) {\n\n        return spapr->htab_fd;\n\n    }\n\n\n\n    spapr->htab_fd = kvmppc_get_htab_fd(false);\n\n    if (spapr->htab_fd < 0) {\n\n        error_report(\"Unable to open fd for reading hash table from KVM: %s\",\n\n                     strerror(errno));\n\n    }\n\n\n\n    return spapr->htab_fd;\n\n}\n", "idx": 19434, "_split": "test", "_hash": "3bcdb6549d5ff82cb622f894658afe1e"}
{"project": "qemu", "commit_id": "a9fc37f6bc3f2ab90585cb16493da9f6dcfbfbcf", "target": 1, "func": "static void qobject_input_start_list(Visitor *v, const char *name,\n\n                                     GenericList **list, size_t size,\n\n                                     Error **errp)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    const QListEntry *entry;\n\n\n\n    if (list) {\n\n        *list = NULL;\n\n    }\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    if (qobject_type(qobj) != QTYPE_QLIST) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"list\");\n\n        return;\n\n    }\n\n\n\n    entry = qobject_input_push(qiv, qobj, list);\n\n    if (entry && list) {\n\n        *list = g_malloc0(size);\n\n    }\n\n}\n", "idx": 19441, "_split": "test", "_hash": "980c3dd34f5de17b007ff136e8c5b1f6"}
{"project": "qemu", "commit_id": "0a982b1bf3953dc8640c4d6e619fb1132ebbebc3", "target": 0, "func": "static void test_qga_file_write_read(gconstpointer fix)\n\n{\n\n    const TestFixture *fixture = fix;\n\n    const unsigned char helloworld[] = \"Hello World!\\n\";\n\n    const char *b64;\n\n    gchar *cmd, *enc;\n\n    QDict *ret, *val;\n\n    int64_t id, eof;\n\n    gsize count;\n\n\n\n    /* open */\n\n    ret = qmp_fd(fixture->fd, \"{'execute': 'guest-file-open',\"\n\n                 \" 'arguments': { 'path': 'foo', 'mode': 'w+' } }\");\n\n    g_assert_nonnull(ret);\n\n    qmp_assert_no_error(ret);\n\n    id = qdict_get_int(ret, \"return\");\n\n    QDECREF(ret);\n\n\n\n    enc = g_base64_encode(helloworld, sizeof(helloworld));\n\n    /* write */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-write',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \",\"\n\n                          \" 'buf-b64': '%s' } }\", id, enc);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    g_assert_nonnull(ret);\n\n    qmp_assert_no_error(ret);\n\n\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"count\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    g_assert_cmpint(count, ==, sizeof(helloworld));\n\n    g_assert_cmpint(eof, ==, 0);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n\n\n    /* read (check implicit flush) */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-read',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \"} }\",\n\n                          id);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"count\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    b64 = qdict_get_str(val, \"buf-b64\");\n\n    g_assert_cmpint(count, ==, 0);\n\n    g_assert(eof);\n\n    g_assert_cmpstr(b64, ==, \"\");\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n\n\n    /* seek to 0 */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-seek',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \", \"\n\n                          \" 'offset': %d, 'whence': %d } }\",\n\n                          id, 0, SEEK_SET);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    qmp_assert_no_error(ret);\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"position\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    g_assert_cmpint(count, ==, 0);\n\n    g_assert(!eof);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n\n\n    /* read */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-read',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \"} }\",\n\n                          id);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"count\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    b64 = qdict_get_str(val, \"buf-b64\");\n\n    g_assert_cmpint(count, ==, sizeof(helloworld));\n\n    g_assert(eof);\n\n    g_assert_cmpstr(b64, ==, enc);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n    g_free(enc);\n\n\n\n    /* close */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-close',\"\n\n                          \" 'arguments': {'handle': %\" PRId64 \"} }\",\n\n                          id);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n}\n", "idx": 19469, "_split": "test", "_hash": "c79b82883891a8c9392258e79e18e5a9"}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_native_list_uint16(TestOutputVisitorData *data,\n\n                                                const void *unused)\n\n{\n\n    test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_U16);\n\n}\n", "idx": 19473, "_split": "test", "_hash": "861bc0446a915a81dddca020f7870ad7"}
{"project": "qemu", "commit_id": "01cd90b641e1aed40cf13a577e6a737af94d55e7", "target": 0, "func": "static int xen_9pfs_connect(struct XenDevice *xendev)\n\n{\n\n    int i;\n\n    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);\n\n    V9fsState *s = &xen_9pdev->state;\n\n    QemuOpts *fsdev;\n\n\n\n    if (xenstore_read_fe_int(&xen_9pdev->xendev, \"num-rings\",\n\n                             &xen_9pdev->num_rings) == -1 ||\n\n        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n\n        return -1;\n\n    }\n\n\n\n    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));\n\n    for (i = 0; i < xen_9pdev->num_rings; i++) {\n\n        char *str;\n\n        int ring_order;\n\n\n\n        xen_9pdev->rings[i].priv = xen_9pdev;\n\n        xen_9pdev->rings[i].evtchn = -1;\n\n        xen_9pdev->rings[i].local_port = -1;\n\n\n\n        str = g_strdup_printf(\"ring-ref%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].ref) == -1) {\n\n            g_free(str);\n\n            goto out;\n\n        }\n\n        g_free(str);\n\n        str = g_strdup_printf(\"event-channel-%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].evtchn) == -1) {\n\n            g_free(str);\n\n            goto out;\n\n        }\n\n        g_free(str);\n\n\n\n        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].intf) {\n\n            goto out;\n\n        }\n\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n\n        if (ring_order > MAX_RING_ORDER) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring_order = ring_order;\n\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                (1 << ring_order),\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].intf->ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].data) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +\n\n                                       XEN_FLEX_RING_SIZE(ring_order);\n\n\n\n        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);\n\n        xen_9pdev->rings[i].out_cons = 0;\n\n        xen_9pdev->rings[i].out_size = 0;\n\n        xen_9pdev->rings[i].inprogress = false;\n\n\n\n\n\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);\n\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n\n            goto out;\n\n        }\n\n        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain\n\n                                            (xen_9pdev->rings[i].evtchndev,\n\n                                             xendev->dom,\n\n                                             xen_9pdev->rings[i].evtchn);\n\n        if (xen_9pdev->rings[i].local_port == -1) {\n\n            xen_pv_printf(xendev, 0,\n\n                          \"xenevtchn_bind_interdomain failed port=%d\\n\",\n\n                          xen_9pdev->rings[i].evtchn);\n\n            goto out;\n\n        }\n\n        xen_pv_printf(xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n\n        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),\n\n                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n\n    }\n\n\n\n    xen_9pdev->security_model = xenstore_read_be_str(xendev, \"security_model\");\n\n    xen_9pdev->path = xenstore_read_be_str(xendev, \"path\");\n\n    xen_9pdev->id = s->fsconf.fsdev_id =\n\n        g_strdup_printf(\"xen9p%d\", xendev->dev);\n\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, \"tag\");\n\n    v9fs_register_transport(s, &xen_9p_transport);\n\n    fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n\n            s->fsconf.tag,\n\n            1, NULL);\n\n    qemu_opt_set(fsdev, \"fsdriver\", \"local\", NULL);\n\n    qemu_opt_set(fsdev, \"path\", xen_9pdev->path, NULL);\n\n    qemu_opt_set(fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n\n    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);\n\n    qemu_fsdev_add(fsdev);\n\n    v9fs_device_realize_common(s, NULL);\n\n\n\n    return 0;\n\n\n\nout:\n\n    xen_9pfs_free(xendev);\n\n    return -1;\n\n}\n", "idx": 19490, "_split": "test", "_hash": "2183f43f9bbaace2f7b163d3422a604e"}
{"project": "qemu", "commit_id": "299f80130401153af1a6ddb3cc011781bcd47600", "target": 0, "func": "static void tcg_opt_gen_mov(TCGContext *s, TCGOp *op, TCGArg *args,\n\n                            TCGArg dst, TCGArg src)\n\n{\n\n    if (temps_are_copies(dst, src)) {\n\n        tcg_op_remove(s, op);\n\n        return;\n\n    }\n\n\n\n    if (temp_is_const(src)) {\n\n        tcg_opt_gen_movi(s, op, args, dst, temps[src].val);\n\n        return;\n\n    }\n\n\n\n    TCGOpcode new_op = op_to_mov(op->opc);\n\n    tcg_target_ulong mask;\n\n\n\n    op->opc = new_op;\n\n\n\n    reset_temp(dst);\n\n    mask = temps[src].mask;\n\n    if (TCG_TARGET_REG_BITS > 32 && new_op == INDEX_op_mov_i32) {\n\n        /* High bits of the destination are now garbage.  */\n\n        mask |= ~0xffffffffull;\n\n    }\n\n    temps[dst].mask = mask;\n\n\n\n    assert(!temp_is_const(src));\n\n\n\n    if (s->temps[src].type == s->temps[dst].type) {\n\n        temps[dst].next_copy = temps[src].next_copy;\n\n        temps[dst].prev_copy = src;\n\n        temps[temps[dst].next_copy].prev_copy = dst;\n\n        temps[src].next_copy = dst;\n\n        temps[dst].is_const = false;\n\n    }\n\n\n\n    args[0] = dst;\n\n    args[1] = src;\n\n}\n", "idx": 19492, "_split": "test", "_hash": "edcfb155ee5743ec9f33415050dd1d5c"}
{"project": "qemu", "commit_id": "449041d4db1f82f281fe097e832f07cd9ee1e864", "target": 1, "func": "static int parse_uint16(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    /* accept both hex and decimal */\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx16 : \"%\" PRIu16;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n", "idx": 19554, "_split": "test", "_hash": "d3009956227e9e202020747918ee1c86"}
{"project": "qemu", "commit_id": "b227a8e9aa5f27d29f77ba90d5eb9d0662a1175e", "target": 0, "func": "static int get_bat (CPUState *env, mmu_ctx_t *ctx,\n\n                    target_ulong virtual, int rw, int type)\n\n{\n\n    target_ulong *BATlt, *BATut, *BATu, *BATl;\n\n    target_ulong base, BEPIl, BEPIu, bl;\n\n    int i;\n\n    int ret = -1;\n\n\n\n#if defined (DEBUG_BATS)\n\n    if (loglevel != 0) {\n\n        fprintf(logfile, \"%s: %cBAT v 0x\" ADDRX \"\\n\", __func__,\n\n                type == ACCESS_CODE ? 'I' : 'D', virtual);\n\n    }\n\n#endif\n\n    switch (type) {\n\n    case ACCESS_CODE:\n\n        BATlt = env->IBAT[1];\n\n        BATut = env->IBAT[0];\n\n        break;\n\n    default:\n\n        BATlt = env->DBAT[1];\n\n        BATut = env->DBAT[0];\n\n        break;\n\n    }\n\n#if defined (DEBUG_BATS)\n\n    if (loglevel != 0) {\n\n        fprintf(logfile, \"%s...: %cBAT v 0x\" ADDRX \"\\n\", __func__,\n\n                type == ACCESS_CODE ? 'I' : 'D', virtual);\n\n    }\n\n#endif\n\n    base = virtual & 0xFFFC0000;\n\n    for (i = 0; i < 4; i++) {\n\n        BATu = &BATut[i];\n\n        BATl = &BATlt[i];\n\n        BEPIu = *BATu & 0xF0000000;\n\n        BEPIl = *BATu & 0x0FFE0000;\n\n        bl = (*BATu & 0x00001FFC) << 15;\n\n#if defined (DEBUG_BATS)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"%s: %cBAT%d v 0x\" ADDRX \" BATu 0x\" ADDRX\n\n                    \" BATl 0x\" ADDRX \"\\n\",\n\n                    __func__, type == ACCESS_CODE ? 'I' : 'D', i, virtual,\n\n                    *BATu, *BATl);\n\n        }\n\n#endif\n\n        if ((virtual & 0xF0000000) == BEPIu &&\n\n            ((virtual & 0x0FFE0000) & ~bl) == BEPIl) {\n\n            /* BAT matches */\n\n            if ((msr_pr == 0 && (*BATu & 0x00000002)) ||\n\n                (msr_pr == 1 && (*BATu & 0x00000001))) {\n\n                /* Get physical address */\n\n                ctx->raddr = (*BATl & 0xF0000000) |\n\n                    ((virtual & 0x0FFE0000 & bl) | (*BATl & 0x0FFE0000)) |\n\n                    (virtual & 0x0001F000);\n\n                if (*BATl & 0x00000001)\n\n                    ctx->prot = PAGE_READ;\n\n                if (*BATl & 0x00000002)\n\n                    ctx->prot = PAGE_WRITE | PAGE_READ;\n\n#if defined (DEBUG_BATS)\n\n                if (loglevel != 0) {\n\n                    fprintf(logfile, \"BAT %d match: r 0x\" PADDRX\n\n                            \" prot=%c%c\\n\",\n\n                            i, ctx->raddr, ctx->prot & PAGE_READ ? 'R' : '-',\n\n                            ctx->prot & PAGE_WRITE ? 'W' : '-');\n\n                }\n\n#endif\n\n                ret = 0;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    if (ret < 0) {\n\n#if defined (DEBUG_BATS)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"no BAT match for 0x\" ADDRX \":\\n\", virtual);\n\n            for (i = 0; i < 4; i++) {\n\n                BATu = &BATut[i];\n\n                BATl = &BATlt[i];\n\n                BEPIu = *BATu & 0xF0000000;\n\n                BEPIl = *BATu & 0x0FFE0000;\n\n                bl = (*BATu & 0x00001FFC) << 15;\n\n                fprintf(logfile, \"%s: %cBAT%d v 0x\" ADDRX \" BATu 0x\" ADDRX\n\n                        \" BATl 0x\" ADDRX \" \\n\\t\"\n\n                        \"0x\" ADDRX \" 0x\" ADDRX \" 0x\" ADDRX \"\\n\",\n\n                        __func__, type == ACCESS_CODE ? 'I' : 'D', i, virtual,\n\n                        *BATu, *BATl, BEPIu, BEPIl, bl);\n\n            }\n\n        }\n\n#endif\n\n    }\n\n    /* No hit */\n\n    return ret;\n\n}\n", "idx": 19567, "_split": "test", "_hash": "1c75f2a95c0e1d277e02bb341f0270c0"}
{"project": "qemu", "commit_id": "2ff30257974e19ebe2a97baad32ac29c06da5fb9", "target": 0, "func": "static void *migration_thread(void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n    /* Used by the bandwidth calcs, updated later */\n\n    int64_t initial_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n    int64_t setup_start = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n\n    int64_t initial_bytes = 0;\n\n    int64_t max_size = 0;\n\n    int64_t start_time = initial_time;\n\n    int64_t end_time;\n\n    bool old_vm_running = false;\n\n    bool entered_postcopy = false;\n\n    /* The active state we expect to be in; ACTIVE or POSTCOPY_ACTIVE */\n\n    enum MigrationStatus current_active_state = MIGRATION_STATUS_ACTIVE;\n\n\n\n    rcu_register_thread();\n\n\n\n    qemu_savevm_state_header(s->to_dst_file);\n\n\n\n    if (migrate_postcopy_ram()) {\n\n        /* Now tell the dest that it should open its end so it can reply */\n\n        qemu_savevm_send_open_return_path(s->to_dst_file);\n\n\n\n        /* And do a ping that will make stuff easier to debug */\n\n        qemu_savevm_send_ping(s->to_dst_file, 1);\n\n\n\n        /*\n\n         * Tell the destination that we *might* want to do postcopy later;\n\n         * if the other end can't do postcopy it should fail now, nice and\n\n         * early.\n\n         */\n\n        qemu_savevm_send_postcopy_advise(s->to_dst_file);\n\n    }\n\n\n\n    qemu_savevm_state_begin(s->to_dst_file, &s->params);\n\n\n\n    s->setup_time = qemu_clock_get_ms(QEMU_CLOCK_HOST) - setup_start;\n\n    current_active_state = MIGRATION_STATUS_ACTIVE;\n\n    migrate_set_state(&s->state, MIGRATION_STATUS_SETUP,\n\n                      MIGRATION_STATUS_ACTIVE);\n\n\n\n    trace_migration_thread_setup_complete();\n\n\n\n    while (s->state == MIGRATION_STATUS_ACTIVE ||\n\n           s->state == MIGRATION_STATUS_POSTCOPY_ACTIVE) {\n\n        int64_t current_time;\n\n        uint64_t pending_size;\n\n\n\n        if (!qemu_file_rate_limit(s->to_dst_file)) {\n\n            uint64_t pend_post, pend_nonpost;\n\n\n\n            qemu_savevm_state_pending(s->to_dst_file, max_size, &pend_nonpost,\n\n                                      &pend_post);\n\n            pending_size = pend_nonpost + pend_post;\n\n            trace_migrate_pending(pending_size, max_size,\n\n                                  pend_post, pend_nonpost);\n\n            if (pending_size && pending_size >= max_size) {\n\n                /* Still a significant amount to transfer */\n\n\n\n                if (migrate_postcopy_ram() &&\n\n                    s->state != MIGRATION_STATUS_POSTCOPY_ACTIVE &&\n\n                    pend_nonpost <= max_size &&\n\n                    atomic_read(&s->start_postcopy)) {\n\n\n\n                    if (!postcopy_start(s, &old_vm_running)) {\n\n                        current_active_state = MIGRATION_STATUS_POSTCOPY_ACTIVE;\n\n                        entered_postcopy = true;\n\n                    }\n\n\n\n                    continue;\n\n                }\n\n                /* Just another iteration step */\n\n                qemu_savevm_state_iterate(s->to_dst_file, entered_postcopy);\n\n            } else {\n\n                trace_migration_thread_low_pending(pending_size);\n\n                migration_completion(s, current_active_state,\n\n                                     &old_vm_running, &start_time);\n\n                break;\n\n            }\n\n        }\n\n\n\n        if (qemu_file_get_error(s->to_dst_file)) {\n\n            migrate_set_state(&s->state, current_active_state,\n\n                              MIGRATION_STATUS_FAILED);\n\n            trace_migration_thread_file_err();\n\n            break;\n\n        }\n\n        current_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n        if (current_time >= initial_time + BUFFER_DELAY) {\n\n            uint64_t transferred_bytes = qemu_ftell(s->to_dst_file) -\n\n                                         initial_bytes;\n\n            uint64_t time_spent = current_time - initial_time;\n\n            double bandwidth = (double)transferred_bytes / time_spent;\n\n            max_size = bandwidth * migrate_max_downtime() / 1000000;\n\n\n\n            s->mbps = (((double) transferred_bytes * 8.0) /\n\n                    ((double) time_spent / 1000.0)) / 1000.0 / 1000.0;\n\n\n\n            trace_migrate_transferred(transferred_bytes, time_spent,\n\n                                      bandwidth, max_size);\n\n            /* if we haven't sent anything, we don't want to recalculate\n\n               10000 is a small enough number for our purposes */\n\n            if (s->dirty_bytes_rate && transferred_bytes > 10000) {\n\n                s->expected_downtime = s->dirty_bytes_rate / bandwidth;\n\n            }\n\n\n\n            qemu_file_reset_rate_limit(s->to_dst_file);\n\n            initial_time = current_time;\n\n            initial_bytes = qemu_ftell(s->to_dst_file);\n\n        }\n\n        if (qemu_file_rate_limit(s->to_dst_file)) {\n\n            /* usleep expects microseconds */\n\n            g_usleep((initial_time + BUFFER_DELAY - current_time)*1000);\n\n        }\n\n    }\n\n\n\n    trace_migration_thread_after_loop();\n\n    /* If we enabled cpu throttling for auto-converge, turn it off. */\n\n    cpu_throttle_stop();\n\n    end_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n\n\n    qemu_mutex_lock_iothread();\n\n    qemu_savevm_state_cleanup();\n\n    if (s->state == MIGRATION_STATUS_COMPLETED) {\n\n        uint64_t transferred_bytes = qemu_ftell(s->to_dst_file);\n\n        s->total_time = end_time - s->total_time;\n\n        if (!entered_postcopy) {\n\n            s->downtime = end_time - start_time;\n\n        }\n\n        if (s->total_time) {\n\n            s->mbps = (((double) transferred_bytes * 8.0) /\n\n                       ((double) s->total_time)) / 1000;\n\n        }\n\n        runstate_set(RUN_STATE_POSTMIGRATE);\n\n    } else {\n\n        if (old_vm_running && !entered_postcopy) {\n\n            vm_start();\n\n        } else {\n\n            if (runstate_check(RUN_STATE_FINISH_MIGRATE)) {\n\n                runstate_set(RUN_STATE_POSTMIGRATE);\n\n            }\n\n        }\n\n    }\n\n    qemu_bh_schedule(s->cleanup_bh);\n\n    qemu_mutex_unlock_iothread();\n\n\n\n    rcu_unregister_thread();\n\n    return NULL;\n\n}\n", "idx": 19574, "_split": "test", "_hash": "4bada21bedc642b08fecd802a2299cfd"}
{"project": "qemu", "commit_id": "b6954712abea03afd686b724060f9873e2c61f2b", "target": 0, "func": "void replay_input_event(QemuConsole *src, InputEvent *evt)\n\n{\n\n    if (replay_mode == REPLAY_MODE_PLAY) {\n\n        /* Nothing */\n\n    } else if (replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_add_input_event(qapi_clone_InputEvent(evt));\n\n    } else {\n\n        qemu_input_event_send_impl(src, evt);\n\n    }\n\n}\n", "idx": 19576, "_split": "test", "_hash": "5a74d8589a353ad5ed4522caf8c28fbe"}
{"project": "qemu", "commit_id": "db3b3c7281ca82e2647e072a1f97db111313dd73", "target": 1, "func": "static int handle_parse_opts(QemuOpts *opts, FsDriverEntry *fse, Error **errp)\n{\n    const char *sec_model = qemu_opt_get(opts, \"security_model\");\n    const char *path = qemu_opt_get(opts, \"path\");\n    if (sec_model) {\n        error_report(\"Invalid argument security_model specified with handle fsdriver\");\n        return -1;\n    }\n    if (!path) {\n        error_report(\"fsdev: No path specified\");\n        return -1;\n    }\n    fse->path = g_strdup(path);\n    return 0;\n}", "idx": 19612, "_split": "test", "_hash": "9f075d4405a4f4ed89dcb5d129b2cea6"}
{"project": "qemu", "commit_id": "302d9d6fd8cb34e393cc9bb101a1748bd53899d3", "target": 1, "func": "void vnc_sasl_client_cleanup(VncState *vs)\n\n{\n\n    if (vs->sasl.conn) {\n\n        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;\n\n        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;\n\n        vs->sasl.encoded = NULL;\n\n        g_free(vs->sasl.username);\n\n        free(vs->sasl.mechlist);\n\n        vs->sasl.username = vs->sasl.mechlist = NULL;\n\n        sasl_dispose(&vs->sasl.conn);\n\n        vs->sasl.conn = NULL;\n\n    }\n\n}\n", "idx": 19633, "_split": "test", "_hash": "02b7d37d0e9c45c0fd7306969f130e21"}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int integratorcm_init(SysBusDevice *dev)\n\n{\n\n    IntegratorCMState *s = INTEGRATOR_CM(dev);\n\n\n\n    s->cm_osc = 0x01000048;\n\n    /* ??? What should the high bits of this value be?  */\n\n    s->cm_auxosc = 0x0007feff;\n\n    s->cm_sdram = 0x00011122;\n\n    if (s->memsz >= 256) {\n\n        integrator_spd[31] = 64;\n\n        s->cm_sdram |= 0x10;\n\n    } else if (s->memsz >= 128) {\n\n        integrator_spd[31] = 32;\n\n        s->cm_sdram |= 0x0c;\n\n    } else if (s->memsz >= 64) {\n\n        integrator_spd[31] = 16;\n\n        s->cm_sdram |= 0x08;\n\n    } else if (s->memsz >= 32) {\n\n        integrator_spd[31] = 4;\n\n        s->cm_sdram |= 0x04;\n\n    } else {\n\n        integrator_spd[31] = 2;\n\n    }\n\n    memcpy(integrator_spd + 73, \"QEMU-MEMORY\", 11);\n\n    s->cm_init = 0x00000112;\n\n    s->cm_refcnt_offset = muldiv64(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL), 24,\n\n                                   1000);\n\n    memory_region_init_ram(&s->flash, OBJECT(s), \"integrator.flash\", 0x100000,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->flash);\n\n\n\n    memory_region_init_io(&s->iomem, OBJECT(s), &integratorcm_ops, s,\n\n                          \"integratorcm\", 0x00800000);\n\n    sysbus_init_mmio(dev, &s->iomem);\n\n\n\n    integratorcm_do_remap(s);\n\n    /* ??? Save/restore.  */\n\n    return 0;\n\n}\n", "idx": 19643, "_split": "test", "_hash": "0dc548540114eb38557d3ed10cac14eb"}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void unterminated_array_comma(void)\n\n{\n\n    QObject *obj = qobject_from_json(\"[32,\", NULL);\n\n    g_assert(obj == NULL);\n\n}\n", "idx": 19650, "_split": "test", "_hash": "4dd707db6f656353ebbd4e6d2cb31695"}
{"project": "qemu", "commit_id": "c3fecea50dc0f27198b8658a0c9c4fbfdd0f95db", "target": 1, "func": "static int coroutine_fn add_aio_request(BDRVSheepdogState *s, AIOReq *aio_req,\n\n                           struct iovec *iov, int niov, int create,\n\n                           enum AIOCBState aiocb_type)\n\n{\n\n    int nr_copies = s->inode.nr_copies;\n\n    SheepdogObjReq hdr;\n\n    unsigned int wlen;\n\n    int ret;\n\n    uint64_t oid = aio_req->oid;\n\n    unsigned int datalen = aio_req->data_len;\n\n    uint64_t offset = aio_req->offset;\n\n    uint8_t flags = aio_req->flags;\n\n    uint64_t old_oid = aio_req->base_oid;\n\n\n\n    if (!nr_copies) {\n\n        error_report(\"bug\");\n\n    }\n\n\n\n    memset(&hdr, 0, sizeof(hdr));\n\n\n\n    if (aiocb_type == AIOCB_READ_UDATA) {\n\n        wlen = 0;\n\n        hdr.opcode = SD_OP_READ_OBJ;\n\n        hdr.flags = flags;\n\n    } else if (create) {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_CREATE_AND_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    } else {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    }\n\n\n\n    hdr.oid = oid;\n\n    hdr.cow_oid = old_oid;\n\n    hdr.copies = s->inode.nr_copies;\n\n\n\n    hdr.data_length = datalen;\n\n    hdr.offset = offset;\n\n\n\n    hdr.id = aio_req->id;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    s->co_send = qemu_coroutine_self();\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, co_write_request,\n\n                            aio_flush_request, NULL, s);\n\n    set_cork(s->fd, 1);\n\n\n\n    /* send a header */\n\n    ret = do_write(s->fd, &hdr, sizeof(hdr));\n\n    if (ret) {\n\n\n        error_report(\"failed to send a req, %s\", strerror(errno));\n\n        return -EIO;\n\n    }\n\n\n\n    if (wlen) {\n\n        ret = do_writev(s->fd, iov, wlen, aio_req->iov_offset);\n\n        if (ret) {\n\n\n            error_report(\"failed to send a data, %s\", strerror(errno));\n\n            return -EIO;\n\n        }\n\n    }\n\n\n\n    set_cork(s->fd, 0);\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, NULL,\n\n                            aio_flush_request, NULL, s);\n\n\n\n\n    return 0;\n\n}", "idx": 19684, "_split": "test", "_hash": "8135092be6e7e8fe3866b14b90b31048"}
{"project": "qemu", "commit_id": "2b3de6ada5d180130ba083d5b45ed51ce8e4def2", "target": 1, "func": "static void ehci_writeback_async_complete_packet(EHCIPacket *p)\n{\n    EHCIQueue *q = p->queue;\n    int state;\n    state = ehci_get_state(q->ehci, q->async);\n    ehci_state_executing(q);\n    ehci_state_writeback(q); /* Frees the packet! */\n    if (!(q->qh.token & QTD_TOKEN_HALT)) {\n        ehci_state_advqueue(q);\n    ehci_set_state(q->ehci, q->async, state);", "idx": 19685, "_split": "test", "_hash": "7a2acdd6e49c8350beab9fee2fedc01a"}
{"project": "qemu", "commit_id": "36c6711bbe79642b0102416a9dd4243505e874a6", "target": 1, "func": "static void gen_ldst_pair (DisasContext *ctx, uint32_t opc, int rd,\n\n                           int base, int16_t offset)\n\n{\n\n    const char *opn = \"ldst_pair\";\n\n    TCGv t0, t1;\n\n\n\n    if (ctx->hflags & MIPS_HFLAG_BMASK || rd == 31 || rd == base) {\n\n        generate_exception(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n\n\n    t0 = tcg_temp_new();\n\n    t1 = tcg_temp_new();\n\n\n\n    gen_base_offset_addr(ctx, t0, base, offset);\n\n\n\n    switch (opc) {\n\n    case LWP:\n\n        save_cpu_state(ctx, 0);\n\n        op_ld_lw(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd);\n\n        tcg_gen_movi_tl(t1, 4);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        op_ld_lw(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd+1);\n\n        opn = \"lwp\";\n\n        break;\n\n    case SWP:\n\n        save_cpu_state(ctx, 0);\n\n        gen_load_gpr(t1, rd);\n\n        op_st_sw(t1, t0, ctx);\n\n        tcg_gen_movi_tl(t1, 4);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        gen_load_gpr(t1, rd+1);\n\n        op_st_sw(t1, t0, ctx);\n\n        opn = \"swp\";\n\n        break;\n\n#ifdef TARGET_MIPS64\n\n    case LDP:\n\n        save_cpu_state(ctx, 0);\n\n        op_ld_ld(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd);\n\n        tcg_gen_movi_tl(t1, 8);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        op_ld_ld(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd+1);\n\n        opn = \"ldp\";\n\n        break;\n\n    case SDP:\n\n        save_cpu_state(ctx, 0);\n\n        gen_load_gpr(t1, rd);\n\n        op_st_sd(t1, t0, ctx);\n\n        tcg_gen_movi_tl(t1, 8);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        gen_load_gpr(t1, rd+1);\n\n        op_st_sd(t1, t0, ctx);\n\n        opn = \"sdp\";\n\n        break;\n\n#endif\n\n    }\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s, %s, %d(%s)\", opn, regnames[rd], offset, regnames[base]);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n", "idx": 19709, "_split": "test", "_hash": "a0268a63bf85dfff22e08d706cc73f33"}
{"project": "qemu", "commit_id": "84ebd3e8c7d4fe955b359b9aac84395907b0412e", "target": 1, "func": "static void wdt_diag288_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    DIAG288Class *diag288 = DIAG288_CLASS(klass);\n\n\n\n    dc->realize = wdt_diag288_realize;\n\n    dc->unrealize = wdt_diag288_unrealize;\n\n    dc->reset = wdt_diag288_reset;\n\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->vmsd = &vmstate_diag288;\n\n    diag288->handle_timer = wdt_diag288_handle_timer;\n\n}", "idx": 19716, "_split": "test", "_hash": "4725b43f09a1e0a330531f62c508719e"}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mtmsr(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    if (ctx->opcode & 0x00010000) {\n\n        /* Special form that does not need any synchronisation */\n\n        TCGv t0 = tcg_temp_new();\n\n        tcg_gen_andi_tl(t0, cpu_gpr[rS(ctx->opcode)], (1 << MSR_RI) | (1 << MSR_EE));\n\n        tcg_gen_andi_tl(cpu_msr, cpu_msr, ~(target_ulong)((1 << MSR_RI) | (1 << MSR_EE)));\n\n        tcg_gen_or_tl(cpu_msr, cpu_msr, t0);\n\n        tcg_temp_free(t0);\n\n    } else {\n\n        TCGv msr = tcg_temp_new();\n\n\n\n        /* XXX: we need to update nip before the store\n\n         *      if we enter power saving mode, we will exit the loop\n\n         *      directly from ppc_store_msr\n\n         */\n\n        gen_update_nip(ctx, ctx->nip);\n\n#if defined(TARGET_PPC64)\n\n        tcg_gen_deposit_tl(msr, cpu_msr, cpu_gpr[rS(ctx->opcode)], 0, 32);\n\n#else\n\n        tcg_gen_mov_tl(msr, cpu_gpr[rS(ctx->opcode)]);\n\n#endif\n\n        gen_helper_store_msr(cpu_env, msr);\n\n        tcg_temp_free(msr);\n\n        /* Must stop the translation as machine state (may have) changed */\n\n        /* Note that mtmsr is not always defined as context-synchronizing */\n\n        gen_stop_exception(ctx);\n\n    }\n\n#endif\n\n}\n", "idx": 19808, "_split": "test", "_hash": "e278f85c7fa969288bb4bb2e8c884858"}
{"project": "qemu", "commit_id": "447b0d0b9ee8a0ac216c3186e0f3c427a1001f0c", "target": 1, "func": "static void flatview_ref(FlatView *view)\n\n{\n\n    atomic_inc(&view->ref);\n\n}\n", "idx": 19809, "_split": "test", "_hash": "39881fd389dbbe8b794b9a6a2018a365"}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "static void test_task_complete(void)\n\n{\n\n    QIOTask *task;\n\n    Object *obj = object_new(TYPE_DUMMY);\n\n    Object *src;\n\n    struct TestTaskData data = { NULL, NULL, false };\n\n\n\n    task = qio_task_new(obj, task_callback, &data, NULL);\n\n    src = qio_task_get_source(task);\n\n\n\n    qio_task_complete(task);\n\n\n\n    g_assert(obj == src);\n\n\n\n    object_unref(obj);\n\n    object_unref(src);\n\n\n\n    g_assert(data.source == obj);\n\n    g_assert(data.err == NULL);\n\n    g_assert(data.freed == false);\n\n}\n", "idx": 19834, "_split": "test", "_hash": "9568aa4060e9c88beedd22460c9de8c1"}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "int qemu_check_nic_model_list(NICInfo *nd, const char * const *models,\n\n                              const char *default_model)\n\n{\n\n    int i, exit_status = 0;\n\n\n\n    if (!nd->model)\n\n        nd->model = strdup(default_model);\n\n\n\n    if (strcmp(nd->model, \"?\") != 0) {\n\n        for (i = 0 ; models[i]; i++)\n\n            if (strcmp(nd->model, models[i]) == 0)\n\n                return i;\n\n\n\n        fprintf(stderr, \"qemu: Unsupported NIC model: %s\\n\", nd->model);\n\n        exit_status = 1;\n\n    }\n\n\n\n    fprintf(stderr, \"qemu: Supported NIC models: \");\n\n    for (i = 0 ; models[i]; i++)\n\n        fprintf(stderr, \"%s%c\", models[i], models[i+1] ? ',' : '\\n');\n\n\n\n    exit(exit_status);\n\n}\n", "idx": 19916, "_split": "test", "_hash": "46fd8444accbd3c22783b5ab1c36cdfe"}
{"project": "qemu", "commit_id": "8103b4d161d7c00ea3ff89ffe66bb2bc2c67de5d", "target": 0, "func": "static void virtio_s390_notify(void *opaque, uint16_t vector)\n\n{\n\n    VirtIOS390Device *dev = (VirtIOS390Device*)opaque;\n\n    uint64_t token = s390_virtio_device_vq_token(dev, vector);\n\n\n\n    /* XXX kvm dependency! */\n\n    kvm_s390_virtio_irq(s390_cpu_addr2state(0), 0, token);\n\n}\n", "idx": 19927, "_split": "test", "_hash": "e0ee824df67e993c16d6479a6510e0ed"}
{"project": "qemu", "commit_id": "d5851089a8a77d5c23e8d5fffb5b99265009ba62", "target": 0, "func": "static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)\n\n{\n\n    if (throttle_conflicting(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    if (!throttle_is_valid(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    if (throttle_max_is_missing_limit(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 19962, "_split": "test", "_hash": "2c0382bb1e89a3e664856a223fe60e32"}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "void qemu_main_loop_start(void)\n\n{\n\n}\n", "idx": 19966, "_split": "test", "_hash": "9a052353d566c5df6f6f864b644a3f2e"}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void cpu_devinit(const char *cpu_model, unsigned int id,\n\n                        uint64_t prom_addr, qemu_irq **cpu_irqs)\n\n{\n\n    CPUState *cs;\n\n    SPARCCPU *cpu;\n\n    CPUSPARCState *env;\n\n\n\n    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"qemu: Unable to find Sparc CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    cpu_sparc_set_id(env, id);\n\n    if (id == 0) {\n\n        qemu_register_reset(main_cpu_reset, cpu);\n\n    } else {\n\n        qemu_register_reset(secondary_cpu_reset, cpu);\n\n        cs = CPU(cpu);\n\n        cs->halted = 1;\n\n    }\n\n    *cpu_irqs = qemu_allocate_irqs(cpu_set_irq, cpu, MAX_PILS);\n\n    env->prom_addr = prom_addr;\n\n}\n", "idx": 19987, "_split": "test", "_hash": "dd29730d81be150523f62de007d8eb33"}
{"project": "qemu", "commit_id": "95a5befc2f8b359e72926f89cd661d063c2cf06c", "target": 1, "func": "static int read_naa_id(const uint8_t *p, uint64_t *p_wwn)\n\n{\n\n    int i;\n\n\n\n    if ((p[1] & 0xF) == 3) {\n\n        /* NAA designator type */\n\n        if (p[3] != 8) {\n\n            return -EINVAL;\n\n        }\n\n        *p_wwn = ldq_be_p(p + 4);\n\n        return 0;\n\n    }\n\n\n\n    if ((p[1] & 0xF) == 8) {\n\n        /* SCSI name string designator type */\n\n        if (p[3] < 20 || memcmp(&p[4], \"naa.\", 4)) {\n\n            return -EINVAL;\n\n        }\n\n        if (p[3] > 20 && p[24] != ',') {\n\n            return -EINVAL;\n\n        }\n\n        *p_wwn = 0;\n\n        for (i = 8; i < 24; i++) {\n\n            char c = toupper(p[i]);\n\n            c -= (c >= '0' && c <= '9' ? '0' : 'A' - 10);\n\n            *p_wwn = (*p_wwn << 4) | c;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    return -EINVAL;\n\n}\n", "idx": 19999, "_split": "test", "_hash": "df9d1485881ca34e62cdfed7f0412f30"}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static int vscsi_queue_cmd(VSCSIState *s, vscsi_req *req)\n\n{\n\n    union srp_iu *srp = &req->iu.srp;\n\n    SCSIDevice *sdev;\n\n    int n, id, lun;\n\n\n\n    vscsi_decode_id_lun(be64_to_cpu(srp->cmd.lun), &id, &lun);\n\n\n\n    /* Qemu vs. linux issue with LUNs to be sorted out ... */\n\n    sdev = (id < 8 && lun < 16) ? s->bus.devs[id] : NULL;\n\n    if (!sdev) {\n\n        dprintf(\"VSCSI: Command for id %d with no drive\\n\", id);\n\n        if (srp->cmd.cdb[0] == INQUIRY) {\n\n            vscsi_inquiry_no_target(s, req);\n\n        } else {\n\n            vscsi_makeup_sense(s, req, ILLEGAL_REQUEST, 0x24, 0x00);\n\n            vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n        } return 1;\n\n    }\n\n\n\n    req->sdev = sdev;\n\n    req->lun = lun;\n\n    n = sdev->info->send_command(sdev, req->qtag, srp->cmd.cdb, lun);\n\n\n\n    dprintf(\"VSCSI: Queued command tag 0x%x CMD 0x%x ID %d LUN %d ret: %d\\n\",\n\n            req->qtag, srp->cmd.cdb[0], id, lun, n);\n\n\n\n    if (n) {\n\n        /* Transfer direction must be set before preprocessing the\n\n         * descriptors\n\n         */\n\n        req->writing = (n < 1);\n\n\n\n        /* Preprocess RDMA descriptors */\n\n        vscsi_preprocess_desc(req);\n\n    }\n\n\n\n    /* Get transfer direction and initiate transfer */\n\n    if (n > 0) {\n\n        req->data_len = n;\n\n        sdev->info->read_data(sdev, req->qtag);\n\n    } else if (n < 0) {\n\n        req->data_len = -n;\n\n        sdev->info->write_data(sdev, req->qtag);\n\n    }\n\n    /* Don't touch req here, it may have been recycled already */\n\n\n\n    return 0;\n\n}\n", "idx": 20026, "_split": "test", "_hash": "5143f4d5b4d9ca258e4e73898a6462fd"}
{"project": "qemu", "commit_id": "3e80bf9351f8fec9085c46df6da075efd5e71003", "target": 1, "func": "static int do_sendv_recvv(int sockfd, struct iovec *iov, int len, int offset,\n\n                          int do_sendv)\n\n{\n\n    int ret, diff, iovlen;\n\n    struct iovec *last_iov;\n\n\n\n    /* last_iov is inclusive, so count from one.  */\n\n    iovlen = 1;\n\n    last_iov = iov;\n\n    len += offset;\n\n\n\n    while (last_iov->iov_len < len) {\n\n        len -= last_iov->iov_len;\n\n\n\n        last_iov++;\n\n        iovlen++;\n\n    }\n\n\n\n    diff = last_iov->iov_len - len;\n\n    last_iov->iov_len -= diff;\n\n\n\n    while (iov->iov_len <= offset) {\n\n        offset -= iov->iov_len;\n\n\n\n        iov++;\n\n        iovlen--;\n\n    }\n\n\n\n    iov->iov_base = (char *) iov->iov_base + offset;\n\n    iov->iov_len -= offset;\n\n\n\n    {\n\n#if defined CONFIG_IOVEC && defined CONFIG_POSIX\n\n        struct msghdr msg;\n\n        memset(&msg, 0, sizeof(msg));\n\n        msg.msg_iov = iov;\n\n        msg.msg_iovlen = iovlen;\n\n\n\n        do {\n\n            if (do_sendv) {\n\n                ret = sendmsg(sockfd, &msg, 0);\n\n            } else {\n\n                ret = recvmsg(sockfd, &msg, 0);\n\n            }\n\n        } while (ret == -1 && errno == EINTR);\n\n#else\n\n        struct iovec *p = iov;\n\n        ret = 0;\n\n        while (iovlen > 0) {\n\n            int rc;\n\n            if (do_sendv) {\n\n                rc = send(sockfd, p->iov_base, p->iov_len, 0);\n\n            } else {\n\n                rc = qemu_recv(sockfd, p->iov_base, p->iov_len, 0);\n\n            }\n\n            if (rc == -1) {\n\n                if (errno == EINTR) {\n\n                    continue;\n\n                }\n\n                if (ret == 0) {\n\n                    ret = -1;\n\n                }\n\n                break;\n\n            }\n\n            if (rc == 0) {\n\n                break;\n\n            }\n\n            ret += rc;\n\n            iovlen--, p++;\n\n        }\n\n#endif\n\n    }\n\n\n\n    /* Undo the changes above */\n\n    iov->iov_base = (char *) iov->iov_base - offset;\n\n    iov->iov_len += offset;\n\n    last_iov->iov_len += diff;\n\n    return ret;\n\n}\n", "idx": 20032, "_split": "test", "_hash": "64913d3c0d827c97c56e6402f6a7933d"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t gt64120_readl (void *opaque,\n\n                               target_phys_addr_t addr, unsigned size)\n\n{\n\n    GT64120State *s = opaque;\n\n    PCIHostState *phb = PCI_HOST_BRIDGE(s);\n\n    uint32_t val;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr & 0xfff) >> 2;\n\n    switch (saddr) {\n\n\n\n    /* CPU Configuration */\n\n    case GT_MULTI:\n\n        /* Only one GT64xxx is present on the CPU bus, return\n\n           the initial value */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* CPU Error Report */\n\n    case GT_CPUERR_ADDRLO:\n\n    case GT_CPUERR_ADDRHI:\n\n    case GT_CPUERR_DATALO:\n\n    case GT_CPUERR_DATAHI:\n\n    case GT_CPUERR_PARITY:\n\n        /* Emulated memory has no error, always return the initial\n\n           values */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* CPU Sync Barrier */\n\n    case GT_PCI0SYNC:\n\n    case GT_PCI1SYNC:\n\n        /* Reading those register should empty all FIFO on the PCI\n\n           bus, which are not emulated. The return value should be\n\n           a random value that should be ignored. */\n\n        val = 0xc000ffee;\n\n        break;\n\n\n\n    /* ECC */\n\n    case GT_ECC_ERRDATALO:\n\n    case GT_ECC_ERRDATAHI:\n\n    case GT_ECC_MEM:\n\n    case GT_ECC_CALC:\n\n    case GT_ECC_ERRADDR:\n\n        /* Emulated memory has no error, always return the initial\n\n           values */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    case GT_CPU:\n\n    case GT_SCS10LD:\n\n    case GT_SCS10HD:\n\n    case GT_SCS32LD:\n\n    case GT_SCS32HD:\n\n    case GT_CS20LD:\n\n    case GT_CS20HD:\n\n    case GT_CS3BOOTLD:\n\n    case GT_CS3BOOTHD:\n\n    case GT_SCS10AR:\n\n    case GT_SCS32AR:\n\n    case GT_CS20R:\n\n    case GT_CS3BOOTR:\n\n    case GT_PCI0IOLD:\n\n    case GT_PCI0M0LD:\n\n    case GT_PCI0M1LD:\n\n    case GT_PCI1IOLD:\n\n    case GT_PCI1M0LD:\n\n    case GT_PCI1M1LD:\n\n    case GT_PCI0IOHD:\n\n    case GT_PCI0M0HD:\n\n    case GT_PCI0M1HD:\n\n    case GT_PCI1IOHD:\n\n    case GT_PCI1M0HD:\n\n    case GT_PCI1M1HD:\n\n    case GT_PCI0IOREMAP:\n\n    case GT_PCI0M0REMAP:\n\n    case GT_PCI0M1REMAP:\n\n    case GT_PCI1IOREMAP:\n\n    case GT_PCI1M0REMAP:\n\n    case GT_PCI1M1REMAP:\n\n    case GT_ISD:\n\n        val = s->regs[saddr];\n\n        break;\n\n    case GT_PCI0_IACK:\n\n        /* Read the IRQ number */\n\n        val = pic_read_irq(isa_pic);\n\n        break;\n\n\n\n    /* SDRAM and Device Address Decode */\n\n    case GT_SCS0LD:\n\n    case GT_SCS0HD:\n\n    case GT_SCS1LD:\n\n    case GT_SCS1HD:\n\n    case GT_SCS2LD:\n\n    case GT_SCS2HD:\n\n    case GT_SCS3LD:\n\n    case GT_SCS3HD:\n\n    case GT_CS0LD:\n\n    case GT_CS0HD:\n\n    case GT_CS1LD:\n\n    case GT_CS1HD:\n\n    case GT_CS2LD:\n\n    case GT_CS2HD:\n\n    case GT_CS3LD:\n\n    case GT_CS3HD:\n\n    case GT_BOOTLD:\n\n    case GT_BOOTHD:\n\n    case GT_ADERR:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* SDRAM Configuration */\n\n    case GT_SDRAM_CFG:\n\n    case GT_SDRAM_OPMODE:\n\n    case GT_SDRAM_BM:\n\n    case GT_SDRAM_ADDRDECODE:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* SDRAM Parameters */\n\n    case GT_SDRAM_B0:\n\n    case GT_SDRAM_B1:\n\n    case GT_SDRAM_B2:\n\n    case GT_SDRAM_B3:\n\n        /* We don't simulate electrical parameters of the SDRAM.\n\n           Just return the last written value. */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* Device Parameters */\n\n    case GT_DEV_B0:\n\n    case GT_DEV_B1:\n\n    case GT_DEV_B2:\n\n    case GT_DEV_B3:\n\n    case GT_DEV_BOOT:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* DMA Record */\n\n    case GT_DMA0_CNT:\n\n    case GT_DMA1_CNT:\n\n    case GT_DMA2_CNT:\n\n    case GT_DMA3_CNT:\n\n    case GT_DMA0_SA:\n\n    case GT_DMA1_SA:\n\n    case GT_DMA2_SA:\n\n    case GT_DMA3_SA:\n\n    case GT_DMA0_DA:\n\n    case GT_DMA1_DA:\n\n    case GT_DMA2_DA:\n\n    case GT_DMA3_DA:\n\n    case GT_DMA0_NEXT:\n\n    case GT_DMA1_NEXT:\n\n    case GT_DMA2_NEXT:\n\n    case GT_DMA3_NEXT:\n\n    case GT_DMA0_CUR:\n\n    case GT_DMA1_CUR:\n\n    case GT_DMA2_CUR:\n\n    case GT_DMA3_CUR:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* DMA Channel Control */\n\n    case GT_DMA0_CTRL:\n\n    case GT_DMA1_CTRL:\n\n    case GT_DMA2_CTRL:\n\n    case GT_DMA3_CTRL:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* DMA Arbiter */\n\n    case GT_DMA_ARB:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* Timer/Counter */\n\n    case GT_TC0:\n\n    case GT_TC1:\n\n    case GT_TC2:\n\n    case GT_TC3:\n\n    case GT_TC_CONTROL:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* PCI Internal */\n\n    case GT_PCI0_CFGADDR:\n\n        val = phb->config_reg;\n\n        break;\n\n    case GT_PCI0_CFGDATA:\n\n        if (!(phb->config_reg & (1 << 31))) {\n\n            val = 0xffffffff;\n\n        } else {\n\n            val = pci_data_read(phb->bus, phb->config_reg, 4);\n\n        }\n\n        if (!(s->regs[GT_PCI0_CMD] & 1) && (phb->config_reg & 0x00fff800)) {\n\n            val = bswap32(val);\n\n        }\n\n        break;\n\n\n\n    case GT_PCI0_CMD:\n\n    case GT_PCI0_TOR:\n\n    case GT_PCI0_BS_SCS10:\n\n    case GT_PCI0_BS_SCS32:\n\n    case GT_PCI0_BS_CS20:\n\n    case GT_PCI0_BS_CS3BT:\n\n    case GT_PCI1_IACK:\n\n    case GT_PCI0_BARE:\n\n    case GT_PCI0_PREFMBR:\n\n    case GT_PCI0_SCS10_BAR:\n\n    case GT_PCI0_SCS32_BAR:\n\n    case GT_PCI0_CS20_BAR:\n\n    case GT_PCI0_CS3BT_BAR:\n\n    case GT_PCI0_SSCS10_BAR:\n\n    case GT_PCI0_SSCS32_BAR:\n\n    case GT_PCI0_SCS3BT_BAR:\n\n    case GT_PCI1_CMD:\n\n    case GT_PCI1_TOR:\n\n    case GT_PCI1_BS_SCS10:\n\n    case GT_PCI1_BS_SCS32:\n\n    case GT_PCI1_BS_CS20:\n\n    case GT_PCI1_BS_CS3BT:\n\n    case GT_PCI1_BARE:\n\n    case GT_PCI1_PREFMBR:\n\n    case GT_PCI1_SCS10_BAR:\n\n    case GT_PCI1_SCS32_BAR:\n\n    case GT_PCI1_CS20_BAR:\n\n    case GT_PCI1_CS3BT_BAR:\n\n    case GT_PCI1_SSCS10_BAR:\n\n    case GT_PCI1_SSCS32_BAR:\n\n    case GT_PCI1_SCS3BT_BAR:\n\n    case GT_PCI1_CFGADDR:\n\n    case GT_PCI1_CFGDATA:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* Interrupts */\n\n    case GT_INTRCAUSE:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"INTRCAUSE %x\\n\", val);\n\n        break;\n\n    case GT_INTRMASK:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"INTRMASK %x\\n\", val);\n\n        break;\n\n    case GT_PCI0_ICMASK:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"ICMASK %x\\n\", val);\n\n        break;\n\n    case GT_PCI0_SERR0MASK:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"SERR0MASK %x\\n\", val);\n\n        break;\n\n\n\n    /* Reserved when only PCI_0 is configured. */\n\n    case GT_HINTRCAUSE:\n\n    case GT_CPU_INTSEL:\n\n    case GT_PCI0_INTSEL:\n\n    case GT_HINTRMASK:\n\n    case GT_PCI0_HICMASK:\n\n    case GT_PCI1_SERR1MASK:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    default:\n\n        val = s->regs[saddr];\n\n        DPRINTF (\"Bad register offset 0x%x\\n\", (int)addr);\n\n        break;\n\n    }\n\n\n\n    if (!(s->regs[GT_CPU] & 0x00001000))\n\n        val = bswap32(val);\n\n\n\n    return val;\n\n}\n", "idx": 20054, "_split": "test", "_hash": "b12100f748613ecc1e06dbbb2db632ef"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opt_set(QemuOpts *opts, const char *name, const char *value)\n\n{\n\n    QemuOpt *opt;\n\n\n\n    opt = qemu_opt_find(opts, name);\n\n    if (!opt) {\n\n        QemuOptDesc *desc = opts->list->desc;\n\n        int i;\n\n\n\n        for (i = 0; desc[i].name != NULL; i++) {\n\n            if (strcmp(desc[i].name, name) == 0) {\n\n                break;\n\n            }\n\n        }\n\n        if (desc[i].name == NULL) {\n\n            if (i == 0) {\n\n                /* empty list -> allow any */;\n\n            } else {\n\n                fprintf(stderr, \"option \\\"%s\\\" is not valid for %s\\n\",\n\n                        name, opts->list->name);\n\n                return -1;\n\n            }\n\n        }\n\n        opt = qemu_mallocz(sizeof(*opt));\n\n        opt->name = qemu_strdup(name);\n\n        opt->opts = opts;\n\n        TAILQ_INSERT_TAIL(&opts->head, opt, next);\n\n        if (desc[i].name != NULL) {\n\n            opt->desc = desc+i;\n\n        }\n\n    }\n\n    qemu_free((/* !const */ char*)opt->str);\n\n    opt->str = NULL;\n\n    if (value) {\n\n        opt->str = qemu_strdup(value);\n\n    }\n\n    if (qemu_opt_parse(opt) < 0) {\n\n        fprintf(stderr, \"Failed to parse \\\"%s\\\" for \\\"%s.%s\\\"\\n\", opt->str,\n\n                opts->list->name, opt->name);\n\n        qemu_opt_del(opt);\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 20070, "_split": "test", "_hash": "59594d765adc85629aeed1ef13e32c87"}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static int scsi_initfn(SCSIDevice *dev)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);\n\n    Error *err = NULL;\n\n\n\n    if (!s->qdev.conf.bs) {\n\n        error_report(\"drive property not set\");\n\n        return -1;\n\n    }\n\n\n\n    if (!(s->features & (1 << SCSI_DISK_F_REMOVABLE)) &&\n\n        !bdrv_is_inserted(s->qdev.conf.bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return -1;\n\n    }\n\n\n\n    blkconf_serial(&s->qdev.conf, &s->serial);\n\n    if (dev->type == TYPE_DISK) {\n\n        blkconf_geometry(&dev->conf, NULL, 65535, 255, 255, &err);\n\n        if (err) {\n\n            error_report(\"%s\", error_get_pretty(err));\n\n            error_free(err);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (s->qdev.conf.discard_granularity == -1) {\n\n        s->qdev.conf.discard_granularity =\n\n            MAX(s->qdev.conf.logical_block_size, DEFAULT_DISCARD_GRANULARITY);\n\n    }\n\n\n\n    if (!s->version) {\n\n        s->version = g_strdup(qemu_get_version());\n\n    }\n\n    if (!s->vendor) {\n\n        s->vendor = g_strdup(\"QEMU\");\n\n    }\n\n\n\n    if (bdrv_is_sg(s->qdev.conf.bs)) {\n\n        error_report(\"unwanted /dev/sg*\");\n\n        return -1;\n\n    }\n\n\n\n    if ((s->features & (1 << SCSI_DISK_F_REMOVABLE)) &&\n\n            !(s->features & (1 << SCSI_DISK_F_NO_REMOVABLE_DEVOPS))) {\n\n        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_removable_block_ops, s);\n\n    } else {\n\n        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_block_ops, s);\n\n    }\n\n    bdrv_set_guest_block_size(s->qdev.conf.bs, s->qdev.blocksize);\n\n\n\n    bdrv_iostatus_enable(s->qdev.conf.bs);\n\n    add_boot_device_path(s->qdev.conf.bootindex, &dev->qdev, NULL);\n\n    return 0;\n\n}\n", "idx": 20086, "_split": "test", "_hash": "9071f77dad7e3c5a766970ae499bcbbb"}
{"project": "qemu", "commit_id": "9359a58b122187964d7465d48165680eadbf69d3", "target": 0, "func": "static void ehci_update_frindex(EHCIState *ehci, int frames)\n\n{\n\n    int i;\n\n\n\n    if (!ehci_enabled(ehci)) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < frames; i++) {\n\n        ehci->frindex += 8;\n\n\n\n        if (ehci->frindex == 0x00002000) {\n\n            ehci_raise_irq(ehci, USBSTS_FLR);\n\n        }\n\n\n\n        if (ehci->frindex == 0x00004000) {\n\n            ehci_raise_irq(ehci, USBSTS_FLR);\n\n            ehci->frindex = 0;\n\n            if (ehci->usbsts_frindex >= 0x00004000) {\n\n                ehci->usbsts_frindex -= 0x00004000;\n\n            } else {\n\n                ehci->usbsts_frindex = 0;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 20095, "_split": "test", "_hash": "19e743fad9a6402bd7de04299ea17c28"}
{"project": "qemu", "commit_id": "85a67692d04e15a6b7d5a0e2b9d573d8bffbe108", "target": 0, "func": "static void pty_chr_state(CharDriverState *chr, int connected)\n\n{\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (!connected) {\n\n        if (s->fd_tag) {\n\n            g_source_remove(s->fd_tag);\n\n            s->fd_tag = 0;\n\n        }\n\n        s->connected = 0;\n\n        s->polling = 0;\n\n        /* (re-)connect poll interval for idle guests: once per second.\n\n         * We check more frequently in case the guests sends data to\n\n         * the virtual device linked to our pty. */\n\n        pty_chr_rearm_timer(chr, 1000);\n\n    } else {\n\n        if (!s->connected)\n\n            qemu_chr_be_generic_open(chr);\n\n        s->connected = 1;\n\n    }\n\n}\n", "idx": 20105, "_split": "test", "_hash": "53ca0af8fb691864dd975bf1fa8e6b2e"}
{"project": "qemu", "commit_id": "f3d8b1eb105199a1d6bf063a8a574e782689909a", "target": 1, "func": "static void stellaris_init(const char *kernel_filename, const char *cpu_model,\n\n                           DisplayState *ds, stellaris_board_info *board)\n\n{\n\n    static const int uart_irq[] = {5, 6, 33, 34};\n\n    static const int timer_irq[] = {19, 21, 23, 35};\n\n    static const uint32_t gpio_addr[7] =\n\n      { 0x40004000, 0x40005000, 0x40006000, 0x40007000,\n\n        0x40024000, 0x40025000, 0x40026000};\n\n    static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31};\n\n\n\n    qemu_irq *pic;\n\n    qemu_irq *gpio_in[5];\n\n    qemu_irq *gpio_out[5];\n\n    qemu_irq adc;\n\n    int sram_size;\n\n    int flash_size;\n\n    i2c_bus *i2c;\n\n    int i;\n\n\n\n    flash_size = ((board->dc0 & 0xffff) + 1) << 1;\n\n    sram_size = (board->dc0 >> 18) + 1;\n\n    pic = armv7m_init(flash_size, sram_size, kernel_filename, cpu_model);\n\n\n\n    if (board->dc1 & (1 << 16)) {\n\n        adc = stellaris_adc_init(0x40038000, pic[14]);\n\n    } else {\n\n        adc = NULL;\n\n    }\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (0x10000 << i)) {\n\n            stellaris_gptm_init(0x40030000 + i * 0x1000,\n\n                                pic[timer_irq[i]], adc);\n\n        }\n\n    }\n\n\n\n    stellaris_sys_init(0x400fe000, pic[28], board, nd_table[0].macaddr);\n\n\n\n    for (i = 0; i < 7; i++) {\n\n        if (board->dc4 & (1 << i)) {\n\n            gpio_in[i] = pl061_init(gpio_addr[i], pic[gpio_irq[i]],\n\n                                    &gpio_out[i]);\n\n        }\n\n    }\n\n\n\n    if (board->dc2 & (1 << 12)) {\n\n        i2c = i2c_init_bus();\n\n        stellaris_i2c_init(0x40020000, pic[8], i2c);\n\n        if (board->peripherals & BP_OLED_I2C) {\n\n            ssd0303_init(ds, i2c, 0x3d);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (1 << i)) {\n\n            pl011_init(0x4000c000 + i * 0x1000, pic[uart_irq[i]],\n\n                       serial_hds[i], PL011_LUMINARY);\n\n        }\n\n    }\n\n    if (board->dc2 & (1 << 4)) {\n\n        if (board->peripherals & BP_OLED_SSI) {\n\n            void * oled;\n\n            void * sd;\n\n            void *ssi_bus;\n\n            int index;\n\n\n\n            oled = ssd0323_init(ds, &gpio_out[GPIO_C][7]);\n\n            index = drive_get_index(IF_SD, 0, 0);\n\n            sd = ssi_sd_init(drives_table[index].bdrv);\n\n\n\n            ssi_bus = stellaris_ssi_bus_init(&gpio_out[GPIO_D][0],\n\n                                             ssi_sd_xfer, sd,\n\n                                             ssd0323_xfer_ssi, oled);\n\n\n\n            pl022_init(0x40008000, pic[7], stellaris_ssi_bus_xfer, ssi_bus);\n\n            /* Make sure the select pin is high.  */\n\n            qemu_irq_raise(gpio_out[GPIO_D][0]);\n\n        } else {\n\n            pl022_init(0x40008000, pic[7], NULL, NULL);\n\n        }\n\n    }\n\n    if (board->dc4 & (1 << 28)) {\n\n        /* FIXME: Obey network model.  */\n\n        stellaris_enet_init(&nd_table[0], 0x40048000, pic[42]);\n\n    }\n\n    if (board->peripherals & BP_GAMEPAD) {\n\n        qemu_irq gpad_irq[5];\n\n        static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d };\n\n\n\n        gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); /* up */\n\n        gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); /* down */\n\n        gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); /* left */\n\n        gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); /* right */\n\n        gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); /* select */\n\n\n\n        stellaris_gamepad_init(5, gpad_irq, gpad_keycode);\n\n    }\n\n}\n", "idx": 20110, "_split": "test", "_hash": "49bcac9d163c615d56b79e08f72f60bb"}
{"project": "qemu", "commit_id": "e95205e1f9cd2c4262b7a7b1c992a94512c86d0e", "target": 1, "func": "static void continue_after_map_failure(void *opaque)\n\n{\n\n    DMAAIOCB *dbs = (DMAAIOCB *)opaque;\n\n\n\n    dbs->bh = qemu_bh_new(reschedule_dma, dbs);\n\n    qemu_bh_schedule(dbs->bh);\n\n}\n", "idx": 20131, "_split": "test", "_hash": "12dd43cae94b5f05f078f82a3a2dd260"}
{"project": "qemu", "commit_id": "3a21532626bb5c3ecb0f916843f75ccce6501a9d", "target": 0, "func": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    EHCIState *s = ptr;\n\n    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);\n\n    uint32_t old = *mmio;\n\n    int i;\n\n\n\n    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);\n\n\n\n    /* Only aligned reads are allowed on OHCI */\n\n    if (addr & 3) {\n\n        fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\"\n\n                TARGET_FMT_plx \"\\n\", addr);\n\n        return;\n\n    }\n\n\n\n    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {\n\n        handle_port_status_write(s, (addr-PORTSC)/4, val);\n\n        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);\n\n        return;\n\n    }\n\n\n\n    if (addr < OPREGBASE) {\n\n        fprintf(stderr, \"usb-ehci: write attempt to read-only register\"\n\n                TARGET_FMT_plx \"\\n\", addr);\n\n        return;\n\n    }\n\n\n\n\n\n    /* Do any register specific pre-write processing here.  */\n\n    switch(addr) {\n\n    case USBCMD:\n\n        if (val & USBCMD_HCRESET) {\n\n            ehci_reset(s);\n\n            val = s->usbcmd;\n\n            break;\n\n        }\n\n\n\n        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=\n\n            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {\n\n            if (!ehci_enabled(s)) {\n\n                qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));\n\n                SET_LAST_RUN_CLOCK(s);\n\n            }\n\n            ehci_update_halt(s);\n\n        }\n\n\n\n        /* not supporting dynamic frame list size at the moment */\n\n        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {\n\n            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",\n\n                    val & USBCMD_FLS);\n\n            val &= ~USBCMD_FLS;\n\n        }\n\n        break;\n\n\n\n    case USBSTS:\n\n        val &= USBSTS_RO_MASK;              // bits 6 through 31 are RO\n\n        ehci_clear_usbsts(s, val);          // bits 0 through 5 are R/WC\n\n        val = s->usbsts;\n\n        ehci_set_interrupt(s, 0);\n\n        break;\n\n\n\n    case USBINTR:\n\n        val &= USBINTR_MASK;\n\n        break;\n\n\n\n    case FRINDEX:\n\n        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */\n\n        break;\n\n\n\n    case CONFIGFLAG:\n\n        val &= 0x1;\n\n        if (val) {\n\n            for(i = 0; i < NB_PORTS; i++)\n\n                handle_port_owner_write(s, i, 0);\n\n        }\n\n        break;\n\n\n\n    case PERIODICLISTBASE:\n\n        if (ehci_periodic_enabled(s)) {\n\n            fprintf(stderr,\n\n              \"ehci: PERIODIC list base register set while periodic schedule\\n\"\n\n              \"      is enabled and HC is enabled\\n\");\n\n        }\n\n        break;\n\n\n\n    case ASYNCLISTADDR:\n\n        if (ehci_async_enabled(s)) {\n\n            fprintf(stderr,\n\n              \"ehci: ASYNC list address register set while async schedule\\n\"\n\n              \"      is enabled and HC is enabled\\n\");\n\n        }\n\n        break;\n\n    }\n\n\n\n    *mmio = val;\n\n    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);\n\n}\n", "idx": 20148, "_split": "test", "_hash": "55938e231f75cecd2d9d211ba1f37f0b"}
{"project": "qemu", "commit_id": "f5babeacc4abccbb32f318278135a43477bdaa20", "target": 0, "func": "sPAPRDRConnector *spapr_drc_by_index(uint32_t index)\n\n{\n\n    Object *obj;\n\n    char name[256];\n\n\n\n    snprintf(name, sizeof(name), \"%s/%x\", DRC_CONTAINER_PATH, index);\n\n    obj = object_resolve_path(name, NULL);\n\n\n\n    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);\n\n}\n", "idx": 20151, "_split": "test", "_hash": "1b93d8909f9ce6f87f44761005791ebe"}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_fnmadd (uint64_t arg1, uint64_t arg2, uint64_t arg3)\n\n{\n\n    CPU_DoubleU farg1, farg2, farg3;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n    farg3.ll = arg3;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                 float64_is_signaling_nan(farg2.d) ||\n\n                 float64_is_signaling_nan(farg3.d))) {\n\n        /* sNaN operation */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN);\n\n    } else if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||\n\n                        (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {\n\n        /* Multiplication of zero by infinity */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ);\n\n    } else {\n\n#if USE_PRECISE_EMULATION\n\n#ifdef FLOAT128\n\n        /* This is the way the PowerPC specification defines it */\n\n        float128 ft0_128, ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) && float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) != float64_is_neg(farg3.d))) {\n\n            /* Magnitude subtraction of infinities */\n\n            farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_add(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n#else\n\n        /* This is OK on x86 hosts */\n\n        farg1.d = (farg1.d * farg2.d) + farg3.d;\n\n#endif\n\n#else\n\n        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);\n\n        farg1.d = float64_add(farg1.d, farg3.d, &env->fp_status);\n\n#endif\n\n        if (likely(!float64_is_nan(farg1.d)))\n\n            farg1.d = float64_chs(farg1.d);\n\n    }\n\n    return farg1.ll;\n\n}\n", "idx": 20158, "_split": "test", "_hash": "6bde5db3dbea1065e2868f5084e6dc02"}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static int cow_probe(const uint8_t *buf, int buf_size, const char *filename)\n\n{\n\n    const struct cow_header_v2 *cow_header = (const void *)buf;\n\n\n\n    if (buf_size >= sizeof(struct cow_header_v2) &&\n\n        be32_to_cpu(cow_header->magic) == COW_MAGIC &&\n\n        be32_to_cpu(cow_header->version) == COW_VERSION)\n\n        return 100;\n\n    else\n\n        return 0;\n\n}\n", "idx": 20189, "_split": "test", "_hash": "18a35497e0d2dc313d0c40ae4a99b328"}
{"project": "qemu", "commit_id": "ad96090a01d848df67d70c5259ed8aa321fa8716", "target": 0, "func": "uint64_t ram_bytes_remaining(void)\n\n{\n\n    return ram_save_remaining() * TARGET_PAGE_SIZE;\n\n}\n", "idx": 20197, "_split": "test", "_hash": "fabbb01f50e5e9d107ebd2ad2c5223b7"}
{"project": "qemu", "commit_id": "0d82d0e8b98cf0ea03a45f8542d835ebd3a84cd3", "target": 0, "func": "static ssize_t buffered_flush(QEMUFileBuffered *s)\n\n{\n\n    size_t offset = 0;\n\n    ssize_t ret = 0;\n\n\n\n    DPRINTF(\"flushing %zu byte(s) of data\\n\", s->buffer_size);\n\n\n\n    while (s->bytes_xfer < s->xfer_limit && offset < s->buffer_size) {\n\n        size_t to_send = MIN(s->buffer_size - offset, s->xfer_limit - s->bytes_xfer);\n\n        ret = migrate_fd_put_buffer(s->migration_state, s->buffer + offset,\n\n                                    to_send);\n\n        if (ret <= 0) {\n\n            DPRINTF(\"error flushing data, %zd\\n\", ret);\n\n            break;\n\n        } else {\n\n            DPRINTF(\"flushed %zd byte(s)\\n\", ret);\n\n            offset += ret;\n\n            s->bytes_xfer += ret;\n\n        }\n\n    }\n\n\n\n    DPRINTF(\"flushed %zu of %zu byte(s)\\n\", offset, s->buffer_size);\n\n    memmove(s->buffer, s->buffer + offset, s->buffer_size - offset);\n\n    s->buffer_size -= offset;\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    return offset;\n\n}\n", "idx": 20200, "_split": "test", "_hash": "fe17a79c31950ad45fc852fba7a41ebf"}
{"project": "qemu", "commit_id": "10c4c98ab7dc18169b37b76f6ea5e60ebe65222b", "target": 0, "func": "void pci_qdev_register(PCIDeviceInfo *info)\n\n{\n\n    info->qdev.init = pci_qdev_init;\n\n    info->qdev.bus_type = BUS_TYPE_PCI;\n\n    qdev_register(&info->qdev);\n\n}\n", "idx": 20213, "_split": "test", "_hash": "8afc9aafc95f4ca18f3eab0c7cae4706"}
{"project": "qemu", "commit_id": "2d2507ef23d2a28eaeea5507ff4ec68657f1792f", "target": 0, "func": "static void vhost_net_stop_one(struct vhost_net *net,\n\n                               VirtIODevice *dev)\n\n{\n\n    struct vhost_vring_file file = { .fd = -1 };\n\n\n\n    if (!net->dev.started) {\n\n        return;\n\n    }\n\n\n\n    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {\n\n        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {\n\n            const VhostOps *vhost_ops = net->dev.vhost_ops;\n\n            int r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,\n\n                                          &file);\n\n            assert(r >= 0);\n\n        }\n\n    }\n\n    if (net->nc->info->poll) {\n\n        net->nc->info->poll(net->nc, true);\n\n    }\n\n    vhost_dev_stop(&net->dev, dev);\n\n    vhost_dev_disable_notifiers(&net->dev, dev);\n\n}\n", "idx": 20233, "_split": "test", "_hash": "e6f088095eb961d4b900f0ebaa5a7fd1"}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "int cpu_s390x_handle_mmu_fault (CPUState *env, target_ulong address, int rw,\n\n                                int mmu_idx, int is_softmmu)\n\n{\n\n    target_ulong phys;\n\n    int prot;\n\n\n\n    /* XXX: implement mmu */\n\n\n\n    phys = address;\n\n    prot = PAGE_READ | PAGE_WRITE;\n\n\n\n    return tlb_set_page(env, address & TARGET_PAGE_MASK,\n\n                        phys & TARGET_PAGE_MASK, prot,\n\n                        mmu_idx, is_softmmu);\n\n}\n", "idx": 20238, "_split": "test", "_hash": "58f98bbce8a0fa27c9ef60beff9fc5c1"}
{"project": "qemu", "commit_id": "8a5bb1f114c5959cf6b247a737394afb0c518b40", "target": 0, "func": "static int inc_refcounts(BlockDriverState *bs,\n\n                         BdrvCheckResult *res,\n\n                         void **refcount_table,\n\n                         int64_t *refcount_table_size,\n\n                         int64_t offset, int64_t size)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t start, last, cluster_offset, k, refcount;\n\n    int ret;\n\n\n\n    if (size <= 0) {\n\n        return 0;\n\n    }\n\n\n\n    start = start_of_cluster(s, offset);\n\n    last = start_of_cluster(s, offset + size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size) {\n\n        k = cluster_offset >> s->cluster_bits;\n\n        if (k >= *refcount_table_size) {\n\n            ret = realloc_refcount_array(s, refcount_table,\n\n                                         refcount_table_size, k + 1);\n\n            if (ret < 0) {\n\n                res->check_errors++;\n\n                return ret;\n\n            }\n\n        }\n\n\n\n        refcount = s->get_refcount(*refcount_table, k);\n\n        if (refcount == s->refcount_max) {\n\n            fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n\n                    \"\\n\", cluster_offset);\n\n            fprintf(stderr, \"Use qemu-img amend to increase the refcount entry \"\n\n                    \"width or qemu-img convert to create a clean copy if the \"\n\n                    \"image cannot be opened for writing\\n\");\n\n            res->corruptions++;\n\n            continue;\n\n        }\n\n        s->set_refcount(*refcount_table, k, refcount + 1);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 20248, "_split": "test", "_hash": "7def5348a4caa46b96195407b4c000a7"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void gic_do_cpu_write(void *opaque, target_phys_addr_t addr,\n\n                             uint64_t value, unsigned size)\n\n{\n\n    GICState **backref = (GICState **)opaque;\n\n    GICState *s = *backref;\n\n    int id = (backref - s->backref);\n\n    gic_cpu_write(s, id, addr, value);\n\n}\n", "idx": 20257, "_split": "test", "_hash": "8a79db6a313938d269ac658aac5242fc"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void stq_be_phys(target_phys_addr_t addr, uint64_t val)\n\n{\n\n    val = cpu_to_be64(val);\n\n    cpu_physical_memory_write(addr, &val, 8);\n\n}\n", "idx": 20282, "_split": "test", "_hash": "9b412d06ac90935c5965925e4aa939c4"}
{"project": "qemu", "commit_id": "9f2130f58d5dd4e1fcb435cca08bf77e7c32e6c6", "target": 0, "func": "static int fb_initialise(struct XenDevice *xendev)\n\n{\n\n    struct XenFB *fb = container_of(xendev, struct XenFB, c.xendev);\n\n    struct xenfb_page *fb_page;\n\n    int videoram;\n\n    int rc;\n\n\n\n    if (xenstore_read_fe_int(xendev, \"videoram\", &videoram) == -1)\n\n\tvideoram = 0;\n\n\n\n    rc = common_bind(&fb->c);\n\n    if (rc != 0)\n\n\treturn rc;\n\n\n\n    fb_page = fb->c.page;\n\n    rc = xenfb_configure_fb(fb, videoram * 1024 * 1024U,\n\n\t\t\t    fb_page->width, fb_page->height, fb_page->depth,\n\n\t\t\t    fb_page->mem_length, 0, fb_page->line_length);\n\n    if (rc != 0)\n\n\treturn rc;\n\n\n\n    rc = xenfb_map_fb(fb);\n\n    if (rc != 0)\n\n\treturn rc;\n\n\n\n#if 0  /* handled in xen_init_display() for now */\n\n    if (!fb->have_console) {\n\n        fb->c.ds = graphic_console_init(xenfb_update,\n\n                                        xenfb_invalidate,\n\n                                        NULL,\n\n                                        NULL,\n\n                                        fb);\n\n        fb->have_console = 1;\n\n    }\n\n#endif\n\n\n\n    if (xenstore_read_fe_int(xendev, \"feature-update\", &fb->feature_update) == -1)\n\n\tfb->feature_update = 0;\n\n    if (fb->feature_update)\n\n\txenstore_write_be_int(xendev, \"request-update\", 1);\n\n\n\n    xen_pv_printf(xendev, 1, \"feature-update=%d, videoram=%d\\n\",\n\n\t\t  fb->feature_update, videoram);\n\n    return 0;\n\n}\n", "idx": 20283, "_split": "test", "_hash": "0f8f210df72828905c6b85f503854fda"}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "static void gen_exts(int ot, TCGv reg)\n\n{\n\n    switch(ot) {\n\n    case OT_BYTE:\n\n        tcg_gen_ext8s_tl(reg, reg);\n\n        break;\n\n    case OT_WORD:\n\n        tcg_gen_ext16s_tl(reg, reg);\n\n        break;\n\n    case OT_LONG:\n\n        tcg_gen_ext32s_tl(reg, reg);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 20299, "_split": "test", "_hash": "144458a47cbd0c55773911aec79f48ca"}
{"project": "qemu", "commit_id": "c0462f6d75fa481f7660c15a5ca3a60205aa4eca", "target": 0, "func": "bool is_valid_option_list(const char *param)\n\n{\n\n    size_t buflen = strlen(param) + 1;\n\n    char *buf = g_malloc(buflen);\n\n    const char *p = param;\n\n    bool result = true;\n\n\n\n    while (*p) {\n\n        p = get_opt_value(buf, buflen, p);\n\n        if (*p && !*++p) {\n\n            result = false;\n\n            goto out;\n\n        }\n\n\n\n        if (!*buf || *buf == ',') {\n\n            result = false;\n\n            goto out;\n\n        }\n\n    }\n\n\n\nout:\n\n    free(buf);\n\n    return result;\n\n}\n", "idx": 20301, "_split": "test", "_hash": "fecfd60b43c7a16a4e44dea850c7903f"}
{"project": "qemu", "commit_id": "d4754a953196516b16beef707dcdfdb35c2eec6e", "target": 1, "func": "static void net_l2tpv3_cleanup(NetClientState *nc)\n\n{\n\n    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nc, nc);\n\n    qemu_purge_queued_packets(nc);\n\n    l2tpv3_read_poll(s, false);\n\n    l2tpv3_write_poll(s, false);\n\n    if (s->fd > 0) {\n\n        close(s->fd);\n\n    }\n\n    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);\n\n    g_free(s->vec);\n\n    g_free(s->header_buf);\n\n    g_free(s->dgram_dst);\n\n}\n", "idx": 20327, "_split": "test", "_hash": "441350c6378658841dfbcf919a26fbe5"}
{"project": "qemu", "commit_id": "79d5ca5617cfc9be13a4f314ed800fca1267d903", "target": 1, "func": "static AioHandler *find_aio_handler(int fd)\n\n{\n\n    AioHandler *node;\n\n\n\n    LIST_FOREACH(node, &aio_handlers, node) {\n\n        if (node->fd == fd)\n\n            return node;\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 20328, "_split": "test", "_hash": "d723a58a2ad7e0ff6e31a1113a3fca14"}
{"project": "qemu", "commit_id": "4e47e39ab0ded72c0af174131ecf49d588d66c12", "target": 1, "func": "int x86_cpu_gdb_write_register(CPUState *cs, uint8_t *mem_buf, int n)\n\n{\n\n    X86CPU *cpu = X86_CPU(cs);\n\n    CPUX86State *env = &cpu->env;\n\n    uint32_t tmp;\n\n\n\n    if (n < CPU_NB_REGS) {\n\n        if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {\n\n            env->regs[gpr_map[n]] = ldtul_p(mem_buf);\n\n            return sizeof(target_ulong);\n\n        } else if (n < CPU_NB_REGS32) {\n\n            n = gpr_map32[n];\n\n            env->regs[n] &= ~0xffffffffUL;\n\n            env->regs[n] |= (uint32_t)ldl_p(mem_buf);\n\n            return 4;\n\n        }\n\n    } else if (n >= IDX_FP_REGS && n < IDX_FP_REGS + 8) {\n\n#ifdef USE_X86LDOUBLE\n\n        /* FIXME: byteswap float values - after fixing fpregs layout. */\n\n        memcpy(&env->fpregs[n - IDX_FP_REGS], mem_buf, 10);\n\n#endif\n\n        return 10;\n\n    } else if (n >= IDX_XMM_REGS && n < IDX_XMM_REGS + CPU_NB_REGS) {\n\n        n -= IDX_XMM_REGS;\n\n        if (n < CPU_NB_REGS32 ||\n\n            (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK)) {\n\n            env->xmm_regs[n].XMM_Q(0) = ldq_p(mem_buf);\n\n            env->xmm_regs[n].XMM_Q(1) = ldq_p(mem_buf + 8);\n\n            return 16;\n\n        }\n\n    } else {\n\n        switch (n) {\n\n        case IDX_IP_REG:\n\n            if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {\n\n                env->eip = ldq_p(mem_buf);\n\n                return 8;\n\n            } else {\n\n                env->eip &= ~0xffffffffUL;\n\n                env->eip |= (uint32_t)ldl_p(mem_buf);\n\n                return 4;\n\n            }\n\n        case IDX_FLAGS_REG:\n\n            env->eflags = ldl_p(mem_buf);\n\n            return 4;\n\n\n\n        case IDX_SEG_REGS:\n\n            return x86_cpu_gdb_load_seg(cpu, R_CS, mem_buf);\n\n        case IDX_SEG_REGS + 1:\n\n            return x86_cpu_gdb_load_seg(cpu, R_SS, mem_buf);\n\n        case IDX_SEG_REGS + 2:\n\n            return x86_cpu_gdb_load_seg(cpu, R_DS, mem_buf);\n\n        case IDX_SEG_REGS + 3:\n\n            return x86_cpu_gdb_load_seg(cpu, R_ES, mem_buf);\n\n        case IDX_SEG_REGS + 4:\n\n            return x86_cpu_gdb_load_seg(cpu, R_FS, mem_buf);\n\n        case IDX_SEG_REGS + 5:\n\n            return x86_cpu_gdb_load_seg(cpu, R_GS, mem_buf);\n\n\n\n        case IDX_FP_REGS + 8:\n\n            env->fpuc = ldl_p(mem_buf);\n\n            return 4;\n\n        case IDX_FP_REGS + 9:\n\n            tmp = ldl_p(mem_buf);\n\n            env->fpstt = (tmp >> 11) & 7;\n\n            env->fpus = tmp & ~0x3800;\n\n            return 4;\n\n        case IDX_FP_REGS + 10: /* ftag */\n\n            return 4;\n\n        case IDX_FP_REGS + 11: /* fiseg */\n\n            return 4;\n\n        case IDX_FP_REGS + 12: /* fioff */\n\n            return 4;\n\n        case IDX_FP_REGS + 13: /* foseg */\n\n            return 4;\n\n        case IDX_FP_REGS + 14: /* fooff */\n\n            return 4;\n\n        case IDX_FP_REGS + 15: /* fop */\n\n            return 4;\n\n\n\n        case IDX_MXCSR_REG:\n\n            env->mxcsr = ldl_p(mem_buf);\n\n            return 4;\n\n        }\n\n    }\n\n    /* Unrecognised register.  */\n\n    return 0;\n\n}\n", "idx": 20345, "_split": "test", "_hash": "c482bdd5295a8245c32259941c0df7bd"}
{"project": "qemu", "commit_id": "424ad8388f89f4202a7836d003273f23ebe04b09", "target": 0, "func": "static void cchip_write(void *opaque, hwaddr addr,\n\n                        uint64_t val, unsigned size)\n\n{\n\n    TyphoonState *s = opaque;\n\n    uint64_t oldval, newval;\n\n\n\n    switch (addr) {\n\n    case 0x0000:\n\n        /* CSC: Cchip System Configuration Register.  */\n\n        /* All sorts of data here; nothing relevant RW.  */\n\n        break;\n\n\n\n    case 0x0040:\n\n        /* MTR: Memory Timing Register.  */\n\n        /* All sorts of stuff related to real DRAM.  */\n\n        break;\n\n\n\n    case 0x0080:\n\n        /* MISC: Miscellaneous Register.  */\n\n        newval = oldval = s->cchip.misc;\n\n        newval &= ~(val & 0x10000ff0);     /* W1C fields */\n\n        if (val & 0x100000) {\n\n            newval &= ~0xff0000ull;        /* ACL clears ABT and ABW */\n\n        } else {\n\n            newval |= val & 0x00f00000;    /* ABT field is W1S */\n\n            if ((newval & 0xf0000) == 0) {\n\n                newval |= val & 0xf0000;   /* ABW field is W1S iff zero */\n\n            }\n\n        }\n\n        newval |= (val & 0xf000) >> 4;     /* IPREQ field sets IPINTR.  */\n\n\n\n        newval &= ~0xf0000000000ull;       /* WO and RW fields */\n\n        newval |= val & 0xf0000000000ull;\n\n        s->cchip.misc = newval;\n\n\n\n        /* Pass on changes to IPI and ITI state.  */\n\n        if ((newval ^ oldval) & 0xff0) {\n\n            int i;\n\n            for (i = 0; i < 4; ++i) {\n\n                AlphaCPU *cpu = s->cchip.cpu[i];\n\n                if (cpu != NULL) {\n\n                    CPUState *cs = CPU(cpu);\n\n                    /* IPI can be either cleared or set by the write.  */\n\n                    if (newval & (1 << (i + 8))) {\n\n                        cpu_interrupt(cs, CPU_INTERRUPT_SMP);\n\n                    } else {\n\n                        cpu_reset_interrupt(cs, CPU_INTERRUPT_SMP);\n\n                    }\n\n\n\n                    /* ITI can only be cleared by the write.  */\n\n                    if ((newval & (1 << (i + 4))) == 0) {\n\n                        cpu_reset_interrupt(cs, CPU_INTERRUPT_TIMER);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x00c0:\n\n        /* MPD: Memory Presence Detect Register.  */\n\n        break;\n\n\n\n    case 0x0100: /* AAR0 */\n\n    case 0x0140: /* AAR1 */\n\n    case 0x0180: /* AAR2 */\n\n    case 0x01c0: /* AAR3 */\n\n        /* AAR: Array Address Register.  */\n\n        /* All sorts of information about DRAM.  */\n\n        break;\n\n\n\n    case 0x0200: /* DIM0 */\n\n        /* DIM: Device Interrupt Mask Register, CPU0.  */\n\n        s->cchip.dim[0] = val;\n\n        cpu_irq_change(s->cchip.cpu[0], val & s->cchip.drir);\n\n        break;\n\n    case 0x0240: /* DIM1 */\n\n        /* DIM: Device Interrupt Mask Register, CPU1.  */\n\n        s->cchip.dim[0] = val;\n\n        cpu_irq_change(s->cchip.cpu[1], val & s->cchip.drir);\n\n        break;\n\n\n\n    case 0x0280: /* DIR0 (RO) */\n\n    case 0x02c0: /* DIR1 (RO) */\n\n    case 0x0300: /* DRIR (RO) */\n\n        break;\n\n\n\n    case 0x0340:\n\n        /* PRBEN: Probe Enable Register.  */\n\n        break;\n\n\n\n    case 0x0380: /* IIC0 */\n\n        s->cchip.iic[0] = val & 0xffffff;\n\n        break;\n\n    case 0x03c0: /* IIC1 */\n\n        s->cchip.iic[1] = val & 0xffffff;\n\n        break;\n\n\n\n    case 0x0400: /* MPR0 */\n\n    case 0x0440: /* MPR1 */\n\n    case 0x0480: /* MPR2 */\n\n    case 0x04c0: /* MPR3 */\n\n        /* MPR: Memory Programming Register.  */\n\n        break;\n\n\n\n    case 0x0580:\n\n        /* TTR: TIGbus Timing Register.  */\n\n        /* All sorts of stuff related to interrupt delivery timings.  */\n\n        break;\n\n    case 0x05c0:\n\n        /* TDR: TIGbug Device Timing Register.  */\n\n        break;\n\n\n\n    case 0x0600:\n\n        /* DIM2: Device Interrupt Mask Register, CPU2.  */\n\n        s->cchip.dim[2] = val;\n\n        cpu_irq_change(s->cchip.cpu[2], val & s->cchip.drir);\n\n        break;\n\n    case 0x0640:\n\n        /* DIM3: Device Interrupt Mask Register, CPU3.  */\n\n        s->cchip.dim[3] = val;\n\n        cpu_irq_change(s->cchip.cpu[3], val & s->cchip.drir);\n\n        break;\n\n\n\n    case 0x0680: /* DIR2 (RO) */\n\n    case 0x06c0: /* DIR3 (RO) */\n\n        break;\n\n\n\n    case 0x0700: /* IIC2 */\n\n        s->cchip.iic[2] = val & 0xffffff;\n\n        break;\n\n    case 0x0740: /* IIC3 */\n\n        s->cchip.iic[3] = val & 0xffffff;\n\n        break;\n\n\n\n    case 0x0780:\n\n        /* PWR: Power Management Control.   */\n\n        break;\n\n    \n\n    case 0x0c00: /* CMONCTLA */\n\n    case 0x0c40: /* CMONCTLB */\n\n    case 0x0c80: /* CMONCNT01 */\n\n    case 0x0cc0: /* CMONCNT23 */\n\n        break;\n\n\n\n    default:\n\n        cpu_unassigned_access(current_cpu, addr, true, false, 0, size);\n\n        return;\n\n    }\n\n}\n", "idx": 20365, "_split": "test", "_hash": "b2f4e64ce7b42236da73e9ffecbf16fa"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void exynos4210_combiner_write(void *opaque, target_phys_addr_t offset,\n\n        uint64_t val, unsigned size)\n\n{\n\n    struct Exynos4210CombinerState *s =\n\n            (struct Exynos4210CombinerState *)opaque;\n\n    uint32_t req_quad_base_n;    /* Base of registers quad. Multiply it by 4 and\n\n                                   get a start of corresponding group quad */\n\n    uint32_t grp_quad_base_n;    /* Base of group quad */\n\n    uint32_t reg_n;              /* Register number inside the quad */\n\n\n\n    req_quad_base_n = offset >> 4;\n\n    grp_quad_base_n = req_quad_base_n << 2;\n\n    reg_n = (offset - (req_quad_base_n << 4)) >> 2;\n\n\n\n    if (req_quad_base_n >= IIC_NGRP) {\n\n        hw_error(\"exynos4210.combiner: unallowed write access at offset 0x\"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        return;\n\n    }\n\n\n\n    if (reg_n > 1) {\n\n        hw_error(\"exynos4210.combiner: unallowed write access at offset 0x\"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        return;\n\n    }\n\n\n\n    if (offset >> 2 >= IIC_REGSET_SIZE) {\n\n        hw_error(\"exynos4210.combiner: overflow of reg_set by 0x\"\n\n                TARGET_FMT_plx \"offset\\n\", offset);\n\n    }\n\n    s->reg_set[offset >> 2] = val;\n\n\n\n    switch (reg_n) {\n\n    /* IIESR */\n\n    case 0:\n\n        /* FIXME: what if irq is pending, allowed by mask, and we allow it\n\n         * again. Interrupt will rise again! */\n\n\n\n        DPRINTF(\"%s enable IRQ for groups %d, %d, %d, %d\\n\",\n\n                s->external ? \"EXT\" : \"INT\",\n\n                grp_quad_base_n,\n\n                grp_quad_base_n + 1,\n\n                grp_quad_base_n + 2,\n\n                grp_quad_base_n + 3);\n\n\n\n        /* Enable interrupt sources */\n\n        s->group[grp_quad_base_n].src_mask |= val & 0xFF;\n\n        s->group[grp_quad_base_n + 1].src_mask |= (val & 0xFF00) >> 8;\n\n        s->group[grp_quad_base_n + 2].src_mask |= (val & 0xFF0000) >> 16;\n\n        s->group[grp_quad_base_n + 3].src_mask |= (val & 0xFF000000) >> 24;\n\n\n\n        exynos4210_combiner_update(s, grp_quad_base_n);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 1);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 2);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 3);\n\n        break;\n\n        /* IIECR */\n\n    case 1:\n\n        DPRINTF(\"%s disable IRQ for groups %d, %d, %d, %d\\n\",\n\n                s->external ? \"EXT\" : \"INT\",\n\n                grp_quad_base_n,\n\n                grp_quad_base_n + 1,\n\n                grp_quad_base_n + 2,\n\n                grp_quad_base_n + 3);\n\n\n\n        /* Disable interrupt sources */\n\n        s->group[grp_quad_base_n].src_mask &= ~(val & 0xFF);\n\n        s->group[grp_quad_base_n + 1].src_mask &= ~((val & 0xFF00) >> 8);\n\n        s->group[grp_quad_base_n + 2].src_mask &= ~((val & 0xFF0000) >> 16);\n\n        s->group[grp_quad_base_n + 3].src_mask &= ~((val & 0xFF000000) >> 24);\n\n\n\n        exynos4210_combiner_update(s, grp_quad_base_n);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 1);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 2);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 3);\n\n        break;\n\n    default:\n\n        hw_error(\"exynos4210.combiner: unallowed write access at offset 0x\"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        break;\n\n    }\n\n}\n", "idx": 20368, "_split": "test", "_hash": "9d701c804939ccf6d30d633c4dd70b19"}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void bt_submit_acl(struct HCIInfo *info,\n\n                const uint8_t *data, int length)\n\n{\n\n    struct bt_hci_s *hci = hci_from_info(info);\n\n    uint16_t handle;\n\n    int datalen, flags;\n\n    struct bt_link_s *link;\n\n\n\n    if (length < HCI_ACL_HDR_SIZE) {\n\n        fprintf(stderr, \"%s: ACL packet too short (%iB)\\n\",\n\n                        __FUNCTION__, length);\n\n        return;\n\n    }\n\n\n\n    handle = acl_handle((data[1] << 8) | data[0]);\n\n    flags = acl_flags((data[1] << 8) | data[0]);\n\n    datalen = (data[3] << 8) | data[2];\n\n    data += HCI_ACL_HDR_SIZE;\n\n    length -= HCI_ACL_HDR_SIZE;\n\n\n\n    if (bt_hci_handle_bad(hci, handle)) {\n\n        fprintf(stderr, \"%s: invalid ACL handle %03x\\n\",\n\n                        __FUNCTION__, handle);\n\n        /* TODO: signal an error */\n\n        return;\n\n    }\n\n    handle &= ~HCI_HANDLE_OFFSET;\n\n\n\n    if (datalen > length) {\n\n        fprintf(stderr, \"%s: ACL packet too short (%iB < %iB)\\n\",\n\n                        __FUNCTION__, length, datalen);\n\n        return;\n\n    }\n\n\n\n    link = hci->lm.handle[handle].link;\n\n\n\n    if ((flags & ~3) == ACL_ACTIVE_BCAST) {\n\n        if (!hci->asb_handle)\n\n            hci->asb_handle = handle;\n\n        else if (handle != hci->asb_handle) {\n\n            fprintf(stderr, \"%s: Bad handle %03x in Active Slave Broadcast\\n\",\n\n                            __FUNCTION__, handle);\n\n            /* TODO: signal an error */\n\n            return;\n\n        }\n\n\n\n        /* TODO */\n\n    }\n\n\n\n    if ((flags & ~3) == ACL_PICO_BCAST) {\n\n        if (!hci->psb_handle)\n\n            hci->psb_handle = handle;\n\n        else if (handle != hci->psb_handle) {\n\n            fprintf(stderr, \"%s: Bad handle %03x in Parked Slave Broadcast\\n\",\n\n                            __FUNCTION__, handle);\n\n            /* TODO: signal an error */\n\n            return;\n\n        }\n\n\n\n        /* TODO */\n\n    }\n\n\n\n    /* TODO: increase counter and send EVT_NUM_COMP_PKTS */\n\n    bt_hci_event_num_comp_pkts(hci, handle | HCI_HANDLE_OFFSET, 1);\n\n\n\n    /* Do this last as it can trigger further events even in this HCI */\n\n    hci->lm.handle[handle].lmp_acl_data(link, data,\n\n                    (flags & 3) == ACL_START, length);\n\n}\n", "idx": 20370, "_split": "test", "_hash": "79216ada23ac6f3ffac5b6bb936d2b75"}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static int nbd_co_flush(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n\n\n    return nbd_client_session_co_flush(&s->client);\n\n}\n", "idx": 20398, "_split": "test", "_hash": "a847bb34b1c6142e760515c5704b90df"}
{"project": "qemu", "commit_id": "581b9e29f36eec5de0779c3dbade980e4405d92e", "target": 0, "func": "static int qiov_is_aligned(QEMUIOVector *qiov)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < qiov->niov; i++) {\n\n        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 20410, "_split": "test", "_hash": "c2645441347e542e3ed731f8da11c354"}
{"project": "qemu", "commit_id": "b2b012afdd9c03ba8a1619f45301d34f358d367b", "target": 1, "func": "static ssize_t imx_fec_receive(NetClientState *nc, const uint8_t *buf,\n\n                               size_t len)\n\n{\n\n    IMXFECState *s = IMX_FEC(qemu_get_nic_opaque(nc));\n\n    IMXFECBufDesc bd;\n\n    uint32_t flags = 0;\n\n    uint32_t addr;\n\n    uint32_t crc;\n\n    uint32_t buf_addr;\n\n    uint8_t *crc_ptr;\n\n    unsigned int buf_len;\n\n    size_t size = len;\n\n\n\n    FEC_PRINTF(\"len %d\\n\", (int)size);\n\n\n\n    if (!s->regs[ENET_RDAR]) {\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"[%s]%s: Unexpected packet\\n\",\n\n                      TYPE_IMX_FEC, __func__);\n\n        return 0;\n\n    }\n\n\n\n    /* 4 bytes for the CRC.  */\n\n    size += 4;\n\n    crc = cpu_to_be32(crc32(~0, buf, size));\n\n    crc_ptr = (uint8_t *) &crc;\n\n\n\n    /* Huge frames are truncated.  */\n\n    if (size > ENET_MAX_FRAME_SIZE) {\n\n        size = ENET_MAX_FRAME_SIZE;\n\n        flags |= ENET_BD_TR | ENET_BD_LG;\n\n    }\n\n\n\n    /* Frames larger than the user limit just set error flags.  */\n\n    if (size > (s->regs[ENET_RCR] >> 16)) {\n\n        flags |= ENET_BD_LG;\n\n    }\n\n\n\n    addr = s->rx_descriptor;\n\n    while (size > 0) {\n\n        imx_fec_read_bd(&bd, addr);\n\n        if ((bd.flags & ENET_BD_E) == 0) {\n\n            /* No descriptors available.  Bail out.  */\n\n            /*\n\n             * FIXME: This is wrong. We should probably either\n\n             * save the remainder for when more RX buffers are\n\n             * available, or flag an error.\n\n             */\n\n            qemu_log_mask(LOG_GUEST_ERROR, \"[%s]%s: Lost end of frame\\n\",\n\n                          TYPE_IMX_FEC, __func__);\n\n            break;\n\n        }\n\n        buf_len = (size <= s->regs[ENET_MRBR]) ? size : s->regs[ENET_MRBR];\n\n        bd.length = buf_len;\n\n        size -= buf_len;\n\n\n\n        FEC_PRINTF(\"rx_bd 0x%x length %d\\n\", addr, bd.length);\n\n\n\n        /* The last 4 bytes are the CRC.  */\n\n        if (size < 4) {\n\n            buf_len += size - 4;\n\n        }\n\n        buf_addr = bd.data;\n\n        dma_memory_write(&address_space_memory, buf_addr, buf, buf_len);\n\n        buf += buf_len;\n\n        if (size < 4) {\n\n            dma_memory_write(&address_space_memory, buf_addr + buf_len,\n\n                             crc_ptr, 4 - size);\n\n            crc_ptr += 4 - size;\n\n        }\n\n        bd.flags &= ~ENET_BD_E;\n\n        if (size == 0) {\n\n            /* Last buffer in frame.  */\n\n            bd.flags |= flags | ENET_BD_L;\n\n            FEC_PRINTF(\"rx frame flags %04x\\n\", bd.flags);\n\n            s->regs[ENET_EIR] |= ENET_INT_RXF;\n\n        } else {\n\n            s->regs[ENET_EIR] |= ENET_INT_RXB;\n\n        }\n\n        imx_fec_write_bd(&bd, addr);\n\n        /* Advance to the next descriptor.  */\n\n        if ((bd.flags & ENET_BD_W) != 0) {\n\n            addr = s->regs[ENET_RDSR];\n\n        } else {\n\n            addr += sizeof(bd);\n\n        }\n\n    }\n\n    s->rx_descriptor = addr;\n\n    imx_eth_enable_rx(s);\n\n    imx_eth_update(s);\n\n    return len;\n\n}\n", "idx": 20425, "_split": "test", "_hash": "7886a570cc56f9900e0bf94ebca2e33f"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void breakpoint_handler(CPUState *env)\n\n{\n\n    CPUBreakpoint *bp;\n\n\n\n    if (env->watchpoint_hit) {\n\n        if (env->watchpoint_hit->flags & BP_CPU) {\n\n            env->watchpoint_hit = NULL;\n\n            if (check_hw_breakpoints(env, 0))\n\n                raise_exception(EXCP01_DB);\n\n            else\n\n                cpu_resume_from_signal(env, NULL);\n\n        }\n\n    } else {\n\n        TAILQ_FOREACH(bp, &env->breakpoints, entry)\n\n            if (bp->pc == env->eip) {\n\n                if (bp->flags & BP_CPU) {\n\n                    check_hw_breakpoints(env, 1);\n\n                    raise_exception(EXCP01_DB);\n\n                }\n\n                break;\n\n            }\n\n    }\n\n    if (prev_debug_excp_handler)\n\n        prev_debug_excp_handler(env);\n\n}\n", "idx": 20433, "_split": "test", "_hash": "adc959f344d490d59bbb4ac123709e03"}
{"project": "qemu", "commit_id": "2884cf5b934808f547b5268a51be631805c25857", "target": 0, "func": "static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,\n\n                                void *opaque)\n\n{\n\n    VirtualConsole *vc = opaque;\n\n    GtkDisplayState *s = vc->s;\n\n    InputButton btn;\n\n\n\n    /* implicitly grab the input at the first click in the relative mode */\n\n    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&\n\n        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {\n\n        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),\n\n                                       TRUE);\n\n        return TRUE;\n\n    }\n\n\n\n    if (button->button == 1) {\n\n        btn = INPUT_BUTTON_LEFT;\n\n    } else if (button->button == 2) {\n\n        btn = INPUT_BUTTON_MIDDLE;\n\n    } else if (button->button == 3) {\n\n        btn = INPUT_BUTTON_RIGHT;\n\n    } else {\n\n        return TRUE;\n\n    }\n\n\n\n    qemu_input_queue_btn(vc->gfx.dcl.con, btn,\n\n                         button->type == GDK_BUTTON_PRESS);\n\n    qemu_input_event_sync();\n\n    return TRUE;\n\n}\n", "idx": 20434, "_split": "test", "_hash": "9d0321407d57d0f0b8cb612075fe6aa4"}
{"project": "qemu", "commit_id": "86865c5ff16bd1a2ef2b9ce217a7bb8f39e2126c", "target": 1, "func": "static void _decode_opc(DisasContext * ctx)\n\n{\n\n    /* This code tries to make movcal emulation sufficiently\n\n       accurate for Linux purposes.  This instruction writes\n\n       memory, and prior to that, always allocates a cache line.\n\n       It is used in two contexts:\n\n       - in memcpy, where data is copied in blocks, the first write\n\n       of to a block uses movca.l for performance.\n\n       - in arch/sh/mm/cache-sh4.c, movcal.l + ocbi combination is used\n\n       to flush the cache. Here, the data written by movcal.l is never\n\n       written to memory, and the data written is just bogus.\n\n\n\n       To simulate this, we simulate movcal.l, we store the value to memory,\n\n       but we also remember the previous content. If we see ocbi, we check\n\n       if movcal.l for that address was done previously. If so, the write should\n\n       not have hit the memory, so we restore the previous content.\n\n       When we see an instruction that is neither movca.l\n\n       nor ocbi, the previous content is discarded.\n\n\n\n       To optimize, we only try to flush stores when we're at the start of\n\n       TB, or if we already saw movca.l in this TB and did not flush stores\n\n       yet.  */\n\n    if (ctx->has_movcal)\n\n\t{\n\n\t  int opcode = ctx->opcode & 0xf0ff;\n\n\t  if (opcode != 0x0093 /* ocbi */\n\n\t      && opcode != 0x00c3 /* movca.l */)\n\n\t      {\n\n\t\t  gen_helper_discard_movcal_backup ();\n\n\t\t  ctx->has_movcal = 0;\n\n\t      }\n\n\t}\n\n\n\n#if 0\n\n    fprintf(stderr, \"Translating opcode 0x%04x\\n\", ctx->opcode);\n\n#endif\n\n\n\n    switch (ctx->opcode) {\n\n    case 0x0019:\t\t/* div0u */\n\n\ttcg_gen_andi_i32(cpu_sr, cpu_sr, ~(SR_M | SR_Q | SR_T));\n\n\treturn;\n\n    case 0x000b:\t\t/* rts */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, cpu_pr);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0028:\t\t/* clrmac */\n\n\ttcg_gen_movi_i32(cpu_mach, 0);\n\n\ttcg_gen_movi_i32(cpu_macl, 0);\n\n\treturn;\n\n    case 0x0048:\t\t/* clrs */\n\n\ttcg_gen_andi_i32(cpu_sr, cpu_sr, ~SR_S);\n\n\treturn;\n\n    case 0x0008:\t\t/* clrt */\n\n\tgen_clr_t();\n\n\treturn;\n\n    case 0x0038:\t\t/* ldtlb */\n\n\tCHECK_PRIVILEGED\n\n\tgen_helper_ldtlb();\n\n\treturn;\n\n    case 0x002b:\t\t/* rte */\n\n\tCHECK_PRIVILEGED\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_sr, cpu_ssr);\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, cpu_spc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0058:\t\t/* sets */\n\n\ttcg_gen_ori_i32(cpu_sr, cpu_sr, SR_S);\n\n\treturn;\n\n    case 0x0018:\t\t/* sett */\n\n\tgen_set_t();\n\n\treturn;\n\n    case 0xfbfd:\t\t/* frchg */\n\n\ttcg_gen_xori_i32(cpu_fpscr, cpu_fpscr, FPSCR_FR);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0xf3fd:\t\t/* fschg */\n\n\ttcg_gen_xori_i32(cpu_fpscr, cpu_fpscr, FPSCR_SZ);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x0009:\t\t/* nop */\n\n\treturn;\n\n    case 0x001b:\t\t/* sleep */\n\n\tCHECK_PRIVILEGED\n\n\tgen_helper_sleep(tcg_const_i32(ctx->pc + 2));\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf000) {\n\n    case 0x1000:\t\t/* mov.l Rm,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B11_8), B3_0 * 4);\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x5000:\t\t/* mov.l @(disp,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 4);\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xe000:\t\t/* mov #imm,Rn */\n\n\ttcg_gen_movi_i32(REG(B11_8), B7_0s);\n\n\treturn;\n\n    case 0x9000:\t\t/* mov.w @(disp,PC),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_const_i32(ctx->pc + 4 + B7_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xd000:\t\t/* mov.l @(disp,PC),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_const_i32((ctx->pc + 4 + B7_0 * 4) & ~3);\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x7000:\t\t/* add #imm,Rn */\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), B7_0s);\n\n\treturn;\n\n    case 0xa000:\t\t/* bra disp */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tctx->delayed_pc = ctx->pc + 4 + B11_0s * 2;\n\n\ttcg_gen_movi_i32(cpu_delayed_pc, ctx->delayed_pc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\treturn;\n\n    case 0xb000:\t\t/* bsr disp */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\tctx->delayed_pc = ctx->pc + 4 + B11_0s * 2;\n\n\ttcg_gen_movi_i32(cpu_delayed_pc, ctx->delayed_pc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf00f) {\n\n    case 0x6003:\t\t/* mov Rm,Rn */\n\n\ttcg_gen_mov_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x2000:\t\t/* mov.b Rm,@Rn */\n\n\ttcg_gen_qemu_st8(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x2001:\t\t/* mov.w Rm,@Rn */\n\n\ttcg_gen_qemu_st16(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x2002:\t\t/* mov.l Rm,@Rn */\n\n\ttcg_gen_qemu_st32(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x6000:\t\t/* mov.b @Rm,Rn */\n\n\ttcg_gen_qemu_ld8s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x6001:\t\t/* mov.w @Rm,Rn */\n\n\ttcg_gen_qemu_ld16s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x6002:\t\t/* mov.l @Rm,Rn */\n\n\ttcg_gen_qemu_ld32s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x2004:\t\t/* mov.b Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 1);\n\n\t    tcg_gen_qemu_st8(REG(B7_4), addr, ctx->memidx);\t/* might cause re-execution */\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\t\t\t/* modify register status */\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x2005:\t\t/* mov.w Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 2);\n\n\t    tcg_gen_qemu_st16(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x2006:\t\t/* mov.l Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t}\n\n\treturn;\n\n    case 0x6004:\t\t/* mov.b @Rm+,Rn */\n\n\ttcg_gen_qemu_ld8s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 1);\n\n\treturn;\n\n    case 0x6005:\t\t/* mov.w @Rm+,Rn */\n\n\ttcg_gen_qemu_ld16s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 2);\n\n\treturn;\n\n    case 0x6006:\t\t/* mov.l @Rm+,Rn */\n\n\ttcg_gen_qemu_ld32s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\treturn;\n\n    case 0x0004:\t\t/* mov.b Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st8(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x0005:\t\t/* mov.w Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st16(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x0006:\t\t/* mov.l Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000c:\t\t/* mov.b @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld8s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000d:\t\t/* mov.w @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld16s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000e:\t\t/* mov.l @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x6008:\t\t/* swap.b Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(high, REG(B7_4), 0xffff0000);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(low, REG(B7_4));\n\n\t    tcg_gen_bswap16_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x6009:\t\t/* swap.w Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_shli_i32(high, REG(B7_4), 16);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_shri_i32(low, REG(B7_4), 16);\n\n\t    tcg_gen_ext16u_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x200d:\t\t/* xtrct Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_shli_i32(high, REG(B7_4), 16);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_shri_i32(low, REG(B11_8), 16);\n\n\t    tcg_gen_ext16u_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x300c:\t\t/* add Rm,Rn */\n\n\ttcg_gen_add_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x300e:\t\t/* addc Rm,Rn */\n\n\tgen_helper_addc(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300f:\t\t/* addv Rm,Rn */\n\n\tgen_helper_addv(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x2009:\t\t/* and Rm,Rn */\n\n\ttcg_gen_and_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x3000:\t\t/* cmp/eq Rm,Rn */\n\n\tgen_cmp(TCG_COND_EQ, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3003:\t\t/* cmp/ge Rm,Rn */\n\n\tgen_cmp(TCG_COND_GE, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3007:\t\t/* cmp/gt Rm,Rn */\n\n\tgen_cmp(TCG_COND_GT, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3006:\t\t/* cmp/hi Rm,Rn */\n\n\tgen_cmp(TCG_COND_GTU, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3002:\t\t/* cmp/hs Rm,Rn */\n\n\tgen_cmp(TCG_COND_GEU, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x200c:\t\t/* cmp/str Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    TCGv cmp1 = tcg_temp_local_new();\n\n\t    TCGv cmp2 = tcg_temp_local_new();\n\n\t    tcg_gen_xor_i32(cmp1, REG(B7_4), REG(B11_8));\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0xff000000);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x00ff0000);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x0000ff00);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x000000ff);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cpu_sr, cpu_sr, ~SR_T);\n\n\t    tcg_gen_br(label2);\n\n\t    gen_set_label(label1);\n\n\t    tcg_gen_ori_i32(cpu_sr, cpu_sr, SR_T);\n\n\t    gen_set_label(label2);\n\n\t    tcg_temp_free(cmp2);\n\n\t    tcg_temp_free(cmp1);\n\n\t}\n\n\treturn;\n\n    case 0x2007:\t\t/* div0s Rm,Rn */\n\n\t{\n\n\t    gen_copy_bit_i32(cpu_sr, 8, REG(B11_8), 31);\t/* SR_Q */\n\n\t    gen_copy_bit_i32(cpu_sr, 9, REG(B7_4), 31);\t\t/* SR_M */\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_xor_i32(val, REG(B7_4), REG(B11_8));\n\n\t    gen_copy_bit_i32(cpu_sr, 0, val, 31);\t\t/* SR_T */\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x3004:\t\t/* div1 Rm,Rn */\n\n\tgen_helper_div1(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300d:\t\t/* dmuls.l Rm,Rn */\n\n\t{\n\n\t    TCGv_i64 tmp1 = tcg_temp_new_i64();\n\n\t    TCGv_i64 tmp2 = tcg_temp_new_i64();\n\n\n\n\t    tcg_gen_ext_i32_i64(tmp1, REG(B7_4));\n\n\t    tcg_gen_ext_i32_i64(tmp2, REG(B11_8));\n\n\t    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n\n\t    tcg_gen_trunc_i64_i32(cpu_macl, tmp1);\n\n\t    tcg_gen_shri_i64(tmp1, tmp1, 32);\n\n\t    tcg_gen_trunc_i64_i32(cpu_mach, tmp1);\n\n\n\n\t    tcg_temp_free_i64(tmp2);\n\n\t    tcg_temp_free_i64(tmp1);\n\n\t}\n\n\treturn;\n\n    case 0x3005:\t\t/* dmulu.l Rm,Rn */\n\n\t{\n\n\t    TCGv_i64 tmp1 = tcg_temp_new_i64();\n\n\t    TCGv_i64 tmp2 = tcg_temp_new_i64();\n\n\n\n\t    tcg_gen_extu_i32_i64(tmp1, REG(B7_4));\n\n\t    tcg_gen_extu_i32_i64(tmp2, REG(B11_8));\n\n\t    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n\n\t    tcg_gen_trunc_i64_i32(cpu_macl, tmp1);\n\n\t    tcg_gen_shri_i64(tmp1, tmp1, 32);\n\n\t    tcg_gen_trunc_i64_i32(cpu_mach, tmp1);\n\n\n\n\t    tcg_temp_free_i64(tmp2);\n\n\t    tcg_temp_free_i64(tmp1);\n\n\t}\n\n\treturn;\n\n    case 0x600e:\t\t/* exts.b Rm,Rn */\n\n\ttcg_gen_ext8s_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600f:\t\t/* exts.w Rm,Rn */\n\n\ttcg_gen_ext16s_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600c:\t\t/* extu.b Rm,Rn */\n\n\ttcg_gen_ext8u_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600d:\t\t/* extu.w Rm,Rn */\n\n\ttcg_gen_ext16u_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x000f:\t\t/* mac.l @Rm+,@Rn+ */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg0, REG(B7_4), ctx->memidx);\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg1, REG(B11_8), ctx->memidx);\n\n\t    gen_helper_macl(arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t}\n\n\treturn;\n\n    case 0x400f:\t\t/* mac.w @Rm+,@Rn+ */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg0, REG(B7_4), ctx->memidx);\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg1, REG(B11_8), ctx->memidx);\n\n\t    gen_helper_macw(arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 2);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 2);\n\n\t}\n\n\treturn;\n\n    case 0x0007:\t\t/* mul.l Rm,Rn */\n\n\ttcg_gen_mul_i32(cpu_macl, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x200f:\t\t/* muls.w Rm,Rn */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_ext16s_i32(arg0, REG(B7_4));\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_ext16s_i32(arg1, REG(B11_8));\n\n\t    tcg_gen_mul_i32(cpu_macl, arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t}\n\n\treturn;\n\n    case 0x200e:\t\t/* mulu.w Rm,Rn */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(arg0, REG(B7_4));\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(arg1, REG(B11_8));\n\n\t    tcg_gen_mul_i32(cpu_macl, arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t}\n\n\treturn;\n\n    case 0x600b:\t\t/* neg Rm,Rn */\n\n\ttcg_gen_neg_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600a:\t\t/* negc Rm,Rn */\n\n\tgen_helper_negc(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x6007:\t\t/* not Rm,Rn */\n\n\ttcg_gen_not_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x200b:\t\t/* or Rm,Rn */\n\n\ttcg_gen_or_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x400c:\t\t/* shad Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    int label3 = gen_new_label();\n\n\t    int label4 = gen_new_label();\n\n\t    TCGv shift;\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B7_4), 0, label1);\n\n\t    /* Rm positive, shift to the left */\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_shl_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label4);\n\n\t    /* Rm negative, shift to the right */\n\n\t    gen_set_label(label1);\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, shift, 0, label2);\n\n\t    tcg_gen_not_i32(shift, REG(B7_4));\n\n\t    tcg_gen_andi_i32(shift, shift, 0x1f);\n\n\t    tcg_gen_addi_i32(shift, shift, 1);\n\n\t    tcg_gen_sar_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label4);\n\n\t    /* Rm = -32 */\n\n\t    gen_set_label(label2);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B11_8), 0, label3);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0);\n\n\t    tcg_gen_br(label4);\n\n\t    gen_set_label(label3);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0xffffffff);\n\n\t    gen_set_label(label4);\n\n\t}\n\n\treturn;\n\n    case 0x400d:\t\t/* shld Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    int label3 = gen_new_label();\n\n\t    TCGv shift;\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B7_4), 0, label1);\n\n\t    /* Rm positive, shift to the left */\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_shl_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label3);\n\n\t    /* Rm negative, shift to the right */\n\n\t    gen_set_label(label1);\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, shift, 0, label2);\n\n\t    tcg_gen_not_i32(shift, REG(B7_4));\n\n\t    tcg_gen_andi_i32(shift, shift, 0x1f);\n\n\t    tcg_gen_addi_i32(shift, shift, 1);\n\n\t    tcg_gen_shr_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label3);\n\n\t    /* Rm = -32 */\n\n\t    gen_set_label(label2);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0);\n\n\t    gen_set_label(label3);\n\n\t}\n\n\treturn;\n\n    case 0x3008:\t\t/* sub Rm,Rn */\n\n\ttcg_gen_sub_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x300a:\t\t/* subc Rm,Rn */\n\n\tgen_helper_subc(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300b:\t\t/* subv Rm,Rn */\n\n\tgen_helper_subv(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x2008:\t\t/* tst Rm,Rn */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_and_i32(val, REG(B7_4), REG(B11_8));\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x200a:\t\t/* xor Rm,Rn */\n\n\ttcg_gen_xor_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0xf00c: /* fmov {F,D,X}Rm,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, XREG(B7_4));\n\n\t    gen_store_fpr64(fp, XREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    tcg_gen_mov_i32(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n\t}\n\n\treturn;\n\n    case 0xf00a: /* fmov {F,D,X}Rm,@Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B7_4);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr  ], REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr+1], addr_hi,\t   ctx->memidx);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], REG(B11_8), ctx->memidx);\n\n\t}\n\n\treturn;\n\n    case 0xf008: /* fmov @Rm,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B11_8);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B7_4), 4);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr  ], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr_hi,   ctx->memidx);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], REG(B7_4), ctx->memidx);\n\n\t}\n\n\treturn;\n\n    case 0xf009: /* fmov @Rm+,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B11_8);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B7_4), 4);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr  ], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr_hi,   ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 8);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\t}\n\n\treturn;\n\n    case 0xf00b: /* fmov {F,D,X}Rm,@-Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr = tcg_temp_new_i32();\n\n\t    int fr = XREG(B7_4);\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    tcg_gen_subi_i32(addr, addr, 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr  ], addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t} else {\n\n\t    TCGv addr;\n\n\t    addr = tcg_temp_new_i32();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf006: /* fmov @(R0,Rm),{F,D,X}Rm - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new_i32();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    if (ctx->fpscr & FPSCR_SZ) {\n\n\t\tint fr = XREG(B11_8);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr\t ], addr, ctx->memidx);\n\n\t\ttcg_gen_addi_i32(addr, addr, 4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    } else {\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], addr, ctx->memidx);\n\n\t    }\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf007: /* fmov {F,D,X}Rn,@(R0,Rn) - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    if (ctx->fpscr & FPSCR_SZ) {\n\n\t\tint fr = XREG(B7_4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr\t ], addr, ctx->memidx);\n\n\t\ttcg_gen_addi_i32(addr, addr, 4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    } else {\n\n\t\ttcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], addr, ctx->memidx);\n\n\t    }\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf000: /* fadd Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf001: /* fsub Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf002: /* fmul Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf003: /* fdiv Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf004: /* fcmp/eq Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n    case 0xf005: /* fcmp/gt Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n\t{\n\n\t    CHECK_FPU_ENABLED\n\n\t    if (ctx->fpscr & FPSCR_PR) {\n\n                TCGv_i64 fp0, fp1;\n\n\n\n\t\tif (ctx->opcode & 0x0110)\n\n\t\t    break; /* illegal instruction */\n\n\t\tfp0 = tcg_temp_new_i64();\n\n\t\tfp1 = tcg_temp_new_i64();\n\n\t\tgen_load_fpr64(fp0, DREG(B11_8));\n\n\t\tgen_load_fpr64(fp1, DREG(B7_4));\n\n                switch (ctx->opcode & 0xf00f) {\n\n                case 0xf000:\t\t/* fadd Rm,Rn */\n\n                    gen_helper_fadd_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf001:\t\t/* fsub Rm,Rn */\n\n                    gen_helper_fsub_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf002:\t\t/* fmul Rm,Rn */\n\n                    gen_helper_fmul_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf003:\t\t/* fdiv Rm,Rn */\n\n                    gen_helper_fdiv_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf004:\t\t/* fcmp/eq Rm,Rn */\n\n                    gen_helper_fcmp_eq_DT(fp0, fp1);\n\n                    return;\n\n                case 0xf005:\t\t/* fcmp/gt Rm,Rn */\n\n                    gen_helper_fcmp_gt_DT(fp0, fp1);\n\n                    return;\n\n                }\n\n\t\tgen_store_fpr64(fp0, DREG(B11_8));\n\n                tcg_temp_free_i64(fp0);\n\n                tcg_temp_free_i64(fp1);\n\n\t    } else {\n\n                switch (ctx->opcode & 0xf00f) {\n\n                case 0xf000:\t\t/* fadd Rm,Rn */\n\n                    gen_helper_fadd_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf001:\t\t/* fsub Rm,Rn */\n\n                    gen_helper_fsub_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf002:\t\t/* fmul Rm,Rn */\n\n                    gen_helper_fmul_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf003:\t\t/* fdiv Rm,Rn */\n\n                    gen_helper_fdiv_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf004:\t\t/* fcmp/eq Rm,Rn */\n\n                    gen_helper_fcmp_eq_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    return;\n\n                case 0xf005:\t\t/* fcmp/gt Rm,Rn */\n\n                    gen_helper_fcmp_gt_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    return;\n\n                }\n\n\t    }\n\n\t}\n\n\treturn;\n\n    case 0xf00e: /* fmac FR0,RM,Rn */\n\n        {\n\n            CHECK_FPU_ENABLED\n\n            if (ctx->fpscr & FPSCR_PR) {\n\n                break; /* illegal instruction */\n\n            } else {\n\n                gen_helper_fmac_FT(cpu_fregs[FREG(B11_8)],\n\n                                   cpu_fregs[FREG(0)], cpu_fregs[FREG(B7_4)], cpu_fregs[FREG(B11_8)]);\n\n                return;\n\n            }\n\n        }\n\n    }\n\n\n\n    switch (ctx->opcode & 0xff00) {\n\n    case 0xc900:\t\t/* and #imm,R0 */\n\n\ttcg_gen_andi_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xcd00:\t\t/* and.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_andi_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8b00:\t\t/* bf label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\t    gen_conditional_jump(ctx, ctx->pc + 2,\n\n\t\t\t\t ctx->pc + 4 + B7_0s * 2);\n\n\tctx->bstate = BS_BRANCH;\n\n\treturn;\n\n    case 0x8f00:\t\t/* bf/s label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tgen_branch_slot(ctx->delayed_pc = ctx->pc + 4 + B7_0s * 2, 0);\n\n\tctx->flags |= DELAY_SLOT_CONDITIONAL;\n\n\treturn;\n\n    case 0x8900:\t\t/* bt label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\t    gen_conditional_jump(ctx, ctx->pc + 4 + B7_0s * 2,\n\n\t\t\t\t ctx->pc + 2);\n\n\tctx->bstate = BS_BRANCH;\n\n\treturn;\n\n    case 0x8d00:\t\t/* bt/s label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tgen_branch_slot(ctx->delayed_pc = ctx->pc + 4 + B7_0s * 2, 1);\n\n\tctx->flags |= DELAY_SLOT_CONDITIONAL;\n\n\treturn;\n\n    case 0x8800:\t\t/* cmp/eq #imm,R0 */\n\n\tgen_cmp_imm(TCG_COND_EQ, REG(0), B7_0s);\n\n\treturn;\n\n    case 0xc400:\t\t/* mov.b @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0);\n\n\t    tcg_gen_qemu_ld8s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc500:\t\t/* mov.w @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc600:\t\t/* mov.l @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 4);\n\n\t    tcg_gen_qemu_ld32s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc000:\t\t/* mov.b R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0);\n\n\t    tcg_gen_qemu_st8(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc100:\t\t/* mov.w R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 2);\n\n\t    tcg_gen_qemu_st16(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc200:\t\t/* mov.l R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 4);\n\n\t    tcg_gen_qemu_st32(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8000:\t\t/* mov.b R0,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0);\n\n\t    tcg_gen_qemu_st8(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8100:\t\t/* mov.w R0,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 2);\n\n\t    tcg_gen_qemu_st16(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8400:\t\t/* mov.b @(disp,Rn),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0);\n\n\t    tcg_gen_qemu_ld8s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8500:\t\t/* mov.w @(disp,Rn),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc700:\t\t/* mova @(disp,PC),R0 */\n\n\ttcg_gen_movi_i32(REG(0), ((ctx->pc & 0xfffffffc) + 4 + B7_0 * 4) & ~3);\n\n\treturn;\n\n    case 0xcb00:\t\t/* or #imm,R0 */\n\n\ttcg_gen_ori_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xcf00:\t\t/* or.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_ori_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc300:\t\t/* trapa #imm */\n\n\t{\n\n\t    TCGv imm;\n\n\t    CHECK_NOT_DELAY_SLOT\n\n\t    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n\t    imm = tcg_const_i32(B7_0);\n\n\t    gen_helper_trapa(imm);\n\n\t    tcg_temp_free(imm);\n\n\t    ctx->bstate = BS_BRANCH;\n\n\t}\n\n\treturn;\n\n    case 0xc800:\t\t/* tst #imm,R0 */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(val, REG(0), B7_0);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0xcc00:\t\t/* tst.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_add_i32(val, REG(0), cpu_gbr);\n\n\t    tcg_gen_qemu_ld8u(val, val, ctx->memidx);\n\n\t    tcg_gen_andi_i32(val, val, B7_0);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0xca00:\t\t/* xor #imm,R0 */\n\n\ttcg_gen_xori_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xce00:\t\t/* xor.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_xori_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf08f) {\n\n    case 0x408e:\t\t/* ldc Rm,Rn_BANK */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(ALTREG(B6_4), REG(B11_8));\n\n\treturn;\n\n    case 0x4087:\t\t/* ldc.l @Rm+,Rn_BANK */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_qemu_ld32s(ALTREG(B6_4), REG(B11_8), ctx->memidx);\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\treturn;\n\n    case 0x0082:\t\t/* stc Rm_BANK,Rn */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(REG(B11_8), ALTREG(B6_4));\n\n\treturn;\n\n    case 0x4083:\t\t/* stc.l Rm_BANK,@-Rn */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(ALTREG(B6_4), addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf0ff) {\n\n    case 0x0023:\t\t/* braf Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_addi_i32(cpu_delayed_pc, REG(B11_8), ctx->pc + 4);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0003:\t\t/* bsrf Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\ttcg_gen_add_i32(cpu_delayed_pc, REG(B11_8), cpu_pr);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x4015:\t\t/* cmp/pl Rn */\n\n\tgen_cmp_imm(TCG_COND_GT, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x4011:\t\t/* cmp/pz Rn */\n\n\tgen_cmp_imm(TCG_COND_GE, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x4010:\t\t/* dt Rn */\n\n\ttcg_gen_subi_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_cmp_imm(TCG_COND_EQ, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x402b:\t\t/* jmp @Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, REG(B11_8));\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x400b:\t\t/* jsr @Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, REG(B11_8));\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x400e:\t\t/* ldc Rm,SR */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_andi_i32(cpu_sr, REG(B11_8), 0x700083f3);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x4007:\t\t/* ldc.l @Rm+,SR */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(val, REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_andi_i32(cpu_sr, val, 0x700083f3);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t    ctx->bstate = BS_STOP;\n\n\t}\n\n\treturn;\n\n    case 0x0002:\t\t/* stc SR,Rn */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(REG(B11_8), cpu_sr);\n\n\treturn;\n\n    case 0x4003:\t\t/* stc SR,@-Rn */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_sr, addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n#define LD(reg,ldnum,ldpnum,prechk)\t\t\\\n\n  case ldnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_mov_i32 (cpu_##reg, REG(B11_8));\t\t\t\\\n\n    return;\t\t\t\t\t\t\t\\\n\n  case ldpnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_qemu_ld32s (cpu_##reg, REG(B11_8), ctx->memidx);\t\\\n\n    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\t\t\\\n\n    return;\n\n#define ST(reg,stnum,stpnum,prechk)\t\t\\\n\n  case stnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_mov_i32 (REG(B11_8), cpu_##reg);\t\t\t\\\n\n    return;\t\t\t\t\t\t\t\\\n\n  case stpnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    {\t\t\t\t\t\t\t\t\\\n\n\tTCGv addr = tcg_temp_new();\t\t\t\t\\\n\n\ttcg_gen_subi_i32(addr, REG(B11_8), 4);\t\t\t\\\n\n\ttcg_gen_qemu_st32 (cpu_##reg, addr, ctx->memidx);\t\\\n\n\ttcg_gen_mov_i32(REG(B11_8), addr);\t\t\t\\\n\n\ttcg_temp_free(addr);\t\t\t\t\t\\\n\n    }\t\t\t\t\t\t\t\t\\\n\n    return;\n\n#define LDST(reg,ldnum,ldpnum,stnum,stpnum,prechk)\t\t\\\n\n\tLD(reg,ldnum,ldpnum,prechk)\t\t\t\t\\\n\n\tST(reg,stnum,stpnum,prechk)\n\n\tLDST(gbr,  0x401e, 0x4017, 0x0012, 0x4013, {})\n\n\tLDST(vbr,  0x402e, 0x4027, 0x0022, 0x4023, CHECK_PRIVILEGED)\n\n\tLDST(ssr,  0x403e, 0x4037, 0x0032, 0x4033, CHECK_PRIVILEGED)\n\n\tLDST(spc,  0x404e, 0x4047, 0x0042, 0x4043, CHECK_PRIVILEGED)\n\n\tST(sgr,  0x003a, 0x4032, CHECK_PRIVILEGED)\n\n\tLD(sgr,  0x403a, 0x4036, CHECK_PRIVILEGED if (!(ctx->features & SH_FEATURE_SH4A)) break;)\n\n\tLDST(dbr,  0x40fa, 0x40f6, 0x00fa, 0x40f2, CHECK_PRIVILEGED)\n\n\tLDST(mach, 0x400a, 0x4006, 0x000a, 0x4002, {})\n\n\tLDST(macl, 0x401a, 0x4016, 0x001a, 0x4012, {})\n\n\tLDST(pr,   0x402a, 0x4026, 0x002a, 0x4022, {})\n\n\tLDST(fpul, 0x405a, 0x4056, 0x005a, 0x4052, {CHECK_FPU_ENABLED})\n\n    case 0x406a:\t\t/* lds Rm,FPSCR */\n\n\tCHECK_FPU_ENABLED\n\n\tgen_helper_ld_fpscr(REG(B11_8));\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x4066:\t\t/* lds.l @Rm+,FPSCR */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(addr, REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t    gen_helper_ld_fpscr(addr);\n\n\t    tcg_temp_free(addr);\n\n\t    ctx->bstate = BS_STOP;\n\n\t}\n\n\treturn;\n\n    case 0x006a:\t\t/* sts FPSCR,Rn */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_andi_i32(REG(B11_8), cpu_fpscr, 0x003fffff);\n\n\treturn;\n\n    case 0x4062:\t\t/* sts FPSCR,@-Rn */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(val, cpu_fpscr, 0x003fffff);\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(val, addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x00c3:\t\t/* movca.l R0,@Rm */\n\n        {\n\n            TCGv val = tcg_temp_new();\n\n            tcg_gen_qemu_ld32u(val, REG(B11_8), ctx->memidx);\n\n            gen_helper_movcal (REG(B11_8), val);            \n\n            tcg_gen_qemu_st32(REG(0), REG(B11_8), ctx->memidx);\n\n        }\n\n        ctx->has_movcal = 1;\n\n\treturn;\n\n    case 0x40a9:\n\n\t/* MOVUA.L @Rm,R0 (Rm) -> R0\n\n\t   Load non-boundary-aligned data */\n\n\ttcg_gen_qemu_ld32u(REG(0), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x40e9:\n\n\t/* MOVUA.L @Rm+,R0   (Rm) -> R0, Rm + 4 -> Rm\n\n\t   Load non-boundary-aligned data */\n\n\ttcg_gen_qemu_ld32u(REG(0), REG(B11_8), ctx->memidx);\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\treturn;\n\n    case 0x0029:\t\t/* movt Rn */\n\n\ttcg_gen_andi_i32(REG(B11_8), cpu_sr, SR_T);\n\n\treturn;\n\n    case 0x0073:\n\n        /* MOVCO.L\n\n\t       LDST -> T\n\n               If (T == 1) R0 -> (Rn)\n\n               0 -> LDST\n\n        */\n\n        if (ctx->features & SH_FEATURE_SH4A) {\n\n\t    int label = gen_new_label();\n\n\t    gen_clr_t();\n\n\t    tcg_gen_or_i32(cpu_sr, cpu_sr, cpu_ldst);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cpu_ldst, 0, label);\n\n\t    tcg_gen_qemu_st32(REG(0), REG(B11_8), ctx->memidx);\n\n\t    gen_set_label(label);\n\n\t    tcg_gen_movi_i32(cpu_ldst, 0);\n\n\t    return;\n\n\t} else\n\n\t    break;\n\n    case 0x0063:\n\n        /* MOVLI.L @Rm,R0\n\n               1 -> LDST\n\n               (Rm) -> R0\n\n               When interrupt/exception\n\n               occurred 0 -> LDST\n\n        */\n\n\tif (ctx->features & SH_FEATURE_SH4A) {\n\n\t    tcg_gen_movi_i32(cpu_ldst, 0);\n\n\t    tcg_gen_qemu_ld32s(REG(0), REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_movi_i32(cpu_ldst, 1);\n\n\t    return;\n\n\t} else\n\n\t    break;\n\n    case 0x0093:\t\t/* ocbi @Rn */\n\n\t{\n\n\t    gen_helper_ocbi (REG(B11_8));\n\n\t}\n\n\treturn;\n\n    case 0x00a3:\t\t/* ocbp @Rn */\n\n\t{\n\n\t    TCGv dummy = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);\n\n\t    tcg_temp_free(dummy);\n\n\t}\n\n\treturn;\n\n    case 0x00b3:\t\t/* ocbwb @Rn */\n\n\t{\n\n\t    TCGv dummy = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);\n\n\t    tcg_temp_free(dummy);\n\n\t}\n\n\treturn;\n\n    case 0x0083:\t\t/* pref @Rn */\n\n\treturn;\n\n    case 0x00d3:\t\t/* prefi @Rn */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x00e3:\t\t/* icbi @Rn */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x00ab:\t\t/* synco */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x4024:\t\t/* rotcl Rn */\n\n\t{\n\n\t    TCGv tmp = tcg_temp_new();\n\n\t    tcg_gen_mov_i32(tmp, cpu_sr);\n\n\t    gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\t    tcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\t    gen_copy_bit_i32(REG(B11_8), 0, tmp, 0);\n\n\t    tcg_temp_free(tmp);\n\n\t}\n\n\treturn;\n\n    case 0x4025:\t\t/* rotcr Rn */\n\n\t{\n\n\t    TCGv tmp = tcg_temp_new();\n\n\t    tcg_gen_mov_i32(tmp, cpu_sr);\n\n\t    gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\t    tcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\t    gen_copy_bit_i32(REG(B11_8), 31, tmp, 0);\n\n\t    tcg_temp_free(tmp);\n\n\t}\n\n\treturn;\n\n    case 0x4004:\t\t/* rotl Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_copy_bit_i32(REG(B11_8), 0, cpu_sr, 0);\n\n\treturn;\n\n    case 0x4005:\t\t/* rotr Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_copy_bit_i32(REG(B11_8), 31, cpu_sr, 0);\n\n\treturn;\n\n    case 0x4000:\t\t/* shll Rn */\n\n    case 0x4020:\t\t/* shal Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4021:\t\t/* shar Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_sari_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4001:\t\t/* shlr Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4008:\t\t/* shll2 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 2);\n\n\treturn;\n\n    case 0x4018:\t\t/* shll8 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 8);\n\n\treturn;\n\n    case 0x4028:\t\t/* shll16 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 16);\n\n\treturn;\n\n    case 0x4009:\t\t/* shlr2 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 2);\n\n\treturn;\n\n    case 0x4019:\t\t/* shlr8 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 8);\n\n\treturn;\n\n    case 0x4029:\t\t/* shlr16 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 16);\n\n\treturn;\n\n    case 0x401b:\t\t/* tas.b @Rn */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_local_new();\n\n\t    tcg_gen_mov_i32(addr, REG(B11_8));\n\n\t    val = tcg_temp_local_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_gen_ori_i32(val, val, 0x80);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf00d: /* fsts FPUL,FRn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_mov_i32(cpu_fregs[FREG(B11_8)], cpu_fpul);\n\n\treturn;\n\n    case 0xf01d: /* flds FRm,FPUL - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_mov_i32(cpu_fpul, cpu_fregs[FREG(B11_8)]);\n\n\treturn;\n\n    case 0xf02d: /* float FPUL,FRn/DRn - FPSCR: R[PR,Enable.I]/W[Cause,Flag] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    TCGv_i64 fp;\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    fp = tcg_temp_new_i64();\n\n\t    gen_helper_float_DT(fp, cpu_fpul);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\telse {\n\n\t    gen_helper_float_FT(cpu_fregs[FREG(B11_8)], cpu_fpul);\n\n\t}\n\n\treturn;\n\n    case 0xf03d: /* ftrc FRm/DRm,FPUL - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    TCGv_i64 fp;\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_ftrc_DT(cpu_fpul, fp);\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\telse {\n\n\t    gen_helper_ftrc_FT(cpu_fpul, cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf04d: /* fneg FRn/DRn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    gen_helper_fneg_T(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf05d: /* fabs FRn/DRn */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fabs_DT(fp, fp);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    gen_helper_fabs_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf06d: /* fsqrt FRn */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fsqrt_DT(fp, fp);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    gen_helper_fsqrt_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf07d: /* fsrra FRn */\n\n\tCHECK_FPU_ENABLED\n\n\tbreak;\n\n    case 0xf08d: /* fldi0 FRn - FPSCR: R[PR] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (!(ctx->fpscr & FPSCR_PR)) {\n\n\t    tcg_gen_movi_i32(cpu_fregs[FREG(B11_8)], 0);\n\n\t}\n\n\treturn;\n\n    case 0xf09d: /* fldi1 FRn - FPSCR: R[PR] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (!(ctx->fpscr & FPSCR_PR)) {\n\n\t    tcg_gen_movi_i32(cpu_fregs[FREG(B11_8)], 0x3f800000);\n\n\t}\n\n\treturn;\n\n    case 0xf0ad: /* fcnvsd FPUL,DRn */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_helper_fcnvsd_FT_DT(fp, cpu_fpul);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\treturn;\n\n    case 0xf0bd: /* fcnvds DRn,FPUL */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fcnvds_DT_FT(cpu_fpul, fp);\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\treturn;\n\n    }\n\n#if 0\n\n    fprintf(stderr, \"unknown instruction 0x%04x at pc 0x%08x\\n\",\n\n\t    ctx->opcode, ctx->pc);\n\n    fflush(stderr);\n\n#endif\n\n    gen_helper_raise_illegal_instruction();\n\n    ctx->bstate = BS_EXCP;\n\n}\n", "idx": 20467, "_split": "test", "_hash": "ee687e4fc78f0948c753487b3bdea8b7"}
{"project": "qemu", "commit_id": "b0f74c87a1dbd6b0c5e4de7f1c5cb40197e3fbe9", "target": 1, "func": "void wm8750_set_bclk_in(void *opaque, int hz)\n\n{\n\n    struct wm8750_s *s = (struct wm8750_s *) opaque;\n\n\n\n    s->ext_adc_hz = hz;\n\n    s->ext_dac_hz = hz;\n\n    wm8750_clk_update(s, 1);\n\n}\n", "idx": 20471, "_split": "test", "_hash": "daafb1c8a5349c0b16202ff89f23322a"}
{"project": "qemu", "commit_id": "ac58fe7b2c67a9be142beacd4c6ee51f3264d90f", "target": 1, "func": "static void pmac_dma_write(BlockBackend *blk,\n\n                         int64_t sector_num, int nb_sectors,\n\n                         void (*cb)(void *opaque, int ret), void *opaque)\n\n{\n\n    DBDMA_io *io = opaque;\n\n    MACIOIDEState *m = io->opaque;\n\n    IDEState *s = idebus_active_if(&m->bus);\n\n    dma_addr_t dma_addr, dma_len;\n\n    void *mem;\n\n    int nsector, remainder;\n\n    int extra = 0;\n\n\n\n    qemu_iovec_destroy(&io->iov);\n\n    qemu_iovec_init(&io->iov, io->len / MACIO_PAGE_SIZE + 1);\n\n\n\n    if (io->remainder_len > 0) {\n\n        /* Return remainder of request */\n\n        int transfer = MIN(io->remainder_len, io->len);\n\n\n\n        MACIO_DPRINTF(\"--- processing write remainder %x\\n\", transfer);\n\n        cpu_physical_memory_read(io->addr,\n\n                                 &io->remainder + (0x200 - transfer),\n\n                                 transfer);\n\n\n\n        io->remainder_len -= transfer;\n\n        io->len -= transfer;\n\n        io->addr += transfer;\n\n\n\n        s->io_buffer_index += transfer;\n\n        s->io_buffer_size -= transfer;\n\n\n\n        if (io->remainder_len != 0) {\n\n            /* Still waiting for remainder */\n\n            return;\n\n        }\n\n\n\n        MACIO_DPRINTF(\"--> prepending bounce buffer with size 0x200\\n\");\n\n\n\n        /* Sector transfer complete - prepend to request */\n\n        qemu_iovec_add(&io->iov, &io->remainder, 0x200);\n\n        extra = 1;\n\n    }\n\n\n\n    if (s->drive_kind == IDE_CD) {\n\n        sector_num = (int64_t)(s->lba << 2) + (s->io_buffer_index >> 9);\n\n    } else {\n\n        sector_num = ide_get_sector(s) + (s->io_buffer_index >> 9);\n\n    }\n\n\n\n    nsector = (io->len >> 9);\n\n    remainder = io->len - (nsector << 9);\n\n\n\n    MACIO_DPRINTF(\"--- DMA write transfer - addr: %\" HWADDR_PRIx \" len: %x\\n\",\n\n                  io->addr, io->len);\n\n    MACIO_DPRINTF(\"xxx remainder: %x\\n\", remainder);\n\n    MACIO_DPRINTF(\"xxx sector_num: %\"PRIx64\"   nsector: %x\\n\",\n\n                  sector_num, nsector);\n\n\n\n    dma_addr = io->addr;\n\n    dma_len = io->len;\n\n    mem = dma_memory_map(&address_space_memory, dma_addr, &dma_len,\n\n                         DMA_DIRECTION_TO_DEVICE);\n\n\n\n    if (!remainder) {\n\n        MACIO_DPRINTF(\"--- DMA write aligned - addr: %\" HWADDR_PRIx\n\n                      \" len: %x\\n\", io->addr, io->len);\n\n        qemu_iovec_add(&io->iov, mem, io->len);\n\n    } else {\n\n        /* Write up to last complete sector */\n\n        MACIO_DPRINTF(\"--- DMA write unaligned - addr: %\" HWADDR_PRIx\n\n                      \" len: %x\\n\", io->addr, (nsector << 9));\n\n        qemu_iovec_add(&io->iov, mem, (nsector << 9));\n\n\n\n        MACIO_DPRINTF(\"--- DMA write read    - bounce addr: %p \"\n\n                      \"remainder_len: %x\\n\", &io->remainder, remainder);\n\n        cpu_physical_memory_read(io->addr + (nsector << 9), &io->remainder,\n\n                                 remainder);\n\n\n\n        io->remainder_len = 0x200 - remainder;\n\n\n\n        MACIO_DPRINTF(\"xxx remainder_len: %x\\n\", io->remainder_len);\n\n    }\n\n\n\n    s->io_buffer_size -= ((nsector + extra) << 9);\n\n    s->io_buffer_index += ((nsector + extra) << 9);\n\n\n\n    io->len = 0;\n\n\n\n    MACIO_DPRINTF(\"--- Block write transfer   - sector_num: %\"PRIx64\"  \"\n\n                  \"nsector: %x\\n\", sector_num, nsector + extra);\n\n\n\n    m->aiocb = blk_aio_writev(blk, sector_num, &io->iov, nsector + extra, cb,\n\n                              io);\n\n}\n", "idx": 20480, "_split": "test", "_hash": "879aac7d8796c11054ba844c72ee1ddc"}
{"project": "qemu", "commit_id": "c5acdc9ab4e6aa9b05e6242114479333b15d496b", "target": 0, "func": "static void bdrv_delete(BlockDriverState *bs)\n\n{\n\n    assert(!bs->job);\n\n    assert(bdrv_op_blocker_is_empty(bs));\n\n    assert(!bs->refcnt);\n\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n\n\n    bdrv_close(bs);\n\n\n\n    /* remove from list, if necessary */\n\n    bdrv_make_anon(bs);\n\n\n\n    g_free(bs);\n\n}\n", "idx": 20485, "_split": "test", "_hash": "a5f4cfeed5ecabd45a6d520c44d0f1d2"}
{"project": "qemu", "commit_id": "37f51384ae05bd50f83308339dbffa3e78404874", "target": 0, "func": "static void vtd_iommu_replay(IOMMUMemoryRegion *iommu_mr, IOMMUNotifier *n)\n\n{\n\n    VTDAddressSpace *vtd_as = container_of(iommu_mr, VTDAddressSpace, iommu);\n\n    IntelIOMMUState *s = vtd_as->iommu_state;\n\n    uint8_t bus_n = pci_bus_num(vtd_as->bus);\n\n    VTDContextEntry ce;\n\n\n\n    /*\n\n     * The replay can be triggered by either a invalidation or a newly\n\n     * created entry. No matter what, we release existing mappings\n\n     * (it means flushing caches for UNMAP-only registers).\n\n     */\n\n    vtd_address_space_unmap(vtd_as, n);\n\n\n\n    if (vtd_dev_to_context_entry(s, bus_n, vtd_as->devfn, &ce) == 0) {\n\n        trace_vtd_replay_ce_valid(bus_n, PCI_SLOT(vtd_as->devfn),\n\n                                  PCI_FUNC(vtd_as->devfn),\n\n                                  VTD_CONTEXT_ENTRY_DID(ce.hi),\n\n                                  ce.hi, ce.lo);\n\n        vtd_page_walk(&ce, 0, ~0ULL, vtd_replay_hook, (void *)n, false);\n\n    } else {\n\n        trace_vtd_replay_ce_invalid(bus_n, PCI_SLOT(vtd_as->devfn),\n\n                                    PCI_FUNC(vtd_as->devfn));\n\n    }\n\n\n\n    return;\n\n}\n", "idx": 20495, "_split": "test", "_hash": "72b5e41a74049805f25fa08f8bfbb3b5"}
{"project": "qemu", "commit_id": "a9c0183059d6a4e4d940cd86ac0f9402b0655d24", "target": 0, "func": "static inline int sd_wp_addr(SDState *sd, uint32_t addr)\n\n{\n\n    return sd->wp_groups[addr >>\n\n            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];\n\n}\n", "idx": 20507, "_split": "test", "_hash": "a5c07773284fa0ef1392a97e66a6893a"}
{"project": "qemu", "commit_id": "4083733db5e4120939acee57019ff52db1f45b9d", "target": 0, "func": "static void console_handle_escape(QemuConsole *s)\n\n{\n\n    int i;\n\n\n\n    for (i=0; i<s->nb_esc_params; i++) {\n\n        switch (s->esc_params[i]) {\n\n            case 0: /* reset all console attributes to default */\n\n                s->t_attrib = s->t_attrib_default;\n\n                break;\n\n            case 1:\n\n                s->t_attrib.bold = 1;\n\n                break;\n\n            case 4:\n\n                s->t_attrib.uline = 1;\n\n                break;\n\n            case 5:\n\n                s->t_attrib.blink = 1;\n\n                break;\n\n            case 7:\n\n                s->t_attrib.invers = 1;\n\n                break;\n\n            case 8:\n\n                s->t_attrib.unvisible = 1;\n\n                break;\n\n            case 22:\n\n                s->t_attrib.bold = 0;\n\n                break;\n\n            case 24:\n\n                s->t_attrib.uline = 0;\n\n                break;\n\n            case 25:\n\n                s->t_attrib.blink = 0;\n\n                break;\n\n            case 27:\n\n                s->t_attrib.invers = 0;\n\n                break;\n\n            case 28:\n\n                s->t_attrib.unvisible = 0;\n\n                break;\n\n            /* set foreground color */\n\n            case 30:\n\n                s->t_attrib.fgcol=COLOR_BLACK;\n\n                break;\n\n            case 31:\n\n                s->t_attrib.fgcol=COLOR_RED;\n\n                break;\n\n            case 32:\n\n                s->t_attrib.fgcol=COLOR_GREEN;\n\n                break;\n\n            case 33:\n\n                s->t_attrib.fgcol=COLOR_YELLOW;\n\n                break;\n\n            case 34:\n\n                s->t_attrib.fgcol=COLOR_BLUE;\n\n                break;\n\n            case 35:\n\n                s->t_attrib.fgcol=COLOR_MAGENTA;\n\n                break;\n\n            case 36:\n\n                s->t_attrib.fgcol=COLOR_CYAN;\n\n                break;\n\n            case 37:\n\n                s->t_attrib.fgcol=COLOR_WHITE;\n\n                break;\n\n            /* set background color */\n\n            case 40:\n\n                s->t_attrib.bgcol=COLOR_BLACK;\n\n                break;\n\n            case 41:\n\n                s->t_attrib.bgcol=COLOR_RED;\n\n                break;\n\n            case 42:\n\n                s->t_attrib.bgcol=COLOR_GREEN;\n\n                break;\n\n            case 43:\n\n                s->t_attrib.bgcol=COLOR_YELLOW;\n\n                break;\n\n            case 44:\n\n                s->t_attrib.bgcol=COLOR_BLUE;\n\n                break;\n\n            case 45:\n\n                s->t_attrib.bgcol=COLOR_MAGENTA;\n\n                break;\n\n            case 46:\n\n                s->t_attrib.bgcol=COLOR_CYAN;\n\n                break;\n\n            case 47:\n\n                s->t_attrib.bgcol=COLOR_WHITE;\n\n                break;\n\n        }\n\n    }\n\n}\n", "idx": 20518, "_split": "test", "_hash": "5b8db9ed66ef580de3c0e552df9b49c1"}
{"project": "qemu", "commit_id": "90e496386fe7fd32c189561f846b7913f95b8cf4", "target": 0, "func": "static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,\n\n                              int element, TCGMemOp memop)\n\n{\n\n    int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);\n\n    switch (memop) {\n\n    case MO_8:\n\n        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_16:\n\n        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_32:\n\n        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_64:\n\n        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n}\n", "idx": 20520, "_split": "test", "_hash": "aaae8833da81fe79ef6f511a84909510"}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static always_inline void gen_ext_h(void (*tcg_gen_ext_i64)(TCGv t0, TCGv t1),\n\n                                    int ra, int rb, int rc,\n\n                                    int islit, uint8_t lit)\n\n{\n\n    if (unlikely(rc == 31))\n\n        return;\n\n\n\n    if (ra != 31) {\n\n        if (islit) {\n\n            if (lit != 0)\n\n                tcg_gen_shli_i64(cpu_ir[rc], cpu_ir[ra], 64 - ((lit & 7) * 8));\n\n            else\n\n                tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[ra]);\n\n        } else {\n\n            TCGv tmp1, tmp2;\n\n            tmp1 = tcg_temp_new(TCG_TYPE_I64);\n\n            tcg_gen_andi_i64(tmp1, cpu_ir[rb], 7);\n\n            tcg_gen_shli_i64(tmp1, tmp1, 3);\n\n            tmp2 = tcg_const_i64(64);\n\n            tcg_gen_sub_i64(tmp1, tmp2, tmp1);\n\n            tcg_temp_free(tmp2);\n\n            tcg_gen_shl_i64(cpu_ir[rc], cpu_ir[ra], tmp1);\n\n            tcg_temp_free(tmp1);\n\n        }\n\n        if (tcg_gen_ext_i64)\n\n            tcg_gen_ext_i64(cpu_ir[rc], cpu_ir[rc]);\n\n    } else\n\n        tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n}\n", "idx": 20531, "_split": "test", "_hash": "b8a2368ac38ce60e20be218473d33583"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    LSIState *s = opaque;\n\n\n\n    return lsi_reg_readb(s, addr & 0xff);\n\n}\n", "idx": 20548, "_split": "test", "_hash": "b09053041b6d1494374f5ee0c4cfd0a8"}
{"project": "qemu", "commit_id": "465f2fedd262cbdcbfc92c181660cf85e5029515", "target": 0, "func": "static int cryptodev_builtin_create_cipher_session(\n\n                    CryptoDevBackendBuiltin *builtin,\n\n                    CryptoDevBackendSymSessionInfo *sess_info,\n\n                    Error **errp)\n\n{\n\n    int algo;\n\n    int mode;\n\n    QCryptoCipher *cipher;\n\n    int index;\n\n    CryptoDevBackendBuiltinSession *sess;\n\n\n\n    if (sess_info->op_type != VIRTIO_CRYPTO_SYM_OP_CIPHER) {\n\n        error_setg(errp, \"Unsupported optype :%u\", sess_info->op_type);\n\n        return -1;\n\n    }\n\n\n\n    index = cryptodev_builtin_get_unused_session_index(builtin);\n\n    if (index < 0) {\n\n        error_setg(errp, \"Total number of sessions created exceeds %u\",\n\n                  MAX_NUM_SESSIONS);\n\n        return -1;\n\n    }\n\n\n\n    switch (sess_info->cipher_alg) {\n\n    case VIRTIO_CRYPTO_CIPHER_AES_ECB:\n\n        algo = cryptodev_builtin_get_aes_algo(sess_info->key_len,\n\n                                                          errp);\n\n        if (algo < 0)  {\n\n            return -1;\n\n        }\n\n        mode = QCRYPTO_CIPHER_MODE_ECB;\n\n        break;\n\n    case VIRTIO_CRYPTO_CIPHER_AES_CBC:\n\n        algo = cryptodev_builtin_get_aes_algo(sess_info->key_len,\n\n                                                          errp);\n\n        if (algo < 0)  {\n\n            return -1;\n\n        }\n\n        mode = QCRYPTO_CIPHER_MODE_CBC;\n\n        break;\n\n    case VIRTIO_CRYPTO_CIPHER_AES_CTR:\n\n        algo = cryptodev_builtin_get_aes_algo(sess_info->key_len,\n\n                                                          errp);\n\n        if (algo < 0)  {\n\n            return -1;\n\n        }\n\n        mode = QCRYPTO_CIPHER_MODE_CTR;\n\n        break;\n\n    case VIRTIO_CRYPTO_CIPHER_DES_ECB:\n\n        algo = QCRYPTO_CIPHER_ALG_DES_RFB;\n\n        mode = QCRYPTO_CIPHER_MODE_ECB;\n\n        break;\n\n    default:\n\n        error_setg(errp, \"Unsupported cipher alg :%u\",\n\n                   sess_info->cipher_alg);\n\n        return -1;\n\n    }\n\n\n\n    cipher = qcrypto_cipher_new(algo, mode,\n\n                               sess_info->cipher_key,\n\n                               sess_info->key_len,\n\n                               errp);\n\n    if (!cipher) {\n\n        return -1;\n\n    }\n\n\n\n    sess = g_new0(CryptoDevBackendBuiltinSession, 1);\n\n    sess->cipher = cipher;\n\n    sess->direction = sess_info->direction;\n\n    sess->type = sess_info->op_type;\n\n\n\n    builtin->sessions[index] = sess;\n\n\n\n    return index;\n\n}\n", "idx": 20549, "_split": "test", "_hash": "e34f4f5bf54b0baeea2ee6ee26a6e2aa"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "envlist_free(envlist_t *envlist)\n\n{\n\n\tstruct envlist_entry *entry;\n\n\n\n\tassert(envlist != NULL);\n\n\n\n\twhile (envlist->el_entries.lh_first != NULL) {\n\n\t\tentry = envlist->el_entries.lh_first;\n\n\t\tLIST_REMOVE(entry, ev_link);\n\n\n\n\t\tfree((char *)entry->ev_var);\n\n\t\tfree(entry);\n\n\t}\n\n\tfree(envlist);\n\n}\n", "idx": 20553, "_split": "test", "_hash": "9eb923cfb8c404ddd6d4c75d7e33efa1"}
{"project": "qemu", "commit_id": "debaaa114a8877a939533ba846e64168fb287b7b", "target": 0, "func": "static void test_hba_enable(void)\n\n{\n\n    AHCIQState *ahci;\n\n\n\n    ahci = ahci_boot();\n\n    ahci_pci_enable(ahci);\n\n    ahci_hba_enable(ahci);\n\n    ahci_shutdown(ahci);\n\n}\n", "idx": 20562, "_split": "test", "_hash": "5fe770dc7374859439b4d678b3e173e3"}
{"project": "qemu", "commit_id": "9e559533bd825a3e371497875576137a8586c831", "target": 1, "func": "static int writev_f(int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, qflag = 0;\n\n    int c, cnt;\n\n    char *buf;\n\n    int64_t offset;\n\n    /* Some compilers get confused and warn if this is not initialized.  */\n\n    int total = 0;\n\n    int nr_iov;\n\n    int pattern = 0xcd;\n\n    QEMUIOVector qiov;\n\n\n\n    while ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n        switch (c) {\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n                return 0;\n\n            }\n\n            break;\n\n        default:\n\n            return command_usage(&writev_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n        return command_usage(&writev_cmd);\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               offset);\n\n        return 0;\n\n    }\n\n\n\n    nr_iov = argc - optind;\n\n    buf = create_iovec(&qiov, &argv[optind], nr_iov, pattern);\n\n    if (buf == NULL) {\n\n        return 0;\n\n    }\n\n\n\n    gettimeofday(&t1, NULL);\n\n    cnt = do_aio_writev(&qiov, offset, &total);\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"writev failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"wrote\", &t2, offset, qiov.size, total, cnt, Cflag);\n\nout:\n\n\n    qemu_io_free(buf);\n\n    return 0;\n\n}", "idx": 20576, "_split": "test", "_hash": "9d2c4bf24bc681254b7c7195a1696f0e"}
{"project": "qemu", "commit_id": "c24a8a0b6dad5a33d84f5fb846edb28c43312c71", "target": 1, "func": "IEEE_ARITH2(sqrtt)\n\nIEEE_ARITH2(cvtst)\n\nIEEE_ARITH2(cvtts)\n\n\n\nstatic void gen_cvttq(DisasContext *ctx, int rb, int rc, int fn11)\n\n{\n\n    TCGv vb, vc;\n\n\n\n    /* No need to set flushzero, since we have an integer output.  */\n\n    vb = gen_ieee_input(ctx, rb, fn11, 0);\n\n    vc = dest_fpr(ctx, rc);\n\n\n\n    /* Almost all integer conversions use cropped rounding, and most\n\n       also do not have integer overflow enabled.  Special case that.  */\n\n    switch (fn11) {\n\n    case QUAL_RM_C:\n\n        gen_helper_cvttq_c(vc, cpu_env, vb);\n\n        break;\n\n    case QUAL_V | QUAL_RM_C:\n\n    case QUAL_S | QUAL_V | QUAL_RM_C:\n\n    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:\n\n        gen_helper_cvttq_svic(vc, cpu_env, vb);\n\n        break;\n\n    default:\n\n        gen_qual_roundmode(ctx, fn11);\n\n        gen_helper_cvttq(vc, cpu_env, vb);\n\n        break;\n\n    }\n\n\n\n    gen_fp_exc_raise(rc, fn11);\n\n}\n", "idx": 20631, "_split": "test", "_hash": "0e45d0a10684e53117aa9b53d1ed2ad4"}
{"project": "qemu", "commit_id": "0e86c13fe2058adb8c792ebb7c51a6a7ca9d3d55", "target": 1, "func": "static int virtio_serial_device_exit(DeviceState *dev)\n\n{\n\n    VirtIOSerial *vser = VIRTIO_SERIAL(dev);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n\n\n    unregister_savevm(dev, \"virtio-console\", vser);\n\n\n\n    g_free(vser->ivqs);\n\n    g_free(vser->ovqs);\n\n    g_free(vser->ports_map);\n\n    if (vser->post_load) {\n\n        g_free(vser->post_load->connected);\n\n        timer_del(vser->post_load->timer);\n\n        timer_free(vser->post_load->timer);\n\n        g_free(vser->post_load);\n\n    }\n\n    virtio_cleanup(vdev);\n\n    return 0;\n\n}\n", "idx": 20643, "_split": "test", "_hash": "779e3b5a9a77a2512cb8235f5da60bfd"}
{"project": "qemu", "commit_id": "5666ca4ae06d20497f887241151278e266947087", "target": 1, "func": "int kvm_arch_init_vcpu(CPUState *cenv)\n\n{\n\n    int ret = 0;\n\n    struct kvm_sregs sregs;\n\n\n\n    sregs.pvr = cenv->spr[SPR_PVR];\n\n    ret = kvm_vcpu_ioctl(cenv, KVM_SET_SREGS, &sregs);\n\n\n\n    idle_timer = qemu_new_timer_ns(vm_clock, kvm_kick_env, cenv);\n\n\n\n    return ret;\n\n}\n", "idx": 20644, "_split": "test", "_hash": "cb7f3cab0a3dae584147f6bd58b6ca23"}
{"project": "qemu", "commit_id": "f5ed36635d8fa73feb66fe12b3b9c2ed90a1adbe", "target": 1, "func": "static void virtio_queue_notify_vq(VirtQueue *vq)\n{\n    if (vq->vring.desc && vq->handle_output) {\n        VirtIODevice *vdev = vq->vdev;\n        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);\n        vq->handle_output(vdev, vq);", "idx": 20647, "_split": "test", "_hash": "3d7280080560287ddfa9798bb80e2949"}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void ppc_store_xer (CPUPPCState *env, uint32_t value)\n\n{\n\n    xer_so = (value >> XER_SO) & 0x01;\n\n    xer_ov = (value >> XER_OV) & 0x01;\n\n    xer_ca = (value >> XER_CA) & 0x01;\n\n    xer_cmp = (value >> XER_CMP) & 0xFF;\n\n    xer_bc = (value >> XER_BC) & 0x3F;\n\n}\n", "idx": 20716, "_split": "test", "_hash": "cab58b1fd98fc2a19deefc351283bbab"}
{"project": "qemu", "commit_id": "4715d42efe8632b0f9d2594a80e917de45e4ef88", "target": 1, "func": "static void property_get_enum(Object *obj, Visitor *v, void *opaque,\n\n                              const char *name, Error **errp)\n\n{\n\n    EnumProperty *prop = opaque;\n\n    int value;\n\n\n\n    value = prop->get(obj, errp);\n\n    visit_type_enum(v, &value, prop->strings, NULL, name, errp);\n\n}\n", "idx": 20722, "_split": "test", "_hash": "b642a87b59c8181857dca0efe88370af"}
{"project": "qemu", "commit_id": "947995c09ebd35a752837a5573985ba5a9942ec1", "target": 0, "func": "static int path_has_protocol(const char *path)\n\n{\n\n#ifdef _WIN32\n\n    if (is_windows_drive(path) ||\n\n        is_windows_drive_prefix(path)) {\n\n        return 0;\n\n    }\n\n#endif\n\n\n\n    return strchr(path, ':') != NULL;\n\n}\n", "idx": 20728, "_split": "test", "_hash": "0a630936f1bcaaf8f2ec61a35eebc1d4"}
{"project": "qemu", "commit_id": "1466cef32dd5e7ef3c6477e96d85d92302ad02e3", "target": 0, "func": "static int mch_init(PCIDevice *d)\n\n{\n\n    int i;\n\n    MCHPCIState *mch = MCH_PCI_DEVICE(d);\n\n\n\n    /* setup pci memory regions */\n\n    memory_region_init_alias(&mch->pci_hole, OBJECT(mch), \"pci-hole\",\n\n                             mch->pci_address_space,\n\n                             mch->below_4g_mem_size,\n\n                             0x100000000ULL - mch->below_4g_mem_size);\n\n    memory_region_add_subregion(mch->system_memory, mch->below_4g_mem_size,\n\n                                &mch->pci_hole);\n\n\n\n    pc_init_pci64_hole(&mch->pci_info, 0x100000000ULL + mch->above_4g_mem_size,\n\n                       mch->pci_hole64_size);\n\n    memory_region_init_alias(&mch->pci_hole_64bit, OBJECT(mch), \"pci-hole64\",\n\n                             mch->pci_address_space,\n\n                             mch->pci_info.w64.begin,\n\n                             mch->pci_hole64_size);\n\n    if (mch->pci_hole64_size) {\n\n        memory_region_add_subregion(mch->system_memory,\n\n                                    mch->pci_info.w64.begin,\n\n                                    &mch->pci_hole_64bit);\n\n    }\n\n    /* smram */\n\n    cpu_smm_register(&mch_set_smm, mch);\n\n    memory_region_init_alias(&mch->smram_region, OBJECT(mch), \"smram-region\",\n\n                             mch->pci_address_space, 0xa0000, 0x20000);\n\n    memory_region_add_subregion_overlap(mch->system_memory, 0xa0000,\n\n                                        &mch->smram_region, 1);\n\n    memory_region_set_enabled(&mch->smram_region, false);\n\n    init_pam(DEVICE(mch), mch->ram_memory, mch->system_memory, mch->pci_address_space,\n\n             &mch->pam_regions[0], PAM_BIOS_BASE, PAM_BIOS_SIZE);\n\n    for (i = 0; i < 12; ++i) {\n\n        init_pam(DEVICE(mch), mch->ram_memory, mch->system_memory, mch->pci_address_space,\n\n                 &mch->pam_regions[i+1], PAM_EXPAN_BASE + i * PAM_EXPAN_SIZE,\n\n                 PAM_EXPAN_SIZE);\n\n    }\n\n    return 0;\n\n}\n", "idx": 20738, "_split": "test", "_hash": "16c52caee65cfe142b610685a1bd109f"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void address_space_write(AddressSpace *as, target_phys_addr_t addr,\n\n                         const uint8_t *buf, int len)\n\n{\n\n    address_space_rw(as, addr, (uint8_t *)buf, len, true);\n\n}\n", "idx": 20743, "_split": "test", "_hash": "be81f36033692ca495b113716f9476fe"}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static void audio_run_capture (AudioState *s)\n\n{\n\n    CaptureVoiceOut *cap;\n\n\n\n    for (cap = s->cap_head.lh_first; cap; cap = cap->entries.le_next) {\n\n        int live, rpos, captured;\n\n        HWVoiceOut *hw = &cap->hw;\n\n        SWVoiceOut *sw;\n\n\n\n        captured = live = audio_pcm_hw_get_live_out (hw);\n\n        rpos = hw->rpos;\n\n        while (live) {\n\n            int left = hw->samples - rpos;\n\n            int to_capture = audio_MIN (live, left);\n\n            st_sample_t *src;\n\n            struct capture_callback *cb;\n\n\n\n            src = hw->mix_buf + rpos;\n\n            hw->clip (cap->buf, src, to_capture);\n\n            mixeng_clear (src, to_capture);\n\n\n\n            for (cb = cap->cb_head.lh_first; cb; cb = cb->entries.le_next) {\n\n                cb->ops.capture (cb->opaque, cap->buf,\n\n                                 to_capture << hw->info.shift);\n\n            }\n\n            rpos = (rpos + to_capture) % hw->samples;\n\n            live -= to_capture;\n\n        }\n\n        hw->rpos = rpos;\n\n\n\n        for (sw = hw->sw_head.lh_first; sw; sw = sw->entries.le_next) {\n\n            if (!sw->active && sw->empty) {\n\n                continue;\n\n            }\n\n\n\n            if (audio_bug (AUDIO_FUNC, captured > sw->total_hw_samples_mixed)) {\n\n                dolog (\"captured=%d sw->total_hw_samples_mixed=%d\\n\",\n\n                       captured, sw->total_hw_samples_mixed);\n\n                captured = sw->total_hw_samples_mixed;\n\n            }\n\n\n\n            sw->total_hw_samples_mixed -= captured;\n\n            sw->empty = sw->total_hw_samples_mixed == 0;\n\n        }\n\n    }\n\n}\n", "idx": 20751, "_split": "test", "_hash": "2549072ce25e8ac1216c5b791a97d311"}
{"project": "qemu", "commit_id": "f3db17b9514b8d724f8d6111a9f9608ff8bad631", "target": 1, "func": "CharDriverState *qemu_chr_alloc(void)\n\n{\n\n    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));\n\n\n    return chr;\n\n}", "idx": 20761, "_split": "test", "_hash": "f3e2a4164de3dcce0afc1438a89431ef"}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void ecc_init(target_phys_addr_t base, qemu_irq irq, uint32_t version)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"eccmemctl\");\n\n    qdev_prop_set_uint32(dev, \"version\", version);\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_mmio_map(s, 0, base);\n\n    if (version == 0) { // SS-600MP only\n\n        sysbus_mmio_map(s, 1, base + 0x1000);\n\n    }\n\n}\n", "idx": 20766, "_split": "test", "_hash": "4623e6bdd70ffc377c70c648b17eb92b"}
{"project": "qemu", "commit_id": "5d1abf234462d13bef3617cc2c55b6815703ddf2", "target": 0, "func": "int pcistb_service_call(S390CPU *cpu, uint8_t r1, uint8_t r3, uint64_t gaddr,\n\n                        uint8_t ar)\n\n{\n\n    CPUS390XState *env = &cpu->env;\n\n    S390PCIBusDevice *pbdev;\n\n    MemoryRegion *mr;\n\n    int i;\n\n    uint32_t fh;\n\n    uint8_t pcias;\n\n    uint8_t len;\n\n    uint8_t buffer[128];\n\n\n\n    if (env->psw.mask & PSW_MASK_PSTATE) {\n\n        program_interrupt(env, PGM_PRIVILEGED, 6);\n\n        return 0;\n\n    }\n\n\n\n    fh = env->regs[r1] >> 32;\n\n    pcias = (env->regs[r1] >> 16) & 0xf;\n\n    len = env->regs[r1] & 0xff;\n\n\n\n    if (pcias > 5) {\n\n        DPRINTF(\"pcistb invalid space\\n\");\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r1, ZPCI_PCI_ST_INVAL_AS);\n\n        return 0;\n\n    }\n\n\n\n    switch (len) {\n\n    case 16:\n\n    case 32:\n\n    case 64:\n\n    case 128:\n\n        break;\n\n    default:\n\n        program_interrupt(env, PGM_SPECIFICATION, 6);\n\n        return 0;\n\n    }\n\n\n\n    pbdev = s390_pci_find_dev_by_fh(fh);\n\n    if (!pbdev || !(pbdev->fh & FH_MASK_ENABLE)) {\n\n        DPRINTF(\"pcistb no pci dev fh 0x%x\\n\", fh);\n\n        setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);\n\n        return 0;\n\n    }\n\n\n\n    if (pbdev->lgstg_blocked) {\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r1, ZPCI_PCI_ST_BLOCKED);\n\n        return 0;\n\n    }\n\n\n\n    mr = pbdev->pdev->io_regions[pcias].memory;\n\n    if (!memory_region_access_valid(mr, env->regs[r3], len, true)) {\n\n        program_interrupt(env, PGM_ADDRESSING, 6);\n\n        return 0;\n\n    }\n\n\n\n    if (s390_cpu_virt_mem_read(cpu, gaddr, ar, buffer, len)) {\n\n        return 0;\n\n    }\n\n\n\n    for (i = 0; i < len / 8; i++) {\n\n        memory_region_dispatch_write(mr, env->regs[r3] + i * 8,\n\n                                     ldq_p(buffer + i * 8), 8,\n\n                                     MEMTXATTRS_UNSPECIFIED);\n\n    }\n\n\n\n    setcc(cpu, ZPCI_PCI_LS_OK);\n\n    return 0;\n\n}\n", "idx": 20797, "_split": "test", "_hash": "b2730bae1e292bc1cf131d010abebfbd"}
{"project": "qemu", "commit_id": "293d2a0014a0e849477413f55aaa05f2743b2e04", "target": 0, "func": "static gboolean monitor_unblocked(GIOChannel *chan, GIOCondition cond,\n\n                                  void *opaque)\n\n{\n\n    monitor_flush(opaque);\n\n    return FALSE;\n\n}\n", "idx": 20802, "_split": "test", "_hash": "5412bae8de328c74e5a8754eb9fc69f8"}
{"project": "qemu", "commit_id": "5c55ff99fa88158871d5b9f619c485deae5f3d5b", "target": 0, "func": "static always_inline void gen_store_spr(int reg, TCGv t)\n\n{\n\n    tcg_gen_st_tl(t, cpu_env, offsetof(CPUState, spr[reg]));\n\n}\n", "idx": 20803, "_split": "test", "_hash": "3373d671eb4fb2947c2cb4fd39ce19dc"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_is_read_only(BlockDriverState *bs)\n\n{\n\n    return bs->read_only;\n\n}\n", "idx": 20811, "_split": "test", "_hash": "b684fc708fa0a15c1122779e8ef246b3"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void bw_conf1_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t val, unsigned size)\n\n{\n\n    PCIBus *b = opaque;\n\n    pci_data_write(b, addr, val, size);\n\n}\n", "idx": 20812, "_split": "test", "_hash": "2866ca1500d82872a279c31d83f75375"}
{"project": "qemu", "commit_id": "54ca9095f046dfa03c3d093cc55f6d76b61864e1", "target": 0, "func": "void tlb_fill(target_ulong addr, int is_write, int is_user, void *retaddr)\n\n{\n\n    TranslationBlock *tb;\n\n    int ret;\n\n    unsigned long pc;\n\n    CPUX86State *saved_env;\n\n\n\n    /* XXX: hack to restore env in all cases, even if not called from\n\n       generated code */\n\n    saved_env = env;\n\n    env = cpu_single_env;\n\n\n\n    ret = cpu_x86_handle_mmu_fault(env, addr, is_write, is_user, 1);\n\n    if (ret) {\n\n        if (retaddr) {\n\n            /* now we have a real cpu fault */\n\n            pc = (unsigned long)retaddr;\n\n            tb = tb_find_pc(pc);\n\n            if (tb) {\n\n                /* the PC is inside the translated code. It means that we have\n\n                   a virtual CPU fault */\n\n                cpu_restore_state(tb, env, pc, NULL);\n\n            }\n\n        }\n\n        if (retaddr)\n\n            raise_exception_err(EXCP0E_PAGE, env->error_code);\n\n        else\n\n            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);\n\n    }\n\n    env = saved_env;\n\n}\n", "idx": 20831, "_split": "test", "_hash": "549221b9dd35904dae2b4fdda6c8bf3c"}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void test_tco1_status_bits(void)\n\n{\n\n    TestData d;\n\n    uint16_t ticks = 8;\n\n    uint16_t val;\n\n    int ret;\n\n\n\n    d.args = NULL;\n\n    d.noreboot = true;\n\n    test_init(&d);\n\n\n\n    stop_tco(&d);\n\n    clear_tco_status(&d);\n\n    reset_on_second_timeout(false);\n\n    set_tco_timeout(&d, ticks);\n\n    load_tco(&d);\n\n    start_tco(&d);\n\n    clock_step(ticks * TCO_TICK_NSEC);\n\n\n\n    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);\n\n    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);\n\n    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);\n\n    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;\n\n    g_assert(ret == 1);\n\n    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);\n\n    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);\n\n    qtest_end();\n\n}\n", "idx": 20835, "_split": "test", "_hash": "37f6c815d66f4e5676552407badd43ee"}
{"project": "qemu", "commit_id": "95c3df5a24e2f18129b58691c2ebaf0d86808525", "target": 1, "func": "block_crypto_create_opts_init(QCryptoBlockFormat format,\n\n                              QemuOpts *opts,\n\n                              Error **errp)\n\n{\n\n    OptsVisitor *ov;\n\n    QCryptoBlockCreateOptions *ret = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    ret = g_new0(QCryptoBlockCreateOptions, 1);\n\n    ret->format = format;\n\n\n\n    ov = opts_visitor_new(opts);\n\n\n\n    visit_start_struct(opts_get_visitor(ov),\n\n                       NULL, NULL, 0, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    switch (format) {\n\n    case Q_CRYPTO_BLOCK_FORMAT_LUKS:\n\n        visit_type_QCryptoBlockCreateOptionsLUKS_members(\n\n            opts_get_visitor(ov), &ret->u.luks, &local_err);\n\n        break;\n\n\n\n    default:\n\n        error_setg(&local_err, \"Unsupported block format %d\", format);\n\n        break;\n\n    }\n\n    error_propagate(errp, local_err);\n\n    local_err = NULL;\n\n\n\n    visit_end_struct(opts_get_visitor(ov), &local_err);\n\n\n\n out:\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        qapi_free_QCryptoBlockCreateOptions(ret);\n\n        ret = NULL;\n\n    }\n\n    opts_visitor_cleanup(ov);\n\n    return ret;\n\n}\n", "idx": 20840, "_split": "test", "_hash": "a43356bf4dd0f05bf09d1413dacfea61"}
{"project": "qemu", "commit_id": "7a0e58fa648736a75f2a6943afd2ab08ea15b8e0", "target": 0, "func": "static void add_cpreg_to_list(gpointer key, gpointer opaque)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    uint64_t regidx;\n\n    const ARMCPRegInfo *ri;\n\n\n\n    regidx = *(uint32_t *)key;\n\n    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);\n\n\n\n    if (!(ri->type & ARM_CP_NO_MIGRATE)) {\n\n        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);\n\n        /* The value array need not be initialized at this point */\n\n        cpu->cpreg_array_len++;\n\n    }\n\n}\n", "idx": 20902, "_split": "test", "_hash": "ef8b439420a29e0a3d2d83cb4f06d1e4"}
{"project": "qemu", "commit_id": "1828be316f6637d43dd4c4f5f32925b17fb8107f", "target": 0, "func": "static inline int alarm_has_dynticks(struct qemu_alarm_timer *t)\n\n{\n\n    return t && t->rearm;\n\n}\n", "idx": 20908, "_split": "test", "_hash": "9c7072825d9ec5df8db7a7e58651fbc9"}
{"project": "qemu", "commit_id": "26e92f65525ef4446a500d85e185cf78835922aa", "target": 0, "func": "static uint32_t arm_sysctl_read(void *opaque, target_phys_addr_t offset)\n\n{\n\n    arm_sysctl_state *s = (arm_sysctl_state *)opaque;\n\n\n\n    switch (offset) {\n\n    case 0x00: /* ID */\n\n        return s->sys_id;\n\n    case 0x04: /* SW */\n\n        /* General purpose hardware switches.\n\n           We don't have a useful way of exposing these to the user.  */\n\n        return 0;\n\n    case 0x08: /* LED */\n\n        return s->leds;\n\n    case 0x20: /* LOCK */\n\n        return s->lockval;\n\n    case 0x0c: /* OSC0 */\n\n    case 0x10: /* OSC1 */\n\n    case 0x14: /* OSC2 */\n\n    case 0x18: /* OSC3 */\n\n    case 0x1c: /* OSC4 */\n\n    case 0x24: /* 100HZ */\n\n        /* ??? Implement these.  */\n\n        return 0;\n\n    case 0x28: /* CFGDATA1 */\n\n        return s->cfgdata1;\n\n    case 0x2c: /* CFGDATA2 */\n\n        return s->cfgdata2;\n\n    case 0x30: /* FLAGS */\n\n        return s->flags;\n\n    case 0x38: /* NVFLAGS */\n\n        return s->nvflags;\n\n    case 0x40: /* RESETCTL */\n\n        return s->resetlevel;\n\n    case 0x44: /* PCICTL */\n\n        return 1;\n\n    case 0x48: /* MCI */\n\n        return 0;\n\n    case 0x4c: /* FLASH */\n\n        return 0;\n\n    case 0x50: /* CLCD */\n\n        return 0x1000;\n\n    case 0x54: /* CLCDSER */\n\n        return 0;\n\n    case 0x58: /* BOOTCS */\n\n        return 0;\n\n    case 0x5c: /* 24MHz */\n\n        return muldiv64(qemu_get_clock(vm_clock), 24000000, get_ticks_per_sec());\n\n    case 0x60: /* MISC */\n\n        return 0;\n\n    case 0x84: /* PROCID0 */\n\n        /* ??? Don't know what the proper value for the core tile ID is.  */\n\n        return 0x02000000;\n\n    case 0x88: /* PROCID1 */\n\n        return 0xff000000;\n\n    case 0x64: /* DMAPSR0 */\n\n    case 0x68: /* DMAPSR1 */\n\n    case 0x6c: /* DMAPSR2 */\n\n    case 0x70: /* IOSEL */\n\n    case 0x74: /* PLDCTL */\n\n    case 0x80: /* BUSID */\n\n    case 0x8c: /* OSCRESET0 */\n\n    case 0x90: /* OSCRESET1 */\n\n    case 0x94: /* OSCRESET2 */\n\n    case 0x98: /* OSCRESET3 */\n\n    case 0x9c: /* OSCRESET4 */\n\n    case 0xc0: /* SYS_TEST_OSC0 */\n\n    case 0xc4: /* SYS_TEST_OSC1 */\n\n    case 0xc8: /* SYS_TEST_OSC2 */\n\n    case 0xcc: /* SYS_TEST_OSC3 */\n\n    case 0xd0: /* SYS_TEST_OSC4 */\n\n        return 0;\n\n    default:\n\n        printf (\"arm_sysctl_read: Bad register offset 0x%x\\n\", (int)offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 20938, "_split": "test", "_hash": "6edf7905658337f62fee73ff704f6b0d"}
{"project": "qemu", "commit_id": "376692b9dc6f02303ee07a4146d08d8727d79c0c", "target": 0, "func": "void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)\n\n{\n\n    struct qemu_work_item wi;\n\n\n\n    if (qemu_cpu_is_self(cpu)) {\n\n        func(data);\n\n        return;\n\n    }\n\n\n\n    wi.func = func;\n\n    wi.data = data;\n\n    wi.free = false;\n\n    if (cpu->queued_work_first == NULL) {\n\n        cpu->queued_work_first = &wi;\n\n    } else {\n\n        cpu->queued_work_last->next = &wi;\n\n    }\n\n    cpu->queued_work_last = &wi;\n\n    wi.next = NULL;\n\n    wi.done = false;\n\n\n\n    qemu_cpu_kick(cpu);\n\n    while (!wi.done) {\n\n        CPUState *self_cpu = current_cpu;\n\n\n\n        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);\n\n        current_cpu = self_cpu;\n\n    }\n\n}\n", "idx": 20945, "_split": "test", "_hash": "d0ef215ce061563b5db9e97dde58115c"}
{"project": "qemu", "commit_id": "a659979328fb6d4d6100d398f5bd9a2310c3e169", "target": 0, "func": "open_f(int argc, char **argv)\n\n{\n\n\tint flags = 0;\n\n\tint readonly = 0;\n\n\tint growable = 0;\n\n\tint c;\n\n\n\n\twhile ((c = getopt(argc, argv, \"snrg\")) != EOF) {\n\n\t\tswitch (c) {\n\n\t\tcase 's':\n\n\t\t\tflags |= BDRV_O_SNAPSHOT;\n\n\t\t\tbreak;\n\n\t\tcase 'n':\n\n\t\t\tflags |= BDRV_O_NOCACHE;\n\n\t\t\tbreak;\n\n\t\tcase 'r':\n\n\t\t\treadonly = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'g':\n\n\t\t\tgrowable = 1;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\treturn command_usage(&open_cmd);\n\n\t\t}\n\n\t}\n\n\n\n\tif (!readonly) {\n\n            flags |= BDRV_O_RDWR;\n\n        }\n\n\n\n\tif (optind != argc - 1)\n\n\t\treturn command_usage(&open_cmd);\n\n\n\n\treturn openfile(argv[optind], flags, growable);\n\n}\n", "idx": 20970, "_split": "test", "_hash": "2e30563546117652d42778dc8d760305"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static unsigned int event_status_media(IDEState *s,\n\n                                       uint8_t *buf)\n\n{\n\n    uint8_t event_code, media_status;\n\n\n\n    media_status = 0;\n\n    if (s->tray_open) {\n\n        media_status = MS_TRAY_OPEN;\n\n    } else if (bdrv_is_inserted(s->bs)) {\n\n        media_status = MS_MEDIA_PRESENT;\n\n    }\n\n\n\n    /* Event notification descriptor */\n\n    event_code = MEC_NO_CHANGE;\n\n    if (media_status != MS_TRAY_OPEN) {\n\n        if (s->events.new_media) {\n\n            event_code = MEC_NEW_MEDIA;\n\n            s->events.new_media = false;\n\n        } else if (s->events.eject_request) {\n\n            event_code = MEC_EJECT_REQUESTED;\n\n            s->events.eject_request = false;\n\n        }\n\n    }\n\n\n\n    buf[4] = event_code;\n\n    buf[5] = media_status;\n\n\n\n    /* These fields are reserved, just clear them. */\n\n    buf[6] = 0;\n\n    buf[7] = 0;\n\n\n\n    return 8; /* We wrote to 4 extra bytes from the header */\n\n}\n", "idx": 20975, "_split": "test", "_hash": "494d14bad7da96b8ce3bc2c785b2d4c7"}
{"project": "qemu", "commit_id": "ef546f1275f6563e8934dd5e338d29d9f9909ca6", "target": 0, "func": "static void virtio_scsi_hotunplug(HotplugHandler *hotplug_dev, DeviceState *dev,\n\n                                  Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(hotplug_dev);\n\n    VirtIOSCSI *s = VIRTIO_SCSI(vdev);\n\n    SCSIDevice *sd = SCSI_DEVICE(dev);\n\n\n\n    if ((vdev->guest_features >> VIRTIO_SCSI_F_HOTPLUG) & 1) {\n\n        virtio_scsi_push_event(s, sd,\n\n                               VIRTIO_SCSI_T_TRANSPORT_RESET,\n\n                               VIRTIO_SCSI_EVT_RESET_REMOVED);\n\n    }\n\n\n\n    if (s->ctx) {\n\n        blk_op_unblock_all(sd->conf.blk, s->blocker);\n\n    }\n\n    qdev_simple_device_unplug_cb(hotplug_dev, dev, errp);\n\n}\n", "idx": 20994, "_split": "test", "_hash": "628b222245994d6814fc58c74d56781c"}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "int qio_channel_socket_connect_sync(QIOChannelSocket *ioc,\n\n                                    SocketAddress *addr,\n\n                                    Error **errp)\n\n{\n\n    int fd;\n\n\n\n    trace_qio_channel_socket_connect_sync(ioc, addr);\n\n    fd = socket_connect(addr, NULL, NULL, errp);\n\n    if (fd < 0) {\n\n        trace_qio_channel_socket_connect_fail(ioc);\n\n        return -1;\n\n    }\n\n\n\n    trace_qio_channel_socket_connect_complete(ioc, fd);\n\n    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 20996, "_split": "test", "_hash": "38ad8aa61135163ead41a2008884a483"}
{"project": "qemu", "commit_id": "b36d24b6c3708413f1174e34bd86b4bf5116012f", "target": 1, "func": "static void host_cpuid(uint32_t function, uint32_t count,\n\n                       uint32_t *eax, uint32_t *ebx,\n\n                       uint32_t *ecx, uint32_t *edx)\n\n{\n\n#if defined(CONFIG_KVM)\n\n    uint32_t vec[4];\n\n\n\n#ifdef __x86_64__\n\n    asm volatile(\"cpuid\"\n\n                 : \"=a\"(vec[0]), \"=b\"(vec[1]),\n\n                   \"=c\"(vec[2]), \"=d\"(vec[3])\n\n                 : \"0\"(function), \"c\"(count) : \"cc\");\n\n#else\n\n    asm volatile(\"pusha \\n\\t\"\n\n                 \"cpuid \\n\\t\"\n\n                 \"mov %%eax, 0(%1) \\n\\t\"\n\n                 \"mov %%ebx, 4(%1) \\n\\t\"\n\n                 \"mov %%ecx, 8(%1) \\n\\t\"\n\n                 \"mov %%edx, 12(%1) \\n\\t\"\n\n                 \"popa\"\n\n                 : : \"a\"(function), \"c\"(count), \"S\"(vec)\n\n                 : \"memory\", \"cc\");\n\n#endif\n\n\n\n    if (eax)\n\n\t*eax = vec[0];\n\n    if (ebx)\n\n\t*ebx = vec[1];\n\n    if (ecx)\n\n\t*ecx = vec[2];\n\n    if (edx)\n\n\t*edx = vec[3];\n\n#endif\n\n}\n", "idx": 21034, "_split": "test", "_hash": "b975503142e486732165dc313945e899"}
{"project": "qemu", "commit_id": "de00982e9e14e2d6ba3d148f02c5a1e94deaa985", "target": 0, "func": "static void platform_mmio_map(PCIDevice *d, int region_num,\n\n                              pcibus_t addr, pcibus_t size, int type)\n\n{\n\n    int mmio_io_addr;\n\n\n\n    mmio_io_addr = cpu_register_io_memory_simple(&platform_mmio_handler,\n\n                                                 DEVICE_NATIVE_ENDIAN);\n\n\n\n    cpu_register_physical_memory(addr, size, mmio_io_addr);\n\n}\n", "idx": 21092, "_split": "test", "_hash": "8bd6b201d323302f61d22cfbd53e5962"}
{"project": "qemu", "commit_id": "ac4b0d0c4feb291643c0e8a07a92e449e13881b5", "target": 0, "func": "static void bt_submit_hci(struct HCIInfo *info,\n\n                const uint8_t *data, int length)\n\n{\n\n    struct bt_hci_s *hci = hci_from_info(info);\n\n    uint16_t cmd;\n\n    int paramlen, i;\n\n\n\n    if (length < HCI_COMMAND_HDR_SIZE)\n\n        goto short_hci;\n\n\n\n    memcpy(&hci->last_cmd, data, 2);\n\n\n\n    cmd = (data[1] << 8) | data[0];\n\n    paramlen = data[2];\n\n    if (cmd_opcode_ogf(cmd) == 0 || cmd_opcode_ocf(cmd) == 0)\t/* NOP */\n\n        return;\n\n\n\n    data += HCI_COMMAND_HDR_SIZE;\n\n    length -= HCI_COMMAND_HDR_SIZE;\n\n\n\n    if (paramlen > length)\n\n        return;\n\n\n\n#define PARAM(cmd, param)\t(((cmd##_cp *) data)->param)\n\n#define PARAM16(cmd, param)\tle16_to_cpup(&PARAM(cmd, param))\n\n#define PARAMHANDLE(cmd)\tHNDL(PARAM(cmd, handle))\n\n#define LENGTH_CHECK(cmd)\tif (length < sizeof(cmd##_cp)) goto short_hci\n\n    /* Note: the supported commands bitmask in bt_hci_read_local_commands_rp\n\n     * needs to be updated every time a command is implemented here!  */\n\n    switch (cmd) {\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_INQUIRY):\n\n        LENGTH_CHECK(inquiry);\n\n\n\n        if (PARAM(inquiry, length) < 1) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 1;\n\n        hci->lm.periodic = 0;\n\n        hci->lm.responses_left = PARAM(inquiry, num_rsp) ?: INT_MAX;\n\n        hci->lm.responses = 0;\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_inquiry_start(hci, PARAM(inquiry, length));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_INQUIRY_CANCEL):\n\n        if (!hci->lm.inquire || hci->lm.periodic) {\n\n            fprintf(stderr, \"%s: Inquiry Cancel should only be issued after \"\n\n                            \"the Inquiry command has been issued, a Command \"\n\n                            \"Status event has been received for the Inquiry \"\n\n                            \"command, and before the Inquiry Complete event \"\n\n                            \"occurs\", __FUNCTION__);\n\n            bt_hci_event_complete_status(hci, HCI_COMMAND_DISALLOWED);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 0;\n\n        qemu_del_timer(hci->lm.inquiry_done);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_PERIODIC_INQUIRY):\n\n        LENGTH_CHECK(periodic_inquiry);\n\n\n\n        if (!(PARAM(periodic_inquiry, length) <\n\n                                PARAM16(periodic_inquiry, min_period) &&\n\n                                PARAM16(periodic_inquiry, min_period) <\n\n                                PARAM16(periodic_inquiry, max_period)) ||\n\n                        PARAM(periodic_inquiry, length) < 1 ||\n\n                        PARAM16(periodic_inquiry, min_period) < 2 ||\n\n                        PARAM16(periodic_inquiry, max_period) < 3) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 1;\n\n        hci->lm.periodic = 1;\n\n        hci->lm.responses_left = PARAM(periodic_inquiry, num_rsp);\n\n        hci->lm.responses = 0;\n\n        hci->lm.inquiry_period = PARAM16(periodic_inquiry, max_period);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        bt_hci_inquiry_start(hci, PARAM(periodic_inquiry, length));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_EXIT_PERIODIC_INQUIRY):\n\n        if (!hci->lm.inquire || !hci->lm.periodic) {\n\n            fprintf(stderr, \"%s: Inquiry Cancel should only be issued after \"\n\n                            \"the Inquiry command has been issued, a Command \"\n\n                            \"Status event has been received for the Inquiry \"\n\n                            \"command, and before the Inquiry Complete event \"\n\n                            \"occurs\", __FUNCTION__);\n\n            bt_hci_event_complete_status(hci, HCI_COMMAND_DISALLOWED);\n\n            break;\n\n        }\n\n        hci->lm.inquire = 0;\n\n        qemu_del_timer(hci->lm.inquiry_done);\n\n        qemu_del_timer(hci->lm.inquiry_next);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_CREATE_CONN):\n\n        LENGTH_CHECK(create_conn);\n\n\n\n        if (hci->lm.connecting >= HCI_HANDLES_MAX) {\n\n            bt_hci_event_status(hci, HCI_REJECTED_LIMITED_RESOURCES);\n\n            break;\n\n        }\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n\n\n        if (bt_hci_connect(hci, &PARAM(create_conn, bdaddr)))\n\n            bt_hci_connection_reject_event(hci, &PARAM(create_conn, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_DISCONNECT):\n\n        LENGTH_CHECK(disconnect);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(disconnect))) {\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_disconnect(hci, PARAMHANDLE(disconnect),\n\n                        PARAM(disconnect, reason));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_CREATE_CONN_CANCEL):\n\n        LENGTH_CHECK(create_conn_cancel);\n\n\n\n        if (bt_hci_lmp_connection_ready(hci,\n\n                                &PARAM(create_conn_cancel, bdaddr))) {\n\n            for (i = 0; i < HCI_HANDLES_MAX; i ++)\n\n                if (bt_hci_role_master(hci, i) && hci->lm.handle[i].link &&\n\n                                !bacmp(&hci->lm.handle[i].link->slave->bd_addr,\n\n                                        &PARAM(create_conn_cancel, bdaddr)))\n\n                   break;\n\n\n\n            bt_hci_event_complete_conn_cancel(hci, i < HCI_HANDLES_MAX ?\n\n                            HCI_ACL_CONNECTION_EXISTS : HCI_NO_CONNECTION,\n\n                            &PARAM(create_conn_cancel, bdaddr));\n\n        } else\n\n            bt_hci_event_complete_conn_cancel(hci, HCI_SUCCESS,\n\n                            &PARAM(create_conn_cancel, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_ACCEPT_CONN_REQ):\n\n        LENGTH_CHECK(accept_conn_req);\n\n\n\n        if (!hci->conn_req_host ||\n\n                        bacmp(&PARAM(accept_conn_req, bdaddr),\n\n                                &hci->conn_req_host->bd_addr)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_connection_accept(hci, hci->conn_req_host);\n\n        hci->conn_req_host = 0;\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REJECT_CONN_REQ):\n\n        LENGTH_CHECK(reject_conn_req);\n\n\n\n        if (!hci->conn_req_host ||\n\n                        bacmp(&PARAM(reject_conn_req, bdaddr),\n\n                                &hci->conn_req_host->bd_addr)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_connection_reject(hci, hci->conn_req_host,\n\n                        PARAM(reject_conn_req, reason));\n\n        bt_hci_connection_reject_event(hci, &hci->conn_req_host->bd_addr);\n\n        hci->conn_req_host = 0;\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_AUTH_REQUESTED):\n\n        LENGTH_CHECK(auth_requested);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(auth_requested)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_auth_complete(hci, PARAMHANDLE(auth_requested));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_SET_CONN_ENCRYPT):\n\n        LENGTH_CHECK(set_conn_encrypt);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(set_conn_encrypt)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_encrypt_change(hci,\n\n                            PARAMHANDLE(set_conn_encrypt),\n\n                            PARAM(set_conn_encrypt, encrypt));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REMOTE_NAME_REQ):\n\n        LENGTH_CHECK(remote_name_req);\n\n\n\n        if (bt_hci_name_req(hci, &PARAM(remote_name_req, bdaddr)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REMOTE_NAME_REQ_CANCEL):\n\n        LENGTH_CHECK(remote_name_req_cancel);\n\n\n\n        bt_hci_event_complete_name_cancel(hci,\n\n                        &PARAM(remote_name_req_cancel, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_FEATURES):\n\n        LENGTH_CHECK(read_remote_features);\n\n\n\n        if (bt_hci_features_req(hci, PARAMHANDLE(read_remote_features)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_EXT_FEATURES):\n\n        LENGTH_CHECK(read_remote_ext_features);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(read_remote_ext_features)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_read_remote_ext_features(hci,\n\n                            PARAMHANDLE(read_remote_ext_features));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_VERSION):\n\n        LENGTH_CHECK(read_remote_version);\n\n\n\n        if (bt_hci_version_req(hci, PARAMHANDLE(read_remote_version)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_CLOCK_OFFSET):\n\n        LENGTH_CHECK(read_clock_offset);\n\n\n\n        if (bt_hci_clkoffset_req(hci, PARAMHANDLE(read_clock_offset)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_LMP_HANDLE):\n\n        LENGTH_CHECK(read_lmp_handle);\n\n\n\n        /* TODO: */\n\n        bt_hci_event_complete_lmp_handle(hci, PARAMHANDLE(read_lmp_handle));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_HOLD_MODE):\n\n        LENGTH_CHECK(hold_mode);\n\n\n\n        if (PARAM16(hold_mode, min_interval) >\n\n                        PARAM16(hold_mode, max_interval) ||\n\n                        PARAM16(hold_mode, min_interval) < 0x0002 ||\n\n                        PARAM16(hold_mode, max_interval) > 0xff00 ||\n\n                        (PARAM16(hold_mode, min_interval) & 1) ||\n\n                        (PARAM16(hold_mode, max_interval) & 1)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        if (bt_hci_mode_change(hci, PARAMHANDLE(hold_mode),\n\n                                PARAM16(hold_mode, max_interval),\n\n                                acl_hold))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_PARK_MODE):\n\n        LENGTH_CHECK(park_mode);\n\n\n\n        if (PARAM16(park_mode, min_interval) >\n\n                        PARAM16(park_mode, max_interval) ||\n\n                        PARAM16(park_mode, min_interval) < 0x000e ||\n\n                        (PARAM16(park_mode, min_interval) & 1) ||\n\n                        (PARAM16(park_mode, max_interval) & 1)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        if (bt_hci_mode_change(hci, PARAMHANDLE(park_mode),\n\n                                PARAM16(park_mode, max_interval),\n\n                                acl_parked))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_EXIT_PARK_MODE):\n\n        LENGTH_CHECK(exit_park_mode);\n\n\n\n        if (bt_hci_mode_cancel(hci, PARAMHANDLE(exit_park_mode),\n\n                                acl_parked))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_ROLE_DISCOVERY):\n\n        LENGTH_CHECK(role_discovery);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(role_discovery)))\n\n            bt_hci_event_complete_role_discovery(hci,\n\n                            HCI_NO_CONNECTION, PARAMHANDLE(role_discovery), 0);\n\n        else\n\n            bt_hci_event_complete_role_discovery(hci,\n\n                            HCI_SUCCESS, PARAMHANDLE(role_discovery),\n\n                            bt_hci_role_master(hci,\n\n                                    PARAMHANDLE(role_discovery)));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_SET_EVENT_MASK):\n\n        LENGTH_CHECK(set_event_mask);\n\n\n\n        memcpy(hci->event_mask, PARAM(set_event_mask, mask), 8);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_RESET):\n\n        bt_hci_reset(hci);\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_SET_EVENT_FLT):\n\n        if (length >= 1 && PARAM(set_event_flt, flt_type) == FLT_CLEAR_ALL)\n\n            /* No length check */;\n\n        else\n\n            LENGTH_CHECK(set_event_flt);\n\n\n\n        /* Filters are not implemented */\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_FLUSH):\n\n        LENGTH_CHECK(flush);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(flush)))\n\n            bt_hci_event_complete_flush(hci,\n\n                            HCI_NO_CONNECTION, PARAMHANDLE(flush));\n\n        else {\n\n            /* TODO: ordering? */\n\n            bt_hci_event(hci, EVT_FLUSH_OCCURRED,\n\n                            &PARAM(flush, handle),\n\n                            EVT_FLUSH_OCCURRED_SIZE);\n\n            bt_hci_event_complete_flush(hci,\n\n                            HCI_SUCCESS, PARAMHANDLE(flush));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_CHANGE_LOCAL_NAME):\n\n        LENGTH_CHECK(change_local_name);\n\n\n\n        if (hci->device.lmp_name)\n\n            free((void *) hci->device.lmp_name);\n\n        hci->device.lmp_name = strndup(PARAM(change_local_name, name),\n\n                        sizeof(PARAM(change_local_name, name)));\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_LOCAL_NAME):\n\n        bt_hci_event_complete_read_local_name(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_CONN_ACCEPT_TIMEOUT):\n\n        bt_hci_event_complete_read_conn_accept_timeout(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_CONN_ACCEPT_TIMEOUT):\n\n        /* TODO */\n\n        LENGTH_CHECK(write_conn_accept_timeout);\n\n\n\n        if (PARAM16(write_conn_accept_timeout, timeout) < 0x0001 ||\n\n                        PARAM16(write_conn_accept_timeout, timeout) > 0xb540) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->conn_accept_tout = PARAM16(write_conn_accept_timeout, timeout);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_SCAN_ENABLE):\n\n        bt_hci_event_complete_read_scan_enable(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_SCAN_ENABLE):\n\n        LENGTH_CHECK(write_scan_enable);\n\n\n\n        /* TODO: check that the remaining bits are all 0 */\n\n        hci->device.inquiry_scan =\n\n                !!(PARAM(write_scan_enable, scan_enable) & SCAN_INQUIRY);\n\n        hci->device.page_scan =\n\n                !!(PARAM(write_scan_enable, scan_enable) & SCAN_PAGE);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_CLASS_OF_DEV):\n\n        bt_hci_event_complete_read_local_class(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_CLASS_OF_DEV):\n\n        LENGTH_CHECK(write_class_of_dev);\n\n\n\n        memcpy(hci->device.class, PARAM(write_class_of_dev, dev_class),\n\n                        sizeof(PARAM(write_class_of_dev, dev_class)));\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_VOICE_SETTING):\n\n        bt_hci_event_complete_voice_setting(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_VOICE_SETTING):\n\n        LENGTH_CHECK(write_voice_setting);\n\n\n\n        hci->voice_setting = PARAM(write_voice_setting, voice_setting);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_HOST_NUMBER_OF_COMPLETED_PACKETS):\n\n        if (length < data[0] * 2 + 1)\n\n            goto short_hci;\n\n\n\n        for (i = 0; i < data[0]; i ++)\n\n            if (bt_hci_handle_bad(hci,\n\n                                    data[i * 2 + 1] | (data[i * 2 + 2] << 8)))\n\n                bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_INQUIRY_MODE):\n\n        /* Only if (local_features[3] & 0x40) && (local_commands[12] & 0x40)\n\n         * else\n\n         *     goto unknown_command */\n\n        bt_hci_event_complete_read_inquiry_mode(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_INQUIRY_MODE):\n\n        /* Only if (local_features[3] & 0x40) && (local_commands[12] & 0x80)\n\n         * else\n\n         *     goto unknown_command */\n\n        LENGTH_CHECK(write_inquiry_mode);\n\n\n\n        if (PARAM(write_inquiry_mode, mode) > 0x01) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquiry_mode = PARAM(write_inquiry_mode, mode);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_VERSION):\n\n        bt_hci_read_local_version_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_COMMANDS):\n\n        bt_hci_read_local_commands_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_FEATURES):\n\n        bt_hci_read_local_features_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_EXT_FEATURES):\n\n        LENGTH_CHECK(read_local_ext_features);\n\n\n\n        bt_hci_read_local_ext_features_rp(hci,\n\n                        PARAM(read_local_ext_features, page_num));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BUFFER_SIZE):\n\n        bt_hci_read_buffer_size_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_COUNTRY_CODE):\n\n        bt_hci_read_country_code_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BD_ADDR):\n\n        bt_hci_read_bd_addr_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_STATUS_PARAM, OCF_READ_LINK_QUALITY):\n\n        LENGTH_CHECK(read_link_quality);\n\n\n\n        bt_hci_link_quality_rp(hci, PARAMHANDLE(read_link_quality));\n\n        break;\n\n\n\n    default:\n\n        bt_hci_event_status(hci, HCI_UNKNOWN_COMMAND);\n\n        break;\n\n\n\n    short_hci:\n\n        fprintf(stderr, \"%s: HCI packet too short (%iB)\\n\",\n\n                        __FUNCTION__, length);\n\n        bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n        break;\n\n    }\n\n}\n", "idx": 21100, "_split": "test", "_hash": "09f488336d240f91730cb59ab9a76722"}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static int kvm_s390_register_io_adapter(S390FLICState *fs, uint32_t id,\n\n                                        uint8_t isc, bool swap,\n\n                                        bool is_maskable)\n\n{\n\n    struct kvm_s390_io_adapter adapter = {\n\n        .id = id,\n\n        .isc = isc,\n\n        .maskable = is_maskable,\n\n        .swap = swap,\n\n    };\n\n    KVMS390FLICState *flic = KVM_S390_FLIC(fs);\n\n    int r, ret;\n\n    struct kvm_device_attr attr = {\n\n        .group = KVM_DEV_FLIC_ADAPTER_REGISTER,\n\n        .addr = (uint64_t)&adapter,\n\n    };\n\n\n\n    if (!kvm_check_extension(kvm_state, KVM_CAP_IRQ_ROUTING)) {\n\n        /* nothing to do */\n\n        return 0;\n\n    }\n\n\n\n    r = ioctl(flic->fd, KVM_SET_DEVICE_ATTR, &attr);\n\n\n\n    ret = r ? -errno : 0;\n\n    return ret;\n\n}\n", "idx": 21102, "_split": "test", "_hash": "d5b756f590baf69d3eff0f7803101fbd"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void dec_calc(DisasContext *dc, uint32_t insn)\n\n{\n\n    uint32_t op0, op1, op2;\n\n    uint32_t ra, rb, rd;\n\n    op0 = extract32(insn, 0, 4);\n\n    op1 = extract32(insn, 8, 2);\n\n    op2 = extract32(insn, 6, 2);\n\n    ra = extract32(insn, 16, 5);\n\n    rb = extract32(insn, 11, 5);\n\n    rd = extract32(insn, 21, 5);\n\n\n\n    switch (op0) {\n\n    case 0x0000:\n\n        switch (op1) {\n\n        case 0x00:    /* l.add */\n\n            LOG_DIS(\"l.add r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_trunc_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0001:    /* l.addc */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.addc r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 tcy = tcg_temp_local_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_cy = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_andi_i32(sr_cy, cpu_sr, SR_CY);\n\n                tcg_gen_extu_i32_i64(tcy, sr_cy);\n\n                tcg_gen_shri_i64(tcy, tcy, 10);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_add_i64(td, td, tcy);\n\n                tcg_gen_trunc_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 32);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(tcy);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_cy);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0002:    /* l.sub */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.sub r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_sub_i64(td, ta, tb);\n\n                tcg_gen_trunc_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0003:    /* l.and */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.and r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_and_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0004:    /* l.or */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.or r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_or_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0005:\n\n        switch (op1) {\n\n        case 0x00:    /* l.xor */\n\n            LOG_DIS(\"l.xor r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_xor_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0006:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mul */\n\n            LOG_DIS(\"l.mul r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (ra != 0 && rb != 0) {\n\n                gen_helper_mul32(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0x0);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0009:\n\n        switch (op1) {\n\n        case 0x03:    /* l.div */\n\n            LOG_DIS(\"l.div r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab0 = gen_new_label();\n\n                int lab1 = gen_new_label();\n\n                int lab2 = gen_new_label();\n\n                int lab3 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[ra],\n\n                                       0x80000000, lab2);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0xffffffff, lab2);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab3);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab2);\n\n                    tcg_gen_div_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab3);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000a:\n\n        switch (op1) {\n\n        case 0x03:    /* l.divu */\n\n            LOG_DIS(\"l.divu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab0 = gen_new_label();\n\n                int lab1 = gen_new_label();\n\n                int lab2 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab2);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_divu_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab2);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000b:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mulu */\n\n            LOG_DIS(\"l.mulu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (rb != 0 && ra != 0) {\n\n                TCGv_i64 result = tcg_temp_local_new_i64();\n\n                TCGv_i64 tra = tcg_temp_local_new_i64();\n\n                TCGv_i64 trb = tcg_temp_local_new_i64();\n\n                TCGv_i64 high = tcg_temp_new_i64();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                int lab = gen_new_label();\n\n                /* Calculate each result. */\n\n                tcg_gen_extu_i32_i64(tra, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(trb, cpu_R[rb]);\n\n                tcg_gen_mul_i64(result, tra, trb);\n\n                tcg_temp_free_i64(tra);\n\n                tcg_temp_free_i64(trb);\n\n                tcg_gen_shri_i64(high, result, TARGET_LONG_BITS);\n\n                /* Overflow or not. */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, high, 0x00000000, lab);\n\n                tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_temp_free_i64(high);\n\n                tcg_gen_trunc_i64_tl(cpu_R[rd], result);\n\n                tcg_temp_free_i64(result);\n\n                tcg_temp_free_i32(sr_ove);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000e:\n\n        switch (op1) {\n\n        case 0x00:    /* l.cmov */\n\n            LOG_DIS(\"l.cmov r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv res = tcg_temp_local_new();\n\n                TCGv sr_f = tcg_temp_new();\n\n                tcg_gen_andi_tl(sr_f, cpu_sr, SR_F);\n\n                tcg_gen_mov_tl(res, cpu_R[rb]);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_f, SR_F, lab);\n\n                tcg_gen_mov_tl(res, cpu_R[ra]);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_tl(cpu_R[rd], res);\n\n                tcg_temp_free(sr_f);\n\n                tcg_temp_free(res);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000f:\n\n        switch (op1) {\n\n        case 0x00:    /* l.ff1 */\n\n            LOG_DIS(\"l.ff1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            gen_helper_ff1(cpu_R[rd], cpu_R[ra]);\n\n            break;\n\n        case 0x01:    /* l.fl1 */\n\n            LOG_DIS(\"l.fl1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            gen_helper_fl1(cpu_R[rd], cpu_R[ra]);\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0008:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.sll */\n\n                LOG_DIS(\"l.sll r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shl_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x01:    /* l.srl */\n\n                LOG_DIS(\"l.srl r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x02:    /* l.sra */\n\n                LOG_DIS(\"l.sra r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_sar_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x03:    /* l.ror */\n\n                LOG_DIS(\"l.ror r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_rotr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000c:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.exths */\n\n                LOG_DIS(\"l.exths r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extbs */\n\n                LOG_DIS(\"l.extbs r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x02:    /* l.exthz */\n\n                LOG_DIS(\"l.exthz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x03:    /* l.extbz */\n\n                LOG_DIS(\"l.extbz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000d:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.extws */\n\n                LOG_DIS(\"l.extws r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extwz */\n\n                LOG_DIS(\"l.extwz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        gen_illegal_exception(dc);\n\n        break;\n\n    }\n\n}\n", "idx": 21106, "_split": "test", "_hash": "202cb1c8291a92f48332155149d94f29"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)\n\n{\n\n    return timer_list->clock->type;\n\n}\n", "idx": 21110, "_split": "test", "_hash": "6858c2cc821e350c9ed755fb8e328e6e"}
{"project": "qemu", "commit_id": "e155494cf0b876c45c3c68a9ab6c641aac22dfdf", "target": 1, "func": "static void qio_channel_command_finalize(Object *obj)\n\n{\n\n    QIOChannelCommand *ioc = QIO_CHANNEL_COMMAND(obj);\n\n    if (ioc->readfd != -1) {\n\n        close(ioc->readfd);\n\n        ioc->readfd = -1;\n\n    }\n\n    if (ioc->writefd != -1) {\n\n        close(ioc->writefd);\n\n        ioc->writefd = -1;\n\n    }\n\n    if (ioc->pid > 0) {\n\n#ifndef WIN32\n\n        qio_channel_command_abort(ioc, NULL);\n\n#endif\n\n    }\n\n}\n", "idx": 21135, "_split": "test", "_hash": "e7925b1fd9fc92ad43a7218f7aa9c304"}
{"project": "qemu", "commit_id": "f37343197708d90f119007ce5ecc2503be9c04c1", "target": 0, "func": "void slirp_select_poll(fd_set *readfds, fd_set *writefds, fd_set *xfds,\n\n                       int select_error)\n\n{\n\n    Slirp *slirp;\n\n    struct socket *so, *so_next;\n\n    int ret;\n\n\n\n    if (QTAILQ_EMPTY(&slirp_instances)) {\n\n        return;\n\n    }\n\n\n\n    global_readfds = readfds;\n\n    global_writefds = writefds;\n\n    global_xfds = xfds;\n\n\n\n    curtime = qemu_get_clock_ms(rt_clock);\n\n\n\n    QTAILQ_FOREACH(slirp, &slirp_instances, entry) {\n\n\t/*\n\n\t * See if anything has timed out\n\n\t */\n\n\t\tif (time_fasttimo && ((curtime - time_fasttimo) >= 2)) {\n\n\t\t\ttcp_fasttimo(slirp);\n\n\t\t\ttime_fasttimo = 0;\n\n\t\t}\n\n\t\tif (do_slowtimo && ((curtime - last_slowtimo) >= 499)) {\n\n\t\t\tip_slowtimo(slirp);\n\n\t\t\ttcp_slowtimo(slirp);\n\n\t\t\tlast_slowtimo = curtime;\n\n\t\t}\n\n\n\n\t/*\n\n\t * Check sockets\n\n\t */\n\n\tif (!select_error) {\n\n\t\t/*\n\n\t\t * Check TCP sockets\n\n\t\t */\n\n\t\tfor (so = slirp->tcb.so_next; so != &slirp->tcb;\n\n\t\t     so = so_next) {\n\n\t\t\tso_next = so->so_next;\n\n\n\n\t\t\t/*\n\n\t\t\t * FD_ISSET is meaningless on these sockets\n\n\t\t\t * (and they can crash the program)\n\n\t\t\t */\n\n\t\t\tif (so->so_state & SS_NOFDREF || so->s == -1)\n\n\t\t\t   continue;\n\n\n\n\t\t\t/*\n\n\t\t\t * Check for URG data\n\n\t\t\t * This will soread as well, so no need to\n\n\t\t\t * test for readfds below if this succeeds\n\n\t\t\t */\n\n\t\t\tif (FD_ISSET(so->s, xfds))\n\n\t\t\t   sorecvoob(so);\n\n\t\t\t/*\n\n\t\t\t * Check sockets for reading\n\n\t\t\t */\n\n\t\t\telse if (FD_ISSET(so->s, readfds)) {\n\n\t\t\t\t/*\n\n\t\t\t\t * Check for incoming connections\n\n\t\t\t\t */\n\n\t\t\t\tif (so->so_state & SS_FACCEPTCONN) {\n\n\t\t\t\t\ttcp_connect(so);\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t} /* else */\n\n\t\t\t\tret = soread(so);\n\n\n\n\t\t\t\t/* Output it if we read something */\n\n\t\t\t\tif (ret > 0)\n\n\t\t\t\t   tcp_output(sototcpcb(so));\n\n\t\t\t}\n\n\n\n\t\t\t/*\n\n\t\t\t * Check sockets for writing\n\n\t\t\t */\n\n\t\t\tif (FD_ISSET(so->s, writefds)) {\n\n\t\t\t  /*\n\n\t\t\t   * Check for non-blocking, still-connecting sockets\n\n\t\t\t   */\n\n\t\t\t  if (so->so_state & SS_ISFCONNECTING) {\n\n\t\t\t    /* Connected */\n\n\t\t\t    so->so_state &= ~SS_ISFCONNECTING;\n\n\n\n\t\t\t    ret = send(so->s, (const void *) &ret, 0, 0);\n\n\t\t\t    if (ret < 0) {\n\n\t\t\t      /* XXXXX Must fix, zero bytes is a NOP */\n\n\t\t\t      if (errno == EAGAIN || errno == EWOULDBLOCK ||\n\n\t\t\t\t  errno == EINPROGRESS || errno == ENOTCONN)\n\n\t\t\t\tcontinue;\n\n\n\n\t\t\t      /* else failed */\n\n\t\t\t      so->so_state &= SS_PERSISTENT_MASK;\n\n\t\t\t      so->so_state |= SS_NOFDREF;\n\n\t\t\t    }\n\n\t\t\t    /* else so->so_state &= ~SS_ISFCONNECTING; */\n\n\n\n\t\t\t    /*\n\n\t\t\t     * Continue tcp_input\n\n\t\t\t     */\n\n\t\t\t    tcp_input((struct mbuf *)NULL, sizeof(struct ip), so);\n\n\t\t\t    /* continue; */\n\n\t\t\t  } else\n\n\t\t\t    ret = sowrite(so);\n\n\t\t\t  /*\n\n\t\t\t   * XXXXX If we wrote something (a lot), there\n\n\t\t\t   * could be a need for a window update.\n\n\t\t\t   * In the worst case, the remote will send\n\n\t\t\t   * a window probe to get things going again\n\n\t\t\t   */\n\n\t\t\t}\n\n\n\n\t\t\t/*\n\n\t\t\t * Probe a still-connecting, non-blocking socket\n\n\t\t\t * to check if it's still alive\n\n\t \t \t */\n\n#ifdef PROBE_CONN\n\n\t\t\tif (so->so_state & SS_ISFCONNECTING) {\n\n                          ret = qemu_recv(so->s, &ret, 0,0);\n\n\n\n\t\t\t  if (ret < 0) {\n\n\t\t\t    /* XXX */\n\n\t\t\t    if (errno == EAGAIN || errno == EWOULDBLOCK ||\n\n\t\t\t\terrno == EINPROGRESS || errno == ENOTCONN)\n\n\t\t\t      continue; /* Still connecting, continue */\n\n\n\n\t\t\t    /* else failed */\n\n\t\t\t    so->so_state &= SS_PERSISTENT_MASK;\n\n\t\t\t    so->so_state |= SS_NOFDREF;\n\n\n\n\t\t\t    /* tcp_input will take care of it */\n\n\t\t\t  } else {\n\n\t\t\t    ret = send(so->s, &ret, 0,0);\n\n\t\t\t    if (ret < 0) {\n\n\t\t\t      /* XXX */\n\n\t\t\t      if (errno == EAGAIN || errno == EWOULDBLOCK ||\n\n\t\t\t\t  errno == EINPROGRESS || errno == ENOTCONN)\n\n\t\t\t\tcontinue;\n\n\t\t\t      /* else failed */\n\n\t\t\t      so->so_state &= SS_PERSISTENT_MASK;\n\n\t\t\t      so->so_state |= SS_NOFDREF;\n\n\t\t\t    } else\n\n\t\t\t      so->so_state &= ~SS_ISFCONNECTING;\n\n\n\n\t\t\t  }\n\n\t\t\t  tcp_input((struct mbuf *)NULL, sizeof(struct ip),so);\n\n\t\t\t} /* SS_ISFCONNECTING */\n\n#endif\n\n\t\t}\n\n\n\n\t\t/*\n\n\t\t * Now UDP sockets.\n\n\t\t * Incoming packets are sent straight away, they're not buffered.\n\n\t\t * Incoming UDP data isn't buffered either.\n\n\t\t */\n\n\t\tfor (so = slirp->udb.so_next; so != &slirp->udb;\n\n\t\t     so = so_next) {\n\n\t\t\tso_next = so->so_next;\n\n\n\n\t\t\tif (so->s != -1 && FD_ISSET(so->s, readfds)) {\n\n                            sorecvfrom(so);\n\n                        }\n\n\t\t}\n\n\n\n                /*\n\n                 * Check incoming ICMP relies.\n\n                 */\n\n                for (so = slirp->icmp.so_next; so != &slirp->icmp;\n\n                     so = so_next) {\n\n                     so_next = so->so_next;\n\n\n\n                    if (so->s != -1 && FD_ISSET(so->s, readfds)) {\n\n                        icmp_receive(so);\n\n                    }\n\n                }\n\n\t}\n\n\n\n\t/*\n\n\t * See if we can start outputting\n\n\t */\n\n\tif (slirp->if_queued) {\n\n\t    if_start(slirp);\n\n\t}\n\n    }\n\n\n\n\t/* clear global file descriptor sets.\n\n\t * these reside on the stack in vl.c\n\n\t * so they're unusable if we're not in\n\n\t * slirp_select_fill or slirp_select_poll.\n\n\t */\n\n\t global_readfds = NULL;\n\n\t global_writefds = NULL;\n\n\t global_xfds = NULL;\n\n}\n", "idx": 21202, "_split": "test", "_hash": "3401d492e8cf281f9184babbacc681a9"}
{"project": "qemu", "commit_id": "970d622e8ab1de8fdf5762e23e92a2dea9d7d36c", "target": 0, "func": "uint64_t helper_cmpbge (uint64_t op1, uint64_t op2)\n\n{\n\n    uint8_t opa, opb, res;\n\n    int i;\n\n\n\n    res = 0;\n\n    for (i = 0; i < 7; i++) {\n\n        opa = op1 >> (i * 8);\n\n        opb = op2 >> (i * 8);\n\n        if (opa >= opb)\n\n            res |= 1 << i;\n\n    }\n\n    return res;\n\n}\n", "idx": 21218, "_split": "test", "_hash": "c00da34a8c8f5508ea6f48b30564f61f"}
{"project": "qemu", "commit_id": "7b527b86eb3560d68f41218cec0cdf3d60a38323", "target": 0, "func": "static int s390_ipl_init(SysBusDevice *dev)\n\n{\n\n    S390IPLState *ipl = S390_IPL(dev);\n\n    uint64_t pentry = KERN_IMAGE_START;\n\n    int kernel_size;\n\n\n\n    int bios_size;\n\n    char *bios_filename;\n\n\n\n    /*\n\n     * Always load the bios if it was enforced,\n\n     * even if an external kernel has been defined.\n\n     */\n\n    if (!ipl->kernel || ipl->enforce_bios) {\n\n        uint64_t fwbase = (MIN(ram_size, 0x80000000U) - 0x200000) & ~0xffffUL;\n\n\n\n        if (bios_name == NULL) {\n\n            bios_name = ipl->firmware;\n\n        }\n\n\n\n        bios_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (bios_filename == NULL) {\n\n            hw_error(\"could not find stage1 bootloader\\n\");\n\n        }\n\n\n\n        bios_size = load_elf(bios_filename, bios_translate_addr, &fwbase,\n\n                             &ipl->bios_start_addr, NULL, NULL, 1,\n\n                             ELF_MACHINE, 0);\n\n        if (bios_size > 0) {\n\n            /* Adjust ELF start address to final location */\n\n            ipl->bios_start_addr += fwbase;\n\n        } else {\n\n            /* Try to load non-ELF file (e.g. s390-zipl.rom) */\n\n            bios_size = load_image_targphys(bios_filename, ZIPL_IMAGE_START,\n\n                                            4096);\n\n            ipl->bios_start_addr = ZIPL_IMAGE_START;\n\n            if (bios_size > 4096) {\n\n                hw_error(\"stage1 bootloader is > 4k\\n\");\n\n            }\n\n        }\n\n        g_free(bios_filename);\n\n\n\n        if (bios_size == -1) {\n\n            hw_error(\"could not load bootloader '%s'\\n\", bios_name);\n\n        }\n\n\n\n        /* default boot target is the bios */\n\n        ipl->start_addr = ipl->bios_start_addr;\n\n    }\n\n\n\n    if (ipl->kernel) {\n\n        kernel_size = load_elf(ipl->kernel, NULL, NULL, &pentry, NULL,\n\n                               NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(ipl->kernel, 0, ram_size);\n\n        }\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"could not load kernel '%s'\\n\", ipl->kernel);\n\n            return -1;\n\n        }\n\n        /*\n\n         * Is it a Linux kernel (starting at 0x10000)? If yes, we fill in the\n\n         * kernel parameters here as well. Note: For old kernels (up to 3.2)\n\n         * we can not rely on the ELF entry point - it was 0x800 (the SALIPL\n\n         * loader) and it won't work. For this case we force it to 0x10000, too.\n\n         */\n\n        if (pentry == KERN_IMAGE_START || pentry == 0x800) {\n\n            ipl->start_addr = KERN_IMAGE_START;\n\n            /* Overwrite parameters in the kernel image, which are \"rom\" */\n\n            strcpy(rom_ptr(KERN_PARM_AREA), ipl->cmdline);\n\n        } else {\n\n            ipl->start_addr = pentry;\n\n        }\n\n\n\n        if (ipl->initrd) {\n\n            ram_addr_t initrd_offset;\n\n            int initrd_size;\n\n\n\n            initrd_offset = INITRD_START;\n\n            while (kernel_size + 0x100000 > initrd_offset) {\n\n                initrd_offset += 0x100000;\n\n            }\n\n            initrd_size = load_image_targphys(ipl->initrd, initrd_offset,\n\n                                              ram_size - initrd_offset);\n\n            if (initrd_size == -1) {\n\n                fprintf(stderr, \"qemu: could not load initrd '%s'\\n\",\n\n                        ipl->initrd);\n\n                exit(1);\n\n            }\n\n\n\n            /*\n\n             * we have to overwrite values in the kernel image,\n\n             * which are \"rom\"\n\n             */\n\n            stq_p(rom_ptr(INITRD_PARM_START), initrd_offset);\n\n            stq_p(rom_ptr(INITRD_PARM_SIZE), initrd_size);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 21219, "_split": "test", "_hash": "4f8689da7ba485d89438d4747b3795c3"}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "static int virtcon_parse(const char *devname)\n\n{\n\n    QemuOptsList *device = qemu_find_opts(\"device\");\n\n    static int index = 0;\n\n    char label[32];\n\n    QemuOpts *bus_opts, *dev_opts;\n\n\n\n    if (strcmp(devname, \"none\") == 0)\n\n        return 0;\n\n    if (index == MAX_VIRTIO_CONSOLES) {\n\n        fprintf(stderr, \"qemu: too many virtio consoles\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    bus_opts = qemu_opts_create(device, NULL, 0);\n\n    if (arch_type == QEMU_ARCH_S390X) {\n\n        qemu_opt_set(bus_opts, \"driver\", \"virtio-serial-s390\");\n\n    } else {\n\n        qemu_opt_set(bus_opts, \"driver\", \"virtio-serial-pci\");\n\n    } \n\n\n\n    dev_opts = qemu_opts_create(device, NULL, 0);\n\n    qemu_opt_set(dev_opts, \"driver\", \"virtconsole\");\n\n\n\n    snprintf(label, sizeof(label), \"virtcon%d\", index);\n\n    virtcon_hds[index] = qemu_chr_new(label, devname, NULL);\n\n    if (!virtcon_hds[index]) {\n\n        fprintf(stderr, \"qemu: could not open virtio console '%s': %s\\n\",\n\n                devname, strerror(errno));\n\n        return -1;\n\n    }\n\n    qemu_opt_set(dev_opts, \"chardev\", label);\n\n\n\n    index++;\n\n    return 0;\n\n}\n", "idx": 21250, "_split": "test", "_hash": "b13c25136206bdbe8666a1186392876e"}
{"project": "qemu", "commit_id": "6cff3e8594cd974a507d531da09455d1c7aeb30d", "target": 0, "func": "static void monitor_puts(Monitor *mon, const char *str)\n\n{\n\n    char c;\n\n\n\n    for(;;) {\n\n        c = *str++;\n\n        if (c == '\\0')\n\n            break;\n\n        if (c == '\\n') {\n\n            qstring_append_chr(mon->outbuf, '\\r');\n\n        }\n\n        qstring_append_chr(mon->outbuf, c);\n\n        if (c == '\\n') {\n\n            monitor_flush(mon);\n\n        }\n\n    }\n\n}\n", "idx": 21256, "_split": "test", "_hash": "b945847df0f4ca38bcbab932b8172df5"}
{"project": "qemu", "commit_id": "1e39d97af086d525cd0408eaa5d19783ea165906", "target": 0, "func": "static void gen_movl_seg_T0(DisasContext *s, int seg_reg)\n\n{\n\n    if (s->pe && !s->vm86) {\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);\n\n        /* abort translation because the addseg value may change or\n\n           because ss32 may change. For R_SS, translation must always\n\n           stop as a special handling must be done to disable hardware\n\n           interrupts for the next instruction */\n\n        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))\n\n            s->is_jmp = DISAS_TB_JUMP;\n\n    } else {\n\n        gen_op_movl_seg_T0_vm(seg_reg);\n\n        if (seg_reg == R_SS)\n\n            s->is_jmp = DISAS_TB_JUMP;\n\n    }\n\n}\n", "idx": 21261, "_split": "test", "_hash": "2898a27a3d28f47b51cd2f23944ee115"}
{"project": "qemu", "commit_id": "5d98bf8f38c17a348ab6e8af196088cd4953acd0", "target": 0, "func": "void gen_intermediate_code_a64(ARMCPU *cpu, TranslationBlock *tb)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUARMState *env = &cpu->env;\n\n    DisasContext dc1, *dc = &dc1;\n\n    target_ulong pc_start;\n\n    target_ulong next_page_start;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n\n\n    dc->tb = tb;\n\n\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->pc = pc_start;\n\n    dc->singlestep_enabled = cs->singlestep_enabled;\n\n    dc->condjmp = 0;\n\n\n\n    dc->aarch64 = 1;\n\n    /* If we are coming from secure EL0 in a system with a 32-bit EL3, then\n\n     * there is no secure EL1, so we route exceptions to EL3.\n\n     */\n\n    dc->secure_routed_to_el3 = arm_feature(env, ARM_FEATURE_EL3) &&\n\n                               !arm_el_is_aa64(env, 3);\n\n    dc->thumb = 0;\n\n    dc->bswap_code = 0;\n\n    dc->condexec_mask = 0;\n\n    dc->condexec_cond = 0;\n\n    dc->mmu_idx = ARM_TBFLAG_MMUIDX(tb->flags);\n\n    dc->current_el = arm_mmu_idx_to_el(dc->mmu_idx);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    dc->user = (dc->current_el == 0);\n\n#endif\n\n    dc->fp_excp_el = ARM_TBFLAG_FPEXC_EL(tb->flags);\n\n    dc->vec_len = 0;\n\n    dc->vec_stride = 0;\n\n    dc->cp_regs = cpu->cp_regs;\n\n    dc->features = env->features;\n\n\n\n    /* Single step state. The code-generation logic here is:\n\n     *  SS_ACTIVE == 0:\n\n     *   generate code with no special handling for single-stepping (except\n\n     *   that anything that can make us go to SS_ACTIVE == 1 must end the TB;\n\n     *   this happens anyway because those changes are all system register or\n\n     *   PSTATE writes).\n\n     *  SS_ACTIVE == 1, PSTATE.SS == 1: (active-not-pending)\n\n     *   emit code for one insn\n\n     *   emit code to clear PSTATE.SS\n\n     *   emit code to generate software step exception for completed step\n\n     *   end TB (as usual for having generated an exception)\n\n     *  SS_ACTIVE == 1, PSTATE.SS == 0: (active-pending)\n\n     *   emit code to generate a software step exception\n\n     *   end the TB\n\n     */\n\n    dc->ss_active = ARM_TBFLAG_SS_ACTIVE(tb->flags);\n\n    dc->pstate_ss = ARM_TBFLAG_PSTATE_SS(tb->flags);\n\n    dc->is_ldex = false;\n\n    dc->ss_same_el = (arm_debug_target_el(env) == dc->current_el);\n\n\n\n    init_tmp_a64_array(dc);\n\n\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0) {\n\n        max_insns = CF_COUNT_MASK;\n\n    }\n\n    if (max_insns > TCG_MAX_INSNS) {\n\n        max_insns = TCG_MAX_INSNS;\n\n    }\n\n\n\n    gen_tb_start(tb);\n\n\n\n    tcg_clear_temp_count();\n\n\n\n    do {\n\n        tcg_gen_insn_start(dc->pc, 0);\n\n        num_insns++;\n\n\n\n        if (unlikely(!QTAILQ_EMPTY(&cs->breakpoints))) {\n\n            CPUBreakpoint *bp;\n\n            QTAILQ_FOREACH(bp, &cs->breakpoints, entry) {\n\n                if (bp->pc == dc->pc) {\n\n                    gen_exception_internal_insn(dc, 0, EXCP_DEBUG);\n\n                    /* Advance PC so that clearing the breakpoint will\n\n                       invalidate this TB.  */\n\n                    dc->pc += 2;\n\n                    goto done_generating;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (num_insns == max_insns && (tb->cflags & CF_LAST_IO)) {\n\n            gen_io_start();\n\n        }\n\n\n\n        if (dc->ss_active && !dc->pstate_ss) {\n\n            /* Singlestep state is Active-pending.\n\n             * If we're in this state at the start of a TB then either\n\n             *  a) we just took an exception to an EL which is being debugged\n\n             *     and this is the first insn in the exception handler\n\n             *  b) debug exceptions were masked and we just unmasked them\n\n             *     without changing EL (eg by clearing PSTATE.D)\n\n             * In either case we're going to take a swstep exception in the\n\n             * \"did not step an insn\" case, and so the syndrome ISV and EX\n\n             * bits should be zero.\n\n             */\n\n            assert(num_insns == 1);\n\n            gen_exception(EXCP_UDEF, syn_swstep(dc->ss_same_el, 0, 0),\n\n                          default_exception_el(dc));\n\n            dc->is_jmp = DISAS_EXC;\n\n            break;\n\n        }\n\n\n\n        disas_a64_insn(env, dc);\n\n\n\n        if (tcg_check_temp_count()) {\n\n            fprintf(stderr, \"TCG temporary leak before \"TARGET_FMT_lx\"\\n\",\n\n                    dc->pc);\n\n        }\n\n\n\n        /* Translation stops when a conditional branch is encountered.\n\n         * Otherwise the subsequent code could get translated several times.\n\n         * Also stop translation when a page boundary is reached.  This\n\n         * ensures prefetch aborts occur at the right place.\n\n         */\n\n    } while (!dc->is_jmp && !tcg_op_buf_full() &&\n\n             !cs->singlestep_enabled &&\n\n             !singlestep &&\n\n             !dc->ss_active &&\n\n             dc->pc < next_page_start &&\n\n             num_insns < max_insns);\n\n\n\n    if (tb->cflags & CF_LAST_IO) {\n\n        gen_io_end();\n\n    }\n\n\n\n    if (unlikely(cs->singlestep_enabled || dc->ss_active)\n\n        && dc->is_jmp != DISAS_EXC) {\n\n        /* Note that this means single stepping WFI doesn't halt the CPU.\n\n         * For conditional branch insns this is harmless unreachable code as\n\n         * gen_goto_tb() has already handled emitting the debug exception\n\n         * (and thus a tb-jump is not possible when singlestepping).\n\n         */\n\n        assert(dc->is_jmp != DISAS_TB_JUMP);\n\n        if (dc->is_jmp != DISAS_JUMP) {\n\n            gen_a64_set_pc_im(dc->pc);\n\n        }\n\n        if (cs->singlestep_enabled) {\n\n            gen_exception_internal(EXCP_DEBUG);\n\n        } else {\n\n            gen_step_complete_exception(dc);\n\n        }\n\n    } else {\n\n        switch (dc->is_jmp) {\n\n        case DISAS_NEXT:\n\n            gen_goto_tb(dc, 1, dc->pc);\n\n            break;\n\n        default:\n\n        case DISAS_UPDATE:\n\n            gen_a64_set_pc_im(dc->pc);\n\n            /* fall through */\n\n        case DISAS_JUMP:\n\n            /* indicate that the hash table must be used to find the next TB */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case DISAS_TB_JUMP:\n\n        case DISAS_EXC:\n\n        case DISAS_SWI:\n\n            break;\n\n        case DISAS_WFE:\n\n            gen_a64_set_pc_im(dc->pc);\n\n            gen_helper_wfe(cpu_env);\n\n            break;\n\n        case DISAS_YIELD:\n\n            gen_a64_set_pc_im(dc->pc);\n\n            gen_helper_yield(cpu_env);\n\n            break;\n\n        case DISAS_WFI:\n\n            /* This is a special case because we don't want to just halt the CPU\n\n             * if trying to debug across a WFI.\n\n             */\n\n            gen_a64_set_pc_im(dc->pc);\n\n            gen_helper_wfi(cpu_env);\n\n            /* The helper doesn't necessarily throw an exception, but we\n\n             * must go back to the main loop to check for interrupts anyway.\n\n             */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        }\n\n    }\n\n\n\ndone_generating:\n\n    gen_tb_end(tb, num_insns);\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"----------------\\n\");\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(cs, pc_start, dc->pc - pc_start,\n\n                         4 | (dc->bswap_code << 1));\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n    tb->size = dc->pc - pc_start;\n\n    tb->icount = num_insns;\n\n}\n", "idx": 21267, "_split": "test", "_hash": "caa161aa992b06b3e2e325b93e2f4eca"}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)\n\n{\n\n    NvmeNamespace *ns;\n\n    uint32_t nsid = le32_to_cpu(cmd->nsid);\n\n\n\n    if (nsid == 0 || nsid > n->num_namespaces) {\n\n        return NVME_INVALID_NSID | NVME_DNR;\n\n    }\n\n\n\n    ns = &n->namespaces[nsid - 1];\n\n    switch (cmd->opcode) {\n\n    case NVME_CMD_FLUSH:\n\n        return nvme_flush(n, ns, cmd, req);\n\n    case NVME_CMD_WRITE_ZEROS:\n\n        return nvme_write_zeros(n, ns, cmd, req);\n\n    case NVME_CMD_WRITE:\n\n    case NVME_CMD_READ:\n\n        return nvme_rw(n, ns, cmd, req);\n\n    default:\n\n        return NVME_INVALID_OPCODE | NVME_DNR;\n\n    }\n\n}\n", "idx": 21296, "_split": "test", "_hash": "c42b92ed0366badf72244b3c6b99a30d"}
{"project": "qemu", "commit_id": "375cb560295484b88898262ebf400eff9a011206", "target": 0, "func": "static uint64_t pl110_read(void *opaque, hwaddr offset,\n\n                           unsigned size)\n\n{\n\n    pl110_state *s = (pl110_state *)opaque;\n\n\n\n    if (offset >= 0xfe0 && offset < 0x1000) {\n\n        return idregs[s->version][(offset - 0xfe0) >> 2];\n\n    }\n\n    if (offset >= 0x200 && offset < 0x400) {\n\n        return s->raw_palette[(offset - 0x200) >> 2];\n\n    }\n\n    switch (offset >> 2) {\n\n    case 0: /* LCDTiming0 */\n\n        return s->timing[0];\n\n    case 1: /* LCDTiming1 */\n\n        return s->timing[1];\n\n    case 2: /* LCDTiming2 */\n\n        return s->timing[2];\n\n    case 3: /* LCDTiming3 */\n\n        return s->timing[3];\n\n    case 4: /* LCDUPBASE */\n\n        return s->upbase;\n\n    case 5: /* LCDLPBASE */\n\n        return s->lpbase;\n\n    case 6: /* LCDIMSC */\n\n        if (s->version != PL110) {\n\n            return s->cr;\n\n        }\n\n        return s->int_mask;\n\n    case 7: /* LCDControl */\n\n        if (s->version != PL110) {\n\n            return s->int_mask;\n\n        }\n\n        return s->cr;\n\n    case 8: /* LCDRIS */\n\n        return s->int_status;\n\n    case 9: /* LCDMIS */\n\n        return s->int_status & s->int_mask;\n\n    case 11: /* LCDUPCURR */\n\n        /* TODO: Implement vertical refresh.  */\n\n        return s->upbase;\n\n    case 12: /* LCDLPCURR */\n\n        return s->lpbase;\n\n    default:\n\n        hw_error(\"pl110_read: Bad offset %x\\n\", (int)offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 21306, "_split": "test", "_hash": "d12b04accd00fd5dac9dba643eca208b"}
{"project": "qemu", "commit_id": "1e577cc7cffd3de14dbd321de5c3ef191c6ab07f", "target": 0, "func": "void arm_cpu_dump_state(CPUState *cs, FILE *f, fprintf_function cpu_fprintf,\n\n                        int flags)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    int i;\n\n\n\n    if (is_a64(env)) {\n\n        aarch64_cpu_dump_state(cs, f, cpu_fprintf, flags);\n\n        return;\n\n    }\n\n\n\n    for(i=0;i<16;i++) {\n\n        cpu_fprintf(f, \"R%02d=%08x\", i, env->regs[i]);\n\n        if ((i % 4) == 3)\n\n            cpu_fprintf(f, \"\\n\");\n\n        else\n\n            cpu_fprintf(f, \" \");\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        uint32_t xpsr = xpsr_read(env);\n\n        const char *mode;\n\n\n\n        if (xpsr & XPSR_EXCP) {\n\n            mode = \"handler\";\n\n        } else {\n\n            if (env->v7m.control & R_V7M_CONTROL_NPRIV_MASK) {\n\n                mode = \"unpriv-thread\";\n\n            } else {\n\n                mode = \"priv-thread\";\n\n            }\n\n        }\n\n\n\n        cpu_fprintf(f, \"XPSR=%08x %c%c%c%c %c %s\\n\",\n\n                    xpsr,\n\n                    xpsr & XPSR_N ? 'N' : '-',\n\n                    xpsr & XPSR_Z ? 'Z' : '-',\n\n                    xpsr & XPSR_C ? 'C' : '-',\n\n                    xpsr & XPSR_V ? 'V' : '-',\n\n                    xpsr & XPSR_T ? 'T' : 'A',\n\n                    mode);\n\n    } else {\n\n        uint32_t psr = cpsr_read(env);\n\n        const char *ns_status = \"\";\n\n\n\n        if (arm_feature(env, ARM_FEATURE_EL3) &&\n\n            (psr & CPSR_M) != ARM_CPU_MODE_MON) {\n\n            ns_status = env->cp15.scr_el3 & SCR_NS ? \"NS \" : \"S \";\n\n        }\n\n\n\n        cpu_fprintf(f, \"PSR=%08x %c%c%c%c %c %s%s%d\\n\",\n\n                    psr,\n\n                    psr & CPSR_N ? 'N' : '-',\n\n                    psr & CPSR_Z ? 'Z' : '-',\n\n                    psr & CPSR_C ? 'C' : '-',\n\n                    psr & CPSR_V ? 'V' : '-',\n\n                    psr & CPSR_T ? 'T' : 'A',\n\n                    ns_status,\n\n                    cpu_mode_names[psr & 0xf], (psr & 0x10) ? 32 : 26);\n\n    }\n\n\n\n    if (flags & CPU_DUMP_FPU) {\n\n        int numvfpregs = 0;\n\n        if (arm_feature(env, ARM_FEATURE_VFP)) {\n\n            numvfpregs += 16;\n\n        }\n\n        if (arm_feature(env, ARM_FEATURE_VFP3)) {\n\n            numvfpregs += 16;\n\n        }\n\n        for (i = 0; i < numvfpregs; i++) {\n\n            uint64_t v = float64_val(env->vfp.regs[i]);\n\n            cpu_fprintf(f, \"s%02d=%08x s%02d=%08x d%02d=%016\" PRIx64 \"\\n\",\n\n                        i * 2, (uint32_t)v,\n\n                        i * 2 + 1, (uint32_t)(v >> 32),\n\n                        i, v);\n\n        }\n\n        cpu_fprintf(f, \"FPSCR: %08x\\n\", (int)env->vfp.xregs[ARM_VFP_FPSCR]);\n\n    }\n\n}\n", "idx": 21324, "_split": "test", "_hash": "6ececa0f29e22cd1b4ebe3d59a38069b"}
{"project": "qemu", "commit_id": "07d4e69147b4957e617812206a62a86f03294ad3", "target": 1, "func": "int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,\n\n                       void *opaque, int version_id)\n\n{\n\n    VMStateField *field = vmsd->fields;\n\n    int ret = 0;\n\n\n\n    trace_vmstate_load_state(vmsd->name, version_id);\n\n    if (version_id > vmsd->version_id) {\n\n        error_report(\"%s: incoming version_id %d is too new \"\n\n                     \"for local version_id %d\",\n\n                     vmsd->name, version_id, vmsd->version_id);\n\n        trace_vmstate_load_state_end(vmsd->name, \"too new\", -EINVAL);\n\n        return -EINVAL;\n\n    }\n\n    if  (version_id < vmsd->minimum_version_id) {\n\n        if (vmsd->load_state_old &&\n\n            version_id >= vmsd->minimum_version_id_old) {\n\n            ret = vmsd->load_state_old(f, opaque, version_id);\n\n            trace_vmstate_load_state_end(vmsd->name, \"old path\", ret);\n\n            return ret;\n\n        }\n\n        error_report(\"%s: incoming version_id %d is too old \"\n\n                     \"for local minimum version_id  %d\",\n\n                     vmsd->name, version_id, vmsd->minimum_version_id);\n\n        trace_vmstate_load_state_end(vmsd->name, \"too old\", -EINVAL);\n\n        return -EINVAL;\n\n    }\n\n    if (vmsd->pre_load) {\n\n        int ret = vmsd->pre_load(opaque);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n    }\n\n    while (field->name) {\n\n        trace_vmstate_load_state_field(vmsd->name, field->name);\n\n        if ((field->field_exists &&\n\n             field->field_exists(opaque, version_id)) ||\n\n            (!field->field_exists &&\n\n             field->version_id <= version_id)) {\n\n            void *first_elem = opaque + field->offset;\n\n            int i, n_elems = vmstate_n_elems(opaque, field);\n\n            int size = vmstate_size(opaque, field);\n\n\n\n            vmstate_handle_alloc(first_elem, field, opaque);\n\n            if (field->flags & VMS_POINTER) {\n\n                first_elem = *(void **)first_elem;\n\n                assert(first_elem  || !n_elems);\n\n            }\n\n            for (i = 0; i < n_elems; i++) {\n\n                void *curr_elem = first_elem + size * i;\n\n\n\n                if (field->flags & VMS_ARRAY_OF_POINTER) {\n\n                    curr_elem = *(void **)curr_elem;\n\n                }\n\n                if (field->flags & VMS_STRUCT) {\n\n                    ret = vmstate_load_state(f, field->vmsd, curr_elem,\n\n                                             field->vmsd->version_id);\n\n                } else {\n\n                    ret = field->info->get(f, curr_elem, size, field);\n\n                }\n\n                if (ret >= 0) {\n\n                    ret = qemu_file_get_error(f);\n\n                }\n\n                if (ret < 0) {\n\n                    qemu_file_set_error(f, ret);\n\n                    error_report(\"Failed to load %s:%s\", vmsd->name,\n\n                                 field->name);\n\n                    trace_vmstate_load_field_error(field->name, ret);\n\n                    return ret;\n\n                }\n\n            }\n\n        } else if (field->flags & VMS_MUST_EXIST) {\n\n            error_report(\"Input validation failed: %s/%s\",\n\n                         vmsd->name, field->name);\n\n            return -1;\n\n        }\n\n        field++;\n\n    }\n\n    ret = vmstate_subsection_load(f, vmsd, opaque);\n\n    if (ret != 0) {\n\n        return ret;\n\n    }\n\n    if (vmsd->post_load) {\n\n        ret = vmsd->post_load(opaque, version_id);\n\n    }\n\n    trace_vmstate_load_state_end(vmsd->name, \"end\", ret);\n\n    return ret;\n\n}\n", "idx": 21335, "_split": "test", "_hash": "7602e63d7d441230f3d916b8c5a2d348"}
{"project": "qemu", "commit_id": "b2dfd71c4843a762f2befe702adb249cf55baf66", "target": 0, "func": "static void xen_log_start(MemoryListener *listener,\n\n                          MemoryRegionSection *section)\n\n{\n\n    XenIOState *state = container_of(listener, XenIOState, memory_listener);\n\n\n\n    xen_sync_dirty_bitmap(state, section->offset_within_address_space,\n\n                          int128_get64(section->size));\n\n}\n", "idx": 21348, "_split": "test", "_hash": "80da514c7695bea9a91801ee325279a4"}
{"project": "qemu", "commit_id": "5efed5a172881f601ac3c57c22ec5c5721f895be", "target": 1, "func": "static void test_smbios_ep_address(test_data *data)\n\n{\n\n    uint32_t off;\n\n\n\n    /* find smbios entry point structure */\n\n    for (off = 0xf0000; off < 0x100000; off += 0x10) {\n\n        uint8_t sig[] = \"_SM_\";\n\n        int i;\n\n\n\n        for (i = 0; i < sizeof sig - 1; ++i) {\n\n            sig[i] = readb(off + i);\n\n        }\n\n\n\n        if (!memcmp(sig, \"_SM_\", sizeof sig)) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    g_assert_cmphex(off, <, 0x100000);\n\n    data->smbios_ep_addr = off;\n\n}\n", "idx": 21383, "_split": "test", "_hash": "f0a4b1a58192b956c3b09186c3a39475"}
{"project": "qemu", "commit_id": "4656e1f01289cc3aa20986deb6a407165826abe5", "target": 1, "func": "int cpu_ppc_handle_mmu_fault(CPUPPCState *env, target_ulong address, int rw,\n\n                             int mmu_idx)\n\n{\n\n    mmu_ctx_t ctx;\n\n    int access_type;\n\n    int ret = 0;\n\n\n\n    if (rw == 2) {\n\n        /* code access */\n\n        rw = 0;\n\n        access_type = ACCESS_CODE;\n\n    } else {\n\n        /* data access */\n\n        access_type = env->access_type;\n\n    }\n\n    ret = get_physical_address(env, &ctx, address, rw, access_type);\n\n    if (ret == 0) {\n\n        tlb_set_page(env, address & TARGET_PAGE_MASK,\n\n                     ctx.raddr & TARGET_PAGE_MASK, ctx.prot,\n\n                     mmu_idx, TARGET_PAGE_SIZE);\n\n        ret = 0;\n\n    } else if (ret < 0) {\n\n        LOG_MMU_STATE(env);\n\n        if (access_type == ACCESS_CODE) {\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables or TLB */\n\n                switch (env->mmu_model) {\n\n                case POWERPC_MMU_SOFT_6xx:\n\n                    env->exception_index = POWERPC_EXCP_IFTLB;\n\n                    env->error_code = 1 << 18;\n\n                    env->spr[SPR_IMISS] = address;\n\n                    env->spr[SPR_ICMP] = 0x80000000 | ctx.ptem;\n\n                    goto tlb_miss;\n\n                case POWERPC_MMU_SOFT_74xx:\n\n                    env->exception_index = POWERPC_EXCP_IFTLB;\n\n                    goto tlb_miss_74xx;\n\n                case POWERPC_MMU_SOFT_4xx:\n\n                case POWERPC_MMU_SOFT_4xx_Z:\n\n                    env->exception_index = POWERPC_EXCP_ITLB;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_40x_DEAR] = address;\n\n                    env->spr[SPR_40x_ESR] = 0x00000000;\n\n                    break;\n\n                case POWERPC_MMU_32B:\n\n                case POWERPC_MMU_601:\n\n#if defined(TARGET_PPC64)\n\n                case POWERPC_MMU_620:\n\n                case POWERPC_MMU_64B:\n\n                case POWERPC_MMU_2_06:\n\n\n#endif\n\n                    env->exception_index = POWERPC_EXCP_ISI;\n\n                    env->error_code = 0x40000000;\n\n                    break;\n\n                case POWERPC_MMU_BOOKE206:\n\n                    booke206_update_mas_tlb_miss(env, address, rw);\n\n                    /* fall through */\n\n                case POWERPC_MMU_BOOKE:\n\n                    env->exception_index = POWERPC_EXCP_ITLB;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_BOOKE_DEAR] = address;\n\n                    return -1;\n\n                case POWERPC_MMU_MPC8xx:\n\n                    /* XXX: TODO */\n\n                    cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n                    break;\n\n                case POWERPC_MMU_REAL:\n\n                    cpu_abort(env, \"PowerPC in real mode should never raise \"\n\n                              \"any MMU exceptions\\n\");\n\n                    return -1;\n\n                default:\n\n                    cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n                    return -1;\n\n                }\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x08000000;\n\n                break;\n\n            case -3:\n\n                /* No execute protection violation */\n\n                if ((env->mmu_model == POWERPC_MMU_BOOKE) ||\n\n                    (env->mmu_model == POWERPC_MMU_BOOKE206)) {\n\n                    env->spr[SPR_BOOKE_ESR] = 0x00000000;\n\n                }\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x10000000;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                /* No code fetch is allowed in direct-store areas */\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x10000000;\n\n                break;\n\n#if defined(TARGET_PPC64)\n\n            case -5:\n\n                /* No match in segment table */\n\n                if (env->mmu_model == POWERPC_MMU_620) {\n\n                    env->exception_index = POWERPC_EXCP_ISI;\n\n                    /* XXX: this might be incorrect */\n\n                    env->error_code = 0x40000000;\n\n                } else {\n\n                    env->exception_index = POWERPC_EXCP_ISEG;\n\n                    env->error_code = 0;\n\n                }\n\n                break;\n\n#endif\n\n            }\n\n        } else {\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables or TLB */\n\n                switch (env->mmu_model) {\n\n                case POWERPC_MMU_SOFT_6xx:\n\n                    if (rw == 1) {\n\n                        env->exception_index = POWERPC_EXCP_DSTLB;\n\n                        env->error_code = 1 << 16;\n\n                    } else {\n\n                        env->exception_index = POWERPC_EXCP_DLTLB;\n\n                        env->error_code = 0;\n\n                    }\n\n                    env->spr[SPR_DMISS] = address;\n\n                    env->spr[SPR_DCMP] = 0x80000000 | ctx.ptem;\n\n                tlb_miss:\n\n                    env->error_code |= ctx.key << 19;\n\n                    env->spr[SPR_HASH1] = env->htab_base +\n\n                        get_pteg_offset(env, ctx.hash[0], HASH_PTE_SIZE_32);\n\n                    env->spr[SPR_HASH2] = env->htab_base +\n\n                        get_pteg_offset(env, ctx.hash[1], HASH_PTE_SIZE_32);\n\n                    break;\n\n                case POWERPC_MMU_SOFT_74xx:\n\n                    if (rw == 1) {\n\n                        env->exception_index = POWERPC_EXCP_DSTLB;\n\n                    } else {\n\n                        env->exception_index = POWERPC_EXCP_DLTLB;\n\n                    }\n\n                tlb_miss_74xx:\n\n                    /* Implement LRU algorithm */\n\n                    env->error_code = ctx.key << 19;\n\n                    env->spr[SPR_TLBMISS] = (address & ~((target_ulong)0x3)) |\n\n                        ((env->last_way + 1) & (env->nb_ways - 1));\n\n                    env->spr[SPR_PTEHI] = 0x80000000 | ctx.ptem;\n\n                    break;\n\n                case POWERPC_MMU_SOFT_4xx:\n\n                case POWERPC_MMU_SOFT_4xx_Z:\n\n                    env->exception_index = POWERPC_EXCP_DTLB;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_40x_DEAR] = address;\n\n                    if (rw) {\n\n                        env->spr[SPR_40x_ESR] = 0x00800000;\n\n                    } else {\n\n                        env->spr[SPR_40x_ESR] = 0x00000000;\n\n                    }\n\n                    break;\n\n                case POWERPC_MMU_32B:\n\n                case POWERPC_MMU_601:\n\n#if defined(TARGET_PPC64)\n\n                case POWERPC_MMU_620:\n\n                case POWERPC_MMU_64B:\n\n                case POWERPC_MMU_2_06:\n\n\n#endif\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x42000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x40000000;\n\n                    }\n\n                    break;\n\n                case POWERPC_MMU_MPC8xx:\n\n                    /* XXX: TODO */\n\n                    cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n                    break;\n\n                case POWERPC_MMU_BOOKE206:\n\n                    booke206_update_mas_tlb_miss(env, address, rw);\n\n                    /* fall through */\n\n                case POWERPC_MMU_BOOKE:\n\n                    env->exception_index = POWERPC_EXCP_DTLB;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_BOOKE_DEAR] = address;\n\n                    env->spr[SPR_BOOKE_ESR] = rw ? ESR_ST : 0;\n\n                    return -1;\n\n                case POWERPC_MMU_REAL:\n\n                    cpu_abort(env, \"PowerPC in real mode should never raise \"\n\n                              \"any MMU exceptions\\n\");\n\n                    return -1;\n\n                default:\n\n                    cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n                    return -1;\n\n                }\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                env->exception_index = POWERPC_EXCP_DSI;\n\n                env->error_code = 0;\n\n                if (env->mmu_model == POWERPC_MMU_SOFT_4xx\n\n                    || env->mmu_model == POWERPC_MMU_SOFT_4xx_Z) {\n\n                    env->spr[SPR_40x_DEAR] = address;\n\n                    if (rw) {\n\n                        env->spr[SPR_40x_ESR] |= 0x00800000;\n\n                    }\n\n                } else if ((env->mmu_model == POWERPC_MMU_BOOKE) ||\n\n                           (env->mmu_model == POWERPC_MMU_BOOKE206)) {\n\n                    env->spr[SPR_BOOKE_DEAR] = address;\n\n                    env->spr[SPR_BOOKE_ESR] = rw ? ESR_ST : 0;\n\n                } else {\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x0A000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x08000000;\n\n                    }\n\n                }\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                switch (access_type) {\n\n                case ACCESS_FLOAT:\n\n                    /* Floating point load/store */\n\n                    env->exception_index = POWERPC_EXCP_ALIGN;\n\n                    env->error_code = POWERPC_EXCP_ALIGN_FP;\n\n                    env->spr[SPR_DAR] = address;\n\n                    break;\n\n                case ACCESS_RES:\n\n                    /* lwarx, ldarx or stwcx. */\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x06000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x04000000;\n\n                    }\n\n                    break;\n\n                case ACCESS_EXT:\n\n                    /* eciwx or ecowx */\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x06100000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x04100000;\n\n                    }\n\n                    break;\n\n                default:\n\n                    printf(\"DSI: invalid exception (%d)\\n\", ret);\n\n                    env->exception_index = POWERPC_EXCP_PROGRAM;\n\n                    env->error_code =\n\n                        POWERPC_EXCP_INVAL | POWERPC_EXCP_INVAL_INVAL;\n\n                    env->spr[SPR_DAR] = address;\n\n                    break;\n\n                }\n\n                break;\n\n#if defined(TARGET_PPC64)\n\n            case -5:\n\n                /* No match in segment table */\n\n                if (env->mmu_model == POWERPC_MMU_620) {\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    /* XXX: this might be incorrect */\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x42000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x40000000;\n\n                    }\n\n                } else {\n\n                    env->exception_index = POWERPC_EXCP_DSEG;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                }\n\n                break;\n\n#endif\n\n            }\n\n        }\n\n#if 0\n\n        printf(\"%s: set exception to %d %02x\\n\", __func__,\n\n               env->exception, env->error_code);\n\n#endif\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}", "idx": 21387, "_split": "test", "_hash": "b3be27bff5df12054d876b6f3eea6c04"}
{"project": "qemu", "commit_id": "bdd4df332a1bdb20b7fa39ea741f7830e41e1187", "target": 1, "func": "void qemu_spice_display_init(DisplayState *ds)\n\n{\n\n    assert(sdpy.ds == NULL);\n\n    qemu_spice_display_init_common(&sdpy, ds);\n\n    register_displaychangelistener(ds, &display_listener);\n\n\n\n    sdpy.qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_interface(&sdpy.qxl.base);\n\n    assert(sdpy.worker);\n\n\n\n    qemu_spice_create_host_memslot(&sdpy);\n\n    qemu_spice_create_host_primary(&sdpy);\n\n}\n", "idx": 21392, "_split": "test", "_hash": "f35743cdb3f3da768026db9b2140dfb7"}
{"project": "qemu", "commit_id": "f8a2e5e3ca6146d4cc66a4750daf44a0cf043319", "target": 0, "func": "static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,\n\n                              int nb_sectors, int *pnum)\n\n{\n\n    uint64_t cluster_offset;\n\n    int ret;\n\n\n\n    *pnum = nb_sectors;\n\n    /* FIXME We can get errors here, but the bdrv_is_allocated interface can't\n\n     * pass them on today */\n\n    ret = qcow2_get_cluster_offset(bs, sector_num << 9, pnum, &cluster_offset);\n\n    if (ret < 0) {\n\n        *pnum = 0;\n\n    }\n\n\n\n    return (cluster_offset != 0);\n\n}\n", "idx": 21411, "_split": "test", "_hash": "41d8d42f5ca8629b8eef5d465268a936"}
{"project": "qemu", "commit_id": "01fa55982692fb51a16049b63b571651a1053989", "target": 0, "func": "static void migrate_params_test_apply(MigrateSetParameters *params,\n\n                                      MigrationParameters *dest)\n\n{\n\n    *dest = migrate_get_current()->parameters;\n\n\n\n    /* TODO use QAPI_CLONE() instead of duplicating it inline */\n\n\n\n    if (params->has_compress_level) {\n\n        dest->compress_level = params->compress_level;\n\n    }\n\n\n\n    if (params->has_compress_threads) {\n\n        dest->compress_threads = params->compress_threads;\n\n    }\n\n\n\n    if (params->has_decompress_threads) {\n\n        dest->decompress_threads = params->decompress_threads;\n\n    }\n\n\n\n    if (params->has_cpu_throttle_initial) {\n\n        dest->cpu_throttle_initial = params->cpu_throttle_initial;\n\n    }\n\n\n\n    if (params->has_cpu_throttle_increment) {\n\n        dest->cpu_throttle_increment = params->cpu_throttle_increment;\n\n    }\n\n\n\n    if (params->has_tls_creds) {\n\n        dest->tls_creds = g_strdup(params->tls_creds);\n\n    }\n\n\n\n    if (params->has_tls_hostname) {\n\n        dest->tls_hostname = g_strdup(params->tls_hostname);\n\n    }\n\n\n\n    if (params->has_max_bandwidth) {\n\n        dest->max_bandwidth = params->max_bandwidth;\n\n    }\n\n\n\n    if (params->has_downtime_limit) {\n\n        dest->downtime_limit = params->downtime_limit;\n\n    }\n\n\n\n    if (params->has_x_checkpoint_delay) {\n\n        dest->x_checkpoint_delay = params->x_checkpoint_delay;\n\n    }\n\n\n\n    if (params->has_block_incremental) {\n\n        dest->block_incremental = params->block_incremental;\n\n    }\n\n}\n", "idx": 21413, "_split": "test", "_hash": "19bdffe6bf853efb864e167db3055663"}
{"project": "qemu", "commit_id": "03e6e5017757645f00b2f3b4f3a257973985e455", "target": 0, "func": "void cpu_state_reset(CPUMIPSState *env)\n\n{\n\n    if (qemu_loglevel_mask(CPU_LOG_RESET)) {\n\n        qemu_log(\"CPU Reset (CPU %d)\\n\", env->cpu_index);\n\n        log_cpu_state(env, 0);\n\n    }\n\n\n\n    memset(env, 0, offsetof(CPUMIPSState, breakpoints));\n\n    tlb_flush(env, 1);\n\n\n\n    /* Reset registers to their default values */\n\n    env->CP0_PRid = env->cpu_model->CP0_PRid;\n\n    env->CP0_Config0 = env->cpu_model->CP0_Config0;\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    env->CP0_Config0 |= (1 << CP0C0_BE);\n\n#endif\n\n    env->CP0_Config1 = env->cpu_model->CP0_Config1;\n\n    env->CP0_Config2 = env->cpu_model->CP0_Config2;\n\n    env->CP0_Config3 = env->cpu_model->CP0_Config3;\n\n    env->CP0_Config6 = env->cpu_model->CP0_Config6;\n\n    env->CP0_Config7 = env->cpu_model->CP0_Config7;\n\n    env->CP0_LLAddr_rw_bitmask = env->cpu_model->CP0_LLAddr_rw_bitmask\n\n                                 << env->cpu_model->CP0_LLAddr_shift;\n\n    env->CP0_LLAddr_shift = env->cpu_model->CP0_LLAddr_shift;\n\n    env->SYNCI_Step = env->cpu_model->SYNCI_Step;\n\n    env->CCRes = env->cpu_model->CCRes;\n\n    env->CP0_Status_rw_bitmask = env->cpu_model->CP0_Status_rw_bitmask;\n\n    env->CP0_TCStatus_rw_bitmask = env->cpu_model->CP0_TCStatus_rw_bitmask;\n\n    env->CP0_SRSCtl = env->cpu_model->CP0_SRSCtl;\n\n    env->current_tc = 0;\n\n    env->SEGBITS = env->cpu_model->SEGBITS;\n\n    env->SEGMask = (target_ulong)((1ULL << env->cpu_model->SEGBITS) - 1);\n\n#if defined(TARGET_MIPS64)\n\n    if (env->cpu_model->insn_flags & ISA_MIPS3) {\n\n        env->SEGMask |= 3ULL << 62;\n\n    }\n\n#endif\n\n    env->PABITS = env->cpu_model->PABITS;\n\n    env->PAMask = (target_ulong)((1ULL << env->cpu_model->PABITS) - 1);\n\n    env->CP0_SRSConf0_rw_bitmask = env->cpu_model->CP0_SRSConf0_rw_bitmask;\n\n    env->CP0_SRSConf0 = env->cpu_model->CP0_SRSConf0;\n\n    env->CP0_SRSConf1_rw_bitmask = env->cpu_model->CP0_SRSConf1_rw_bitmask;\n\n    env->CP0_SRSConf1 = env->cpu_model->CP0_SRSConf1;\n\n    env->CP0_SRSConf2_rw_bitmask = env->cpu_model->CP0_SRSConf2_rw_bitmask;\n\n    env->CP0_SRSConf2 = env->cpu_model->CP0_SRSConf2;\n\n    env->CP0_SRSConf3_rw_bitmask = env->cpu_model->CP0_SRSConf3_rw_bitmask;\n\n    env->CP0_SRSConf3 = env->cpu_model->CP0_SRSConf3;\n\n    env->CP0_SRSConf4_rw_bitmask = env->cpu_model->CP0_SRSConf4_rw_bitmask;\n\n    env->CP0_SRSConf4 = env->cpu_model->CP0_SRSConf4;\n\n    env->active_fpu.fcr0 = env->cpu_model->CP1_fcr0;\n\n    env->insn_flags = env->cpu_model->insn_flags;\n\n\n\n#if defined(CONFIG_USER_ONLY)\n\n    env->hflags = MIPS_HFLAG_UM;\n\n    /* Enable access to the CPUNum, SYNCI_Step, CC, and CCRes RDHWR\n\n       hardware registers.  */\n\n    env->CP0_HWREna |= 0x0000000F;\n\n    if (env->CP0_Config1 & (1 << CP0C1_FP)) {\n\n        env->hflags |= MIPS_HFLAG_FPU;\n\n    }\n\n#ifdef TARGET_MIPS64\n\n    if (env->active_fpu.fcr0 & (1 << FCR0_F64)) {\n\n        env->hflags |= MIPS_HFLAG_F64;\n\n    }\n\n#endif\n\n#else\n\n    if (env->hflags & MIPS_HFLAG_BMASK) {\n\n        /* If the exception was raised from a delay slot,\n\n           come back to the jump.  */\n\n        env->CP0_ErrorEPC = env->active_tc.PC - 4;\n\n    } else {\n\n        env->CP0_ErrorEPC = env->active_tc.PC;\n\n    }\n\n    env->active_tc.PC = (int32_t)0xBFC00000;\n\n    env->CP0_Random = env->tlb->nb_tlb - 1;\n\n    env->tlb->tlb_in_use = env->tlb->nb_tlb;\n\n    env->CP0_Wired = 0;\n\n    env->CP0_EBase = 0x80000000 | (env->cpu_index & 0x3FF);\n\n    env->CP0_Status = (1 << CP0St_BEV) | (1 << CP0St_ERL);\n\n    /* vectored interrupts not implemented, timer on int 7,\n\n       no performance counters. */\n\n    env->CP0_IntCtl = 0xe0000000;\n\n    {\n\n        int i;\n\n\n\n        for (i = 0; i < 7; i++) {\n\n            env->CP0_WatchLo[i] = 0;\n\n            env->CP0_WatchHi[i] = 0x80000000;\n\n        }\n\n        env->CP0_WatchLo[7] = 0;\n\n        env->CP0_WatchHi[7] = 0;\n\n    }\n\n    /* Count register increments in debug mode, EJTAG version 1 */\n\n    env->CP0_Debug = (1 << CP0DB_CNT) | (0x1 << CP0DB_VER);\n\n    env->hflags = MIPS_HFLAG_CP0;\n\n\n\n    if (env->CP0_Config3 & (1 << CP0C3_MT)) {\n\n        int i;\n\n\n\n        /* Only TC0 on VPE 0 starts as active.  */\n\n        for (i = 0; i < ARRAY_SIZE(env->tcs); i++) {\n\n            env->tcs[i].CP0_TCBind = env->cpu_index << CP0TCBd_CurVPE;\n\n            env->tcs[i].CP0_TCHalt = 1;\n\n        }\n\n        env->active_tc.CP0_TCHalt = 1;\n\n        env->halted = 1;\n\n\n\n        if (!env->cpu_index) {\n\n            /* VPE0 starts up enabled.  */\n\n            env->mvp->CP0_MVPControl |= (1 << CP0MVPCo_EVP);\n\n            env->CP0_VPEConf0 |= (1 << CP0VPEC0_MVP) | (1 << CP0VPEC0_VPA);\n\n\n\n            /* TC0 starts up unhalted.  */\n\n            env->halted = 0;\n\n            env->active_tc.CP0_TCHalt = 0;\n\n            env->tcs[0].CP0_TCHalt = 0;\n\n            /* With thread 0 active.  */\n\n            env->active_tc.CP0_TCStatus = (1 << CP0TCSt_A);\n\n            env->tcs[0].CP0_TCStatus = (1 << CP0TCSt_A);\n\n        }\n\n    }\n\n#endif\n\n#if defined(TARGET_MIPS64)\n\n    if (env->cpu_model->insn_flags & ISA_MIPS3) {\n\n        env->hflags |= MIPS_HFLAG_64;\n\n    }\n\n#endif\n\n    env->exception_index = EXCP_NONE;\n\n}\n", "idx": 21427, "_split": "test", "_hash": "ccb992eca7fceacd15ab7e114441fa21"}
{"project": "qemu", "commit_id": "57ef3f1278585fbac5f6102362d3c5e066976fdc", "target": 0, "func": "bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)\n\n{\n\n    BdrvOpBlocker *blocker;\n\n    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);\n\n    if (!QLIST_EMPTY(&bs->op_blockers[op])) {\n\n        blocker = QLIST_FIRST(&bs->op_blockers[op]);\n\n        if (errp) {\n\n            *errp = error_copy(blocker->reason);\n\n            error_prepend(errp, \"Node '%s' is busy: \",\n\n                          bdrv_get_device_or_node_name(bs));\n\n        }\n\n        return true;\n\n    }\n\n    return false;\n\n}\n", "idx": 21430, "_split": "test", "_hash": "16008f335fa951cd35825d07053beff2"}
{"project": "qemu", "commit_id": "3ddf3efefa364505ee44582873612dd8f6abb838", "target": 0, "func": "static BlockJob *find_block_job(const char *device, AioContext **aio_context,\n\n                                Error **errp)\n\n{\n\n    BlockBackend *blk;\n\n    BlockDriverState *bs;\n\n\n\n    *aio_context = NULL;\n\n\n\n    blk = blk_by_name(device);\n\n    if (!blk) {\n\n        goto notfound;\n\n    }\n\n\n\n    *aio_context = blk_get_aio_context(blk);\n\n    aio_context_acquire(*aio_context);\n\n\n\n    if (!blk_is_available(blk)) {\n\n        goto notfound;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    if (!bs->job) {\n\n        goto notfound;\n\n    }\n\n\n\n    return bs->job;\n\n\n\nnotfound:\n\n    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,\n\n              \"No active block job on device '%s'\", device);\n\n    if (*aio_context) {\n\n        aio_context_release(*aio_context);\n\n        *aio_context = NULL;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 21435, "_split": "test", "_hash": "8fecf3deb73c86619ba0b947c6709de8"}
{"project": "qemu", "commit_id": "f61eddcb2bb5cbbdd1d911b7e937db9affc29028", "target": 0, "func": "static int bt_hci_parse(const char *str)\n\n{\n\n    struct HCIInfo *hci;\n\n    bdaddr_t bdaddr;\n\n\n\n    if (nb_hcis >= MAX_NICS) {\n\n        fprintf(stderr, \"qemu: Too many bluetooth HCIs (max %i).\\n\", MAX_NICS);\n\n        return -1;\n\n    }\n\n\n\n    hci = hci_init(str);\n\n    if (!hci)\n\n        return -1;\n\n\n\n    bdaddr.b[0] = 0x52;\n\n    bdaddr.b[1] = 0x54;\n\n    bdaddr.b[2] = 0x00;\n\n    bdaddr.b[3] = 0x12;\n\n    bdaddr.b[4] = 0x34;\n\n    bdaddr.b[5] = 0x56 + nb_hcis;\n\n    hci->bdaddr_set(hci, bdaddr.b);\n\n\n\n    hci_table[nb_hcis++] = hci;\n\n\n\n    return 0;\n\n}\n", "idx": 21450, "_split": "test", "_hash": "ad3bdf0577d48840a074d2f811f77b83"}
{"project": "qemu", "commit_id": "58aebb946acff82c62383f350cab593e55cc13dc", "target": 0, "func": "static int cris_mmu_translate_page(struct cris_mmu_result *res,\n\n\t\t\t\t   CPUState *env, uint32_t vaddr,\n\n\t\t\t\t   int rw, int usermode, int debug)\n\n{\n\n\tunsigned int vpage;\n\n\tunsigned int idx;\n\n\tuint32_t pid, lo, hi;\n\n\tuint32_t tlb_vpn, tlb_pfn = 0;\n\n\tint tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;\n\n\tint cfg_v, cfg_k, cfg_w, cfg_x;\t\n\n\tint set, match = 0;\n\n\tuint32_t r_cause;\n\n\tuint32_t r_cfg;\n\n\tint rwcause;\n\n\tint mmu = 1; /* Data mmu is default.  */\n\n\tint vect_base;\n\n\n\n\tr_cause = env->sregs[SFR_R_MM_CAUSE];\n\n\tr_cfg = env->sregs[SFR_RW_MM_CFG];\n\n\tpid = env->pregs[PR_PID] & 0xff;\n\n\n\n\tswitch (rw) {\n\n\t\tcase 2: rwcause = CRIS_MMU_ERR_EXEC; mmu = 0; break;\n\n\t\tcase 1: rwcause = CRIS_MMU_ERR_WRITE; break;\n\n\t\tdefault:\n\n\t\tcase 0: rwcause = CRIS_MMU_ERR_READ; break;\n\n\t}\n\n\n\n\t/* I exception vectors 4 - 7, D 8 - 11.  */\n\n\tvect_base = (mmu + 1) * 4;\n\n\n\n\tvpage = vaddr >> 13;\n\n\n\n\t/* We know the index which to check on each set.\n\n\t   Scan both I and D.  */\n\n#if 0\n\n\tfor (set = 0; set < 4; set++) {\n\n\t\tfor (idx = 0; idx < 16; idx++) {\n\n\t\t\tlo = env->tlbsets[mmu][set][idx].lo;\n\n\t\t\thi = env->tlbsets[mmu][set][idx].hi;\n\n\t\t\ttlb_vpn = EXTRACT_FIELD(hi, 13, 31);\n\n\t\t\ttlb_pfn = EXTRACT_FIELD(lo, 13, 31);\n\n\n\n\t\t\tprintf (\"TLB: [%d][%d] hi=%x lo=%x v=%x p=%x\\n\", \n\n\t\t\t\t\tset, idx, hi, lo, tlb_vpn, tlb_pfn);\n\n\t\t}\n\n\t}\n\n#endif\n\n\n\n\tidx = vpage & 15;\n\n\tfor (set = 0; set < 4; set++)\n\n\t{\n\n\t\tlo = env->tlbsets[mmu][set][idx].lo;\n\n\t\thi = env->tlbsets[mmu][set][idx].hi;\n\n\n\n\t\ttlb_vpn = hi >> 13;\n\n\t\ttlb_pid = EXTRACT_FIELD(hi, 0, 7);\n\n\t\ttlb_g  = EXTRACT_FIELD(lo, 4, 4);\n\n\n\n\t\tD_LOG(\"TLB[%d][%d][%d] v=%x vpage=%x lo=%x hi=%x\\n\", \n\n\t\t\t mmu, set, idx, tlb_vpn, vpage, lo, hi);\n\n\t\tif ((tlb_g || (tlb_pid == pid))\n\n\t\t    && tlb_vpn == vpage) {\n\n\t\t\tmatch = 1;\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\n\n\tres->bf_vec = vect_base;\n\n\tif (match) {\n\n\t\tcfg_w  = EXTRACT_FIELD(r_cfg, 19, 19);\n\n\t\tcfg_k  = EXTRACT_FIELD(r_cfg, 18, 18);\n\n\t\tcfg_x  = EXTRACT_FIELD(r_cfg, 17, 17);\n\n\t\tcfg_v  = EXTRACT_FIELD(r_cfg, 16, 16);\n\n\n\n\t\ttlb_pfn = EXTRACT_FIELD(lo, 13, 31);\n\n\t\ttlb_v = EXTRACT_FIELD(lo, 3, 3);\n\n\t\ttlb_k = EXTRACT_FIELD(lo, 2, 2);\n\n\t\ttlb_w = EXTRACT_FIELD(lo, 1, 1);\n\n\t\ttlb_x = EXTRACT_FIELD(lo, 0, 0);\n\n\n\n\t\t/*\n\n\t\tset_exception_vector(0x04, i_mmu_refill);\n\n\t\tset_exception_vector(0x05, i_mmu_invalid);\n\n\t\tset_exception_vector(0x06, i_mmu_access);\n\n\t\tset_exception_vector(0x07, i_mmu_execute);\n\n\t\tset_exception_vector(0x08, d_mmu_refill);\n\n\t\tset_exception_vector(0x09, d_mmu_invalid);\n\n\t\tset_exception_vector(0x0a, d_mmu_access);\n\n\t\tset_exception_vector(0x0b, d_mmu_write);\n\n\t\t*/\n\n\t\tif (cfg_k && tlb_k && usermode) {\n\n\t\t\tD(printf (\"tlb: kernel protected %x lo=%x pc=%x\\n\", \n\n\t\t\t\t  vaddr, lo, env->pc));\n\n\t\t\tmatch = 0;\n\n\t\t\tres->bf_vec = vect_base + 2;\n\n\t\t} else if (rw == 1 && cfg_w && !tlb_w) {\n\n\t\t\tD(printf (\"tlb: write protected %x lo=%x pc=%x\\n\", \n\n\t\t\t\t  vaddr, lo, env->pc));\n\n\t\t\tmatch = 0;\n\n\t\t\t/* write accesses never go through the I mmu.  */\n\n\t\t\tres->bf_vec = vect_base + 3;\n\n\t\t} else if (rw == 2 && cfg_x && !tlb_x) {\n\n\t\t\tD(printf (\"tlb: exec protected %x lo=%x pc=%x\\n\", \n\n\t\t\t\t vaddr, lo, env->pc));\n\n\t\t\tmatch = 0;\n\n\t\t\tres->bf_vec = vect_base + 3;\n\n\t\t} else if (cfg_v && !tlb_v) {\n\n\t\t\tD(printf (\"tlb: invalid %x\\n\", vaddr));\n\n\t\t\tmatch = 0;\n\n\t\t\tres->bf_vec = vect_base + 1;\n\n\t\t}\n\n\n\n\t\tres->prot = 0;\n\n\t\tif (match) {\n\n\t\t\tres->prot |= PAGE_READ;\n\n\t\t\tif (tlb_w)\n\n\t\t\t\tres->prot |= PAGE_WRITE;\n\n\t\t\tif (tlb_x)\n\n\t\t\t\tres->prot |= PAGE_EXEC;\n\n\t\t}\n\n\t\telse\n\n\t\t\tD(dump_tlb(env, mmu));\n\n\t} else {\n\n\t\t/* If refill, provide a randomized set.  */\n\n\t\tset = env->mmu_rand_lfsr & 3;\n\n\t}\n\n\n\n\tif (!match && !debug) {\n\n\t\tcris_mmu_update_rand_lfsr(env);\n\n\n\n\t\t/* Compute index.  */\n\n\t\tidx = vpage & 15;\n\n\n\n\t\t/* Update RW_MM_TLB_SEL.  */\n\n\t\tenv->sregs[SFR_RW_MM_TLB_SEL] = 0;\n\n\t\tset_field(&env->sregs[SFR_RW_MM_TLB_SEL], idx, 0, 4);\n\n\t\tset_field(&env->sregs[SFR_RW_MM_TLB_SEL], set, 4, 2);\n\n\n\n\t\t/* Update RW_MM_CAUSE.  */\n\n\t\tset_field(&r_cause, rwcause, 8, 2);\n\n\t\tset_field(&r_cause, vpage, 13, 19);\n\n\t\tset_field(&r_cause, pid, 0, 8);\n\n\t\tenv->sregs[SFR_R_MM_CAUSE] = r_cause;\n\n\t\tD(printf(\"refill vaddr=%x pc=%x\\n\", vaddr, env->pc));\n\n\t}\n\n\n\n\tD(printf (\"%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x\"\n\n\t\t  \" %x cause=%x sel=%x sp=%x %x %x\\n\",\n\n\t\t  __func__, rw, match, env->pc,\n\n\t\t  vaddr, vpage,\n\n\t\t  tlb_vpn, tlb_pfn, tlb_pid, \n\n\t\t  pid,\n\n\t\t  r_cause,\n\n\t\t  env->sregs[SFR_RW_MM_TLB_SEL],\n\n\t\t  env->regs[R_SP], env->pregs[PR_USP], env->ksp));\n\n\n\n\tres->phy = tlb_pfn << TARGET_PAGE_BITS;\n\n\treturn !match;\n\n}\n", "idx": 21459, "_split": "test", "_hash": "c6a03cc8e8c2a06474f190375f44812a"}
{"project": "qemu", "commit_id": "e41029b378b4a65a0b89b5a8dc087aca6b5d012d", "target": 1, "func": "static void gen_dst(DisasContext *ctx)\n\n{\n\n    if (rA(ctx->opcode) == 0) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);\n\n    } else {\n\n        /* interpreted as no-op */\n\n    }\n\n}\n", "idx": 21466, "_split": "test", "_hash": "a55cbc10ad0436cb759cf72dd2effbda"}
{"project": "qemu", "commit_id": "96193c22ab39ea24f81e386ad7883260ff24f5fd", "target": 0, "func": "static void x86_cpu_enable_xsave_components(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    int i;\n\n\n\n    if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {\n\n        return;\n\n    }\n\n\n\n    env->xsave_components = (XSTATE_FP_MASK | XSTATE_SSE_MASK);\n\n    for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {\n\n        const ExtSaveArea *esa = &x86_ext_save_areas[i];\n\n        if (env->features[esa->feature] & esa->bits) {\n\n            env->xsave_components |= (1ULL << i);\n\n        }\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        KVMState *s = kvm_state;\n\n        uint64_t kvm_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);\n\n        kvm_mask <<= 32;\n\n        kvm_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);\n\n        env->xsave_components &= kvm_mask;\n\n    }\n\n}\n", "idx": 21473, "_split": "test", "_hash": "7f1dba92176e771996e7f4ec387370b2"}
{"project": "qemu", "commit_id": "2bcf018340cbf233f7145e643fc1bb367f23fd90", "target": 0, "func": "int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,\n\n                       target_ulong *addr, int *flags)\n\n{\n\n    /* TODO: low address protection once we flush the tlb on cr changes */\n\n    *flags = PAGE_READ | PAGE_WRITE;\n\n    *addr = mmu_real2abs(env, raddr);\n\n\n\n    /* TODO: storage key handling */\n\n    return 0;\n\n}\n", "idx": 21487, "_split": "test", "_hash": "3c3e817e156cfb9752b638301594e65d"}
{"project": "qemu", "commit_id": "6cded3a43ad0044d9831590795d9c6cf0dc2d2ee", "target": 0, "func": "static void nic_selective_reset(EEPRO100State * s)\n\n{\n\n    size_t i;\n\n    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);\n\n    //~ eeprom93xx_reset(s->eeprom);\n\n    memcpy(eeprom_contents, s->conf.macaddr.a, 6);\n\n    eeprom_contents[0xa] = 0x4000;\n\n    if (s->device == i82557B || s->device == i82557C)\n\n        eeprom_contents[5] = 0x0100;\n\n    uint16_t sum = 0;\n\n    for (i = 0; i < EEPROM_SIZE - 1; i++) {\n\n        sum += eeprom_contents[i];\n\n    }\n\n    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;\n\n    TRACE(EEPROM, logout(\"checksum=0x%04x\\n\", eeprom_contents[EEPROM_SIZE - 1]));\n\n\n\n    memset(s->mem, 0, sizeof(s->mem));\n\n    uint32_t val = BIT(21);\n\n    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));\n\n\n\n    assert(sizeof(s->mdimem) == sizeof(eepro100_mdi_default));\n\n    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));\n\n}\n", "idx": 21492, "_split": "test", "_hash": "38c1be333e2aeb9061f14f0d904d16ff"}
{"project": "qemu", "commit_id": "0208def1cadd4f72f862e62548c2af268a543b20", "target": 1, "func": "void pci_bridge_reset_reg(PCIDevice *dev)\n\n{\n\n    uint8_t *conf = dev->config;\n\n\n\n    conf[PCI_PRIMARY_BUS] = 0;\n\n    conf[PCI_SECONDARY_BUS] = 0;\n\n    conf[PCI_SUBORDINATE_BUS] = 0;\n\n    conf[PCI_SEC_LATENCY_TIMER] = 0;\n\n\n\n    conf[PCI_IO_BASE] = 0;\n\n    conf[PCI_IO_LIMIT] = 0;\n\n    pci_set_word(conf + PCI_MEMORY_BASE, 0);\n\n    pci_set_word(conf + PCI_MEMORY_LIMIT, 0);\n\n    pci_set_word(conf + PCI_PREF_MEMORY_BASE, 0);\n\n    pci_set_word(conf + PCI_PREF_MEMORY_LIMIT, 0);\n\n    pci_set_word(conf + PCI_PREF_BASE_UPPER32, 0);\n\n    pci_set_word(conf + PCI_PREF_LIMIT_UPPER32, 0);\n\n\n\n    pci_set_word(conf + PCI_BRIDGE_CONTROL, 0);\n\n}\n", "idx": 21508, "_split": "test", "_hash": "143ffdfa95fda8dd3904b59152bf0b95"}
{"project": "qemu", "commit_id": "a01672d3968cf91208666d371784110bfde9d4f8", "target": 1, "func": "static int kvm_client_sync_dirty_bitmap(struct CPUPhysMemoryClient *client,\n\n                                        target_phys_addr_t start_addr,\n\n                                        target_phys_addr_t end_addr)\n\n{\n\n    return kvm_physical_sync_dirty_bitmap(start_addr, end_addr);\n\n}\n", "idx": 21511, "_split": "test", "_hash": "15b1494a30100be209cbf28b5af78a87"}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    PCIBonitoState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr - BONITO_REGBASE) >> 2;\n\n\n\n    DPRINTF(\"bonito_readl \"TARGET_FMT_plx\"  \\n\", addr);\n\n    switch (saddr) {\n\n    case BONITO_INTISR:\n\n        return s->regs[saddr];\n\n    default:\n\n        return s->regs[saddr];\n\n    }\n\n}\n", "idx": 21513, "_split": "test", "_hash": "e8e38317c7ce5ce8cd36240b122bc94a"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "struct omap_mpu_state_s *omap310_mpu_init(MemoryRegion *system_memory,\n\n                unsigned long sdram_size,\n\n                const char *core)\n\n{\n\n    int i;\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *)\n\n            g_malloc0(sizeof(struct omap_mpu_state_s));\n\n    qemu_irq dma_irqs[6];\n\n    DriveInfo *dinfo;\n\n    SysBusDevice *busdev;\n\n\n\n    if (!core)\n\n        core = \"ti925t\";\n\n\n\n    /* Core */\n\n    s->mpu_model = omap310;\n\n    s->cpu = cpu_arm_init(core);\n\n    if (s->cpu == NULL) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    s->sdram_size = sdram_size;\n\n    s->sram_size = OMAP15XX_SRAM_SIZE;\n\n\n\n    s->wakeup = qemu_allocate_irq(omap_mpu_wakeup, s, 0);\n\n\n\n    /* Clocks */\n\n    omap_clk_init(s);\n\n\n\n    /* Memory-mapped stuff */\n\n    memory_region_init_ram(&s->emiff_ram, NULL, \"omap1.dram\", s->sdram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->emiff_ram);\n\n    memory_region_add_subregion(system_memory, OMAP_EMIFF_BASE, &s->emiff_ram);\n\n    memory_region_init_ram(&s->imif_ram, NULL, \"omap1.sram\", s->sram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->imif_ram);\n\n    memory_region_add_subregion(system_memory, OMAP_IMIF_BASE, &s->imif_ram);\n\n\n\n    omap_clkm_init(system_memory, 0xfffece00, 0xe1008000, s);\n\n\n\n    s->ih[0] = qdev_create(NULL, \"omap-intc\");\n\n    qdev_prop_set_uint32(s->ih[0], \"size\", 0x100);\n\n    qdev_prop_set_ptr(s->ih[0], \"clk\", omap_findclk(s, \"arminth_ck\"));\n\n    qdev_init_nofail(s->ih[0]);\n\n    busdev = SYS_BUS_DEVICE(s->ih[0]);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(DEVICE(s->cpu), ARM_CPU_IRQ));\n\n    sysbus_connect_irq(busdev, 1,\n\n                       qdev_get_gpio_in(DEVICE(s->cpu), ARM_CPU_FIQ));\n\n    sysbus_mmio_map(busdev, 0, 0xfffecb00);\n\n    s->ih[1] = qdev_create(NULL, \"omap-intc\");\n\n    qdev_prop_set_uint32(s->ih[1], \"size\", 0x800);\n\n    qdev_prop_set_ptr(s->ih[1], \"clk\", omap_findclk(s, \"arminth_ck\"));\n\n    qdev_init_nofail(s->ih[1]);\n\n    busdev = SYS_BUS_DEVICE(s->ih[1]);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_15XX_IH2_IRQ));\n\n    /* The second interrupt controller's FIQ output is not wired up */\n\n    sysbus_mmio_map(busdev, 0, 0xfffe0000);\n\n\n\n    for (i = 0; i < 6; i++) {\n\n        dma_irqs[i] = qdev_get_gpio_in(s->ih[omap1_dma_irq_map[i].ih],\n\n                                       omap1_dma_irq_map[i].intr);\n\n    }\n\n    s->dma = omap_dma_init(0xfffed800, dma_irqs, system_memory,\n\n                           qdev_get_gpio_in(s->ih[0], OMAP_INT_DMA_LCD),\n\n                           s, omap_findclk(s, \"dma_ck\"), omap_dma_3_1);\n\n\n\n    s->port[emiff    ].addr_valid = omap_validate_emiff_addr;\n\n    s->port[emifs    ].addr_valid = omap_validate_emifs_addr;\n\n    s->port[imif     ].addr_valid = omap_validate_imif_addr;\n\n    s->port[tipb     ].addr_valid = omap_validate_tipb_addr;\n\n    s->port[local    ].addr_valid = omap_validate_local_addr;\n\n    s->port[tipb_mpui].addr_valid = omap_validate_tipb_mpui_addr;\n\n\n\n    /* Register SDRAM and SRAM DMA ports for fast transfers.  */\n\n    soc_dma_port_add_mem(s->dma, memory_region_get_ram_ptr(&s->emiff_ram),\n\n                         OMAP_EMIFF_BASE, s->sdram_size);\n\n    soc_dma_port_add_mem(s->dma, memory_region_get_ram_ptr(&s->imif_ram),\n\n                         OMAP_IMIF_BASE, s->sram_size);\n\n\n\n    s->timer[0] = omap_mpu_timer_init(system_memory, 0xfffec500,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_TIMER1),\n\n                    omap_findclk(s, \"mputim_ck\"));\n\n    s->timer[1] = omap_mpu_timer_init(system_memory, 0xfffec600,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_TIMER2),\n\n                    omap_findclk(s, \"mputim_ck\"));\n\n    s->timer[2] = omap_mpu_timer_init(system_memory, 0xfffec700,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_TIMER3),\n\n                    omap_findclk(s, \"mputim_ck\"));\n\n\n\n    s->wdt = omap_wd_timer_init(system_memory, 0xfffec800,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_WD_TIMER),\n\n                    omap_findclk(s, \"armwdt_ck\"));\n\n\n\n    s->os_timer = omap_os_timer_init(system_memory, 0xfffb9000,\n\n                    qdev_get_gpio_in(s->ih[1], OMAP_INT_OS_TIMER),\n\n                    omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    s->lcd = omap_lcdc_init(system_memory, 0xfffec000,\n\n                            qdev_get_gpio_in(s->ih[0], OMAP_INT_LCD_CTRL),\n\n                            omap_dma_get_lcdch(s->dma),\n\n                            omap_findclk(s, \"lcd_ck\"));\n\n\n\n    omap_ulpd_pm_init(system_memory, 0xfffe0800, s);\n\n    omap_pin_cfg_init(system_memory, 0xfffe1000, s);\n\n    omap_id_init(system_memory, s);\n\n\n\n    omap_mpui_init(system_memory, 0xfffec900, s);\n\n\n\n    s->private_tipb = omap_tipb_bridge_init(system_memory, 0xfffeca00,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_BRIDGE_PRIV),\n\n                    omap_findclk(s, \"tipb_ck\"));\n\n    s->public_tipb = omap_tipb_bridge_init(system_memory, 0xfffed300,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_BRIDGE_PUB),\n\n                    omap_findclk(s, \"tipb_ck\"));\n\n\n\n    omap_tcmi_init(system_memory, 0xfffecc00, s);\n\n\n\n    s->uart[0] = omap_uart_init(0xfffb0000,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_UART1),\n\n                    omap_findclk(s, \"uart1_ck\"),\n\n                    omap_findclk(s, \"uart1_ck\"),\n\n                    s->drq[OMAP_DMA_UART1_TX], s->drq[OMAP_DMA_UART1_RX],\n\n                    \"uart1\",\n\n                    serial_hds[0]);\n\n    s->uart[1] = omap_uart_init(0xfffb0800,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_UART2),\n\n                    omap_findclk(s, \"uart2_ck\"),\n\n                    omap_findclk(s, \"uart2_ck\"),\n\n                    s->drq[OMAP_DMA_UART2_TX], s->drq[OMAP_DMA_UART2_RX],\n\n                    \"uart2\",\n\n                    serial_hds[0] ? serial_hds[1] : NULL);\n\n    s->uart[2] = omap_uart_init(0xfffb9800,\n\n                                qdev_get_gpio_in(s->ih[0], OMAP_INT_UART3),\n\n                    omap_findclk(s, \"uart3_ck\"),\n\n                    omap_findclk(s, \"uart3_ck\"),\n\n                    s->drq[OMAP_DMA_UART3_TX], s->drq[OMAP_DMA_UART3_RX],\n\n                    \"uart3\",\n\n                    serial_hds[0] && serial_hds[1] ? serial_hds[2] : NULL);\n\n\n\n    s->dpll[0] = omap_dpll_init(system_memory, 0xfffecf00,\n\n                                omap_findclk(s, \"dpll1\"));\n\n    s->dpll[1] = omap_dpll_init(system_memory, 0xfffed000,\n\n                                omap_findclk(s, \"dpll2\"));\n\n    s->dpll[2] = omap_dpll_init(system_memory, 0xfffed100,\n\n                                omap_findclk(s, \"dpll3\"));\n\n\n\n    dinfo = drive_get(IF_SD, 0, 0);\n\n    if (!dinfo) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n\n        exit(1);\n\n    }\n\n    s->mmc = omap_mmc_init(0xfffb7800, system_memory,\n\n                           blk_bs(blk_by_legacy_dinfo(dinfo)),\n\n                           qdev_get_gpio_in(s->ih[1], OMAP_INT_OQN),\n\n                           &s->drq[OMAP_DMA_MMC_TX],\n\n                    omap_findclk(s, \"mmc_ck\"));\n\n\n\n    s->mpuio = omap_mpuio_init(system_memory, 0xfffb5000,\n\n                               qdev_get_gpio_in(s->ih[1], OMAP_INT_KEYBOARD),\n\n                               qdev_get_gpio_in(s->ih[1], OMAP_INT_MPUIO),\n\n                               s->wakeup, omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    s->gpio = qdev_create(NULL, \"omap-gpio\");\n\n    qdev_prop_set_int32(s->gpio, \"mpu_model\", s->mpu_model);\n\n    qdev_prop_set_ptr(s->gpio, \"clk\", omap_findclk(s, \"arm_gpio_ck\"));\n\n    qdev_init_nofail(s->gpio);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(s->gpio), 0,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_GPIO_BANK1));\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(s->gpio), 0, 0xfffce000);\n\n\n\n    s->microwire = omap_uwire_init(system_memory, 0xfffb3000,\n\n                                   qdev_get_gpio_in(s->ih[1], OMAP_INT_uWireTX),\n\n                                   qdev_get_gpio_in(s->ih[1], OMAP_INT_uWireRX),\n\n                    s->drq[OMAP_DMA_UWIRE_TX], omap_findclk(s, \"mpuper_ck\"));\n\n\n\n    s->pwl = omap_pwl_init(system_memory, 0xfffb5800,\n\n                           omap_findclk(s, \"armxor_ck\"));\n\n    s->pwt = omap_pwt_init(system_memory, 0xfffb6000,\n\n                           omap_findclk(s, \"armxor_ck\"));\n\n\n\n    s->i2c[0] = qdev_create(NULL, \"omap_i2c\");\n\n    qdev_prop_set_uint8(s->i2c[0], \"revision\", 0x11);\n\n    qdev_prop_set_ptr(s->i2c[0], \"fclk\", omap_findclk(s, \"mpuper_ck\"));\n\n    qdev_init_nofail(s->i2c[0]);\n\n    busdev = SYS_BUS_DEVICE(s->i2c[0]);\n\n    sysbus_connect_irq(busdev, 0, qdev_get_gpio_in(s->ih[1], OMAP_INT_I2C));\n\n    sysbus_connect_irq(busdev, 1, s->drq[OMAP_DMA_I2C_TX]);\n\n    sysbus_connect_irq(busdev, 2, s->drq[OMAP_DMA_I2C_RX]);\n\n    sysbus_mmio_map(busdev, 0, 0xfffb3800);\n\n\n\n    s->rtc = omap_rtc_init(system_memory, 0xfffb4800,\n\n                           qdev_get_gpio_in(s->ih[1], OMAP_INT_RTC_TIMER),\n\n                           qdev_get_gpio_in(s->ih[1], OMAP_INT_RTC_ALARM),\n\n                    omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    s->mcbsp1 = omap_mcbsp_init(system_memory, 0xfffb1800,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP1TX),\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP1RX),\n\n                    &s->drq[OMAP_DMA_MCBSP1_TX], omap_findclk(s, \"dspxor_ck\"));\n\n    s->mcbsp2 = omap_mcbsp_init(system_memory, 0xfffb1000,\n\n                                qdev_get_gpio_in(s->ih[0],\n\n                                                 OMAP_INT_310_McBSP2_TX),\n\n                                qdev_get_gpio_in(s->ih[0],\n\n                                                 OMAP_INT_310_McBSP2_RX),\n\n                    &s->drq[OMAP_DMA_MCBSP2_TX], omap_findclk(s, \"mpuper_ck\"));\n\n    s->mcbsp3 = omap_mcbsp_init(system_memory, 0xfffb7000,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP3TX),\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP3RX),\n\n                    &s->drq[OMAP_DMA_MCBSP3_TX], omap_findclk(s, \"dspxor_ck\"));\n\n\n\n    s->led[0] = omap_lpg_init(system_memory,\n\n                              0xfffbd000, omap_findclk(s, \"clk32-kHz\"));\n\n    s->led[1] = omap_lpg_init(system_memory,\n\n                              0xfffbd800, omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    /* Register mappings not currenlty implemented:\n\n     * MCSI2 Comm\tfffb2000 - fffb27ff (not mapped on OMAP310)\n\n     * MCSI1 Bluetooth\tfffb2800 - fffb2fff (not mapped on OMAP310)\n\n     * USB W2FC\t\tfffb4000 - fffb47ff\n\n     * Camera Interface\tfffb6800 - fffb6fff\n\n     * USB Host\t\tfffba000 - fffba7ff\n\n     * FAC\t\tfffba800 - fffbafff\n\n     * HDQ/1-Wire\tfffbc000 - fffbc7ff\n\n     * TIPB switches\tfffbc800 - fffbcfff\n\n     * Mailbox\t\tfffcf000 - fffcf7ff\n\n     * Local bus IF\tfffec100 - fffec1ff\n\n     * Local bus MMU\tfffec200 - fffec2ff\n\n     * DSP MMU\t\tfffed200 - fffed2ff\n\n     */\n\n\n\n    omap_setup_dsp_mapping(system_memory, omap15xx_dsp_mm);\n\n    omap_setup_mpui_io(system_memory, s);\n\n\n\n    qemu_register_reset(omap1_mpu_reset, s);\n\n\n\n    return s;\n\n}\n", "idx": 21538, "_split": "test", "_hash": "7ef6be84771db223bb5aaa2a59b6508b"}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "void nbd_client_close(NBDClient *client)\n\n{\n\n    if (client->closing) {\n\n        return;\n\n    }\n\n\n\n    client->closing = true;\n\n\n\n    /* Force requests to finish.  They will drop their own references,\n\n     * then we'll close the socket and free the NBDClient.\n\n     */\n\n    shutdown(client->sock, 2);\n\n\n\n    /* Also tell the client, so that they release their reference.  */\n\n    if (client->close) {\n\n        client->close(client);\n\n    }\n\n}\n", "idx": 21549, "_split": "test", "_hash": "c092012a69bcfb9fe9e479e8a2159708"}
{"project": "qemu", "commit_id": "06b106889a09277617fc8c542397a9f595ee605a", "target": 1, "func": "static bool find_dirty_block(RAMState *rs, PageSearchStatus *pss,\n\n                             bool *again, ram_addr_t *ram_addr_abs)\n\n{\n\n    pss->offset = migration_bitmap_find_dirty(rs, pss->block, pss->offset,\n\n                                              ram_addr_abs);\n\n    if (pss->complete_round && pss->block == rs->last_seen_block &&\n\n        pss->offset >= rs->last_offset) {\n\n        /*\n\n         * We've been once around the RAM and haven't found anything.\n\n         * Give up.\n\n         */\n\n        *again = false;\n\n        return false;\n\n    }\n\n    if (pss->offset >= pss->block->used_length) {\n\n        /* Didn't find anything in this RAM Block */\n\n        pss->offset = 0;\n\n        pss->block = QLIST_NEXT_RCU(pss->block, next);\n\n        if (!pss->block) {\n\n            /* Hit the end of the list */\n\n            pss->block = QLIST_FIRST_RCU(&ram_list.blocks);\n\n            /* Flag that we've looped */\n\n            pss->complete_round = true;\n\n            rs->ram_bulk_stage = false;\n\n            if (migrate_use_xbzrle()) {\n\n                /* If xbzrle is on, stop using the data compression at this\n\n                 * point. In theory, xbzrle can do better than compression.\n\n                 */\n\n                flush_compressed_data(rs);\n\n            }\n\n        }\n\n        /* Didn't find anything this time, but try again on the new block */\n\n        *again = true;\n\n        return false;\n\n    } else {\n\n        /* Can go around again, but... */\n\n        *again = true;\n\n        /* We've found something so probably don't need to */\n\n        return true;\n\n    }\n\n}\n", "idx": 21567, "_split": "test", "_hash": "a01dd3a0f3c3cb4364b93b71407a3f9c"}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void OPPROTO op_POWER_doz (void)\n\n{\n\n    if (Ts1 > Ts0)\n\n        T0 = T1 - T0;\n\n    else\n\n        T0 = 0;\n\n    RETURN();\n\n}\n", "idx": 21569, "_split": "test", "_hash": "4e856a4e90dd19eacc99fa71f69d1b23"}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,\n\n                                        hwaddr size, unsigned client)\n\n{\n\n    assert(mr->terminates);\n\n    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,\n\n                                                    size, client);\n\n}\n", "idx": 21612, "_split": "test", "_hash": "e6083fa15d70626a71e9c83c966b7e3d"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static int bdrv_get_cluster_size(BlockDriverState *bs)\n\n{\n\n    BlockDriverInfo bdi;\n\n    int ret;\n\n\n\n    ret = bdrv_get_info(bs, &bdi);\n\n    if (ret < 0 || bdi.cluster_size == 0) {\n\n        return bs->request_alignment;\n\n    } else {\n\n        return bdi.cluster_size;\n\n    }\n\n}\n", "idx": 21622, "_split": "test", "_hash": "9be5e1b6916f7f7f60c8bc1c9f81fd0b"}
{"project": "qemu", "commit_id": "f68945d42bab700d95b87f62e0898606ce2421ed", "target": 1, "func": "void qemu_savevm_state_complete(QEMUFile *f)\n\n{\n\n    QJSON *vmdesc;\n\n    int vmdesc_len;\n\n    SaveStateEntry *se;\n\n    int ret;\n\n\n\n    trace_savevm_state_complete();\n\n\n\n    cpu_synchronize_all_states();\n\n\n\n    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {\n\n        if (!se->ops || !se->ops->save_live_complete) {\n\n            continue;\n\n        }\n\n        if (se->ops && se->ops->is_active) {\n\n            if (!se->ops->is_active(se->opaque)) {\n\n                continue;\n\n            }\n\n        }\n\n        trace_savevm_section_start(se->idstr, se->section_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_END);\n\n\n\n        ret = se->ops->save_live_complete(f, se->opaque);\n\n        trace_savevm_section_end(se->idstr, se->section_id, ret);\n\n\n        if (ret < 0) {\n\n            qemu_file_set_error(f, ret);\n\n            return;\n\n        }\n\n    }\n\n\n\n    vmdesc = qjson_new();\n\n    json_prop_int(vmdesc, \"page_size\", TARGET_PAGE_SIZE);\n\n    json_start_array(vmdesc, \"devices\");\n\n    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {\n\n\n\n        if ((!se->ops || !se->ops->save_state) && !se->vmsd) {\n\n            continue;\n\n        }\n\n        trace_savevm_section_start(se->idstr, se->section_id);\n\n\n\n        json_start_object(vmdesc, NULL);\n\n        json_prop_str(vmdesc, \"name\", se->idstr);\n\n        json_prop_int(vmdesc, \"instance_id\", se->instance_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_FULL);\n\n\n\n        vmstate_save(f, se, vmdesc);\n\n\n\n        json_end_object(vmdesc);\n\n        trace_savevm_section_end(se->idstr, se->section_id, 0);\n\n\n    }\n\n\n\n    qemu_put_byte(f, QEMU_VM_EOF);\n\n\n\n    json_end_array(vmdesc);\n\n    qjson_finish(vmdesc);\n\n    vmdesc_len = strlen(qjson_get_str(vmdesc));\n\n\n\n    if (should_send_vmdesc()) {\n\n        qemu_put_byte(f, QEMU_VM_VMDESCRIPTION);\n\n        qemu_put_be32(f, vmdesc_len);\n\n        qemu_put_buffer(f, (uint8_t *)qjson_get_str(vmdesc), vmdesc_len);\n\n    }\n\n    object_unref(OBJECT(vmdesc));\n\n\n\n    qemu_fflush(f);\n\n}", "idx": 21670, "_split": "test", "_hash": "bc46201be149048b906b2b50f0ec2ee3"}
{"project": "qemu", "commit_id": "f45cb2f43f5bb0a4122a64e61c746048b59a84ed", "target": 1, "func": "static void mvp_init (CPUMIPSState *env, const mips_def_t *def)\n\n{\n\n    env->mvp = g_malloc0(sizeof(CPUMIPSMVPContext));\n\n\n\n    /* MVPConf1 implemented, TLB sharable, no gating storage support,\n\n       programmable cache partitioning implemented, number of allocatable\n\n       and sharable TLB entries, MVP has allocatable TCs, 2 VPEs\n\n       implemented, 5 TCs implemented. */\n\n    env->mvp->CP0_MVPConf0 = (1 << CP0MVPC0_M) | (1 << CP0MVPC0_TLBS) |\n\n                             (0 << CP0MVPC0_GS) | (1 << CP0MVPC0_PCP) |\n\n// TODO: actually do 2 VPEs.\n\n//                             (1 << CP0MVPC0_TCA) | (0x1 << CP0MVPC0_PVPE) |\n\n//                             (0x04 << CP0MVPC0_PTC);\n\n                             (1 << CP0MVPC0_TCA) | (0x0 << CP0MVPC0_PVPE) |\n\n                             (0x00 << CP0MVPC0_PTC);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* Usermode has no TLB support */\n\n    env->mvp->CP0_MVPConf0 |= (env->tlb->nb_tlb << CP0MVPC0_PTLBE);\n\n#endif\n\n\n\n    /* Allocatable CP1 have media extensions, allocatable CP1 have FP support,\n\n       no UDI implemented, no CP2 implemented, 1 CP1 implemented. */\n\n    env->mvp->CP0_MVPConf1 = (1 << CP0MVPC1_CIM) | (1 << CP0MVPC1_CIF) |\n\n                             (0x0 << CP0MVPC1_PCX) | (0x0 << CP0MVPC1_PCP2) |\n\n                             (0x1 << CP0MVPC1_PCP1);\n\n}\n", "idx": 21694, "_split": "test", "_hash": "6c4f664d73cc6b29b2f034a37fdc20c1"}
{"project": "qemu", "commit_id": "de13d2161473d02ae97ec0f8e4503147554892dd", "target": 0, "func": "static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)\n\n{\n\n    VirtIOS390Bus *bus;\n\n    int dev_len;\n\n\n\n    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);\n\n    dev->vdev = vdev;\n\n    dev->dev_offs = bus->dev_offs;\n\n    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */\n\n\n\n    dev_len = VIRTIO_DEV_OFFS_CONFIG;\n\n    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;\n\n    dev_len += dev->feat_len * 2;\n\n    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);\n\n\n\n    bus->dev_offs += dev_len;\n\n\n\n    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,\n\n                                                      dev->host_features);\n\n    s390_virtio_device_sync(dev);\n\n    s390_virtio_reset_idx(dev);\n\n    if (dev->qdev.hotplugged) {\n\n        S390CPU *cpu = s390_cpu_addr2state(0);\n\n        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21723, "_split": "test", "_hash": "7e7aedca3631997efb9c75a637ec795a"}
{"project": "qemu", "commit_id": "0a75601853c00f3729fa62c49ec0d4bb1e3d9bc1", "target": 0, "func": "RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,\n\n                                  void (*resized)(const char*,\n\n                                                  uint64_t length,\n\n                                                  void *host),\n\n                                  void *host, bool resizeable,\n\n                                  MemoryRegion *mr, Error **errp)\n\n{\n\n    RAMBlock *new_block;\n\n    Error *local_err = NULL;\n\n\n\n    size = HOST_PAGE_ALIGN(size);\n\n    max_size = HOST_PAGE_ALIGN(max_size);\n\n    new_block = g_malloc0(sizeof(*new_block));\n\n    new_block->mr = mr;\n\n    new_block->resized = resized;\n\n    new_block->used_length = size;\n\n    new_block->max_length = max_size;\n\n    assert(max_size >= size);\n\n    new_block->fd = -1;\n\n    new_block->host = host;\n\n    if (host) {\n\n        new_block->flags |= RAM_PREALLOC;\n\n    }\n\n    if (resizeable) {\n\n        new_block->flags |= RAM_RESIZEABLE;\n\n    }\n\n    ram_block_add(new_block, &local_err);\n\n    if (local_err) {\n\n        g_free(new_block);\n\n        error_propagate(errp, local_err);\n\n        return NULL;\n\n    }\n\n    mr->ram_block = new_block;\n\n    return new_block;\n\n}\n", "idx": 21731, "_split": "test", "_hash": "70289af2d16e9b311b919fc0fc995a4d"}
{"project": "qemu", "commit_id": "f02ca5cbeaf86038834c1953247a1579d7921927", "target": 0, "func": "static inline void tcg_out_movi(TCGContext *s, TCGType type,\n\n                                int ret, tcg_target_long arg)\n\n{\n\n#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)\n\n    if (arg != (arg & 0xffffffff))\n\n        fprintf(stderr, \"unimplemented %s with constant %ld\\n\", __func__, arg);\n\n#endif\n\n    if (arg == (arg & 0xfff))\n\n        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |\n\n                  INSN_IMM13(arg));\n\n    else {\n\n        tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));\n\n        if (arg & 0x3ff)\n\n            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |\n\n                      INSN_IMM13(arg & 0x3ff));\n\n    }\n\n}\n", "idx": 21739, "_split": "test", "_hash": "2c8f1bf190864205e7790bca788a7661"}
{"project": "qemu", "commit_id": "375092332eeaa6e47561ce47fd36144cdaf964d0", "target": 0, "func": "qcrypto_block_luks_create(QCryptoBlock *block,\n\n                          QCryptoBlockCreateOptions *options,\n\n                          QCryptoBlockInitFunc initfunc,\n\n                          QCryptoBlockWriteFunc writefunc,\n\n                          void *opaque,\n\n                          Error **errp)\n\n{\n\n    QCryptoBlockLUKS *luks;\n\n    QCryptoBlockCreateOptionsLUKS luks_opts;\n\n    Error *local_err = NULL;\n\n    uint8_t *masterkey = NULL;\n\n    uint8_t *slotkey = NULL;\n\n    uint8_t *splitkey = NULL;\n\n    size_t splitkeylen = 0;\n\n    size_t i;\n\n    QCryptoCipher *cipher = NULL;\n\n    QCryptoIVGen *ivgen = NULL;\n\n    char *password;\n\n    const char *cipher_alg;\n\n    const char *cipher_mode;\n\n    const char *ivgen_alg;\n\n    const char *ivgen_hash_alg = NULL;\n\n    const char *hash_alg;\n\n    char *cipher_mode_spec = NULL;\n\n    QCryptoCipherAlgorithm ivcipheralg = 0;\n\n    uint64_t iters;\n\n\n\n    memcpy(&luks_opts, &options->u.luks, sizeof(luks_opts));\n\n    if (!luks_opts.has_iter_time) {\n\n        luks_opts.iter_time = 2000;\n\n    }\n\n    if (!luks_opts.has_cipher_alg) {\n\n        luks_opts.cipher_alg = QCRYPTO_CIPHER_ALG_AES_256;\n\n    }\n\n    if (!luks_opts.has_cipher_mode) {\n\n        luks_opts.cipher_mode = QCRYPTO_CIPHER_MODE_XTS;\n\n    }\n\n    if (!luks_opts.has_ivgen_alg) {\n\n        luks_opts.ivgen_alg = QCRYPTO_IVGEN_ALG_PLAIN64;\n\n    }\n\n    if (!luks_opts.has_hash_alg) {\n\n        luks_opts.hash_alg = QCRYPTO_HASH_ALG_SHA256;\n\n    }\n\n    if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {\n\n        if (!luks_opts.has_ivgen_hash_alg) {\n\n            luks_opts.ivgen_hash_alg = QCRYPTO_HASH_ALG_SHA256;\n\n            luks_opts.has_ivgen_hash_alg = true;\n\n        }\n\n    }\n\n    /* Note we're allowing ivgen_hash_alg to be set even for\n\n     * non-essiv iv generators that don't need a hash. It will\n\n     * be silently ignored, for compatibility with dm-crypt */\n\n\n\n    if (!options->u.luks.key_secret) {\n\n        error_setg(errp, \"Parameter 'key-secret' is required for cipher\");\n\n        return -1;\n\n    }\n\n    password = qcrypto_secret_lookup_as_utf8(luks_opts.key_secret, errp);\n\n    if (!password) {\n\n        return -1;\n\n    }\n\n\n\n    luks = g_new0(QCryptoBlockLUKS, 1);\n\n    block->opaque = luks;\n\n\n\n    memcpy(luks->header.magic, qcrypto_block_luks_magic,\n\n           QCRYPTO_BLOCK_LUKS_MAGIC_LEN);\n\n\n\n    /* We populate the header in native endianness initially and\n\n     * then convert everything to big endian just before writing\n\n     * it out to disk\n\n     */\n\n    luks->header.version = QCRYPTO_BLOCK_LUKS_VERSION;\n\n    qcrypto_block_luks_uuid_gen(luks->header.uuid);\n\n\n\n    cipher_alg = qcrypto_block_luks_cipher_alg_lookup(luks_opts.cipher_alg,\n\n                                                      errp);\n\n    if (!cipher_alg) {\n\n        goto error;\n\n    }\n\n\n\n    cipher_mode = QCryptoCipherMode_lookup[luks_opts.cipher_mode];\n\n    ivgen_alg = QCryptoIVGenAlgorithm_lookup[luks_opts.ivgen_alg];\n\n    if (luks_opts.has_ivgen_hash_alg) {\n\n        ivgen_hash_alg = QCryptoHashAlgorithm_lookup[luks_opts.ivgen_hash_alg];\n\n        cipher_mode_spec = g_strdup_printf(\"%s-%s:%s\", cipher_mode, ivgen_alg,\n\n                                           ivgen_hash_alg);\n\n    } else {\n\n        cipher_mode_spec = g_strdup_printf(\"%s-%s\", cipher_mode, ivgen_alg);\n\n    }\n\n    hash_alg = QCryptoHashAlgorithm_lookup[luks_opts.hash_alg];\n\n\n\n\n\n    if (strlen(cipher_alg) >= QCRYPTO_BLOCK_LUKS_CIPHER_NAME_LEN) {\n\n        error_setg(errp, \"Cipher name '%s' is too long for LUKS header\",\n\n                   cipher_alg);\n\n        goto error;\n\n    }\n\n    if (strlen(cipher_mode_spec) >= QCRYPTO_BLOCK_LUKS_CIPHER_MODE_LEN) {\n\n        error_setg(errp, \"Cipher mode '%s' is too long for LUKS header\",\n\n                   cipher_mode_spec);\n\n        goto error;\n\n    }\n\n    if (strlen(hash_alg) >= QCRYPTO_BLOCK_LUKS_HASH_SPEC_LEN) {\n\n        error_setg(errp, \"Hash name '%s' is too long for LUKS header\",\n\n                   hash_alg);\n\n        goto error;\n\n    }\n\n\n\n    if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {\n\n        ivcipheralg = qcrypto_block_luks_essiv_cipher(luks_opts.cipher_alg,\n\n                                                      luks_opts.ivgen_hash_alg,\n\n                                                      &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            goto error;\n\n        }\n\n    } else {\n\n        ivcipheralg = luks_opts.cipher_alg;\n\n    }\n\n\n\n    strcpy(luks->header.cipher_name, cipher_alg);\n\n    strcpy(luks->header.cipher_mode, cipher_mode_spec);\n\n    strcpy(luks->header.hash_spec, hash_alg);\n\n\n\n    luks->header.key_bytes = qcrypto_cipher_get_key_len(luks_opts.cipher_alg);\n\n    if (luks_opts.cipher_mode == QCRYPTO_CIPHER_MODE_XTS) {\n\n        luks->header.key_bytes *= 2;\n\n    }\n\n\n\n    /* Generate the salt used for hashing the master key\n\n     * with PBKDF later\n\n     */\n\n    if (qcrypto_random_bytes(luks->header.master_key_salt,\n\n                             QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                             errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Generate random master key */\n\n    masterkey = g_new0(uint8_t, luks->header.key_bytes);\n\n    if (qcrypto_random_bytes(masterkey,\n\n                             luks->header.key_bytes, errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Setup the block device payload encryption objects */\n\n    block->cipher = qcrypto_cipher_new(luks_opts.cipher_alg,\n\n                                       luks_opts.cipher_mode,\n\n                                       masterkey, luks->header.key_bytes,\n\n                                       errp);\n\n    if (!block->cipher) {\n\n        goto error;\n\n    }\n\n\n\n    block->kdfhash = luks_opts.hash_alg;\n\n    block->niv = qcrypto_cipher_get_iv_len(luks_opts.cipher_alg,\n\n                                           luks_opts.cipher_mode);\n\n    block->ivgen = qcrypto_ivgen_new(luks_opts.ivgen_alg,\n\n                                     ivcipheralg,\n\n                                     luks_opts.ivgen_hash_alg,\n\n                                     masterkey, luks->header.key_bytes,\n\n                                     errp);\n\n\n\n    if (!block->ivgen) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Determine how many iterations we need to hash the master\n\n     * key, in order to have 1 second of compute time used\n\n     */\n\n    iters = qcrypto_pbkdf2_count_iters(luks_opts.hash_alg,\n\n                                       masterkey, luks->header.key_bytes,\n\n                                       luks->header.master_key_salt,\n\n                                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                                       QCRYPTO_BLOCK_LUKS_DIGEST_LEN,\n\n                                       &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    if (iters > (ULLONG_MAX / luks_opts.iter_time)) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu too large to scale\",\n\n                         (unsigned long long)iters);\n\n        goto error;\n\n    }\n\n\n\n    /* iter_time was in millis, but count_iters reported for secs */\n\n    iters = iters * luks_opts.iter_time / 1000;\n\n\n\n    /* Why /= 8 ?  That matches cryptsetup, but there's no\n\n     * explanation why they chose /= 8... Probably so that\n\n     * if all 8 keyslots are active we only spend 1 second\n\n     * in total time to check all keys */\n\n    iters /= 8;\n\n    if (iters > UINT32_MAX) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu larger than %u\",\n\n                         (unsigned long long)iters, UINT32_MAX);\n\n        goto error;\n\n    }\n\n    iters = MAX(iters, QCRYPTO_BLOCK_LUKS_MIN_MASTER_KEY_ITERS);\n\n    luks->header.master_key_iterations = iters;\n\n\n\n    /* Hash the master key, saving the result in the LUKS\n\n     * header. This hash is used when opening the encrypted\n\n     * device to verify that the user password unlocked a\n\n     * valid master key\n\n     */\n\n    if (qcrypto_pbkdf2(luks_opts.hash_alg,\n\n                       masterkey, luks->header.key_bytes,\n\n                       luks->header.master_key_salt,\n\n                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                       luks->header.master_key_iterations,\n\n                       luks->header.master_key_digest,\n\n                       QCRYPTO_BLOCK_LUKS_DIGEST_LEN,\n\n                       errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Although LUKS has multiple key slots, we're just going\n\n     * to use the first key slot */\n\n    splitkeylen = luks->header.key_bytes * QCRYPTO_BLOCK_LUKS_STRIPES;\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        luks->header.key_slots[i].active = i == 0 ?\n\n            QCRYPTO_BLOCK_LUKS_KEY_SLOT_ENABLED :\n\n            QCRYPTO_BLOCK_LUKS_KEY_SLOT_DISABLED;\n\n        luks->header.key_slots[i].stripes = QCRYPTO_BLOCK_LUKS_STRIPES;\n\n\n\n        /* This calculation doesn't match that shown in the spec,\n\n         * but instead follows the cryptsetup implementation.\n\n         */\n\n        luks->header.key_slots[i].key_offset =\n\n            (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n             QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) +\n\n            (ROUND_UP(DIV_ROUND_UP(splitkeylen, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE),\n\n                      (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n                       QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)) * i);\n\n    }\n\n\n\n    if (qcrypto_random_bytes(luks->header.key_slots[0].salt,\n\n                             QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                             errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Again we determine how many iterations are required to\n\n     * hash the user password while consuming 1 second of compute\n\n     * time */\n\n    iters = qcrypto_pbkdf2_count_iters(luks_opts.hash_alg,\n\n                                       (uint8_t *)password, strlen(password),\n\n                                       luks->header.key_slots[0].salt,\n\n                                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                                       luks->header.key_bytes,\n\n                                       &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    if (iters > (ULLONG_MAX / luks_opts.iter_time)) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu too large to scale\",\n\n                         (unsigned long long)iters);\n\n        goto error;\n\n    }\n\n\n\n    /* iter_time was in millis, but count_iters reported for secs */\n\n    iters = iters * luks_opts.iter_time / 1000;\n\n\n\n    if (iters > UINT32_MAX) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu larger than %u\",\n\n                         (unsigned long long)iters, UINT32_MAX);\n\n        goto error;\n\n    }\n\n\n\n    luks->header.key_slots[0].iterations =\n\n        MAX(iters, QCRYPTO_BLOCK_LUKS_MIN_SLOT_KEY_ITERS);\n\n\n\n\n\n    /* Generate a key that we'll use to encrypt the master\n\n     * key, from the user's password\n\n     */\n\n    slotkey = g_new0(uint8_t, luks->header.key_bytes);\n\n    if (qcrypto_pbkdf2(luks_opts.hash_alg,\n\n                       (uint8_t *)password, strlen(password),\n\n                       luks->header.key_slots[0].salt,\n\n                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                       luks->header.key_slots[0].iterations,\n\n                       slotkey, luks->header.key_bytes,\n\n                       errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Setup the encryption objects needed to encrypt the\n\n     * master key material\n\n     */\n\n    cipher = qcrypto_cipher_new(luks_opts.cipher_alg,\n\n                                luks_opts.cipher_mode,\n\n                                slotkey, luks->header.key_bytes,\n\n                                errp);\n\n    if (!cipher) {\n\n        goto error;\n\n    }\n\n\n\n    ivgen = qcrypto_ivgen_new(luks_opts.ivgen_alg,\n\n                              ivcipheralg,\n\n                              luks_opts.ivgen_hash_alg,\n\n                              slotkey, luks->header.key_bytes,\n\n                              errp);\n\n    if (!ivgen) {\n\n        goto error;\n\n    }\n\n\n\n    /* Before storing the master key, we need to vastly\n\n     * increase its size, as protection against forensic\n\n     * disk data recovery */\n\n    splitkey = g_new0(uint8_t, splitkeylen);\n\n\n\n    if (qcrypto_afsplit_encode(luks_opts.hash_alg,\n\n                               luks->header.key_bytes,\n\n                               luks->header.key_slots[0].stripes,\n\n                               masterkey,\n\n                               splitkey,\n\n                               errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Now we encrypt the split master key with the key generated\n\n     * from the user's password, before storing it */\n\n    if (qcrypto_block_encrypt_helper(cipher, block->niv, ivgen,\n\n                                     QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,\n\n                                     0,\n\n                                     splitkey,\n\n                                     splitkeylen,\n\n                                     errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* The total size of the LUKS headers is the partition header + key\n\n     * slot headers, rounded up to the nearest sector, combined with\n\n     * the size of each master key material region, also rounded up\n\n     * to the nearest sector */\n\n    luks->header.payload_offset =\n\n        (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n         QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) +\n\n        (ROUND_UP(DIV_ROUND_UP(splitkeylen, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE),\n\n                  (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n                   QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)) *\n\n         QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS);\n\n\n\n    block->payload_offset = luks->header.payload_offset *\n\n        QCRYPTO_BLOCK_LUKS_SECTOR_SIZE;\n\n\n\n    /* Reserve header space to match payload offset */\n\n    initfunc(block, block->payload_offset, &local_err, opaque);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    /* Everything on disk uses Big Endian, so flip header fields\n\n     * before writing them */\n\n    cpu_to_be16s(&luks->header.version);\n\n    cpu_to_be32s(&luks->header.payload_offset);\n\n    cpu_to_be32s(&luks->header.key_bytes);\n\n    cpu_to_be32s(&luks->header.master_key_iterations);\n\n\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        cpu_to_be32s(&luks->header.key_slots[i].active);\n\n        cpu_to_be32s(&luks->header.key_slots[i].iterations);\n\n        cpu_to_be32s(&luks->header.key_slots[i].key_offset);\n\n        cpu_to_be32s(&luks->header.key_slots[i].stripes);\n\n    }\n\n\n\n\n\n    /* Write out the partition header and key slot headers */\n\n    writefunc(block, 0,\n\n              (const uint8_t *)&luks->header,\n\n              sizeof(luks->header),\n\n              &local_err,\n\n              opaque);\n\n\n\n    /* Delay checking local_err until we've byte-swapped */\n\n\n\n    /* Byte swap the header back to native, in case we need\n\n     * to read it again later */\n\n    be16_to_cpus(&luks->header.version);\n\n    be32_to_cpus(&luks->header.payload_offset);\n\n    be32_to_cpus(&luks->header.key_bytes);\n\n    be32_to_cpus(&luks->header.master_key_iterations);\n\n\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        be32_to_cpus(&luks->header.key_slots[i].active);\n\n        be32_to_cpus(&luks->header.key_slots[i].iterations);\n\n        be32_to_cpus(&luks->header.key_slots[i].key_offset);\n\n        be32_to_cpus(&luks->header.key_slots[i].stripes);\n\n    }\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    /* Write out the master key material, starting at the\n\n     * sector immediately following the partition header. */\n\n    if (writefunc(block,\n\n                  luks->header.key_slots[0].key_offset *\n\n                  QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,\n\n                  splitkey, splitkeylen,\n\n                  errp,\n\n                  opaque) != splitkeylen) {\n\n        goto error;\n\n    }\n\n\n\n    luks->cipher_alg = luks_opts.cipher_alg;\n\n    luks->cipher_mode = luks_opts.cipher_mode;\n\n    luks->ivgen_alg = luks_opts.ivgen_alg;\n\n    luks->ivgen_hash_alg = luks_opts.ivgen_hash_alg;\n\n    luks->hash_alg = luks_opts.hash_alg;\n\n\n\n    memset(masterkey, 0, luks->header.key_bytes);\n\n    g_free(masterkey);\n\n    memset(slotkey, 0, luks->header.key_bytes);\n\n    g_free(slotkey);\n\n    g_free(splitkey);\n\n    g_free(password);\n\n    g_free(cipher_mode_spec);\n\n\n\n    qcrypto_ivgen_free(ivgen);\n\n    qcrypto_cipher_free(cipher);\n\n\n\n    return 0;\n\n\n\n error:\n\n    if (masterkey) {\n\n        memset(masterkey, 0, luks->header.key_bytes);\n\n    }\n\n    g_free(masterkey);\n\n    if (slotkey) {\n\n        memset(slotkey, 0, luks->header.key_bytes);\n\n    }\n\n    g_free(slotkey);\n\n    g_free(splitkey);\n\n    g_free(password);\n\n    g_free(cipher_mode_spec);\n\n\n\n    qcrypto_ivgen_free(ivgen);\n\n    qcrypto_cipher_free(cipher);\n\n\n\n    g_free(luks);\n\n    return -1;\n\n}\n", "idx": 21740, "_split": "test", "_hash": "6562e5c8d34834dac7e70912a0760dcb"}
{"project": "qemu", "commit_id": "ab3ad07f89c7f9e03c17c98e1d1a02dbf61c605c", "target": 1, "func": "static void kvm_hwpoison_page_add(ram_addr_t ram_addr)\n\n{\n\n    HWPoisonPage *page;\n\n\n\n    QLIST_FOREACH(page, &hwpoison_page_list, list) {\n\n        if (page->ram_addr == ram_addr) {\n\n            return;\n\n        }\n\n    }\n\n    page = g_malloc(sizeof(HWPoisonPage));\n\n    page->ram_addr = ram_addr;\n\n    QLIST_INSERT_HEAD(&hwpoison_page_list, page, list);\n\n}\n", "idx": 21794, "_split": "test", "_hash": "06d5c20b4e3c8199f6589b2c1429612b"}
{"project": "qemu", "commit_id": "43e86c8f5b6d9f6279e20dede4e1f7829bdc43b7", "target": 1, "func": "static void pcie_mmcfg_data_write(PCIBus *s,\n\n                                  uint32_t mmcfg_addr, uint32_t val, int len)\n\n{\n\n    PCIDevice *pci_dev = pcie_dev_find_by_mmcfg_addr(s, mmcfg_addr);\n\n\n\n    if (!pci_dev) {\n\n        return;\n\n    }\n\n    pci_host_config_write_common(pci_dev, PCIE_MMCFG_CONFOFFSET(mmcfg_addr),\n\n                                 pci_config_size(pci_dev), val, len);\n\n}\n", "idx": 21820, "_split": "test", "_hash": "6fb302ca31754a97d6edfb30dfc544c5"}
{"project": "qemu", "commit_id": "147dfab747dd1720cb6350b6b746ca84e15f9a24", "target": 1, "func": "void aio_context_setup(AioContext *ctx, Error **errp)\n\n{\n\n#ifdef CONFIG_EPOLL\n\n    assert(!ctx->epollfd);\n\n    ctx->epollfd = epoll_create1(EPOLL_CLOEXEC);\n\n    if (ctx->epollfd == -1) {\n\n        ctx->epoll_available = false;\n\n    } else {\n\n        ctx->epoll_available = true;\n\n    }\n\n#endif\n\n}\n", "idx": 21836, "_split": "test", "_hash": "fa0015041e788a1de01cac503bc6899a"}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "static void kvm_set_phys_mem(target_phys_addr_t start_addr,\n\n\t\t\t     ram_addr_t size,\n\n\t\t\t     ram_addr_t phys_offset)\n\n{\n\n    KVMState *s = kvm_state;\n\n    ram_addr_t flags = phys_offset & ~TARGET_PAGE_MASK;\n\n    KVMSlot *mem, old;\n\n    int err;\n\n\n\n    /* kvm works in page size chunks, but the function may be called\n\n       with sub-page size and unaligned start address. */\n\n    size = TARGET_PAGE_ALIGN(size);\n\n    start_addr = TARGET_PAGE_ALIGN(start_addr);\n\n\n\n    /* KVM does not support read-only slots */\n\n    phys_offset &= ~IO_MEM_ROM;\n\n\n\n    while (1) {\n\n        mem = kvm_lookup_overlapping_slot(s, start_addr, start_addr + size);\n\n        if (!mem) {\n\n            break;\n\n        }\n\n\n\n        if (flags < IO_MEM_UNASSIGNED && start_addr >= mem->start_addr &&\n\n            (start_addr + size <= mem->start_addr + mem->memory_size) &&\n\n            (phys_offset - start_addr == mem->phys_offset - mem->start_addr)) {\n\n            /* The new slot fits into the existing one and comes with\n\n             * identical parameters - nothing to be done. */\n\n            return;\n\n        }\n\n\n\n        old = *mem;\n\n\n\n        /* unregister the overlapping slot */\n\n        mem->memory_size = 0;\n\n        err = kvm_set_user_memory_region(s, mem);\n\n        if (err) {\n\n            fprintf(stderr, \"%s: error unregistering overlapping slot: %s\\n\",\n\n                    __func__, strerror(-err));\n\n            abort();\n\n        }\n\n\n\n        /* Workaround for older KVM versions: we can't join slots, even not by\n\n         * unregistering the previous ones and then registering the larger\n\n         * slot. We have to maintain the existing fragmentation. Sigh.\n\n         *\n\n         * This workaround assumes that the new slot starts at the same\n\n         * address as the first existing one. If not or if some overlapping\n\n         * slot comes around later, we will fail (not seen in practice so far)\n\n         * - and actually require a recent KVM version. */\n\n        if (s->broken_set_mem_region &&\n\n            old.start_addr == start_addr && old.memory_size < size &&\n\n            flags < IO_MEM_UNASSIGNED) {\n\n            mem = kvm_alloc_slot(s);\n\n            mem->memory_size = old.memory_size;\n\n            mem->start_addr = old.start_addr;\n\n            mem->phys_offset = old.phys_offset;\n\n            mem->flags = 0;\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error updating slot: %s\\n\", __func__,\n\n                        strerror(-err));\n\n                abort();\n\n            }\n\n\n\n            start_addr += old.memory_size;\n\n            phys_offset += old.memory_size;\n\n            size -= old.memory_size;\n\n            continue;\n\n        }\n\n\n\n        /* register prefix slot */\n\n        if (old.start_addr < start_addr) {\n\n            mem = kvm_alloc_slot(s);\n\n            mem->memory_size = start_addr - old.start_addr;\n\n            mem->start_addr = old.start_addr;\n\n            mem->phys_offset = old.phys_offset;\n\n            mem->flags = 0;\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error registering prefix slot: %s\\n\",\n\n                        __func__, strerror(-err));\n\n                abort();\n\n            }\n\n        }\n\n\n\n        /* register suffix slot */\n\n        if (old.start_addr + old.memory_size > start_addr + size) {\n\n            ram_addr_t size_delta;\n\n\n\n            mem = kvm_alloc_slot(s);\n\n            mem->start_addr = start_addr + size;\n\n            size_delta = mem->start_addr - old.start_addr;\n\n            mem->memory_size = old.memory_size - size_delta;\n\n            mem->phys_offset = old.phys_offset + size_delta;\n\n            mem->flags = 0;\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error registering suffix slot: %s\\n\",\n\n                        __func__, strerror(-err));\n\n                abort();\n\n            }\n\n        }\n\n    }\n\n\n\n    /* in case the KVM bug workaround already \"consumed\" the new slot */\n\n    if (!size)\n\n        return;\n\n\n\n    /* KVM does not need to know about this memory */\n\n    if (flags >= IO_MEM_UNASSIGNED)\n\n        return;\n\n\n\n    mem = kvm_alloc_slot(s);\n\n    mem->memory_size = size;\n\n    mem->start_addr = start_addr;\n\n    mem->phys_offset = phys_offset;\n\n    mem->flags = 0;\n\n\n\n    err = kvm_set_user_memory_region(s, mem);\n\n    if (err) {\n\n        fprintf(stderr, \"%s: error registering slot: %s\\n\", __func__,\n\n                strerror(-err));\n\n        abort();\n\n    }\n\n}\n", "idx": 21863, "_split": "test", "_hash": "a08127033804ec64c0017f3d411318c9"}
{"project": "qemu", "commit_id": "0fbf50b6ec126600dca115adb1563c657cc27695", "target": 1, "func": "static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,\n\n                                   unsigned size)\n\n{\n\n}\n", "idx": 21889, "_split": "test", "_hash": "725964248f8a70fdf401a177baf3299c"}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(divw)\n\n{\n\n    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {\n\n        T0 = (int32_t)((-1) * (T0 >> 31));\n\n    } else {\n\n        T0 = (Ts0 / Ts1);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 21957, "_split": "test", "_hash": "b2ea531006f4be06d42ff1afe462ddc2"}
{"project": "qemu", "commit_id": "cdad4bd8940c6fb1616733550663d006c611b2f4", "target": 1, "func": "BlockInterfaceErrorAction drive_get_onerror(BlockDriverState *bdrv)\n\n{\n\n    int index;\n\n\n\n    for (index = 0; index < nb_drives; index++)\n\n        if (drives_table[index].bdrv == bdrv)\n\n            return drives_table[index].onerror;\n\n\n\n    return BLOCK_ERR_REPORT;\n\n}\n", "idx": 21958, "_split": "test", "_hash": "fb103cb5967ca6d6c148cc00c8167c51"}
{"project": "qemu", "commit_id": "671f66f87fbf6cc6a3879f3055f16347b1db91e9", "target": 1, "func": "static void netfilter_finalize(Object *obj)\n\n{\n\n    NetFilterState *nf = NETFILTER(obj);\n\n    NetFilterClass *nfc = NETFILTER_GET_CLASS(obj);\n\n\n\n    if (nfc->cleanup) {\n\n        nfc->cleanup(nf);\n\n    }\n\n\n\n    if (nf->netdev && !QTAILQ_EMPTY(&nf->netdev->filters)) {\n\n        QTAILQ_REMOVE(&nf->netdev->filters, nf, next);\n\n    }\n\n\n}", "idx": 21962, "_split": "test", "_hash": "5d900c8becc236ec17ef3edcc1f16d57"}
{"project": "qemu", "commit_id": "7839ff593be03a7de3c6760e0b50c565ea751d36", "target": 1, "func": "static void pc_compat_1_4(QEMUMachineInitArgs *args)\n\n{\n\n    pc_compat_1_5(args);\n\n    has_pvpanic = false;\n\n    x86_cpu_compat_set_features(\"n270\", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);\n\n    x86_cpu_compat_set_features(\"Westmere\", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);\n\n}\n", "idx": 21967, "_split": "test", "_hash": "07a2846290c63a6bff77b2229df0f6d7"}
{"project": "qemu", "commit_id": "ef0e8fc768a561dd13a86420b3268f6f3d5d0621", "target": 1, "func": "static void amdvi_realize(DeviceState *dev, Error **err)\n\n{\n\n    int ret = 0;\n\n    AMDVIState *s = AMD_IOMMU_DEVICE(dev);\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(dev);\n\n    PCIBus *bus = PC_MACHINE(qdev_get_machine())->bus;\n\n    s->iotlb = g_hash_table_new_full(amdvi_uint64_hash,\n\n                                     amdvi_uint64_equal, g_free, g_free);\n\n\n\n    /* This device should take care of IOMMU PCI properties */\n\n    x86_iommu->type = TYPE_AMD;\n\n    qdev_set_parent_bus(DEVICE(&s->pci), &bus->qbus);\n\n    object_property_set_bool(OBJECT(&s->pci), true, \"realized\", err);\n\n    s->capab_offset = pci_add_capability(&s->pci.dev, AMDVI_CAPAB_ID_SEC, 0,\n\n                                         AMDVI_CAPAB_SIZE);\n\n    assert(s->capab_offset > 0);\n\n    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_MSI, 0, AMDVI_CAPAB_REG_SIZE);\n\n    assert(ret > 0);\n\n    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_HT, 0, AMDVI_CAPAB_REG_SIZE);\n\n    assert(ret > 0);\n\n\n\n    /* set up MMIO */\n\n    memory_region_init_io(&s->mmio, OBJECT(s), &mmio_mem_ops, s, \"amdvi-mmio\",\n\n                          AMDVI_MMIO_SIZE);\n\n\n\n    sysbus_init_mmio(SYS_BUS_DEVICE(s), &s->mmio);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(s), 0, AMDVI_BASE_ADDR);\n\n    pci_setup_iommu(bus, amdvi_host_dma_iommu, s);\n\n    s->devid = object_property_get_int(OBJECT(&s->pci), \"addr\", err);\n\n    msi_init(&s->pci.dev, 0, 1, true, false, err);\n\n    amdvi_init(s);\n\n}\n", "idx": 21969, "_split": "test", "_hash": "da203efee6a0f761587e1f73dd6b8df3"}
{"project": "qemu", "commit_id": "7d91ddd25e3a4e5008a2ac16127d51a34fd56bf1", "target": 1, "func": "static void qemu_net_queue_append(NetQueue *queue,\n\n                                  NetClientState *sender,\n\n                                  unsigned flags,\n\n                                  const uint8_t *buf,\n\n                                  size_t size,\n\n                                  NetPacketSent *sent_cb)\n\n{\n\n    NetPacket *packet;\n\n\n\n    if (queue->nq_count >= queue->nq_maxlen && !sent_cb) {\n\n        return; /* drop if queue full and no callback */\n\n    }\n\n    packet = g_malloc(sizeof(NetPacket) + size);\n\n    packet->sender = sender;\n\n    packet->flags = flags;\n\n    packet->size = size;\n\n    packet->sent_cb = sent_cb;\n\n    memcpy(packet->data, buf, size);\n\n\n\n\n    QTAILQ_INSERT_TAIL(&queue->packets, packet, entry);\n\n}", "idx": 21995, "_split": "test", "_hash": "f92fd228bd2185878072d8e4071192a9"}
{"project": "qemu", "commit_id": "33bef0b9948b85000221d32c758d9d4a9276aaaf", "target": 1, "func": "bool timerlist_expired(QEMUTimerList *timer_list)\n\n{\n\n    int64_t expire_time;\n\n\n\n    if (!atomic_read(&timer_list->active_timers)) {\n\n        return false;\n\n    }\n\n\n\n    qemu_mutex_lock(&timer_list->active_timers_lock);\n\n    if (!timer_list->active_timers) {\n\n        qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n        return false;\n\n    }\n\n    expire_time = timer_list->active_timers->expire_time;\n\n    qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n\n\n    return expire_time < qemu_clock_get_ns(timer_list->clock->type);\n\n}\n", "idx": 22006, "_split": "test", "_hash": "3464402240d32462507115b389d7b329"}
{"project": "qemu", "commit_id": "9fbf0fa81fca8f527669dd4fa72662d66e7d6329", "target": 1, "func": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist,\n\n                                AHCICmdHdr *cmd, int64_t limit, int32_t offset)\n\n{\n\n    uint16_t opts = le16_to_cpu(cmd->opts);\n\n    uint16_t prdtl = le16_to_cpu(cmd->prdtl);\n\n    uint64_t cfis_addr = le64_to_cpu(cmd->tbl_addr);\n\n    uint64_t prdt_addr = cfis_addr + 0x80;\n\n    dma_addr_t prdt_len = (prdtl * sizeof(AHCI_SG));\n\n    dma_addr_t real_prdt_len = prdt_len;\n\n    uint8_t *prdt;\n\n    int i;\n\n    int r = 0;\n\n    uint64_t sum = 0;\n\n    int off_idx = -1;\n\n    int64_t off_pos = -1;\n\n    int tbl_entry_size;\n\n    IDEBus *bus = &ad->port;\n\n    BusState *qbus = BUS(bus);\n\n\n\n    /*\n\n     * Note: AHCI PRDT can describe up to 256GiB. SATA/ATA only support\n\n     * transactions of up to 32MiB as of ATA8-ACS3 rev 1b, assuming a\n\n     * 512 byte sector size. We limit the PRDT in this implementation to\n\n     * a reasonably large 2GiB, which can accommodate the maximum transfer\n\n     * request for sector sizes up to 32K.\n\n     */\n\n\n\n    if (!prdtl) {\n\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n\n        return -1;\n\n    }\n\n\n\n    /* map PRDT */\n\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n\n                                DMA_DIRECTION_TO_DEVICE))){\n\n        DPRINTF(ad->port_no, \"map failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (prdt_len < real_prdt_len) {\n\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n\n        r = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n\n    if (prdtl > 0) {\n\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n\n        sum = 0;\n\n        for (i = 0; i < prdtl; i++) {\n\n            tbl_entry_size = prdt_tbl_entry_size(&tbl[i]);\n\n            if (offset < (sum + tbl_entry_size)) {\n\n                off_idx = i;\n\n                off_pos = offset - sum;\n\n                break;\n\n            }\n\n            sum += tbl_entry_size;\n\n        }\n\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n\n                            \"off_idx: %d, off_pos: %\"PRId64\"\\n\",\n\n                            __func__, off_idx, off_pos);\n\n            r = -1;\n\n            goto out;\n\n        }\n\n\n\n        qemu_sglist_init(sglist, qbus->parent, (prdtl - off_idx),\n\n                         ad->hba->as);\n\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr) + off_pos,\n\n                        MIN(prdt_tbl_entry_size(&tbl[off_idx]) - off_pos,\n\n                            limit));\n\n\n\n        for (i = off_idx + 1; i < prdtl && sglist->size < limit; i++) {\n\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n\n                            MIN(prdt_tbl_entry_size(&tbl[i]),\n\n                                limit - sglist->size));\n\n            if (sglist->size > INT32_MAX) {\n\n                error_report(\"AHCI Physical Region Descriptor Table describes \"\n\n                             \"more than 2 GiB.\");\n\n                qemu_sglist_destroy(sglist);\n\n                r = -1;\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n\n    return r;\n\n}\n", "idx": 22016, "_split": "test", "_hash": "5eadc3c6c09f8592477b4a7e9790d227"}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void error_propagate(Error **dst_errp, Error *local_err)\n\n{\n\n    if (local_err && dst_errp == &error_abort) {\n\n        error_report_err(local_err);\n\n        abort();\n\n    } else if (dst_errp && !*dst_errp) {\n\n        *dst_errp = local_err;\n\n    } else if (local_err) {\n\n        error_free(local_err);\n\n    }\n\n}\n", "idx": 22047, "_split": "test", "_hash": "ac48013cf180d00ee14274be00661476"}
{"project": "qemu", "commit_id": "9bbd4843c052a0a467c7a3363046b0c95c0e5fc0", "target": 1, "func": "gen_msub32_q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32_t n,\n\n             uint32_t up_shift, CPUTriCoreState *env)\n\n{\n\n    TCGv temp = tcg_temp_new();\n\n    TCGv temp2 = tcg_temp_new();\n\n    TCGv temp3 = tcg_temp_new();\n\n    TCGv_i64 t1 = tcg_temp_new_i64();\n\n    TCGv_i64 t2 = tcg_temp_new_i64();\n\n    TCGv_i64 t3 = tcg_temp_new_i64();\n\n    TCGv_i64 t4 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_ext_i32_i64(t2, arg2);\n\n    tcg_gen_ext_i32_i64(t3, arg3);\n\n\n\n    tcg_gen_mul_i64(t2, t2, t3);\n\n\n\n    tcg_gen_ext_i32_i64(t1, arg1);\n\n    /* if we shift part of the fraction out, we need to round up */\n\n    tcg_gen_andi_i64(t4, t2, (1ll << (up_shift - n)) - 1);\n\n    tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);\n\n    tcg_gen_sari_i64(t2, t2, up_shift - n);\n\n    tcg_gen_add_i64(t2, t2, t4);\n\n\n\n    tcg_gen_sub_i64(t3, t1, t2);\n\n    tcg_gen_trunc_i64_i32(temp3, t3);\n\n    /* calc v bit */\n\n    tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);\n\n    tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL);\n\n    tcg_gen_or_i64(t1, t1, t2);\n\n    tcg_gen_trunc_i64_i32(cpu_PSW_V, t1);\n\n    tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);\n\n    /* We produce an overflow on the host if the mul before was\n\n       (0x80000000 * 0x80000000) << 1). If this is the\n\n       case, we negate the ovf. */\n\n    if (n == 1) {\n\n        tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);\n\n        tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);\n\n        tcg_gen_and_tl(temp, temp, temp2);\n\n        tcg_gen_shli_tl(temp, temp, 31);\n\n        /* negate v bit, if special condition */\n\n        tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);\n\n    }\n\n    /* Calc SV bit */\n\n    tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);\n\n    /* Calc AV/SAV bits */\n\n    tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);\n\n    tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);\n\n    /* calc SAV */\n\n    tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);\n\n    /* write back result */\n\n    tcg_gen_mov_tl(ret, temp3);\n\n\n\n    tcg_temp_free(temp);\n\n    tcg_temp_free(temp2);\n\n    tcg_temp_free(temp3);\n\n    tcg_temp_free_i64(t1);\n\n    tcg_temp_free_i64(t2);\n\n    tcg_temp_free_i64(t3);\n\n    tcg_temp_free_i64(t4);\n\n}\n", "idx": 22058, "_split": "test", "_hash": "fdccdc7c95a4df6d9b48f0a1c9362087"}
{"project": "qemu", "commit_id": "b3a6a2e0417c78ec5491347eb85a7d125a5fefdc", "target": 1, "func": "int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )\n\n{\n\n    flag aSign;\n\n    int16 aExp, shiftCount;\n\n    uint64_t aSig, savedASig;\n\n    int32 z;\n\n    a = float64_squash_input_denormal(a STATUS_VAR);\n\n\n\n    aSig = extractFloat64Frac( a );\n\n    aExp = extractFloat64Exp( a );\n\n    aSign = extractFloat64Sign( a );\n\n    if ( 0x41E < aExp ) {\n\n        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;\n\n        goto invalid;\n\n    }\n\n    else if ( aExp < 0x3FF ) {\n\n        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n        return 0;\n\n    }\n\n    aSig |= LIT64( 0x0010000000000000 );\n\n    shiftCount = 0x433 - aExp;\n\n    savedASig = aSig;\n\n    aSig >>= shiftCount;\n\n    z = aSig;\n\n    if ( aSign ) z = - z;\n\n    if ( ( z < 0 ) ^ aSign ) {\n\n invalid:\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;\n\n    }\n\n    if ( ( aSig<<shiftCount ) != savedASig ) {\n\n        STATUS(float_exception_flags) |= float_flag_inexact;\n\n    }\n\n    return z;\n\n\n\n}\n", "idx": 22065, "_split": "test", "_hash": "fe0eb6613c866b4b1a1f73f71bb8914d"}
{"project": "qemu", "commit_id": "67251a311371c4d22e803f151f47fe817175b6c3", "target": 0, "func": "BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,\n\n                                    BlockDriverState *bs, int flags)\n\n{\n\n    assert(bs != NULL);\n\n\n\n    BlockReopenQueueEntry *bs_entry;\n\n    if (bs_queue == NULL) {\n\n        bs_queue = g_new0(BlockReopenQueue, 1);\n\n        QSIMPLEQ_INIT(bs_queue);\n\n    }\n\n\n\n    /* bdrv_open() masks this flag out */\n\n    flags &= ~BDRV_O_PROTOCOL;\n\n\n\n    if (bs->file) {\n\n        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));\n\n    }\n\n\n\n    bs_entry = g_new0(BlockReopenQueueEntry, 1);\n\n    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);\n\n\n\n    bs_entry->state.bs = bs;\n\n    bs_entry->state.flags = flags;\n\n\n\n    return bs_queue;\n\n}\n", "idx": 22082, "_split": "test", "_hash": "038943400c76bfeceebde0cd275108ed"}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)\n\n{\n\n    struct kvm_signal_mask *sigmask;\n\n    int r;\n\n\n\n    if (!sigset)\n\n        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);\n\n\n\n    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));\n\n\n\n    sigmask->len = 8;\n\n    memcpy(sigmask->sigset, sigset, sizeof(*sigset));\n\n    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);\n\n    free(sigmask);\n\n\n\n    return r;\n\n}\n", "idx": 22094, "_split": "test", "_hash": "b2d0d5ba490d868b3bc8462c9efc1408"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int unix_close(void *opaque)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n    close(s->fd);\n\n    g_free(s);\n\n    return 0;\n\n}\n", "idx": 22132, "_split": "test", "_hash": "b65eefe0b3567c2ec4b28a5ea31692a2"}
{"project": "qemu", "commit_id": "9bd7854e1e5d6f4cfe4558090bbd9493c12bf846", "target": 0, "func": "static void fd_chr_read(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    FDCharDriver *s = chr->opaque;\n\n    int size, len;\n\n    uint8_t buf[1024];\n\n\n\n    len = sizeof(buf);\n\n    if (len > s->max_size)\n\n        len = s->max_size;\n\n    if (len == 0)\n\n        return;\n\n    size = read(s->fd_in, buf, len);\n\n    if (size == 0) {\n\n        /* FD has been closed. Remove it from the active list.  */\n\n        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);\n\n        qemu_chr_event(chr, CHR_EVENT_CLOSED);\n\n        return;\n\n    }\n\n    if (size > 0) {\n\n        qemu_chr_read(chr, buf, size);\n\n    }\n\n}\n", "idx": 22140, "_split": "test", "_hash": "c2ce42870b8eea11d95b2d42c4989c15"}
{"project": "qemu", "commit_id": "fc3b32958a80bca13309e2695de07b43dd788421", "target": 0, "func": "static void smbios_build_type_1_fields(QemuOpts *opts)\n\n{\n\n    const char *val;\n\n\n\n    val = qemu_opt_get(opts, \"manufacturer\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, manufacturer_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"product\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, product_name_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"version\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, version_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"serial\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, serial_number_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"uuid\");\n\n    if (val) {\n\n        if (qemu_uuid_parse(val, qemu_uuid) != 0) {\n\n            error_report(\"Invalid UUID\");\n\n            exit(1);\n\n        }\n\n    }\n\n    val = qemu_opt_get(opts, \"sku\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, sku_number_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"family\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, family_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n}\n", "idx": 22151, "_split": "test", "_hash": "ad7cc1c43d8c04cbb60a753157448d8a"}
{"project": "qemu", "commit_id": "5829b097204189c56dd1fb62c7f827360394bb39", "target": 0, "func": "static void vmsvga_fifo_run(struct vmsvga_state_s *s)\n\n{\n\n    uint32_t cmd, colour;\n\n    int args, len;\n\n    int x, y, dx, dy, width, height;\n\n    struct vmsvga_cursor_definition_s cursor;\n\n    uint32_t cmd_start;\n\n\n\n    len = vmsvga_fifo_length(s);\n\n    while (len > 0) {\n\n        /* May need to go back to the start of the command if incomplete */\n\n        cmd_start = s->cmd->stop;\n\n\n\n        switch (cmd = vmsvga_fifo_read(s)) {\n\n        case SVGA_CMD_UPDATE:\n\n        case SVGA_CMD_UPDATE_VERBOSE:\n\n            len -= 5;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            width = vmsvga_fifo_read(s);\n\n            height = vmsvga_fifo_read(s);\n\n            vmsvga_update_rect_delayed(s, x, y, width, height);\n\n            break;\n\n\n\n        case SVGA_CMD_RECT_FILL:\n\n            len -= 6;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            colour = vmsvga_fifo_read(s);\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            width = vmsvga_fifo_read(s);\n\n            height = vmsvga_fifo_read(s);\n\n#ifdef HW_FILL_ACCEL\n\n            if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {\n\n                break;\n\n            }\n\n#endif\n\n            args = 0;\n\n            goto badcmd;\n\n\n\n        case SVGA_CMD_RECT_COPY:\n\n            len -= 7;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            dx = vmsvga_fifo_read(s);\n\n            dy = vmsvga_fifo_read(s);\n\n            width = vmsvga_fifo_read(s);\n\n            height = vmsvga_fifo_read(s);\n\n#ifdef HW_RECT_ACCEL\n\n            if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {\n\n                break;\n\n            }\n\n#endif\n\n            args = 0;\n\n            goto badcmd;\n\n\n\n        case SVGA_CMD_DEFINE_CURSOR:\n\n            len -= 8;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            cursor.id = vmsvga_fifo_read(s);\n\n            cursor.hot_x = vmsvga_fifo_read(s);\n\n            cursor.hot_y = vmsvga_fifo_read(s);\n\n            cursor.width = x = vmsvga_fifo_read(s);\n\n            cursor.height = y = vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            cursor.bpp = vmsvga_fifo_read(s);\n\n\n\n            args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);\n\n            if (SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||\n\n                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {\n\n                    goto badcmd;\n\n            }\n\n\n\n            len -= args;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {\n\n                cursor.mask[args] = vmsvga_fifo_read_raw(s);\n\n            }\n\n            for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {\n\n                cursor.image[args] = vmsvga_fifo_read_raw(s);\n\n            }\n\n#ifdef HW_MOUSE_ACCEL\n\n            vmsvga_cursor_define(s, &cursor);\n\n            break;\n\n#else\n\n            args = 0;\n\n            goto badcmd;\n\n#endif\n\n\n\n        /*\n\n         * Other commands that we at least know the number of arguments\n\n         * for so we can avoid FIFO desync if driver uses them illegally.\n\n         */\n\n        case SVGA_CMD_DEFINE_ALPHA_CURSOR:\n\n            len -= 6;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            args = x * y;\n\n            goto badcmd;\n\n        case SVGA_CMD_RECT_ROP_FILL:\n\n            args = 6;\n\n            goto badcmd;\n\n        case SVGA_CMD_RECT_ROP_COPY:\n\n            args = 7;\n\n            goto badcmd;\n\n        case SVGA_CMD_DRAW_GLYPH_CLIPPED:\n\n            len -= 4;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            args = 7 + (vmsvga_fifo_read(s) >> 2);\n\n            goto badcmd;\n\n        case SVGA_CMD_SURFACE_ALPHA_BLEND:\n\n            args = 12;\n\n            goto badcmd;\n\n\n\n        /*\n\n         * Other commands that are not listed as depending on any\n\n         * CAPABILITIES bits, but are not described in the README either.\n\n         */\n\n        case SVGA_CMD_SURFACE_FILL:\n\n        case SVGA_CMD_SURFACE_COPY:\n\n        case SVGA_CMD_FRONT_ROP_FILL:\n\n        case SVGA_CMD_FENCE:\n\n        case SVGA_CMD_INVALID_CMD:\n\n            break; /* Nop */\n\n\n\n        default:\n\n            args = 0;\n\n        badcmd:\n\n            len -= args;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            while (args--) {\n\n                vmsvga_fifo_read(s);\n\n            }\n\n            printf(\"%s: Unknown command 0x%02x in SVGA command FIFO\\n\",\n\n                   __func__, cmd);\n\n            break;\n\n\n\n        rewind:\n\n            s->cmd->stop = cmd_start;\n\n            break;\n\n        }\n\n    }\n\n\n\n    s->syncing = 0;\n\n}\n", "idx": 22155, "_split": "test", "_hash": "73f794e66a7b463f64dd717cd057cd51"}
{"project": "qemu", "commit_id": "69583490856713f693291b32fc74b6d0f5992b72", "target": 1, "func": "static int hdev_get_max_segments(const struct stat *st)\n\n{\n\n#ifdef CONFIG_LINUX\n\n    char buf[32];\n\n    const char *end;\n\n    char *sysfspath;\n\n    int ret;\n\n    int fd = -1;\n\n    long max_segments;\n\n\n\n    sysfspath = g_strdup_printf(\"/sys/dev/block/%u:%u/queue/max_segments\",\n\n                                major(st->st_rdev), minor(st->st_rdev));\n\n    fd = open(sysfspath, O_RDONLY);\n\n    if (fd == -1) {\n\n        ret = -errno;\n\n        goto out;\n\n    }\n\n    do {\n\n        ret = read(fd, buf, sizeof(buf));\n\n    } while (ret == -1 && errno == EINTR);\n\n    if (ret < 0) {\n\n        ret = -errno;\n\n        goto out;\n\n    } else if (ret == 0) {\n\n        ret = -EIO;\n\n        goto out;\n\n    }\n\n    buf[ret] = 0;\n\n    /* The file is ended with '\\n', pass 'end' to accept that. */\n\n    ret = qemu_strtol(buf, &end, 10, &max_segments);\n\n    if (ret == 0 && end && *end == '\\n') {\n\n        ret = max_segments;\n\n    }\n\n\n\nout:\n\n    g_free(sysfspath);\n\n    return ret;\n\n#else\n\n    return -ENOTSUP;\n\n#endif\n\n}\n", "idx": 22167, "_split": "test", "_hash": "659b60f5241eef3f301919f7ae2970f5"}
{"project": "qemu", "commit_id": "3db3659bf60094657e1465cc809acb09551816ee", "target": 0, "func": "static void apic_update_irq(APICCommonState *s)\n\n{\n\n    if (!(s->spurious_vec & APIC_SV_ENABLE)) {\n\n        return;\n\n    }\n\n    if (apic_irq_pending(s) > 0) {\n\n        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);\n\n    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&\n\n               pic_get_output(isa_pic)) {\n\n        apic_deliver_pic_intr(&s->busdev.qdev, 1);\n\n    }\n\n}\n", "idx": 22201, "_split": "test", "_hash": "0e3f824e8cdd8dbd6d949f1701ac2084"}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(extsh)\n\n{\n\n    T0 = (int32_t)((int16_t)(Ts0));\n\n    RETURN();\n\n}\n", "idx": 22250, "_split": "test", "_hash": "43544cb6181a331063cd7766ceb08c6f"}
{"project": "qemu", "commit_id": "113fe792fd4931dd0538f03859278b8719ee4fa2", "target": 1, "func": "static int nfs_file_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp) {\n\n    NFSClient *client = bs->opaque;\n\n    int64_t ret;\n\n\n\n    client->aio_context = bdrv_get_aio_context(bs);\n\n\n\n    ret = nfs_client_open(client, options,\n\n                          (flags & BDRV_O_RDWR) ? O_RDWR : O_RDONLY,\n\n                          bs->open_flags, errp);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    qemu_mutex_init(&client->mutex);\n\n    bs->total_sectors = ret;\n\n    ret = 0;\n\n    return ret;\n\n}\n", "idx": 22265, "_split": "test", "_hash": "51e7aaf48ac2a7e4888dda9a3e9f2575"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t pmac_ide_readb (void *opaque,target_phys_addr_t addr)\n\n{\n\n    uint8_t retval;\n\n    MACIOIDEState *d = opaque;\n\n\n\n    addr = (addr & 0xFFF) >> 4;\n\n    switch (addr) {\n\n    case 1 ... 7:\n\n        retval = ide_ioport_read(&d->bus, addr);\n\n        break;\n\n    case 8:\n\n    case 22:\n\n        retval = ide_status_read(&d->bus, 0);\n\n        break;\n\n    default:\n\n        retval = 0xFF;\n\n        break;\n\n    }\n\n    return retval;\n\n}\n", "idx": 22270, "_split": "test", "_hash": "c65a0a2d5fd0d2d9dcdb786bbd61aba6"}
{"project": "qemu", "commit_id": "21a0b6ed1dd9f1d8e3d953954847776c8697bd99", "target": 0, "func": "target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)\n\n{\n\n    uint32_t tlbncfg;\n\n    int tlbn = booke206_tlbm_to_tlbn(env, tlb);\n\n    int tlbm_size;\n\n\n\n    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];\n\n\n\n    if (tlbncfg & TLBnCFG_AVAIL) {\n\n        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;\n\n    } else {\n\n        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;\n\n        tlbm_size <<= 1;\n\n    }\n\n\n\n    return 1024ULL << tlbm_size;\n\n}\n", "idx": 22276, "_split": "test", "_hash": "ea372d62ffda7e121b6b40b1c6f307ec"}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)\n\n{\n\n    usb_packet_setup(&xfer->packet,\n\n                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,\n\n                     xfer->xhci->slots[xfer->slotid-1].devaddr,\n\n                     ep & 0x7f);\n\n    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);\n\n    DPRINTF(\"xhci: setup packet pid 0x%x addr %d ep %d\\n\",\n\n            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);\n\n    return 0;\n\n}\n", "idx": 22279, "_split": "test", "_hash": "a609e216305aa6d2d2ff8b0a404a840d"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void thread_pool_cancel(BlockAIOCB *acb)\n\n{\n\n    ThreadPoolElement *elem = (ThreadPoolElement *)acb;\n\n    ThreadPool *pool = elem->pool;\n\n\n\n    trace_thread_pool_cancel(elem, elem->common.opaque);\n\n\n\n    qemu_mutex_lock(&pool->lock);\n\n    if (elem->state == THREAD_QUEUED &&\n\n        /* No thread has yet started working on elem. we can try to \"steal\"\n\n         * the item from the worker if we can get a signal from the\n\n         * semaphore.  Because this is non-blocking, we can do it with\n\n         * the lock taken and ensure that elem will remain THREAD_QUEUED.\n\n         */\n\n        qemu_sem_timedwait(&pool->sem, 0) == 0) {\n\n        QTAILQ_REMOVE(&pool->request_list, elem, reqs);\n\n        qemu_bh_schedule(pool->completion_bh);\n\n\n\n        elem->state = THREAD_DONE;\n\n        elem->ret = -ECANCELED;\n\n    }\n\n\n\n    qemu_mutex_unlock(&pool->lock);\n\n}\n", "idx": 22280, "_split": "test", "_hash": "a087b8d073791e00e803ecb5c32452b7"}
{"project": "qemu", "commit_id": "c20b7fa4b2fedd979bcb0cc974bb5d08a10e3448", "target": 1, "func": "static void monitor_protocol_event_init(void)\n\n{\n\n    qemu_mutex_init(&monitor_event_state_lock);\n\n    /* Limit RTC & BALLOON events to 1 per second */\n\n    monitor_protocol_event_throttle(QEVENT_RTC_CHANGE, 1000);\n\n    monitor_protocol_event_throttle(QEVENT_BALLOON_CHANGE, 1000);\n\n    monitor_protocol_event_throttle(QEVENT_WATCHDOG, 1000);\n\n}\n", "idx": 22300, "_split": "test", "_hash": "8801ec3431ed50faf571dda6fa311ffc"}
{"project": "qemu", "commit_id": "5229f45bd98558af84d806a98032df3cb741c357", "target": 0, "func": "AUXReply aux_request(AUXBus *bus, AUXCommand cmd, uint32_t address,\n\n                      uint8_t len, uint8_t *data)\n\n{\n\n    AUXReply ret = AUX_NACK;\n\n    I2CBus *i2c_bus = aux_get_i2c_bus(bus);\n\n    size_t i;\n\n    bool is_write = false;\n\n\n\n    DPRINTF(\"request at address 0x%\" PRIX32 \", command %u, len %u\\n\", address,\n\n            cmd, len);\n\n\n\n    switch (cmd) {\n\n    /*\n\n     * Forward the request on the AUX bus..\n\n     */\n\n    case WRITE_AUX:\n\n    case READ_AUX:\n\n        is_write = cmd == READ_AUX ? false : true;\n\n        for (i = 0; i < len; i++) {\n\n            if (!address_space_rw(&bus->aux_addr_space, address++,\n\n                                  MEMTXATTRS_UNSPECIFIED, data++, 1,\n\n                                  is_write)) {\n\n                ret = AUX_I2C_ACK;\n\n            } else {\n\n                ret = AUX_NACK;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    /*\n\n     * Classic I2C transactions..\n\n     */\n\n    case READ_I2C:\n\n    case WRITE_I2C:\n\n        is_write = cmd == READ_I2C ? false : true;\n\n        if (i2c_bus_busy(i2c_bus)) {\n\n            i2c_end_transfer(i2c_bus);\n\n        }\n\n\n\n        if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n            ret = AUX_I2C_NACK;\n\n            break;\n\n        }\n\n\n\n        ret = AUX_I2C_ACK;\n\n        while (len > 0) {\n\n            if (i2c_send_recv(i2c_bus, data++, is_write) < 0) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n            len--;\n\n        }\n\n        i2c_end_transfer(i2c_bus);\n\n        break;\n\n    /*\n\n     * I2C MOT transactions.\n\n     *\n\n     * Here we send a start when:\n\n     *  - We didn't start transaction yet.\n\n     *  - We had a READ and we do a WRITE.\n\n     *  - We changed the address.\n\n     */\n\n    case WRITE_I2C_MOT:\n\n    case READ_I2C_MOT:\n\n        is_write = cmd == READ_I2C_MOT ? false : true;\n\n        if (!i2c_bus_busy(i2c_bus)) {\n\n            /*\n\n             * No transactions started..\n\n             */\n\n            if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n        } else if ((address != bus->last_i2c_address) ||\n\n                   (bus->last_transaction != cmd)) {\n\n            /*\n\n             * Transaction started but we need to restart..\n\n             */\n\n            i2c_end_transfer(i2c_bus);\n\n            if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n        }\n\n\n\n        while (len > 0) {\n\n            if (i2c_send_recv(i2c_bus, data++, is_write) < 0) {\n\n                ret = AUX_I2C_NACK;\n\n                i2c_end_transfer(i2c_bus);\n\n                break;\n\n            }\n\n            len--;\n\n        }\n\n        bus->last_transaction = cmd;\n\n        bus->last_i2c_address = address;\n\n        ret = AUX_I2C_ACK;\n\n        break;\n\n    default:\n\n        DPRINTF(\"Not implemented!\\n\");\n\n        return AUX_NACK;\n\n    }\n\n\n\n    DPRINTF(\"reply: %u\\n\", ret);\n\n    return ret;\n\n}\n", "idx": 22330, "_split": "test", "_hash": "f3b05d700995e1c282731618df51cb00"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "MigrationInfo *qmp_query_migrate(Error **errp)\n\n{\n\n    MigrationInfo *info = g_malloc0(sizeof(*info));\n\n    MigrationState *s = migrate_get_current();\n\n\n\n    switch (s->state) {\n\n    case MIG_STATE_NONE:\n\n        /* no migration has happened ever */\n\n        break;\n\n    case MIG_STATE_SETUP:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"setup\");\n\n        info->has_total_time = false;\n\n        break;\n\n    case MIG_STATE_ACTIVE:\n\n    case MIG_STATE_CANCELLING:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"active\");\n\n        info->has_total_time = true;\n\n        info->total_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME)\n\n            - s->total_time;\n\n        info->has_expected_downtime = true;\n\n        info->expected_downtime = s->expected_downtime;\n\n        info->has_setup_time = true;\n\n        info->setup_time = s->setup_time;\n\n\n\n        info->has_ram = true;\n\n        info->ram = g_malloc0(sizeof(*info->ram));\n\n        info->ram->transferred = ram_bytes_transferred();\n\n        info->ram->remaining = ram_bytes_remaining();\n\n        info->ram->total = ram_bytes_total();\n\n        info->ram->duplicate = dup_mig_pages_transferred();\n\n        info->ram->skipped = skipped_mig_pages_transferred();\n\n        info->ram->normal = norm_mig_pages_transferred();\n\n        info->ram->normal_bytes = norm_mig_bytes_transferred();\n\n        info->ram->dirty_pages_rate = s->dirty_pages_rate;\n\n        info->ram->mbps = s->mbps;\n\n        info->ram->dirty_sync_count = s->dirty_sync_count;\n\n\n\n        if (blk_mig_active()) {\n\n            info->has_disk = true;\n\n            info->disk = g_malloc0(sizeof(*info->disk));\n\n            info->disk->transferred = blk_mig_bytes_transferred();\n\n            info->disk->remaining = blk_mig_bytes_remaining();\n\n            info->disk->total = blk_mig_bytes_total();\n\n        }\n\n\n\n        get_xbzrle_cache_stats(info);\n\n        break;\n\n    case MIG_STATE_COMPLETED:\n\n        get_xbzrle_cache_stats(info);\n\n\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"completed\");\n\n        info->has_total_time = true;\n\n        info->total_time = s->total_time;\n\n        info->has_downtime = true;\n\n        info->downtime = s->downtime;\n\n        info->has_setup_time = true;\n\n        info->setup_time = s->setup_time;\n\n\n\n        info->has_ram = true;\n\n        info->ram = g_malloc0(sizeof(*info->ram));\n\n        info->ram->transferred = ram_bytes_transferred();\n\n        info->ram->remaining = 0;\n\n        info->ram->total = ram_bytes_total();\n\n        info->ram->duplicate = dup_mig_pages_transferred();\n\n        info->ram->skipped = skipped_mig_pages_transferred();\n\n        info->ram->normal = norm_mig_pages_transferred();\n\n        info->ram->normal_bytes = norm_mig_bytes_transferred();\n\n        info->ram->mbps = s->mbps;\n\n        info->ram->dirty_sync_count = s->dirty_sync_count;\n\n        break;\n\n    case MIG_STATE_ERROR:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"failed\");\n\n        break;\n\n    case MIG_STATE_CANCELLED:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"cancelled\");\n\n        break;\n\n    }\n\n\n\n    return info;\n\n}\n", "idx": 22364, "_split": "test", "_hash": "f7de6afc9496a80671091409af7e85d6"}
{"project": "qemu", "commit_id": "b0ad5a455d7e5352d4c86ba945112011dbeadfb8", "target": 1, "func": "static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)\n\n{\n\n    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;\n\n    uint8_t bitmap;\n\n\n\n    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=\n\n\t    sizeof(bitmap)) {\n\n       return -errno;\n\n    }\n\n\n\n    bitmap |= (1 << (bitnum % 8));\n\n\n\n    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=\n\n\t    sizeof(bitmap)) {\n\n       return -errno;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22365, "_split": "test", "_hash": "0f3edb9c4feac113794b741b5fdd931c"}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(cmpl)\n\n{\n\n    if (T0 < T1) {\n\n        T0 = 0x08;\n\n    } else if (T0 > T1) {\n\n        T0 = 0x04;\n\n    } else {\n\n        T0 = 0x02;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 22369, "_split": "test", "_hash": "e7c2c8d4304d08fc3236d0c54770a419"}
{"project": "qemu", "commit_id": "e78815a554adaa551d62a71be10ee2fcf128e473", "target": 1, "func": "int ram_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    ram_addr_t addr;\n\n    int flags;\n\n\n\n    if (version_id < 3 || version_id > 4) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    do {\n\n        addr = qemu_get_be64(f);\n\n\n\n        flags = addr & ~TARGET_PAGE_MASK;\n\n        addr &= TARGET_PAGE_MASK;\n\n\n\n        if (flags & RAM_SAVE_FLAG_MEM_SIZE) {\n\n            if (version_id == 3) {\n\n                if (addr != ram_bytes_total()) {\n\n                    return -EINVAL;\n\n                }\n\n            } else {\n\n                /* Synchronize RAM block list */\n\n                char id[256];\n\n                ram_addr_t length;\n\n                ram_addr_t total_ram_bytes = addr;\n\n\n\n                while (total_ram_bytes) {\n\n                    RAMBlock *block;\n\n                    uint8_t len;\n\n\n\n                    len = qemu_get_byte(f);\n\n                    qemu_get_buffer(f, (uint8_t *)id, len);\n\n                    id[len] = 0;\n\n                    length = qemu_get_be64(f);\n\n\n\n                    QLIST_FOREACH(block, &ram_list.blocks, next) {\n\n                        if (!strncmp(id, block->idstr, sizeof(id))) {\n\n                            if (block->length != length)\n\n                                return -EINVAL;\n\n                            break;\n\n                        }\n\n                    }\n\n\n\n                    if (!block) {\n\n                        fprintf(stderr, \"Unknown ramblock \\\"%s\\\", cannot \"\n\n                                \"accept migration\\n\", id);\n\n                        return -EINVAL;\n\n                    }\n\n\n\n                    total_ram_bytes -= length;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (flags & RAM_SAVE_FLAG_COMPRESS) {\n\n            void *host;\n\n            uint8_t ch;\n\n\n\n            if (version_id == 3)\n\n                host = qemu_get_ram_ptr(addr);\n\n            else\n\n                host = host_from_stream_offset(f, addr, flags);\n\n\n\n            ch = qemu_get_byte(f);\n\n            memset(host, ch, TARGET_PAGE_SIZE);\n\n#ifndef _WIN32\n\n            if (ch == 0 &&\n\n                (!kvm_enabled() || kvm_has_sync_mmu())) {\n\n                madvise(host, TARGET_PAGE_SIZE, MADV_DONTNEED);\n\n            }\n\n#endif\n\n        } else if (flags & RAM_SAVE_FLAG_PAGE) {\n\n            void *host;\n\n\n\n            if (version_id == 3)\n\n                host = qemu_get_ram_ptr(addr);\n\n            else\n\n                host = host_from_stream_offset(f, addr, flags);\n\n\n\n            qemu_get_buffer(f, host, TARGET_PAGE_SIZE);\n\n        }\n\n        if (qemu_file_has_error(f)) {\n\n            return -EIO;\n\n        }\n\n    } while (!(flags & RAM_SAVE_FLAG_EOS));\n\n\n\n    return 0;\n\n}\n", "idx": 22381, "_split": "test", "_hash": "883657ba4726bc46fb3a6ed85e1afb1b"}
{"project": "qemu", "commit_id": "111049a4ecefc9cf1ac75c773f4c5c165f27fe63", "target": 1, "func": "static void drive_backup_prepare(BlkActionState *common, Error **errp)\n\n{\n\n    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);\n\n    BlockDriverState *bs;\n\n    DriveBackup *backup;\n\n    Error *local_err = NULL;\n\n\n\n    assert(common->action->type == TRANSACTION_ACTION_KIND_DRIVE_BACKUP);\n\n    backup = common->action->u.drive_backup.data;\n\n\n\n    bs = qmp_get_root_bs(backup->device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    /* AioContext is released in .clean() */\n\n    state->aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(state->aio_context);\n\n    bdrv_drained_begin(bs);\n\n    state->bs = bs;\n\n\n\n    do_drive_backup(backup, common->block_job_txn, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    state->job = state->bs->job;\n\n}\n", "idx": 22387, "_split": "test", "_hash": "25a5be25a96638de448a026d97c70894"}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "static inline void RET_STOP (DisasContext *ctx)\n\n{\n\n    gen_op_update_nip((ctx)->nip);\n\n    ctx->exception = EXCP_MTMSR;\n\n}\n", "idx": 22389, "_split": "test", "_hash": "1204ed31e6f1adcd36f3183127b795de"}
{"project": "qemu", "commit_id": "91cda45b69e45a089f9989979a65db3f710c9925", "target": 0, "func": "static int get_segment64(CPUPPCState *env, struct mmu_ctx_hash64 *ctx,\n\n                         target_ulong eaddr, int rw, int type)\n\n{\n\n    hwaddr hash;\n\n    target_ulong vsid;\n\n    int pr, target_page_bits;\n\n    int ret, ret2;\n\n\n\n    pr = msr_pr;\n\n    ctx->eaddr = eaddr;\n\n    ppc_slb_t *slb;\n\n    target_ulong pageaddr;\n\n    int segment_bits;\n\n\n\n    LOG_MMU(\"Check SLBs\\n\");\n\n    slb = slb_lookup(env, eaddr);\n\n    if (!slb) {\n\n        return -5;\n\n    }\n\n\n\n    if (slb->vsid & SLB_VSID_B) {\n\n        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT_1T;\n\n        segment_bits = 40;\n\n    } else {\n\n        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT;\n\n        segment_bits = 28;\n\n    }\n\n\n\n    target_page_bits = (slb->vsid & SLB_VSID_L)\n\n        ? TARGET_PAGE_BITS_16M : TARGET_PAGE_BITS;\n\n    ctx->key = !!(pr ? (slb->vsid & SLB_VSID_KP)\n\n                  : (slb->vsid & SLB_VSID_KS));\n\n    ctx->nx = !!(slb->vsid & SLB_VSID_N);\n\n\n\n    pageaddr = eaddr & ((1ULL << segment_bits)\n\n                            - (1ULL << target_page_bits));\n\n    if (slb->vsid & SLB_VSID_B) {\n\n        hash = vsid ^ (vsid << 25) ^ (pageaddr >> target_page_bits);\n\n    } else {\n\n        hash = vsid ^ (pageaddr >> target_page_bits);\n\n    }\n\n    /* Only 5 bits of the page index are used in the AVPN */\n\n    ctx->ptem = (slb->vsid & SLB_VSID_PTEM) |\n\n        ((pageaddr >> 16) & ((1ULL << segment_bits) - 0x80));\n\n\n\n    LOG_MMU(\"pte segment: key=%d nx %d vsid \" TARGET_FMT_lx \"\\n\",\n\n            ctx->key, ctx->nx, vsid);\n\n    ret = -1;\n\n\n\n    /* Check if instruction fetch is allowed, if needed */\n\n    if (type != ACCESS_CODE || ctx->nx == 0) {\n\n        /* Page address translation */\n\n        LOG_MMU(\"htab_base \" TARGET_FMT_plx \" htab_mask \" TARGET_FMT_plx\n\n                \" hash \" TARGET_FMT_plx \"\\n\",\n\n                env->htab_base, env->htab_mask, hash);\n\n        ctx->hash[0] = hash;\n\n        ctx->hash[1] = ~hash;\n\n\n\n        /* Initialize real address with an invalid value */\n\n        ctx->raddr = (hwaddr)-1ULL;\n\n        LOG_MMU(\"0 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                \" vsid=\" TARGET_FMT_lx \" ptem=\" TARGET_FMT_lx\n\n                \" hash=\" TARGET_FMT_plx \"\\n\",\n\n                env->htab_base, env->htab_mask, vsid, ctx->ptem,\n\n                ctx->hash[0]);\n\n        /* Primary table lookup */\n\n        ret = find_pte64(env, ctx, 0, rw, type, target_page_bits);\n\n        if (ret < 0) {\n\n            /* Secondary table lookup */\n\n            LOG_MMU(\"1 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                    \" vsid=\" TARGET_FMT_lx \" api=\" TARGET_FMT_lx\n\n                    \" hash=\" TARGET_FMT_plx \"\\n\", env->htab_base,\n\n                    env->htab_mask, vsid, ctx->ptem, ctx->hash[1]);\n\n            ret2 = find_pte64(env, ctx, 1, rw, type, target_page_bits);\n\n            if (ret2 != -1) {\n\n                ret = ret2;\n\n            }\n\n        }\n\n    } else {\n\n        LOG_MMU(\"No access allowed\\n\");\n\n        ret = -3;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 22399, "_split": "test", "_hash": "f6d84cc4c28398fc46b9ae227f0e88e0"}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int v9fs_receivefd(int sockfd, int *status)\n\n{\n\n    struct iovec iov;\n\n    struct msghdr msg;\n\n    struct cmsghdr *cmsg;\n\n    int retval, data, fd;\n\n    union MsgControl msg_control;\n\n\n\n    iov.iov_base = &data;\n\n    iov.iov_len = sizeof(data);\n\n\n\n    memset(&msg, 0, sizeof(msg));\n\n    msg.msg_iov = &iov;\n\n    msg.msg_iovlen = 1;\n\n    msg.msg_control = &msg_control;\n\n    msg.msg_controllen = sizeof(msg_control);\n\n\n\n    do {\n\n        retval = recvmsg(sockfd, &msg, 0);\n\n    } while (retval < 0 && errno == EINTR);\n\n    if (retval <= 0) {\n\n        return retval;\n\n    }\n\n    /*\n\n     * data is set to V9FS_FD_VALID, if ancillary data is sent.  If this\n\n     * request doesn't need ancillary data (fd) or an error occurred,\n\n     * data is set to negative errno value.\n\n     */\n\n    if (data != V9FS_FD_VALID) {\n\n        *status = data;\n\n        return 0;\n\n    }\n\n    /*\n\n     * File descriptor (fd) is sent in the ancillary data. Check if we\n\n     * indeed received it. One of the reasons to fail to receive it is if\n\n     * we exceeded the maximum number of file descriptors!\n\n     */\n\n    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\n        if (cmsg->cmsg_len != CMSG_LEN(sizeof(int)) ||\n\n            cmsg->cmsg_level != SOL_SOCKET ||\n\n            cmsg->cmsg_type != SCM_RIGHTS) {\n\n            continue;\n\n        }\n\n        fd = *((int *)CMSG_DATA(cmsg));\n\n        *status = fd;\n\n        return 0;\n\n    }\n\n    *status = -ENFILE;  /* Ancillary data sent but not received */\n\n    return 0;\n\n}\n", "idx": 22413, "_split": "test", "_hash": "9d97f1084d64336550457711126f9652"}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,\n\n                                  int flag)\n\n{\n\n    struct kvm_x86_mce_data data = {\n\n        .env = env,\n\n        .mce = mce,\n\n        .abort_on_error = (flag & ABORT_ON_ERROR),\n\n    };\n\n\n\n    if (!env->mcg_cap) {\n\n        fprintf(stderr, \"MCE support is not enabled!\\n\");\n\n        return;\n\n    }\n\n\n\n    run_on_cpu(env, kvm_do_inject_x86_mce, &data);\n\n}\n", "idx": 22417, "_split": "test", "_hash": "c40d47fcaf5179e1db873e20e8bb633a"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static AioHandler *find_aio_handler(AioContext *ctx, int fd)\n\n{\n\n    AioHandler *node;\n\n\n\n    QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n        if (node->pfd.fd == fd)\n\n            if (!node->deleted)\n\n                return node;\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 22418, "_split": "test", "_hash": "380d17ec73357e6df4df8b1bad9d1426"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void disas_xtensa_insn(CPUXtensaState *env, DisasContext *dc)\n\n{\n\n#define HAS_OPTION_BITS(opt) do { \\\n\n        if (!option_bits_enabled(dc, opt)) { \\\n\n            qemu_log(\"Option is not enabled %s:%d\\n\", \\\n\n                    __FILE__, __LINE__); \\\n\n            goto invalid_opcode; \\\n\n        } \\\n\n    } while (0)\n\n\n\n#define HAS_OPTION(opt) HAS_OPTION_BITS(XTENSA_OPTION_BIT(opt))\n\n\n\n#define TBD() qemu_log(\"TBD(pc = %08x): %s:%d\\n\", dc->pc, __FILE__, __LINE__)\n\n#define RESERVED() do { \\\n\n        qemu_log(\"RESERVED(pc = %08x, %02x%02x%02x): %s:%d\\n\", \\\n\n                dc->pc, b0, b1, b2, __FILE__, __LINE__); \\\n\n        goto invalid_opcode; \\\n\n    } while (0)\n\n\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define OP0 (((b0) & 0xf0) >> 4)\n\n#define OP1 (((b2) & 0xf0) >> 4)\n\n#define OP2 ((b2) & 0xf)\n\n#define RRR_R ((b1) & 0xf)\n\n#define RRR_S (((b1) & 0xf0) >> 4)\n\n#define RRR_T ((b0) & 0xf)\n\n#else\n\n#define OP0 (((b0) & 0xf))\n\n#define OP1 (((b2) & 0xf))\n\n#define OP2 (((b2) & 0xf0) >> 4)\n\n#define RRR_R (((b1) & 0xf0) >> 4)\n\n#define RRR_S (((b1) & 0xf))\n\n#define RRR_T (((b0) & 0xf0) >> 4)\n\n#endif\n\n#define RRR_X ((RRR_R & 0x4) >> 2)\n\n#define RRR_Y ((RRR_T & 0x4) >> 2)\n\n#define RRR_W (RRR_R & 0x3)\n\n\n\n#define RRRN_R RRR_R\n\n#define RRRN_S RRR_S\n\n#define RRRN_T RRR_T\n\n\n\n#define RRI4_R RRR_R\n\n#define RRI4_S RRR_S\n\n#define RRI4_T RRR_T\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define RRI4_IMM4 ((b2) & 0xf)\n\n#else\n\n#define RRI4_IMM4 (((b2) & 0xf0) >> 4)\n\n#endif\n\n\n\n#define RRI8_R RRR_R\n\n#define RRI8_S RRR_S\n\n#define RRI8_T RRR_T\n\n#define RRI8_IMM8 (b2)\n\n#define RRI8_IMM8_SE ((((b2) & 0x80) ? 0xffffff00 : 0) | RRI8_IMM8)\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define RI16_IMM16 (((b1) << 8) | (b2))\n\n#else\n\n#define RI16_IMM16 (((b2) << 8) | (b1))\n\n#endif\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define CALL_N (((b0) & 0xc) >> 2)\n\n#define CALL_OFFSET ((((b0) & 0x3) << 16) | ((b1) << 8) | (b2))\n\n#else\n\n#define CALL_N (((b0) & 0x30) >> 4)\n\n#define CALL_OFFSET ((((b0) & 0xc0) >> 6) | ((b1) << 2) | ((b2) << 10))\n\n#endif\n\n#define CALL_OFFSET_SE \\\n\n    (((CALL_OFFSET & 0x20000) ? 0xfffc0000 : 0) | CALL_OFFSET)\n\n\n\n#define CALLX_N CALL_N\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define CALLX_M ((b0) & 0x3)\n\n#else\n\n#define CALLX_M (((b0) & 0xc0) >> 6)\n\n#endif\n\n#define CALLX_S RRR_S\n\n\n\n#define BRI12_M CALLX_M\n\n#define BRI12_S RRR_S\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define BRI12_IMM12 ((((b1) & 0xf) << 8) | (b2))\n\n#else\n\n#define BRI12_IMM12 ((((b1) & 0xf0) >> 4) | ((b2) << 4))\n\n#endif\n\n#define BRI12_IMM12_SE (((BRI12_IMM12 & 0x800) ? 0xfffff000 : 0) | BRI12_IMM12)\n\n\n\n#define BRI8_M BRI12_M\n\n#define BRI8_R RRI8_R\n\n#define BRI8_S RRI8_S\n\n#define BRI8_IMM8 RRI8_IMM8\n\n#define BRI8_IMM8_SE RRI8_IMM8_SE\n\n\n\n#define RSR_SR (b1)\n\n\n\n    uint8_t b0 = cpu_ldub_code(env, dc->pc);\n\n    uint8_t b1 = cpu_ldub_code(env, dc->pc + 1);\n\n    uint8_t b2 = 0;\n\n    unsigned len = xtensa_op0_insn_len(OP0);\n\n\n\n    static const uint32_t B4CONST[] = {\n\n        0xffffffff, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256\n\n    };\n\n\n\n    static const uint32_t B4CONSTU[] = {\n\n        32768, 65536, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256\n\n    };\n\n\n\n    switch (len) {\n\n    case 2:\n\n        HAS_OPTION(XTENSA_OPTION_CODE_DENSITY);\n\n        break;\n\n\n\n    case 3:\n\n        b2 = cpu_ldub_code(env, dc->pc + 2);\n\n        break;\n\n\n\n    default:\n\n        RESERVED();\n\n    }\n\n    dc->next_pc = dc->pc + len;\n\n\n\n    switch (OP0) {\n\n    case 0: /*QRST*/\n\n        switch (OP1) {\n\n        case 0: /*RST0*/\n\n            switch (OP2) {\n\n            case 0: /*ST0*/\n\n                if ((RRR_R & 0xc) == 0x8) {\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                }\n\n\n\n                switch (RRR_R) {\n\n                case 0: /*SNM0*/\n\n                    switch (CALLX_M) {\n\n                    case 0: /*ILL*/\n\n                        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        break;\n\n\n\n                    case 1: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n\n\n                    case 2: /*JR*/\n\n                        switch (CALLX_N) {\n\n                        case 0: /*RET*/\n\n                        case 2: /*JX*/\n\n                            if (gen_window_check1(dc, CALLX_S)) {\n\n                                gen_jump(dc, cpu_R[CALLX_S]);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*RETWw*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            {\n\n                                TCGv_i32 tmp = tcg_const_i32(dc->pc);\n\n                                gen_advance_ccount(dc);\n\n                                gen_helper_retw(tmp, cpu_env, tmp);\n\n                                gen_jump(dc, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        case 3: /*reserved*/\n\n                            RESERVED();\n\n                            break;\n\n                        }\n\n                        break;\n\n\n\n                    case 3: /*CALLX*/\n\n                        if (!gen_window_check2(dc, CALLX_S, CALLX_N << 2)) {\n\n                            break;\n\n                        }\n\n                        switch (CALLX_N) {\n\n                        case 0: /*CALLX0*/\n\n                            {\n\n                                TCGv_i32 tmp = tcg_temp_new_i32();\n\n                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);\n\n                                tcg_gen_movi_i32(cpu_R[0], dc->next_pc);\n\n                                gen_jump(dc, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*CALLX4w*/\n\n                        case 2: /*CALLX8w*/\n\n                        case 3: /*CALLX12w*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            {\n\n                                TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);\n\n                                gen_callw(dc, CALLX_N, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n                        }\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*MOVSPw*/\n\n                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                    if (gen_window_check2(dc, RRR_T, RRR_S)) {\n\n                        TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n                        gen_advance_ccount(dc);\n\n                        gen_helper_movsp(cpu_env, pc);\n\n                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                        tcg_temp_free(pc);\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*SYNC*/\n\n                    switch (RRR_T) {\n\n                    case 0: /*ISYNC*/\n\n                        break;\n\n\n\n                    case 1: /*RSYNC*/\n\n                        break;\n\n\n\n                    case 2: /*ESYNC*/\n\n                        break;\n\n\n\n                    case 3: /*DSYNC*/\n\n                        break;\n\n\n\n                    case 8: /*EXCW*/\n\n                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                        break;\n\n\n\n                    case 12: /*MEMW*/\n\n                        break;\n\n\n\n                    case 13: /*EXTW*/\n\n                        break;\n\n\n\n                    case 15: /*NOP*/\n\n                        break;\n\n\n\n                    default: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*RFEIx*/\n\n                    switch (RRR_T) {\n\n                    case 0: /*RFETx*/\n\n                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                        switch (RRR_S) {\n\n                        case 0: /*RFEx*/\n\n                            if (gen_check_privilege(dc)) {\n\n                                tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1]);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*RFUEx*/\n\n                            RESERVED();\n\n                            break;\n\n\n\n                        case 2: /*RFDEx*/\n\n                            if (gen_check_privilege(dc)) {\n\n                                gen_jump(dc, cpu_SR[\n\n                                         dc->config->ndepc ? DEPC : EPC1]);\n\n                            }\n\n                            break;\n\n\n\n                        case 4: /*RFWOw*/\n\n                        case 5: /*RFWUw*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            if (gen_check_privilege(dc)) {\n\n                                TCGv_i32 tmp = tcg_const_i32(1);\n\n\n\n                                tcg_gen_andi_i32(\n\n                                        cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);\n\n                                tcg_gen_shl_i32(tmp, tmp, cpu_SR[WINDOW_BASE]);\n\n\n\n                                if (RRR_S == 4) {\n\n                                    tcg_gen_andc_i32(cpu_SR[WINDOW_START],\n\n                                            cpu_SR[WINDOW_START], tmp);\n\n                                } else {\n\n                                    tcg_gen_or_i32(cpu_SR[WINDOW_START],\n\n                                            cpu_SR[WINDOW_START], tmp);\n\n                                }\n\n\n\n                                gen_helper_restore_owb(cpu_env);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1]);\n\n\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        default: /*reserved*/\n\n                            RESERVED();\n\n                            break;\n\n                        }\n\n                        break;\n\n\n\n                    case 1: /*RFIx*/\n\n                        HAS_OPTION(XTENSA_OPTION_HIGH_PRIORITY_INTERRUPT);\n\n                        if (RRR_S >= 2 && RRR_S <= dc->config->nlevel) {\n\n                            if (gen_check_privilege(dc)) {\n\n                                tcg_gen_mov_i32(cpu_SR[PS],\n\n                                                cpu_SR[EPS2 + RRR_S - 2]);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1 + RRR_S - 1]);\n\n                            }\n\n                        } else {\n\n                            qemu_log(\"RFI %d is illegal\\n\", RRR_S);\n\n                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        }\n\n                        break;\n\n\n\n                    case 2: /*RFME*/\n\n                        TBD();\n\n                        break;\n\n\n\n                    default: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*BREAKx*/\n\n                    HAS_OPTION(XTENSA_OPTION_DEBUG);\n\n                    if (dc->debug) {\n\n                        gen_debug_exception(dc, DEBUGCAUSE_BI);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*SYSCALLx*/\n\n                    HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                    switch (RRR_S) {\n\n                    case 0: /*SYSCALLx*/\n\n                        gen_exception_cause(dc, SYSCALL_CAUSE);\n\n                        break;\n\n\n\n                    case 1: /*SIMCALL*/\n\n                        if (semihosting_enabled) {\n\n                            if (gen_check_privilege(dc)) {\n\n                                gen_helper_simcall(cpu_env);\n\n                            }\n\n                        } else {\n\n                            qemu_log(\"SIMCALL but semihosting is disabled\\n\");\n\n                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        }\n\n                        break;\n\n\n\n                    default:\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*RSILx*/\n\n                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);\n\n                    if (gen_check_privilege(dc) &&\n\n                        gen_window_check1(dc, RRR_T)) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_SR[PS]);\n\n                        tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_INTLEVEL);\n\n                        tcg_gen_ori_i32(cpu_SR[PS], cpu_SR[PS], RRR_S);\n\n                        gen_helper_check_interrupts(cpu_env);\n\n                        gen_jumpi_check_loop_end(dc, 0);\n\n                    }\n\n                    break;\n\n\n\n                case 7: /*WAITIx*/\n\n                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_waiti(dc, RRR_S);\n\n                    }\n\n                    break;\n\n\n\n                case 8: /*ANY4p*/\n\n                case 9: /*ALL4p*/\n\n                case 10: /*ANY8p*/\n\n                case 11: /*ALL8p*/\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                    {\n\n                        const unsigned shift = (RRR_R & 2) ? 8 : 4;\n\n                        TCGv_i32 mask = tcg_const_i32(\n\n                                ((1 << shift) - 1) << RRR_S);\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_and_i32(tmp, cpu_SR[BR], mask);\n\n                        if (RRR_R & 1) { /*ALL*/\n\n                            tcg_gen_addi_i32(tmp, tmp, 1 << RRR_S);\n\n                        } else { /*ANY*/\n\n                            tcg_gen_add_i32(tmp, tmp, mask);\n\n                        }\n\n                        tcg_gen_shri_i32(tmp, tmp, RRR_S + shift);\n\n                        tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR],\n\n                                tmp, RRR_T, 1);\n\n                        tcg_temp_free(mask);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n            case 1: /*AND*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_and_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*OR*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_or_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 3: /*XOR*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_xor_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 4: /*ST1*/\n\n                switch (RRR_R) {\n\n                case 0: /*SSR*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        gen_right_shift_sar(dc, cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*SSL*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        gen_left_shift_sar(dc, cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*SSA8L*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);\n\n                        gen_right_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*SSA8B*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);\n\n                        gen_left_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*SSAI*/\n\n                    {\n\n                        TCGv_i32 tmp = tcg_const_i32(\n\n                                RRR_S | ((RRR_T & 1) << 4));\n\n                        gen_right_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*RER*/\n\n                    TBD();\n\n                    break;\n\n\n\n                case 7: /*WER*/\n\n                    TBD();\n\n                    break;\n\n\n\n                case 8: /*ROTWw*/\n\n                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                    if (gen_check_privilege(dc)) {\n\n                        TCGv_i32 tmp = tcg_const_i32(\n\n                                RRR_T | ((RRR_T & 8) ? 0xfffffff0 : 0));\n\n                        gen_helper_rotw(cpu_env, tmp);\n\n                        tcg_temp_free(tmp);\n\n                        /* This can change tb->flags, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                    }\n\n                    break;\n\n\n\n                case 14: /*NSAu*/\n\n                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);\n\n                    if (gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                        gen_helper_nsa(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 15: /*NSAUu*/\n\n                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);\n\n                    if (gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                        gen_helper_nsau(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 5: /*TLB*/\n\n                HAS_OPTION_BITS(\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_MMU) |\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_PROTECTION) |\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_TRANSLATION));\n\n                if (gen_check_privilege(dc) &&\n\n                    gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                    TCGv_i32 dtlb = tcg_const_i32((RRR_R & 8) != 0);\n\n\n\n                    switch (RRR_R & 7) {\n\n                    case 3: /*RITLB0*/ /*RDTLB0*/\n\n                        gen_helper_rtlb0(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    case 4: /*IITLB*/ /*IDTLB*/\n\n                        gen_helper_itlb(cpu_env, cpu_R[RRR_S], dtlb);\n\n                        /* This could change memory mapping, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                        break;\n\n\n\n                    case 5: /*PITLB*/ /*PDTLB*/\n\n                        tcg_gen_movi_i32(cpu_pc, dc->pc);\n\n                        gen_helper_ptlb(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    case 6: /*WITLB*/ /*WDTLB*/\n\n                        gen_helper_wtlb(\n\n                                cpu_env, cpu_R[RRR_T], cpu_R[RRR_S], dtlb);\n\n                        /* This could change memory mapping, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                        break;\n\n\n\n                    case 7: /*RITLB1*/ /*RDTLB1*/\n\n                        gen_helper_rtlb1(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    default:\n\n                        tcg_temp_free(dtlb);\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    tcg_temp_free(dtlb);\n\n                }\n\n                break;\n\n\n\n            case 6: /*RT0*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                switch (RRR_S) {\n\n                case 0: /*NEG*/\n\n                    tcg_gen_neg_i32(cpu_R[RRR_R], cpu_R[RRR_T]);\n\n                    break;\n\n\n\n                case 1: /*ABS*/\n\n                    {\n\n                        TCGv_i32 zero = tcg_const_i32(0);\n\n                        TCGv_i32 neg = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_neg_i32(neg, cpu_R[RRR_T]);\n\n                        tcg_gen_movcond_i32(TCG_COND_GE, cpu_R[RRR_R],\n\n                                cpu_R[RRR_T], zero, cpu_R[RRR_T], neg);\n\n                        tcg_temp_free(neg);\n\n                        tcg_temp_free(zero);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 7: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n\n\n            case 8: /*ADD*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_add_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 9: /*ADD**/\n\n            case 10:\n\n            case 11:\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 8);\n\n                    tcg_gen_add_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 12: /*SUB*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_sub_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 13: /*SUB**/\n\n            case 14:\n\n            case 15:\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 12);\n\n                    tcg_gen_sub_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 1: /*RST1*/\n\n            switch (OP2) {\n\n            case 0: /*SLLI*/\n\n            case 1:\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    tcg_gen_shli_i32(cpu_R[RRR_R], cpu_R[RRR_S],\n\n                                     32 - (RRR_T | ((OP2 & 1) << 4)));\n\n                }\n\n                break;\n\n\n\n            case 2: /*SRAI*/\n\n            case 3:\n\n                if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    tcg_gen_sari_i32(cpu_R[RRR_R], cpu_R[RRR_T],\n\n                                     RRR_S | ((OP2 & 1) << 4));\n\n                }\n\n                break;\n\n\n\n            case 4: /*SRLI*/\n\n                if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    tcg_gen_shri_i32(cpu_R[RRR_R], cpu_R[RRR_T], RRR_S);\n\n                }\n\n                break;\n\n\n\n            case 6: /*XSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_X) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_mov_i32(tmp, cpu_R[RRR_T]);\n\n                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);\n\n                    gen_wsr(dc, RSR_SR, tmp);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n                /*\n\n                 * Note: 64 bit ops are used here solely because SAR values\n\n                 * have range 0..63\n\n                 */\n\n#define gen_shift_reg(cmd, reg) do { \\\n\n                    TCGv_i64 tmp = tcg_temp_new_i64(); \\\n\n                    tcg_gen_extu_i32_i64(tmp, reg); \\\n\n                    tcg_gen_##cmd##_i64(v, v, tmp); \\\n\n                    tcg_gen_trunc_i64_i32(cpu_R[RRR_R], v); \\\n\n                    tcg_temp_free_i64(v); \\\n\n                    tcg_temp_free_i64(tmp); \\\n\n                } while (0)\n\n\n\n#define gen_shift(cmd) gen_shift_reg(cmd, cpu_SR[SAR])\n\n\n\n            case 8: /*SRC*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_concat_i32_i64(v, cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    gen_shift(shr);\n\n                }\n\n                break;\n\n\n\n            case 9: /*SRL*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_5bit) {\n\n                    tcg_gen_shr_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_T]);\n\n                    gen_shift(shr);\n\n                }\n\n                break;\n\n\n\n            case 10: /*SLL*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_m32_5bit) {\n\n                    tcg_gen_shl_i32(cpu_R[RRR_R], cpu_R[RRR_S], dc->sar_m32);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    TCGv_i32 s = tcg_const_i32(32);\n\n                    tcg_gen_sub_i32(s, s, cpu_SR[SAR]);\n\n                    tcg_gen_andi_i32(s, s, 0x3f);\n\n                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_S]);\n\n                    gen_shift_reg(shl, s);\n\n                    tcg_temp_free(s);\n\n                }\n\n                break;\n\n\n\n            case 11: /*SRA*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_5bit) {\n\n                    tcg_gen_sar_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_ext_i32_i64(v, cpu_R[RRR_T]);\n\n                    gen_shift(sar);\n\n                }\n\n                break;\n\n#undef gen_shift\n\n#undef gen_shift_reg\n\n\n\n            case 12: /*MUL16U*/\n\n                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 v1 = tcg_temp_new_i32();\n\n                    TCGv_i32 v2 = tcg_temp_new_i32();\n\n                    tcg_gen_ext16u_i32(v1, cpu_R[RRR_S]);\n\n                    tcg_gen_ext16u_i32(v2, cpu_R[RRR_T]);\n\n                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);\n\n                    tcg_temp_free(v2);\n\n                    tcg_temp_free(v1);\n\n                }\n\n                break;\n\n\n\n            case 13: /*MUL16S*/\n\n                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 v1 = tcg_temp_new_i32();\n\n                    TCGv_i32 v2 = tcg_temp_new_i32();\n\n                    tcg_gen_ext16s_i32(v1, cpu_R[RRR_S]);\n\n                    tcg_gen_ext16s_i32(v2, cpu_R[RRR_T]);\n\n                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);\n\n                    tcg_temp_free(v2);\n\n                    tcg_temp_free(v1);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 2: /*RST2*/\n\n            if (OP2 >= 8 && !gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                break;\n\n            }\n\n\n\n            if (OP2 >= 12) {\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IDIV);\n\n                int label = gen_new_label();\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0, label);\n\n                gen_exception_cause(dc, INTEGER_DIVIDE_BY_ZERO_CAUSE);\n\n                gen_set_label(label);\n\n            }\n\n\n\n            switch (OP2) {\n\n#define BOOLEAN_LOGIC(fn, r, s, t) \\\n\n                do { \\\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN); \\\n\n                    TCGv_i32 tmp1 = tcg_temp_new_i32(); \\\n\n                    TCGv_i32 tmp2 = tcg_temp_new_i32(); \\\n\n                    \\\n\n                    tcg_gen_shri_i32(tmp1, cpu_SR[BR], s); \\\n\n                    tcg_gen_shri_i32(tmp2, cpu_SR[BR], t); \\\n\n                    tcg_gen_##fn##_i32(tmp1, tmp1, tmp2); \\\n\n                    tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR], tmp1, r, 1); \\\n\n                    tcg_temp_free(tmp1); \\\n\n                    tcg_temp_free(tmp2); \\\n\n                } while (0)\n\n\n\n            case 0: /*ANDBp*/\n\n                BOOLEAN_LOGIC(and, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 1: /*ANDBCp*/\n\n                BOOLEAN_LOGIC(andc, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 2: /*ORBp*/\n\n                BOOLEAN_LOGIC(or, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 3: /*ORBCp*/\n\n                BOOLEAN_LOGIC(orc, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 4: /*XORBp*/\n\n                BOOLEAN_LOGIC(xor, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n#undef BOOLEAN_LOGIC\n\n\n\n            case 8: /*MULLi*/\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL);\n\n                tcg_gen_mul_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 10: /*MULUHi*/\n\n            case 11: /*MULSHi*/\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL_HIGH);\n\n                {\n\n                    TCGv lo = tcg_temp_new();\n\n\n\n                    if (OP2 == 10) {\n\n                        tcg_gen_mulu2_i32(lo, cpu_R[RRR_R],\n\n                                          cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    } else {\n\n                        tcg_gen_muls2_i32(lo, cpu_R[RRR_R],\n\n                                          cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    }\n\n                    tcg_temp_free(lo);\n\n                }\n\n                break;\n\n\n\n            case 12: /*QUOUi*/\n\n                tcg_gen_divu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 13: /*QUOSi*/\n\n            case 15: /*REMSi*/\n\n                {\n\n                    int label1 = gen_new_label();\n\n                    int label2 = gen_new_label();\n\n\n\n                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_S], 0x80000000,\n\n                            label1);\n\n                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0xffffffff,\n\n                            label1);\n\n                    tcg_gen_movi_i32(cpu_R[RRR_R],\n\n                            OP2 == 13 ? 0x80000000 : 0);\n\n                    tcg_gen_br(label2);\n\n                    gen_set_label(label1);\n\n                    if (OP2 == 13) {\n\n                        tcg_gen_div_i32(cpu_R[RRR_R],\n\n                                cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    } else {\n\n                        tcg_gen_rem_i32(cpu_R[RRR_R],\n\n                                cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    }\n\n                    gen_set_label(label2);\n\n                }\n\n                break;\n\n\n\n            case 14: /*REMUi*/\n\n                tcg_gen_remu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 3: /*RST3*/\n\n            switch (OP2) {\n\n            case 0: /*RSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_R) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);\n\n                }\n\n                break;\n\n\n\n            case 1: /*WSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_W) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    gen_wsr(dc, RSR_SR, cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*SEXTu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_SEXT);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    int shift = 24 - RRR_T;\n\n\n\n                    if (shift == 24) {\n\n                        tcg_gen_ext8s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    } else if (shift == 16) {\n\n                        tcg_gen_ext16s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    } else {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], shift);\n\n                        tcg_gen_sari_i32(cpu_R[RRR_R], tmp, shift);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                }\n\n                break;\n\n\n\n            case 3: /*CLAMPSu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_CLAMPS);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    TCGv_i32 tmp1 = tcg_temp_new_i32();\n\n                    TCGv_i32 tmp2 = tcg_temp_new_i32();\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 24 - RRR_T);\n\n                    tcg_gen_xor_i32(tmp2, tmp1, cpu_R[RRR_S]);\n\n                    tcg_gen_andi_i32(tmp2, tmp2, 0xffffffff << (RRR_T + 7));\n\n\n\n                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 31);\n\n                    tcg_gen_xori_i32(tmp1, tmp1, 0xffffffff >> (25 - RRR_T));\n\n\n\n                    tcg_gen_movcond_i32(TCG_COND_EQ, cpu_R[RRR_R], tmp2, zero,\n\n                            cpu_R[RRR_S], tmp1);\n\n                    tcg_temp_free(tmp1);\n\n                    tcg_temp_free(tmp2);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 4: /*MINu*/\n\n            case 5: /*MAXu*/\n\n            case 6: /*MINUu*/\n\n            case 7: /*MAXUu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_MINMAX);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_LE,\n\n                        TCG_COND_GE,\n\n                        TCG_COND_LEU,\n\n                        TCG_COND_GEU\n\n                    };\n\n                    tcg_gen_movcond_i32(cond[OP2 - 4], cpu_R[RRR_R],\n\n                            cpu_R[RRR_S], cpu_R[RRR_T],\n\n                            cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 8: /*MOVEQZ*/\n\n            case 9: /*MOVNEZ*/\n\n            case 10: /*MOVLTZ*/\n\n            case 11: /*MOVGEZ*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_EQ,\n\n                        TCG_COND_NE,\n\n                        TCG_COND_LT,\n\n                        TCG_COND_GE,\n\n                    };\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_R[RRR_R],\n\n                            cpu_R[RRR_T], zero, cpu_R[RRR_S], cpu_R[RRR_R]);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 12: /*MOVFp*/\n\n            case 13: /*MOVTp*/\n\n                HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);\n\n                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                            cpu_R[RRR_R], tmp, zero,\n\n                            cpu_R[RRR_S], cpu_R[RRR_R]);\n\n\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 14: /*RUR*/\n\n                if (gen_window_check1(dc, RRR_R)) {\n\n                    int st = (RRR_S << 4) + RRR_T;\n\n                    if (uregnames[st].name) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_UR[st]);\n\n                    } else {\n\n                        qemu_log(\"RUR %d not implemented, \", st);\n\n                        TBD();\n\n                    }\n\n                }\n\n                break;\n\n\n\n            case 15: /*WUR*/\n\n                if (gen_window_check1(dc, RRR_T)) {\n\n                    if (uregnames[RSR_SR].name) {\n\n                        gen_wur(RSR_SR, cpu_R[RRR_T]);\n\n                    } else {\n\n                        qemu_log(\"WUR %d not implemented, \", RSR_SR);\n\n                        TBD();\n\n                    }\n\n                }\n\n                break;\n\n\n\n            }\n\n            break;\n\n\n\n        case 4: /*EXTUI*/\n\n        case 5:\n\n            if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                int shiftimm = RRR_S | ((OP1 & 1) << 4);\n\n                int maskimm = (1 << (OP2 + 1)) - 1;\n\n\n\n                TCGv_i32 tmp = tcg_temp_new_i32();\n\n                tcg_gen_shri_i32(tmp, cpu_R[RRR_T], shiftimm);\n\n                tcg_gen_andi_i32(cpu_R[RRR_R], tmp, maskimm);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n\n\n        case 6: /*CUST0*/\n\n            RESERVED();\n\n            break;\n\n\n\n        case 7: /*CUST1*/\n\n            RESERVED();\n\n            break;\n\n\n\n        case 8: /*LSCXp*/\n\n            switch (OP2) {\n\n            case 0: /*LSXf*/\n\n            case 1: /*LSXUf*/\n\n            case 4: /*SSXf*/\n\n            case 5: /*SSXUf*/\n\n                HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n                if (gen_window_check2(dc, RRR_S, RRR_T) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_add_i32(addr, cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    gen_load_store_alignment(dc, 2, addr, false);\n\n                    if (OP2 & 0x4) {\n\n                        tcg_gen_qemu_st32(cpu_FR[RRR_R], addr, dc->cring);\n\n                    } else {\n\n                        tcg_gen_qemu_ld32u(cpu_FR[RRR_R], addr, dc->cring);\n\n                    }\n\n                    if (OP2 & 0x1) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_S], addr);\n\n                    }\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 9: /*LSC4*/\n\n            if (!gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                break;\n\n            }\n\n            switch (OP2) {\n\n            case 0: /*L32E*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                if (gen_check_privilege(dc)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],\n\n                            (0xffffffc0 | (RRR_R << 2)));\n\n                    tcg_gen_qemu_ld32u(cpu_R[RRR_T], addr, dc->ring);\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            case 4: /*S32E*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                if (gen_check_privilege(dc)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],\n\n                            (0xffffffc0 | (RRR_R << 2)));\n\n                    tcg_gen_qemu_st32(cpu_R[RRR_T], addr, dc->ring);\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            default:\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 10: /*FP0*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n            switch (OP2) {\n\n            case 0: /*ADD.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_add_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 1: /*SUB.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_sub_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*MUL.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_mul_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 4: /*MADD.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_madd_s(cpu_FR[RRR_R], cpu_env,\n\n                                      cpu_FR[RRR_R], cpu_FR[RRR_S],\n\n                                      cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 5: /*MSUB.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_msub_s(cpu_FR[RRR_R], cpu_env,\n\n                                      cpu_FR[RRR_R], cpu_FR[RRR_S],\n\n                                      cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 8: /*ROUND.Sf*/\n\n            case 9: /*TRUNC.Sf*/\n\n            case 10: /*FLOOR.Sf*/\n\n            case 11: /*CEIL.Sf*/\n\n            case 14: /*UTRUNC.Sf*/\n\n                if (gen_window_check1(dc, RRR_R) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    static const unsigned rounding_mode_const[] = {\n\n                        float_round_nearest_even,\n\n                        float_round_to_zero,\n\n                        float_round_down,\n\n                        float_round_up,\n\n                        [6] = float_round_to_zero,\n\n                    };\n\n                    TCGv_i32 rounding_mode = tcg_const_i32(\n\n                            rounding_mode_const[OP2 & 7]);\n\n                    TCGv_i32 scale = tcg_const_i32(RRR_T);\n\n\n\n                    if (OP2 == 14) {\n\n                        gen_helper_ftoui(cpu_R[RRR_R], cpu_FR[RRR_S],\n\n                                rounding_mode, scale);\n\n                    } else {\n\n                        gen_helper_ftoi(cpu_R[RRR_R], cpu_FR[RRR_S],\n\n                                rounding_mode, scale);\n\n                    }\n\n\n\n                    tcg_temp_free(rounding_mode);\n\n                    tcg_temp_free(scale);\n\n                }\n\n                break;\n\n\n\n            case 12: /*FLOAT.Sf*/\n\n            case 13: /*UFLOAT.Sf*/\n\n                if (gen_window_check1(dc, RRR_S) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 scale = tcg_const_i32(-RRR_T);\n\n\n\n                    if (OP2 == 13) {\n\n                        gen_helper_uitof(cpu_FR[RRR_R], cpu_env,\n\n                                cpu_R[RRR_S], scale);\n\n                    } else {\n\n                        gen_helper_itof(cpu_FR[RRR_R], cpu_env,\n\n                                cpu_R[RRR_S], scale);\n\n                    }\n\n                    tcg_temp_free(scale);\n\n                }\n\n                break;\n\n\n\n            case 15: /*FP1OP*/\n\n                switch (RRR_T) {\n\n                case 0: /*MOV.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*ABS.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        gen_helper_abs_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*RFRf*/\n\n                    if (gen_window_check1(dc, RRR_R) &&\n\n                        gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*WFRf*/\n\n                    if (gen_window_check1(dc, RRR_S) &&\n\n                        gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*NEG.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        gen_helper_neg_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 11: /*FP1*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n\n\n#define gen_compare(rel, br, a, b) \\\n\n    do { \\\n\n        if (gen_check_cpenable(dc, 0)) { \\\n\n            TCGv_i32 bit = tcg_const_i32(1 << br); \\\n\n            \\\n\n            gen_helper_##rel(cpu_env, bit, cpu_FR[a], cpu_FR[b]); \\\n\n            tcg_temp_free(bit); \\\n\n        } \\\n\n    } while (0)\n\n\n\n            switch (OP2) {\n\n            case 1: /*UN.Sf*/\n\n                gen_compare(un_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 2: /*OEQ.Sf*/\n\n                gen_compare(oeq_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 3: /*UEQ.Sf*/\n\n                gen_compare(ueq_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 4: /*OLT.Sf*/\n\n                gen_compare(olt_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 5: /*ULT.Sf*/\n\n                gen_compare(ult_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 6: /*OLE.Sf*/\n\n                gen_compare(ole_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 7: /*ULE.Sf*/\n\n                gen_compare(ule_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n#undef gen_compare\n\n\n\n            case 8: /*MOVEQZ.Sf*/\n\n            case 9: /*MOVNEZ.Sf*/\n\n            case 10: /*MOVLTZ.Sf*/\n\n            case 11: /*MOVGEZ.Sf*/\n\n                if (gen_window_check1(dc, RRR_T) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_EQ,\n\n                        TCG_COND_NE,\n\n                        TCG_COND_LT,\n\n                        TCG_COND_GE,\n\n                    };\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_FR[RRR_R],\n\n                            cpu_R[RRR_T], zero, cpu_FR[RRR_S], cpu_FR[RRR_R]);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 12: /*MOVF.Sf*/\n\n            case 13: /*MOVT.Sf*/\n\n                HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);\n\n                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                            cpu_FR[RRR_R], tmp, zero,\n\n                            cpu_FR[RRR_S], cpu_FR[RRR_R]);\n\n\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 1: /*L32R*/\n\n        if (gen_window_check1(dc, RRR_T)) {\n\n            TCGv_i32 tmp = tcg_const_i32(\n\n                    ((dc->tb->flags & XTENSA_TBFLAG_LITBASE) ?\n\n                     0 : ((dc->pc + 3) & ~3)) +\n\n                    (0xfffc0000 | (RI16_IMM16 << 2)));\n\n\n\n            if (dc->tb->flags & XTENSA_TBFLAG_LITBASE) {\n\n                tcg_gen_add_i32(tmp, tmp, dc->litbase);\n\n            }\n\n            tcg_gen_qemu_ld32u(cpu_R[RRR_T], tmp, dc->cring);\n\n            tcg_temp_free(tmp);\n\n        }\n\n        break;\n\n\n\n    case 2: /*LSAI*/\n\n#define gen_load_store(type, shift) do { \\\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << shift); \\\n\n                if (shift) { \\\n\n                    gen_load_store_alignment(dc, shift, addr, false); \\\n\n                } \\\n\n                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n        switch (RRI8_R) {\n\n        case 0: /*L8UI*/\n\n            gen_load_store(ld8u, 0);\n\n            break;\n\n\n\n        case 1: /*L16UI*/\n\n            gen_load_store(ld16u, 1);\n\n            break;\n\n\n\n        case 2: /*L32I*/\n\n            gen_load_store(ld32u, 2);\n\n            break;\n\n\n\n        case 4: /*S8I*/\n\n            gen_load_store(st8, 0);\n\n            break;\n\n\n\n        case 5: /*S16I*/\n\n            gen_load_store(st16, 1);\n\n            break;\n\n\n\n        case 6: /*S32I*/\n\n            gen_load_store(st32, 2);\n\n            break;\n\n\n\n#define gen_dcache_hit_test(w, shift) do { \\\n\n            if (gen_window_check1(dc, RRI##w##_S)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                TCGv_i32 res = tcg_temp_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \\\n\n                                 RRI##w##_IMM##w << shift); \\\n\n                tcg_gen_qemu_ld8u(res, addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n                tcg_temp_free(res); \\\n\n            } \\\n\n        } while (0)\n\n\n\n#define gen_dcache_hit_test4() gen_dcache_hit_test(4, 4)\n\n#define gen_dcache_hit_test8() gen_dcache_hit_test(8, 2)\n\n\n\n        case 7: /*CACHEc*/\n\n            if (RRI8_T < 8) {\n\n                HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n            }\n\n\n\n            switch (RRI8_T) {\n\n            case 0: /*DPFRc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 1: /*DPFWc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 2: /*DPFROc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 3: /*DPFWOc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 4: /*DHWBc*/\n\n                gen_dcache_hit_test8();\n\n                break;\n\n\n\n            case 5: /*DHWBIc*/\n\n                gen_dcache_hit_test8();\n\n                break;\n\n\n\n            case 6: /*DHIc*/\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_dcache_hit_test8();\n\n                }\n\n                break;\n\n\n\n            case 7: /*DIIc*/\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_window_check1(dc, RRI8_S);\n\n                }\n\n                break;\n\n\n\n            case 8: /*DCEc*/\n\n                switch (OP1) {\n\n                case 0: /*DPFLl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_dcache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*DHUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_dcache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*DIUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*DIWBc*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*DIWBIc*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n#undef gen_dcache_hit_test\n\n#undef gen_dcache_hit_test4\n\n#undef gen_dcache_hit_test8\n\n\n\n#define gen_icache_hit_test(w, shift) do { \\\n\n            if (gen_window_check1(dc, RRI##w##_S)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                tcg_gen_movi_i32(cpu_pc, dc->pc); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \\\n\n                                 RRI##w##_IMM##w << shift); \\\n\n                gen_helper_itlb_hit_test(cpu_env, addr); \\\n\n                tcg_temp_free(addr); \\\n\n            }\\\n\n        } while (0)\n\n\n\n#define gen_icache_hit_test4() gen_icache_hit_test(4, 4)\n\n#define gen_icache_hit_test8() gen_icache_hit_test(8, 2)\n\n\n\n            case 12: /*IPFc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 13: /*ICEc*/\n\n                switch (OP1) {\n\n                case 0: /*IPFLl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_icache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*IHUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_icache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*IIUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 14: /*IHIc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                gen_icache_hit_test8();\n\n                break;\n\n\n\n            case 15: /*IIIc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_window_check1(dc, RRI8_S);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n#undef gen_icache_hit_test\n\n#undef gen_icache_hit_test4\n\n#undef gen_icache_hit_test8\n\n\n\n        case 9: /*L16SI*/\n\n            gen_load_store(ld16s, 1);\n\n            break;\n\n#undef gen_load_store\n\n\n\n        case 10: /*MOVI*/\n\n            if (gen_window_check1(dc, RRI8_T)) {\n\n                tcg_gen_movi_i32(cpu_R[RRI8_T],\n\n                                 RRI8_IMM8 | (RRI8_S << 8) |\n\n                                 ((RRI8_S & 0x8) ? 0xfffff000 : 0));\n\n            }\n\n            break;\n\n\n\n#define gen_load_store_no_hw_align(type) do { \\\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_local_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2); \\\n\n                gen_load_store_alignment(dc, 2, addr, true); \\\n\n                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n        case 11: /*L32AIy*/\n\n            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);\n\n            gen_load_store_no_hw_align(ld32u); /*TODO acquire?*/\n\n            break;\n\n\n\n        case 12: /*ADDI*/\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S], RRI8_IMM8_SE);\n\n            }\n\n            break;\n\n\n\n        case 13: /*ADDMI*/\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S],\n\n                                 RRI8_IMM8_SE << 8);\n\n            }\n\n            break;\n\n\n\n        case 14: /*S32C1Iy*/\n\n            HAS_OPTION(XTENSA_OPTION_CONDITIONAL_STORE);\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                int label = gen_new_label();\n\n                TCGv_i32 tmp = tcg_temp_local_new_i32();\n\n                TCGv_i32 addr = tcg_temp_local_new_i32();\n\n                TCGv_i32 tpc;\n\n\n\n                tcg_gen_mov_i32(tmp, cpu_R[RRI8_T]);\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);\n\n                gen_load_store_alignment(dc, 2, addr, true);\n\n\n\n                gen_advance_ccount(dc);\n\n                tpc = tcg_const_i32(dc->pc);\n\n                gen_helper_check_atomctl(cpu_env, tpc, addr);\n\n                tcg_gen_qemu_ld32u(cpu_R[RRI8_T], addr, dc->cring);\n\n                tcg_gen_brcond_i32(TCG_COND_NE, cpu_R[RRI8_T],\n\n                        cpu_SR[SCOMPARE1], label);\n\n\n\n                tcg_gen_qemu_st32(tmp, addr, dc->cring);\n\n\n\n                gen_set_label(label);\n\n                tcg_temp_free(tpc);\n\n                tcg_temp_free(addr);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n\n\n        case 15: /*S32RIy*/\n\n            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);\n\n            gen_load_store_no_hw_align(st32); /*TODO release?*/\n\n            break;\n\n#undef gen_load_store_no_hw_align\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 3: /*LSCIp*/\n\n        switch (RRI8_R) {\n\n        case 0: /*LSIf*/\n\n        case 4: /*SSIf*/\n\n        case 8: /*LSIUf*/\n\n        case 12: /*SSIUf*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n            if (gen_window_check1(dc, RRI8_S) &&\n\n                gen_check_cpenable(dc, 0)) {\n\n                TCGv_i32 addr = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);\n\n                gen_load_store_alignment(dc, 2, addr, false);\n\n                if (RRI8_R & 0x4) {\n\n                    tcg_gen_qemu_st32(cpu_FR[RRI8_T], addr, dc->cring);\n\n                } else {\n\n                    tcg_gen_qemu_ld32u(cpu_FR[RRI8_T], addr, dc->cring);\n\n                }\n\n                if (RRI8_R & 0x8) {\n\n                    tcg_gen_mov_i32(cpu_R[RRI8_S], addr);\n\n                }\n\n                tcg_temp_free(addr);\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 4: /*MAC16d*/\n\n        HAS_OPTION(XTENSA_OPTION_MAC16);\n\n        {\n\n            enum {\n\n                MAC16_UMUL = 0x0,\n\n                MAC16_MUL  = 0x4,\n\n                MAC16_MULA = 0x8,\n\n                MAC16_MULS = 0xc,\n\n                MAC16_NONE = 0xf,\n\n            } op = OP1 & 0xc;\n\n            bool is_m1_sr = (OP2 & 0x3) == 2;\n\n            bool is_m2_sr = (OP2 & 0xc) == 0;\n\n            uint32_t ld_offset = 0;\n\n\n\n            if (OP2 > 9) {\n\n                RESERVED();\n\n            }\n\n\n\n            switch (OP2 & 2) {\n\n            case 0: /*MACI?/MACC?*/\n\n                is_m1_sr = true;\n\n                ld_offset = (OP2 & 1) ? -4 : 4;\n\n\n\n                if (OP2 >= 8) { /*MACI/MACC*/\n\n                    if (OP1 == 0) { /*LDINC/LDDEC*/\n\n                        op = MAC16_NONE;\n\n                    } else {\n\n                        RESERVED();\n\n                    }\n\n                } else if (op != MAC16_MULA) { /*MULA.*.*.LDINC/LDDEC*/\n\n                    RESERVED();\n\n                }\n\n                break;\n\n\n\n            case 2: /*MACD?/MACA?*/\n\n                if (op == MAC16_UMUL && OP2 != 7) { /*UMUL only in MACAA*/\n\n                    RESERVED();\n\n                }\n\n                break;\n\n            }\n\n\n\n            if (op != MAC16_NONE) {\n\n                if (!is_m1_sr && !gen_window_check1(dc, RRR_S)) {\n\n                    break;\n\n                }\n\n                if (!is_m2_sr && !gen_window_check1(dc, RRR_T)) {\n\n                    break;\n\n                }\n\n            }\n\n\n\n            if (ld_offset && !gen_window_check1(dc, RRR_S)) {\n\n                break;\n\n            }\n\n\n\n            {\n\n                TCGv_i32 vaddr = tcg_temp_new_i32();\n\n                TCGv_i32 mem32 = tcg_temp_new_i32();\n\n\n\n                if (ld_offset) {\n\n                    tcg_gen_addi_i32(vaddr, cpu_R[RRR_S], ld_offset);\n\n                    gen_load_store_alignment(dc, 2, vaddr, false);\n\n                    tcg_gen_qemu_ld32u(mem32, vaddr, dc->cring);\n\n                }\n\n                if (op != MAC16_NONE) {\n\n                    TCGv_i32 m1 = gen_mac16_m(\n\n                            is_m1_sr ? cpu_SR[MR + RRR_X] : cpu_R[RRR_S],\n\n                            OP1 & 1, op == MAC16_UMUL);\n\n                    TCGv_i32 m2 = gen_mac16_m(\n\n                            is_m2_sr ? cpu_SR[MR + 2 + RRR_Y] : cpu_R[RRR_T],\n\n                            OP1 & 2, op == MAC16_UMUL);\n\n\n\n                    if (op == MAC16_MUL || op == MAC16_UMUL) {\n\n                        tcg_gen_mul_i32(cpu_SR[ACCLO], m1, m2);\n\n                        if (op == MAC16_UMUL) {\n\n                            tcg_gen_movi_i32(cpu_SR[ACCHI], 0);\n\n                        } else {\n\n                            tcg_gen_sari_i32(cpu_SR[ACCHI], cpu_SR[ACCLO], 31);\n\n                        }\n\n                    } else {\n\n                        TCGv_i32 lo = tcg_temp_new_i32();\n\n                        TCGv_i32 hi = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_mul_i32(lo, m1, m2);\n\n                        tcg_gen_sari_i32(hi, lo, 31);\n\n                        if (op == MAC16_MULA) {\n\n                            tcg_gen_add2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             lo, hi);\n\n                        } else {\n\n                            tcg_gen_sub2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             lo, hi);\n\n                        }\n\n                        tcg_gen_ext8s_i32(cpu_SR[ACCHI], cpu_SR[ACCHI]);\n\n\n\n                        tcg_temp_free_i32(lo);\n\n                        tcg_temp_free_i32(hi);\n\n                    }\n\n                    tcg_temp_free(m1);\n\n                    tcg_temp_free(m2);\n\n                }\n\n                if (ld_offset) {\n\n                    tcg_gen_mov_i32(cpu_R[RRR_S], vaddr);\n\n                    tcg_gen_mov_i32(cpu_SR[MR + RRR_W], mem32);\n\n                }\n\n                tcg_temp_free(vaddr);\n\n                tcg_temp_free(mem32);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 5: /*CALLN*/\n\n        switch (CALL_N) {\n\n        case 0: /*CALL0*/\n\n            tcg_gen_movi_i32(cpu_R[0], dc->next_pc);\n\n            gen_jumpi(dc, (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);\n\n            break;\n\n\n\n        case 1: /*CALL4w*/\n\n        case 2: /*CALL8w*/\n\n        case 3: /*CALL12w*/\n\n            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n            if (gen_window_check1(dc, CALL_N << 2)) {\n\n                gen_callwi(dc, CALL_N,\n\n                           (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);\n\n            }\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 6: /*SI*/\n\n        switch (CALL_N) {\n\n        case 0: /*J*/\n\n            gen_jumpi(dc, dc->pc + 4 + CALL_OFFSET_SE, 0);\n\n            break;\n\n\n\n        case 1: /*BZ*/\n\n            if (gen_window_check1(dc, BRI12_S)) {\n\n                static const TCGCond cond[] = {\n\n                    TCG_COND_EQ, /*BEQZ*/\n\n                    TCG_COND_NE, /*BNEZ*/\n\n                    TCG_COND_LT, /*BLTZ*/\n\n                    TCG_COND_GE, /*BGEZ*/\n\n                };\n\n\n\n                gen_brcondi(dc, cond[BRI12_M & 3], cpu_R[BRI12_S], 0,\n\n                        4 + BRI12_IMM12_SE);\n\n            }\n\n            break;\n\n\n\n        case 2: /*BI0*/\n\n            if (gen_window_check1(dc, BRI8_S)) {\n\n                static const TCGCond cond[] = {\n\n                    TCG_COND_EQ, /*BEQI*/\n\n                    TCG_COND_NE, /*BNEI*/\n\n                    TCG_COND_LT, /*BLTI*/\n\n                    TCG_COND_GE, /*BGEI*/\n\n                };\n\n\n\n                gen_brcondi(dc, cond[BRI8_M & 3],\n\n                        cpu_R[BRI8_S], B4CONST[BRI8_R], 4 + BRI8_IMM8_SE);\n\n            }\n\n            break;\n\n\n\n        case 3: /*BI1*/\n\n            switch (BRI8_M) {\n\n            case 0: /*ENTRYw*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                {\n\n                    TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n                    TCGv_i32 s = tcg_const_i32(BRI12_S);\n\n                    TCGv_i32 imm = tcg_const_i32(BRI12_IMM12);\n\n                    gen_advance_ccount(dc);\n\n                    gen_helper_entry(cpu_env, pc, s, imm);\n\n                    tcg_temp_free(imm);\n\n                    tcg_temp_free(s);\n\n                    tcg_temp_free(pc);\n\n                    /* This can change tb->flags, so exit tb */\n\n                    gen_jumpi_check_loop_end(dc, -1);\n\n                }\n\n                break;\n\n\n\n            case 1: /*B1*/\n\n                switch (BRI8_R) {\n\n                case 0: /*BFp*/\n\n                case 1: /*BTp*/\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                    {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRI8_S);\n\n                        gen_brcondi(dc,\n\n                                BRI8_R == 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                                tmp, 0, 4 + RRI8_IMM8_SE);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 8: /*LOOP*/\n\n                case 9: /*LOOPNEZ*/\n\n                case 10: /*LOOPGTZ*/\n\n                    HAS_OPTION(XTENSA_OPTION_LOOP);\n\n                    if (gen_window_check1(dc, RRI8_S)) {\n\n                        uint32_t lend = dc->pc + RRI8_IMM8 + 4;\n\n                        TCGv_i32 tmp = tcg_const_i32(lend);\n\n\n\n                        tcg_gen_subi_i32(cpu_SR[LCOUNT], cpu_R[RRI8_S], 1);\n\n                        tcg_gen_movi_i32(cpu_SR[LBEG], dc->next_pc);\n\n                        gen_helper_wsr_lend(cpu_env, tmp);\n\n                        tcg_temp_free(tmp);\n\n\n\n                        if (BRI8_R > 8) {\n\n                            int label = gen_new_label();\n\n                            tcg_gen_brcondi_i32(\n\n                                    BRI8_R == 9 ? TCG_COND_NE : TCG_COND_GT,\n\n                                    cpu_R[RRI8_S], 0, label);\n\n                            gen_jumpi(dc, lend, 1);\n\n                            gen_set_label(label);\n\n                        }\n\n\n\n                        gen_jumpi(dc, dc->next_pc, 0);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n            case 2: /*BLTUI*/\n\n            case 3: /*BGEUI*/\n\n                if (gen_window_check1(dc, BRI8_S)) {\n\n                    gen_brcondi(dc, BRI8_M == 2 ? TCG_COND_LTU : TCG_COND_GEU,\n\n                                cpu_R[BRI8_S], B4CONSTU[BRI8_R],\n\n                                4 + BRI8_IMM8_SE);\n\n                }\n\n                break;\n\n            }\n\n            break;\n\n\n\n        }\n\n        break;\n\n\n\n    case 7: /*B*/\n\n        {\n\n            TCGCond eq_ne = (RRI8_R & 8) ? TCG_COND_NE : TCG_COND_EQ;\n\n\n\n            switch (RRI8_R & 7) {\n\n            case 0: /*BNONE*/ /*BANY*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 1: /*BEQ*/ /*BNE*/\n\n            case 2: /*BLT*/ /*BGE*/\n\n            case 3: /*BLTU*/ /*BGEU*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        [1] = TCG_COND_EQ,\n\n                        [2] = TCG_COND_LT,\n\n                        [3] = TCG_COND_LTU,\n\n                        [9] = TCG_COND_NE,\n\n                        [10] = TCG_COND_GE,\n\n                        [11] = TCG_COND_GEU,\n\n                    };\n\n                    gen_brcond(dc, cond[RRI8_R], cpu_R[RRI8_S], cpu_R[RRI8_T],\n\n                            4 + RRI8_IMM8_SE);\n\n                }\n\n                break;\n\n\n\n            case 4: /*BALL*/ /*BNALL*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);\n\n                    gen_brcond(dc, eq_ne, tmp, cpu_R[RRI8_T],\n\n                            4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 5: /*BBC*/ /*BBS*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                    TCGv_i32 bit = tcg_const_i32(0x80000000);\n\n#else\n\n                    TCGv_i32 bit = tcg_const_i32(0x00000001);\n\n#endif\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_T], 0x1f);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                    tcg_gen_shr_i32(bit, bit, tmp);\n\n#else\n\n                    tcg_gen_shl_i32(bit, bit, tmp);\n\n#endif\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], bit);\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(bit);\n\n                }\n\n                break;\n\n\n\n            case 6: /*BBCI*/ /*BBSI*/\n\n            case 7:\n\n                if (gen_window_check1(dc, RRI8_S)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_S],\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                            0x80000000 >> (((RRI8_R & 1) << 4) | RRI8_T));\n\n#else\n\n                            0x00000001 << (((RRI8_R & 1) << 4) | RRI8_T));\n\n#endif\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            }\n\n        }\n\n        break;\n\n\n\n#define gen_narrow_load_store(type) do { \\\n\n            if (gen_window_check2(dc, RRRN_S, RRRN_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRRN_S], RRRN_R << 2); \\\n\n                gen_load_store_alignment(dc, 2, addr, false); \\\n\n                tcg_gen_qemu_##type(cpu_R[RRRN_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n    case 8: /*L32I.Nn*/\n\n        gen_narrow_load_store(ld32u);\n\n        break;\n\n\n\n    case 9: /*S32I.Nn*/\n\n        gen_narrow_load_store(st32);\n\n        break;\n\n#undef gen_narrow_load_store\n\n\n\n    case 10: /*ADD.Nn*/\n\n        if (gen_window_check3(dc, RRRN_R, RRRN_S, RRRN_T)) {\n\n            tcg_gen_add_i32(cpu_R[RRRN_R], cpu_R[RRRN_S], cpu_R[RRRN_T]);\n\n        }\n\n        break;\n\n\n\n    case 11: /*ADDI.Nn*/\n\n        if (gen_window_check2(dc, RRRN_R, RRRN_S)) {\n\n            tcg_gen_addi_i32(cpu_R[RRRN_R], cpu_R[RRRN_S],\n\n                             RRRN_T ? RRRN_T : -1);\n\n        }\n\n        break;\n\n\n\n    case 12: /*ST2n*/\n\n        if (!gen_window_check1(dc, RRRN_S)) {\n\n            break;\n\n        }\n\n        if (RRRN_T < 8) { /*MOVI.Nn*/\n\n            tcg_gen_movi_i32(cpu_R[RRRN_S],\n\n                    RRRN_R | (RRRN_T << 4) |\n\n                    ((RRRN_T & 6) == 6 ? 0xffffff80 : 0));\n\n        } else { /*BEQZ.Nn*/ /*BNEZ.Nn*/\n\n            TCGCond eq_ne = (RRRN_T & 4) ? TCG_COND_NE : TCG_COND_EQ;\n\n\n\n            gen_brcondi(dc, eq_ne, cpu_R[RRRN_S], 0,\n\n                    4 + (RRRN_R | ((RRRN_T & 3) << 4)));\n\n        }\n\n        break;\n\n\n\n    case 13: /*ST3n*/\n\n        switch (RRRN_R) {\n\n        case 0: /*MOV.Nn*/\n\n            if (gen_window_check2(dc, RRRN_S, RRRN_T)) {\n\n                tcg_gen_mov_i32(cpu_R[RRRN_T], cpu_R[RRRN_S]);\n\n            }\n\n            break;\n\n\n\n        case 15: /*S3*/\n\n            switch (RRRN_T) {\n\n            case 0: /*RET.Nn*/\n\n                gen_jump(dc, cpu_R[0]);\n\n                break;\n\n\n\n            case 1: /*RETW.Nn*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                {\n\n                    TCGv_i32 tmp = tcg_const_i32(dc->pc);\n\n                    gen_advance_ccount(dc);\n\n                    gen_helper_retw(tmp, cpu_env, tmp);\n\n                    gen_jump(dc, tmp);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 2: /*BREAK.Nn*/\n\n                HAS_OPTION(XTENSA_OPTION_DEBUG);\n\n                if (dc->debug) {\n\n                    gen_debug_exception(dc, DEBUGCAUSE_BN);\n\n                }\n\n                break;\n\n\n\n            case 3: /*NOP.Nn*/\n\n                break;\n\n\n\n            case 6: /*ILL.Nn*/\n\n                gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default: /*reserved*/\n\n        RESERVED();\n\n        break;\n\n    }\n\n\n\n    if (dc->is_jmp == DISAS_NEXT) {\n\n        gen_check_loop_end(dc, 0);\n\n    }\n\n    dc->pc = dc->next_pc;\n\n\n\n    return;\n\n\n\ninvalid_opcode:\n\n    qemu_log(\"INVALID(pc = %08x)\\n\", dc->pc);\n\n    gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n#undef HAS_OPTION\n\n}\n", "idx": 22421, "_split": "test", "_hash": "72fda72899f6a50597d1bb91548cd6c6"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_file_set_error(QEMUFile *f, int ret)\n\n{\n\n    if (f->last_error == 0) {\n\n        f->last_error = ret;\n\n    }\n\n}\n", "idx": 22431, "_split": "test", "_hash": "8cca1a78d2a37a8416a91557b13cc17c"}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_efdctuidz (uint64_t val)\n\n{\n\n    CPU_DoubleU u;\n\n\n\n    u.ll = val;\n\n    /* NaN are not treated the same way IEEE 754 does */\n\n    if (unlikely(float64_is_nan(u.d)))\n\n        return 0;\n\n\n\n    return float64_to_uint64_round_to_zero(u.d, &env->vec_status);\n\n}\n", "idx": 22462, "_split": "test", "_hash": "2278548a52bc2fad1e6eff70a4115c49"}
{"project": "qemu", "commit_id": "28213cb6a61a724e2cb1e3a76d2bb17aa0ce9b36", "target": 0, "func": "void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,\n\n                                     void *start, unsigned size,\n\n                                     uint8_t *checksum)\n\n{\n\n    BiosLinkerLoaderEntry entry;\n\n    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);\n\n    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;\n\n    ptrdiff_t start_offset = (gchar *)start - file->blob->data;\n\n\n\n    assert(checksum_offset >= 0);\n\n    assert(start_offset >= 0);\n\n    assert(checksum_offset + 1 <= file->blob->len);\n\n    assert(start_offset + size <= file->blob->len);\n\n    assert(*checksum == 0x0);\n\n\n\n    memset(&entry, 0, sizeof entry);\n\n    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);\n\n    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);\n\n    entry.cksum.offset = cpu_to_le32(checksum_offset);\n\n    entry.cksum.start = cpu_to_le32(start_offset);\n\n    entry.cksum.length = cpu_to_le32(size);\n\n\n\n    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);\n\n}\n", "idx": 22465, "_split": "test", "_hash": "a4b0054cba05ec184048f5df4adbed7b"}
{"project": "qemu", "commit_id": "6b49809c597331803ea941eadda813e5bb4e8fe2", "target": 1, "func": "void qemu_mutex_lock_iothread(void)\n\n{\n\n    if (!tcg_enabled()) {\n\n        qemu_mutex_lock(&qemu_global_mutex);\n\n    } else {\n\n        iothread_requesting_mutex = true;\n\n        if (qemu_mutex_trylock(&qemu_global_mutex)) {\n\n            qemu_cpu_kick_thread(first_cpu);\n\n            qemu_mutex_lock(&qemu_global_mutex);\n\n        }\n\n        iothread_requesting_mutex = false;\n\n        qemu_cond_broadcast(&qemu_io_proceeded_cond);\n\n    }\n\n}\n", "idx": 22534, "_split": "test", "_hash": "4d97a487edde225d4175fb472c539996"}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "static inline void gen_op_addl_ESP_im(int32_t val)\n\n{\n\n    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));\n\n    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);\n\n#ifdef TARGET_X86_64\n\n    tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, 0xffffffff);\n\n#endif\n\n    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));\n\n}\n", "idx": 22545, "_split": "test", "_hash": "f467d00ca3da046d00c7d9ec74063bee"}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_movu_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tint size = memsize_z(dc);\n\n\tDIS(fprintf (logfile, \"movu.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(size),\n\n\t\t    dc->op1, dc->op2));\n\n\n\n\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\tdec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);\n\n\tcris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n", "idx": 22552, "_split": "test", "_hash": "a88b77b6a9abe894fc0390f3d1331947"}
{"project": "qemu", "commit_id": "654598c944aa31cdbea435bd468055af9c918d16", "target": 1, "func": "static void pc_fw_add_pflash_drv(void)\n\n{\n\n    QemuOpts *opts;\n\n    QEMUMachine *machine;\n\n    char *filename;\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = BIOS_FILENAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n\n\n    opts = drive_add(IF_PFLASH, -1, filename, \"readonly=on\");\n\n\n\n    g_free(filename);\n\n\n\n    if (opts == NULL) {\n\n      return;\n\n    }\n\n\n\n    machine = find_default_machine();\n\n    if (machine == NULL) {\n\n      return;\n\n    }\n\n\n\n    drive_init(opts, machine->use_scsi);\n\n}\n", "idx": 22615, "_split": "test", "_hash": "3424c012dd90b2177502ad0a218669d5"}
{"project": "qemu", "commit_id": "fa4478d5c8b74a5f0c8b93cc00590ec007be5016", "target": 1, "func": "void stream_start(BlockDriverState *bs, BlockDriverState *base,\n\n                  const char *base_id, int64_t speed,\n\n                  BlockDriverCompletionFunc *cb,\n\n                  void *opaque, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n    Coroutine *co;\n\n\n\n    s = block_job_create(&stream_job_type, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->base = base;\n\n    if (base_id) {\n\n        pstrcpy(s->backing_file_id, sizeof(s->backing_file_id), base_id);\n\n    }\n\n\n\n    co = qemu_coroutine_create(stream_run);\n\n    trace_stream_start(bs, base, s, co, opaque);\n\n    qemu_coroutine_enter(co, s);\n\n}\n", "idx": 22652, "_split": "test", "_hash": "5cd10a05db393c5f97bd37c61ec5a766"}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(srawi)\n\n{\n\n    T1 = T0;\n\n    T0 = (Ts0 >> PARAM(1));\n\n    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {\n\n        xer_ca = 1;\n\n    } else {\n\n        xer_ca = 0;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 22683, "_split": "test", "_hash": "2701b2dddb2d32e3d00aa41a29e5e111"}
{"project": "qemu", "commit_id": "daa76aa416b1e18ab1fac650ff53d966d8f21f68", "target": 1, "func": "void trace_init_file(const char *file)\n\n{\n\n#ifdef CONFIG_TRACE_SIMPLE\n\n    st_set_trace_file(file);\n\n#elif defined CONFIG_TRACE_LOG\n\n    /* If both the simple and the log backends are enabled, \"-trace file\"\n\n     * only applies to the simple backend; use \"-D\" for the log backend.\n\n     */\n\n    if (file) {\n\n        qemu_set_log_filename(file);\n\n    }\n\n#else\n\n    if (file) {\n\n        fprintf(stderr, \"error: -trace file=...: \"\n\n                \"option not supported by the selected tracing backends\\n\");\n\n        exit(1);\n\n    }\n\n#endif\n\n}\n", "idx": 22693, "_split": "test", "_hash": "8ecc28c10fd1405dc1a454a04bf6b5dc"}
{"project": "qemu", "commit_id": "7faa8075d898ae56d2c533c530569bb25ab86eaf", "target": 1, "func": "static void piix4_update_hotplug(PIIX4PMState *s)\n\n{\n\n    PCIDevice *dev = &s->dev;\n\n    BusState *bus = qdev_get_parent_bus(&dev->qdev);\n\n    DeviceState *qdev, *next;\n\n\n\n    s->pci0_hotplug_enable = ~0;\n\n\n\n    QTAILQ_FOREACH_SAFE(qdev, &bus->children, sibling, next) {\n\n        PCIDevice *pdev = PCI_DEVICE(qdev);\n\n        PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pdev);\n\n        int slot = PCI_SLOT(pdev->devfn);\n\n\n\n        if (pc->no_hotplug) {\n\n            s->pci0_hotplug_enable &= ~(1 << slot);\n\n        }\n\n    }\n\n}\n", "idx": 22705, "_split": "test", "_hash": "d74223f4f1eca1c95c504f5f826103c7"}
{"project": "qemu", "commit_id": "f3e4ce4af336f2ea306fa0f40ec1a5149864ca8c", "target": 1, "func": "static void stream_set_speed(BlockJob *job, int64_t speed, Error **errp)\n\n{\n\n    StreamBlockJob *s = container_of(job, StreamBlockJob, common);\n\n\n\n    if (speed < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");\n\n        return;\n\n    }\n\n    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);\n\n}\n", "idx": 22709, "_split": "test", "_hash": "4b872ce7e66c55e91b687e098bb3cf2c"}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "int unix_start_incoming_migration(const char *path)\n\n{\n\n    struct sockaddr_un un;\n\n    int sock;\n\n\n\n    dprintf(\"Attempting to start an incoming migration\\n\");\n\n\n\n    sock = socket(PF_UNIX, SOCK_STREAM, 0);\n\n    if (sock < 0) {\n\n        fprintf(stderr, \"Could not open unix socket: %s\\n\", strerror(errno));\n\n        return -EINVAL;\n\n    }\n\n\n\n    memset(&un, 0, sizeof(un));\n\n    un.sun_family = AF_UNIX;\n\n    snprintf(un.sun_path, sizeof(un.sun_path), \"%s\", path);\n\n\n\n    unlink(un.sun_path);\n\n    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {\n\n        fprintf(stderr, \"bind(unix:%s): %s\\n\", un.sun_path, strerror(errno));\n\n        goto err;\n\n    }\n\n    if (listen(sock, 1) < 0) {\n\n        fprintf(stderr, \"listen(unix:%s): %s\\n\", un.sun_path, strerror(errno));\n\n        goto err;\n\n    }\n\n\n\n    qemu_set_fd_handler2(sock, NULL, unix_accept_incoming_migration, NULL,\n\n\t\t\t (void *)(unsigned long)sock);\n\n\n\n    return 0;\n\n\n\nerr:\n\n    close(sock);\n\n\n\n    return -EINVAL;\n\n}\n", "idx": 22741, "_split": "test", "_hash": "f3ee5df2b113123528e63804310720e7"}
{"project": "qemu", "commit_id": "d9e0dfa2462e32cc5c6c49401ad7bff36453f75c", "target": 0, "func": "void bdrv_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    Error *local_err = NULL;\n\n\n\n    memset(&bs->bl, 0, sizeof(bs->bl));\n\n\n\n    if (!drv) {\n\n        return;\n\n    }\n\n\n\n    /* Default alignment based on whether driver has byte interface */\n\n    bs->request_alignment = drv->bdrv_co_preadv ? 1 : 512;\n\n\n\n    /* Take some limits from the children as a default */\n\n    if (bs->file) {\n\n        bdrv_refresh_limits(bs->file->bs, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n        bs->bl.opt_transfer = bs->file->bs->bl.opt_transfer;\n\n        bs->bl.max_transfer = bs->file->bs->bl.max_transfer;\n\n        bs->bl.min_mem_alignment = bs->file->bs->bl.min_mem_alignment;\n\n        bs->bl.opt_mem_alignment = bs->file->bs->bl.opt_mem_alignment;\n\n        bs->bl.max_iov = bs->file->bs->bl.max_iov;\n\n    } else {\n\n        bs->bl.min_mem_alignment = 512;\n\n        bs->bl.opt_mem_alignment = getpagesize();\n\n\n\n        /* Safe default since most protocols use readv()/writev()/etc */\n\n        bs->bl.max_iov = IOV_MAX;\n\n    }\n\n\n\n    if (bs->backing) {\n\n        bdrv_refresh_limits(bs->backing->bs, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n        bs->bl.opt_transfer = MAX(bs->bl.opt_transfer,\n\n                                  bs->backing->bs->bl.opt_transfer);\n\n        bs->bl.max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,\n\n                                           bs->backing->bs->bl.max_transfer);\n\n        bs->bl.opt_mem_alignment =\n\n            MAX(bs->bl.opt_mem_alignment,\n\n                bs->backing->bs->bl.opt_mem_alignment);\n\n        bs->bl.min_mem_alignment =\n\n            MAX(bs->bl.min_mem_alignment,\n\n                bs->backing->bs->bl.min_mem_alignment);\n\n        bs->bl.max_iov =\n\n            MIN(bs->bl.max_iov,\n\n                bs->backing->bs->bl.max_iov);\n\n    }\n\n\n\n    /* Then let the driver override it */\n\n    if (drv->bdrv_refresh_limits) {\n\n        drv->bdrv_refresh_limits(bs, errp);\n\n    }\n\n}\n", "idx": 22752, "_split": "test", "_hash": "a65904bedada2acb8f23acc7bf3e6e6f"}
{"project": "qemu", "commit_id": "8a5bb1f114c5959cf6b247a737394afb0c518b40", "target": 0, "func": "static int check_refblocks(BlockDriverState *bs, BdrvCheckResult *res,\n\n                           BdrvCheckMode fix, bool *rebuild,\n\n                           void **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t i, size;\n\n    int ret;\n\n\n\n    for(i = 0; i < s->refcount_table_size; i++) {\n\n        uint64_t offset, cluster;\n\n        offset = s->refcount_table[i];\n\n        cluster = offset >> s->cluster_bits;\n\n\n\n        /* Refcount blocks are cluster aligned */\n\n        if (offset_into_cluster(s, offset)) {\n\n            fprintf(stderr, \"ERROR refcount block %\" PRId64 \" is not \"\n\n                \"cluster aligned; refcount table entry corrupted\\n\", i);\n\n            res->corruptions++;\n\n            *rebuild = true;\n\n            continue;\n\n        }\n\n\n\n        if (cluster >= *nb_clusters) {\n\n            fprintf(stderr, \"%s refcount block %\" PRId64 \" is outside image\\n\",\n\n                    fix & BDRV_FIX_ERRORS ? \"Repairing\" : \"ERROR\", i);\n\n\n\n            if (fix & BDRV_FIX_ERRORS) {\n\n                int64_t new_nb_clusters;\n\n                Error *local_err = NULL;\n\n\n\n                if (offset > INT64_MAX - s->cluster_size) {\n\n                    ret = -EINVAL;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                ret = bdrv_truncate(bs->file, offset + s->cluster_size,\n\n                                    &local_err);\n\n                if (ret < 0) {\n\n                    error_report_err(local_err);\n\n                    goto resize_fail;\n\n                }\n\n                size = bdrv_getlength(bs->file->bs);\n\n                if (size < 0) {\n\n                    ret = size;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                new_nb_clusters = size_to_clusters(s, size);\n\n                assert(new_nb_clusters >= *nb_clusters);\n\n\n\n                ret = realloc_refcount_array(s, refcount_table,\n\n                                             nb_clusters, new_nb_clusters);\n\n                if (ret < 0) {\n\n                    res->check_errors++;\n\n                    return ret;\n\n                }\n\n\n\n                if (cluster >= *nb_clusters) {\n\n                    ret = -EINVAL;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                res->corruptions_fixed++;\n\n                ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                                    offset, s->cluster_size);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                /* No need to check whether the refcount is now greater than 1:\n\n                 * This area was just allocated and zeroed, so it can only be\n\n                 * exactly 1 after inc_refcounts() */\n\n                continue;\n\n\n\nresize_fail:\n\n                res->corruptions++;\n\n                *rebuild = true;\n\n                fprintf(stderr, \"ERROR could not resize image: %s\\n\",\n\n                        strerror(-ret));\n\n            } else {\n\n                res->corruptions++;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        if (offset != 0) {\n\n            ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                                offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n            if (s->get_refcount(*refcount_table, cluster) != 1) {\n\n                fprintf(stderr, \"ERROR refcount block %\" PRId64\n\n                        \" refcount=%\" PRIu64 \"\\n\", i,\n\n                        s->get_refcount(*refcount_table, cluster));\n\n                res->corruptions++;\n\n                *rebuild = true;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 22759, "_split": "test", "_hash": "df4e3ede8dedfe6aba5f73b10d1a61c5"}
{"project": "qemu", "commit_id": "bb44619b06c0bef20b658ff532cf850c16362ae7", "target": 1, "func": "DriveInfo *drive_init(QemuOpts *opts, BlockInterfaceType block_default_type)\n\n{\n\n    const char *buf;\n\n    const char *file = NULL;\n\n    const char *serial;\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriver *drv = NULL;\n\n    int max_devs;\n\n    int index;\n\n    int ro = 0;\n\n    int bdrv_flags = 0;\n\n    int on_read_error, on_write_error;\n\n    const char *devaddr;\n\n    DriveInfo *dinfo;\n\n    BlockIOLimit io_limits;\n\n    int snapshot = 0;\n\n    bool copy_on_read;\n\n    int ret;\n\n    Error *error = NULL;\n\n\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n    bus_id  = qemu_opt_get_number(opts, \"bus\", 0);\n\n    unit_id = qemu_opt_get_number(opts, \"unit\", -1);\n\n    index   = qemu_opt_get_number(opts, \"index\", -1);\n\n\n\n    cyls  = qemu_opt_get_number(opts, \"cyls\", 0);\n\n    heads = qemu_opt_get_number(opts, \"heads\", 0);\n\n    secs  = qemu_opt_get_number(opts, \"secs\", 0);\n\n\n\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n    ro = qemu_opt_get_bool(opts, \"readonly\", 0);\n\n    copy_on_read = qemu_opt_get_bool(opts, \"copy-on-read\", false);\n\n\n\n    file = qemu_opt_get(opts, \"file\");\n\n    serial = qemu_opt_get(opts, \"serial\");\n\n\n\n    if ((buf = qemu_opt_get(opts, \"if\")) != NULL) {\n\n        for (type = 0; type < IF_COUNT && strcmp(buf, if_name[type]); type++)\n\n            ;\n\n        if (type == IF_COUNT) {\n\n            error_report(\"unsupported bus type '%s'\", buf);\n\n            return NULL;\n\n\t}\n\n    } else {\n\n        type = block_default_type;\n\n    }\n\n\n\n    max_devs = if_max_devs[type];\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1) {\n\n            error_report(\"invalid physical cyls number\");\n\n\t    return NULL;\n\n\t}\n\n        if (heads < 1) {\n\n            error_report(\"invalid physical heads number\");\n\n\t    return NULL;\n\n\t}\n\n        if (secs < 1) {\n\n            error_report(\"invalid physical secs number\");\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"trans\")) != NULL) {\n\n        if (!cyls) {\n\n            error_report(\"'%s' trans must be used with cyls, heads and secs\",\n\n                         buf);\n\n            return NULL;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            error_report(\"'%s' invalid translation type\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"media\")) != NULL) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                error_report(\"CHS can't be set with media=%s\", buf);\n\n\t        return NULL;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    error_report(\"'%s' invalid media\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"discard\")) != NULL) {\n\n        if (bdrv_parse_discard_flags(buf, &bdrv_flags) != 0) {\n\n            error_report(\"invalid discard option\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    bdrv_flags |= BDRV_O_CACHE_WB;\n\n    if ((buf = qemu_opt_get(opts, \"cache\")) != NULL) {\n\n        if (bdrv_parse_cache_flags(buf, &bdrv_flags) != 0) {\n\n            error_report(\"invalid cache option\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n#ifdef CONFIG_LINUX_AIO\n\n    if ((buf = qemu_opt_get(opts, \"aio\")) != NULL) {\n\n        if (!strcmp(buf, \"native\")) {\n\n            bdrv_flags |= BDRV_O_NATIVE_AIO;\n\n        } else if (!strcmp(buf, \"threads\")) {\n\n            /* this is the default */\n\n        } else {\n\n           error_report(\"invalid aio option\");\n\n           return NULL;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n\n        if (is_help_option(buf)) {\n\n            error_printf(\"Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            error_printf(\"\\n\");\n\n            return NULL;\n\n        }\n\n        drv = bdrv_find_whitelisted_format(buf);\n\n        if (!drv) {\n\n            error_report(\"'%s' invalid format\", buf);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* disk I/O throttling */\n\n    io_limits.bps[BLOCK_IO_LIMIT_TOTAL]  =\n\n                           qemu_opt_get_number(opts, \"bps\", 0);\n\n    io_limits.bps[BLOCK_IO_LIMIT_READ]   =\n\n                           qemu_opt_get_number(opts, \"bps_rd\", 0);\n\n    io_limits.bps[BLOCK_IO_LIMIT_WRITE]  =\n\n                           qemu_opt_get_number(opts, \"bps_wr\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_TOTAL] =\n\n                           qemu_opt_get_number(opts, \"iops\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_READ]  =\n\n                           qemu_opt_get_number(opts, \"iops_rd\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_WRITE] =\n\n                           qemu_opt_get_number(opts, \"iops_wr\", 0);\n\n\n\n    if (!do_check_io_limits(&io_limits, &error)) {\n\n        error_report(\"%s\", error_get_pretty(error));\n\n        error_free(error);\n\n        return NULL;\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"boot\") != NULL) {\n\n        fprintf(stderr, \"qemu-kvm: boot=on|off is deprecated and will be \"\n\n                \"ignored. Future versions will reject this parameter. Please \"\n\n                \"update your scripts.\\n\");\n\n    }\n\n\n\n    on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;\n\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO && type != IF_NONE) {\n\n            error_report(\"werror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_write_error = parse_block_error_action(buf, 0);\n\n        if (on_write_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    on_read_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI && type != IF_NONE) {\n\n            error_report(\"rerror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_read_error = parse_block_error_action(buf, 1);\n\n        if (on_read_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if ((devaddr = qemu_opt_get(opts, \"addr\")) != NULL) {\n\n        if (type != IF_VIRTIO) {\n\n            error_report(\"addr is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            error_report(\"index cannot be used with bus and unit\");\n\n            return NULL;\n\n        }\n\n        bus_id = drive_index_to_bus_id(type, index);\n\n        unit_id = drive_index_to_unit_id(type, index);\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get(type, bus_id, unit_id) != NULL) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        error_report(\"unit %d too big (max is %d)\",\n\n                     unit_id, max_devs - 1);\n\n        return NULL;\n\n    }\n\n\n\n    /*\n\n     * catch multiple definitions\n\n     */\n\n\n\n    if (drive_get(type, bus_id, unit_id) != NULL) {\n\n        error_report(\"drive with bus=%d, unit=%d (index=%d) exists\",\n\n                     bus_id, unit_id, index);\n\n        return NULL;\n\n    }\n\n\n\n    /* init */\n\n\n\n    dinfo = g_malloc0(sizeof(*dinfo));\n\n    if ((buf = qemu_opts_id(opts)) != NULL) {\n\n        dinfo->id = g_strdup(buf);\n\n    } else {\n\n        /* no id supplied -> create one */\n\n        dinfo->id = g_malloc0(32);\n\n        if (type == IF_IDE || type == IF_SCSI)\n\n            mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n        if (max_devs)\n\n            snprintf(dinfo->id, 32, \"%s%i%s%i\",\n\n                     if_name[type], bus_id, mediastr, unit_id);\n\n        else\n\n            snprintf(dinfo->id, 32, \"%s%s%i\",\n\n                     if_name[type], mediastr, unit_id);\n\n    }\n\n    dinfo->bdrv = bdrv_new(dinfo->id);\n\n    dinfo->bdrv->open_flags = snapshot ? BDRV_O_SNAPSHOT : 0;\n\n    dinfo->bdrv->read_only = ro;\n\n    dinfo->devaddr = devaddr;\n\n    dinfo->type = type;\n\n    dinfo->bus = bus_id;\n\n    dinfo->unit = unit_id;\n\n    dinfo->cyls = cyls;\n\n    dinfo->heads = heads;\n\n    dinfo->secs = secs;\n\n    dinfo->trans = translation;\n\n    dinfo->opts = opts;\n\n    dinfo->refcount = 1;\n\n    dinfo->serial = serial;\n\n    QTAILQ_INSERT_TAIL(&drives, dinfo, next);\n\n\n\n    bdrv_set_on_error(dinfo->bdrv, on_read_error, on_write_error);\n\n\n\n    /* disk I/O throttling */\n\n    bdrv_set_io_limits(dinfo->bdrv, &io_limits);\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n    case IF_NONE:\n\n        dinfo->media_cd = media == MEDIA_CDROM;\n\n        break;\n\n    case IF_SD:\n\n    case IF_FLOPPY:\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n        break;\n\n    case IF_VIRTIO:\n\n        /* add virtio block device */\n\n        opts = qemu_opts_create_nofail(qemu_find_opts(\"device\"));\n\n        if (arch_type == QEMU_ARCH_S390X) {\n\n            qemu_opt_set(opts, \"driver\", \"virtio-blk-s390\");\n\n        } else {\n\n            qemu_opt_set(opts, \"driver\", \"virtio-blk-pci\");\n\n        }\n\n        qemu_opt_set(opts, \"drive\", dinfo->id);\n\n        if (devaddr)\n\n            qemu_opt_set(opts, \"addr\", devaddr);\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    if (!file || !*file) {\n\n        return dinfo;\n\n    }\n\n    if (snapshot) {\n\n        /* always use cache=unsafe with snapshot */\n\n        bdrv_flags &= ~BDRV_O_CACHE_MASK;\n\n        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB|BDRV_O_NO_FLUSH);\n\n    }\n\n\n\n    if (copy_on_read) {\n\n        bdrv_flags |= BDRV_O_COPY_ON_READ;\n\n    }\n\n\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n\n        bdrv_flags |= BDRV_O_INCOMING;\n\n    }\n\n\n\n    if (media == MEDIA_CDROM) {\n\n        /* CDROM is fine for any interface, don't check.  */\n\n        ro = 1;\n\n    } else if (ro == 1) {\n\n        if (type != IF_SCSI && type != IF_VIRTIO && type != IF_FLOPPY &&\n\n            type != IF_NONE && type != IF_PFLASH) {\n\n            error_report(\"readonly not supported by this bus type\");\n\n            goto err;\n\n        }\n\n    }\n\n\n\n    bdrv_flags |= ro ? 0 : BDRV_O_RDWR;\n\n\n\n    if (ro && copy_on_read) {\n\n        error_report(\"warning: disabling copy_on_read on readonly drive\");\n\n    }\n\n\n\n    ret = bdrv_open(dinfo->bdrv, file, NULL, bdrv_flags, drv);\n\n    if (ret < 0) {\n\n        if (ret == -EMEDIUMTYPE) {\n\n            error_report(\"could not open disk image %s: not in %s format\",\n\n                         file, drv->format_name);\n\n        } else {\n\n            error_report(\"could not open disk image %s: %s\",\n\n                         file, strerror(-ret));\n\n        }\n\n        goto err;\n\n    }\n\n\n\n    if (bdrv_key_required(dinfo->bdrv))\n\n        autostart = 0;\n\n    return dinfo;\n\n\n\nerr:\n\n    bdrv_delete(dinfo->bdrv);\n\n    g_free(dinfo->id);\n\n    QTAILQ_REMOVE(&drives, dinfo, next);\n\n    g_free(dinfo);\n\n    return NULL;\n\n}\n", "idx": 22801, "_split": "test", "_hash": "7f438159b4b0778735efde4b8ab7f6c7"}
{"project": "qemu", "commit_id": "0b2c1beea4358e40d1049b8ee019408ce96b37ce", "target": 1, "func": "static const char *keyval_parse_one(QDict *qdict, const char *params,\n\n                                    const char *implied_key,\n\n                                    Error **errp)\n\n{\n\n    const char *key, *key_end, *s;\n\n    size_t len;\n\n    char key_in_cur[128];\n\n    QDict *cur;\n\n    int ret;\n\n    QObject *next;\n\n    QString *val;\n\n\n\n    key = params;\n\n    len = strcspn(params, \"=,\");\n\n    if (implied_key && len && key[len] != '=') {\n\n        /* Desugar implied key */\n\n        key = implied_key;\n\n        len = strlen(implied_key);\n\n    }\n\n    key_end = key + len;\n\n\n\n    /*\n\n     * Loop over key fragments: @s points to current fragment, it\n\n     * applies to @cur.  @key_in_cur[] holds the previous fragment.\n\n     */\n\n    cur = qdict;\n\n    s = key;\n\n    for (;;) {\n\n        ret = parse_qapi_name(s, false);\n\n        len = ret < 0 ? 0 : ret;\n\n        assert(s + len <= key_end);\n\n        if (!len || (s + len < key_end && s[len] != '.')) {\n\n            assert(key != implied_key);\n\n            error_setg(errp, \"Invalid parameter '%.*s'\",\n\n                       (int)(key_end - key), key);\n\n            return NULL;\n\n        }\n\n        if (len >= sizeof(key_in_cur)) {\n\n            assert(key != implied_key);\n\n            error_setg(errp, \"Parameter%s '%.*s' is too long\",\n\n                       s != key || s + len != key_end ? \" fragment\" : \"\",\n\n                       (int)len, s);\n\n            return NULL;\n\n        }\n\n\n\n        if (s != key) {\n\n            next = keyval_parse_put(cur, key_in_cur, NULL,\n\n                                    key, s - 1, errp);\n\n            if (!next) {\n\n                return NULL;\n\n            }\n\n            cur = qobject_to_qdict(next);\n\n            assert(cur);\n\n        }\n\n\n\n        memcpy(key_in_cur, s, len);\n\n        key_in_cur[len] = 0;\n\n        s += len;\n\n\n\n        if (*s != '.') {\n\n            break;\n\n        }\n\n        s++;\n\n    }\n\n\n\n    if (key == implied_key) {\n\n        assert(!*s);\n\n        s = params;\n\n    } else {\n\n        if (*s != '=') {\n\n            error_setg(errp, \"Expected '=' after parameter '%.*s'\",\n\n                       (int)(s - key), key);\n\n            return NULL;\n\n        }\n\n        s++;\n\n    }\n\n\n\n    val = qstring_new();\n\n    for (;;) {\n\n        if (!*s) {\n\n            break;\n\n        } else if (*s == ',') {\n\n            s++;\n\n            if (*s != ',') {\n\n                break;\n\n            }\n\n        }\n\n        qstring_append_chr(val, *s++);\n\n    }\n\n\n\n    if (!keyval_parse_put(cur, key_in_cur, val, key, key_end, errp)) {\n\n        return NULL;\n\n    }\n\n    return s;\n\n}\n", "idx": 22815, "_split": "test", "_hash": "81a706d6de411ce17716db1d2ff8c601"}
{"project": "qemu", "commit_id": "a879125b47c3ae554c01824f996a64a45a86556e", "target": 1, "func": "static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    return inl(0xcfc);\n\n}\n", "idx": 22834, "_split": "test", "_hash": "730fa26fb6ddd572d66b5449c7873640"}
{"project": "qemu", "commit_id": "4cb88c3c378ae8c86c0ba53619caf6924f72239c", "target": 1, "func": "static int load_normal_reset(S390CPU *cpu)\n\n{\n\n    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);\n\n\n\n    pause_all_vcpus();\n\n    cpu_synchronize_all_states();\n\n    cpu_reset_all();\n\n\n    io_subsystem_reset();\n\n    scc->initial_cpu_reset(CPU(cpu));\n\n    scc->load_normal(CPU(cpu));\n\n    cpu_synchronize_all_post_reset();\n\n    resume_all_vcpus();\n\n    return 0;\n\n}", "idx": 22875, "_split": "test", "_hash": "75a63c2853b0a047d3bebe57c333f671"}
{"project": "qemu", "commit_id": "ab03b63d7a9c7978d51e56c191f0b86888d121dc", "target": 1, "func": "static void v9fs_post_lcreate(V9fsState *s, V9fsLcreateState *vs, int err)\n\n{\n\n    if (err == 0) {\n\n        v9fs_string_copy(&vs->fidp->path, &vs->fullname);\n\n        stat_to_qid(&vs->stbuf, &vs->qid);\n\n        vs->offset += pdu_marshal(vs->pdu, vs->offset, \"Qd\", &vs->qid,\n\n                &vs->iounit);\n\n        err = vs->offset;\n\n    } else {\n\n        vs->fidp->fid_type = P9_FID_NONE;\n\n        close(vs->fidp->fs.fd);\n\n        err = -errno;\n\n    }\n\n\n\n    complete_pdu(s, vs->pdu, err);\n\n    v9fs_string_free(&vs->name);\n\n    v9fs_string_free(&vs->fullname);\n\n    qemu_free(vs);\n\n}\n", "idx": 22876, "_split": "test", "_hash": "a14a4478cf1c21bdf8ec1689333e3bc6"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void get_xbzrle_cache_stats(MigrationInfo *info)\n\n{\n\n    if (migrate_use_xbzrle()) {\n\n        info->has_xbzrle_cache = true;\n\n        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));\n\n        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();\n\n        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();\n\n        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();\n\n        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();\n\n        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();\n\n        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();\n\n    }\n\n}\n", "idx": 22906, "_split": "test", "_hash": "53d2c552395039b387c0d5b9b5e1c9da"}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,\n\n                                      int do_init,\n\n                                      const char *cpu_model,\n\n                                      uint32_t sysclk)\n\n{\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    qemu_irq *irqs;\n\n\n\n    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    ppc_booke_timers_init(cpu, sysclk, 0/* no flags */);\n\n\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n    return cpu;\n\n}\n", "idx": 22931, "_split": "test", "_hash": "6adc4fd11c4648583c527f9dad8e304d"}
{"project": "qemu", "commit_id": "7372c2b926200db295412efbb53f93773b7f1754", "target": 1, "func": "static TCGv gen_ea(CPUM68KState *env, DisasContext *s, uint16_t insn,\n\n                   int opsize, TCGv val, TCGv *addrp, ea_what what)\n\n{\n\n    TCGv reg;\n\n    TCGv result;\n\n    uint32_t offset;\n\n\n\n    switch ((insn >> 3) & 7) {\n\n    case 0: /* Data register direct.  */\n\n        reg = DREG(insn, 0);\n\n        if (what == EA_STORE) {\n\n            gen_partset_reg(opsize, reg, val);\n\n            return store_dummy;\n\n        } else {\n\n            return gen_extend(reg, opsize, what == EA_LOADS);\n\n        }\n\n    case 1: /* Address register direct.  */\n\n        reg = AREG(insn, 0);\n\n        if (what == EA_STORE) {\n\n            tcg_gen_mov_i32(reg, val);\n\n            return store_dummy;\n\n        } else {\n\n            return gen_extend(reg, opsize, what == EA_LOADS);\n\n        }\n\n    case 2: /* Indirect register */\n\n        reg = AREG(insn, 0);\n\n        return gen_ldst(s, opsize, reg, val, what);\n\n    case 3: /* Indirect postincrement.  */\n\n        reg = AREG(insn, 0);\n\n        result = gen_ldst(s, opsize, reg, val, what);\n\n        /* ??? This is not exception safe.  The instruction may still\n\n           fault after this point.  */\n\n        if (what == EA_STORE || !addrp)\n\n            tcg_gen_addi_i32(reg, reg, opsize_bytes(opsize));\n\n        return result;\n\n    case 4: /* Indirect predecrememnt.  */\n\n        {\n\n            TCGv tmp;\n\n            if (addrp && what == EA_STORE) {\n\n                tmp = *addrp;\n\n            } else {\n\n                tmp = gen_lea(env, s, insn, opsize);\n\n                if (IS_NULL_QREG(tmp))\n\n                    return tmp;\n\n                if (addrp)\n\n                    *addrp = tmp;\n\n            }\n\n            result = gen_ldst(s, opsize, tmp, val, what);\n\n            /* ??? This is not exception safe.  The instruction may still\n\n               fault after this point.  */\n\n            if (what == EA_STORE || !addrp) {\n\n                reg = AREG(insn, 0);\n\n                tcg_gen_mov_i32(reg, tmp);\n\n            }\n\n        }\n\n        return result;\n\n    case 5: /* Indirect displacement.  */\n\n    case 6: /* Indirect index + displacement.  */\n\n        return gen_ea_once(env, s, insn, opsize, val, addrp, what);\n\n    case 7: /* Other */\n\n        switch (insn & 7) {\n\n        case 0: /* Absolute short.  */\n\n        case 1: /* Absolute long.  */\n\n        case 2: /* pc displacement  */\n\n        case 3: /* pc index+displacement.  */\n\n            return gen_ea_once(env, s, insn, opsize, val, addrp, what);\n\n        case 4: /* Immediate.  */\n\n            /* Sign extend values for consistency.  */\n\n            switch (opsize) {\n\n            case OS_BYTE:\n\n                if (what == EA_LOADS) {\n\n                    offset = cpu_ldsb_code(env, s->pc + 1);\n\n                } else {\n\n                    offset = cpu_ldub_code(env, s->pc + 1);\n\n                }\n\n                s->pc += 2;\n\n                break;\n\n            case OS_WORD:\n\n                if (what == EA_LOADS) {\n\n                    offset = cpu_ldsw_code(env, s->pc);\n\n                } else {\n\n                    offset = cpu_lduw_code(env, s->pc);\n\n                }\n\n                s->pc += 2;\n\n                break;\n\n            case OS_LONG:\n\n                offset = read_im32(env, s);\n\n                break;\n\n            default:\n\n                qemu_assert(0, \"Bad immediate operand\");\n\n            }\n\n            return tcg_const_i32(offset);\n\n        default:\n\n            return NULL_QREG;\n\n        }\n\n    }\n\n    /* Should never happen.  */\n\n    return NULL_QREG;\n\n}\n", "idx": 22969, "_split": "test", "_hash": "27c5ef3846228267ba477bc8aa3cfae2"}
{"project": "qemu", "commit_id": "161c4f20bfbd54f0b77426adccb68ee831678af0", "target": 1, "func": "static void vnc_disconnect_finish(VncState *vs)\n{\n    vnc_qmp_event(vs, QEVENT_VNC_DISCONNECTED);\n    buffer_free(&vs->input);\n    buffer_free(&vs->output);\n    qobject_decref(vs->info);\n#ifdef CONFIG_VNC_TLS\n    vnc_tls_client_cleanup(vs);\n#endif /* CONFIG_VNC_TLS */\n#ifdef CONFIG_VNC_SASL\n    vnc_sasl_client_cleanup(vs);\n#endif /* CONFIG_VNC_SASL */\n    audio_del(vs);\n    QTAILQ_REMOVE(&vs->vd->clients, vs, next);\n    if (QTAILQ_EMPTY(&vs->vd->clients)) {\n        dcl->idle = 1;\n    }\n    qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n    vnc_remove_timer(vs->vd);\n    if (vs->vd->lock_key_sync)\n        qemu_remove_led_event_handler(vs->led);\n    qemu_free(vs);\n}", "idx": 22980, "_split": "test", "_hash": "9f7cab49fb168d5c3f579377550a7d4c"}
{"project": "qemu", "commit_id": "43c5d8f8001eb467abf091c3e2a8aca3d1e5b522", "target": 0, "func": "void qemu_opts_print(QemuOpts *opts)\n\n{\n\n    QemuOpt *opt;\n\n    QemuOptDesc *desc = opts->list->desc;\n\n\n\n    if (desc[0].name == NULL) {\n\n        QTAILQ_FOREACH(opt, &opts->head, next) {\n\n            printf(\"%s=\\\"%s\\\" \", opt->name, opt->str);\n\n        }\n\n        return;\n\n    }\n\n    for (; desc && desc->name; desc++) {\n\n        const char *value;\n\n        QemuOpt *opt = qemu_opt_find(opts, desc->name);\n\n\n\n        value = opt ? opt->str : desc->def_value_str;\n\n        if (!value) {\n\n            continue;\n\n        }\n\n        if (desc->type == QEMU_OPT_STRING) {\n\n            printf(\"%s='%s' \", desc->name, value);\n\n        } else if ((desc->type == QEMU_OPT_SIZE ||\n\n                    desc->type == QEMU_OPT_NUMBER) && opt) {\n\n            printf(\"%s=%\" PRId64 \" \", desc->name, opt->value.uint);\n\n        } else {\n\n            printf(\"%s=%s \", desc->name, value);\n\n        }\n\n    }\n\n}\n", "idx": 22994, "_split": "test", "_hash": "20407c34428bf7f4f7211358ab746121"}
{"project": "qemu", "commit_id": "e3da9921ebc554fad3224a9fdda9a7425ffd9ef7", "target": 0, "func": "static uint32_t nvic_readl(nvic_state *s, uint32_t offset)\n\n{\n\n    ARMCPU *cpu;\n\n    uint32_t val;\n\n    int irq;\n\n\n\n    switch (offset) {\n\n    case 4: /* Interrupt Control Type.  */\n\n        return (s->num_irq / 32) - 1;\n\n    case 0x10: /* SysTick Control and Status.  */\n\n        val = s->systick.control;\n\n        s->systick.control &= ~SYSTICK_COUNTFLAG;\n\n        return val;\n\n    case 0x14: /* SysTick Reload Value.  */\n\n        return s->systick.reload;\n\n    case 0x18: /* SysTick Current Value.  */\n\n        {\n\n            int64_t t;\n\n            if ((s->systick.control & SYSTICK_ENABLE) == 0)\n\n                return 0;\n\n            t = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n            if (t >= s->systick.tick)\n\n                return 0;\n\n            val = ((s->systick.tick - (t + 1)) / systick_scale(s)) + 1;\n\n            /* The interrupt in triggered when the timer reaches zero.\n\n               However the counter is not reloaded until the next clock\n\n               tick.  This is a hack to return zero during the first tick.  */\n\n            if (val > s->systick.reload)\n\n                val = 0;\n\n            return val;\n\n        }\n\n    case 0x1c: /* SysTick Calibration Value.  */\n\n        return 10000;\n\n    case 0xd00: /* CPUID Base.  */\n\n        cpu = ARM_CPU(current_cpu);\n\n        return cpu->env.cp15.c0_cpuid;\n\n    case 0xd04: /* Interrupt Control State.  */\n\n        /* VECTACTIVE */\n\n        val = s->gic.running_irq[0];\n\n        if (val == 1023) {\n\n            val = 0;\n\n        } else if (val >= 32) {\n\n            val -= 16;\n\n        }\n\n        /* RETTOBASE */\n\n        if (s->gic.running_irq[0] == 1023\n\n                || s->gic.last_active[s->gic.running_irq[0]][0] == 1023) {\n\n            val |= (1 << 11);\n\n        }\n\n        /* VECTPENDING */\n\n        if (s->gic.current_pending[0] != 1023)\n\n            val |= (s->gic.current_pending[0] << 12);\n\n        /* ISRPENDING */\n\n        for (irq = 32; irq < s->num_irq; irq++) {\n\n            if (s->gic.irq_state[irq].pending) {\n\n                val |= (1 << 22);\n\n                break;\n\n            }\n\n        }\n\n        /* PENDSTSET */\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SYSTICK].pending)\n\n            val |= (1 << 26);\n\n        /* PENDSVSET */\n\n        if (s->gic.irq_state[ARMV7M_EXCP_PENDSV].pending)\n\n            val |= (1 << 28);\n\n        /* NMIPENDSET */\n\n        if (s->gic.irq_state[ARMV7M_EXCP_NMI].pending)\n\n            val |= (1 << 31);\n\n        return val;\n\n    case 0xd08: /* Vector Table Offset.  */\n\n        cpu = ARM_CPU(current_cpu);\n\n        return cpu->env.v7m.vecbase;\n\n    case 0xd0c: /* Application Interrupt/Reset Control.  */\n\n        return 0xfa05000;\n\n    case 0xd10: /* System Control.  */\n\n        /* TODO: Implement SLEEPONEXIT.  */\n\n        return 0;\n\n    case 0xd14: /* Configuration Control.  */\n\n        /* TODO: Implement Configuration Control bits.  */\n\n        return 0;\n\n    case 0xd24: /* System Handler Status.  */\n\n        val = 0;\n\n        if (s->gic.irq_state[ARMV7M_EXCP_MEM].active) val |= (1 << 0);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_BUS].active) val |= (1 << 1);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].active) val |= (1 << 3);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SVC].active) val |= (1 << 7);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_DEBUG].active) val |= (1 << 8);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_PENDSV].active) val |= (1 << 10);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SYSTICK].active) val |= (1 << 11);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].pending) val |= (1 << 12);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_MEM].pending) val |= (1 << 13);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_BUS].pending) val |= (1 << 14);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SVC].pending) val |= (1 << 15);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_MEM].enabled) val |= (1 << 16);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_BUS].enabled) val |= (1 << 17);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].enabled) val |= (1 << 18);\n\n        return val;\n\n    case 0xd28: /* Configurable Fault Status.  */\n\n        /* TODO: Implement Fault Status.  */\n\n        qemu_log_mask(LOG_UNIMP, \"Configurable Fault Status unimplemented\\n\");\n\n        return 0;\n\n    case 0xd2c: /* Hard Fault Status.  */\n\n    case 0xd30: /* Debug Fault Status.  */\n\n    case 0xd34: /* Mem Manage Address.  */\n\n    case 0xd38: /* Bus Fault Address.  */\n\n    case 0xd3c: /* Aux Fault Status.  */\n\n        /* TODO: Implement fault status registers.  */\n\n        qemu_log_mask(LOG_UNIMP, \"Fault status registers unimplemented\\n\");\n\n        return 0;\n\n    case 0xd40: /* PFR0.  */\n\n        return 0x00000030;\n\n    case 0xd44: /* PRF1.  */\n\n        return 0x00000200;\n\n    case 0xd48: /* DFR0.  */\n\n        return 0x00100000;\n\n    case 0xd4c: /* AFR0.  */\n\n        return 0x00000000;\n\n    case 0xd50: /* MMFR0.  */\n\n        return 0x00000030;\n\n    case 0xd54: /* MMFR1.  */\n\n        return 0x00000000;\n\n    case 0xd58: /* MMFR2.  */\n\n        return 0x00000000;\n\n    case 0xd5c: /* MMFR3.  */\n\n        return 0x00000000;\n\n    case 0xd60: /* ISAR0.  */\n\n        return 0x01141110;\n\n    case 0xd64: /* ISAR1.  */\n\n        return 0x02111000;\n\n    case 0xd68: /* ISAR2.  */\n\n        return 0x21112231;\n\n    case 0xd6c: /* ISAR3.  */\n\n        return 0x01111110;\n\n    case 0xd70: /* ISAR4.  */\n\n        return 0x01310102;\n\n    /* TODO: Implement debug registers.  */\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"NVIC: Bad read offset 0x%x\\n\", offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 23016, "_split": "test", "_hash": "b2f3753a73547cc2c64369526fcd63bd"}
{"project": "qemu", "commit_id": "2f464b5a32b414adb545acc6d94b5c35c7d258ba", "target": 0, "func": "static void qxl_render_update_area_unlocked(PCIQXLDevice *qxl)\n\n{\n\n    VGACommonState *vga = &qxl->vga;\n\n    int i;\n\n\n\n    if (qxl->guest_primary.resized) {\n\n        qxl->guest_primary.resized = 0;\n\n        qxl->guest_primary.data = memory_region_get_ram_ptr(&qxl->vga.vram);\n\n        qxl_set_rect_to_surface(qxl, &qxl->dirty[0]);\n\n        qxl->num_dirty_rects = 1;\n\n        trace_qxl_render_guest_primary_resized(\n\n               qxl->guest_primary.surface.width,\n\n               qxl->guest_primary.surface.height,\n\n               qxl->guest_primary.qxl_stride,\n\n               qxl->guest_primary.bytes_pp,\n\n               qxl->guest_primary.bits_pp);\n\n        if (qxl->guest_primary.qxl_stride > 0) {\n\n            qemu_free_displaysurface(vga->ds);\n\n            qemu_create_displaysurface_from(qxl->guest_primary.surface.width,\n\n                                            qxl->guest_primary.surface.height,\n\n                                            qxl->guest_primary.bits_pp,\n\n                                            qxl->guest_primary.abs_stride,\n\n                                            qxl->guest_primary.data);\n\n        } else {\n\n            qemu_resize_displaysurface(vga->ds,\n\n                    qxl->guest_primary.surface.width,\n\n                    qxl->guest_primary.surface.height);\n\n        }\n\n        dpy_gfx_resize(vga->ds);\n\n    }\n\n    for (i = 0; i < qxl->num_dirty_rects; i++) {\n\n        if (qemu_spice_rect_is_empty(qxl->dirty+i)) {\n\n            break;\n\n        }\n\n        qxl_blit(qxl, qxl->dirty+i);\n\n        dpy_gfx_update(vga->ds,\n\n                       qxl->dirty[i].left, qxl->dirty[i].top,\n\n                       qxl->dirty[i].right - qxl->dirty[i].left,\n\n                       qxl->dirty[i].bottom - qxl->dirty[i].top);\n\n    }\n\n    qxl->num_dirty_rects = 0;\n\n}\n", "idx": 23050, "_split": "test", "_hash": "4de183e84e0c9ce06188b4269b2e1b11"}
{"project": "qemu", "commit_id": "47c16ed56aa6bc4037bdb7b61f049097993cd244", "target": 0, "func": "static void page_init(void)\n\n{\n\n    /* NOTE: we can always suppose that qemu_host_page_size >=\n\n       TARGET_PAGE_SIZE */\n\n#ifdef _WIN32\n\n    {\n\n        SYSTEM_INFO system_info;\n\n\n\n        GetSystemInfo(&system_info);\n\n        qemu_real_host_page_size = system_info.dwPageSize;\n\n    }\n\n#else\n\n    qemu_real_host_page_size = getpagesize();\n\n#endif\n\n    if (qemu_host_page_size == 0) {\n\n        qemu_host_page_size = qemu_real_host_page_size;\n\n    }\n\n    if (qemu_host_page_size < TARGET_PAGE_SIZE) {\n\n        qemu_host_page_size = TARGET_PAGE_SIZE;\n\n    }\n\n    qemu_host_page_mask = ~(qemu_host_page_size - 1);\n\n\n\n#if defined(CONFIG_BSD) && defined(CONFIG_USER_ONLY)\n\n    {\n\n#ifdef HAVE_KINFO_GETVMMAP\n\n        struct kinfo_vmentry *freep;\n\n        int i, cnt;\n\n\n\n        freep = kinfo_getvmmap(getpid(), &cnt);\n\n        if (freep) {\n\n            mmap_lock();\n\n            for (i = 0; i < cnt; i++) {\n\n                unsigned long startaddr, endaddr;\n\n\n\n                startaddr = freep[i].kve_start;\n\n                endaddr = freep[i].kve_end;\n\n                if (h2g_valid(startaddr)) {\n\n                    startaddr = h2g(startaddr) & TARGET_PAGE_MASK;\n\n\n\n                    if (h2g_valid(endaddr)) {\n\n                        endaddr = h2g(endaddr);\n\n                        page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n                    } else {\n\n#if TARGET_ABI_BITS <= L1_MAP_ADDR_SPACE_BITS\n\n                        endaddr = ~0ul;\n\n                        page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n#endif\n\n                    }\n\n                }\n\n            }\n\n            free(freep);\n\n            mmap_unlock();\n\n        }\n\n#else\n\n        FILE *f;\n\n\n\n        last_brk = (unsigned long)sbrk(0);\n\n\n\n        f = fopen(\"/compat/linux/proc/self/maps\", \"r\");\n\n        if (f) {\n\n            mmap_lock();\n\n\n\n            do {\n\n                unsigned long startaddr, endaddr;\n\n                int n;\n\n\n\n                n = fscanf(f, \"%lx-%lx %*[^\\n]\\n\", &startaddr, &endaddr);\n\n\n\n                if (n == 2 && h2g_valid(startaddr)) {\n\n                    startaddr = h2g(startaddr) & TARGET_PAGE_MASK;\n\n\n\n                    if (h2g_valid(endaddr)) {\n\n                        endaddr = h2g(endaddr);\n\n                    } else {\n\n                        endaddr = ~0ul;\n\n                    }\n\n                    page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n                }\n\n            } while (!feof(f));\n\n\n\n            fclose(f);\n\n            mmap_unlock();\n\n        }\n\n#endif\n\n    }\n\n#endif\n\n}\n", "idx": 23052, "_split": "test", "_hash": "fd3358f8c92aa137e9f4d2a2cbbeab68"}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static SocketAddress *tcp_build_address(const char *host_port, Error **errp)\n\n{\n\n    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);\n\n    SocketAddress *saddr;\n\n\n\n    if (inet_parse(iaddr, host_port, errp)) {\n\n        qapi_free_InetSocketAddress(iaddr);\n\n        return NULL;\n\n    }\n\n\n\n    saddr = g_new0(SocketAddress, 1);\n\n    saddr->type = SOCKET_ADDRESS_KIND_INET;\n\n    saddr->u.inet.data = iaddr;\n\n\n\n    return saddr;\n\n}\n", "idx": 23066, "_split": "test", "_hash": "186e72e9715a24356ea30535aed89fa8"}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static void nbd_close(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n\n\n    qemu_opts_del(s->socket_opts);\n\n    nbd_client_session_close(&s->client);\n\n}\n", "idx": 23074, "_split": "test", "_hash": "83043f50436d5797b2927fc18f41f8eb"}
{"project": "qemu", "commit_id": "4f9242fc931ab5e5b1b753c8e5a76c50c0b0612e", "target": 0, "func": "static void reset(DeviceState *d)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n\n\n    trace_spapr_drc_reset(spapr_drc_index(drc));\n\n\n\n    g_free(drc->ccs);\n\n    drc->ccs = NULL;\n\n\n\n    /* immediately upon reset we can safely assume DRCs whose devices\n\n     * are pending removal can be safely removed, and that they will\n\n     * subsequently be left in an ISOLATED state. move the DRC to this\n\n     * state in these cases (which will in turn complete any pending\n\n     * device removals)\n\n     */\n\n    if (drc->awaiting_release) {\n\n        drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_ISOLATED);\n\n        /* generally this should also finalize the removal, but if the device\n\n         * hasn't yet been configured we normally defer removal under the\n\n         * assumption that this transition is taking place as part of device\n\n         * configuration. so check if we're still waiting after this, and\n\n         * force removal if we are\n\n         */\n\n        if (drc->awaiting_release) {\n\n            spapr_drc_detach(drc, DEVICE(drc->dev), NULL);\n\n        }\n\n\n\n        /* non-PCI devices may be awaiting a transition to UNUSABLE */\n\n        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&\n\n            drc->awaiting_release) {\n\n            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_UNUSABLE);\n\n        }\n\n    }\n\n}\n", "idx": 23076, "_split": "test", "_hash": "550b2968bfe2ef6fc01a945425a25341"}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,\n\n                          target_ulong len, int type)\n\n{\n\n    struct kvm_sw_breakpoint *bp;\n\n    CPUState *env;\n\n    int err;\n\n\n\n    if (type == GDB_BREAKPOINT_SW) {\n\n        bp = kvm_find_sw_breakpoint(current_env, addr);\n\n        if (!bp)\n\n            return -ENOENT;\n\n\n\n        if (bp->use_count > 1) {\n\n            bp->use_count--;\n\n            return 0;\n\n        }\n\n\n\n        err = kvm_arch_remove_sw_breakpoint(current_env, bp);\n\n        if (err)\n\n            return err;\n\n\n\n        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);\n\n        qemu_free(bp);\n\n    } else {\n\n        err = kvm_arch_remove_hw_breakpoint(addr, len, type);\n\n        if (err)\n\n            return err;\n\n    }\n\n\n\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n\n        err = kvm_update_guest_debug(env, 0);\n\n        if (err)\n\n            return err;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23088, "_split": "test", "_hash": "9c6c74219883e8a47f82ee1ece0f3131"}
{"project": "qemu", "commit_id": "fea7d77d3ea287d3b1878648f3049fc6bb4fd57b", "target": 0, "func": "void helper_fcmp_gt_DT(CPUSH4State *env, float64 t0, float64 t1)\n\n{\n\n    int relation;\n\n\n\n    set_float_exception_flags(0, &env->fp_status);\n\n    relation = float64_compare(t0, t1, &env->fp_status);\n\n    if (unlikely(relation == float_relation_unordered)) {\n\n        update_fpscr(env, GETPC());\n\n    } else {\n\n        env->sr_t = (relation == float_relation_greater);\n\n    }\n\n}\n", "idx": 23104, "_split": "test", "_hash": "909d61ef8e91577576047b9d281cb900"}
{"project": "qemu", "commit_id": "f0536bb848ad6eb2709a7dc675f261bd160c751b", "target": 0, "func": "static int img_info(int argc, char **argv)\n\n{\n\n    int c;\n\n    OutputFormat output_format = OFORMAT_HUMAN;\n\n    const char *filename, *fmt, *output;\n\n    BlockDriverState *bs;\n\n    ImageInfo *info;\n\n\n\n    fmt = NULL;\n\n    output = NULL;\n\n    for(;;) {\n\n        int option_index = 0;\n\n        static const struct option long_options[] = {\n\n            {\"help\", no_argument, 0, 'h'},\n\n            {\"format\", required_argument, 0, 'f'},\n\n            {\"output\", required_argument, 0, OPTION_OUTPUT},\n\n            {0, 0, 0, 0}\n\n        };\n\n        c = getopt_long(argc, argv, \"f:h\",\n\n                        long_options, &option_index);\n\n        if (c == -1) {\n\n            break;\n\n        }\n\n        switch(c) {\n\n        case '?':\n\n        case 'h':\n\n            help();\n\n            break;\n\n        case 'f':\n\n            fmt = optarg;\n\n            break;\n\n        case OPTION_OUTPUT:\n\n            output = optarg;\n\n            break;\n\n        }\n\n    }\n\n    if (optind >= argc) {\n\n        help();\n\n    }\n\n    filename = argv[optind++];\n\n\n\n    if (output && !strcmp(output, \"json\")) {\n\n        output_format = OFORMAT_JSON;\n\n    } else if (output && !strcmp(output, \"human\")) {\n\n        output_format = OFORMAT_HUMAN;\n\n    } else if (output) {\n\n        error_report(\"--output must be used with human or json as argument.\");\n\n        return 1;\n\n    }\n\n\n\n    bs = bdrv_new_open(filename, fmt, BDRV_O_FLAGS | BDRV_O_NO_BACKING);\n\n    if (!bs) {\n\n        return 1;\n\n    }\n\n\n\n    info = g_new0(ImageInfo, 1);\n\n    collect_image_info(bs, info, filename, fmt);\n\n\n\n    switch (output_format) {\n\n    case OFORMAT_HUMAN:\n\n        dump_human_image_info(info);\n\n        dump_snapshots(bs);\n\n        break;\n\n    case OFORMAT_JSON:\n\n        collect_snapshots(bs, info);\n\n        dump_json_image_info(info);\n\n        break;\n\n    }\n\n\n\n    qapi_free_ImageInfo(info);\n\n    bdrv_delete(bs);\n\n    return 0;\n\n}\n", "idx": 23105, "_split": "test", "_hash": "9270726ab037522d8c9eea3cd23cf22f"}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "int qio_dns_resolver_lookup_sync(QIODNSResolver *resolver,\n\n                                 SocketAddressLegacy *addr,\n\n                                 size_t *naddrs,\n\n                                 SocketAddressLegacy ***addrs,\n\n                                 Error **errp)\n\n{\n\n    switch (addr->type) {\n\n    case SOCKET_ADDRESS_LEGACY_KIND_INET:\n\n        return qio_dns_resolver_lookup_sync_inet(resolver,\n\n                                                 addr,\n\n                                                 naddrs,\n\n                                                 addrs,\n\n                                                 errp);\n\n\n\n    case SOCKET_ADDRESS_LEGACY_KIND_UNIX:\n\n    case SOCKET_ADDRESS_LEGACY_KIND_VSOCK:\n\n    case SOCKET_ADDRESS_LEGACY_KIND_FD:\n\n        return qio_dns_resolver_lookup_sync_nop(resolver,\n\n                                                addr,\n\n                                                naddrs,\n\n                                                addrs,\n\n                                                errp);\n\n\n\n    default:\n\n        abort();\n\n    }\n\n}\n", "idx": 23108, "_split": "test", "_hash": "b7c84dea7ad425a9e8ff69a87064cba4"}
{"project": "qemu", "commit_id": "d85f4222b4681da7ebf8a90b26e085a68fa2c55a", "target": 0, "func": "static coroutine_fn int qcow_co_readv(BlockDriverState *bs, int64_t sector_num,\n\n                         int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    int ret = 0, n;\n\n    uint64_t cluster_offset;\n\n    struct iovec hd_iov;\n\n    QEMUIOVector hd_qiov;\n\n    uint8_t *buf;\n\n    void *orig_buf;\n\n    Error *err = NULL;\n\n\n\n    if (qiov->niov > 1) {\n\n        buf = orig_buf = qemu_try_blockalign(bs, qiov->size);\n\n        if (buf == NULL) {\n\n            return -ENOMEM;\n\n        }\n\n    } else {\n\n        orig_buf = NULL;\n\n        buf = (uint8_t *)qiov->iov->iov_base;\n\n    }\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (nb_sectors != 0) {\n\n        /* prepare next request */\n\n        cluster_offset = get_cluster_offset(bs, sector_num << 9,\n\n                                                 0, 0, 0, 0);\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n = s->cluster_sectors - index_in_cluster;\n\n        if (n > nb_sectors) {\n\n            n = nb_sectors;\n\n        }\n\n\n\n        if (!cluster_offset) {\n\n            if (bs->backing) {\n\n                /* read from the base image */\n\n                hd_iov.iov_base = (void *)buf;\n\n                hd_iov.iov_len = n * 512;\n\n                qemu_iovec_init_external(&hd_qiov, &hd_iov, 1);\n\n                qemu_co_mutex_unlock(&s->lock);\n\n                ret = bdrv_co_readv(bs->backing, sector_num, n, &hd_qiov);\n\n                qemu_co_mutex_lock(&s->lock);\n\n                if (ret < 0) {\n\n                    goto fail;\n\n                }\n\n            } else {\n\n                /* Note: in this case, no need to wait */\n\n                memset(buf, 0, 512 * n);\n\n            }\n\n        } else if (cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n            /* add AIO support for compressed blocks ? */\n\n            if (decompress_cluster(bs, cluster_offset) < 0) {\n\n                goto fail;\n\n            }\n\n            memcpy(buf,\n\n                   s->cluster_cache + index_in_cluster * 512, 512 * n);\n\n        } else {\n\n            if ((cluster_offset & 511) != 0) {\n\n                goto fail;\n\n            }\n\n            hd_iov.iov_base = (void *)buf;\n\n            hd_iov.iov_len = n * 512;\n\n            qemu_iovec_init_external(&hd_qiov, &hd_iov, 1);\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            ret = bdrv_co_readv(bs->file,\n\n                                (cluster_offset >> 9) + index_in_cluster,\n\n                                n, &hd_qiov);\n\n            qemu_co_mutex_lock(&s->lock);\n\n            if (ret < 0) {\n\n                break;\n\n            }\n\n            if (bs->encrypted) {\n\n                assert(s->cipher);\n\n                if (encrypt_sectors(s, sector_num, buf,\n\n                                    n, false, &err) < 0) {\n\n                    goto fail;\n\n                }\n\n            }\n\n        }\n\n        ret = 0;\n\n\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n    }\n\n\n\ndone:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    if (qiov->niov > 1) {\n\n        qemu_iovec_from_buf(qiov, 0, orig_buf, qiov->size);\n\n        qemu_vfree(orig_buf);\n\n    }\n\n\n\n    return ret;\n\n\n\nfail:\n\n    error_free(err);\n\n    ret = -EIO;\n\n    goto done;\n\n}\n", "idx": 23116, "_split": "test", "_hash": "b72b85dc583057099f5065d049f1ce0f"}
{"project": "qemu", "commit_id": "cb2e28780c7080af489e72227683fe374f05022d", "target": 0, "func": "static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child,\n\n        int64_t offset, unsigned int bytes, QEMUIOVector *qiov)\n\n{\n\n    BlockDriverState *bs = child->bs;\n\n\n\n    /* Perform I/O through a temporary buffer so that users who scribble over\n\n     * their read buffer while the operation is in progress do not end up\n\n     * modifying the image file.  This is critical for zero-copy guest I/O\n\n     * where anything might happen inside guest memory.\n\n     */\n\n    void *bounce_buffer;\n\n\n\n    BlockDriver *drv = bs->drv;\n\n    struct iovec iov;\n\n    QEMUIOVector bounce_qiov;\n\n    int64_t cluster_offset;\n\n    unsigned int cluster_bytes;\n\n    size_t skip_bytes;\n\n    int ret;\n\n\n\n    /* FIXME We cannot require callers to have write permissions when all they\n\n     * are doing is a read request. If we did things right, write permissions\n\n     * would be obtained anyway, but internally by the copy-on-read code. As\n\n     * long as it is implemented here rather than in a separate filter driver,\n\n     * the copy-on-read code doesn't have its own BdrvChild, however, for which\n\n     * it could request permissions. Therefore we have to bypass the permission\n\n     * system for the moment. */\n\n    // assert(child->perm & (BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE));\n\n\n\n    /* Cover entire cluster so no additional backing file I/O is required when\n\n     * allocating cluster in the image file.\n\n     */\n\n    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);\n\n\n\n    trace_bdrv_co_do_copy_on_readv(bs, offset, bytes,\n\n                                   cluster_offset, cluster_bytes);\n\n\n\n    iov.iov_len = cluster_bytes;\n\n    iov.iov_base = bounce_buffer = qemu_try_blockalign(bs, iov.iov_len);\n\n    if (bounce_buffer == NULL) {\n\n        ret = -ENOMEM;\n\n        goto err;\n\n    }\n\n\n\n    qemu_iovec_init_external(&bounce_qiov, &iov, 1);\n\n\n\n    ret = bdrv_driver_preadv(bs, cluster_offset, cluster_bytes,\n\n                             &bounce_qiov, 0);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    bdrv_debug_event(bs, BLKDBG_COR_WRITE);\n\n    if (drv->bdrv_co_pwrite_zeroes &&\n\n        buffer_is_zero(bounce_buffer, iov.iov_len)) {\n\n        /* FIXME: Should we (perhaps conditionally) be setting\n\n         * BDRV_REQ_MAY_UNMAP, if it will allow for a sparser copy\n\n         * that still correctly reads as zero? */\n\n        ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, cluster_bytes, 0);\n\n    } else {\n\n        /* This does not change the data on the disk, it is not necessary\n\n         * to flush even in cache=writethrough mode.\n\n         */\n\n        ret = bdrv_driver_pwritev(bs, cluster_offset, cluster_bytes,\n\n                                  &bounce_qiov, 0);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        /* It might be okay to ignore write errors for guest requests.  If this\n\n         * is a deliberate copy-on-read then we don't want to ignore the error.\n\n         * Simply report it in all cases.\n\n         */\n\n        goto err;\n\n    }\n\n\n\n    skip_bytes = offset - cluster_offset;\n\n    qemu_iovec_from_buf(qiov, 0, bounce_buffer + skip_bytes, bytes);\n\n\n\nerr:\n\n    qemu_vfree(bounce_buffer);\n\n    return ret;\n\n}\n", "idx": 23140, "_split": "test", "_hash": "c591059215296825052d7110e1daecb4"}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_ioctl(KVMState *s, int type, ...)\n\n{\n\n    int ret;\n\n    void *arg;\n\n    va_list ap;\n\n\n\n    va_start(ap, type);\n\n    arg = va_arg(ap, void *);\n\n    va_end(ap);\n\n\n\n    ret = ioctl(s->fd, type, arg);\n\n    if (ret == -1)\n\n        ret = -errno;\n\n\n\n    return ret;\n\n}\n", "idx": 23145, "_split": "test", "_hash": "1121e548c887250ee5e742fe7b3bec5b"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t exynos4210_mct_read(void *opaque, target_phys_addr_t offset,\n\n        unsigned size)\n\n{\n\n    Exynos4210MCTState *s = (Exynos4210MCTState *)opaque;\n\n    int index;\n\n    int shift;\n\n    uint64_t count;\n\n    uint32_t value;\n\n    int lt_i;\n\n\n\n    switch (offset) {\n\n\n\n    case MCT_CFG:\n\n        value = s->reg_mct_cfg;\n\n        break;\n\n\n\n    case G_CNT_L: case G_CNT_U:\n\n        shift = 8 * (offset & 0x4);\n\n        count = exynos4210_gfrc_get_count(&s->g_timer);\n\n        value = UINT32_MAX & (count >> shift);\n\n        DPRINTF(\"read FRC=0x%llx\\n\", count);\n\n        break;\n\n\n\n    case G_CNT_WSTAT:\n\n        value = s->g_timer.reg.cnt_wstat;\n\n        break;\n\n\n\n    case G_COMP_L(0): case G_COMP_L(1): case G_COMP_L(2): case G_COMP_L(3):\n\n    case G_COMP_U(0): case G_COMP_U(1): case G_COMP_U(2): case G_COMP_U(3):\n\n    index = GET_G_COMP_IDX(offset);\n\n    shift = 8 * (offset & 0x4);\n\n    value = UINT32_MAX & (s->g_timer.reg.comp[index] >> shift);\n\n    break;\n\n\n\n    case G_TCON:\n\n        value = s->g_timer.reg.tcon;\n\n        break;\n\n\n\n    case G_INT_CSTAT:\n\n        value = s->g_timer.reg.int_cstat;\n\n        break;\n\n\n\n    case G_INT_ENB:\n\n        value = s->g_timer.reg.int_enb;\n\n        break;\n\n        break;\n\n    case G_WSTAT:\n\n        value = s->g_timer.reg.wstat;\n\n        break;\n\n\n\n    case G_COMP0_ADD_INCR: case G_COMP1_ADD_INCR:\n\n    case G_COMP2_ADD_INCR: case G_COMP3_ADD_INCR:\n\n        value = s->g_timer.reg.comp_add_incr[GET_G_COMP_ADD_INCR_IDX(offset)];\n\n        break;\n\n\n\n        /* Local timers */\n\n    case L0_TCNTB: case L0_ICNTB: case L0_FRCNTB:\n\n    case L1_TCNTB: case L1_ICNTB: case L1_FRCNTB:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n        index = GET_L_TIMER_CNT_REG_IDX(offset, lt_i);\n\n        value = s->l_timer[lt_i].reg.cnt[index];\n\n        break;\n\n\n\n    case L0_TCNTO: case L1_TCNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_ltick_cnt_get_cnto(&s->l_timer[lt_i].tick_timer);\n\n        DPRINTF(\"local timer[%d] read TCNTO %x\\n\", lt_i, value);\n\n        break;\n\n\n\n    case L0_ICNTO: case L1_ICNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_ltick_int_get_cnto(&s->l_timer[lt_i].tick_timer);\n\n        DPRINTF(\"local timer[%d] read ICNTO %x\\n\", lt_i, value);\n\n        break;\n\n\n\n    case L0_FRCNTO: case L1_FRCNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_lfrc_get_count(&s->l_timer[lt_i]);\n\n\n\n        break;\n\n\n\n    case L0_TCON: case L1_TCON:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.tcon;\n\n        break;\n\n\n\n    case L0_INT_CSTAT: case L1_INT_CSTAT:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.int_cstat;\n\n        break;\n\n\n\n    case L0_INT_ENB: case L1_INT_ENB:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.int_enb;\n\n        break;\n\n\n\n    case L0_WSTAT: case L1_WSTAT:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.wstat;\n\n        break;\n\n\n\n    default:\n\n        hw_error(\"exynos4210.mct: bad read offset \"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        break;\n\n    }\n\n    return value;\n\n}\n", "idx": 23155, "_split": "test", "_hash": "8592228b30918dada8007eb17e240a30"}
{"project": "qemu", "commit_id": "3a5c76baf312d83cb77c8faa72c5f7a477effed0", "target": 0, "func": "static FWCfgState *bochs_bios_init(void)\n\n{\n\n    FWCfgState *fw_cfg;\n\n    uint8_t *smbios_tables, *smbios_anchor;\n\n    size_t smbios_tables_len, smbios_anchor_len;\n\n    uint64_t *numa_fw_cfg;\n\n    int i, j;\n\n    unsigned int apic_id_limit = pc_apic_id_limit(max_cpus);\n\n\n\n    fw_cfg = fw_cfg_init_io(BIOS_CFG_IOPORT);\n\n    /* FW_CFG_MAX_CPUS is a bit confusing/problematic on x86:\n\n     *\n\n     * SeaBIOS needs FW_CFG_MAX_CPUS for CPU hotplug, but the CPU hotplug\n\n     * QEMU<->SeaBIOS interface is not based on the \"CPU index\", but on the APIC\n\n     * ID of hotplugged CPUs[1]. This means that FW_CFG_MAX_CPUS is not the\n\n     * \"maximum number of CPUs\", but the \"limit to the APIC ID values SeaBIOS\n\n     * may see\".\n\n     *\n\n     * So, this means we must not use max_cpus, here, but the maximum possible\n\n     * APIC ID value, plus one.\n\n     *\n\n     * [1] The only kind of \"CPU identifier\" used between SeaBIOS and QEMU is\n\n     *     the APIC ID, not the \"CPU index\"\n\n     */\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, (uint16_t)apic_id_limit);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_ACPI_TABLES,\n\n                     acpi_tables, acpi_tables_len);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_IRQ0_OVERRIDE, kvm_allows_irq0_override());\n\n\n\n    smbios_tables = smbios_get_table_legacy(&smbios_tables_len);\n\n    if (smbios_tables) {\n\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_SMBIOS_ENTRIES,\n\n                         smbios_tables, smbios_tables_len);\n\n    }\n\n\n\n    smbios_get_tables(&smbios_tables, &smbios_tables_len,\n\n                      &smbios_anchor, &smbios_anchor_len);\n\n    if (smbios_anchor) {\n\n        fw_cfg_add_file(fw_cfg, \"etc/smbios/smbios-tables\",\n\n                        smbios_tables, smbios_tables_len);\n\n        fw_cfg_add_file(fw_cfg, \"etc/smbios/smbios-anchor\",\n\n                        smbios_anchor, smbios_anchor_len);\n\n    }\n\n\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_E820_TABLE,\n\n                     &e820_reserve, sizeof(e820_reserve));\n\n    fw_cfg_add_file(fw_cfg, \"etc/e820\", e820_table,\n\n                    sizeof(struct e820_entry) * e820_entries);\n\n\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_HPET, &hpet_cfg, sizeof(hpet_cfg));\n\n    /* allocate memory for the NUMA channel: one (64bit) word for the number\n\n     * of nodes, one word for each VCPU->node and one word for each node to\n\n     * hold the amount of memory.\n\n     */\n\n    numa_fw_cfg = g_new0(uint64_t, 1 + apic_id_limit + nb_numa_nodes);\n\n    numa_fw_cfg[0] = cpu_to_le64(nb_numa_nodes);\n\n    for (i = 0; i < max_cpus; i++) {\n\n        unsigned int apic_id = x86_cpu_apic_id_from_index(i);\n\n        assert(apic_id < apic_id_limit);\n\n        for (j = 0; j < nb_numa_nodes; j++) {\n\n            if (test_bit(i, numa_info[j].node_cpu)) {\n\n                numa_fw_cfg[apic_id + 1] = cpu_to_le64(j);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    for (i = 0; i < nb_numa_nodes; i++) {\n\n        numa_fw_cfg[apic_id_limit + 1 + i] = cpu_to_le64(numa_info[i].node_mem);\n\n    }\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_NUMA, numa_fw_cfg,\n\n                     (1 + apic_id_limit + nb_numa_nodes) *\n\n                     sizeof(*numa_fw_cfg));\n\n\n\n    return fw_cfg;\n\n}\n", "idx": 23163, "_split": "test", "_hash": "113ee04e927fde622bfb226bf07277b0"}
{"project": "qemu", "commit_id": "e3e09d87c6e69c2da684d5aacabe3124ebcb6f8e", "target": 0, "func": "int mmu_translate(CPUS390XState *env, target_ulong vaddr, int rw, uint64_t asc,\n\n                  target_ulong *raddr, int *flags)\n\n{\n\n    int r = -1;\n\n    uint8_t *sk;\n\n\n\n    *flags = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n    vaddr &= TARGET_PAGE_MASK;\n\n\n\n    if (!(env->psw.mask & PSW_MASK_DAT)) {\n\n        *raddr = vaddr;\n\n        r = 0;\n\n        goto out;\n\n    }\n\n\n\n    switch (asc) {\n\n    case PSW_ASC_PRIMARY:\n\n    case PSW_ASC_HOME:\n\n        r = mmu_translate_asc(env, vaddr, asc, raddr, flags, rw);\n\n        break;\n\n    case PSW_ASC_SECONDARY:\n\n        /*\n\n         * Instruction: Primary\n\n         * Data: Secondary\n\n         */\n\n        if (rw == 2) {\n\n            r = mmu_translate_asc(env, vaddr, PSW_ASC_PRIMARY, raddr, flags,\n\n                                  rw);\n\n            *flags &= ~(PAGE_READ | PAGE_WRITE);\n\n        } else {\n\n            r = mmu_translate_asc(env, vaddr, PSW_ASC_SECONDARY, raddr, flags,\n\n                                  rw);\n\n            *flags &= ~(PAGE_EXEC);\n\n        }\n\n        break;\n\n    case PSW_ASC_ACCREG:\n\n    default:\n\n        hw_error(\"guest switched to unknown asc mode\\n\");\n\n        break;\n\n    }\n\n\n\n out:\n\n    /* Convert real address -> absolute address */\n\n    *raddr = mmu_real2abs(env, *raddr);\n\n\n\n    if (*raddr <= ram_size) {\n\n        sk = &env->storage_keys[*raddr / TARGET_PAGE_SIZE];\n\n        if (*flags & PAGE_READ) {\n\n            *sk |= SK_R;\n\n        }\n\n\n\n        if (*flags & PAGE_WRITE) {\n\n            *sk |= SK_C;\n\n        }\n\n    }\n\n\n\n    return r;\n\n}\n", "idx": 23174, "_split": "test", "_hash": "55edc4de499f81be5cd81cf535943f4e"}
{"project": "qemu", "commit_id": "faab207f115cf9738f110cb088ab35a4b7aef73a", "target": 1, "func": "static int local_opendir(FsContext *ctx,\n\n                         V9fsPath *fs_path, V9fsFidOpenState *fs)\n\n{\n\n    int dirfd;\n\n    DIR *stream;\n\n\n\n    dirfd = local_opendir_nofollow(ctx, fs_path->data);\n\n    if (dirfd == -1) {\n\n        return -1;\n\n    }\n\n\n\n    stream = fdopendir(dirfd);\n\n    if (!stream) {\n\n\n        return -1;\n\n    }\n\n    fs->dir.stream = stream;\n\n    return 0;\n\n}", "idx": 23186, "_split": "test", "_hash": "d4a70692ea387663548f775c2792391d"}
{"project": "qemu", "commit_id": "25d943b95703ae45567395db4156b25052ee54c4", "target": 1, "func": "get_net_error_message(gint error)\n\n{\n\n    HMODULE module = NULL;\n\n    gchar *retval = NULL;\n\n    wchar_t *msg = NULL;\n\n    int flags;\n\n    size_t nchars;\n\n\n\n    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |\n\n        FORMAT_MESSAGE_IGNORE_INSERTS |\n\n        FORMAT_MESSAGE_FROM_SYSTEM;\n\n\n\n    if (error >= NERR_BASE && error <= MAX_NERR) {\n\n        module = LoadLibraryExW(L\"netmsg.dll\", NULL, LOAD_LIBRARY_AS_DATAFILE);\n\n\n\n        if (module != NULL) {\n\n            flags |= FORMAT_MESSAGE_FROM_HMODULE;\n\n        }\n\n    }\n\n\n\n    FormatMessageW(flags, module, error, 0, (LPWSTR)&msg, 0, NULL);\n\n\n\n    if (msg != NULL) {\n\n        nchars = wcslen(msg);\n\n\n\n        if (nchars > 2 &&\n\n            msg[nchars - 1] == L'\\n' &&\n\n            msg[nchars - 2] == L'\\r') {\n\n            msg[nchars - 2] = L'\\0';\n\n        }\n\n\n\n        retval = g_utf16_to_utf8(msg, -1, NULL, NULL, NULL);\n\n\n\n        LocalFree(msg);\n\n    }\n\n\n\n    if (module != NULL) {\n\n        FreeLibrary(module);\n\n    }\n\n\n\n    return retval;\n\n}\n", "idx": 23213, "_split": "test", "_hash": "32dfc2b1be10b06b83a9615b48bfe2cd"}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void kqemu_record_flush(void)\n\n{\n\n    PCRecord *r, *r_next;\n\n    int h;\n\n\n\n    for(h = 0; h < PC_REC_HASH_SIZE; h++) {\n\n        for(r = pc_rec_hash[h]; r != NULL; r = r_next) {\n\n            r_next = r->next;\n\n            free(r);\n\n        }\n\n        pc_rec_hash[h] = NULL;\n\n    }\n\n    nb_pc_records = 0;\n\n}\n", "idx": 23237, "_split": "test", "_hash": "c1a85a47146f1f1d571ad4f74eb18ebf"}
{"project": "qemu", "commit_id": "e1123a3b40a1a9a625a29c8ed4debb7e206ea690", "target": 0, "func": "static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,\n\n                                    int nb_sectors)\n\n{\n\n    int64_t cluster_num, nb_clusters;\n\n    if (iscsilun->allocationmap == NULL) {\n\n        return;\n\n    }\n\n    cluster_num = sector_num / iscsilun->cluster_sectors;\n\n    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,\n\n                               iscsilun->cluster_sectors) - cluster_num;\n\n    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);\n\n}\n", "idx": 23244, "_split": "test", "_hash": "54e803cbc0e1b8b36f211d6a1740d6cd"}
{"project": "qemu", "commit_id": "e511b4d783c47a32420da802104cfb0eb974b22f", "target": 0, "func": "int cpu_exec(CPUArchState *env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n#ifdef TARGET_I386\n\n    X86CPU *x86_cpu = X86_CPU(cpu);\n\n#endif\n\n    int ret, interrupt_request;\n\n    TranslationBlock *tb;\n\n    uint8_t *tc_ptr;\n\n    uintptr_t next_tb;\n\n    SyncClocks sc;\n\n\n\n    /* This must be volatile so it is not trashed by longjmp() */\n\n    volatile bool have_tb_lock = false;\n\n\n\n    if (cpu->halted) {\n\n        if (!cpu_has_work(cpu)) {\n\n            return EXCP_HALTED;\n\n        }\n\n\n\n        cpu->halted = 0;\n\n    }\n\n\n\n    current_cpu = cpu;\n\n\n\n    /* As long as current_cpu is null, up to the assignment just above,\n\n     * requests by other threads to exit the execution loop are expected to\n\n     * be issued using the exit_request global. We must make sure that our\n\n     * evaluation of the global value is performed past the current_cpu\n\n     * value transition point, which requires a memory barrier as well as\n\n     * an instruction scheduling constraint on modern architectures.  */\n\n    smp_mb();\n\n\n\n    if (unlikely(exit_request)) {\n\n        cpu->exit_request = 1;\n\n    }\n\n\n\n    cc->cpu_exec_enter(cpu);\n\n    cpu->exception_index = -1;\n\n\n\n    /* Calculate difference between guest clock and host clock.\n\n     * This delay includes the delay of the last cycle, so\n\n     * what we have to do is sleep until it is 0. As for the\n\n     * advance/delay we gain here, we try to fix it next time.\n\n     */\n\n    init_delay_params(&sc, cpu);\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    for(;;) {\n\n        if (sigsetjmp(cpu->jmp_env, 0) == 0) {\n\n            /* if an exception is pending, we execute it here */\n\n            if (cpu->exception_index >= 0) {\n\n                if (cpu->exception_index >= EXCP_INTERRUPT) {\n\n                    /* exit request from the cpu execution loop */\n\n                    ret = cpu->exception_index;\n\n                    if (ret == EXCP_DEBUG) {\n\n                        cpu_handle_debug_exception(env);\n\n                    }\n\n                    break;\n\n                } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n                    /* if user mode only, we simulate a fake exception\n\n                       which will be handled outside the cpu execution\n\n                       loop */\n\n#if defined(TARGET_I386)\n\n                    cc->do_interrupt(cpu);\n\n#endif\n\n                    ret = cpu->exception_index;\n\n                    break;\n\n#else\n\n                    cc->do_interrupt(cpu);\n\n                    cpu->exception_index = -1;\n\n#endif\n\n                }\n\n            }\n\n\n\n            next_tb = 0; /* force lookup of first TB */\n\n            for(;;) {\n\n                interrupt_request = cpu->interrupt_request;\n\n                if (unlikely(interrupt_request)) {\n\n                    if (unlikely(cpu->singlestep_enabled & SSTEP_NOIRQ)) {\n\n                        /* Mask out external interrupts for this step. */\n\n                        interrupt_request &= ~CPU_INTERRUPT_SSTEP_MASK;\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_DEBUG) {\n\n                        cpu->interrupt_request &= ~CPU_INTERRUPT_DEBUG;\n\n                        cpu->exception_index = EXCP_DEBUG;\n\n                        cpu_loop_exit(cpu);\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_HALT) {\n\n                        cpu->interrupt_request &= ~CPU_INTERRUPT_HALT;\n\n                        cpu->halted = 1;\n\n                        cpu->exception_index = EXCP_HLT;\n\n                        cpu_loop_exit(cpu);\n\n                    }\n\n#if defined(TARGET_I386)\n\n                    if (interrupt_request & CPU_INTERRUPT_INIT) {\n\n                        cpu_svm_check_intercept_param(env, SVM_EXIT_INIT, 0);\n\n                        do_cpu_init(x86_cpu);\n\n                        cpu->exception_index = EXCP_HALTED;\n\n                        cpu_loop_exit(cpu);\n\n                    }\n\n#else\n\n                    if (interrupt_request & CPU_INTERRUPT_RESET) {\n\n                        cpu_reset(cpu);\n\n                    }\n\n#endif\n\n                    /* The target hook has 3 exit conditions:\n\n                       False when the interrupt isn't processed,\n\n                       True when it is, and we should restart on a new TB,\n\n                       and via longjmp via cpu_loop_exit.  */\n\n                    if (cc->cpu_exec_interrupt(cpu, interrupt_request)) {\n\n                        next_tb = 0;\n\n                    }\n\n                    /* Don't use the cached interrupt_request value,\n\n                       do_interrupt may have updated the EXITTB flag. */\n\n                    if (cpu->interrupt_request & CPU_INTERRUPT_EXITTB) {\n\n                        cpu->interrupt_request &= ~CPU_INTERRUPT_EXITTB;\n\n                        /* ensure that no TB jump will be modified as\n\n                           the program flow was changed */\n\n                        next_tb = 0;\n\n                    }\n\n                }\n\n                if (unlikely(cpu->exit_request)) {\n\n                    cpu->exit_request = 0;\n\n                    cpu->exception_index = EXCP_INTERRUPT;\n\n                    cpu_loop_exit(cpu);\n\n                }\n\n                spin_lock(&tcg_ctx.tb_ctx.tb_lock);\n\n                have_tb_lock = true;\n\n                tb = tb_find_fast(env);\n\n                /* Note: we do it here to avoid a gcc bug on Mac OS X when\n\n                   doing it in tb_find_slow */\n\n                if (tcg_ctx.tb_ctx.tb_invalidated_flag) {\n\n                    /* as some TB could have been invalidated because\n\n                       of memory exceptions while generating the code, we\n\n                       must recompute the hash index here */\n\n                    next_tb = 0;\n\n                    tcg_ctx.tb_ctx.tb_invalidated_flag = 0;\n\n                }\n\n                if (qemu_loglevel_mask(CPU_LOG_EXEC)) {\n\n                    qemu_log(\"Trace %p [\" TARGET_FMT_lx \"] %s\\n\",\n\n                             tb->tc_ptr, tb->pc, lookup_symbol(tb->pc));\n\n                }\n\n                /* see if we can patch the calling TB. When the TB\n\n                   spans two pages, we cannot safely do a direct\n\n                   jump. */\n\n                if (next_tb != 0 && tb->page_addr[1] == -1) {\n\n                    tb_add_jump((TranslationBlock *)(next_tb & ~TB_EXIT_MASK),\n\n                                next_tb & TB_EXIT_MASK, tb);\n\n                }\n\n                have_tb_lock = false;\n\n                spin_unlock(&tcg_ctx.tb_ctx.tb_lock);\n\n\n\n                /* cpu_interrupt might be called while translating the\n\n                   TB, but before it is linked into a potentially\n\n                   infinite loop and becomes env->current_tb. Avoid\n\n                   starting execution if there is a pending interrupt. */\n\n                cpu->current_tb = tb;\n\n                barrier();\n\n                if (likely(!cpu->exit_request)) {\n\n                    trace_exec_tb(tb, tb->pc);\n\n                    tc_ptr = tb->tc_ptr;\n\n                    /* execute the generated code */\n\n                    next_tb = cpu_tb_exec(cpu, tc_ptr);\n\n                    switch (next_tb & TB_EXIT_MASK) {\n\n                    case TB_EXIT_REQUESTED:\n\n                        /* Something asked us to stop executing\n\n                         * chained TBs; just continue round the main\n\n                         * loop. Whatever requested the exit will also\n\n                         * have set something else (eg exit_request or\n\n                         * interrupt_request) which we will handle\n\n                         * next time around the loop.\n\n                         */\n\n                        tb = (TranslationBlock *)(next_tb & ~TB_EXIT_MASK);\n\n                        next_tb = 0;\n\n                        break;\n\n                    case TB_EXIT_ICOUNT_EXPIRED:\n\n                    {\n\n                        /* Instruction counter expired.  */\n\n                        int insns_left;\n\n                        tb = (TranslationBlock *)(next_tb & ~TB_EXIT_MASK);\n\n                        insns_left = cpu->icount_decr.u32;\n\n                        if (cpu->icount_extra && insns_left >= 0) {\n\n                            /* Refill decrementer and continue execution.  */\n\n                            cpu->icount_extra += insns_left;\n\n                            if (cpu->icount_extra > 0xffff) {\n\n                                insns_left = 0xffff;\n\n                            } else {\n\n                                insns_left = cpu->icount_extra;\n\n                            }\n\n                            cpu->icount_extra -= insns_left;\n\n                            cpu->icount_decr.u16.low = insns_left;\n\n                        } else {\n\n                            if (insns_left > 0) {\n\n                                /* Execute remaining instructions.  */\n\n                                cpu_exec_nocache(env, insns_left, tb);\n\n                                align_clocks(&sc, cpu);\n\n                            }\n\n                            cpu->exception_index = EXCP_INTERRUPT;\n\n                            next_tb = 0;\n\n                            cpu_loop_exit(cpu);\n\n                        }\n\n                        break;\n\n                    }\n\n                    default:\n\n                        break;\n\n                    }\n\n                }\n\n                cpu->current_tb = NULL;\n\n                /* Try to align the host and virtual clocks\n\n                   if the guest is in advance */\n\n                align_clocks(&sc, cpu);\n\n                /* reset soft MMU for next block (it can currently\n\n                   only be set by a memory fault) */\n\n            } /* for(;;) */\n\n        } else {\n\n            /* Reload env after longjmp - the compiler may have smashed all\n\n             * local variables as longjmp is marked 'noreturn'. */\n\n            cpu = current_cpu;\n\n            env = cpu->env_ptr;\n\n            cc = CPU_GET_CLASS(cpu);\n\n#ifdef TARGET_I386\n\n            x86_cpu = X86_CPU(cpu);\n\n#endif\n\n            if (have_tb_lock) {\n\n                spin_unlock(&tcg_ctx.tb_ctx.tb_lock);\n\n                have_tb_lock = false;\n\n            }\n\n        }\n\n    } /* for(;;) */\n\n\n\n    cc->cpu_exec_exit(cpu);\n\n\n\n    /* fail safe : never use current_cpu outside cpu_exec() */\n\n    current_cpu = NULL;\n\n    return ret;\n\n}\n", "idx": 23245, "_split": "test", "_hash": "00e3f3dfa0065f3d70c38f128fd1905d"}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static void test_qemu_strtosz_metric(void)\n\n{\n\n    const char *str = \"12345k\";\n\n    char *endptr = NULL;\n\n    int64_t res;\n\n\n\n    res = qemu_strtosz_metric(str, &endptr);\n\n    g_assert_cmpint(res, ==, 12345000);\n\n    g_assert(endptr == str + 6);\n\n}\n", "idx": 23247, "_split": "test", "_hash": "6ca2b8439fed78d8f211d2ec09affbf1"}
{"project": "qemu", "commit_id": "9366f4186025e1d8fc3bebd41fb714521c170b6f", "target": 1, "func": "int register_savevm(const char *idstr,\n\n                    int instance_id,\n\n                    int version_id,\n\n                    SaveStateHandler *save_state,\n\n                    LoadStateHandler *load_state,\n\n                    void *opaque)\n\n{\n\n    SaveStateEntry *se, **pse;\n\n\n\n    se = qemu_malloc(sizeof(SaveStateEntry));\n\n    if (!se)\n\n        return -1;\n\n    pstrcpy(se->idstr, sizeof(se->idstr), idstr);\n\n    se->instance_id = (instance_id == -1) ? 0 : instance_id;\n\n    se->version_id = version_id;\n\n    se->save_state = save_state;\n\n    se->load_state = load_state;\n\n    se->opaque = opaque;\n\n    se->next = NULL;\n\n\n\n    /* add at the end of list */\n\n    pse = &first_se;\n\n    while (*pse != NULL) {\n\n        if (instance_id == -1\n\n                && strcmp(se->idstr, (*pse)->idstr) == 0\n\n                && se->instance_id <= (*pse)->instance_id)\n\n            se->instance_id = (*pse)->instance_id + 1;\n\n        pse = &(*pse)->next;\n\n    }\n\n    *pse = se;\n\n    return 0;\n\n}\n", "idx": 23274, "_split": "test", "_hash": "80ce65224717b02fd90c4480a84b9fbb"}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void arm_mptimer_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = arm_mptimer_realize;\n\n    dc->vmsd = &vmstate_arm_mptimer;\n\n    dc->reset = arm_mptimer_reset;\n\n    dc->no_user = 1;\n\n    dc->props = arm_mptimer_properties;\n\n}\n", "idx": 23277, "_split": "test", "_hash": "9f6e31849962c2f701473e25ff205968"}
{"project": "qemu", "commit_id": "a2d4e44b485222a8972ea9e555b148148c655bb9", "target": 1, "func": "void pci_default_write_config(PCIDevice *d, \n\n                              uint32_t address, uint32_t val, int len)\n\n{\n\n    int can_write, i;\n\n    uint32_t end, addr;\n\n\n\n    if (len == 4 && ((address >= 0x10 && address < 0x10 + 4 * 6) || \n\n                     (address >= 0x30 && address < 0x34))) {\n\n        PCIIORegion *r;\n\n        int reg;\n\n\n\n        if ( address >= 0x30 ) {\n\n            reg = PCI_ROM_SLOT;\n\n        }else{\n\n            reg = (address - 0x10) >> 2;\n\n        }\n\n        r = &d->io_regions[reg];\n\n        if (r->size == 0)\n\n            goto default_config;\n\n        /* compute the stored value */\n\n        if (reg == PCI_ROM_SLOT) {\n\n            /* keep ROM enable bit */\n\n            val &= (~(r->size - 1)) | 1;\n\n        } else {\n\n            val &= ~(r->size - 1);\n\n            val |= r->type;\n\n        }\n\n        *(uint32_t *)(d->config + address) = cpu_to_le32(val);\n\n        pci_update_mappings(d);\n\n        return;\n\n    }\n\n default_config:\n\n    /* not efficient, but simple */\n\n    addr = address;\n\n    for(i = 0; i < len; i++) {\n\n        /* default read/write accesses */\n\n        switch(d->config[0x0e]) {\n\n        case 0x00:\n\n        case 0x80:\n\n            switch(addr) {\n\n            case 0x00:\n\n            case 0x01:\n\n            case 0x02:\n\n            case 0x03:\n\n            case 0x08:\n\n            case 0x09:\n\n            case 0x0a:\n\n            case 0x0b:\n\n            case 0x0e:\n\n            case 0x10 ... 0x27: /* base */\n\n            case 0x30 ... 0x33: /* rom */\n\n            case 0x3d:\n\n                can_write = 0;\n\n                break;\n\n            default:\n\n                can_write = 1;\n\n                break;\n\n            }\n\n            break;\n\n        default:\n\n        case 0x01:\n\n            switch(addr) {\n\n            case 0x00:\n\n            case 0x01:\n\n            case 0x02:\n\n            case 0x03:\n\n            case 0x08:\n\n            case 0x09:\n\n            case 0x0a:\n\n            case 0x0b:\n\n            case 0x0e:\n\n            case 0x38 ... 0x3b: /* rom */\n\n            case 0x3d:\n\n                can_write = 0;\n\n                break;\n\n            default:\n\n                can_write = 1;\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n        if (can_write) {\n\n            d->config[addr] = val;\n\n        }\n\n        addr++;\n\n        val >>= 8;\n\n    }\n\n\n\n    end = address + len;\n\n    if (end > PCI_COMMAND && address < (PCI_COMMAND + 2)) {\n\n        /* if the command register is modified, we must modify the mappings */\n\n        pci_update_mappings(d);\n\n    }\n\n}\n", "idx": 23307, "_split": "test", "_hash": "89c1356d9eb22d6afc65b1df6cd9295b"}
{"project": "qemu", "commit_id": "fc40787abcf8452b8f50d92b7a13243a12972c7a", "target": 1, "func": "target_ulong helper_ldl(CPUMIPSState *env, target_ulong arg1,\n\n                        target_ulong arg2, int mem_idx)\n\n{\n\n    uint64_t tmp;\n\n\n\n    tmp = do_lbu(env, arg2, mem_idx);\n\n    arg1 = (arg1 & 0x00FFFFFFFFFFFFFFULL) | (tmp << 56);\n\n\n\n    if (GET_LMASK64(arg2) <= 6) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 1), mem_idx);\n\n        arg1 = (arg1 & 0xFF00FFFFFFFFFFFFULL) | (tmp << 48);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 5) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 2), mem_idx);\n\n        arg1 = (arg1 & 0xFFFF00FFFFFFFFFFULL) | (tmp << 40);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 4) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 3), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFF00FFFFFFFFULL) | (tmp << 32);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 3) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 4), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFF00FFFFFFULL) | (tmp << 24);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 2) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 5), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFF00FFFFULL) | (tmp << 16);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 1) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 6), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFFFF00FFULL) | (tmp << 8);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) == 0) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 7), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFFFFFF00ULL) | tmp;\n\n    }\n\n\n\n    return arg1;\n\n}\n", "idx": 23339, "_split": "test", "_hash": "51d07adeca0806d901f15ad9885cd3fc"}
{"project": "qemu", "commit_id": "dc8764f06155a7b3e635e02281b747a9e292127e", "target": 1, "func": "static void child_handler(int sig)\n\n{\n\n    int status;\n\n    while (waitpid(-1, &status, WNOHANG) > 0) /* NOTHING */;\n\n}\n", "idx": 23354, "_split": "test", "_hash": "6beb7b440c3de9382694f6f59c9ddce9"}
{"project": "qemu", "commit_id": "203d65a4706be345c209f3408d3a011a3e48f0c9", "target": 0, "func": "static void imx_epit_reset(DeviceState *dev)\n\n{\n\n    IMXEPITState *s = IMX_EPIT(dev);\n\n\n\n    /*\n\n     * Soft reset doesn't touch some bits; hard reset clears them\n\n     */\n\n    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);\n\n    s->sr = 0;\n\n    s->lr = TIMER_MAX;\n\n    s->cmp = 0;\n\n    s->cnt = 0;\n\n    /* stop both timers */\n\n    ptimer_stop(s->timer_cmp);\n\n    ptimer_stop(s->timer_reload);\n\n    /* compute new frequency */\n\n    imx_epit_set_freq(s);\n\n    /* init both timers to TIMER_MAX */\n\n    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);\n\n    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);\n\n    if (s->freq && (s->cr & CR_EN)) {\n\n        /* if the timer is still enabled, restart it */\n\n        ptimer_run(s->timer_reload, 0);\n\n    }\n\n}\n", "idx": 23371, "_split": "test", "_hash": "da0cdd70c9d29c81754ddd85728af3be"}
{"project": "qemu", "commit_id": "1828be316f6637d43dd4c4f5f32925b17fb8107f", "target": 0, "func": "static void quit_timers(void)\n\n{\n\n    alarm_timer->stop(alarm_timer);\n\n    alarm_timer = NULL;\n\n}\n", "idx": 23374, "_split": "test", "_hash": "9335413bb816c2fc741920302f55a725"}
{"project": "qemu", "commit_id": "d470ad42acfc73c45d3e8ed5311a491160b4c100", "target": 1, "func": "static int coroutine_fn bdrv_aligned_pwritev(BdrvChild *child,\n    BdrvTrackedRequest *req, int64_t offset, unsigned int bytes,\n    int64_t align, QEMUIOVector *qiov, int flags)\n{\n    BlockDriverState *bs = child->bs;\n    BlockDriver *drv = bs->drv;\n    bool waited;\n    int ret;\n    int64_t end_sector = DIV_ROUND_UP(offset + bytes, BDRV_SECTOR_SIZE);\n    uint64_t bytes_remaining = bytes;\n    int max_transfer;\n    if (bdrv_has_readonly_bitmaps(bs)) {\n        return -EPERM;\n    assert(is_power_of_2(align));\n    assert((offset & (align - 1)) == 0);\n    assert((bytes & (align - 1)) == 0);\n    assert(!qiov || bytes == qiov->size);\n    assert((bs->open_flags & BDRV_O_NO_IO) == 0);\n    assert(!(flags & ~BDRV_REQ_MASK));\n    max_transfer = QEMU_ALIGN_DOWN(MIN_NON_ZERO(bs->bl.max_transfer, INT_MAX),\n                                   align);\n    waited = wait_serialising_requests(req);\n    assert(!waited || !req->serialising);\n    assert(req->overlap_offset <= offset);\n    assert(offset + bytes <= req->overlap_offset + req->overlap_bytes);\n    assert(child->perm & BLK_PERM_WRITE);\n    assert(end_sector <= bs->total_sectors || child->perm & BLK_PERM_RESIZE);\n    ret = notifier_with_return_list_notify(&bs->before_write_notifiers, req);\n    if (!ret && bs->detect_zeroes != BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF &&\n        !(flags & BDRV_REQ_ZERO_WRITE) && drv->bdrv_co_pwrite_zeroes &&\n        qemu_iovec_is_zero(qiov)) {\n        flags |= BDRV_REQ_ZERO_WRITE;\n        if (bs->detect_zeroes == BLOCKDEV_DETECT_ZEROES_OPTIONS_UNMAP) {\n            flags |= BDRV_REQ_MAY_UNMAP;\n    if (ret < 0) {\n        /* Do nothing, write notifier decided to fail this request */\n    } else if (flags & BDRV_REQ_ZERO_WRITE) {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV_ZERO);\n        ret = bdrv_co_do_pwrite_zeroes(bs, offset, bytes, flags);\n    } else if (flags & BDRV_REQ_WRITE_COMPRESSED) {\n        ret = bdrv_driver_pwritev_compressed(bs, offset, bytes, qiov);\n    } else if (bytes <= max_transfer) {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV);\n        ret = bdrv_driver_pwritev(bs, offset, bytes, qiov, flags);\n    } else {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV);\n        while (bytes_remaining) {\n            int num = MIN(bytes_remaining, max_transfer);\n            QEMUIOVector local_qiov;\n            int local_flags = flags;\n            assert(num);\n            if (num < bytes_remaining && (flags & BDRV_REQ_FUA) &&\n                !(bs->supported_write_flags & BDRV_REQ_FUA)) {\n                /* If FUA is going to be emulated by flush, we only\n                 * need to flush on the last iteration */\n                local_flags &= ~BDRV_REQ_FUA;\n            qemu_iovec_init(&local_qiov, qiov->niov);\n            qemu_iovec_concat(&local_qiov, qiov, bytes - bytes_remaining, num);\n            ret = bdrv_driver_pwritev(bs, offset + bytes - bytes_remaining,\n                                      num, &local_qiov, local_flags);\n            qemu_iovec_destroy(&local_qiov);\n            if (ret < 0) {\n                break;\n            bytes_remaining -= num;\n    bdrv_debug_event(bs, BLKDBG_PWRITEV_DONE);\n    atomic_inc(&bs->write_gen);\n    bdrv_set_dirty(bs, offset, bytes);\n    stat64_max(&bs->wr_highest_offset, offset + bytes);\n    if (ret >= 0) {\n        bs->total_sectors = MAX(bs->total_sectors, end_sector);\n        ret = 0;\n    return ret;", "idx": 23386, "_split": "test", "_hash": "ca770dbbdb16ea16da28f85913842bdb"}
{"project": "qemu", "commit_id": "3c529d935923a70519557d420db1d5a09a65086a", "target": 0, "func": "static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,\n\n        int64_t sector_num, uint8_t *buf, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    RawAIOCB *acb;\n\n\n\n    /*\n\n     * If O_DIRECT is used and the buffer is not aligned fall back\n\n     * to synchronous IO.\n\n     */\n\n    BDRVRawState *s = bs->opaque;\n\n\n\n    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {\n\n        QEMUBH *bh;\n\n        acb = qemu_aio_get(bs, cb, opaque);\n\n        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);\n\n        bh = qemu_bh_new(raw_aio_em_cb, acb);\n\n        qemu_bh_schedule(bh);\n\n        return &acb->common;\n\n    }\n\n\n\n    acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    if (aio_read(&acb->aiocb) < 0) {\n\n        qemu_aio_release(acb);\n\n        return NULL;\n\n    }\n\n    return &acb->common;\n\n}\n", "idx": 23393, "_split": "test", "_hash": "caa1c6aa53021cc2e04169ced7c6d7bf"}
{"project": "qemu", "commit_id": "a03ef88f77af045a2eb9629b5ce774a3fb973c5e", "target": 0, "func": "static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,\n\n    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,\n\n    BdrvRequestFlags flags)\n\n{\n\n    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,\n\n                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);\n\n}\n", "idx": 23405, "_split": "test", "_hash": "fbe7e8daed580ed9ae444c544f96bcea"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void sigchld_handler(int signal)\n\n{\n\n    qemu_bh_schedule(sigchld_bh);\n\n}\n", "idx": 23411, "_split": "test", "_hash": "9df1268962d08f8953d4549b301af28f"}
{"project": "qemu", "commit_id": "79afc36d91be7550affbe7db227b4552451da41d", "target": 0, "func": "static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)\n\n{\n\n    if (kvm_enabled()) {\n\n        kvm_s390_virtio_irq(cpu, config_change, token);\n\n    } else {\n\n        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);\n\n    }\n\n}\n", "idx": 23455, "_split": "test", "_hash": "9713bc36771de001af44a5b7a017430c"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "BlockDriverState *bdrv_next(BlockDriverState *bs)\n\n{\n\n    if (!bs) {\n\n        return QTAILQ_FIRST(&bdrv_states);\n\n    }\n\n    return QTAILQ_NEXT(bs, device_list);\n\n}\n", "idx": 23491, "_split": "test", "_hash": "12c42608ee9aa8fe04716212735780f0"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void mcf_uart_write(void *opaque, target_phys_addr_t addr,\n\n                    uint64_t val, unsigned size)\n\n{\n\n    mcf_uart_state *s = (mcf_uart_state *)opaque;\n\n    switch (addr & 0x3f) {\n\n    case 0x00:\n\n        s->mr[s->current_mr] = val;\n\n        s->current_mr = 1;\n\n        break;\n\n    case 0x04:\n\n        /* CSR is ignored.  */\n\n        break;\n\n    case 0x08: /* Command Register.  */\n\n        mcf_do_command(s, val);\n\n        break;\n\n    case 0x0c: /* Transmit Buffer.  */\n\n        s->sr &= ~MCF_UART_TxEMP;\n\n        s->tb = val;\n\n        mcf_uart_do_tx(s);\n\n        break;\n\n    case 0x10:\n\n        /* ACR is ignored.  */\n\n        break;\n\n    case 0x14:\n\n        s->imr = val;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    mcf_uart_update(s);\n\n}\n", "idx": 23495, "_split": "test", "_hash": "b7df8a888655c40ac009735551f7a0bd"}
{"project": "qemu", "commit_id": "b16595275bc9b9ce6a36bfb0344d514ab77e6b98", "target": 0, "func": "MemTxAttrs kvm_arch_post_run(CPUState *cs, struct kvm_run *run)\n\n{\n\n    ARMCPU *cpu;\n\n    uint32_t switched_level;\n\n\n\n    if (kvm_irqchip_in_kernel()) {\n\n        /*\n\n         * We only need to sync timer states with user-space interrupt\n\n         * controllers, so return early and save cycles if we don't.\n\n         */\n\n        return MEMTXATTRS_UNSPECIFIED;\n\n    }\n\n\n\n    cpu = ARM_CPU(cs);\n\n\n\n    /* Synchronize our shadowed in-kernel device irq lines with the kvm ones */\n\n    if (run->s.regs.device_irq_level != cpu->device_irq_level) {\n\n        switched_level = cpu->device_irq_level ^ run->s.regs.device_irq_level;\n\n\n\n        qemu_mutex_lock_iothread();\n\n\n\n        if (switched_level & KVM_ARM_DEV_EL1_VTIMER) {\n\n            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_VIRT],\n\n                         !!(run->s.regs.device_irq_level &\n\n                            KVM_ARM_DEV_EL1_VTIMER));\n\n            switched_level &= ~KVM_ARM_DEV_EL1_VTIMER;\n\n        }\n\n\n\n        if (switched_level & KVM_ARM_DEV_EL1_PTIMER) {\n\n            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_PHYS],\n\n                         !!(run->s.regs.device_irq_level &\n\n                            KVM_ARM_DEV_EL1_PTIMER));\n\n            switched_level &= ~KVM_ARM_DEV_EL1_PTIMER;\n\n        }\n\n\n\n        /* XXX PMU IRQ is missing */\n\n\n\n        if (switched_level) {\n\n            qemu_log_mask(LOG_UNIMP, \"%s: unhandled in-kernel device IRQ %x\\n\",\n\n                          __func__, switched_level);\n\n        }\n\n\n\n        /* We also mark unknown levels as processed to not waste cycles */\n\n        cpu->device_irq_level = run->s.regs.device_irq_level;\n\n        qemu_mutex_unlock_iothread();\n\n    }\n\n\n\n    return MEMTXATTRS_UNSPECIFIED;\n\n}\n", "idx": 23504, "_split": "test", "_hash": "4d945cde3dd9f0ee12432d11334546cf"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    if (size != 2) {\n\n        return omap_badwidth_read16(opaque, addr);\n\n    }\n\n\n\n    if (addr == OMAP_MPUI_BASE)\t/* CMR */\n\n        return 0xfe4d;\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 23516, "_split": "test", "_hash": "84f589f00684a0c7e71a49e7ba9c8099"}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    PCIAC97LinkState *d = opaque;\n\n    AC97LinkState *s = &d->ac97;\n\n    dolog (\"U nam writeb %#x <- %#x\\n\", addr, val);\n\n    s->cas = 0;\n\n}\n", "idx": 23540, "_split": "test", "_hash": "01068bafcda92fbf9a4a6ec4e1fa998f"}
{"project": "qemu", "commit_id": "3b00f702c236900cca403bdcbed48d59bfec0fba", "target": 0, "func": "static void s390_flic_common_realize(DeviceState *dev, Error **errp)\n\n{\n\n    S390FLICState *fs = S390_FLIC_COMMON(dev);\n\n    uint32_t max_batch = fs->adapter_routes_max_batch;\n\n\n\n    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {\n\n        error_setg(errp, \"flic property adapter_routes_max_batch too big\"\n\n                   \" (%d > %d)\", max_batch, ADAPTER_ROUTES_MAX_GSI);\n\n    }\n\n\n\n    fs->ais_supported = true;\n\n}\n", "idx": 23555, "_split": "test", "_hash": "1f67774dfe9816cb5e2a5577f4b128e9"}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void do_load_dcr (void)\n\n{\n\n    target_ulong val;\n\n\n\n    if (unlikely(env->dcr_env == NULL)) {\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"No DCR environment\\n\");\n\n        }\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_INVAL_INVAL);\n\n    } else if (unlikely(ppc_dcr_read(env->dcr_env, T0, &val) != 0)) {\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"DCR read error %d %03x\\n\", (int)T0, (int)T0);\n\n        }\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_PRIV_REG);\n\n    } else {\n\n        T0 = val;\n\n    }\n\n}\n", "idx": 23587, "_split": "test", "_hash": "6e707df0036a64678e00b8e0ab147566"}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "void tlb_set_page(CPUArchState *env, target_ulong vaddr,\n\n                  target_phys_addr_t paddr, int prot,\n\n                  int mmu_idx, target_ulong size)\n\n{\n\n    MemoryRegionSection *section;\n\n    unsigned int index;\n\n    target_ulong address;\n\n    target_ulong code_address;\n\n    uintptr_t addend;\n\n    CPUTLBEntry *te;\n\n    target_phys_addr_t iotlb;\n\n\n\n    assert(size >= TARGET_PAGE_SIZE);\n\n    if (size != TARGET_PAGE_SIZE) {\n\n        tlb_add_large_page(env, vaddr, size);\n\n    }\n\n    section = phys_page_find(paddr >> TARGET_PAGE_BITS);\n\n#if defined(DEBUG_TLB)\n\n    printf(\"tlb_set_page: vaddr=\" TARGET_FMT_lx \" paddr=0x\" TARGET_FMT_plx\n\n           \" prot=%x idx=%d pd=0x%08lx\\n\",\n\n           vaddr, paddr, prot, mmu_idx, pd);\n\n#endif\n\n\n\n    address = vaddr;\n\n    if (!(memory_region_is_ram(section->mr) ||\n\n          memory_region_is_romd(section->mr))) {\n\n        /* IO memory case (romd handled later) */\n\n        address |= TLB_MMIO;\n\n    }\n\n    if (memory_region_is_ram(section->mr) ||\n\n        memory_region_is_romd(section->mr)) {\n\n        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr)\n\n        + memory_region_section_addr(section, paddr);\n\n    } else {\n\n        addend = 0;\n\n    }\n\n\n\n    code_address = address;\n\n    iotlb = memory_region_section_get_iotlb(env, section, vaddr, paddr, prot,\n\n                                            &address);\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    env->iotlb[mmu_idx][index] = iotlb - vaddr;\n\n    te = &env->tlb_table[mmu_idx][index];\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((memory_region_is_ram(section->mr) && section->readonly)\n\n            || memory_region_is_romd(section->mr)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if (memory_region_is_ram(section->mr)\n\n                   && !cpu_physical_memory_is_dirty(\n\n                           section->mr->ram_addr\n\n                           + memory_region_section_addr(section, paddr))) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n", "idx": 23622, "_split": "test", "_hash": "d0b6179208711ae3071364deedf34502"}
{"project": "qemu", "commit_id": "4abf12f4ea866779b493ecf4606bd0b6d35f8348", "target": 1, "func": "static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)\n\n{\n\n    RTL8139State *s = opaque;\n\n\n\n    addr &= 0xff;\n\n\n\n    switch (addr)\n\n    {\n\n        case MAC0 ... MAC0+5:\n\n            s->phys[addr - MAC0] = val;\n\n            break;\n\n        case MAC0+6 ... MAC0+7:\n\n            /* reserved */\n\n            break;\n\n        case MAR0 ... MAR0+7:\n\n            s->mult[addr - MAR0] = val;\n\n            break;\n\n        case ChipCmd:\n\n            rtl8139_ChipCmd_write(s, val);\n\n            break;\n\n        case Cfg9346:\n\n            rtl8139_Cfg9346_write(s, val);\n\n            break;\n\n        case TxConfig: /* windows driver sometimes writes using byte-lenth call */\n\n            rtl8139_TxConfig_writeb(s, val);\n\n            break;\n\n        case Config0:\n\n            rtl8139_Config0_write(s, val);\n\n            break;\n\n        case Config1:\n\n            rtl8139_Config1_write(s, val);\n\n            break;\n\n        case Config3:\n\n            rtl8139_Config3_write(s, val);\n\n            break;\n\n        case Config4:\n\n            rtl8139_Config4_write(s, val);\n\n            break;\n\n        case Config5:\n\n            rtl8139_Config5_write(s, val);\n\n            break;\n\n        case MediaStatus:\n\n            /* ignore */\n\n            DPRINTF(\"not implemented write(b) to MediaStatus val=0x%02x\\n\",\n\n                val);\n\n            break;\n\n\n\n        case HltClk:\n\n            DPRINTF(\"HltClk write val=0x%08x\\n\", val);\n\n            if (val == 'R')\n\n            {\n\n                s->clock_enabled = 1;\n\n            }\n\n            else if (val == 'H')\n\n            {\n\n                s->clock_enabled = 0;\n\n            }\n\n            break;\n\n\n\n        case TxThresh:\n\n            DPRINTF(\"C+ TxThresh write(b) val=0x%02x\\n\", val);\n\n            s->TxThresh = val;\n\n            break;\n\n\n\n        case TxPoll:\n\n            DPRINTF(\"C+ TxPoll write(b) val=0x%02x\\n\", val);\n\n            if (val & (1 << 7))\n\n            {\n\n                DPRINTF(\"C+ TxPoll high priority transmission (not \"\n\n                    \"implemented)\\n\");\n\n                //rtl8139_cplus_transmit(s);\n\n            }\n\n            if (val & (1 << 6))\n\n            {\n\n                DPRINTF(\"C+ TxPoll normal priority transmission\\n\");\n\n                rtl8139_cplus_transmit(s);\n\n            }\n\n\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"not implemented write(b) addr=0x%x val=0x%02x\\n\", addr,\n\n                val);\n\n            break;\n\n    }\n\n}\n", "idx": 23626, "_split": "test", "_hash": "e6ca83e65e98fce804528c7969649dce"}
{"project": "qemu", "commit_id": "82e59a676c01b3df3b53998d428d0a64a55f2439", "target": 1, "func": "void hmp_memchar_write(Monitor *mon, const QDict *qdict)\n\n{\n\n    uint32_t size;\n\n    const char *chardev = qdict_get_str(qdict, \"device\");\n\n    const char *data = qdict_get_str(qdict, \"data\");\n\n    Error *errp = NULL;\n\n\n\n    size = strlen(data);\n\n    qmp_memchar_write(chardev, size, data, false, 0, &errp);\n\n\n\n    hmp_handle_error(mon, &errp);\n\n}\n", "idx": 23656, "_split": "test", "_hash": "f175a85298c5c6a41510b0653137a362"}
{"project": "qemu", "commit_id": "761731b1805f6ef64eb615e5b82a0801db3cde78", "target": 0, "func": "void qmp_drive_backup(const char *device, const char *target,\n\n                      bool has_format, const char *format,\n\n                      enum MirrorSyncMode sync,\n\n                      bool has_mode, enum NewImageMode mode,\n\n                      bool has_speed, int64_t speed,\n\n                      bool has_on_source_error, BlockdevOnError on_source_error,\n\n                      bool has_on_target_error, BlockdevOnError on_target_error,\n\n                      Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *target_bs;\n\n    BlockDriverState *source = NULL;\n\n    BlockDriver *drv = NULL;\n\n    Error *local_err = NULL;\n\n    int flags;\n\n    int64_t size;\n\n    int ret;\n\n\n\n    if (!has_speed) {\n\n        speed = 0;\n\n    }\n\n    if (!has_on_source_error) {\n\n        on_source_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!has_on_target_error) {\n\n        on_target_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!has_mode) {\n\n        mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n\n    }\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    if (!bdrv_is_inserted(bs)) {\n\n        error_set(errp, QERR_DEVICE_HAS_NO_MEDIUM, device);\n\n        return;\n\n    }\n\n\n\n    if (!has_format) {\n\n        format = mode == NEW_IMAGE_MODE_EXISTING ? NULL : bs->drv->format_name;\n\n    }\n\n    if (format) {\n\n        drv = bdrv_find_format(format);\n\n        if (!drv) {\n\n            error_set(errp, QERR_INVALID_BLOCK_FORMAT, format);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_BACKUP_SOURCE, errp)) {\n\n        return;\n\n    }\n\n\n\n    flags = bs->open_flags | BDRV_O_RDWR;\n\n\n\n    /* See if we have a backing HD we can use to create our new image\n\n     * on top of. */\n\n    if (sync == MIRROR_SYNC_MODE_TOP) {\n\n        source = bs->backing_hd;\n\n        if (!source) {\n\n            sync = MIRROR_SYNC_MODE_FULL;\n\n        }\n\n    }\n\n    if (sync == MIRROR_SYNC_MODE_NONE) {\n\n        source = bs;\n\n    }\n\n\n\n    size = bdrv_getlength(bs);\n\n    if (size < 0) {\n\n        error_setg_errno(errp, -size, \"bdrv_getlength failed\");\n\n        return;\n\n    }\n\n\n\n    if (mode != NEW_IMAGE_MODE_EXISTING) {\n\n        assert(format && drv);\n\n        if (source) {\n\n            bdrv_img_create(target, format, source->filename,\n\n                            source->drv->format_name, NULL,\n\n                            size, flags, &local_err, false);\n\n        } else {\n\n            bdrv_img_create(target, format, NULL, NULL, NULL,\n\n                            size, flags, &local_err, false);\n\n        }\n\n    }\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    target_bs = NULL;\n\n    ret = bdrv_open(&target_bs, target, NULL, NULL, flags, drv, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    backup_start(bs, target_bs, speed, sync, on_source_error, on_target_error,\n\n                 block_job_cb, bs, &local_err);\n\n    if (local_err != NULL) {\n\n        bdrv_unref(target_bs);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n}\n", "idx": 23680, "_split": "test", "_hash": "f847cbc2ef4d7f1b533cb24440e6108b"}
{"project": "qemu", "commit_id": "35c648078aa493c3b976840eb7cf2e53ab5b7a2d", "target": 0, "func": "static void malta_fpga_write(void *opaque, hwaddr addr,\n\n                             uint64_t val, unsigned size)\n\n{\n\n    MaltaFPGAState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr & 0xfffff);\n\n\n\n    switch (saddr) {\n\n\n\n    /* SWITCH Register */\n\n    case 0x00200:\n\n        break;\n\n\n\n    /* JMPRS Register */\n\n    case 0x00210:\n\n        break;\n\n\n\n    /* LEDBAR Register */\n\n    case 0x00408:\n\n        s->leds = val & 0xff;\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* ASCIIWORD Register */\n\n    case 0x00410:\n\n        snprintf(s->display_text, 9, \"%08X\", (uint32_t)val);\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* ASCIIPOS0 to ASCIIPOS7 Registers */\n\n    case 0x00418:\n\n    case 0x00420:\n\n    case 0x00428:\n\n    case 0x00430:\n\n    case 0x00438:\n\n    case 0x00440:\n\n    case 0x00448:\n\n    case 0x00450:\n\n        s->display_text[(saddr - 0x00418) >> 3] = (char) val;\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* SOFTRES Register */\n\n    case 0x00500:\n\n        if (val == 0x42)\n\n            qemu_system_reset_request ();\n\n        break;\n\n\n\n    /* BRKRES Register */\n\n    case 0x00508:\n\n        s->brk = val & 0xff;\n\n        break;\n\n\n\n    /* UART Registers are handled directly by the serial device */\n\n\n\n    /* GPOUT Register */\n\n    case 0x00a00:\n\n        s->gpout = val & 0xff;\n\n        break;\n\n\n\n    /* I2COE Register */\n\n    case 0x00b08:\n\n        s->i2coe = val & 0x03;\n\n        break;\n\n\n\n    /* I2COUT Register */\n\n    case 0x00b10:\n\n        eeprom24c0x_write(val & 0x02, val & 0x01);\n\n        s->i2cout = val;\n\n        break;\n\n\n\n    /* I2CSEL Register */\n\n    case 0x00b18:\n\n        s->i2csel = val & 0x01;\n\n        break;\n\n\n\n    default:\n\n#if 0\n\n        printf (\"malta_fpga_write: Bad register offset 0x\" TARGET_FMT_lx \"\\n\",\n\n                addr);\n\n#endif\n\n        break;\n\n    }\n\n}\n", "idx": 23688, "_split": "test", "_hash": "8d7aba030dcf857fcab6182b3bf7871c"}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_hpet(GArray *table_data, GArray *linker)\n\n{\n\n    Acpi20Hpet *hpet;\n\n\n\n    hpet = acpi_data_push(table_data, sizeof(*hpet));\n\n    /* Note timer_block_id value must be kept in sync with value advertised by\n\n     * emulated hpet\n\n     */\n\n    hpet->timer_block_id = cpu_to_le32(0x8086a201);\n\n    hpet->addr.address = cpu_to_le64(HPET_BASE);\n\n    build_header(linker, table_data,\n\n                 (void *)hpet, \"HPET\", sizeof(*hpet), 1, NULL);\n\n}\n", "idx": 23696, "_split": "test", "_hash": "ebcccc73bac64b06697916aaa23f4d54"}
{"project": "qemu", "commit_id": "b6ce27a593ab39ac28baebc3045901925046bebd", "target": 0, "func": "static void virtio_pci_modern_region_map(VirtIOPCIProxy *proxy,\n\n                                         VirtIOPCIRegion *region,\n\n                                         struct virtio_pci_cap *cap)\n\n{\n\n    memory_region_add_subregion(&proxy->modern_bar,\n\n                                region->offset,\n\n                                &region->mr);\n\n\n\n    cap->cfg_type = region->type;\n\n    cap->offset = cpu_to_le32(region->offset);\n\n    cap->length = cpu_to_le32(memory_region_size(&region->mr));\n\n    virtio_pci_add_mem_cap(proxy, cap);\n\n}\n", "idx": 23744, "_split": "test", "_hash": "5343ca55b8e21a4585ad3988aade7fda"}
{"project": "qemu", "commit_id": "d044be3714db9c3750c430a2bb1be74beee6fd27", "target": 0, "func": "static void mixer_reset (AC97LinkState *s)\n\n{\n\n    uint8_t active[LAST_INDEX];\n\n\n\n    dolog (\"mixer_reset\\n\");\n\n    memset (s->mixer_data, 0, sizeof (s->mixer_data));\n\n    memset (active, 0, sizeof (active));\n\n    mixer_store (s, AC97_Reset                   , 0x0000); /* 6940 */\n\n    mixer_store (s, AC97_Master_Volume_Mono_Mute , 0x8000);\n\n    mixer_store (s, AC97_PC_BEEP_Volume_Mute     , 0x0000);\n\n\n\n    mixer_store (s, AC97_Phone_Volume_Mute       , 0x8008);\n\n    mixer_store (s, AC97_Mic_Volume_Mute         , 0x8008);\n\n    mixer_store (s, AC97_CD_Volume_Mute          , 0x8808);\n\n    mixer_store (s, AC97_Aux_Volume_Mute         , 0x8808);\n\n    mixer_store (s, AC97_Record_Gain_Mic_Mute    , 0x8000);\n\n    mixer_store (s, AC97_General_Purpose         , 0x0000);\n\n    mixer_store (s, AC97_3D_Control              , 0x0000);\n\n    mixer_store (s, AC97_Powerdown_Ctrl_Stat     , 0x000f);\n\n\n\n    /*\n\n     * Sigmatel 9700 (STAC9700)\n\n     */\n\n    mixer_store (s, AC97_Vendor_ID1              , 0x8384);\n\n    mixer_store (s, AC97_Vendor_ID2              , 0x7600); /* 7608 */\n\n\n\n    mixer_store (s, AC97_Extended_Audio_ID       , 0x0809);\n\n    mixer_store (s, AC97_Extended_Audio_Ctrl_Stat, 0x0009);\n\n    mixer_store (s, AC97_PCM_Front_DAC_Rate      , 0xbb80);\n\n    mixer_store (s, AC97_PCM_Surround_DAC_Rate   , 0xbb80);\n\n    mixer_store (s, AC97_PCM_LFE_DAC_Rate        , 0xbb80);\n\n    mixer_store (s, AC97_PCM_LR_ADC_Rate         , 0xbb80);\n\n    mixer_store (s, AC97_MIC_ADC_Rate            , 0xbb80);\n\n\n\n    record_select (s, 0);\n\n    set_volume (s, AC97_Master_Volume_Mute, 0x8000);\n\n    set_volume (s, AC97_PCM_Out_Volume_Mute, 0x8808);\n\n    set_volume (s, AC97_Line_In_Volume_Mute, 0x8808);\n\n\n\n    reset_voices (s, active);\n\n}\n", "idx": 23747, "_split": "test", "_hash": "7b3e4927976ae195f1cd7eda2e5d7707"}
{"project": "qemu", "commit_id": "88b062c2036cfd05b5111147736a08ba05ea05a9", "target": 0, "func": "int bdrv_pdiscard(BlockDriverState *bs, int64_t offset, int count)\n\n{\n\n    Coroutine *co;\n\n    DiscardCo rwco = {\n\n        .bs = bs,\n\n        .offset = offset,\n\n        .count = count,\n\n        .ret = NOT_DONE,\n\n    };\n\n\n\n    if (qemu_in_coroutine()) {\n\n        /* Fast-path if already in coroutine context */\n\n        bdrv_pdiscard_co_entry(&rwco);\n\n    } else {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        co = qemu_coroutine_create(bdrv_pdiscard_co_entry, &rwco);\n\n        qemu_coroutine_enter(co);\n\n        while (rwco.ret == NOT_DONE) {\n\n            aio_poll(aio_context, true);\n\n        }\n\n    }\n\n\n\n    return rwco.ret;\n\n}\n", "idx": 23751, "_split": "test", "_hash": "d21b67d687269b492fec81d675125c45"}
{"project": "qemu", "commit_id": "f9f46db444a2dfc2ebf1f9f7d4b42163ab33187d", "target": 0, "func": "void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)\n\n{\n\n    uintptr_t ra = GETPC();\n\n\n\n    switch (addr & 3) {\n\n    case 3:\n\n        cpu_stb_data_ra(env, addr, val, ra);\n\n        break;\n\n    case 2:\n\n        cpu_stw_data_ra(env, addr, val, ra);\n\n        break;\n\n    case 1:\n\n        /* The 3 byte store must appear atomic.  */\n\n        if (parallel_cpus) {\n\n            atomic_store_3(env, addr, val, 0x00ffffffu, ra);\n\n        } else {\n\n            cpu_stb_data_ra(env, addr, val >> 16, ra);\n\n            cpu_stw_data_ra(env, addr + 1, val, ra);\n\n        }\n\n        break;\n\n    default:\n\n        cpu_stl_data_ra(env, addr, val, ra);\n\n        break;\n\n    }\n\n}\n", "idx": 23758, "_split": "test", "_hash": "63facaf2e0732d7dc4f6d004262431a3"}
{"project": "qemu", "commit_id": "52c91dac6bd891656f297dab76da51fc8bc61309", "target": 1, "func": "static void memory_region_destructor_alias(MemoryRegion *mr)\n\n{\n\n    memory_region_unref(mr->alias);\n\n}\n", "idx": 23771, "_split": "test", "_hash": "ab5aa418b4dd8b49258c03a0e99c0f8c"}
{"project": "qemu", "commit_id": "be18b2b53ebbf2eb3f00e7890d0b9ff8b58d22bf", "target": 1, "func": "int ppc_hash64_handle_mmu_fault(PowerPCCPU *cpu, target_ulong eaddr,\n\n                                int rwx, int mmu_idx)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUPPCState *env = &cpu->env;\n\n    ppc_slb_t *slb;\n\n    hwaddr pte_offset;\n\n    ppc_hash_pte64_t pte;\n\n    int pp_prot, amr_prot, prot;\n\n    uint64_t new_pte1;\n\n    const int need_prot[] = {PAGE_READ, PAGE_WRITE, PAGE_EXEC};\n\n    hwaddr raddr;\n\n\n\n    assert((rwx == 0) || (rwx == 1) || (rwx == 2));\n\n\n\n    /* 1. Handle real mode accesses */\n\n    if (((rwx == 2) && (msr_ir == 0)) || ((rwx != 2) && (msr_dr == 0))) {\n\n        /* Translation is off */\n\n        /* In real mode the top 4 effective address bits are ignored */\n\n        raddr = eaddr & 0x0FFFFFFFFFFFFFFFULL;\n\n        tlb_set_page(cs, eaddr & TARGET_PAGE_MASK, raddr & TARGET_PAGE_MASK,\n\n                     PAGE_READ | PAGE_WRITE | PAGE_EXEC, mmu_idx,\n\n                     TARGET_PAGE_SIZE);\n\n        return 0;\n\n    }\n\n\n\n    /* 2. Translation is on, so look up the SLB */\n\n    slb = slb_lookup(cpu, eaddr);\n\n\n\n    if (!slb) {\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISEG;\n\n            env->error_code = 0;\n\n        } else {\n\n            cs->exception_index = POWERPC_EXCP_DSEG;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n        }\n\n        return 1;\n\n    }\n\n\n\n    /* 3. Check for segment level no-execute violation */\n\n    if ((rwx == 2) && (slb->vsid & SLB_VSID_N)) {\n\n        cs->exception_index = POWERPC_EXCP_ISI;\n\n        env->error_code = 0x10000000;\n\n        return 1;\n\n    }\n\n\n\n    /* 4. Locate the PTE in the hash table */\n\n    pte_offset = ppc_hash64_htab_lookup(cpu, slb, eaddr, &pte);\n\n    if (pte_offset == -1) {\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISI;\n\n            env->error_code = 0x40000000;\n\n        } else {\n\n            cs->exception_index = POWERPC_EXCP_DSI;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n            if (rwx == 1) {\n\n                env->spr[SPR_DSISR] = 0x42000000;\n\n            } else {\n\n                env->spr[SPR_DSISR] = 0x40000000;\n\n            }\n\n        }\n\n        return 1;\n\n    }\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n                \"found PTE at offset %08\" HWADDR_PRIx \"\\n\", pte_offset);\n\n\n\n    /* 5. Check access permissions */\n\n\n\n    pp_prot = ppc_hash64_pte_prot(cpu, slb, pte);\n\n    amr_prot = ppc_hash64_amr_prot(cpu, pte);\n\n    prot = pp_prot & amr_prot;\n\n\n\n    if ((need_prot[rwx] & ~prot) != 0) {\n\n        /* Access right violation */\n\n        qemu_log_mask(CPU_LOG_MMU, \"PTE access rejected\\n\");\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISI;\n\n            env->error_code = 0x08000000;\n\n        } else {\n\n            target_ulong dsisr = 0;\n\n\n\n            cs->exception_index = POWERPC_EXCP_DSI;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n            if (need_prot[rwx] & ~pp_prot) {\n\n                dsisr |= 0x08000000;\n\n            }\n\n            if (rwx == 1) {\n\n                dsisr |= 0x02000000;\n\n            }\n\n            if (need_prot[rwx] & ~amr_prot) {\n\n                dsisr |= 0x00200000;\n\n            }\n\n            env->spr[SPR_DSISR] = dsisr;\n\n        }\n\n        return 1;\n\n    }\n\n\n\n    qemu_log_mask(CPU_LOG_MMU, \"PTE access granted !\\n\");\n\n\n\n    /* 6. Update PTE referenced and changed bits if necessary */\n\n\n\n    new_pte1 = pte.pte1 | HPTE64_R_R; /* set referenced bit */\n\n    if (rwx == 1) {\n\n        new_pte1 |= HPTE64_R_C; /* set changed (dirty) bit */\n\n    } else {\n\n        /* Treat the page as read-only for now, so that a later write\n\n         * will pass through this function again to set the C bit */\n\n        prot &= ~PAGE_WRITE;\n\n    }\n\n\n\n    if (new_pte1 != pte.pte1) {\n\n        ppc_hash64_store_hpte(cpu, pte_offset / HASH_PTE_SIZE_64,\n\n                              pte.pte0, new_pte1);\n\n    }\n\n\n\n    /* 7. Determine the real address from the PTE */\n\n\n\n    raddr = deposit64(pte.pte1 & HPTE64_R_RPN, 0, slb->sps->page_shift, eaddr);\n\n\n\n    tlb_set_page(cs, eaddr & TARGET_PAGE_MASK, raddr & TARGET_PAGE_MASK,\n\n                 prot, mmu_idx, TARGET_PAGE_SIZE);\n\n\n\n    return 0;\n\n}\n", "idx": 23779, "_split": "test", "_hash": "c03faf7638f0841b9404fec253f0055a"}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)\n\n{\n\n    QemuOpts *opts;\n\n\n\n    opts = qemu_opts_create(list, qdict_get_try_str(qdict, \"id\"), 1);\n\n    if (opts == NULL)\n\n        return NULL;\n\n\n\n    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);\n\n    return opts;\n\n}\n", "idx": 23809, "_split": "test", "_hash": "7403ab918370fd8f60502feedb0b1d86"}
{"project": "qemu", "commit_id": "ad674e53b5cce265fadafbde2c6a4f190345cd00", "target": 0, "func": "static void conditional_branch(DBDMA_channel *ch)\n\n{\n\n    dbdma_cmd *current = &ch->current;\n\n    uint16_t br;\n\n    uint16_t sel_mask, sel_value;\n\n    uint32_t status;\n\n    int cond;\n\n\n\n    DBDMA_DPRINTF(\"conditional_branch\\n\");\n\n\n\n    /* check if we must branch */\n\n\n\n    br = le16_to_cpu(current->command) & BR_MASK;\n\n\n\n    switch(br) {\n\n    case BR_NEVER:  /* don't branch */\n\n        next(ch);\n\n        return;\n\n    case BR_ALWAYS: /* always branch */\n\n        branch(ch);\n\n        return;\n\n    }\n\n\n\n    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;\n\n\n\n    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;\n\n    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;\n\n\n\n    cond = (status & sel_mask) == (sel_value & sel_mask);\n\n\n\n    switch(br) {\n\n    case BR_IFSET:  /* branch if condition bit is 1 */\n\n        if (cond)\n\n            branch(ch);\n\n        else\n\n            next(ch);\n\n        return;\n\n    case BR_IFCLR:  /* branch if condition bit is 0 */\n\n        if (!cond)\n\n            branch(ch);\n\n        else\n\n            next(ch);\n\n        return;\n\n    }\n\n}\n", "idx": 23816, "_split": "test", "_hash": "5c079a0b2b25d59d4d66ef44a3433a37"}
{"project": "qemu", "commit_id": "5819e3e072f41cbf81ad80d822a5c468a91f54e0", "target": 0, "func": "static void gdb_accept(void)\n\n{\n\n    GDBState *s;\n\n    struct sockaddr_in sockaddr;\n\n    socklen_t len;\n\n    int fd;\n\n\n\n    for(;;) {\n\n        len = sizeof(sockaddr);\n\n        fd = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);\n\n        if (fd < 0 && errno != EINTR) {\n\n            perror(\"accept\");\n\n            return;\n\n        } else if (fd >= 0) {\n\n#ifndef _WIN32\n\n            fcntl(fd, F_SETFD, FD_CLOEXEC);\n\n#endif\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* set short latency */\n\n    socket_set_nodelay(fd);\n\n\n\n    s = g_malloc0(sizeof(GDBState));\n\n    s->c_cpu = first_cpu;\n\n    s->g_cpu = first_cpu;\n\n    s->fd = fd;\n\n    gdb_has_xml = false;\n\n\n\n    gdbserver_state = s;\n\n\n\n    fcntl(fd, F_SETFL, O_NONBLOCK);\n\n}\n", "idx": 23855, "_split": "test", "_hash": "61c7e01fa06c4a48724d74fbb4ec477e"}
{"project": "qemu", "commit_id": "fbeadf50f2f965741def823036b086bbc2999b1f", "target": 1, "func": "unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,\n\n\t\t\t\t unsigned long offset)\n\n{\n\n    const unsigned long *p = addr + BITOP_WORD(offset);\n\n    unsigned long result = offset & ~(BITS_PER_LONG-1);\n\n    unsigned long tmp;\n\n\n\n    if (offset >= size) {\n\n        return size;\n\n    }\n\n    size -= result;\n\n    offset %= BITS_PER_LONG;\n\n    if (offset) {\n\n        tmp = *(p++);\n\n        tmp |= ~0UL >> (BITS_PER_LONG - offset);\n\n        if (size < BITS_PER_LONG) {\n\n            goto found_first;\n\n        }\n\n        if (~tmp) {\n\n            goto found_middle;\n\n        }\n\n        size -= BITS_PER_LONG;\n\n        result += BITS_PER_LONG;\n\n    }\n\n    while (size & ~(BITS_PER_LONG-1)) {\n\n        if (~(tmp = *(p++))) {\n\n            goto found_middle;\n\n        }\n\n        result += BITS_PER_LONG;\n\n        size -= BITS_PER_LONG;\n\n    }\n\n    if (!size) {\n\n        return result;\n\n    }\n\n    tmp = *p;\n\n\n\nfound_first:\n\n    tmp |= ~0UL << size;\n\n    if (tmp == ~0UL) {\t/* Are any bits zero? */\n\n        return result + size;\t/* Nope. */\n\n    }\n\nfound_middle:\n\n    return result + ffz(tmp);\n\n}\n", "idx": 23888, "_split": "test", "_hash": "6a8b850df61c01affc1b4dba0f7a4348"}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_end_implicit_struct(Visitor *v, Error **errp)\n\n{\n\n    assert(!error_is_set(errp));\n\n    if (v->end_implicit_struct) {\n\n        v->end_implicit_struct(v, errp);\n\n    }\n\n}\n", "idx": 23895, "_split": "test", "_hash": "50d5570680beefaaf2db2f2a42228ac1"}
{"project": "qemu", "commit_id": "894e02804c862c6940b43a0a488164655d3fb3f0", "target": 1, "func": "static int nbd_reject_length(NBDClient *client, bool fatal, Error **errp)\n\n{\n\n    int ret;\n\n\n\n    assert(client->optlen);\n\n    if (nbd_drop(client->ioc, client->optlen, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    ret = nbd_negotiate_send_rep_err(client, NBD_REP_ERR_INVALID, errp,\n\n                                     \"option '%s' should have zero length\",\n\n                                     nbd_opt_lookup(client->opt));\n\n    if (fatal && !ret) {\n\n        error_setg(errp, \"option '%s' should have zero length\",\n\n                   nbd_opt_lookup(client->opt));\n\n        return -EINVAL;\n\n    }\n\n    return ret;\n\n}\n", "idx": 23899, "_split": "test", "_hash": "54f056c01593926fb788c2f6c68de32a"}
{"project": "qemu", "commit_id": "57be80f948cdbb75ef00fd8345845d83010d8af1", "target": 1, "func": "static int kvmppc_read_host_property(const char *node_path, const char *prop,\n\n                                     void *val, size_t len)\n\n{\n\n    char *path;\n\n    FILE *f;\n\n    int ret;\n\n    int pathlen;\n\n\n\n    pathlen = snprintf(NULL, 0, \"%s/%s/%s\", PROC_DEVTREE_PATH, node_path, prop)\n\n              + 1;\n\n    path = qemu_malloc(pathlen);\n\n    if (path == NULL) {\n\n        ret = -ENOMEM;\n\n        goto out;\n\n    }\n\n\n\n    snprintf(path, pathlen, \"%s/%s/%s\", PROC_DEVTREE_PATH, node_path, prop);\n\n\n\n    f = fopen(path, \"rb\");\n\n    if (f == NULL) {\n\n        ret = errno;\n\n        goto free;\n\n    }\n\n\n\n    len = fread(val, len, 1, f);\n\n    if (len != 1) {\n\n        ret = ferror(f);\n\n        goto close;\n\n    }\n\n\n\nclose:\n\n    fclose(f);\n\nfree:\n\n    free(path);\n\nout:\n\n    return ret;\n\n}\n", "idx": 23912, "_split": "test", "_hash": "52c2a1cae455dbb081c09b39cc1e3649"}
{"project": "qemu", "commit_id": "5c32be5baf41aec4f4675d2bf24f9948756abf3c", "target": 1, "func": "static void tcg_out_qemu_ld(TCGContext *s, TCGReg data, TCGReg addr,\n\n                            TCGMemOpIdx oi, bool is_64)\n\n{\n\n    TCGMemOp memop = get_memop(oi);\n\n#ifdef CONFIG_SOFTMMU\n\n    unsigned memi = get_mmuidx(oi);\n\n    TCGReg addrz, param;\n\n    tcg_insn_unit *func;\n\n    tcg_insn_unit *label_ptr;\n\n\n\n    addrz = tcg_out_tlb_load(s, addr, memi, memop,\n\n                             offsetof(CPUTLBEntry, addr_read));\n\n\n\n    /* The fast path is exactly one insn.  Thus we can perform the\n\n       entire TLB Hit in the (annulled) delay slot of the branch\n\n       over the TLB Miss case.  */\n\n\n\n    /* beq,a,pt %[xi]cc, label0 */\n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT\n\n                  | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);\n\n    /* delay slot */\n\n    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,\n\n                    qemu_ld_opc[memop & (MO_BSWAP | MO_SSIZE)]);\n\n\n\n    /* TLB Miss.  */\n\n\n\n    param = TCG_REG_O1;\n\n    if (!SPARC64 && TARGET_LONG_BITS == 64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, addr);\n\n\n\n    /* We use the helpers to extend SB and SW data, leaving the case\n\n       of SL needing explicit extending below.  */\n\n    if ((memop & MO_SSIZE) == MO_SL) {\n\n        func = qemu_ld_trampoline[memop & (MO_BSWAP | MO_SIZE)];\n\n    } else {\n\n        func = qemu_ld_trampoline[memop & (MO_BSWAP | MO_SSIZE)];\n\n    }\n\n    tcg_debug_assert(func != NULL);\n\n    tcg_out_call_nodelay(s, func);\n\n    /* delay slot */\n\n    tcg_out_movi(s, TCG_TYPE_I32, param, oi);\n\n\n\n    /* Recall that all of the helpers return 64-bit results.\n\n       Which complicates things for sparcv8plus.  */\n\n    if (SPARC64) {\n\n        /* We let the helper sign-extend SB and SW, but leave SL for here.  */\n\n        if (is_64 && (memop & MO_SSIZE) == MO_SL) {\n\n            tcg_out_arithi(s, data, TCG_REG_O0, 0, SHIFT_SRA);\n\n        } else {\n\n            tcg_out_mov(s, TCG_TYPE_REG, data, TCG_REG_O0);\n\n        }\n\n    } else {\n\n        if ((memop & MO_SIZE) == MO_64) {\n\n            tcg_out_arithi(s, TCG_REG_O0, TCG_REG_O0, 32, SHIFT_SLLX);\n\n            tcg_out_arithi(s, TCG_REG_O1, TCG_REG_O1, 0, SHIFT_SRL);\n\n            tcg_out_arith(s, data, TCG_REG_O0, TCG_REG_O1, ARITH_OR);\n\n        } else if (is_64) {\n\n            /* Re-extend from 32-bit rather than reassembling when we\n\n               know the high register must be an extension.  */\n\n            tcg_out_arithi(s, data, TCG_REG_O1, 0,\n\n                           memop & MO_SIGN ? SHIFT_SRA : SHIFT_SRL);\n\n        } else {\n\n            tcg_out_mov(s, TCG_TYPE_I32, data, TCG_REG_O1);\n\n        }\n\n    }\n\n\n\n    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));\n\n#else\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);\n\n        addr = TCG_REG_T1;\n\n    }\n\n    tcg_out_ldst_rr(s, data, addr,\n\n                    (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0),\n\n                    qemu_ld_opc[memop & (MO_BSWAP | MO_SSIZE)]);\n\n#endif /* CONFIG_SOFTMMU */\n\n}\n", "idx": 23916, "_split": "test", "_hash": "cd4988e16a3eed784e3972e23f246f67"}
{"project": "qemu", "commit_id": "e36c87667aa2204a3f19efe7bbcb6eb41f098e40", "target": 1, "func": "opts_visitor_cleanup(OptsVisitor *ov)\n\n{\n\n    if (ov->unprocessed_opts != NULL) {\n\n        g_hash_table_destroy(ov->unprocessed_opts);\n\n    }\n\n    g_free(ov->fake_id_opt);\n\n    memset(ov, '\\0', sizeof *ov);\n\n}\n", "idx": 23918, "_split": "test", "_hash": "c91f86c2a647669efc864549ed0a7d06"}
{"project": "qemu", "commit_id": "7d553f27fce284805d7f94603932045ee3bbb979", "target": 0, "func": "static int usb_host_open(USBHostDevice *s, libusb_device *dev)\n\n{\n\n    USBDevice *udev = USB_DEVICE(s);\n\n    int bus_num = libusb_get_bus_number(dev);\n\n    int addr    = libusb_get_device_address(dev);\n\n    int rc;\n\n\n\n    trace_usb_host_open_started(bus_num, addr);\n\n\n\n    if (s->dh != NULL) {\n\n        goto fail;\n\n    }\n\n    rc = libusb_open(dev, &s->dh);\n\n    if (rc != 0) {\n\n        goto fail;\n\n    }\n\n\n\n    s->dev     = dev;\n\n    s->bus_num = bus_num;\n\n    s->addr    = addr;\n\n\n\n    usb_host_detach_kernel(s);\n\n\n\n    libusb_get_device_descriptor(dev, &s->ddesc);\n\n    usb_host_get_port(s->dev, s->port, sizeof(s->port));\n\n\n\n    usb_ep_init(udev);\n\n    usb_host_ep_update(s);\n\n\n\n    udev->speed     = speed_map[libusb_get_device_speed(dev)];\n\n    usb_host_speed_compat(s);\n\n\n\n    if (s->ddesc.iProduct) {\n\n        libusb_get_string_descriptor_ascii(s->dh, s->ddesc.iProduct,\n\n                                           (unsigned char *)udev->product_desc,\n\n                                           sizeof(udev->product_desc));\n\n    } else {\n\n        snprintf(udev->product_desc, sizeof(udev->product_desc),\n\n                 \"host:%d.%d\", bus_num, addr);\n\n    }\n\n\n\n    rc = usb_device_attach(udev);\n\n    if (rc) {\n\n        goto fail;\n\n    }\n\n\n\n    trace_usb_host_open_success(bus_num, addr);\n\n    return 0;\n\n\n\nfail:\n\n    trace_usb_host_open_failure(bus_num, addr);\n\n    if (s->dh != NULL) {\n\n        libusb_close(s->dh);\n\n        s->dh = NULL;\n\n        s->dev = NULL;\n\n    }\n\n    return -1;\n\n}\n", "idx": 23922, "_split": "test", "_hash": "f19c257d944a2642b654f16ce585ac5c"}
{"project": "qemu", "commit_id": "2a313e5cf6ed90b932b0abe2b4f2055785397f93", "target": 0, "func": "int64_t xbzrle_cache_resize(int64_t new_size, Error **errp)\n\n{\n\n    PageCache *new_cache;\n\n    int64_t ret;\n\n\n\n    /* Check for truncation */\n\n    if (new_size != (size_t)new_size) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                   \"exceeding address space\");\n\n        return -1;\n\n    }\n\n\n\n    /* Cache should not be larger than guest ram size */\n\n    if (new_size > ram_bytes_total()) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                   \"exceeds guest ram size\");\n\n        return -1;\n\n    }\n\n\n\n    XBZRLE_cache_lock();\n\n\n\n    if (XBZRLE.cache != NULL) {\n\n        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {\n\n            goto out_new_size;\n\n        }\n\n        new_cache = cache_init(new_size, TARGET_PAGE_SIZE, errp);\n\n        if (!new_cache) {\n\n            ret = -1;\n\n            goto out;\n\n        }\n\n\n\n        cache_fini(XBZRLE.cache);\n\n        XBZRLE.cache = new_cache;\n\n    }\n\n\n\nout_new_size:\n\n    ret = pow2floor(new_size);\n\nout:\n\n    XBZRLE_cache_unlock();\n\n    return ret;\n\n}\n", "idx": 23924, "_split": "test", "_hash": "e0d6947445386ce654fe8eda10c88fb8"}
{"project": "qemu", "commit_id": "b0fd8d18683f0d77a8e6b482771ebea82234d727", "target": 0, "func": "static void setup_rt_frame(int sig, struct target_sigaction *ka,\n\n                           target_siginfo_t *info,\n\n                           target_sigset_t *set, CPUAlphaState *env)\n\n{\n\n    abi_ulong frame_addr, r26;\n\n    struct target_rt_sigframe *frame;\n\n    int i, err = 0;\n\n\n\n    frame_addr = get_sigframe(ka, env, sizeof(*frame));\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {\n\n        goto give_sigsegv;\n\n    }\n\n\n\n    err |= copy_siginfo_to_user(&frame->info, info);\n\n\n\n    __put_user(0, &frame->uc.tuc_flags);\n\n    __put_user(0, &frame->uc.tuc_link);\n\n    __put_user(set->sig[0], &frame->uc.tuc_osf_sigmask);\n\n    __put_user(target_sigaltstack_used.ss_sp,\n\n               &frame->uc.tuc_stack.ss_sp);\n\n    __put_user(sas_ss_flags(env->ir[IR_SP]),\n\n               &frame->uc.tuc_stack.ss_flags);\n\n    __put_user(target_sigaltstack_used.ss_size,\n\n               &frame->uc.tuc_stack.ss_size);\n\n    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);\n\n    for (i = 0; i < TARGET_NSIG_WORDS; ++i) {\n\n        __put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]);\n\n    }\n\n\n\n    if (ka->sa_restorer) {\n\n        r26 = ka->sa_restorer;\n\n    } else {\n\n        __put_user(INSN_MOV_R30_R16, &frame->retcode[0]);\n\n        __put_user(INSN_LDI_R0 + TARGET_NR_rt_sigreturn,\n\n                   &frame->retcode[1]);\n\n        __put_user(INSN_CALLSYS, &frame->retcode[2]);\n\n        /* imb(); */\n\n        r26 = frame_addr;\n\n    }\n\n\n\n    if (err) {\n\n    give_sigsegv:\n\n       if (sig == TARGET_SIGSEGV) {\n\n            ka->_sa_handler = TARGET_SIG_DFL;\n\n        }\n\n        force_sig(TARGET_SIGSEGV);\n\n    }\n\n\n\n    env->ir[IR_RA] = r26;\n\n    env->ir[IR_PV] = env->pc = ka->_sa_handler;\n\n    env->ir[IR_A0] = sig;\n\n    env->ir[IR_A1] = frame_addr + offsetof(struct target_rt_sigframe, info);\n\n    env->ir[IR_A2] = frame_addr + offsetof(struct target_rt_sigframe, uc);\n\n    env->ir[IR_SP] = frame_addr;\n\n}\n", "idx": 23933, "_split": "test", "_hash": "3a4b83cadf3977402195446059842227"}
{"project": "qemu", "commit_id": "203d65a4706be345c209f3408d3a011a3e48f0c9", "target": 0, "func": "static void imx_gpt_reset(DeviceState *dev)\n\n{\n\n    IMXGPTState *s = IMX_GPT(dev);\n\n\n\n    /* stop timer */\n\n    ptimer_stop(s->timer);\n\n\n\n    /*\n\n     * Soft reset doesn't touch some bits; hard reset clears them\n\n     */\n\n    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|\n\n               GPT_CR_WAITEN|GPT_CR_DBGEN);\n\n    s->sr = 0;\n\n    s->pr = 0;\n\n    s->ir = 0;\n\n    s->cnt = 0;\n\n    s->ocr1 = TIMER_MAX;\n\n    s->ocr2 = TIMER_MAX;\n\n    s->ocr3 = TIMER_MAX;\n\n    s->icr1 = 0;\n\n    s->icr2 = 0;\n\n\n\n    s->next_timeout = TIMER_MAX;\n\n    s->next_int = 0;\n\n\n\n    /* compute new freq */\n\n    imx_gpt_set_freq(s);\n\n\n\n    /* reset the limit to TIMER_MAX */\n\n    ptimer_set_limit(s->timer, TIMER_MAX, 1);\n\n\n\n    /* if the timer is still enabled, restart it */\n\n    if (s->freq && (s->cr & GPT_CR_EN)) {\n\n        ptimer_run(s->timer, 1);\n\n    }\n\n}\n", "idx": 23938, "_split": "test", "_hash": "7dd52ca871903a67c84f98de58210f1c"}
{"project": "qemu", "commit_id": "9ed415b28b0c808e8b0fc631902cb9ce277f0245", "target": 1, "func": "static int dynticks_start_timer(struct qemu_alarm_timer *t)\n\n{\n\n    struct sigevent ev;\n\n    timer_t host_timer;\n\n    struct sigaction act;\n\n\n\n    sigfillset(&act.sa_mask);\n\n    act.sa_flags = 0;\n\n    act.sa_handler = host_alarm_handler;\n\n\n\n    sigaction(SIGALRM, &act, NULL);\n\n\n\n\n\n\n\n\n    ev.sigev_value.sival_int = 0;\n\n    ev.sigev_notify = SIGEV_SIGNAL;\n\n    ev.sigev_signo = SIGALRM;\n\n\n\n    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {\n\n        perror(\"timer_create\");\n\n\n\n        /* disable dynticks */\n\n        fprintf(stderr, \"Dynamic Ticks disabled\\n\");\n\n\n\n        return -1;\n\n    }\n\n\n\n    t->priv = (void *)(long)host_timer;\n\n\n\n    return 0;\n\n}", "idx": 23942, "_split": "test", "_hash": "73c76836fcdf465c377ae549dd8decd3"}
{"project": "qemu", "commit_id": "b7022d9ac61311f92aef0994e2ab801b76d55f14", "target": 1, "func": "static void s390_pci_generate_event(uint8_t cc, uint16_t pec, uint32_t fh,\n\n                                    uint32_t fid, uint64_t faddr, uint32_t e)\n\n{\n\n    SeiContainer *sei_cont = g_malloc0(sizeof(SeiContainer));\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(\n\n        object_resolve_path(TYPE_S390_PCI_HOST_BRIDGE, NULL));\n\n\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    sei_cont->fh = fh;\n\n    sei_cont->fid = fid;\n\n    sei_cont->cc = cc;\n\n    sei_cont->pec = pec;\n\n    sei_cont->faddr = faddr;\n\n    sei_cont->e = e;\n\n\n\n    QTAILQ_INSERT_TAIL(&s->pending_sei, sei_cont, link);\n\n    css_generate_css_crws(0);\n\n}\n", "idx": 23947, "_split": "test", "_hash": "f37b41d57da4696eb0ad2e271f1ebc60"}
{"project": "qemu", "commit_id": "81907a582901671c15be36a63b5063f88f3487e2", "target": 1, "func": "void cpsr_write(CPUARMState *env, uint32_t val, uint32_t mask,\n\n                CPSRWriteType write_type)\n\n{\n\n    uint32_t changed_daif;\n\n\n\n    if (mask & CPSR_NZCV) {\n\n        env->ZF = (~val) & CPSR_Z;\n\n        env->NF = val;\n\n        env->CF = (val >> 29) & 1;\n\n        env->VF = (val << 3) & 0x80000000;\n\n    }\n\n    if (mask & CPSR_Q)\n\n        env->QF = ((val & CPSR_Q) != 0);\n\n    if (mask & CPSR_T)\n\n        env->thumb = ((val & CPSR_T) != 0);\n\n    if (mask & CPSR_IT_0_1) {\n\n        env->condexec_bits &= ~3;\n\n        env->condexec_bits |= (val >> 25) & 3;\n\n    }\n\n    if (mask & CPSR_IT_2_7) {\n\n        env->condexec_bits &= 3;\n\n        env->condexec_bits |= (val >> 8) & 0xfc;\n\n    }\n\n    if (mask & CPSR_GE) {\n\n        env->GE = (val >> 16) & 0xf;\n\n    }\n\n\n\n    /* In a V7 implementation that includes the security extensions but does\n\n     * not include Virtualization Extensions the SCR.FW and SCR.AW bits control\n\n     * whether non-secure software is allowed to change the CPSR_F and CPSR_A\n\n     * bits respectively.\n\n     *\n\n     * In a V8 implementation, it is permitted for privileged software to\n\n     * change the CPSR A/F bits regardless of the SCR.AW/FW bits.\n\n     */\n\n    if (write_type != CPSRWriteRaw && !arm_feature(env, ARM_FEATURE_V8) &&\n\n        arm_feature(env, ARM_FEATURE_EL3) &&\n\n        !arm_feature(env, ARM_FEATURE_EL2) &&\n\n        !arm_is_secure(env)) {\n\n\n\n        changed_daif = (env->daif ^ val) & mask;\n\n\n\n        if (changed_daif & CPSR_A) {\n\n            /* Check to see if we are allowed to change the masking of async\n\n             * abort exceptions from a non-secure state.\n\n             */\n\n            if (!(env->cp15.scr_el3 & SCR_AW)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Ignoring attempt to switch CPSR_A flag from \"\n\n                              \"non-secure world with SCR.AW bit clear\\n\");\n\n                mask &= ~CPSR_A;\n\n            }\n\n        }\n\n\n\n        if (changed_daif & CPSR_F) {\n\n            /* Check to see if we are allowed to change the masking of FIQ\n\n             * exceptions from a non-secure state.\n\n             */\n\n            if (!(env->cp15.scr_el3 & SCR_FW)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Ignoring attempt to switch CPSR_F flag from \"\n\n                              \"non-secure world with SCR.FW bit clear\\n\");\n\n                mask &= ~CPSR_F;\n\n            }\n\n\n\n            /* Check whether non-maskable FIQ (NMFI) support is enabled.\n\n             * If this bit is set software is not allowed to mask\n\n             * FIQs, but is allowed to set CPSR_F to 0.\n\n             */\n\n            if ((A32_BANKED_CURRENT_REG_GET(env, sctlr) & SCTLR_NMFI) &&\n\n                (val & CPSR_F)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Ignoring attempt to enable CPSR_F flag \"\n\n                              \"(non-maskable FIQ [NMFI] support enabled)\\n\");\n\n                mask &= ~CPSR_F;\n\n            }\n\n        }\n\n    }\n\n\n\n    env->daif &= ~(CPSR_AIF & mask);\n\n    env->daif |= val & CPSR_AIF & mask;\n\n\n\n    if (write_type != CPSRWriteRaw &&\n\n        (env->uncached_cpsr & CPSR_M) != CPSR_USER &&\n\n        ((env->uncached_cpsr ^ val) & mask & CPSR_M)) {\n\n        if (bad_mode_switch(env, val & CPSR_M)) {\n\n            /* Attempt to switch to an invalid mode: this is UNPREDICTABLE.\n\n             * We choose to ignore the attempt and leave the CPSR M field\n\n             * untouched.\n\n             */\n\n            mask &= ~CPSR_M;\n\n        } else {\n\n            switch_mode(env, val & CPSR_M);\n\n        }\n\n    }\n\n    mask &= ~CACHED_CPSR_BITS;\n\n    env->uncached_cpsr = (env->uncached_cpsr & ~mask) | (val & mask);\n\n}\n", "idx": 23956, "_split": "test", "_hash": "2cb2ac4079b7f2266d4aac6bb8579330"}
{"project": "qemu", "commit_id": "bdd81addf4033ce26e6cd180b060f63095f3ded9", "target": 1, "func": "static void vfio_probe_nvidia_bar0_quirk(VFIOPCIDevice *vdev, int nr)\n\n{\n\n    VFIOQuirk *quirk;\n\n    VFIOConfigMirrorQuirk *mirror;\n\n\n\n    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID) ||\n\n        !vfio_is_vga(vdev) || nr != 0) {\n\n        return;\n\n    }\n\n\n\n    quirk = g_malloc0(sizeof(*quirk));\n\n    mirror = quirk->data = g_malloc0(sizeof(*mirror));\n\n    mirror->mem = quirk->mem = g_malloc0(sizeof(MemoryRegion));\n\n    quirk->nr_mem = 1;\n\n    mirror->vdev = vdev;\n\n    mirror->offset = 0x88000;\n\n    mirror->bar = nr;\n\n\n\n    memory_region_init_io(mirror->mem, OBJECT(vdev),\n\n                          &vfio_nvidia_mirror_quirk, mirror,\n\n                          \"vfio-nvidia-bar0-88000-mirror-quirk\",\n\n                          PCIE_CONFIG_SPACE_SIZE);\n\n    memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                        mirror->offset, mirror->mem, 1);\n\n\n\n    QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);\n\n\n\n    /* The 0x1800 offset mirror only seems to get used by legacy VGA */\n\n    if (vdev->has_vga) {\n\n        quirk = g_malloc0(sizeof(*quirk));\n\n        mirror = quirk->data = g_malloc0(sizeof(*mirror));\n\n        mirror->mem = quirk->mem = g_malloc0(sizeof(MemoryRegion));\n\n        quirk->nr_mem = 1;\n\n        mirror->vdev = vdev;\n\n        mirror->offset = 0x1800;\n\n        mirror->bar = nr;\n\n\n\n        memory_region_init_io(mirror->mem, OBJECT(vdev),\n\n                              &vfio_nvidia_mirror_quirk, mirror,\n\n                              \"vfio-nvidia-bar0-1800-mirror-quirk\",\n\n                              PCI_CONFIG_SPACE_SIZE);\n\n        memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                            mirror->offset, mirror->mem, 1);\n\n\n\n        QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);\n\n    }\n\n\n\n    trace_vfio_quirk_nvidia_bar0_probe(vdev->vbasedev.name);\n\n}\n", "idx": 23965, "_split": "test", "_hash": "1e267d6b1360861a9912d60266be9c3c"}
{"project": "qemu", "commit_id": "8e7a6db96566fe4162edaeb3e8b62fc8004d1598", "target": 1, "func": "static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,\n\n                                           TCGv arg1, TCGv arg2, int sub)\n\n{\n\n    TCGv t0 = tcg_temp_new();\n\n\n\n    tcg_gen_xor_tl(cpu_ov, arg0, arg1);\n\n    tcg_gen_xor_tl(t0, arg1, arg2);\n\n    if (sub) {\n\n        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);\n\n    } else {\n\n        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);\n\n    }\n\n    tcg_temp_free(t0);\n\n    if (NARROW_MODE(ctx)) {\n\n        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);\n\n    }\n\n    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);\n\n    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);\n\n}\n", "idx": 24009, "_split": "test", "_hash": "e4a6568979d516bf9700a91e67ba1451"}
{"project": "qemu", "commit_id": "2cd53943115be5118b5b2d4b80ee0a39c94c4f73", "target": 0, "func": "static void cpu_common_reset(CPUState *cpu)\n\n{\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_RESET)) {\n\n        qemu_log(\"CPU Reset (CPU %d)\\n\", cpu->cpu_index);\n\n        log_cpu_state(cpu, cc->reset_dump_flags);\n\n    }\n\n\n\n    cpu->interrupt_request = 0;\n\n    cpu->halted = 0;\n\n    cpu->mem_io_pc = 0;\n\n    cpu->mem_io_vaddr = 0;\n\n    cpu->icount_extra = 0;\n\n    cpu->icount_decr.u32 = 0;\n\n    cpu->can_do_io = 1;\n\n    cpu->exception_index = -1;\n\n    cpu->crash_occurred = false;\n\n\n\n    if (tcg_enabled()) {\n\n        cpu_tb_jmp_cache_clear(cpu);\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n        tlb_flush(cpu, 0);\n\n#endif\n\n    }\n\n}\n", "idx": 24044, "_split": "test", "_hash": "208fc41dbfcb842be7bb544fe4bfcbe1"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,\n\n                      int abort_on_failure)\n\n{\n\n    QemuOpts *opts;\n\n    int rc = 0;\n\n\n\n    TAILQ_FOREACH(opts, &list->head, next) {\n\n        rc = func(opts, opaque);\n\n        if (abort_on_failure  &&  rc != 0)\n\n            break;\n\n    }\n\n    return rc;\n\n}\n", "idx": 24047, "_split": "test", "_hash": "56f4f7a562461aa68a26451647d4046e"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void subpage_write(void *opaque, target_phys_addr_t addr,\n\n                          uint64_t value, unsigned len)\n\n{\n\n    subpage_t *mmio = opaque;\n\n    unsigned int idx = SUBPAGE_IDX(addr);\n\n    MemoryRegionSection *section;\n\n#if defined(DEBUG_SUBPAGE)\n\n    printf(\"%s: subpage %p len %d addr \" TARGET_FMT_plx\n\n           \" idx %d value %\"PRIx64\"\\n\",\n\n           __func__, mmio, len, addr, idx, value);\n\n#endif\n\n\n\n    section = &phys_sections[mmio->sub_section[idx]];\n\n    addr += mmio->base;\n\n    addr -= section->offset_within_address_space;\n\n    addr += section->offset_within_region;\n\n    io_mem_write(section->mr, addr, value, len);\n\n}\n", "idx": 24050, "_split": "test", "_hash": "c0fa3a2c9ef014c63c8443883545f90b"}
{"project": "qemu", "commit_id": "f3ced3c59287dabc253f83f0c70aa4934470c15e", "target": 1, "func": "void tb_flush_jmp_cache(CPUState *cpu, target_ulong addr)\n\n{\n\n    unsigned int i;\n\n\n\n    /* Discard jump cache entries for any tb which might potentially\n\n       overlap the flushed page.  */\n\n    i = tb_jmp_cache_hash_page(addr - TARGET_PAGE_SIZE);\n\n    memset(&cpu->tb_jmp_cache[i], 0,\n\n           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));\n\n\n\n    i = tb_jmp_cache_hash_page(addr);\n\n    memset(&cpu->tb_jmp_cache[i], 0,\n\n           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));\n\n}\n", "idx": 24075, "_split": "test", "_hash": "53719549d4ae96206de637e75ecb4989"}
{"project": "qemu", "commit_id": "fa879d62eb51253d00b6920ce1d1d9d261370a49", "target": 0, "func": "DeviceState *bdrv_get_attached(BlockDriverState *bs)\n\n{\n\n    return bs->peer;\n\n}\n", "idx": 24084, "_split": "test", "_hash": "1d39664710fe4f8e8769f5983b323f37"}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)\n\n{\n\n    StackEntry *e = g_malloc0(sizeof(*e));\n\n\n\n    e->value = value;\n\n\n\n    /* see if we're just pushing a list head tracker */\n\n    if (value == NULL) {\n\n        e->is_list_head = true;\n\n    }\n\n    QTAILQ_INSERT_HEAD(&qov->stack, e, node);\n\n}\n", "idx": 24085, "_split": "test", "_hash": "604382b60031e8b67989456fe7bb6826"}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "void *vnc_zlib_zalloc(void *x, unsigned items, unsigned size)\n\n{\n\n    void *p;\n\n\n\n    size *= items;\n\n    size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);\n\n\n\n    p = qemu_mallocz(size);\n\n\n\n    return (p);\n\n}\n", "idx": 24087, "_split": "test", "_hash": "6be87088bbf0cf551b355601665753d5"}
{"project": "qemu", "commit_id": "bc210eb163b162ff2e94e5c8f4307715731257f8", "target": 0, "func": "static int send_png_rect(VncState *vs, int x, int y, int w, int h,\n\n                         VncPalette *palette)\n\n{\n\n    png_byte color_type;\n\n    png_structp png_ptr;\n\n    png_infop info_ptr;\n\n    png_colorp png_palette = NULL;\n\n    pixman_image_t *linebuf;\n\n    int level = tight_png_conf[vs->tight.compression].png_zlib_level;\n\n    int filters = tight_png_conf[vs->tight.compression].png_filters;\n\n    uint8_t *buf;\n\n    int dy;\n\n\n\n    png_ptr = png_create_write_struct_2(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL,\n\n                                        NULL, vnc_png_malloc, vnc_png_free);\n\n\n\n    if (png_ptr == NULL)\n\n        return -1;\n\n\n\n    info_ptr = png_create_info_struct(png_ptr);\n\n\n\n    if (info_ptr == NULL) {\n\n        png_destroy_write_struct(&png_ptr, NULL);\n\n        return -1;\n\n    }\n\n\n\n    png_set_write_fn(png_ptr, (void *) vs, png_write_data, png_flush_data);\n\n    png_set_compression_level(png_ptr, level);\n\n    png_set_filter(png_ptr, PNG_FILTER_TYPE_DEFAULT, filters);\n\n\n\n    if (palette) {\n\n        color_type = PNG_COLOR_TYPE_PALETTE;\n\n    } else {\n\n        color_type = PNG_COLOR_TYPE_RGB;\n\n    }\n\n\n\n    png_set_IHDR(png_ptr, info_ptr, w, h,\n\n                 8, color_type, PNG_INTERLACE_NONE,\n\n                 PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);\n\n\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        struct palette_cb_priv priv;\n\n\n\n        png_palette = png_malloc(png_ptr, sizeof(*png_palette) *\n\n                                 palette_size(palette));\n\n\n\n        priv.vs = vs;\n\n        priv.png_palette = png_palette;\n\n        palette_iter(palette, write_png_palette, &priv);\n\n\n\n        png_set_PLTE(png_ptr, info_ptr, png_palette, palette_size(palette));\n\n\n\n        if (vs->client_pf.bytes_per_pixel == 4) {\n\n            tight_encode_indexed_rect32(vs->tight.tight.buffer, w * h, palette);\n\n        } else {\n\n            tight_encode_indexed_rect16(vs->tight.tight.buffer, w * h, palette);\n\n        }\n\n    }\n\n\n\n    png_write_info(png_ptr, info_ptr);\n\n\n\n    buffer_reserve(&vs->tight.png, 2048);\n\n    linebuf = qemu_pixman_linebuf_create(PIXMAN_BE_r8g8b8, w);\n\n    buf = (uint8_t *)pixman_image_get_data(linebuf);\n\n    for (dy = 0; dy < h; dy++)\n\n    {\n\n        if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n            memcpy(buf, vs->tight.tight.buffer + (dy * w), w);\n\n        } else {\n\n            qemu_pixman_linebuf_fill(linebuf, vs->vd->server, w, dy);\n\n        }\n\n        png_write_row(png_ptr, buf);\n\n    }\n\n    qemu_pixman_image_unref(linebuf);\n\n\n\n    png_write_end(png_ptr, NULL);\n\n\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        png_free(png_ptr, png_palette);\n\n    }\n\n\n\n    png_destroy_write_struct(&png_ptr, &info_ptr);\n\n\n\n    vnc_write_u8(vs, VNC_TIGHT_PNG << 4);\n\n\n\n    tight_send_compact_size(vs, vs->tight.png.offset);\n\n    vnc_write(vs, vs->tight.png.buffer, vs->tight.png.offset);\n\n    buffer_reset(&vs->tight.png);\n\n    return 1;\n\n}\n", "idx": 24090, "_split": "test", "_hash": "73b11b39ee3c845289b1a56ad2056789"}
{"project": "qemu", "commit_id": "35c5a52d1d016c632aed6137549754ca53446c92", "target": 0, "func": "void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,\n\n                            FWCfgState *fw_cfg, Object *owner)\n\n{\n\n    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,\n\n                          \"nvdimm-acpi-io\", NVDIMM_ACPI_IO_LEN);\n\n    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);\n\n\n\n    state->dsm_mem = g_array_new(false, true /* clear */, 1);\n\n    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);\n\n    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,\n\n                    state->dsm_mem->len);\n\n}\n", "idx": 24100, "_split": "test", "_hash": "6aff6eb0654442aaa00424e12b755591"}
{"project": "qemu", "commit_id": "8a5bb1f114c5959cf6b247a737394afb0c518b40", "target": 0, "func": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                               BdrvCheckMode fix, bool *rebuild,\n\n                               void **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    if (!*refcount_table) {\n\n        int64_t old_size = 0;\n\n        ret = realloc_refcount_array(s, refcount_table,\n\n                                     &old_size, *nb_clusters);\n\n        if (ret < 0) {\n\n            res->check_errors++;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* header */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* snapshots */\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* refcount data */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* encryption */\n\n    if (s->crypto_header.length) {\n\n        ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                            s->crypto_header.offset,\n\n                            s->crypto_header.length);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);\n\n}\n", "idx": 24103, "_split": "test", "_hash": "3c5b031a38aa08dfe5b903825565af17"}
{"project": "qemu", "commit_id": "025b168ca674e42896c573fdbddf3090c6dc0d8f", "target": 1, "func": "static void ehci_trace_qtd(EHCIQueue *q, target_phys_addr_t addr, EHCIqtd *qtd)\n\n{\n\n    trace_usb_ehci_qtd(q, addr, qtd->next, qtd->altnext,\n\n                       get_field(qtd->token, QTD_TOKEN_TBYTES),\n\n                       get_field(qtd->token, QTD_TOKEN_CPAGE),\n\n                       get_field(qtd->token, QTD_TOKEN_CERR),\n\n                       get_field(qtd->token, QTD_TOKEN_PID),\n\n                       (bool)(qtd->token & QTD_TOKEN_IOC),\n\n                       (bool)(qtd->token & QTD_TOKEN_ACTIVE),\n\n                       (bool)(qtd->token & QTD_TOKEN_HALT),\n\n                       (bool)(qtd->token & QTD_TOKEN_BABBLE),\n\n                       (bool)(qtd->token & QTD_TOKEN_XACTERR));\n\n}\n", "idx": 24123, "_split": "test", "_hash": "e9250b7ce83da7a6053517311e07fcc1"}
{"project": "qemu", "commit_id": "afea4e1410654154018587dd35c1b250ba4d8ec4", "target": 1, "func": "static void megasas_scsi_uninit(PCIDevice *d)\n\n{\n\n    MegasasState *s = MEGASAS(d);\n\n\n\n    if (megasas_use_msix(s)) {\n\n        msix_uninit(d, &s->mmio_io, &s->mmio_io);\n\n    }\n\n    if (megasas_use_msi(s)) {\n\n        msi_uninit(d);\n\n    }\n\n}\n", "idx": 24141, "_split": "test", "_hash": "09c4b83e2fb5be28e012e91af65dead3"}
{"project": "qemu", "commit_id": "a22313deca720e038ebc5805cf451b3a685d29ce", "target": 0, "func": "static void vfio_platform_eoi(VFIODevice *vbasedev)\n\n{\n\n    VFIOINTp *intp;\n\n    VFIOPlatformDevice *vdev =\n\n        container_of(vbasedev, VFIOPlatformDevice, vbasedev);\n\n\n\n    qemu_mutex_lock(&vdev->intp_mutex);\n\n    QLIST_FOREACH(intp, &vdev->intp_list, next) {\n\n        if (intp->state == VFIO_IRQ_ACTIVE) {\n\n            trace_vfio_platform_eoi(intp->pin,\n\n                                event_notifier_get_fd(&intp->interrupt));\n\n            intp->state = VFIO_IRQ_INACTIVE;\n\n\n\n            /* deassert the virtual IRQ */\n\n            qemu_set_irq(intp->qemuirq, 0);\n\n\n\n            if (intp->flags & VFIO_IRQ_INFO_AUTOMASKED) {\n\n                /* unmasks the physical level-sensitive IRQ */\n\n                vfio_unmask_single_irqindex(vbasedev, intp->pin);\n\n            }\n\n\n\n            /* a single IRQ can be active at a time */\n\n            break;\n\n        }\n\n    }\n\n    /* in case there are pending IRQs, handle the first one */\n\n    if (!QSIMPLEQ_EMPTY(&vdev->pending_intp_queue)) {\n\n        intp = QSIMPLEQ_FIRST(&vdev->pending_intp_queue);\n\n        vfio_intp_inject_pending_lockheld(intp);\n\n        QSIMPLEQ_REMOVE_HEAD(&vdev->pending_intp_queue, pqnext);\n\n    }\n\n    qemu_mutex_unlock(&vdev->intp_mutex);\n\n}\n", "idx": 24162, "_split": "test", "_hash": "4f688bcfe91e5edaf550db813d2c6859"}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n", "idx": 24164, "_split": "test", "_hash": "1555cd7b3273d20d3ec09d8186f1a573"}
{"project": "qemu", "commit_id": "29a6731afb20707ab0c1f9be997bef74cef34665", "target": 0, "func": "static void vararg_number(void)\n\n{\n\n    QObject *obj;\n\n    QInt *qint;\n\n    QFloat *qfloat;\n\n    int value = 0x2342;\n\n    int64_t value64 = 0x2342342343LL;\n\n    double valuef = 2.323423423;\n\n\n\n    obj = qobject_from_jsonf(\"%d\", value);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n\n\n    qint = qobject_to_qint(obj);\n\n    g_assert(qint_get_int(qint) == value);\n\n\n\n    QDECREF(qint);\n\n\n\n    obj = qobject_from_jsonf(\"%\" PRId64, value64);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n\n\n    qint = qobject_to_qint(obj);\n\n    g_assert(qint_get_int(qint) == value64);\n\n\n\n    QDECREF(qint);\n\n\n\n    obj = qobject_from_jsonf(\"%f\", valuef);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QFLOAT);\n\n\n\n    qfloat = qobject_to_qfloat(obj);\n\n    g_assert(qfloat_get_double(qfloat) == valuef);\n\n\n\n    QDECREF(qfloat);\n\n}\n", "idx": 24179, "_split": "test", "_hash": "f70a8c0185abc0115486c4d82a50fd45"}
{"project": "qemu", "commit_id": "95ed56939eb2eaa4e2f349fe6dcd13ca4edfd8fb", "target": 0, "func": "static int ohci_service_ed_list(OHCIState *ohci, uint32_t head, int completion)\n\n{\n\n    struct ohci_ed ed;\n\n    uint32_t next_ed;\n\n    uint32_t cur;\n\n    int active;\n\n\n\n    active = 0;\n\n\n\n    if (head == 0)\n\n        return 0;\n\n\n\n    for (cur = head; cur; cur = next_ed) {\n\n        if (ohci_read_ed(ohci, cur, &ed)) {\n\n            trace_usb_ohci_ed_read_error(cur);\n\n            ohci_die(ohci);\n\n            return 0;\n\n        }\n\n\n\n        next_ed = ed.next & OHCI_DPTR_MASK;\n\n\n\n        if ((ed.head & OHCI_ED_H) || (ed.flags & OHCI_ED_K)) {\n\n            uint32_t addr;\n\n            /* Cancel pending packets for ED that have been paused.  */\n\n            addr = ed.head & OHCI_DPTR_MASK;\n\n            if (ohci->async_td && addr == ohci->async_td) {\n\n                usb_cancel_packet(&ohci->usb_packet);\n\n                ohci->async_td = 0;\n\n                usb_device_ep_stopped(ohci->usb_packet.ep->dev,\n\n                                      ohci->usb_packet.ep);\n\n            }\n\n            continue;\n\n        }\n\n\n\n        while ((ed.head & OHCI_DPTR_MASK) != ed.tail) {\n\n            trace_usb_ohci_ed_pkt(cur, (ed.head & OHCI_ED_H) != 0,\n\n                    (ed.head & OHCI_ED_C) != 0, ed.head & OHCI_DPTR_MASK,\n\n                    ed.tail & OHCI_DPTR_MASK, ed.next & OHCI_DPTR_MASK);\n\n            trace_usb_ohci_ed_pkt_flags(\n\n                    OHCI_BM(ed.flags, ED_FA), OHCI_BM(ed.flags, ED_EN),\n\n                    OHCI_BM(ed.flags, ED_D), (ed.flags & OHCI_ED_S)!= 0,\n\n                    (ed.flags & OHCI_ED_K) != 0, (ed.flags & OHCI_ED_F) != 0,\n\n                    OHCI_BM(ed.flags, ED_MPS));\n\n\n\n            active = 1;\n\n\n\n            if ((ed.flags & OHCI_ED_F) == 0) {\n\n                if (ohci_service_td(ohci, &ed))\n\n                    break;\n\n            } else {\n\n                /* Handle isochronous endpoints */\n\n                if (ohci_service_iso_td(ohci, &ed, completion))\n\n                    break;\n\n            }\n\n        }\n\n\n\n        if (ohci_put_ed(ohci, cur, &ed)) {\n\n            ohci_die(ohci);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return active;\n\n}\n", "idx": 24200, "_split": "test", "_hash": "52eafa9a85272cf592990e664f3f2862"}
{"project": "qemu", "commit_id": "67d5cd9722b230027d3d4267ae6069c5d8a65463", "target": 0, "func": "void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)\n\n{\n\n    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);\n\n    object_unparent(OBJECT(&pbdev->iommu_mr));\n\n    pbdev->iommu_enabled = false;\n\n}\n", "idx": 24201, "_split": "test", "_hash": "7419ada7169bacc92cf356246e2d0f2a"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "uint8_t sd_read_data(SDState *sd)\n\n{\n\n    /* TODO: Append CRCs */\n\n    uint8_t ret;\n\n    int io_len;\n\n\n\n    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable)\n\n        return 0x00;\n\n\n\n    if (sd->state != sd_sendingdata_state) {\n\n        fprintf(stderr, \"sd_read_data: not in Sending-Data state\\n\");\n\n        return 0x00;\n\n    }\n\n\n\n    if (sd->card_status & (ADDRESS_ERROR | WP_VIOLATION))\n\n        return 0x00;\n\n\n\n    io_len = (sd->ocr & (1 << 30)) ? 512 : sd->blk_len;\n\n\n\n    switch (sd->current_cmd) {\n\n    case 6:\t/* CMD6:   SWITCH_FUNCTION */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 64)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 9:\t/* CMD9:   SEND_CSD */\n\n    case 10:\t/* CMD10:  SEND_CID */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 16)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 11:\t/* CMD11:  READ_DAT_UNTIL_STOP */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len) {\n\n            sd->data_start += io_len;\n\n            sd->data_offset = 0;\n\n            if (sd->data_start + io_len > sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 13:\t/* ACMD13: SD_STATUS */\n\n        ret = sd->sd_status[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sizeof(sd->sd_status))\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 17:\t/* CMD17:  READ_SINGLE_BLOCK */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 18:\t/* CMD18:  READ_MULTIPLE_BLOCK */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len) {\n\n            sd->data_start += io_len;\n\n            sd->data_offset = 0;\n\n            if (sd->data_start + io_len > sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 22:\t/* ACMD22: SEND_NUM_WR_BLOCKS */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 4)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 30:\t/* CMD30:  SEND_WRITE_PROT */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 4)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 51:\t/* ACMD51: SEND_SCR */\n\n        ret = sd->scr[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sizeof(sd->scr))\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 56:\t/* CMD56:  GEN_CMD */\n\n        if (sd->data_offset == 0)\n\n            APP_READ_BLOCK(sd->data_start, sd->blk_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sd->blk_len)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    default:\n\n        fprintf(stderr, \"sd_read_data: unknown command\\n\");\n\n        return 0x00;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24206, "_split": "test", "_hash": "e1ec22cef9a250bb2568057c98278c97"}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_int(TestOutputVisitorData *data,\n\n                                 const void *unused)\n\n{\n\n    int64_t value = -42;\n\n    QObject *obj;\n\n\n\n    visit_type_int(data->ov, NULL, &value, &error_abort);\n\n\n\n    obj = visitor_get(data);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);\n\n}\n", "idx": 24212, "_split": "test", "_hash": "6284bfe9f20f43e634311030dcbf01ef"}
{"project": "qemu", "commit_id": "9c12a6f24d8bfd0e0d81a4a77f515e32d15547c1", "target": 0, "func": "void net_slirp_hostfwd_remove(Monitor *mon, const char *src_str)\n\n{\n\n    struct in_addr host_addr = { .s_addr = INADDR_ANY };\n\n    int host_port;\n\n    char buf[256] = \"\";\n\n    const char *p = src_str;\n\n    int is_udp = 0;\n\n    int n;\n\n\n\n    if (!slirp_inited) {\n\n        monitor_printf(mon, \"user mode network stack not in use\\n\");\n\n        return;\n\n    }\n\n\n\n    if (!src_str || !src_str[0])\n\n        goto fail_syntax;\n\n\n\n    get_str_sep(buf, sizeof(buf), &p, ':');\n\n\n\n    if (!strcmp(buf, \"tcp\") || buf[0] == '\\0') {\n\n        is_udp = 0;\n\n    } else if (!strcmp(buf, \"udp\")) {\n\n        is_udp = 1;\n\n    } else {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (buf[0] != '\\0' && !inet_aton(buf, &host_addr)) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    host_port = atoi(p);\n\n\n\n    n = slirp_remove_hostfwd(is_udp, host_addr, host_port);\n\n\n\n    monitor_printf(mon, \"removed %d host forwarding rules for %s\\n\", n,\n\n                   src_str);\n\n    return;\n\n\n\n fail_syntax:\n\n    monitor_printf(mon, \"invalid format\\n\");\n\n}\n", "idx": 24213, "_split": "test", "_hash": "241f077fff5c3b873189675edf3e6144"}
{"project": "qemu", "commit_id": "ab0997e0afdcb272fd04784a280b2df46b0c759f", "target": 1, "func": "static int qcow2_co_readv(BlockDriverState *bs, int64_t sector_num,\n\n                          int remaining_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster, n1;\n\n    int ret;\n\n    int cur_nr_sectors; /* number of sectors in current iteration */\n\n    uint64_t cluster_offset = 0;\n\n    uint64_t bytes_done = 0;\n\n    QEMUIOVector hd_qiov;\n\n    uint8_t *cluster_data = NULL;\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (remaining_sectors != 0) {\n\n\n\n        /* prepare next request */\n\n        cur_nr_sectors = remaining_sectors;\n\n        if (s->crypt_method) {\n\n            cur_nr_sectors = MIN(cur_nr_sectors,\n\n                QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n        }\n\n\n\n        ret = qcow2_get_cluster_offset(bs, sector_num << 9,\n\n            &cur_nr_sectors, &cluster_offset);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (!cluster_offset) {\n\n\n\n            if (bs->backing_hd) {\n\n                /* read from the base image */\n\n                n1 = qcow2_backing_read1(bs->backing_hd, &hd_qiov,\n\n                    sector_num, cur_nr_sectors);\n\n                if (n1 > 0) {\n\n                    BLKDBG_EVENT(bs->file, BLKDBG_READ_BACKING_AIO);\n\n                    qemu_co_mutex_unlock(&s->lock);\n\n                    ret = bdrv_co_readv(bs->backing_hd, sector_num,\n\n                                        n1, &hd_qiov);\n\n                    qemu_co_mutex_lock(&s->lock);\n\n                    if (ret < 0) {\n\n                        goto fail;\n\n                    }\n\n                }\n\n            } else {\n\n                /* Note: in this case, no need to wait */\n\n                qemu_iovec_memset(&hd_qiov, 0, 512 * cur_nr_sectors);\n\n            }\n\n        } else if (cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n            /* add AIO support for compressed blocks ? */\n\n            ret = qcow2_decompress_cluster(bs, cluster_offset);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            qemu_iovec_from_buffer(&hd_qiov,\n\n                s->cluster_cache + index_in_cluster * 512,\n\n                512 * cur_nr_sectors);\n\n        } else {\n\n            if ((cluster_offset & 511) != 0) {\n\n                ret = -EIO;\n\n                goto fail;\n\n            }\n\n\n\n            if (s->crypt_method) {\n\n                /*\n\n                 * For encrypted images, read everything into a temporary\n\n                 * contiguous buffer on which the AES functions can work.\n\n                 */\n\n                if (!cluster_data) {\n\n                    cluster_data =\n\n                        g_malloc0(QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n                }\n\n\n\n                assert(cur_nr_sectors <=\n\n                    QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n                qemu_iovec_reset(&hd_qiov);\n\n                qemu_iovec_add(&hd_qiov, cluster_data,\n\n                    512 * cur_nr_sectors);\n\n            }\n\n\n\n            BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            ret = bdrv_co_readv(bs->file,\n\n                                (cluster_offset >> 9) + index_in_cluster,\n\n                                cur_nr_sectors, &hd_qiov);\n\n            qemu_co_mutex_lock(&s->lock);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n            if (s->crypt_method) {\n\n                qcow2_encrypt_sectors(s, sector_num,  cluster_data,\n\n                    cluster_data, cur_nr_sectors, 0, &s->aes_decrypt_key);\n\n                qemu_iovec_reset(&hd_qiov);\n\n                qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n                    cur_nr_sectors * 512);\n\n                qemu_iovec_from_buffer(&hd_qiov, cluster_data,\n\n                    512 * cur_nr_sectors);\n\n            }\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n\n\n\n    return ret;\n\n}", "idx": 24222, "_split": "test", "_hash": "cbee0aefd626726303e9c13d2198667b"}
{"project": "qemu", "commit_id": "728470bea15b11ba7b3e3db54f0d9939908e0e65", "target": 1, "func": "static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)\n\n{\n\n    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));\n\n\n\n    if (qemu_file_mode_is_not_valid(mode)) {\n\n        return NULL;\n\n    }\n\n\n\n    r->rdma = rdma;\n\n\n\n    if (mode[0] == 'w') {\n\n        r->file = qemu_fopen_ops(r, &rdma_write_ops);\n\n    } else {\n\n        r->file = qemu_fopen_ops(r, &rdma_read_ops);\n\n    }\n\n\n\n    return r->file;\n\n}\n", "idx": 24231, "_split": "test", "_hash": "6c0380e4fa01d25fdba3b7b173858ba5"}
{"project": "qemu", "commit_id": "f2b58c43758efc61e2a49b899f5e58848489d0dc", "target": 1, "func": "int v9fs_device_realize_common(V9fsState *s, Error **errp)\n\n{\n\n    int i, len;\n\n    struct stat stat;\n\n    FsDriverEntry *fse;\n\n    V9fsPath path;\n\n    int rc = 1;\n\n\n\n    /* initialize pdu allocator */\n\n    QLIST_INIT(&s->free_list);\n\n    QLIST_INIT(&s->active_list);\n\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n\n        QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next);\n\n        s->pdus[i].s = s;\n\n        s->pdus[i].idx = i;\n\n    }\n\n\n\n    v9fs_path_init(&path);\n\n\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n\n\n    if (!fse) {\n\n        /* We don't have a fsdev identified by fsdev_id */\n\n        error_setg(errp, \"9pfs device couldn't find fsdev with the \"\n\n                   \"id = %s\",\n\n                   s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n\n        goto out;\n\n    }\n\n\n\n    if (!s->fsconf.tag) {\n\n        /* we haven't specified a mount_tag */\n\n        error_setg(errp, \"fsdev with id %s needs mount_tag arguments\",\n\n                   s->fsconf.fsdev_id);\n\n        goto out;\n\n    }\n\n\n\n    s->ctx.export_flags = fse->export_flags;\n\n    s->ctx.fs_root = g_strdup(fse->path);\n\n    s->ctx.exops.get_st_gen = NULL;\n\n    len = strlen(s->fsconf.tag);\n\n    if (len > MAX_TAG_LEN - 1) {\n\n        error_setg(errp, \"mount tag '%s' (%d bytes) is longer than \"\n\n                   \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n\n        goto out;\n\n    }\n\n\n\n    s->tag = g_strdup(s->fsconf.tag);\n\n    s->ctx.uid = -1;\n\n\n\n    s->ops = fse->ops;\n\n\n\n    s->fid_list = NULL;\n\n    qemu_co_rwlock_init(&s->rename_lock);\n\n\n\n    if (s->ops->init(&s->ctx) < 0) {\n\n        error_setg(errp, \"9pfs Failed to initialize fs-driver with id:%s\"\n\n                   \" and export path:%s\", s->fsconf.fsdev_id, s->ctx.fs_root);\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * Check details of export path, We need to use fs driver\n\n     * call back to do that. Since we are in the init path, we don't\n\n     * use co-routines here.\n\n     */\n\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n\n        error_setg(errp,\n\n                   \"error in converting name to path %s\", strerror(errno));\n\n        goto out;\n\n    }\n\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n\n        error_setg(errp, \"share path %s does not exist\", fse->path);\n\n        goto out;\n\n    } else if (!S_ISDIR(stat.st_mode)) {\n\n        error_setg(errp, \"share path %s is not a directory\", fse->path);\n\n        goto out;\n\n    }\n\n    v9fs_path_free(&path);\n\n\n\n    rc = 0;\n\nout:\n\n    if (rc) {\n\n        if (s->ops->cleanup && s->ctx.private) {\n\n            s->ops->cleanup(&s->ctx);\n\n        }\n\n        g_free(s->tag);\n\n        g_free(s->ctx.fs_root);\n\n        v9fs_path_free(&path);\n\n    }\n\n    return rc;\n\n}\n", "idx": 24280, "_split": "test", "_hash": "00bc7d553b23237f0bce977e9512cb47"}
{"project": "qemu", "commit_id": "a77fd4bb2988c05953fdc9f1524085870ec1c939", "target": 1, "func": "void bdrv_drain(BlockDriverState *bs)\n\n{\n\n    bool busy = true;\n\n\n\n    bdrv_drain_recurse(bs);\n\n\n\n\n\n    while (busy) {\n\n        /* Keep iterating */\n\n         bdrv_flush_io_queue(bs);\n\n         busy = bdrv_requests_pending(bs);\n\n         busy |= aio_poll(bdrv_get_aio_context(bs), busy);\n\n", "idx": 24292, "_split": "test", "_hash": "9d610bf83d4f952303346398fbf7ccac"}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "static void main_loop(void)\n\n{\n\n    bool nonblocking;\n\n    int last_io __attribute__ ((unused)) = 0;\n\n#ifdef CONFIG_PROFILER\n\n    int64_t ti;\n\n#endif\n\n    int r;\n\n\n\n    qemu_main_loop_start();\n\n\n\n    for (;;) {\n\n#ifdef CONFIG_IOTHREAD\n\n        nonblocking = !kvm_enabled() && last_io > 0;\n\n#else\n\n        nonblocking = cpu_exec_all();\n\n        if (vm_request_pending()) {\n\n            nonblocking = true;\n\n        }\n\n#endif\n\n#ifdef CONFIG_PROFILER\n\n        ti = profile_getclock();\n\n#endif\n\n        last_io = main_loop_wait(nonblocking);\n\n#ifdef CONFIG_PROFILER\n\n        dev_time += profile_getclock() - ti;\n\n#endif\n\n\n\n        if (qemu_debug_requested()) {\n\n            vm_stop(VMSTOP_DEBUG);\n\n        }\n\n        if (qemu_shutdown_requested()) {\n\n            qemu_kill_report();\n\n            monitor_protocol_event(QEVENT_SHUTDOWN, NULL);\n\n            if (no_shutdown) {\n\n                vm_stop(VMSTOP_SHUTDOWN);\n\n            } else\n\n                break;\n\n        }\n\n        if (qemu_reset_requested()) {\n\n            pause_all_vcpus();\n\n            cpu_synchronize_all_states();\n\n            qemu_system_reset(VMRESET_REPORT);\n\n            resume_all_vcpus();\n\n        }\n\n        if (qemu_powerdown_requested()) {\n\n            monitor_protocol_event(QEVENT_POWERDOWN, NULL);\n\n            qemu_irq_raise(qemu_system_powerdown);\n\n        }\n\n        if ((r = qemu_vmstop_requested())) {\n\n            vm_stop(r);\n\n        }\n\n    }\n\n    bdrv_close_all();\n\n    pause_all_vcpus();\n\n}\n", "idx": 24294, "_split": "test", "_hash": "63a1804c55777e9090de7e81a7838d63"}
{"project": "qemu", "commit_id": "0928a95ffe91862938cee997c9e30602fa7884ab", "target": 0, "func": "static void bootp_reply(const struct bootp_t *bp)\n\n{\n\n    BOOTPClient *bc = NULL;\n\n    struct mbuf *m;\n\n    struct bootp_t *rbp;\n\n    struct sockaddr_in saddr, daddr;\n\n    struct in_addr dns_addr;\n\n    const struct in_addr *preq_addr;\n\n    int dhcp_msg_type, val;\n\n    uint8_t *q;\n\n\n\n    /* extract exact DHCP msg type */\n\n    dhcp_decode(bp, &dhcp_msg_type, &preq_addr);\n\n    dprintf(\"bootp packet op=%d msgtype=%d\", bp->bp_op, dhcp_msg_type);\n\n    if (preq_addr)\n\n        dprintf(\" req_addr=%08x\\n\", ntohl(preq_addr->s_addr));\n\n    else\n\n        dprintf(\"\\n\");\n\n\n\n    if (dhcp_msg_type == 0)\n\n        dhcp_msg_type = DHCPREQUEST; /* Force reply for old BOOTP clients */\n\n\n\n    if (dhcp_msg_type != DHCPDISCOVER &&\n\n        dhcp_msg_type != DHCPREQUEST)\n\n        return;\n\n    /* XXX: this is a hack to get the client mac address */\n\n    memcpy(client_ethaddr, bp->bp_hwaddr, 6);\n\n\n\n    if ((m = m_get()) == NULL)\n\n        return;\n\n    m->m_data += IF_MAXLINKHDR;\n\n    rbp = (struct bootp_t *)m->m_data;\n\n    m->m_data += sizeof(struct udpiphdr);\n\n    memset(rbp, 0, sizeof(struct bootp_t));\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER) {\n\n        if (preq_addr) {\n\n            bc = request_addr(preq_addr, client_ethaddr);\n\n            if (bc) {\n\n                daddr.sin_addr = *preq_addr;\n\n            }\n\n        }\n\n        if (!bc) {\n\n         new_addr:\n\n            bc = get_new_addr(&daddr.sin_addr);\n\n            if (!bc) {\n\n                dprintf(\"no address left\\n\");\n\n                return;\n\n            }\n\n        }\n\n        memcpy(bc->macaddr, client_ethaddr, 6);\n\n    } else if (preq_addr) {\n\n        bc = request_addr(preq_addr, client_ethaddr);\n\n        if (bc) {\n\n            daddr.sin_addr = *preq_addr;\n\n            memcpy(bc->macaddr, client_ethaddr, 6);\n\n        } else {\n\n            daddr.sin_addr.s_addr = 0;\n\n        }\n\n    } else {\n\n        bc = find_addr(&daddr.sin_addr, bp->bp_hwaddr);\n\n        if (!bc) {\n\n            /* if never assigned, behaves as if it was already\n\n               assigned (windows fix because it remembers its address) */\n\n            goto new_addr;\n\n        }\n\n    }\n\n\n\n    saddr.sin_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_ALIAS);\n\n    saddr.sin_port = htons(BOOTP_SERVER);\n\n\n\n    daddr.sin_port = htons(BOOTP_CLIENT);\n\n\n\n    rbp->bp_op = BOOTP_REPLY;\n\n    rbp->bp_xid = bp->bp_xid;\n\n    rbp->bp_htype = 1;\n\n    rbp->bp_hlen = 6;\n\n    memcpy(rbp->bp_hwaddr, bp->bp_hwaddr, 6);\n\n\n\n    rbp->bp_yiaddr = daddr.sin_addr; /* Client IP address */\n\n    rbp->bp_siaddr = saddr.sin_addr; /* Server IP address */\n\n\n\n    q = rbp->bp_vend;\n\n    memcpy(q, rfc1533_cookie, 4);\n\n    q += 4;\n\n\n\n    if (bc) {\n\n        dprintf(\"%s addr=%08x\\n\",\n\n                (dhcp_msg_type == DHCPDISCOVER) ? \"offered\" : \"ack'ed\",\n\n                ntohl(daddr.sin_addr.s_addr));\n\n\n\n        if (dhcp_msg_type == DHCPDISCOVER) {\n\n            *q++ = RFC2132_MSG_TYPE;\n\n            *q++ = 1;\n\n            *q++ = DHCPOFFER;\n\n        } else /* DHCPREQUEST */ {\n\n            *q++ = RFC2132_MSG_TYPE;\n\n            *q++ = 1;\n\n            *q++ = DHCPACK;\n\n        }\n\n\n\n        if (bootp_filename)\n\n            snprintf((char *)rbp->bp_file, sizeof(rbp->bp_file), \"%s\",\n\n                     bootp_filename);\n\n\n\n        *q++ = RFC2132_SRV_ID;\n\n        *q++ = 4;\n\n        memcpy(q, &saddr.sin_addr, 4);\n\n        q += 4;\n\n\n\n        *q++ = RFC1533_NETMASK;\n\n        *q++ = 4;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0x00;\n\n\n\n        if (!slirp_restrict) {\n\n            *q++ = RFC1533_GATEWAY;\n\n            *q++ = 4;\n\n            memcpy(q, &saddr.sin_addr, 4);\n\n            q += 4;\n\n\n\n            *q++ = RFC1533_DNS;\n\n            *q++ = 4;\n\n            dns_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_DNS);\n\n            memcpy(q, &dns_addr, 4);\n\n            q += 4;\n\n        }\n\n\n\n        *q++ = RFC2132_LEASE_TIME;\n\n        *q++ = 4;\n\n        val = htonl(LEASE_TIME);\n\n        memcpy(q, &val, 4);\n\n        q += 4;\n\n\n\n        if (*slirp_hostname) {\n\n            val = strlen(slirp_hostname);\n\n            *q++ = RFC1533_HOSTNAME;\n\n            *q++ = val;\n\n            memcpy(q, slirp_hostname, val);\n\n            q += val;\n\n        }\n\n    } else {\n\n        static const char nak_msg[] = \"requested address not available\";\n\n\n\n        dprintf(\"nak'ed addr=%08x\\n\", ntohl(preq_addr->s_addr));\n\n\n\n        *q++ = RFC2132_MSG_TYPE;\n\n        *q++ = 1;\n\n        *q++ = DHCPNAK;\n\n\n\n        *q++ = RFC2132_MESSAGE;\n\n        *q++ = sizeof(nak_msg) - 1;\n\n        memcpy(q, nak_msg, sizeof(nak_msg) - 1);\n\n        q += sizeof(nak_msg) - 1;\n\n    }\n\n    *q++ = RFC1533_END;\n\n\n\n    daddr.sin_addr.s_addr = 0xffffffffu;\n\n\n\n    m->m_len = sizeof(struct bootp_t) -\n\n        sizeof(struct ip) - sizeof(struct udphdr);\n\n    udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);\n\n}\n", "idx": 24311, "_split": "test", "_hash": "a1de21a7744c9a3dfa56d5909e352a4c"}
{"project": "qemu", "commit_id": "9a78eead0c74333a394c0f7bbfc4423ac746fcd5", "target": 0, "func": "static void print_features(FILE *f,\n\n                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),\n\n                           uint32_t features, const char *prefix)\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < ARRAY_SIZE(feature_name); i++)\n\n        if (feature_name[i] && (features & (1 << i))) {\n\n            if (prefix)\n\n                (*cpu_fprintf)(f, \"%s\", prefix);\n\n            (*cpu_fprintf)(f, \"%s \", feature_name[i]);\n\n        }\n\n}\n", "idx": 24312, "_split": "test", "_hash": "cdc1ba491d4ea26f0cb1a13fc7185a0c"}
{"project": "qemu", "commit_id": "1a9353d258aba69afd8a389bf5fb705caab12ce0", "target": 0, "func": "int cpu_x86_gen_code(uint8_t *gen_code_buf, int max_code_size, \n\n                     int *gen_code_size_ptr, uint8_t *pc_start, \n\n                     int flags)\n\n{\n\n    DisasContext dc1, *dc = &dc1;\n\n    uint8_t *gen_code_end, *pc_ptr;\n\n    long ret;\n\n#ifdef DEBUG_DISAS\n\n    struct disassemble_info disasm_info;\n\n#endif\n\n    dc->code32 = (flags >> GEN_FLAG_CODE32_SHIFT) & 1;\n\n    dc->addseg = (flags >> GEN_FLAG_ADDSEG_SHIFT) & 1;\n\n    dc->f_st = (flags >> GEN_FLAG_ST_SHIFT) & 7;\n\n    dc->cc_op = CC_OP_DYNAMIC;\n\n    gen_code_ptr = gen_code_buf;\n\n    gen_code_end = gen_code_buf + max_code_size - 4096;\n\n    gen_start();\n\n\n\n    dc->is_jmp = 0;\n\n    pc_ptr = pc_start;\n\n    do {\n\n        ret = disas_insn(dc, pc_ptr);\n\n        if (ret == -1) \n\n            error(\"unknown instruction at PC=0x%x B=%02x %02x\", \n\n                  pc_ptr, pc_ptr[0], pc_ptr[1]);\n\n        pc_ptr = (void *)ret;\n\n    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);\n\n    /* we must store the eflags state if it is not already done */\n\n    if (dc->cc_op != CC_OP_DYNAMIC)\n\n        gen_op_set_cc_op(dc->cc_op);\n\n    if (dc->is_jmp != 1) {\n\n        /* we add an additionnal jmp to update the simulated PC */\n\n        gen_op_jmp_im(ret);\n\n    }\n\n    gen_end();\n\n    *gen_code_size_ptr = gen_code_ptr - gen_code_buf;\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel) {\n\n        uint8_t *pc;\n\n        int count;\n\n\n\n        INIT_DISASSEMBLE_INFO(disasm_info, logfile, fprintf);\n\n#if 0        \n\n        disasm_info.flavour = bfd_get_flavour (abfd);\n\n        disasm_info.arch = bfd_get_arch (abfd);\n\n        disasm_info.mach = bfd_get_mach (abfd);\n\n#endif\n\n#ifdef WORDS_BIGENDIAN\n\n        disasm_info.endian = BFD_ENDIAN_BIG;\n\n#else\n\n        disasm_info.endian = BFD_ENDIAN_LITTLE;\n\n#endif        \n\n        fprintf(logfile, \"IN:\\n\");\n\n        disasm_info.buffer = pc_start;\n\n        disasm_info.buffer_vma = (unsigned long)pc_start;\n\n        disasm_info.buffer_length = pc_ptr - pc_start;\n\n        pc = pc_start;\n\n        while (pc < pc_ptr) {\n\n            fprintf(logfile, \"0x%08lx:  \", (long)pc);\n\n            count = print_insn_i386((unsigned long)pc, &disasm_info);\n\n            fprintf(logfile, \"\\n\");\n\n            pc += count;\n\n        }\n\n        fprintf(logfile, \"\\n\");\n\n        \n\n        pc = gen_code_buf;\n\n        disasm_info.buffer = pc;\n\n        disasm_info.buffer_vma = (unsigned long)pc;\n\n        disasm_info.buffer_length = *gen_code_size_ptr;\n\n        fprintf(logfile, \"OUT: [size=%d]\\n\", *gen_code_size_ptr);\n\n        while (pc < gen_code_ptr) {\n\n            fprintf(logfile, \"0x%08lx:  \", (long)pc);\n\n            count = print_insn_i386((unsigned long)pc, &disasm_info);\n\n            fprintf(logfile, \"\\n\");\n\n            pc += count;\n\n        }\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 24315, "_split": "test", "_hash": "a427149195dbb0ad04b4671db992b3be"}
{"project": "qemu", "commit_id": "31478f26ab4ed82d35b763bbf259810d0c8b44e1", "target": 1, "func": "static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,\n\n                                            const char *name,\n\n                                            Error **errp)\n\n{\n\n    QObject *qobj;\n\n    QString *qstr;\n\n\n\n    qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    if (!qobj) {\n\n        return NULL;\n\n    }\n\n\n\n    qstr = qobject_to_qstring(qobj);\n\n    if (!qstr) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,\n\n                   full_name(qiv, name), \"string\");\n\n        return NULL;\n\n    }\n\n\n\n    return qstring_get_str(qstr);\n\n}\n", "idx": 24328, "_split": "test", "_hash": "f6b28b5f24a52910ed34522dd8653670"}
{"project": "qemu", "commit_id": "74b6ce43e3aacbb101018407196fc963e2c39fea", "target": 1, "func": "static void qio_channel_socket_finalize(Object *obj)\n{\n    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);\n    if (ioc->fd != -1) {\n#ifdef WIN32\n        WSAEventSelect(ioc->fd, NULL, 0);\n#endif\n        closesocket(ioc->fd);\n        ioc->fd = -1;", "idx": 24331, "_split": "test", "_hash": "a87ca2869ca55e6d8b3bfab1ad2ca236"}
{"project": "qemu", "commit_id": "c9add6219514b20223f024584f0464b8842b1ec0", "target": 1, "func": "bool ftrace_init(void)\n\n{\n\n    char mount_point[PATH_MAX];\n\n    char path[PATH_MAX];\n\n    int debugfs_found;\n\n    int trace_fd = -1;\n\n\n\n    debugfs_found = find_mount(mount_point, \"debugfs\");\n\n    if (debugfs_found) {\n\n        snprintf(path, PATH_MAX, \"%s/tracing/tracing_on\", mount_point);\n\n        trace_fd = open(path, O_WRONLY);\n\n        if (trace_fd < 0) {\n\n            if (errno == EACCES) {\n\n                trace_marker_fd = open(\"/dev/null\", O_WRONLY);\n\n                if (trace_marker_fd != -1) {\n\n                    return true;\n\n                }\n\n            }\n\n            perror(\"Could not open ftrace 'tracing_on' file\");\n\n            return false;\n\n        } else {\n\n            if (write(trace_fd, \"1\", 1) < 0) {\n\n                perror(\"Could not write to 'tracing_on' file\");\n\n                close(trace_fd);\n\n                return false;\n\n            }\n\n            close(trace_fd);\n\n        }\n\n        snprintf(path, PATH_MAX, \"%s/tracing/trace_marker\", mount_point);\n\n        trace_marker_fd = open(path, O_WRONLY);\n\n        if (trace_marker_fd < 0) {\n\n            perror(\"Could not open ftrace 'trace_marker' file\");\n\n            return false;\n\n        }\n\n    } else {\n\n        fprintf(stderr, \"debugfs is not mounted\\n\");\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 24351, "_split": "test", "_hash": "2a79e36afa4ced7cff94c6adf504a5be"}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_int(v, obj, name, errp);\n\n    }\n\n}\n", "idx": 24364, "_split": "test", "_hash": "5cd2dcfe5c840ca4d944ac954ccb4bae"}
{"project": "qemu", "commit_id": "240ce26a0533a6e5ee472789fbfbd9f7f939197e", "target": 1, "func": "static void gen_pool16c_insn(DisasContext *ctx, int *is_branch)\n\n{\n\n    int rd = mmreg((ctx->opcode >> 3) & 0x7);\n\n    int rs = mmreg(ctx->opcode & 0x7);\n\n    int opc;\n\n\n\n    switch (((ctx->opcode) >> 4) & 0x3f) {\n\n    case NOT16 + 0:\n\n    case NOT16 + 1:\n\n    case NOT16 + 2:\n\n    case NOT16 + 3:\n\n        gen_logic(ctx, OPC_NOR, rd, rs, 0);\n\n        break;\n\n    case XOR16 + 0:\n\n    case XOR16 + 1:\n\n    case XOR16 + 2:\n\n    case XOR16 + 3:\n\n        gen_logic(ctx, OPC_XOR, rd, rd, rs);\n\n        break;\n\n    case AND16 + 0:\n\n    case AND16 + 1:\n\n    case AND16 + 2:\n\n    case AND16 + 3:\n\n        gen_logic(ctx, OPC_AND, rd, rd, rs);\n\n        break;\n\n    case OR16 + 0:\n\n    case OR16 + 1:\n\n    case OR16 + 2:\n\n    case OR16 + 3:\n\n        gen_logic(ctx, OPC_OR, rd, rd, rs);\n\n        break;\n\n    case LWM16 + 0:\n\n    case LWM16 + 1:\n\n    case LWM16 + 2:\n\n    case LWM16 + 3:\n\n        {\n\n            static const int lwm_convert[] = { 0x11, 0x12, 0x13, 0x14 };\n\n            int offset = ZIMM(ctx->opcode, 0, 4);\n\n\n\n            gen_ldst_multiple(ctx, LWM32, lwm_convert[(ctx->opcode >> 4) & 0x3],\n\n                              29, offset << 2);\n\n        }\n\n        break;\n\n    case SWM16 + 0:\n\n    case SWM16 + 1:\n\n    case SWM16 + 2:\n\n    case SWM16 + 3:\n\n        {\n\n            static const int swm_convert[] = { 0x11, 0x12, 0x13, 0x14 };\n\n            int offset = ZIMM(ctx->opcode, 0, 4);\n\n\n\n            gen_ldst_multiple(ctx, SWM32, swm_convert[(ctx->opcode >> 4) & 0x3],\n\n                              29, offset << 2);\n\n        }\n\n        break;\n\n    case JR16 + 0:\n\n    case JR16 + 1:\n\n        {\n\n            int reg = ctx->opcode & 0x1f;\n\n\n\n            gen_compute_branch(ctx, OPC_JR, 2, reg, 0, 0);\n\n        }\n\n        *is_branch = 1;\n\n        break;\n\n    case JRC16 + 0:\n\n    case JRC16 + 1:\n\n        {\n\n            int reg = ctx->opcode & 0x1f;\n\n\n\n            gen_compute_branch(ctx, OPC_JR, 2, reg, 0, 0);\n\n            /* Let normal delay slot handling in our caller take us\n\n               to the branch target.  */\n\n        }\n\n        break;\n\n    case JALR16 + 0:\n\n    case JALR16 + 1:\n\n        opc = OPC_JALR;\n\n        goto do_jalr;\n\n    case JALR16S + 0:\n\n    case JALR16S + 1:\n\n        opc = OPC_JALRS;\n\n    do_jalr:\n\n        {\n\n            int reg = ctx->opcode & 0x1f;\n\n\n\n            gen_compute_branch(ctx, opc, 2, reg, 31, 0);\n\n        }\n\n        *is_branch = 1;\n\n        break;\n\n    case MFHI16 + 0:\n\n    case MFHI16 + 1:\n\n        gen_HILO(ctx, OPC_MFHI, 0, uMIPS_RS5(ctx->opcode));\n\n        break;\n\n    case MFLO16 + 0:\n\n    case MFLO16 + 1:\n\n        gen_HILO(ctx, OPC_MFLO, 0, uMIPS_RS5(ctx->opcode));\n\n        break;\n\n    case BREAK16:\n\n        generate_exception(ctx, EXCP_BREAK);\n\n        break;\n\n    case SDBBP16:\n\n        /* XXX: not clear which exception should be raised\n\n         *      when in debug mode...\n\n         */\n\n        check_insn(ctx, ISA_MIPS32);\n\n        if (!(ctx->hflags & MIPS_HFLAG_DM)) {\n\n            generate_exception(ctx, EXCP_DBp);\n\n        } else {\n\n            generate_exception(ctx, EXCP_DBp);\n\n        }\n\n        break;\n\n    case JRADDIUSP + 0:\n\n    case JRADDIUSP + 1:\n\n        {\n\n            int imm = ZIMM(ctx->opcode, 0, 5);\n\n\n\n            gen_compute_branch(ctx, OPC_JR, 2, 31, 0, 0);\n\n            gen_arith_imm(ctx, OPC_ADDIU, 29, 29, imm << 2);\n\n            /* Let normal delay slot handling in our caller take us\n\n               to the branch target.  */\n\n        }\n\n        break;\n\n    default:\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n}\n", "idx": 24483, "_split": "test", "_hash": "e2bc0a17f855713585d546f0c39d2ef2"}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,\n\n                            const void *data,\n\n                            size_t len) {\n\n    VncState *vs = (VncState *)transport;\n\n    int ret;\n\n\n\n retry:\n\n    ret = send(vs->csock, data, len, 0);\n\n    if (ret < 0) {\n\n        if (errno == EINTR)\n\n            goto retry;\n\n        return -1;\n\n    }\n\n    return ret;\n\n}\n", "idx": 24485, "_split": "test", "_hash": "77fb7813a1e5456a7de9082953da265e"}
{"project": "qemu", "commit_id": "4715d42efe8632b0f9d2594a80e917de45e4ef88", "target": 1, "func": "static void property_set_enum(Object *obj, Visitor *v, void *opaque,\n\n                              const char *name, Error **errp)\n\n{\n\n    EnumProperty *prop = opaque;\n\n    int value;\n\n\n\n    visit_type_enum(v, &value, prop->strings, NULL, name, errp);\n\n    prop->set(obj, value, errp);\n\n}\n", "idx": 24486, "_split": "test", "_hash": "076d5c30fd042e73c046bf9258702e95"}
{"project": "qemu", "commit_id": "bf18bee547d19fde314e7b6b81f21f68b46c8a92", "target": 0, "func": "void qmp_eject(const char *device, bool has_force, bool force, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    int rc;\n\n\n\n    if (!has_force) {\n\n        force = false;\n\n    }\n\n\n\n    rc = do_open_tray(device, force, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    if (rc == EINPROGRESS) {\n\n        error_setg(errp, \"Device '%s' is locked and force was not specified, \"\n\n                   \"wait for tray to open and try again\", device);\n\n        return;\n\n    }\n\n\n\n    qmp_x_blockdev_remove_medium(device, errp);\n\n}\n", "idx": 24501, "_split": "test", "_hash": "34b821e96a5010c004ce1deb624d9274"}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "int check_prot(int prot, int rw, int access_type)\n\n{\n\n    int ret;\n\n\n\n    if (access_type == ACCESS_CODE) {\n\n        if (prot & PAGE_EXEC) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else if (rw) {\n\n        if (prot & PAGE_WRITE) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else {\n\n        if (prot & PAGE_READ) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24508, "_split": "test", "_hash": "1b1afe698ca2908c4c508206ee366bb0"}
{"project": "qemu", "commit_id": "4545d4f4af8b29ba3b38dfb74d6f45342e15a62d", "target": 1, "func": "static int vmdk_write_extent(VmdkExtent *extent, int64_t cluster_offset,\n\n                            int64_t offset_in_cluster, QEMUIOVector *qiov,\n\n                            uint64_t qiov_offset, uint64_t n_bytes,\n\n                            uint64_t offset)\n\n{\n\n    int ret;\n\n    VmdkGrainMarker *data = NULL;\n\n    uLongf buf_len;\n\n    QEMUIOVector local_qiov;\n\n    struct iovec iov;\n\n    int64_t write_offset;\n\n    int64_t write_end_sector;\n\n\n\n    if (extent->compressed) {\n\n        void *compressed_data;\n\n\n\n        if (!extent->has_marker) {\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n        buf_len = (extent->cluster_sectors << 9) * 2;\n\n        data = g_malloc(buf_len + sizeof(VmdkGrainMarker));\n\n\n\n        compressed_data = g_malloc(n_bytes);\n\n        qemu_iovec_to_buf(qiov, qiov_offset, compressed_data, n_bytes);\n\n        ret = compress(data->data, &buf_len, compressed_data, n_bytes);\n\n        g_free(compressed_data);\n\n\n\n        if (ret != Z_OK || buf_len == 0) {\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n\n\n        data->lba = offset >> BDRV_SECTOR_BITS;\n\n        data->size = buf_len;\n\n\n\n        n_bytes = buf_len + sizeof(VmdkGrainMarker);\n\n        iov = (struct iovec) {\n\n            .iov_base   = data,\n\n            .iov_len    = n_bytes,\n\n        };\n\n        qemu_iovec_init_external(&local_qiov, &iov, 1);\n\n    } else {\n\n        qemu_iovec_init(&local_qiov, qiov->niov);\n\n        qemu_iovec_concat(&local_qiov, qiov, qiov_offset, n_bytes);\n\n    }\n\n\n\n    write_offset = cluster_offset + offset_in_cluster,\n\n    ret = bdrv_co_pwritev(extent->file, write_offset, n_bytes,\n\n                          &local_qiov, 0);\n\n\n\n    write_end_sector = DIV_ROUND_UP(write_offset + n_bytes, BDRV_SECTOR_SIZE);\n\n\n\n    if (extent->compressed) {\n\n        extent->next_cluster_sector = write_end_sector;\n\n    } else {\n\n        extent->next_cluster_sector = MAX(extent->next_cluster_sector,\n\n                                          write_end_sector);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n    ret = 0;\n\n out:\n\n    g_free(data);\n\n    if (!extent->compressed) {\n\n        qemu_iovec_destroy(&local_qiov);\n\n    }\n\n    return ret;\n\n}\n", "idx": 24540, "_split": "test", "_hash": "dc3adcaa6c75ddbaa79e8ea8dabd6cd7"}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static int get_monitor_def(target_long *pval, const char *name)\n\n{\n\n    const MonitorDef *md;\n\n    void *ptr;\n\n\n\n    for(md = monitor_defs; md->name != NULL; md++) {\n\n        if (compare_cmd(name, md->name)) {\n\n            if (md->get_value) {\n\n                *pval = md->get_value(md, md->offset);\n\n            } else {\n\n                CPUState *env = mon_get_cpu();\n\n                if (!env)\n\n                    return -2;\n\n                ptr = (uint8_t *)env + md->offset;\n\n                switch(md->type) {\n\n                case MD_I32:\n\n                    *pval = *(int32_t *)ptr;\n\n                    break;\n\n                case MD_TLONG:\n\n                    *pval = *(target_long *)ptr;\n\n                    break;\n\n                default:\n\n                    *pval = 0;\n\n                    break;\n\n                }\n\n            }\n\n            return 0;\n\n        }\n\n    }\n\n    return -1;\n\n}\n", "idx": 24559, "_split": "test", "_hash": "a69ad36e9fffaaddfd39078dd6029f62"}
{"project": "qemu", "commit_id": "5f9099d9cee0e9ed377aee705ca9f4db75e8948d", "target": 1, "func": "static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,\n                                 struct target_ucontext_v2 *uc)\n{\n    sigset_t host_set;\n    abi_ulong *regspace;\n    target_to_host_sigset(&host_set, &uc->tuc_sigmask);\n    sigprocmask(SIG_SETMASK, &host_set, NULL);\n    if (restore_sigcontext(env, &uc->tuc_mcontext))\n    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)\n#if 0\n    /* Send SIGTRAP if we're single-stepping */\n    if (ptrace_cancel_bpt(current))\n            send_sig(SIGTRAP, current, 1);\n#endif\n    return 0;", "idx": 24578, "_split": "test", "_hash": "57545fd7255be3a8beb5b94ba45cdc1b"}
{"project": "qemu", "commit_id": "619d11e4631000f20318dec90b87f314272bfa4a", "target": 0, "func": "FWCfgState *pc_memory_init(MemoryRegion *system_memory,\n\n                           const char *kernel_filename,\n\n                           const char *kernel_cmdline,\n\n                           const char *initrd_filename,\n\n                           ram_addr_t below_4g_mem_size,\n\n                           ram_addr_t above_4g_mem_size,\n\n                           MemoryRegion *rom_memory,\n\n                           MemoryRegion **ram_memory,\n\n                           PcGuestInfo *guest_info)\n\n{\n\n    int linux_boot, i;\n\n    MemoryRegion *ram, *option_rom_mr;\n\n    MemoryRegion *ram_below_4g, *ram_above_4g;\n\n    FWCfgState *fw_cfg;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* Allocate RAM.  We allocate it as a single memory region and use\n\n     * aliases to address portions of it, mostly for backwards compatibility\n\n     * with older qemus that used qemu_ram_alloc().\n\n     */\n\n    ram = g_malloc(sizeof(*ram));\n\n    memory_region_init_ram(ram, NULL, \"pc.ram\",\n\n                           below_4g_mem_size + above_4g_mem_size);\n\n    vmstate_register_ram_global(ram);\n\n    *ram_memory = ram;\n\n    ram_below_4g = g_malloc(sizeof(*ram_below_4g));\n\n    memory_region_init_alias(ram_below_4g, NULL, \"ram-below-4g\", ram,\n\n                             0, below_4g_mem_size);\n\n    memory_region_add_subregion(system_memory, 0, ram_below_4g);\n\n    e820_add_entry(0, below_4g_mem_size, E820_RAM);\n\n    if (above_4g_mem_size > 0) {\n\n        ram_above_4g = g_malloc(sizeof(*ram_above_4g));\n\n        memory_region_init_alias(ram_above_4g, NULL, \"ram-above-4g\", ram,\n\n                                 below_4g_mem_size, above_4g_mem_size);\n\n        memory_region_add_subregion(system_memory, 0x100000000ULL,\n\n                                    ram_above_4g);\n\n        e820_add_entry(0x100000000ULL, above_4g_mem_size, E820_RAM);\n\n    }\n\n\n\n\n\n    /* Initialize PC system firmware */\n\n    pc_system_firmware_init(rom_memory, guest_info->isapc_ram_fw);\n\n\n\n    option_rom_mr = g_malloc(sizeof(*option_rom_mr));\n\n    memory_region_init_ram(option_rom_mr, NULL, \"pc.rom\", PC_ROM_SIZE);\n\n    vmstate_register_ram_global(option_rom_mr);\n\n    memory_region_add_subregion_overlap(rom_memory,\n\n                                        PC_ROM_MIN_VGA,\n\n                                        option_rom_mr,\n\n                                        1);\n\n\n\n    fw_cfg = bochs_bios_init();\n\n    rom_set_fw(fw_cfg);\n\n\n\n    if (linux_boot) {\n\n        load_linux(fw_cfg, kernel_filename, initrd_filename, kernel_cmdline, below_4g_mem_size);\n\n    }\n\n\n\n    for (i = 0; i < nb_option_roms; i++) {\n\n        rom_add_option(option_rom[i].name, option_rom[i].bootindex);\n\n    }\n\n    guest_info->fw_cfg = fw_cfg;\n\n    return fw_cfg;\n\n}\n", "idx": 24588, "_split": "test", "_hash": "51c072343658834e40c5103f6c1618c5"}
{"project": "qemu", "commit_id": "c5ce83334465ee5acb6789a2f22d125273761c9e", "target": 0, "func": "static void press_key(VncState *vs, int keysym)\n\n{\n\n    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;\n\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);\n\n    qemu_input_event_send_key_delay(0);\n\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);\n\n    qemu_input_event_send_key_delay(0);\n\n}\n", "idx": 24603, "_split": "test", "_hash": "3734bee21bbb4305155ba90191d33131"}
{"project": "qemu", "commit_id": "8172539d21a03e982aa7f139ddc1607dc1422045", "target": 0, "func": "static void s390_virtio_device_sync(VirtIOS390Device *dev)\n\n{\n\n    VirtIOS390Bus *bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);\n\n    ram_addr_t cur_offs;\n\n    uint8_t num_vq;\n\n    int i;\n\n\n\n    virtio_reset(dev->vdev);\n\n\n\n    /* Sync dev space */\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_TYPE, dev->vdev->device_id);\n\n\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, s390_virtio_device_num_vq(dev));\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_FEATURE_LEN, dev->feat_len);\n\n\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG_LEN, dev->vdev->config_len);\n\n\n\n    num_vq = s390_virtio_device_num_vq(dev);\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, num_vq);\n\n\n\n    /* Sync virtqueues */\n\n    for (i = 0; i < num_vq; i++) {\n\n        ram_addr_t vq = (dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG) +\n\n                        (i * VIRTIO_VQCONFIG_LEN);\n\n        ram_addr_t vring;\n\n\n\n        vring = s390_virtio_next_ring(bus);\n\n        virtio_queue_set_addr(dev->vdev, i, vring);\n\n        virtio_queue_set_vector(dev->vdev, i, i);\n\n        stq_phys(vq + VIRTIO_VQCONFIG_OFFS_ADDRESS, vring);\n\n        stw_phys(vq + VIRTIO_VQCONFIG_OFFS_NUM, virtio_queue_get_num(dev->vdev, i));\n\n    }\n\n\n\n    cur_offs = dev->dev_offs;\n\n    cur_offs += VIRTIO_DEV_OFFS_CONFIG;\n\n    cur_offs += num_vq * VIRTIO_VQCONFIG_LEN;\n\n\n\n    /* Sync feature bitmap */\n\n    if (dev->vdev->get_features) {\n\n        stl_phys(cur_offs, dev->vdev->get_features(dev->vdev));\n\n    }\n\n\n\n    dev->feat_offs = cur_offs + dev->feat_len;\n\n    cur_offs += dev->feat_len * 2;\n\n\n\n    /* Sync config space */\n\n    if (dev->vdev->get_config) {\n\n        dev->vdev->get_config(dev->vdev, dev->vdev->config);\n\n    }\n\n\n\n    cpu_physical_memory_rw(cur_offs, dev->vdev->config, dev->vdev->config_len, 1);\n\n    cur_offs += dev->vdev->config_len;\n\n}\n", "idx": 24606, "_split": "test", "_hash": "5997bb797afb1f396905e86a44fb4dae"}
{"project": "qemu", "commit_id": "164a101f28a53cd3db60ed874e7c3630e7988ed8", "target": 1, "func": "void aio_set_event_notifier(AioContext *ctx,\n\n                            EventNotifier *e,\n\n                            EventNotifierHandler *io_notify,\n\n                            AioFlushEventNotifierHandler *io_flush)\n\n{\n\n    AioHandler *node;\n\n\n\n    QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n        if (node->e == e && !node->deleted) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Are we deleting the fd handler? */\n\n    if (!io_notify) {\n\n        if (node) {\n\n            g_source_remove_poll(&ctx->source, &node->pfd);\n\n\n\n            /* If the lock is held, just mark the node as deleted */\n\n            if (ctx->walking_handlers) {\n\n                node->deleted = 1;\n\n                node->pfd.revents = 0;\n\n            } else {\n\n                /* Otherwise, delete it for real.  We can't just mark it as\n\n                 * deleted because deleted nodes are only cleaned up after\n\n                 * releasing the walking_handlers lock.\n\n                 */\n\n                QLIST_REMOVE(node, node);\n\n                g_free(node);\n\n            }\n\n        }\n\n    } else {\n\n        if (node == NULL) {\n\n            /* Alloc and insert if it's not already there */\n\n            node = g_malloc0(sizeof(AioHandler));\n\n            node->e = e;\n\n            node->pfd.fd = (uintptr_t)event_notifier_get_handle(e);\n\n            node->pfd.events = G_IO_IN;\n\n            QLIST_INSERT_HEAD(&ctx->aio_handlers, node, node);\n\n\n\n            g_source_add_poll(&ctx->source, &node->pfd);\n\n        }\n\n        /* Update handler with latest information */\n\n        node->io_notify = io_notify;\n\n        node->io_flush = io_flush;\n\n    }\n\n\n\n    aio_notify(ctx);\n\n}\n", "idx": 24626, "_split": "test", "_hash": "0bf2cbc0b13ef47f56907667efeb4d70"}
{"project": "qemu", "commit_id": "e957f6a9b92439a222ecd4ff1c8cdc9700710c72", "target": 1, "func": "static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset,\n\n                                  sPAPRMachineState *spapr)\n\n{\n\n    PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n    CPUPPCState *env = &cpu->env;\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs);\n\n    int index = ppc_get_vcpu_dt_id(cpu);\n\n    uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),\n\n                       0xffffffff, 0xffffffff};\n\n    uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq()\n\n        : SPAPR_TIMEBASE_FREQ;\n\n    uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;\n\n    uint32_t page_sizes_prop[64];\n\n    size_t page_sizes_prop_size;\n\n    uint32_t vcpus_per_socket = smp_threads * smp_cores;\n\n    uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)};\n\n    int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu));\n\n    sPAPRDRConnector *drc;\n\n    sPAPRDRConnectorClass *drck;\n\n    int drc_index;\n\n    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];\n\n    int i;\n\n\n\n    drc = spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_CPU, index);\n\n    if (drc) {\n\n        drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n        drc_index = drck->get_index(drc);\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index)));\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"reg\", index)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"device_type\", \"cpu\")));\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"cpu-version\", env->spr[SPR_PVR])));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-block-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-line-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-block-size\",\n\n                           env->icache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-line-size\",\n\n                           env->icache_line_size)));\n\n\n\n    if (pcc->l1_dcache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-size\",\n\n                               pcc->l1_dcache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 dcache size for cpu\");\n\n    }\n\n    if (pcc->l1_icache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-size\",\n\n                               pcc->l1_icache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 icache size for cpu\");\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"timebase-frequency\", tbfreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"clock-frequency\", cpufreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"status\", \"okay\")));\n\n    _FDT((fdt_setprop(fdt, offset, \"64-bit\", NULL, 0)));\n\n\n\n    if (env->spr_cb[SPR_PURR].oea_read) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,purr\", NULL, 0)));\n\n    }\n\n\n\n    if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-segment-sizes\",\n\n                          segs, sizeof(segs))));\n\n    }\n\n\n\n    /* Advertise VMX/VSX (vector extensions) if available\n\n     *   0 / no property == no vector extensions\n\n     *   1               == VMX / Altivec available\n\n     *   2               == VSX available */\n\n    if (env->insns_flags & PPC_ALTIVEC) {\n\n        uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;\n\n\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,vmx\", vmx)));\n\n    }\n\n\n\n    /* Advertise DFP (Decimal Floating Point) if available\n\n     *   0 / no property == no DFP\n\n     *   1               == DFP available */\n\n    if (env->insns_flags2 & PPC2_DFP) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,dfp\", 1)));\n\n    }\n\n\n\n    page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop,\n\n                                                  sizeof(page_sizes_prop));\n\n    if (page_sizes_prop_size) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,segment-page-sizes\",\n\n                          page_sizes_prop, page_sizes_prop_size)));\n\n    }\n\n\n\n    spapr_populate_pa_features(env, fdt, offset);\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,chip-id\",\n\n                           cs->cpu_index / vcpus_per_socket)));\n\n\n\n    _FDT((fdt_setprop(fdt, offset, \"ibm,pft-size\",\n\n                      pft_size_prop, sizeof(pft_size_prop))));\n\n\n\n    _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cs));\n\n\n\n    _FDT(spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt));\n\n\n\n    if (pcc->radix_page_info) {\n\n        for (i = 0; i < pcc->radix_page_info->count; i++) {\n\n            radix_AP_encodings[i] =\n\n                cpu_to_be32(pcc->radix_page_info->entries[i]);\n\n        }\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-radix-AP-encodings\",\n\n                          radix_AP_encodings,\n\n                          pcc->radix_page_info->count *\n\n                          sizeof(radix_AP_encodings[0]))));\n\n    }\n\n}\n", "idx": 24648, "_split": "test", "_hash": "62dd04aaabe084ac903e8f8f150d78cc"}
{"project": "qemu", "commit_id": "edf779ffccc836661a7b654d320571a6c220caea", "target": 0, "func": "static void setup_frame(int sig, struct emulated_sigaction *ka,\n\n\t\t\ttarget_sigset_t *set, CPUX86State *env)\n\n{\n\n\tstruct sigframe *frame;\n\n\tint err = 0;\n\n\n\n\tframe = get_sigframe(ka, env, sizeof(*frame));\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\n\t\tgoto give_sigsegv;\n\n#endif\n\n\terr |= __put_user((/*current->exec_domain\n\n\t\t           && current->exec_domain->signal_invmap\n\n\t\t           && sig < 32\n\n\t\t           ? current->exec_domain->signal_invmap[sig]\n\n\t\t           : */ sig),\n\n\t\t          &frame->sig);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\tsetup_sigcontext(&frame->sc, &frame->fpstate, env, set->sig[0]);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\tif (TARGET_NSIG_WORDS > 1) {\n\n\t\terr |= __copy_to_user(frame->extramask, &set->sig[1],\n\n\t\t\t\t      sizeof(frame->extramask));\n\n\t}\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up to return from userspace.  If provided, use a stub\n\n\t   already in userspace.  */\n\n\tif (ka->sa.sa_flags & TARGET_SA_RESTORER) {\n\n\t\terr |= __put_user(ka->sa.sa_restorer, &frame->pretcode);\n\n\t} else {\n\n\t\terr |= __put_user(frame->retcode, &frame->pretcode);\n\n\t\t/* This is popl %eax ; movl $,%eax ; int $0x80 */\n\n\t\terr |= __put_user(0xb858, (short *)(frame->retcode+0));\n\n\t\terr |= __put_user(TARGET_NR_sigreturn, (int *)(frame->retcode+2));\n\n\t\terr |= __put_user(0x80cd, (short *)(frame->retcode+6));\n\n\t}\n\n\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up registers for signal handler */\n\n\tenv->regs[R_ESP] = (unsigned long) frame;\n\n\tenv->eip = (unsigned long) ka->sa._sa_handler;\n\n\n\n        cpu_x86_load_seg(env, R_DS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_ES, __USER_DS);\n\n        cpu_x86_load_seg(env, R_SS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_CS, __USER_CS);\n\n\tenv->eflags &= ~TF_MASK;\n\n\n\n\treturn;\n\n\n\ngive_sigsegv:\n\n\tif (sig == TARGET_SIGSEGV)\n\n\t\tka->sa._sa_handler = TARGET_SIG_DFL;\n\n\tforce_sig(TARGET_SIGSEGV /* , current */);\n\n}\n", "idx": 24720, "_split": "test", "_hash": "cd5523baa6579065a32b623e545b6132"}
{"project": "qemu", "commit_id": "ce137829e7e58fcdc5ba63b5e256f972e80be438", "target": 1, "func": "static void write_target_close(BlockDriverState *bs) {\n\n    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);\n\n    bdrv_delete(s->qcow);\n\n    free(s->qcow_filename);\n\n}\n", "idx": 24730, "_split": "test", "_hash": "520449c3888f7d0abc4d9c016746729f"}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_fnmsub (uint64_t arg1, uint64_t arg2, uint64_t arg3)\n\n{\n\n    CPU_DoubleU farg1, farg2, farg3;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n    farg3.ll = arg3;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                 float64_is_signaling_nan(farg2.d) ||\n\n                 float64_is_signaling_nan(farg3.d))) {\n\n        /* sNaN operation */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN);\n\n    } else if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||\n\n                        (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {\n\n        /* Multiplication of zero by infinity */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ);\n\n    } else {\n\n#if USE_PRECISE_EMULATION\n\n#ifdef FLOAT128\n\n        /* This is the way the PowerPC specification defines it */\n\n        float128 ft0_128, ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) && float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) == float64_is_neg(farg3.d))) {\n\n            /* Magnitude subtraction of infinities */\n\n            farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_sub(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n#else\n\n        /* This is OK on x86 hosts */\n\n        farg1.d = (farg1.d * farg2.d) - farg3.d;\n\n#endif\n\n#else\n\n        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);\n\n        farg1.d = float64_sub(farg1.d, farg3.d, &env->fp_status);\n\n#endif\n\n        if (likely(!float64_is_nan(farg1.d)))\n\n            farg1.d = float64_chs(farg1.d);\n\n    }\n\n    return farg1.ll;\n\n}\n", "idx": 24742, "_split": "test", "_hash": "3caf287dafeb04a3fbca0e7d090d4bf3"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void dec_modu(DisasContext *dc)\n\n{\n\n    int l1;\n\n\n\n    LOG_DIS(\"modu r%d, r%d, %d\\n\", dc->r2, dc->r0, dc->r1);\n\n\n\n    if (!(dc->features & LM32_FEATURE_DIVIDE)) {\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"hardware divider is not available\\n\");\n\n        t_gen_illegal_insn(dc);\n\n        return;\n\n    }\n\n\n\n    l1 = gen_new_label();\n\n    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);\n\n    tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);\n\n    gen_set_label(l1);\n\n    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);\n\n}\n", "idx": 24744, "_split": "test", "_hash": "c9c8f657d1be98bbf5ae7f2a71a8037b"}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "static void omap_l4_io_writeb(void *opaque, target_phys_addr_t addr,\n\n                uint32_t value)\n\n{\n\n    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;\n\n\n\n    return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);\n\n}\n", "idx": 24748, "_split": "test", "_hash": "79cffc414d6100f17823065f427c64fd"}
{"project": "qemu", "commit_id": "63729c36924348e494d69adbbdec6fdda339b76b", "target": 0, "func": "static void v9fs_create_post_lstat(V9fsState *s, V9fsCreateState *vs, int err)\n\n{\n\n\n\n    if (err == 0 || errno != ENOENT) {\n\n        err = -errno;\n\n        goto out;\n\n    }\n\n\n\n    if (vs->perm & P9_STAT_MODE_DIR) {\n\n        err = v9fs_do_mkdir(s, vs);\n\n        v9fs_create_post_mkdir(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_SYMLINK) {\n\n        err = v9fs_do_symlink(s, vs);\n\n        v9fs_create_post_perms(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_LINK) {\n\n        int32_t nfid = atoi(vs->extension.data);\n\n        V9fsFidState *nfidp = lookup_fid(s, nfid);\n\n        if (nfidp == NULL) {\n\n            err = -errno;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n        err = v9fs_do_link(s, &nfidp->path, &vs->fullname);\n\n        v9fs_create_post_perms(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_DEVICE) {\n\n        char ctype;\n\n        uint32_t major, minor;\n\n        mode_t nmode = 0;\n\n\n\n        if (sscanf(vs->extension.data, \"%c %u %u\", &ctype, &major,\n\n                                        &minor) != 3) {\n\n            err = -errno;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n\n\n        switch (ctype) {\n\n        case 'c':\n\n            nmode = S_IFCHR;\n\n            break;\n\n        case 'b':\n\n            nmode = S_IFBLK;\n\n            break;\n\n        default:\n\n            err = -EIO;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n\n\n        nmode |= vs->perm & 0777;\n\n        err = v9fs_do_mknod(s, vs, nmode, makedev(major, minor));\n\n        v9fs_create_post_perms(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_NAMED_PIPE) {\n\n        err = v9fs_do_mknod(s, vs, S_IFIFO | (vs->perm & 0777), 0);\n\n        v9fs_post_create(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_SOCKET) {\n\n        err = v9fs_do_mksock(s, &vs->fullname);\n\n        v9fs_create_post_mksock(s, vs, err);\n\n    } else {\n\n        vs->fidp->fd = v9fs_do_open2(s, vs);\n\n        v9fs_create_post_open2(s, vs, err);\n\n    }\n\n\n\n    return;\n\n\n\nout:\n\n    v9fs_post_create(s, vs, err);\n\n}\n", "idx": 24754, "_split": "test", "_hash": "2e8a4d6c0d6880b0ba58ed5bd44ad657"}
{"project": "qemu", "commit_id": "6049f4f831c6f409031dfa09282b38d0cbaecad8", "target": 0, "func": "void pal_init (CPUState *env)\n\n{\n\n}\n", "idx": 24756, "_split": "test", "_hash": "7fb692c4125efbdc21c4cdad772558ac"}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "target_ulong spapr_rtas_call(sPAPREnvironment *spapr,\n\n                             uint32_t token, uint32_t nargs, target_ulong args,\n\n                             uint32_t nret, target_ulong rets)\n\n{\n\n    if ((token >= TOKEN_BASE)\n\n        && ((token - TOKEN_BASE) < TOKEN_MAX)) {\n\n        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);\n\n\n\n        if (call->fn) {\n\n            call->fn(spapr, token, nargs, args, nret, rets);\n\n            return H_SUCCESS;\n\n        }\n\n    }\n\n\n\n    /* HACK: Some Linux early debug code uses RTAS display-character,\n\n     * but assumes the token value is 0xa (which it is on some real\n\n     * machines) without looking it up in the device tree.  This\n\n     * special case makes this work */\n\n    if (token == 0xa) {\n\n        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);\n\n        return H_SUCCESS;\n\n    }\n\n\n\n    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);\n\n    rtas_st(rets, 0, -3);\n\n    return H_PARAMETER;\n\n}\n", "idx": 24759, "_split": "test", "_hash": "e45e1e929d0a1c582fba95ff3a513011"}
{"project": "qemu", "commit_id": "665414ad06aa1bc92e615db9641e58fb13d07de1", "target": 1, "func": "static int ram_block_enable_notify(const char *block_name, void *host_addr,\n\n                                   ram_addr_t offset, ram_addr_t length,\n\n                                   void *opaque)\n\n{\n\n    MigrationIncomingState *mis = opaque;\n\n    struct uffdio_register reg_struct;\n\n\n\n    reg_struct.range.start = (uintptr_t)host_addr;\n\n    reg_struct.range.len = length;\n\n    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;\n\n\n\n    /* Now tell our userfault_fd that it's responsible for this area */\n\n    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {\n\n        error_report(\"%s userfault register: %s\", __func__, strerror(errno));\n\n\n\n\n\n\n\n\n\n    return 0;\n", "idx": 24771, "_split": "test", "_hash": "d5a6056cc824b9e22836a161dc00ea2d"}
{"project": "qemu", "commit_id": "1f51470d044852592922f91000e741c381582cdc", "target": 1, "func": "static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)\n\n{\n\n    const char *file_out = qemu_opt_get(opts, \"path\");\n\n    HANDLE fd_out;\n\n\n\n    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,\n\n                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n\n    if (fd_out == INVALID_HANDLE_VALUE) {\n\n        return -EIO;\n\n    }\n\n\n\n    return qemu_chr_open_win_file(fd_out, _chr);\n\n}\n", "idx": 24794, "_split": "test", "_hash": "71cbe2c870e19465d744a23df6d18dd5"}
{"project": "qemu", "commit_id": "a3f409cb4a35d9aa6a4d24a7a1e05423e189cb7a", "target": 1, "func": "static void vtd_init(IntelIOMMUState *s)\n\n{\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(s);\n\n\n\n    memset(s->csr, 0, DMAR_REG_SIZE);\n\n    memset(s->wmask, 0, DMAR_REG_SIZE);\n\n    memset(s->w1cmask, 0, DMAR_REG_SIZE);\n\n    memset(s->womask, 0, DMAR_REG_SIZE);\n\n\n\n    s->iommu_ops.translate = vtd_iommu_translate;\n\n    s->iommu_ops.notify_started = vtd_iommu_notify_started;\n\n    s->root = 0;\n\n    s->root_extended = false;\n\n    s->dmar_enabled = false;\n\n    s->iq_head = 0;\n\n    s->iq_tail = 0;\n\n    s->iq = 0;\n\n    s->iq_size = 0;\n\n    s->qi_enabled = false;\n\n    s->iq_last_desc_type = VTD_INV_DESC_NONE;\n\n    s->next_frcd_reg = 0;\n\n    s->cap = VTD_CAP_FRO | VTD_CAP_NFR | VTD_CAP_ND | VTD_CAP_MGAW |\n\n             VTD_CAP_SAGAW | VTD_CAP_MAMV | VTD_CAP_PSI | VTD_CAP_SLLPS;\n\n    s->ecap = VTD_ECAP_QI | VTD_ECAP_IRO;\n\n\n\n    if (x86_iommu->intr_supported) {\n\n        s->ecap |= VTD_ECAP_IR | VTD_ECAP_EIM;\n\n    }\n\n\n\n    vtd_reset_context_cache(s);\n\n    vtd_reset_iotlb(s);\n\n\n\n    /* Define registers with default values and bit semantics */\n\n    vtd_define_long(s, DMAR_VER_REG, 0x10UL, 0, 0);\n\n    vtd_define_quad(s, DMAR_CAP_REG, s->cap, 0, 0);\n\n    vtd_define_quad(s, DMAR_ECAP_REG, s->ecap, 0, 0);\n\n    vtd_define_long(s, DMAR_GCMD_REG, 0, 0xff800000UL, 0);\n\n    vtd_define_long_wo(s, DMAR_GCMD_REG, 0xff800000UL);\n\n    vtd_define_long(s, DMAR_GSTS_REG, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_RTADDR_REG, 0, 0xfffffffffffff000ULL, 0);\n\n    vtd_define_quad(s, DMAR_CCMD_REG, 0, 0xe0000003ffffffffULL, 0);\n\n    vtd_define_quad_wo(s, DMAR_CCMD_REG, 0x3ffff0000ULL);\n\n\n\n    /* Advanced Fault Logging not supported */\n\n    vtd_define_long(s, DMAR_FSTS_REG, 0, 0, 0x11UL);\n\n    vtd_define_long(s, DMAR_FECTL_REG, 0x80000000UL, 0x80000000UL, 0);\n\n    vtd_define_long(s, DMAR_FEDATA_REG, 0, 0x0000ffffUL, 0);\n\n    vtd_define_long(s, DMAR_FEADDR_REG, 0, 0xfffffffcUL, 0);\n\n\n\n    /* Treated as RsvdZ when EIM in ECAP_REG is not supported\n\n     * vtd_define_long(s, DMAR_FEUADDR_REG, 0, 0xffffffffUL, 0);\n\n     */\n\n    vtd_define_long(s, DMAR_FEUADDR_REG, 0, 0, 0);\n\n\n\n    /* Treated as RO for implementations that PLMR and PHMR fields reported\n\n     * as Clear in the CAP_REG.\n\n     * vtd_define_long(s, DMAR_PMEN_REG, 0, 0x80000000UL, 0);\n\n     */\n\n    vtd_define_long(s, DMAR_PMEN_REG, 0, 0, 0);\n\n\n\n    vtd_define_quad(s, DMAR_IQH_REG, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_IQT_REG, 0, 0x7fff0ULL, 0);\n\n    vtd_define_quad(s, DMAR_IQA_REG, 0, 0xfffffffffffff007ULL, 0);\n\n    vtd_define_long(s, DMAR_ICS_REG, 0, 0, 0x1UL);\n\n    vtd_define_long(s, DMAR_IECTL_REG, 0x80000000UL, 0x80000000UL, 0);\n\n    vtd_define_long(s, DMAR_IEDATA_REG, 0, 0xffffffffUL, 0);\n\n    vtd_define_long(s, DMAR_IEADDR_REG, 0, 0xfffffffcUL, 0);\n\n    /* Treadted as RsvdZ when EIM in ECAP_REG is not supported */\n\n    vtd_define_long(s, DMAR_IEUADDR_REG, 0, 0, 0);\n\n\n\n    /* IOTLB registers */\n\n    vtd_define_quad(s, DMAR_IOTLB_REG, 0, 0Xb003ffff00000000ULL, 0);\n\n    vtd_define_quad(s, DMAR_IVA_REG, 0, 0xfffffffffffff07fULL, 0);\n\n    vtd_define_quad_wo(s, DMAR_IVA_REG, 0xfffffffffffff07fULL);\n\n\n\n    /* Fault Recording Registers, 128-bit */\n\n    vtd_define_quad(s, DMAR_FRCD_REG_0_0, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_FRCD_REG_0_2, 0, 0, 0x8000000000000000ULL);\n\n\n\n    /*\n\n     * Interrupt remapping registers.\n\n     */\n\n    vtd_define_quad(s, DMAR_IRTA_REG, 0, 0xfffffffffffff80fULL, 0);\n\n}\n", "idx": 24824, "_split": "test", "_hash": "9938a028fd694f86394317c0899748fe"}
{"project": "qemu", "commit_id": "736d120af4bf5f3e13b2f90c464b3a24847f78f0", "target": 0, "func": "void helper_ctc1(CPUMIPSState *env, target_ulong arg1, uint32_t reg)\n\n{\n\n    switch(reg) {\n\n    case 25:\n\n        if (arg1 & 0xffffff00)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0x017fffff) | ((arg1 & 0xfe) << 24) |\n\n                     ((arg1 & 0x1) << 23);\n\n        break;\n\n    case 26:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfffc0f83) | (arg1 & 0x0003f07c);\n\n        break;\n\n    case 28:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfefff07c) | (arg1 & 0x00000f83) |\n\n                     ((arg1 & 0x4) << 22);\n\n        break;\n\n    case 31:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = arg1;\n\n        break;\n\n    default:\n\n        return;\n\n    }\n\n    /* set rounding mode */\n\n    restore_rounding_mode(env);\n\n    /* set flush-to-zero mode */\n\n    restore_flush_mode(env);\n\n    set_float_exception_flags(0, &env->active_fpu.fp_status);\n\n    if ((GET_FP_ENABLE(env->active_fpu.fcr31) | 0x20) & GET_FP_CAUSE(env->active_fpu.fcr31))\n\n        do_raise_exception(env, EXCP_FPE, GETPC());\n\n}\n", "idx": 24847, "_split": "test", "_hash": "79699e844ce133e49424b613fe758994"}
{"project": "qemu", "commit_id": "94ad5b00a31113ed36b9d03a8db16de5535e90c4", "target": 0, "func": "static void cpu_set_irq(void *opaque, int irq, int level)\n\n{\n\n    CPUState *env = opaque;\n\n\n\n    if (level) {\n\n        CPUIRQ_DPRINTF(\"Raise CPU IRQ %d\\n\", irq);\n\n        env->halted = 0;\n\n        env->pil_in |= 1 << irq;\n\n        cpu_check_irqs(env);\n\n    } else {\n\n        CPUIRQ_DPRINTF(\"Lower CPU IRQ %d\\n\", irq);\n\n        env->pil_in &= ~(1 << irq);\n\n        cpu_check_irqs(env);\n\n    }\n\n}\n", "idx": 24853, "_split": "test", "_hash": "eebafcab3bae8ab2de80f75283cfb9d4"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int get_stream_blocksize(BlockDriverState *bdrv)\n\n{\n\n    uint8_t cmd[6];\n\n    uint8_t buf[12];\n\n    uint8_t sensebuf[8];\n\n    sg_io_hdr_t io_header;\n\n    int ret;\n\n\n\n    memset(cmd, 0, sizeof(cmd));\n\n    memset(buf, 0, sizeof(buf));\n\n    cmd[0] = MODE_SENSE;\n\n    cmd[4] = sizeof(buf);\n\n\n\n    memset(&io_header, 0, sizeof(io_header));\n\n    io_header.interface_id = 'S';\n\n    io_header.dxfer_direction = SG_DXFER_FROM_DEV;\n\n    io_header.dxfer_len = sizeof(buf);\n\n    io_header.dxferp = buf;\n\n    io_header.cmdp = cmd;\n\n    io_header.cmd_len = sizeof(cmd);\n\n    io_header.mx_sb_len = sizeof(sensebuf);\n\n    io_header.sbp = sensebuf;\n\n    io_header.timeout = 6000; /* XXX */\n\n\n\n    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);\n\n    if (ret < 0 || io_header.driver_status || io_header.host_status) {\n\n        return -1;\n\n    }\n\n    return (buf[9] << 16) | (buf[10] << 8) | buf[11];\n\n}\n", "idx": 24855, "_split": "test", "_hash": "eb630d810fb7f61f0570c899b604c860"}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,\n\n                                  int64_t size)\n\n{\n\n    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    } else if (ret > 0) {\n\n        int metadata_ol_bitnr = ffs(ret) - 1;\n\n        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);\n\n\n\n        qcow2_signal_corruption(bs, true, offset, size, \"Preventing invalid \"\n\n                                \"write on metadata (overlaps with %s)\",\n\n                                metadata_ol_names[metadata_ol_bitnr]);\n\n        return -EIO;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24880, "_split": "test", "_hash": "46537b7fe80814d04ed7b80a379f0d33"}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void co_write_request(void *opaque)\n\n{\n\n    BDRVSheepdogState *s = opaque;\n\n\n\n    qemu_coroutine_enter(s->co_send, NULL);\n\n}\n", "idx": 24895, "_split": "test", "_hash": "0695aa7c726d3dd3f68cc4a77c99a3d4"}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "udp_listen(Slirp *slirp, u_int32_t haddr, u_int hport, u_int32_t laddr,\n\n           u_int lport, int flags)\n\n{\n\n\tstruct sockaddr_in addr;\n\n\tstruct socket *so;\n\n\tsocklen_t addrlen = sizeof(struct sockaddr_in), opt = 1;\n\n\n\n\tso = socreate(slirp);\n\n\tif (!so) {\n\n\t    return NULL;\n\n\t}\n\n\tso->s = socket(AF_INET,SOCK_DGRAM,0);\n\n\tso->so_expire = curtime + SO_EXPIRE;\n\n\tinsque(so, &slirp->udb);\n\n\n\n\taddr.sin_family = AF_INET;\n\n\taddr.sin_addr.s_addr = haddr;\n\n\taddr.sin_port = hport;\n\n\n\n\tif (bind(so->s,(struct sockaddr *)&addr, addrlen) < 0) {\n\n\t\tudp_detach(so);\n\n\t\treturn NULL;\n\n\t}\n\n\tsetsockopt(so->s,SOL_SOCKET,SO_REUSEADDR,(char *)&opt,sizeof(int));\n\n\n\n\tgetsockname(so->s,(struct sockaddr *)&addr,&addrlen);\n\n\tso->so_fport = addr.sin_port;\n\n\tif (addr.sin_addr.s_addr == 0 ||\n\n\t    addr.sin_addr.s_addr == loopback_addr.s_addr) {\n\n\t   so->so_faddr = slirp->vhost_addr;\n\n\t} else {\n\n\t   so->so_faddr = addr.sin_addr;\n\n\t}\n\n\tso->so_lport = lport;\n\n\tso->so_laddr.s_addr = laddr;\n\n\tif (flags != SS_FACCEPTONCE)\n\n\t   so->so_expire = 0;\n\n\n\n\tso->so_state &= SS_PERSISTENT_MASK;\n\n\tso->so_state |= SS_ISFCONNECTED | flags;\n\n\n\n\treturn so;\n\n}\n", "idx": 24897, "_split": "test", "_hash": "5678adf8c58176bfef9b2d01d0b056d7"}
{"project": "qemu", "commit_id": "b4548fcc0314f5e118ed45b5774e9cd99f9a97d3", "target": 1, "func": "static uint32_t grlib_irqmp_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    IRQMP      *irqmp = opaque;\n\n    IRQMPState *state;\n\n\n\n    assert(irqmp != NULL);\n\n    state = irqmp->state;\n\n    assert(state != NULL);\n\n\n\n    addr &= 0xff;\n\n\n\n    /* global registers */\n\n    switch (addr) {\n\n    case LEVEL_OFFSET:\n\n        return state->level;\n\n\n\n    case PENDING_OFFSET:\n\n        return state->pending;\n\n\n\n    case FORCE0_OFFSET:\n\n        /* This register is an \"alias\" for the force register of CPU 0 */\n\n        return state->force[0];\n\n\n\n    case CLEAR_OFFSET:\n\n    case MP_STATUS_OFFSET:\n\n        /* Always read as 0 */\n\n        return 0;\n\n\n\n    case BROADCAST_OFFSET:\n\n        return state->broadcast;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* mask registers */\n\n    if (addr >= MASK_OFFSET && addr < FORCE_OFFSET) {\n\n        int cpu = (addr - MASK_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->mask[cpu];\n\n    }\n\n\n\n    /* force registers */\n\n    if (addr >= FORCE_OFFSET && addr < EXTENDED_OFFSET) {\n\n        int cpu = (addr - FORCE_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->force[cpu];\n\n    }\n\n\n\n    /* extended (not supported) */\n\n    if (addr >= EXTENDED_OFFSET && addr < IRQMP_REG_SIZE) {\n\n        int cpu = (addr - EXTENDED_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->extended[cpu];\n\n    }\n\n\n\n    trace_grlib_irqmp_unknown_register(\"read\", addr);\n\n    return 0;\n\n}\n", "idx": 24899, "_split": "test", "_hash": "eaf3ecd925d65225c8c8355e0c0bcdf0"}
{"project": "qemu", "commit_id": "ea8d82a1ed72634f089ed1bccccd9c84cc1ab855", "target": 1, "func": "void qemu_sglist_destroy(QEMUSGList *qsg)\n\n{\n\n    g_free(qsg->sg);\n\n\n}", "idx": 24902, "_split": "test", "_hash": "3f1bc34be3d0981e277cbe04ac475bd2"}
{"project": "qemu", "commit_id": "27915efb974999dd256a6c432a17432d9d84e606", "target": 1, "func": "static int virtio_9p_device_init(VirtIODevice *vdev)\n\n{\n\n    V9fsState *s = VIRTIO_9P(vdev);\n\n    int i, len;\n\n    struct stat stat;\n\n    FsDriverEntry *fse;\n\n    V9fsPath path;\n\n\n\n    virtio_init(VIRTIO_DEVICE(s), \"virtio-9p\", VIRTIO_ID_9P,\n\n                sizeof(struct virtio_9p_config) + MAX_TAG_LEN);\n\n\n\n    /* initialize pdu allocator */\n\n    QLIST_INIT(&s->free_list);\n\n    QLIST_INIT(&s->active_list);\n\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n\n        QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next);\n\n    }\n\n\n\n    s->vq = virtio_add_queue(vdev, MAX_REQ, handle_9p_output);\n\n\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n\n\n    if (!fse) {\n\n        /* We don't have a fsdev identified by fsdev_id */\n\n        fprintf(stderr, \"Virtio-9p device couldn't find fsdev with the \"\n\n                \"id = %s\\n\",\n\n                s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n\n        goto out;\n\n    }\n\n\n\n    if (!s->fsconf.tag) {\n\n        /* we haven't specified a mount_tag */\n\n        fprintf(stderr, \"fsdev with id %s needs mount_tag arguments\\n\",\n\n                s->fsconf.fsdev_id);\n\n        goto out;\n\n    }\n\n\n\n    s->ctx.export_flags = fse->export_flags;\n\n    s->ctx.fs_root = g_strdup(fse->path);\n\n    s->ctx.exops.get_st_gen = NULL;\n\n    len = strlen(s->fsconf.tag);\n\n    if (len > MAX_TAG_LEN - 1) {\n\n        fprintf(stderr, \"mount tag '%s' (%d bytes) is longer than \"\n\n                \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n\n        goto out;\n\n    }\n\n\n\n    s->tag = g_strdup(s->fsconf.tag);\n\n    s->ctx.uid = -1;\n\n\n\n    s->ops = fse->ops;\n\n    s->config_size = sizeof(struct virtio_9p_config) + len;\n\n    s->fid_list = NULL;\n\n    qemu_co_rwlock_init(&s->rename_lock);\n\n\n\n    if (s->ops->init(&s->ctx) < 0) {\n\n        fprintf(stderr, \"Virtio-9p Failed to initialize fs-driver with id:%s\"\n\n                \" and export path:%s\\n\", s->fsconf.fsdev_id, s->ctx.fs_root);\n\n        goto out;\n\n    }\n\n    if (v9fs_init_worker_threads() < 0) {\n\n        fprintf(stderr, \"worker thread initialization failed\\n\");\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * Check details of export path, We need to use fs driver\n\n     * call back to do that. Since we are in the init path, we don't\n\n     * use co-routines here.\n\n     */\n\n    v9fs_path_init(&path);\n\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n\n        fprintf(stderr,\n\n                \"error in converting name to path %s\", strerror(errno));\n\n        goto out;\n\n    }\n\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n\n        fprintf(stderr, \"share path %s does not exist\\n\", fse->path);\n\n        goto out;\n\n    } else if (!S_ISDIR(stat.st_mode)) {\n\n        fprintf(stderr, \"share path %s is not a directory\\n\", fse->path);\n\n        goto out;\n\n    }\n\n    v9fs_path_free(&path);\n\n\n\n    return 0;\n\nout:\n\n    g_free(s->ctx.fs_root);\n\n    g_free(s->tag);\n\n    virtio_cleanup(vdev);\n\n    v9fs_path_free(&path);\n\n\n\n    return -1;\n\n\n\n}\n", "idx": 24921, "_split": "test", "_hash": "d063d1f5c897e66a9bcb8e0b8e42eadd"}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int v9fs_request(V9fsProxy *proxy, int type,\n\n                        void *response, const char *fmt, ...)\n\n{\n\n    dev_t rdev;\n\n    va_list ap;\n\n    int size = 0;\n\n    int retval = 0;\n\n    uint64_t offset;\n\n    ProxyHeader header = { 0, 0};\n\n    struct timespec spec[2];\n\n    int flags, mode, uid, gid;\n\n    V9fsString *name, *value;\n\n    V9fsString *path, *oldpath;\n\n    struct iovec *iovec = NULL, *reply = NULL;\n\n\n\n    qemu_mutex_lock(&proxy->mutex);\n\n\n\n    if (proxy->sockfd == -1) {\n\n        retval = -EIO;\n\n        goto err_out;\n\n    }\n\n    iovec = &proxy->out_iovec;\n\n    reply = &proxy->in_iovec;\n\n    va_start(ap, fmt);\n\n    switch (type) {\n\n    case T_OPEN:\n\n        path = va_arg(ap, V9fsString *);\n\n        flags = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, flags);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_OPEN;\n\n        }\n\n        break;\n\n    case T_CREATE:\n\n        path = va_arg(ap, V9fsString *);\n\n        flags = va_arg(ap, int);\n\n        mode = va_arg(ap, int);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sdddd\", path,\n\n                                    flags, mode, uid, gid);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_CREATE;\n\n        }\n\n        break;\n\n    case T_MKNOD:\n\n        path = va_arg(ap, V9fsString *);\n\n        mode = va_arg(ap, int);\n\n        rdev = va_arg(ap, long int);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddsdq\",\n\n                                    uid, gid, path, mode, rdev);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_MKNOD;\n\n        }\n\n        break;\n\n    case T_MKDIR:\n\n        path = va_arg(ap, V9fsString *);\n\n        mode = va_arg(ap, int);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddsd\",\n\n                                    uid, gid, path, mode);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_MKDIR;\n\n        }\n\n        break;\n\n    case T_SYMLINK:\n\n        oldpath = va_arg(ap, V9fsString *);\n\n        path = va_arg(ap, V9fsString *);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddss\",\n\n                                    uid, gid, oldpath, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_SYMLINK;\n\n        }\n\n        break;\n\n    case T_LINK:\n\n        oldpath = va_arg(ap, V9fsString *);\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\",\n\n                                    oldpath, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LINK;\n\n        }\n\n        break;\n\n    case T_LSTAT:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LSTAT;\n\n        }\n\n        break;\n\n    case T_READLINK:\n\n        path = va_arg(ap, V9fsString *);\n\n        size = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, size);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_READLINK;\n\n        }\n\n        break;\n\n    case T_STATFS:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_STATFS;\n\n        }\n\n        break;\n\n    case T_CHMOD:\n\n        path = va_arg(ap, V9fsString *);\n\n        mode = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, mode);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_CHMOD;\n\n        }\n\n        break;\n\n    case T_CHOWN:\n\n        path = va_arg(ap, V9fsString *);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sdd\", path, uid, gid);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_CHOWN;\n\n        }\n\n        break;\n\n    case T_TRUNCATE:\n\n        path = va_arg(ap, V9fsString *);\n\n        offset = va_arg(ap, uint64_t);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sq\", path, offset);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_TRUNCATE;\n\n        }\n\n        break;\n\n    case T_UTIME:\n\n        path = va_arg(ap, V9fsString *);\n\n        spec[0].tv_sec = va_arg(ap, long);\n\n        spec[0].tv_nsec = va_arg(ap, long);\n\n        spec[1].tv_sec = va_arg(ap, long);\n\n        spec[1].tv_nsec = va_arg(ap, long);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sqqqq\", path,\n\n                                    spec[0].tv_sec, spec[1].tv_nsec,\n\n                                    spec[1].tv_sec, spec[1].tv_nsec);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_UTIME;\n\n        }\n\n        break;\n\n    case T_RENAME:\n\n        oldpath = va_arg(ap, V9fsString *);\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\", oldpath, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_RENAME;\n\n        }\n\n        break;\n\n    case T_REMOVE:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_REMOVE;\n\n        }\n\n        break;\n\n    case T_LGETXATTR:\n\n        size = va_arg(ap, int);\n\n        path = va_arg(ap, V9fsString *);\n\n        name = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ,\n\n                                    \"dss\", size, path, name);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LGETXATTR;\n\n        }\n\n        break;\n\n    case T_LLISTXATTR:\n\n        size = va_arg(ap, int);\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ds\", size, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LLISTXATTR;\n\n        }\n\n        break;\n\n    case T_LSETXATTR:\n\n        path = va_arg(ap, V9fsString *);\n\n        name = va_arg(ap, V9fsString *);\n\n        value = va_arg(ap, V9fsString *);\n\n        size = va_arg(ap, int);\n\n        flags = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sssdd\",\n\n                                    path, name, value, size, flags);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LSETXATTR;\n\n        }\n\n        break;\n\n    case T_LREMOVEXATTR:\n\n        path = va_arg(ap, V9fsString *);\n\n        name = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\", path, name);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LREMOVEXATTR;\n\n        }\n\n        break;\n\n    case T_GETVERSION:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_GETVERSION;\n\n        }\n\n        break;\n\n    default:\n\n        error_report(\"Invalid type %d\", type);\n\n        retval = -EINVAL;\n\n        break;\n\n    }\n\n    va_end(ap);\n\n\n\n    if (retval < 0) {\n\n        goto err_out;\n\n    }\n\n\n\n    /* marshal the header details */\n\n    proxy_marshal(iovec, 0, \"dd\", header.type, header.size);\n\n    header.size += PROXY_HDR_SZ;\n\n\n\n    retval = qemu_write_full(proxy->sockfd, iovec->iov_base, header.size);\n\n    if (retval != header.size) {\n\n        goto close_error;\n\n    }\n\n\n\n    switch (type) {\n\n    case T_OPEN:\n\n    case T_CREATE:\n\n        /*\n\n         * A file descriptor is returned as response for\n\n         * T_OPEN,T_CREATE on success\n\n         */\n\n        if (v9fs_receivefd(proxy->sockfd, &retval) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_MKNOD:\n\n    case T_MKDIR:\n\n    case T_SYMLINK:\n\n    case T_LINK:\n\n    case T_CHMOD:\n\n    case T_CHOWN:\n\n    case T_RENAME:\n\n    case T_TRUNCATE:\n\n    case T_UTIME:\n\n    case T_REMOVE:\n\n    case T_LSETXATTR:\n\n    case T_LREMOVEXATTR:\n\n        if (v9fs_receive_status(proxy, reply, &retval) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_LSTAT:\n\n    case T_READLINK:\n\n    case T_STATFS:\n\n    case T_GETVERSION:\n\n        if (v9fs_receive_response(proxy, type, &retval, response) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_LGETXATTR:\n\n    case T_LLISTXATTR:\n\n        if (!size) {\n\n            if (v9fs_receive_status(proxy, reply, &retval) < 0) {\n\n                goto close_error;\n\n            }\n\n        } else {\n\n            if (v9fs_receive_response(proxy, type, &retval, response) < 0) {\n\n                goto close_error;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\nerr_out:\n\n    qemu_mutex_unlock(&proxy->mutex);\n\n    return retval;\n\n\n\nclose_error:\n\n    close(proxy->sockfd);\n\n    proxy->sockfd = -1;\n\n    qemu_mutex_unlock(&proxy->mutex);\n\n    return -EIO;\n\n}\n", "idx": 24933, "_split": "test", "_hash": "c173c7925c5be47b6ecc81cbc52c78f5"}
{"project": "qemu", "commit_id": "a1f0cce2ac0243572ff72aa561da67fe3766a395", "target": 1, "func": "static void scsi_req_set_status(SCSIDiskReq *r, int status, int sense_code)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n\n\n    r->req.status = status;\n\n    scsi_disk_set_sense(s, sense_code);\n\n}\n", "idx": 24968, "_split": "test", "_hash": "dd8ac8994a0897e3fd123fee72d58f4d"}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static inline void sdhci_blkgap_write(SDHCIState *s, uint8_t value)\n\n{\n\n    if ((value & SDHC_STOP_AT_GAP_REQ) && (s->blkgap & SDHC_STOP_AT_GAP_REQ)) {\n\n        return;\n\n    }\n\n    s->blkgap = value & SDHC_STOP_AT_GAP_REQ;\n\n\n\n    if ((value & SDHC_CONTINUE_REQ) && s->stopped_state &&\n\n            (s->blkgap & SDHC_STOP_AT_GAP_REQ) == 0) {\n\n        if (s->stopped_state == sdhc_gap_read) {\n\n            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_READ;\n\n            SDHCI_GET_CLASS(s)->read_block_from_card(s);\n\n        } else {\n\n            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_WRITE;\n\n            SDHCI_GET_CLASS(s)->write_block_to_card(s);\n\n        }\n\n        s->stopped_state = sdhc_not_stopped;\n\n    } else if (!s->stopped_state && (value & SDHC_STOP_AT_GAP_REQ)) {\n\n        if (s->prnsts & SDHC_DOING_READ) {\n\n            s->stopped_state = sdhc_gap_read;\n\n        } else if (s->prnsts & SDHC_DOING_WRITE) {\n\n            s->stopped_state = sdhc_gap_write;\n\n        }\n\n    }\n\n}\n", "idx": 25005, "_split": "test", "_hash": "998f063926815b22c3853bf55c612adf"}
{"project": "qemu", "commit_id": "568c73a4783cd981e9aa6de4f15dcda7829643ad", "target": 0, "func": "static void qemu_chr_parse_vc(QemuOpts *opts, ChardevBackend *backend,\n\n                              Error **errp)\n\n{\n\n    int val;\n\n\n\n    backend->vc = g_new0(ChardevVC, 1);\n\n\n\n    val = qemu_opt_get_number(opts, \"width\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_width = true;\n\n        backend->vc->width = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"height\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_height = true;\n\n        backend->vc->height = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"cols\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_cols = true;\n\n        backend->vc->cols = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"rows\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_rows = true;\n\n        backend->vc->rows = val;\n\n    }\n\n}\n", "idx": 25024, "_split": "test", "_hash": "5a2a2dbc0d7cdd9c470a47ac6487d6c6"}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "void helper_idivl_EAX_T0(void)\n\n{\n\n    int den, q, r;\n\n    int64_t num;\n\n    \n\n    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);\n\n    den = T0;\n\n    if (den == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n#ifdef BUGGY_GCC_DIV64\n\n    r = idiv32(&q, num, den);\n\n#else\n\n    q = (num / den);\n\n    r = (num % den);\n\n#endif\n\n    EAX = (uint32_t)q;\n\n    EDX = (uint32_t)r;\n\n}\n", "idx": 25075, "_split": "test", "_hash": "c837f9f87974b6665cc33700ffbe8da9"}
{"project": "qemu", "commit_id": "8dfe8e7f4facef400ef1c220f29196ae5cfc526c", "target": 0, "func": "static void ppc_spapr_init(MachineState *machine)\n\n{\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\n\n    sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    PowerPCCPU *cpu;\n\n    PCIHostState *phb;\n\n    int i;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *rma_region;\n\n    void *rma = NULL;\n\n    hwaddr rma_alloc_size;\n\n    hwaddr node0_size = spapr_node0_size();\n\n    uint32_t initrd_base = 0;\n\n    long kernel_size = 0, initrd_size = 0;\n\n    long load_limit, fw_size;\n\n    bool kernel_le = false;\n\n    char *filename;\n\n\n\n    msi_supported = true;\n\n\n\n    QLIST_INIT(&spapr->phbs);\n\n\n\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n\n\n\n    /* Allocate RMA if necessary */\n\n    rma_alloc_size = kvmppc_alloc_rma(&rma);\n\n\n\n    if (rma_alloc_size == -1) {\n\n        error_report(\"Unable to create RMA\");\n\n        exit(1);\n\n    }\n\n\n\n    if (rma_alloc_size && (rma_alloc_size < node0_size)) {\n\n        spapr->rma_size = rma_alloc_size;\n\n    } else {\n\n        spapr->rma_size = node0_size;\n\n\n\n        /* With KVM, we don't actually know whether KVM supports an\n\n         * unbounded RMA (PR KVM) or is limited by the hash table size\n\n         * (HV KVM using VRMA), so we always assume the latter\n\n         *\n\n         * In that case, we also limit the initial allocations for RTAS\n\n         * etc... to 256M since we have no way to know what the VRMA size\n\n         * is going to be as it depends on the size of the hash table\n\n         * isn't determined yet.\n\n         */\n\n        if (kvm_enabled()) {\n\n            spapr->vrma_adjust = 1;\n\n            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size > node0_size) {\n\n        error_report(\"Numa node 0 has to span the RMA (%#08\"HWADDR_PRIx\")\",\n\n                     spapr->rma_size);\n\n        exit(1);\n\n    }\n\n\n\n    /* Setup a load limit for the ramdisk leaving room for SLOF and FDT */\n\n    load_limit = MIN(spapr->rma_size, RTAS_MAX_ADDR) - FW_OVERHEAD;\n\n\n\n    /* We aim for a hash table of size 1/128 the size of RAM.  The\n\n     * normal rule of thumb is 1/64 the size of RAM, but that's much\n\n     * more than needed for the Linux guests we support. */\n\n    spapr->htab_shift = 18; /* Minimum architected size */\n\n    while (spapr->htab_shift <= 46) {\n\n        if ((1ULL << (spapr->htab_shift + 7)) >= machine->maxram_size) {\n\n            break;\n\n        }\n\n        spapr->htab_shift++;\n\n    }\n\n    spapr_alloc_htab(spapr);\n\n\n\n    /* Set up Interrupt Controller before we create the VCPUs */\n\n    spapr->icp = xics_system_init(machine,\n\n                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),\n\n                                               smp_threads),\n\n                                  XICS_IRQS, &error_fatal);\n\n\n\n    if (smc->dr_lmb_enabled) {\n\n        spapr_validate_node_memory(machine, &error_fatal);\n\n    }\n\n\n\n    /* init CPUs */\n\n    if (machine->cpu_model == NULL) {\n\n        machine->cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n\n    }\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(machine->cpu_model);\n\n        if (cpu == NULL) {\n\n            error_report(\"Unable to find PowerPC CPU definition\");\n\n            exit(1);\n\n        }\n\n        spapr_cpu_init(spapr, cpu, &error_fatal);\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        /* Enable H_LOGICAL_CI_* so SLOF can talk to in-kernel devices */\n\n        kvmppc_enable_logical_ci_hcalls();\n\n        kvmppc_enable_set_mode_hcall();\n\n    }\n\n\n\n    /* allocate RAM */\n\n    memory_region_allocate_system_memory(ram, NULL, \"ppc_spapr.ram\",\n\n                                         machine->ram_size);\n\n    memory_region_add_subregion(sysmem, 0, ram);\n\n\n\n    if (rma_alloc_size && rma) {\n\n        rma_region = g_new(MemoryRegion, 1);\n\n        memory_region_init_ram_ptr(rma_region, NULL, \"ppc_spapr.rma\",\n\n                                   rma_alloc_size, rma);\n\n        vmstate_register_ram_global(rma_region);\n\n        memory_region_add_subregion(sysmem, 0, rma_region);\n\n    }\n\n\n\n    /* initialize hotplug memory address space */\n\n    if (machine->ram_size < machine->maxram_size) {\n\n        ram_addr_t hotplug_mem_size = machine->maxram_size - machine->ram_size;\n\n\n\n        if (machine->ram_slots > SPAPR_MAX_RAM_SLOTS) {\n\n            error_report(\"Specified number of memory slots %\"\n\n                         PRIu64\" exceeds max supported %d\",\n\n                         machine->ram_slots, SPAPR_MAX_RAM_SLOTS);\n\n            exit(1);\n\n        }\n\n\n\n        spapr->hotplug_memory.base = ROUND_UP(machine->ram_size,\n\n                                              SPAPR_HOTPLUG_MEM_ALIGN);\n\n        memory_region_init(&spapr->hotplug_memory.mr, OBJECT(spapr),\n\n                           \"hotplug-memory\", hotplug_mem_size);\n\n        memory_region_add_subregion(sysmem, spapr->hotplug_memory.base,\n\n                                    &spapr->hotplug_memory.mr);\n\n    }\n\n\n\n    if (smc->dr_lmb_enabled) {\n\n        spapr_create_lmb_dr_connectors(spapr);\n\n    }\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n\n    if (!filename) {\n\n        error_report(\"Could not find LPAR rtas '%s'\", \"spapr-rtas.bin\");\n\n        exit(1);\n\n    }\n\n    spapr->rtas_size = get_image_size(filename);\n\n    spapr->rtas_blob = g_malloc(spapr->rtas_size);\n\n    if (load_image_size(filename, spapr->rtas_blob, spapr->rtas_size) < 0) {\n\n        error_report(\"Could not load LPAR rtas '%s'\", filename);\n\n        exit(1);\n\n    }\n\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n\n        error_report(\"RTAS too big ! 0x%zx bytes (max is 0x%x)\",\n\n                     (size_t)spapr->rtas_size, RTAS_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* Set up EPOW events infrastructure */\n\n    spapr_events_init(spapr);\n\n\n\n    /* Set up the RTC RTAS interfaces */\n\n    spapr_rtc_create(spapr);\n\n\n\n    /* Set up VIO bus */\n\n    spapr->vio_bus = spapr_vio_bus_init();\n\n\n\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    /* We always have at least the nvram device on VIO */\n\n    spapr_create_nvram(spapr);\n\n\n\n    /* Set up PCI */\n\n    spapr_pci_rtas_init();\n\n\n\n    phb = spapr_create_phb(spapr, 0);\n\n\n\n    for (i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!nd->model) {\n\n            nd->model = g_strdup(\"ibmveth\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n\n            spapr_vlan_create(spapr->vio_bus, nd);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n\n        spapr_vscsi_create(spapr->vio_bus);\n\n    }\n\n\n\n    /* Graphics */\n\n    if (spapr_vga_init(phb->bus, &error_fatal)) {\n\n        spapr->has_graphics = true;\n\n        machine->usb |= defaults_enabled() && !machine->usb_disabled;\n\n    }\n\n\n\n    if (machine->usb) {\n\n        if (smc->use_ohci_by_default) {\n\n            pci_create_simple(phb->bus, -1, \"pci-ohci\");\n\n        } else {\n\n            pci_create_simple(phb->bus, -1, \"nec-usb-xhci\");\n\n        }\n\n\n\n        if (spapr->has_graphics) {\n\n            USBBus *usb_bus = usb_bus_find(-1);\n\n\n\n            usb_create_simple(usb_bus, \"usb-kbd\");\n\n            usb_create_simple(usb_bus, \"usb-mouse\");\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n\n        error_report(\n\n            \"pSeries SLOF firmware requires >= %ldM guest RMA (Real Mode Area memory)\",\n\n            MIN_RMA_SLOF);\n\n        exit(1);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t lowaddr = 0;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, PPC_ELF_MACHINE, 0);\n\n        if (kernel_size == ELF_LOAD_WRONG_ENDIAN) {\n\n            kernel_size = load_elf(kernel_filename,\n\n                                   translate_kernel_address, NULL,\n\n                                   NULL, &lowaddr, NULL, 0, PPC_ELF_MACHINE, 0);\n\n            kernel_le = kernel_size > 0;\n\n        }\n\n        if (kernel_size < 0) {\n\n            error_report(\"error loading %s: %s\",\n\n                         kernel_filename, load_elf_strerror(kernel_size));\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            /* Try to locate the initrd in the gap between the kernel\n\n             * and the firmware. Add a bit of space just in case\n\n             */\n\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                error_report(\"could not load initial ram disk '%s'\",\n\n                             initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (!filename) {\n\n        error_report(\"Could not find LPAR firmware '%s'\", bios_name);\n\n        exit(1);\n\n    }\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size <= 0) {\n\n        error_report(\"Could not load LPAR firmware '%s'\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* FIXME: Should register things through the MachineState's qdev\n\n     * interface, this is a legacy from the sPAPREnvironment structure\n\n     * which predated MachineState but had a similar function */\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    /* Prepare the device tree */\n\n    spapr->fdt_skel = spapr_create_fdt_skel(initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            kernel_cmdline,\n\n                                            spapr->check_exception_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n\n\n    /* used by RTAS */\n\n    QTAILQ_INIT(&spapr->ccs_list);\n\n    qemu_register_reset(spapr_ccs_reset_hook, spapr);\n\n\n\n    qemu_register_boot_set(spapr_boot_set, spapr);\n\n}\n", "idx": 25103, "_split": "test", "_hash": "1a04402326bcc761f9bf0a32203733ab"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void n8x0_nand_setup(struct n800_s *s)\n\n{\n\n    char *otp_region;\n\n    DriveInfo *dinfo;\n\n\n\n    s->nand = qdev_create(NULL, \"onenand\");\n\n    qdev_prop_set_uint16(s->nand, \"manufacturer_id\", NAND_MFR_SAMSUNG);\n\n    /* Either 0x40 or 0x48 are OK for the device ID */\n\n    qdev_prop_set_uint16(s->nand, \"device_id\", 0x48);\n\n    qdev_prop_set_uint16(s->nand, \"version_id\", 0);\n\n    qdev_prop_set_int32(s->nand, \"shift\", 1);\n\n    dinfo = drive_get(IF_MTD, 0, 0);\n\n    if (dinfo) {\n\n        qdev_prop_set_drive_nofail(s->nand, \"drive\",\n\n                                   blk_bs(blk_by_legacy_dinfo(dinfo)));\n\n    }\n\n    qdev_init_nofail(s->nand);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(s->nand), 0,\n\n                       qdev_get_gpio_in(s->mpu->gpio, N8X0_ONENAND_GPIO));\n\n    omap_gpmc_attach(s->mpu->gpmc, N8X0_ONENAND_CS,\n\n                     sysbus_mmio_get_region(SYS_BUS_DEVICE(s->nand), 0));\n\n    otp_region = onenand_raw_otp(s->nand);\n\n\n\n    memcpy(otp_region + 0x000, n8x0_cal_wlan_mac, sizeof(n8x0_cal_wlan_mac));\n\n    memcpy(otp_region + 0x800, n8x0_cal_bt_id, sizeof(n8x0_cal_bt_id));\n\n    /* XXX: in theory should also update the OOB for both pages */\n\n}\n", "idx": 25113, "_split": "test", "_hash": "cc6834e256cb6f4afffb887276c70282"}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void cpu_dump_state (CPUState *env, FILE *f, \n\n                     int (*cpu_fprintf)(FILE *f, const char *fmt, ...),\n\n                     int flags)\n\n{\n\n    uint32_t c0_status;\n\n    int i;\n\n    \n\n    cpu_fprintf(f, \"pc=0x\" TARGET_FMT_lx \" HI=0x\" TARGET_FMT_lx \" LO=0x\" TARGET_FMT_lx \" ds %04x \" TARGET_FMT_lx \" %d\\n\",\n\n                env->PC, env->HI, env->LO, env->hflags, env->btarget, env->bcond);\n\n    for (i = 0; i < 32; i++) {\n\n        if ((i & 3) == 0)\n\n            cpu_fprintf(f, \"GPR%02d:\", i);\n\n        cpu_fprintf(f, \" %s \" TARGET_FMT_lx, regnames[i], env->gpr[i]);\n\n        if ((i & 3) == 3)\n\n            cpu_fprintf(f, \"\\n\");\n\n    }\n\n\n\n    c0_status = env->CP0_Status;\n\n\n\n    cpu_fprintf(f, \"CP0 Status  0x%08x Cause   0x%08x EPC    0x\" TARGET_FMT_lx \"\\n\",\n\n                c0_status, env->CP0_Cause, env->CP0_EPC);\n\n    cpu_fprintf(f, \"    Config0 0x%08x Config1 0x%08x LLAddr 0x\" TARGET_FMT_lx \"\\n\",\n\n                env->CP0_Config0, env->CP0_Config1, env->CP0_LLAddr);\n\n    if (c0_status & (1 << CP0St_CU1))\n\n        fpu_dump_state(env, f, cpu_fprintf, flags);\n\n#if defined(TARGET_MIPS64) && defined(MIPS_DEBUG_SIGN_EXTENSIONS)\n\n    cpu_mips_check_sign_extensions(env, f, cpu_fprintf, flags);\n\n#endif\n\n}\n", "idx": 25119, "_split": "test", "_hash": "bfafc13de56dedce4a84ce14053818f9"}
{"project": "qemu", "commit_id": "eb513f82f04fab442cdef9db698dafc852275f7f", "target": 1, "func": "uint64_t helper_ld_asi(CPUSPARCState *env, target_ulong addr, int asi, int size,\n\n                       int sign)\n\n{\n\n    uint64_t ret = 0;\n\n#if defined(DEBUG_ASI)\n\n    target_ulong last_addr = addr;\n\n#endif\n\n\n\n    if (asi < 0x80) {\n\n        helper_raise_exception(env, TT_PRIV_ACT);\n\n    }\n\n\n\n    helper_check_align(env, addr, size - 1);\n\n    addr = asi_address_mask(env, asi, addr);\n\n\n\n    switch (asi) {\n\n    case 0x82: /* Primary no-fault */\n\n    case 0x8a: /* Primary no-fault LE */\n\n        if (page_check_range(addr, size, PAGE_READ) == -1) {\n\n#ifdef DEBUG_ASI\n\n            dump_asi(\"read \", last_addr, asi, size, ret);\n\n#endif\n\n            return 0;\n\n        }\n\n        /* Fall through */\n\n    case 0x80: /* Primary */\n\n    case 0x88: /* Primary LE */\n\n        {\n\n            switch (size) {\n\n            case 1:\n\n                ret = ldub_raw(addr);\n\n                break;\n\n            case 2:\n\n                ret = lduw_raw(addr);\n\n                break;\n\n            case 4:\n\n                ret = ldl_raw(addr);\n\n                break;\n\n            default:\n\n            case 8:\n\n                ret = ldq_raw(addr);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    case 0x83: /* Secondary no-fault */\n\n    case 0x8b: /* Secondary no-fault LE */\n\n        if (page_check_range(addr, size, PAGE_READ) == -1) {\n\n#ifdef DEBUG_ASI\n\n            dump_asi(\"read \", last_addr, asi, size, ret);\n\n#endif\n\n            return 0;\n\n        }\n\n        /* Fall through */\n\n    case 0x81: /* Secondary */\n\n    case 0x89: /* Secondary LE */\n\n        /* XXX */\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* Convert from little endian */\n\n    switch (asi) {\n\n    case 0x88: /* Primary LE */\n\n    case 0x89: /* Secondary LE */\n\n    case 0x8a: /* Primary no-fault LE */\n\n    case 0x8b: /* Secondary no-fault LE */\n\n        switch (size) {\n\n        case 2:\n\n            ret = bswap16(ret);\n\n            break;\n\n        case 4:\n\n            ret = bswap32(ret);\n\n            break;\n\n        case 8:\n\n            ret = bswap64(ret);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* Convert to signed number */\n\n    if (sign) {\n\n        switch (size) {\n\n        case 1:\n\n            ret = (int8_t) ret;\n\n            break;\n\n        case 2:\n\n            ret = (int16_t) ret;\n\n            break;\n\n        case 4:\n\n            ret = (int32_t) ret;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n#ifdef DEBUG_ASI\n\n    dump_asi(\"read \", last_addr, asi, size, ret);\n\n#endif\n\n    return ret;\n\n}\n", "idx": 25134, "_split": "test", "_hash": "670c42ea1695fc556141928ec0e80dcb"}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "static void spr_write_dbatu_h (void *opaque, int sprn)\n\n{\n\n    DisasContext *ctx = opaque;\n\n\n\n    gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);\n\n    RET_STOP(ctx);\n\n}\n", "idx": 25163, "_split": "test", "_hash": "a97dfe578c7c616b4b33aeb2d31b8de2"}
{"project": "qemu", "commit_id": "9eca6cc64392b4ad8bd8723e840f491fa36524ad", "target": 0, "func": "sprintf_len(char *string, const char *format, ...)\n\n#else\n\nsprintf_len(va_alist) va_dcl\n\n#endif\n\n{\n\n\tva_list args;\n\n#ifdef __STDC__\n\n\tva_start(args, format);\n\n#else\n\n\tchar *string;\n\n\tchar *format;\n\n\tva_start(args);\n\n\tstring = va_arg(args, char *);\n\n\tformat = va_arg(args, char *);\n\n#endif\n\n\tvsprintf(string, format, args);\n\n\treturn strlen(string);\n\n}\n", "idx": 25167, "_split": "test", "_hash": "b6cc579b56cde8a255a55f9b3171e4f7"}
{"project": "qemu", "commit_id": "9d8256ebc0ef88fb1f35d0405893962d20cc10ad", "target": 1, "func": "void sdl2_gl_scanout(DisplayChangeListener *dcl,\n\n                     uint32_t backing_id, bool backing_y_0_top,\n\n\n                     uint32_t x, uint32_t y,\n\n                     uint32_t w, uint32_t h)\n\n{\n\n    struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);\n\n\n\n    assert(scon->opengl);\n\n    scon->x = x;\n\n    scon->y = y;\n\n    scon->w = w;\n\n    scon->h = h;\n\n    scon->tex_id = backing_id;\n\n    scon->y0_top = backing_y_0_top;\n\n\n\n    SDL_GL_MakeCurrent(scon->real_window, scon->winctx);\n\n\n\n    if (scon->tex_id == 0 || scon->w == 0 || scon->h == 0) {\n\n        sdl2_set_scanout_mode(scon, false);\n\n        return;\n\n    }\n\n\n\n    sdl2_set_scanout_mode(scon, true);\n\n    if (!scon->fbo_id) {\n\n        glGenFramebuffers(1, &scon->fbo_id);\n\n    }\n\n\n\n    glBindFramebuffer(GL_FRAMEBUFFER_EXT, scon->fbo_id);\n\n    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,\n\n                              GL_TEXTURE_2D, scon->tex_id, 0);\n\n}", "idx": 25182, "_split": "test", "_hash": "87c7992c02daddb64017f8f490f9f51d"}
{"project": "qemu", "commit_id": "40f08e87f613273f9dcc8df7d6a0f574b7d28d05", "target": 1, "func": "static void mm_stop_timer(struct qemu_alarm_timer *t)\n\n{\n\n    timeKillEvent(mm_timer);\n\n    timeEndPeriod(mm_period);\n\n}\n", "idx": 25185, "_split": "test", "_hash": "d70f2f7c04ebba458c618fd333f5753d"}
{"project": "qemu", "commit_id": "5c32be5baf41aec4f4675d2bf24f9948756abf3c", "target": 1, "func": "static void tcg_out_qemu_st(TCGContext *s, TCGReg data, TCGReg addr,\n\n                            TCGMemOpIdx oi)\n\n{\n\n    TCGMemOp memop = get_memop(oi);\n\n#ifdef CONFIG_SOFTMMU\n\n    unsigned memi = get_mmuidx(oi);\n\n    TCGReg addrz, param;\n\n    tcg_insn_unit *func;\n\n    tcg_insn_unit *label_ptr;\n\n\n\n    addrz = tcg_out_tlb_load(s, addr, memi, memop,\n\n                             offsetof(CPUTLBEntry, addr_write));\n\n\n\n    /* The fast path is exactly one insn.  Thus we can perform the entire\n\n       TLB Hit in the (annulled) delay slot of the branch over TLB Miss.  */\n\n    /* beq,a,pt %[xi]cc, label0 */\n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT\n\n                  | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);\n\n    /* delay slot */\n\n    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,\n\n                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);\n\n\n\n    /* TLB Miss.  */\n\n\n\n    param = TCG_REG_O1;\n\n    if (!SPARC64 && TARGET_LONG_BITS == 64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, addr);\n\n    if (!SPARC64 && (memop & MO_SIZE) == MO_64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, data);\n\n\n\n    func = qemu_st_trampoline[memop & (MO_BSWAP | MO_SIZE)];\n\n    tcg_debug_assert(func != NULL);\n\n    tcg_out_call_nodelay(s, func);\n\n    /* delay slot */\n\n    tcg_out_movi(s, TCG_TYPE_I32, param, oi);\n\n\n\n    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));\n\n#else\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);\n\n        addr = TCG_REG_T1;\n\n    }\n\n    tcg_out_ldst_rr(s, data, addr,\n\n                    (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0),\n\n                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);\n\n#endif /* CONFIG_SOFTMMU */\n\n}\n", "idx": 25189, "_split": "test", "_hash": "47e66c56c185d9b8dddb4122c0731247"}
{"project": "qemu", "commit_id": "871d2f079661323a7645b388eb5ae8d7eeb3117c", "target": 0, "func": "QEMUFile *qemu_fopen_fd(int fd)\n\n{\n\n    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));\n\n\n\n    if (s == NULL)\n\n        return NULL;\n\n\n\n    s->fd = fd;\n\n    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);\n\n    return s->file;\n\n}\n", "idx": 25223, "_split": "test", "_hash": "2cce663ac83a5c4661dce27b11d58fef"}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static void boston_lcd_event(void *opaque, int event)\n\n{\n\n    BostonState *s = opaque;\n\n    if (event == CHR_EVENT_OPENED && !s->lcd_inited) {\n\n        qemu_chr_fe_printf(&s->lcd_display, \"        \");\n\n        s->lcd_inited = true;\n\n    }\n\n}\n", "idx": 25247, "_split": "test", "_hash": "3dbf57916c00218f9a98b2b64aa4b56a"}
{"project": "qemu", "commit_id": "ba7806ad92a2f6b1625cfa67d44dc1b71e3be44e", "target": 1, "func": "void add_command(const cmdinfo_t *ci)\n\n{\n\n    cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab));\n\n    cmdtab[ncmds - 1] = *ci;\n\n    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);\n\n}\n", "idx": 25252, "_split": "test", "_hash": "d39c69fb364f58b86e8fdc2991405530"}
{"project": "qemu", "commit_id": "af7e9e74c6a62a5bcd911726a9e88d28b61490e0", "target": 1, "func": "static void openpic_update_irq(OpenPICState *opp, int n_IRQ)\n\n{\n\n    IRQ_src_t *src;\n\n    int i;\n\n\n\n    src = &opp->src[n_IRQ];\n\n\n\n    if (!src->pending) {\n\n        /* no irq pending */\n\n        DPRINTF(\"%s: IRQ %d is not pending\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ipvp & IPVP_MASK_MASK) {\n\n        /* Interrupt source is disabled */\n\n        DPRINTF(\"%s: IRQ %d is disabled\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (IPVP_PRIORITY(src->ipvp) == 0) {\n\n        /* Priority set to zero */\n\n        DPRINTF(\"%s: IRQ %d has 0 priority\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ipvp & IPVP_ACTIVITY_MASK) {\n\n        /* IRQ already active */\n\n        DPRINTF(\"%s: IRQ %d is already active\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ide == 0) {\n\n        /* No target */\n\n        DPRINTF(\"%s: IRQ %d has no target\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n\n\n    if (src->ide == (1 << src->last_cpu)) {\n\n        /* Only one CPU is allowed to receive this IRQ */\n\n        IRQ_local_pipe(opp, src->last_cpu, n_IRQ);\n\n    } else if (!(src->ipvp & IPVP_MODE_MASK)) {\n\n        /* Directed delivery mode */\n\n        for (i = 0; i < opp->nb_cpus; i++) {\n\n            if (src->ide & (1 << i)) {\n\n                IRQ_local_pipe(opp, i, n_IRQ);\n\n            }\n\n        }\n\n    } else {\n\n        /* Distributed delivery mode */\n\n        for (i = src->last_cpu + 1; i != src->last_cpu; i++) {\n\n            if (i == opp->nb_cpus)\n\n                i = 0;\n\n            if (src->ide & (1 << i)) {\n\n                IRQ_local_pipe(opp, i, n_IRQ);\n\n                src->last_cpu = i;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 25260, "_split": "test", "_hash": "ba6ed3ccd64d4cdfa5b47eb33185d011"}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static inline void usb_bt_fifo_out_enqueue(struct USBBtState *s,\n\n                struct usb_hci_out_fifo_s *fifo,\n\n                void (*send)(struct HCIInfo *, const uint8_t *, int),\n\n                int (*complete)(const uint8_t *, int),\n\n                const uint8_t *data, int len)\n\n{\n\n    if (fifo->len) {\n\n        memcpy(fifo->data + fifo->len, data, len);\n\n        fifo->len += len;\n\n        if (complete(fifo->data, fifo->len)) {\n\n            send(s->hci, fifo->data, fifo->len);\n\n            fifo->len = 0;\n\n        }\n\n    } else if (complete(data, len))\n\n        send(s->hci, data, len);\n\n    else {\n\n        memcpy(fifo->data, data, len);\n\n        fifo->len = len;\n\n    }\n\n\n\n    /* TODO: do we need to loop? */\n\n}\n", "idx": 25263, "_split": "test", "_hash": "977999371cb5304ba88f10da602f77d4"}
{"project": "qemu", "commit_id": "b3be28969b797b27d7f7f806827e9898e4ee08f0", "target": 0, "func": "static int ram_save_compressed_page(QEMUFile *f, PageSearchStatus *pss,\n\n                                    bool last_stage,\n\n                                    uint64_t *bytes_transferred)\n\n{\n\n    int pages = -1;\n\n    uint64_t bytes_xmit;\n\n    uint8_t *p;\n\n    int ret;\n\n    RAMBlock *block = pss->block;\n\n    ram_addr_t offset = pss->offset;\n\n\n\n    p = block->host + offset;\n\n\n\n    bytes_xmit = 0;\n\n    ret = ram_control_save_page(f, block->offset,\n\n                                offset, TARGET_PAGE_SIZE, &bytes_xmit);\n\n    if (bytes_xmit) {\n\n        *bytes_transferred += bytes_xmit;\n\n        pages = 1;\n\n    }\n\n    if (block == last_sent_block) {\n\n        offset |= RAM_SAVE_FLAG_CONTINUE;\n\n    }\n\n    if (ret != RAM_SAVE_CONTROL_NOT_SUPP) {\n\n        if (ret != RAM_SAVE_CONTROL_DELAYED) {\n\n            if (bytes_xmit > 0) {\n\n                acct_info.norm_pages++;\n\n            } else if (bytes_xmit == 0) {\n\n                acct_info.dup_pages++;\n\n            }\n\n        }\n\n    } else {\n\n        /* When starting the process of a new block, the first page of\n\n         * the block should be sent out before other pages in the same\n\n         * block, and all the pages in last block should have been sent\n\n         * out, keeping this order is important, because the 'cont' flag\n\n         * is used to avoid resending the block name.\n\n         */\n\n        if (block != last_sent_block) {\n\n            flush_compressed_data(f);\n\n            pages = save_zero_page(f, block, offset, p, bytes_transferred);\n\n            if (pages == -1) {\n\n                set_compress_params(&comp_param[0], block, offset);\n\n                /* Use the qemu thread to compress the data to make sure the\n\n                 * first page is sent out before other pages\n\n                 */\n\n                bytes_xmit = do_compress_ram_page(&comp_param[0]);\n\n                acct_info.norm_pages++;\n\n                qemu_put_qemu_file(f, comp_param[0].file);\n\n                *bytes_transferred += bytes_xmit;\n\n                pages = 1;\n\n            }\n\n        } else {\n\n            pages = save_zero_page(f, block, offset, p, bytes_transferred);\n\n            if (pages == -1) {\n\n                pages = compress_page_with_multi_thread(f, block, offset,\n\n                                                        bytes_transferred);\n\n            }\n\n        }\n\n    }\n\n\n\n    return pages;\n\n}\n", "idx": 25284, "_split": "test", "_hash": "2560a98b3d521b2c2eb3b9622ead4bd1"}
{"project": "qemu", "commit_id": "554b614765090f47d97a20ca6981e17e96515ec1", "target": 0, "func": "void qmp_block_stream(bool has_job_id, const char *job_id, const char *device,\n\n                      bool has_base, const char *base,\n\n                      bool has_backing_file, const char *backing_file,\n\n                      bool has_speed, int64_t speed,\n\n                      bool has_on_error, BlockdevOnError on_error,\n\n                      Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *base_bs = NULL;\n\n    AioContext *aio_context;\n\n    Error *local_err = NULL;\n\n    const char *base_name = NULL;\n\n\n\n    if (!has_on_error) {\n\n        on_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n\n\n    bs = qmp_get_root_bs(device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_STREAM, errp)) {\n\n        goto out;\n\n    }\n\n\n\n    if (has_base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n        if (base_bs == NULL) {\n\n            error_setg(errp, QERR_BASE_NOT_FOUND, base);\n\n            goto out;\n\n        }\n\n        assert(bdrv_get_aio_context(base_bs) == aio_context);\n\n        base_name = base;\n\n    }\n\n\n\n    /* if we are streaming the entire chain, the result will have no backing\n\n     * file, and specifying one is therefore an error */\n\n    if (base_bs == NULL && has_backing_file) {\n\n        error_setg(errp, \"backing file specified, but streaming the \"\n\n                         \"entire chain\");\n\n        goto out;\n\n    }\n\n\n\n    /* backing_file string overrides base bs filename */\n\n    base_name = has_backing_file ? backing_file : base_name;\n\n\n\n    stream_start(has_job_id ? job_id : NULL, bs, base_bs, base_name,\n\n                 has_speed ? speed : 0, on_error, block_job_cb, bs, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out;\n\n    }\n\n\n\n    trace_qmp_block_stream(bs, bs->job);\n\n\n\nout:\n\n    aio_context_release(aio_context);\n\n}\n", "idx": 25310, "_split": "test", "_hash": "c151a67cb723affc213398cd4a314b2a"}
{"project": "qemu", "commit_id": "39f80521df1e7f1252960d1ada2bd1a41d4d2cd3", "target": 0, "func": "static int inet_listen_saddr(InetSocketAddress *saddr,\n\n                             int port_offset,\n\n                             bool update_addr,\n\n                             Error **errp)\n\n{\n\n    struct addrinfo ai,*res,*e;\n\n    char port[33];\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int slisten, rc, port_min, port_max, p;\n\n    Error *err = NULL;\n\n\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_PASSIVE;\n\n    if (saddr->has_numeric && saddr->numeric) {\n\n        ai.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;\n\n    }\n\n    ai.ai_family = inet_ai_family_from_address(saddr, &err);\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return -1;\n\n    }\n\n\n\n    if (saddr->host == NULL) {\n\n        error_setg(errp, \"host not specified\");\n\n        return -1;\n\n    }\n\n    if (saddr->port != NULL) {\n\n        pstrcpy(port, sizeof(port), saddr->port);\n\n    } else {\n\n        port[0] = '\\0';\n\n    }\n\n\n\n    /* lookup */\n\n    if (port_offset) {\n\n        unsigned long long baseport;\n\n        if (strlen(port) == 0) {\n\n            error_setg(errp, \"port not specified\");\n\n            return -1;\n\n        }\n\n        if (parse_uint_full(port, &baseport, 10) < 0) {\n\n            error_setg(errp, \"can't convert to a number: %s\", port);\n\n            return -1;\n\n        }\n\n        if (baseport > 65535 ||\n\n            baseport + port_offset > 65535) {\n\n            error_setg(errp, \"port %s out of range\", port);\n\n            return -1;\n\n        }\n\n        snprintf(port, sizeof(port), \"%d\", (int)baseport + port_offset);\n\n    }\n\n    rc = getaddrinfo(strlen(saddr->host) ? saddr->host : NULL,\n\n                     strlen(port) ? port : NULL, &ai, &res);\n\n    if (rc != 0) {\n\n        error_setg(errp, \"address resolution failed for %s:%s: %s\",\n\n                   saddr->host, port, gai_strerror(rc));\n\n        return -1;\n\n    }\n\n\n\n    /* create socket + bind */\n\n    for (e = res; e != NULL; e = e->ai_next) {\n\n        getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,\n\n\t\t        uaddr,INET6_ADDRSTRLEN,uport,32,\n\n\t\t        NI_NUMERICHOST | NI_NUMERICSERV);\n\n        slisten = qemu_socket(e->ai_family, e->ai_socktype, e->ai_protocol);\n\n        if (slisten < 0) {\n\n            if (!e->ai_next) {\n\n                error_setg_errno(errp, errno, \"Failed to create socket\");\n\n            }\n\n            continue;\n\n        }\n\n\n\n        socket_set_fast_reuse(slisten);\n\n\n\n        port_min = inet_getport(e);\n\n        port_max = saddr->has_to ? saddr->to + port_offset : port_min;\n\n        for (p = port_min; p <= port_max; p++) {\n\n            inet_setport(e, p);\n\n            if (try_bind(slisten, saddr, e) >= 0) {\n\n                goto listen;\n\n            }\n\n            if (p == port_max) {\n\n                if (!e->ai_next) {\n\n                    error_setg_errno(errp, errno, \"Failed to bind socket\");\n\n                }\n\n            }\n\n        }\n\n        closesocket(slisten);\n\n    }\n\n    freeaddrinfo(res);\n\n    return -1;\n\n\n\nlisten:\n\n    if (listen(slisten,1) != 0) {\n\n        error_setg_errno(errp, errno, \"Failed to listen on socket\");\n\n        closesocket(slisten);\n\n        freeaddrinfo(res);\n\n        return -1;\n\n    }\n\n    if (update_addr) {\n\n        g_free(saddr->host);\n\n        saddr->host = g_strdup(uaddr);\n\n        g_free(saddr->port);\n\n        saddr->port = g_strdup_printf(\"%d\",\n\n                                      inet_getport(e) - port_offset);\n\n        saddr->has_ipv6 = saddr->ipv6 = e->ai_family == PF_INET6;\n\n        saddr->has_ipv4 = saddr->ipv4 = e->ai_family != PF_INET6;\n\n    }\n\n    freeaddrinfo(res);\n\n    return slisten;\n\n}\n", "idx": 25353, "_split": "test", "_hash": "652ae3cc38439580d507ce3da7262e55"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void vmstate_unregister(const VMStateDescription *vmsd, void *opaque)\n\n{\n\n    SaveStateEntry *se, *new_se;\n\n\n\n    TAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) {\n\n        if (se->vmsd == vmsd && se->opaque == opaque) {\n\n            TAILQ_REMOVE(&savevm_handlers, se, entry);\n\n            qemu_free(se);\n\n        }\n\n    }\n\n}\n", "idx": 25370, "_split": "test", "_hash": "20aa18be52df4794ed18dc53e1641c70"}
{"project": "qemu", "commit_id": "edc243851279e3393000b28b6b69454cae1190ef", "target": 1, "func": "static int virtio_net_handle_mac(VirtIONet *n, uint8_t cmd,\n\n                                 struct iovec *iov, unsigned int iov_cnt)\n\n{\n\n    struct virtio_net_ctrl_mac mac_data;\n\n    size_t s;\n\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n\n\n    if (cmd == VIRTIO_NET_CTRL_MAC_ADDR_SET) {\n\n        if (iov_size(iov, iov_cnt) != sizeof(n->mac)) {\n\n            return VIRTIO_NET_ERR;\n\n        }\n\n        s = iov_to_buf(iov, iov_cnt, 0, &n->mac, sizeof(n->mac));\n\n        assert(s == sizeof(n->mac));\n\n        qemu_format_nic_info_str(qemu_get_queue(n->nic), n->mac);\n\n        rxfilter_notify(nc);\n\n\n\n        return VIRTIO_NET_OK;\n\n    }\n\n\n\n    if (cmd != VIRTIO_NET_CTRL_MAC_TABLE_SET) {\n\n        return VIRTIO_NET_ERR;\n\n    }\n\n\n\n    int in_use = 0;\n\n    int first_multi = 0;\n\n    uint8_t uni_overflow = 0;\n\n    uint8_t multi_overflow = 0;\n\n    uint8_t *macs = g_malloc0(MAC_TABLE_ENTRIES * ETH_ALEN);\n\n\n\n    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,\n\n                   sizeof(mac_data.entries));\n\n    mac_data.entries = ldl_p(&mac_data.entries);\n\n    if (s != sizeof(mac_data.entries)) {\n\n        goto error;\n\n    }\n\n    iov_discard_front(&iov, &iov_cnt, s);\n\n\n\n    if (mac_data.entries * ETH_ALEN > iov_size(iov, iov_cnt)) {\n\n        goto error;\n\n    }\n\n\n\n    if (mac_data.entries <= MAC_TABLE_ENTRIES) {\n\n        s = iov_to_buf(iov, iov_cnt, 0, macs,\n\n                       mac_data.entries * ETH_ALEN);\n\n        if (s != mac_data.entries * ETH_ALEN) {\n\n            goto error;\n\n        }\n\n        in_use += mac_data.entries;\n\n    } else {\n\n        uni_overflow = 1;\n\n    }\n\n\n\n    iov_discard_front(&iov, &iov_cnt, mac_data.entries * ETH_ALEN);\n\n\n\n    first_multi = in_use;\n\n\n\n    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,\n\n                   sizeof(mac_data.entries));\n\n    mac_data.entries = ldl_p(&mac_data.entries);\n\n    if (s != sizeof(mac_data.entries)) {\n\n        goto error;\n\n    }\n\n\n\n    iov_discard_front(&iov, &iov_cnt, s);\n\n\n\n    if (mac_data.entries * ETH_ALEN != iov_size(iov, iov_cnt)) {\n\n        goto error;\n\n    }\n\n\n\n    if (in_use + mac_data.entries <= MAC_TABLE_ENTRIES) {\n\n        s = iov_to_buf(iov, iov_cnt, 0, &macs[in_use * ETH_ALEN],\n\n                       mac_data.entries * ETH_ALEN);\n\n        if (s != mac_data.entries * ETH_ALEN) {\n\n            goto error;\n\n        }\n\n        in_use += mac_data.entries;\n\n    } else {\n\n        multi_overflow = 1;\n\n    }\n\n\n\n    n->mac_table.in_use = in_use;\n\n    n->mac_table.first_multi = first_multi;\n\n    n->mac_table.uni_overflow = uni_overflow;\n\n    n->mac_table.multi_overflow = multi_overflow;\n\n    memcpy(n->mac_table.macs, macs, MAC_TABLE_ENTRIES * ETH_ALEN);\n\n    g_free(macs);\n\n    rxfilter_notify(nc);\n\n\n\n    return VIRTIO_NET_OK;\n\n\n\nerror:\n\n    g_free(macs);\n\n    return VIRTIO_NET_ERR;\n\n}\n", "idx": 25382, "_split": "test", "_hash": "581b5fbf8fac97d1df4298723b60bf0c"}
{"project": "qemu", "commit_id": "70976a7926b42d87e0c575412b85a8f5c1e48fad", "target": 1, "func": "static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    if (n < 32) {\n\n#ifdef WORDS_BIGENDIAN\n\n        env->avr[n].u64[0] = ldq_p(mem_buf);\n\n        env->avr[n].u64[1] = ldq_p(mem_buf+8);\n\n#else\n\n        env->avr[n].u64[1] = ldq_p(mem_buf);\n\n        env->avr[n].u64[0] = ldq_p(mem_buf+8);\n\n#endif\n\n        return 16;\n\n    }\n\n    if (n == 33) {\n\n        env->vscr = ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    if (n == 34) {\n\n        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25459, "_split": "test", "_hash": "06b7fc648c26af3f40075ac30269ba17"}
{"project": "qemu", "commit_id": "94ef4f337fb614f18b765a8e0e878a4c23cdedcd", "target": 1, "func": "static void vga_draw_text(VGACommonState *s, int full_update)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s->con);\n\n    int cx, cy, cheight, cw, ch, cattr, height, width, ch_attr;\n\n    int cx_min, cx_max, linesize, x_incr, line, line1;\n\n    uint32_t offset, fgcol, bgcol, v, cursor_offset;\n\n    uint8_t *d1, *d, *src, *dest, *cursor_ptr;\n\n    const uint8_t *font_ptr, *font_base[2];\n\n    int dup9, line_offset;\n\n    uint32_t *palette;\n\n    uint32_t *ch_attr_ptr;\n\n    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL);\n\n\n\n    /* compute font data address (in plane 2) */\n\n    v = s->sr[VGA_SEQ_CHARACTER_MAP];\n\n    offset = (((v >> 4) & 1) | ((v << 1) & 6)) * 8192 * 4 + 2;\n\n    if (offset != s->font_offsets[0]) {\n\n        s->font_offsets[0] = offset;\n\n        full_update = 1;\n\n    }\n\n    font_base[0] = s->vram_ptr + offset;\n\n\n\n    offset = (((v >> 5) & 1) | ((v >> 1) & 6)) * 8192 * 4 + 2;\n\n    font_base[1] = s->vram_ptr + offset;\n\n    if (offset != s->font_offsets[1]) {\n\n        s->font_offsets[1] = offset;\n\n        full_update = 1;\n\n    }\n\n    if (s->plane_updated & (1 << 2) || s->has_chain4_alias) {\n\n        /* if the plane 2 was modified since the last display, it\n\n           indicates the font may have been modified */\n\n        s->plane_updated = 0;\n\n        full_update = 1;\n\n    }\n\n    full_update |= update_basic_params(s);\n\n\n\n    line_offset = s->line_offset;\n\n\n\n    vga_get_text_resolution(s, &width, &height, &cw, &cheight);\n\n    if ((height * width) <= 1) {\n\n        /* better than nothing: exit if transient size is too small */\n\n        return;\n\n    }\n\n    if ((height * width) > CH_ATTR_SIZE) {\n\n        /* better than nothing: exit if transient size is too big */\n\n        return;\n\n    }\n\n\n\n    if (width != s->last_width || height != s->last_height ||\n\n        cw != s->last_cw || cheight != s->last_ch || s->last_depth) {\n\n        s->last_scr_width = width * cw;\n\n        s->last_scr_height = height * cheight;\n\n        qemu_console_resize(s->con, s->last_scr_width, s->last_scr_height);\n\n        surface = qemu_console_surface(s->con);\n\n        dpy_text_resize(s->con, width, height);\n\n        s->last_depth = 0;\n\n        s->last_width = width;\n\n        s->last_height = height;\n\n        s->last_ch = cheight;\n\n        s->last_cw = cw;\n\n        full_update = 1;\n\n    }\n\n    full_update |= update_palette16(s);\n\n    palette = s->last_palette;\n\n    x_incr = cw * surface_bytes_per_pixel(surface);\n\n\n\n    if (full_update) {\n\n        s->full_update_text = 1;\n\n    }\n\n    if (s->full_update_gfx) {\n\n        s->full_update_gfx = 0;\n\n        full_update |= 1;\n\n    }\n\n\n\n    cursor_offset = ((s->cr[VGA_CRTC_CURSOR_HI] << 8) |\n\n                     s->cr[VGA_CRTC_CURSOR_LO]) - s->start_addr;\n\n    if (cursor_offset != s->cursor_offset ||\n\n        s->cr[VGA_CRTC_CURSOR_START] != s->cursor_start ||\n\n        s->cr[VGA_CRTC_CURSOR_END] != s->cursor_end) {\n\n      /* if the cursor position changed, we update the old and new\n\n         chars */\n\n        if (s->cursor_offset < CH_ATTR_SIZE)\n\n            s->last_ch_attr[s->cursor_offset] = -1;\n\n        if (cursor_offset < CH_ATTR_SIZE)\n\n            s->last_ch_attr[cursor_offset] = -1;\n\n        s->cursor_offset = cursor_offset;\n\n        s->cursor_start = s->cr[VGA_CRTC_CURSOR_START];\n\n        s->cursor_end = s->cr[VGA_CRTC_CURSOR_END];\n\n    }\n\n    cursor_ptr = s->vram_ptr + (s->start_addr + cursor_offset) * 4;\n\n    if (now >= s->cursor_blink_time) {\n\n        s->cursor_blink_time = now + VGA_TEXT_CURSOR_PERIOD_MS / 2;\n\n        s->cursor_visible_phase = !s->cursor_visible_phase;\n\n    }\n\n\n\n    dest = surface_data(surface);\n\n    linesize = surface_stride(surface);\n\n    ch_attr_ptr = s->last_ch_attr;\n\n    line = 0;\n\n    offset = s->start_addr * 4;\n\n    for(cy = 0; cy < height; cy++) {\n\n        d1 = dest;\n\n        src = s->vram_ptr + offset;\n\n        cx_min = width;\n\n        cx_max = -1;\n\n        for(cx = 0; cx < width; cx++) {\n\n            ch_attr = *(uint16_t *)src;\n\n            if (full_update || ch_attr != *ch_attr_ptr || src == cursor_ptr) {\n\n                if (cx < cx_min)\n\n                    cx_min = cx;\n\n                if (cx > cx_max)\n\n                    cx_max = cx;\n\n                *ch_attr_ptr = ch_attr;\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n                ch = ch_attr >> 8;\n\n                cattr = ch_attr & 0xff;\n\n#else\n\n                ch = ch_attr & 0xff;\n\n                cattr = ch_attr >> 8;\n\n#endif\n\n                font_ptr = font_base[(cattr >> 3) & 1];\n\n                font_ptr += 32 * 4 * ch;\n\n                bgcol = palette[cattr >> 4];\n\n                fgcol = palette[cattr & 0x0f];\n\n                if (cw == 16) {\n\n                    vga_draw_glyph16(d1, linesize,\n\n                                     font_ptr, cheight, fgcol, bgcol);\n\n                } else if (cw != 9) {\n\n                    vga_draw_glyph8(d1, linesize,\n\n                                    font_ptr, cheight, fgcol, bgcol);\n\n                } else {\n\n                    dup9 = 0;\n\n                    if (ch >= 0xb0 && ch <= 0xdf &&\n\n                        (s->ar[VGA_ATC_MODE] & 0x04)) {\n\n                        dup9 = 1;\n\n                    }\n\n                    vga_draw_glyph9(d1, linesize,\n\n                                    font_ptr, cheight, fgcol, bgcol, dup9);\n\n                }\n\n                if (src == cursor_ptr &&\n\n                    !(s->cr[VGA_CRTC_CURSOR_START] & 0x20) &&\n\n                    s->cursor_visible_phase) {\n\n                    int line_start, line_last, h;\n\n                    /* draw the cursor */\n\n                    line_start = s->cr[VGA_CRTC_CURSOR_START] & 0x1f;\n\n                    line_last = s->cr[VGA_CRTC_CURSOR_END] & 0x1f;\n\n                    /* XXX: check that */\n\n                    if (line_last > cheight - 1)\n\n                        line_last = cheight - 1;\n\n                    if (line_last >= line_start && line_start < cheight) {\n\n                        h = line_last - line_start + 1;\n\n                        d = d1 + linesize * line_start;\n\n                        if (cw == 16) {\n\n                            vga_draw_glyph16(d, linesize,\n\n                                             cursor_glyph, h, fgcol, bgcol);\n\n                        } else if (cw != 9) {\n\n                            vga_draw_glyph8(d, linesize,\n\n                                            cursor_glyph, h, fgcol, bgcol);\n\n                        } else {\n\n                            vga_draw_glyph9(d, linesize,\n\n                                            cursor_glyph, h, fgcol, bgcol, 1);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            d1 += x_incr;\n\n            src += 4;\n\n            ch_attr_ptr++;\n\n        }\n\n        if (cx_max != -1) {\n\n            dpy_gfx_update(s->con, cx_min * cw, cy * cheight,\n\n                           (cx_max - cx_min + 1) * cw, cheight);\n\n        }\n\n        dest += linesize * cheight;\n\n        line1 = line + cheight;\n\n        offset += line_offset;\n\n        if (line < s->line_compare && line1 >= s->line_compare) {\n\n            offset = 0;\n\n        }\n\n        line = line1;\n\n    }\n\n}\n", "idx": 25472, "_split": "test", "_hash": "2409ff6259939ca60ecc2f1c9ba5936e"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "int64_t qemu_ftell(QEMUFile *f)\n\n{\n\n    qemu_fflush(f);\n\n    return f->pos;\n\n}\n", "idx": 25492, "_split": "test", "_hash": "6d5efda0ea723f19ece8077cb6634fb8"}
{"project": "qemu", "commit_id": "30d335d68d93705eb346387c03bb6aca0f52454a", "target": 1, "func": "static PCIDevice *qemu_pci_hot_add_storage(Monitor *mon,\n\n                                           const char *devaddr,\n\n                                           const char *opts)\n\n{\n\n    PCIDevice *dev;\n\n    DriveInfo *dinfo = NULL;\n\n    int type = -1;\n\n    char buf[128];\n\n    PCIBus *bus;\n\n    int devfn;\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", opts)) {\n\n        if (!strcmp(buf, \"scsi\"))\n\n            type = IF_SCSI;\n\n        else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n        } else {\n\n            monitor_printf(mon, \"type %s not a hotpluggable PCI device.\\n\", buf);\n\n            return NULL;\n\n        }\n\n    } else {\n\n        monitor_printf(mon, \"no if= specified\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"file\", opts)) {\n\n        dinfo = add_init_drive(opts);\n\n        if (!dinfo)\n\n            return NULL;\n\n        if (dinfo->devaddr) {\n\n            monitor_printf(mon, \"Parameter addr not supported\\n\");\n\n            return NULL;\n\n        }\n\n    } else {\n\n        dinfo = NULL;\n\n    }\n\n\n\n    bus = pci_get_bus_devfn(&devfn, devaddr);\n\n    if (!bus) {\n\n        monitor_printf(mon, \"Invalid PCI device address %s\\n\", devaddr);\n\n        return NULL;\n\n    }\n\n\n\n    switch (type) {\n\n    case IF_SCSI:\n\n        if (!dinfo) {\n\n            monitor_printf(mon, \"scsi requires a backing file/device.\\n\");\n\n            return NULL;\n\n        }\n\n        dev = pci_create(bus, devfn, \"lsi53c895a\");\n\n        if (qdev_init(&dev->qdev) < 0)\n\n            dev = NULL;\n\n        if (dev) {\n\n            BusState *scsibus = QLIST_FIRST(&dev->qdev.child_bus);\n\n            scsi_bus_legacy_add_drive(DO_UPCAST(SCSIBus, qbus, scsibus),\n\n                                      dinfo, dinfo->unit);\n\n        }\n\n        break;\n\n    case IF_VIRTIO:\n\n        if (!dinfo) {\n\n            monitor_printf(mon, \"virtio requires a backing file/device.\\n\");\n\n            return NULL;\n\n        }\n\n        dev = pci_create(bus, devfn, \"virtio-blk-pci\");\n\n        qdev_prop_set_drive(&dev->qdev, \"drive\", dinfo);\n\n        if (qdev_init(&dev->qdev) < 0)\n\n            dev = NULL;\n\n        break;\n\n    default:\n\n        dev = NULL;\n\n    }\n\n    return dev;\n\n}\n", "idx": 25505, "_split": "test", "_hash": "621dbebb49a979de80f5ff26bbfcb76b"}
{"project": "qemu", "commit_id": "6fedcaa1c5419fa89c31fd34dabbd71861c615d2", "target": 0, "func": "uint16_t eeprom93xx_read(eeprom_t *eeprom)\n\n{\n\n    /* Return status of pin DO (0 or 1). */\n\n    logout(\"CS=%u DO=%u\\n\", eeprom->eecs, eeprom->eedo);\n\n    return (eeprom->eedo);\n\n}\n", "idx": 25510, "_split": "test", "_hash": "9fca777de1b614d91ff49b54e7dccc38"}
{"project": "qemu", "commit_id": "f3172a0e2e7bd983cada19f11d9bb59400e0dd3d", "target": 0, "func": "static void sysctl_write(void *opaque, target_phys_addr_t addr, uint32_t value)\n\n{\n\n    MilkymistSysctlState *s = opaque;\n\n\n\n    trace_milkymist_sysctl_memory_write(addr, value);\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_GPIO_OUT:\n\n    case R_GPIO_INTEN:\n\n    case R_TIMER0_COUNTER:\n\n        if (value > s->regs[R_TIMER0_COUNTER]) {\n\n            value = s->regs[R_TIMER0_COUNTER];\n\n            error_report(\"milkymist_sysctl: timer0: trying to write a \"\n\n                    \"value greater than the limit. Clipping.\");\n\n        }\n\n        /* milkymist timer counts up */\n\n        value = s->regs[R_TIMER0_COUNTER] - value;\n\n        ptimer_set_count(s->ptimer0, value);\n\n        break;\n\n    case R_TIMER1_COUNTER:\n\n        if (value > s->regs[R_TIMER1_COUNTER]) {\n\n            value = s->regs[R_TIMER1_COUNTER];\n\n            error_report(\"milkymist_sysctl: timer1: trying to write a \"\n\n                    \"value greater than the limit. Clipping.\");\n\n        }\n\n        /* milkymist timer counts up */\n\n        value = s->regs[R_TIMER1_COUNTER] - value;\n\n        ptimer_set_count(s->ptimer1, value);\n\n        break;\n\n    case R_TIMER0_COMPARE:\n\n        ptimer_set_limit(s->ptimer0, value, 0);\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_TIMER1_COMPARE:\n\n        ptimer_set_limit(s->ptimer1, value, 0);\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_TIMER0_CONTROL:\n\n        s->regs[addr] = value;\n\n        if (s->regs[R_TIMER0_CONTROL] & CTRL_ENABLE) {\n\n            trace_milkymist_sysctl_start_timer1();\n\n            ptimer_run(s->ptimer0, 0);\n\n        } else {\n\n            trace_milkymist_sysctl_stop_timer1();\n\n            ptimer_stop(s->ptimer0);\n\n        }\n\n        break;\n\n    case R_TIMER1_CONTROL:\n\n        s->regs[addr] = value;\n\n        if (s->regs[R_TIMER1_CONTROL] & CTRL_ENABLE) {\n\n            trace_milkymist_sysctl_start_timer1();\n\n            ptimer_run(s->ptimer1, 0);\n\n        } else {\n\n            trace_milkymist_sysctl_stop_timer1();\n\n            ptimer_stop(s->ptimer1);\n\n        }\n\n        break;\n\n    case R_ICAP:\n\n        sysctl_icap_write(s, value);\n\n        break;\n\n    case R_SYSTEM_ID:\n\n        qemu_system_reset_request();\n\n        break;\n\n\n\n    case R_GPIO_IN:\n\n    case R_CAPABILITIES:\n\n        error_report(\"milkymist_sysctl: write to read-only register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n\n\n    default:\n\n        error_report(\"milkymist_sysctl: write access to unkown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n}\n", "idx": 25515, "_split": "test", "_hash": "dd0e958df82d77c0bfe3f786af468a83"}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)\n\n{\n\n    PXA2xxPICState *s;\n\n    int iomemtype;\n\n    qemu_irq *qi;\n\n\n\n    s = (PXA2xxPICState *)\n\n            qemu_mallocz(sizeof(PXA2xxPICState));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->cpu_env = env;\n\n\n\n    s->int_pending[0] = 0;\n\n    s->int_pending[1] = 0;\n\n    s->int_enabled[0] = 0;\n\n    s->int_enabled[1] = 0;\n\n    s->is_fiq[0] = 0;\n\n    s->is_fiq[1] = 0;\n\n\n\n    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);\n\n\n\n    /* Enable IC memory-mapped registers access.  */\n\n    iomemtype = cpu_register_io_memory(pxa2xx_pic_readfn,\n\n                    pxa2xx_pic_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(base, 0x00100000, iomemtype);\n\n\n\n    /* Enable IC coprocessor access.  */\n\n    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);\n\n\n\n    register_savevm(NULL, \"pxa2xx_pic\", 0, 0, pxa2xx_pic_save,\n\n                    pxa2xx_pic_load, s);\n\n\n\n    return qi;\n\n}\n", "idx": 25549, "_split": "test", "_hash": "050f72eb6a4e7ccf9c88923e8218429e"}
{"project": "qemu", "commit_id": "4a917c39aed9ad7f648c435204a6586c4ca3f2f2", "target": 0, "func": "int net_init_vde(QemuOpts *opts, const NetClientOptions *new_opts,\n\n                 const char *name, VLANState *vlan)\n\n{\n\n    const char *sock;\n\n    const char *group;\n\n    int port, mode;\n\n\n\n    sock  = qemu_opt_get(opts, \"sock\");\n\n    group = qemu_opt_get(opts, \"group\");\n\n\n\n    port = qemu_opt_get_number(opts, \"port\", 0);\n\n    mode = qemu_opt_get_number(opts, \"mode\", 0700);\n\n\n\n    if (net_vde_init(vlan, \"vde\", name, sock, port, group, mode) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25550, "_split": "test", "_hash": "7552cd9bb3b4a6453ad8e1b91309e36b"}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "static void qstring_destroy_obj(QObject *obj)\n\n{\n\n    QString *qs;\n\n\n\n    assert(obj != NULL);\n\n    qs = qobject_to_qstring(obj);\n\n    g_free(qs->string);\n\n    g_free(qs);\n\n}\n", "idx": 25571, "_split": "test", "_hash": "d59922871b83eb76b202238cd64b03b3"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "bool aio_pending(AioContext *ctx)\n\n{\n\n    AioHandler *node;\n\n    bool result = false;\n\n\n\n    /*\n\n     * We have to walk very carefully in case aio_set_fd_handler is\n\n     * called while we're walking.\n\n     */\n\n    qemu_lockcnt_inc(&ctx->list_lock);\n\n    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {\n\n        if (node->pfd.revents && node->io_notify) {\n\n            result = true;\n\n            break;\n\n        }\n\n\n\n        if ((node->pfd.revents & G_IO_IN) && node->io_read) {\n\n            result = true;\n\n            break;\n\n        }\n\n        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {\n\n            result = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    qemu_lockcnt_dec(&ctx->list_lock);\n\n    return result;\n\n}\n", "idx": 25574, "_split": "test", "_hash": "359000fe0357439d14edf051dd400bb4"}
{"project": "qemu", "commit_id": "e1f7b4812eab992de46c98b3726745afb042a7f0", "target": 0, "func": "static size_t get_request_size(VirtQueue *vq)\n\n{\n\n    unsigned int in, out;\n\n\n\n    virtqueue_get_avail_bytes(vq, &in, &out);\n\n    return in;\n\n}\n", "idx": 25578, "_split": "test", "_hash": "8210bd5f1e6f81d374554fe713449aea"}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_quit(int argc, const char **argv)\n\n{\n\n    exit(0);\n\n}\n", "idx": 25580, "_split": "test", "_hash": "541799ac17830f59985dc6210859dd59"}
{"project": "qemu", "commit_id": "63ffb564dca94f8bda01ed6d209784104630a4d2", "target": 0, "func": "static void pc_init1(ram_addr_t ram_size,\n\n                     const char *boot_device,\n\n                     const char *kernel_filename,\n\n                     const char *kernel_cmdline,\n\n                     const char *initrd_filename,\n\n                     const char *cpu_model,\n\n                     int pci_enabled,\n\n                     int kvmclock_enabled)\n\n{\n\n    int i;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size;\n\n    PCIBus *pci_bus;\n\n    PCII440FXState *i440fx_state;\n\n    int piix3_devfn = -1;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *isa_irq;\n\n    qemu_irq *i8259;\n\n    qemu_irq *cmos_s3;\n\n    qemu_irq *smi_irq;\n\n    IsaIrqState *isa_irq_state;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    FDCtrl *floppy_controller;\n\n    BusState *idebus[MAX_IDE_BUS];\n\n    ISADevice *rtc_state;\n\n\n\n    pc_cpus_init(cpu_model);\n\n\n\n    if (kvmclock_enabled) {\n\n        kvmclock_create();\n\n    }\n\n\n\n    /* allocate ram and load rom/bios */\n\n    pc_memory_init(ram_size, kernel_filename, kernel_cmdline, initrd_filename,\n\n                   &below_4g_mem_size, &above_4g_mem_size);\n\n\n\n    cpu_irq = pc_allocate_cpu_irq();\n\n    i8259 = i8259_init(cpu_irq[0]);\n\n    isa_irq_state = qemu_mallocz(sizeof(*isa_irq_state));\n\n    isa_irq_state->i8259 = i8259;\n\n    if (pci_enabled) {\n\n        ioapic_init(isa_irq_state);\n\n    }\n\n    isa_irq = qemu_allocate_irqs(isa_irq_handler, isa_irq_state, 24);\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, isa_irq, ram_size);\n\n    } else {\n\n        pci_bus = NULL;\n\n        i440fx_state = NULL;\n\n        isa_bus_new(NULL);\n\n    }\n\n    isa_bus_irqs(isa_irq);\n\n\n\n    pc_register_ferr_irq(isa_reserve_irq(13));\n\n\n\n    pc_vga_init(pci_enabled? pci_bus: NULL);\n\n\n\n    /* init basic PC hardware */\n\n    pc_basic_device_init(isa_irq, &floppy_controller, &rtc_state);\n\n\n\n    for(i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!pci_enabled || (nd->model && strcmp(nd->model, \"ne2k_isa\") == 0))\n\n            pc_init_ne2k_isa(nd);\n\n        else\n\n            pci_nic_init_nofail(nd, \"e1000\", NULL);\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        PCIDevice *dev;\n\n        dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        idebus[0] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\");\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            ISADevice *dev;\n\n            dev = isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i],\n\n                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n            idebus[i] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        }\n\n    }\n\n\n\n    audio_init(isa_irq, pci_enabled ? pci_bus : NULL);\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device,\n\n                 idebus[0], idebus[1], floppy_controller, rtc_state);\n\n\n\n    if (pci_enabled && usb_enabled) {\n\n        usb_uhci_piix3_init(pci_bus, piix3_devfn + 2);\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        uint8_t *eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */\n\n        i2c_bus *smbus;\n\n\n\n        cmos_s3 = qemu_allocate_irqs(pc_cmos_set_s3_resume, rtc_state, 1);\n\n        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              isa_reserve_irq(9), *cmos_s3, *smi_irq,\n\n                              kvm_enabled());\n\n        for (i = 0; i < 8; i++) {\n\n            DeviceState *eeprom;\n\n            eeprom = qdev_create((BusState *)smbus, \"smbus-eeprom\");\n\n            qdev_prop_set_uint8(eeprom, \"address\", 0x50 + i);\n\n            qdev_prop_set_ptr(eeprom, \"data\", eeprom_buf + (i * 256));\n\n            qdev_init_nofail(eeprom);\n\n        }\n\n    }\n\n\n\n    if (i440fx_state) {\n\n        i440fx_init_memory_mappings(i440fx_state);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n}\n", "idx": 25583, "_split": "test", "_hash": "1545cf7c6bbb88b68246816a8b1e3dd3"}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int usb_bt_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    struct USBBtState *s = (struct USBBtState *) dev->opaque;\n\n    int ret = 0;\n\n\n\n    if (!s->config)\n\n        goto fail;\n\n\n\n    switch (p->pid) {\n\n    case USB_TOKEN_IN:\n\n        switch (p->devep & 0xf) {\n\n        case USB_EVT_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->evt, p);\n\n            break;\n\n\n\n        case USB_ACL_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->acl, p);\n\n            break;\n\n\n\n        case USB_SCO_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->sco, p);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    case USB_TOKEN_OUT:\n\n        switch (p->devep & 0xf) {\n\n        case USB_ACL_EP:\n\n            usb_bt_fifo_out_enqueue(s, &s->outacl, s->hci->acl_send,\n\n                            usb_bt_hci_acl_complete, p->data, p->len);\n\n            break;\n\n\n\n        case USB_SCO_EP:\n\n            usb_bt_fifo_out_enqueue(s, &s->outsco, s->hci->sco_send,\n\n                            usb_bt_hci_sco_complete, p->data, p->len);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 25602, "_split": "test", "_hash": "35b108ab17073fc03f28328eaad15579"}
{"project": "qemu", "commit_id": "46c5874e9cd752ed8ded31af03472edd8fc3efc1", "target": 0, "func": "static void rtas_ibm_read_slot_reset_state2(PowerPCCPU *cpu,\n\n                                            sPAPREnvironment *spapr,\n\n                                            uint32_t token, uint32_t nargs,\n\n                                            target_ulong args, uint32_t nret,\n\n                                            target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    sPAPRPHBClass *spc;\n\n    uint64_t buid;\n\n    int state, ret;\n\n\n\n    if ((nargs != 3) || (nret != 4 && nret != 5)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);\n\n    sphb = find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);\n\n    if (!spc->eeh_get_state) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    ret = spc->eeh_get_state(sphb, &state);\n\n    rtas_st(rets, 0, ret);\n\n    if (ret != RTAS_OUT_SUCCESS) {\n\n        return;\n\n    }\n\n\n\n    rtas_st(rets, 1, state);\n\n    rtas_st(rets, 2, RTAS_EEH_SUPPORT);\n\n    rtas_st(rets, 3, RTAS_EEH_PE_UNAVAIL_INFO);\n\n    if (nret >= 5) {\n\n        rtas_st(rets, 4, RTAS_EEH_PE_RECOVER_INFO);\n\n    }\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 25619, "_split": "test", "_hash": "1a2938ecde35cad3560f9b9c702ad588"}
{"project": "qemu", "commit_id": "c91e681a558fc21073ffc491b5a022d5f340fa0b", "target": 0, "func": "void qmp_migrate_set_cache_size(int64_t value, Error **errp)\n\n{\n\n    MigrationState *s = migrate_get_current();\n\n\n\n    /* Check for truncation */\n\n    if (value != (size_t)value) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                  \"exceeding address space\");\n\n        return;\n\n    }\n\n\n\n    s->xbzrle_cache_size = xbzrle_cache_resize(value);\n\n}\n", "idx": 25636, "_split": "test", "_hash": "547080a9a3a5bc4f9e776ea6fa4abc5f"}
{"project": "qemu", "commit_id": "f53f4da9c68941fe70a3ca9e3fc792c8acf69c0c", "target": 1, "func": "int path_is_absolute(const char *path)\n\n{\n\n    const char *p;\n\n#ifdef _WIN32\n\n    /* specific case for names like: \"\\\\.\\d:\" */\n\n    if (*path == '/' || *path == '\\\\')\n\n        return 1;\n\n#endif\n\n    p = strchr(path, ':');\n\n    if (p)\n\n        p++;\n\n    else\n\n        p = path;\n\n#ifdef _WIN32\n\n    return (*p == '/' || *p == '\\\\');\n\n#else\n\n    return (*p == '/');\n\n#endif\n\n}\n", "idx": 25669, "_split": "test", "_hash": "1ef2dd1fc1f8032b81a090c7793ec422"}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "opts_end_struct(Visitor *v, Error **errp)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n    GHashTableIter iter;\n\n    GQueue *any;\n\n\n\n    if (--ov->depth > 0) {\n\n        return;\n\n    }\n\n\n\n    /* we should have processed all (distinct) QemuOpt instances */\n\n    g_hash_table_iter_init(&iter, ov->unprocessed_opts);\n\n    if (g_hash_table_iter_next(&iter, NULL, (void **)&any)) {\n\n        const QemuOpt *first;\n\n\n\n        first = g_queue_peek_head(any);\n\n        error_setg(errp, QERR_INVALID_PARAMETER, first->name);\n\n    }\n\n    g_hash_table_destroy(ov->unprocessed_opts);\n\n    ov->unprocessed_opts = NULL;\n\n    if (ov->fake_id_opt) {\n\n        g_free(ov->fake_id_opt->name);\n\n        g_free(ov->fake_id_opt->str);\n\n        g_free(ov->fake_id_opt);\n\n    }\n\n    ov->fake_id_opt = NULL;\n\n}\n", "idx": 25670, "_split": "test", "_hash": "f1d58dfcdf1675acddf288e874ce768a"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t apic_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    DeviceState *d;\n\n    APICCommonState *s;\n\n    uint32_t val;\n\n    int index;\n\n\n\n    d = cpu_get_current_apic();\n\n    if (!d) {\n\n        return 0;\n\n    }\n\n    s = DO_UPCAST(APICCommonState, busdev.qdev, d);\n\n\n\n    index = (addr >> 4) & 0xff;\n\n    switch(index) {\n\n    case 0x02: /* id */\n\n        val = s->id << 24;\n\n        break;\n\n    case 0x03: /* version */\n\n        val = 0x11 | ((APIC_LVT_NB - 1) << 16); /* version 0x11 */\n\n        break;\n\n    case 0x08:\n\n        apic_sync_vapic(s, SYNC_FROM_VAPIC);\n\n        if (apic_report_tpr_access) {\n\n            cpu_report_tpr_access(s->cpu_env, TPR_ACCESS_READ);\n\n        }\n\n        val = s->tpr;\n\n        break;\n\n    case 0x09:\n\n        val = apic_get_arb_pri(s);\n\n        break;\n\n    case 0x0a:\n\n        /* ppr */\n\n        val = apic_get_ppr(s);\n\n        break;\n\n    case 0x0b:\n\n        val = 0;\n\n        break;\n\n    case 0x0d:\n\n        val = s->log_dest << 24;\n\n        break;\n\n    case 0x0e:\n\n        val = s->dest_mode << 28;\n\n        break;\n\n    case 0x0f:\n\n        val = s->spurious_vec;\n\n        break;\n\n    case 0x10 ... 0x17:\n\n        val = s->isr[index & 7];\n\n        break;\n\n    case 0x18 ... 0x1f:\n\n        val = s->tmr[index & 7];\n\n        break;\n\n    case 0x20 ... 0x27:\n\n        val = s->irr[index & 7];\n\n        break;\n\n    case 0x28:\n\n        val = s->esr;\n\n        break;\n\n    case 0x30:\n\n    case 0x31:\n\n        val = s->icr[index & 1];\n\n        break;\n\n    case 0x32 ... 0x37:\n\n        val = s->lvt[index - 0x32];\n\n        break;\n\n    case 0x38:\n\n        val = s->initial_count;\n\n        break;\n\n    case 0x39:\n\n        val = apic_get_current_count(s);\n\n        break;\n\n    case 0x3e:\n\n        val = s->divide_conf;\n\n        break;\n\n    default:\n\n        s->esr |= ESR_ILLEGAL_ADDRESS;\n\n        val = 0;\n\n        break;\n\n    }\n\n    trace_apic_mem_readl(addr, val);\n\n    return val;\n\n}\n", "idx": 25704, "_split": "test", "_hash": "3b1601d844e9afa6c0b1a68ed3ba394c"}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static SocketAddressLegacy *tcp_build_address(const char *host_port, Error **errp)\n\n{\n\n    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);\n\n    SocketAddressLegacy *saddr;\n\n\n\n    if (inet_parse(iaddr, host_port, errp)) {\n\n        qapi_free_InetSocketAddress(iaddr);\n\n        return NULL;\n\n    }\n\n\n\n    saddr = g_new0(SocketAddressLegacy, 1);\n\n    saddr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;\n\n    saddr->u.inet.data = iaddr;\n\n\n\n    return saddr;\n\n}\n", "idx": 25711, "_split": "test", "_hash": "93c51157d5d3c838ec0686da486da58e"}
{"project": "qemu", "commit_id": "47c6d3ecdfc3fc354cf996f873a9f854c2325160", "target": 1, "func": "static const QObject *qmp_input_get_object(QmpInputVisitor *qiv,\n\n                                           const char *name)\n\n{\n\n    const QObject *qobj;\n\n\n\n    if (qiv->nb_stack == 0) {\n\n        qobj = qiv->obj;\n\n    } else {\n\n        qobj = qiv->stack[qiv->nb_stack - 1].obj;\n\n    }\n\n\n\n    if (name && qobject_type(qobj) == QTYPE_QDICT) {\n\n        return qdict_get(qobject_to_qdict(qobj), name);\n\n    } else if (qiv->nb_stack > 0 && qobject_type(qobj) == QTYPE_QLIST) {\n\n        return qlist_entry_obj(qiv->stack[qiv->nb_stack - 1].entry);\n\n    }\n\n\n\n    return qobj;\n\n}\n", "idx": 25734, "_split": "test", "_hash": "bc8b6c522c235b0d2bc040c7b3687d3e"}
{"project": "qemu", "commit_id": "0d4cc3e715f5794077895345577725539afe81eb", "target": 1, "func": "static int vpc_write(BlockDriverState *bs, int64_t sector_num,\n\n    const uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    int64_t offset;\n\n    int64_t sectors, sectors_per_block;\n\n    int ret;\n\n    VHDFooter *footer =  (VHDFooter *) s->footer_buf;\n\n\n\n    if (cpu_to_be32(footer->type) == VHD_FIXED) {\n\n        return bdrv_write(bs->file, sector_num, buf, nb_sectors);\n\n    }\n\n    while (nb_sectors > 0) {\n\n        offset = get_sector_offset(bs, sector_num, 1);\n\n\n\n        sectors_per_block = s->block_size >> BDRV_SECTOR_BITS;\n\n        sectors = sectors_per_block - (sector_num % sectors_per_block);\n\n        if (sectors > nb_sectors) {\n\n            sectors = nb_sectors;\n\n        }\n\n\n\n        if (offset == -1) {\n\n            offset = alloc_block(bs, sector_num);\n\n            if (offset < 0)\n\n                return -1;\n\n        }\n\n\n\n        ret = bdrv_pwrite(bs->file, offset, buf, sectors * BDRV_SECTOR_SIZE);\n\n        if (ret != sectors * BDRV_SECTOR_SIZE) {\n\n            return -1;\n\n        }\n\n\n\n        nb_sectors -= sectors;\n\n        sector_num += sectors;\n\n        buf += sectors * BDRV_SECTOR_SIZE;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25741, "_split": "test", "_hash": "457d2ba8cdd284aa4ed94b4f008de9c3"}
{"project": "qemu", "commit_id": "7264961934130df50d151def5eb415efa2e28ec5", "target": 0, "func": "exynos4_boards_init_common(MachineState *machine,\n\n                           Exynos4BoardType board_type)\n\n{\n\n    Exynos4BoardState *s = g_new(Exynos4BoardState, 1);\n\n    MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n\n\n    if (smp_cpus != EXYNOS4210_NCPUS && !qtest_enabled()) {\n\n        error_report(\"%s board supports only %d CPU cores, ignoring smp_cpus\"\n\n                     \" value\",\n\n                     mc->name, EXYNOS4210_NCPUS);\n\n    }\n\n\n\n    exynos4_board_binfo.ram_size = exynos4_board_ram_size[board_type];\n\n    exynos4_board_binfo.board_id = exynos4_board_id[board_type];\n\n    exynos4_board_binfo.smp_bootreg_addr =\n\n            exynos4_board_smp_bootreg_addr[board_type];\n\n    exynos4_board_binfo.kernel_filename = machine->kernel_filename;\n\n    exynos4_board_binfo.initrd_filename = machine->initrd_filename;\n\n    exynos4_board_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    exynos4_board_binfo.gic_cpu_if_addr =\n\n            EXYNOS4210_SMP_PRIVATE_BASE_ADDR + 0x100;\n\n\n\n    PRINT_DEBUG(\"\\n ram_size: %luMiB [0x%08lx]\\n\"\n\n            \" kernel_filename: %s\\n\"\n\n            \" kernel_cmdline: %s\\n\"\n\n            \" initrd_filename: %s\\n\",\n\n            exynos4_board_ram_size[board_type] / 1048576,\n\n            exynos4_board_ram_size[board_type],\n\n            machine->kernel_filename,\n\n            machine->kernel_cmdline,\n\n            machine->initrd_filename);\n\n\n\n    exynos4_boards_init_ram(s, get_system_memory(),\n\n                            exynos4_board_ram_size[board_type]);\n\n\n\n    s->soc = exynos4210_init(get_system_memory());\n\n\n\n    return s;\n\n}\n", "idx": 25753, "_split": "test", "_hash": "175c4c8becc4c821737c30f5d1865c29"}
{"project": "qemu", "commit_id": "2231f69b4e4523c43aa459cab18ab77c0e29b4d1", "target": 0, "func": "build_madt(GArray *table_data, BIOSLinker *linker, VirtGuestInfo *guest_info)\n\n{\n\n    int madt_start = table_data->len;\n\n    const MemMapEntry *memmap = guest_info->memmap;\n\n    const int *irqmap = guest_info->irqmap;\n\n    AcpiMultipleApicTable *madt;\n\n    AcpiMadtGenericDistributor *gicd;\n\n    AcpiMadtGenericMsiFrame *gic_msi;\n\n    int i;\n\n\n\n    madt = acpi_data_push(table_data, sizeof *madt);\n\n\n\n    gicd = acpi_data_push(table_data, sizeof *gicd);\n\n    gicd->type = ACPI_APIC_GENERIC_DISTRIBUTOR;\n\n    gicd->length = sizeof(*gicd);\n\n    gicd->base_address = memmap[VIRT_GIC_DIST].base;\n\n    gicd->version = guest_info->gic_version;\n\n\n\n    for (i = 0; i < guest_info->smp_cpus; i++) {\n\n        AcpiMadtGenericInterrupt *gicc = acpi_data_push(table_data,\n\n                                                     sizeof *gicc);\n\n        ARMCPU *armcpu = ARM_CPU(qemu_get_cpu(i));\n\n\n\n        gicc->type = ACPI_APIC_GENERIC_INTERRUPT;\n\n        gicc->length = sizeof(*gicc);\n\n        if (guest_info->gic_version == 2) {\n\n            gicc->base_address = memmap[VIRT_GIC_CPU].base;\n\n        }\n\n        gicc->cpu_interface_number = i;\n\n        gicc->arm_mpidr = armcpu->mp_affinity;\n\n        gicc->uid = i;\n\n        gicc->flags = cpu_to_le32(ACPI_GICC_ENABLED);\n\n\n\n        if (armcpu->has_pmu) {\n\n            gicc->performance_interrupt = cpu_to_le32(PPI(VIRTUAL_PMU_IRQ));\n\n        }\n\n    }\n\n\n\n    if (guest_info->gic_version == 3) {\n\n        AcpiMadtGenericTranslator *gic_its;\n\n        AcpiMadtGenericRedistributor *gicr = acpi_data_push(table_data,\n\n                                                         sizeof *gicr);\n\n\n\n        gicr->type = ACPI_APIC_GENERIC_REDISTRIBUTOR;\n\n        gicr->length = sizeof(*gicr);\n\n        gicr->base_address = cpu_to_le64(memmap[VIRT_GIC_REDIST].base);\n\n        gicr->range_length = cpu_to_le32(memmap[VIRT_GIC_REDIST].size);\n\n\n\n        if (its_class_name()) {\n\n            gic_its = acpi_data_push(table_data, sizeof *gic_its);\n\n            gic_its->type = ACPI_APIC_GENERIC_TRANSLATOR;\n\n            gic_its->length = sizeof(*gic_its);\n\n            gic_its->translation_id = 0;\n\n            gic_its->base_address = cpu_to_le64(memmap[VIRT_GIC_ITS].base);\n\n        }\n\n    } else {\n\n        gic_msi = acpi_data_push(table_data, sizeof *gic_msi);\n\n        gic_msi->type = ACPI_APIC_GENERIC_MSI_FRAME;\n\n        gic_msi->length = sizeof(*gic_msi);\n\n        gic_msi->gic_msi_frame_id = 0;\n\n        gic_msi->base_address = cpu_to_le64(memmap[VIRT_GIC_V2M].base);\n\n        gic_msi->flags = cpu_to_le32(1);\n\n        gic_msi->spi_count = cpu_to_le16(NUM_GICV2M_SPIS);\n\n        gic_msi->spi_base = cpu_to_le16(irqmap[VIRT_GIC_V2M] + ARM_SPI_BASE);\n\n    }\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)(table_data->data + madt_start), \"APIC\",\n\n                 table_data->len - madt_start, 3, NULL, NULL);\n\n}\n", "idx": 25810, "_split": "test", "_hash": "46717e0af5bc0e7eddba71e3e4538d7b"}
{"project": "qemu", "commit_id": "d6cf84e1de0a167963f0803d6e39f6ca03e27eaa", "target": 0, "func": "int slirp_can_output(void)\n\n{\n\n    return !slirp_vc || qemu_can_send_packet(slirp_vc);\n\n}\n", "idx": 25813, "_split": "test", "_hash": "e1c857cecaf9b5b2e12427a7e25d35c6"}
{"project": "qemu", "commit_id": "7f595609b49615b07c50b7182c4ef125c39cb5da", "target": 0, "func": "static void usb_tablet_class_initfn(ObjectClass *klass, void *data)\n\n{\n\n    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);\n\n\n\n    uc->init           = usb_tablet_initfn;\n\n    uc->product_desc   = \"QEMU USB Tablet\";\n\n    uc->usb_desc       = &desc_tablet;\n\n    uc->handle_packet  = usb_generic_handle_packet;\n\n    uc->handle_reset   = usb_hid_handle_reset;\n\n    uc->handle_control = usb_hid_handle_control;\n\n    uc->handle_data    = usb_hid_handle_data;\n\n    uc->handle_destroy = usb_hid_handle_destroy;\n\n}\n", "idx": 25814, "_split": "test", "_hash": "69ac2d12f11775add33067f310f85e2f"}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "static void ccw_machine_2_9_class_options(MachineClass *mc)\n\n{\n\n    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);\n\n\n\n    s390mc->gs_allowed = false;\n\n    ccw_machine_2_10_class_options(mc);\n\n    SET_MACHINE_COMPAT(mc, CCW_COMPAT_2_9);\n\n    s390mc->css_migration_enabled = false;\n\n}\n", "idx": 25831, "_split": "test", "_hash": "8f6764b89cbd4208c77e20108f6e2b49"}
{"project": "qemu", "commit_id": "248de4a89915001e64176580d620d22b612e06f2", "target": 1, "func": "static void test_dma_fragmented(void)\n\n{\n\n    AHCIQState *ahci;\n\n    AHCICommand *cmd;\n\n    uint8_t px;\n\n    size_t bufsize = 4096;\n\n    unsigned char *tx = g_malloc(bufsize);\n\n    unsigned char *rx = g_malloc0(bufsize);\n\n    uint64_t ptr;\n\n\n\n    ahci = ahci_boot_and_enable(NULL);\n\n    px = ahci_port_select(ahci);\n\n    ahci_port_clear(ahci, px);\n\n\n\n    /* create pattern */\n\n    generate_pattern(tx, bufsize, AHCI_SECTOR_SIZE);\n\n\n\n    /* Create a DMA buffer in guest memory, and write our pattern to it. */\n\n    ptr = guest_alloc(ahci->parent->alloc, bufsize);\n\n    g_assert(ptr);\n\n    bufwrite(ptr, tx, bufsize);\n\n\n\n    cmd = ahci_command_create(CMD_WRITE_DMA);\n\n    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);\n\n    ahci_command_commit(ahci, cmd, px);\n\n    ahci_command_issue(ahci, cmd);\n\n    ahci_command_verify(ahci, cmd);\n\n    g_free(cmd);\n\n\n\n    cmd = ahci_command_create(CMD_READ_DMA);\n\n    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);\n\n    ahci_command_commit(ahci, cmd, px);\n\n    ahci_command_issue(ahci, cmd);\n\n    ahci_command_verify(ahci, cmd);\n\n    g_free(cmd);\n\n\n\n    /* Read back the guest's receive buffer into local memory */\n\n    bufread(ptr, rx, bufsize);\n\n    guest_free(ahci->parent->alloc, ptr);\n\n\n\n    g_assert_cmphex(memcmp(tx, rx, bufsize), ==, 0);\n\n\n\n    ahci_shutdown(ahci);\n\n\n\n    g_free(rx);\n\n    g_free(tx);\n\n}\n", "idx": 25862, "_split": "test", "_hash": "b9a2da85b82fa49452f860f4aa9ece55"}
{"project": "qemu", "commit_id": "ba737541edddf9d0026460eb7b1d1c599b4c8ae9", "target": 1, "func": "static uint32_t pcihotplug_read(void *opaque, uint32_t addr)\n\n{\n\n    uint32_t val = 0;\n\n    struct pci_status *g = opaque;\n\n    switch (addr) {\n\n        case PCI_BASE:\n\n            val = g->up;\n\n            break;\n\n        case PCI_BASE + 4:\n\n            val = g->down;\n\n            break;\n\n        default:\n\n            break;\n\n    }\n\n\n\n    PIIX4_DPRINTF(\"pcihotplug read %x == %x\\n\", addr, val);\n\n    return val;\n\n}\n", "idx": 25865, "_split": "test", "_hash": "f08607c0438ac437ad8b97bcc172eda9"}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)\n\n{\n\n    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));\n\n\n\n    entry->rect.x = x;\n\n    entry->rect.y = y;\n\n    entry->rect.w = w;\n\n    entry->rect.h = h;\n\n\n\n    vnc_lock_queue(queue);\n\n    QLIST_INSERT_HEAD(&job->rectangles, entry, next);\n\n    vnc_unlock_queue(queue);\n\n    return 1;\n\n}\n", "idx": 25872, "_split": "test", "_hash": "79fa82d6478eb45e3355f9bc9aaf007b"}
{"project": "qemu", "commit_id": "54f254f973a1b2ed0f3571390f4de060adfe23e8", "target": 0, "func": "static void uhci_async_complete_packet(USBPacket * packet, void *opaque)\n\n{\n\n    UHCIState *s = opaque;\n\n    UHCI_QH qh;\n\n    UHCI_TD td;\n\n    uint32_t link;\n\n    uint32_t old_td_ctrl;\n\n    uint32_t val;\n\n    uint32_t frame_addr;\n\n    int ret;\n\n\n\n    /* Handle async isochronous packet completion */\n\n    frame_addr = s->async_frame_addr;\n\n    if (frame_addr) {\n\n        cpu_physical_memory_read(frame_addr, (uint8_t *)&link, 4);\n\n        le32_to_cpus(&link);\n\n\n\n        cpu_physical_memory_read(link & ~0xf, (uint8_t *)&td, sizeof(td));\n\n        le32_to_cpus(&td.link);\n\n        le32_to_cpus(&td.ctrl);\n\n        le32_to_cpus(&td.token);\n\n        le32_to_cpus(&td.buffer);\n\n        old_td_ctrl = td.ctrl;\n\n        ret = uhci_handle_td(s, &td, &s->pending_int_mask, 1);\n\n\n\n        /* update the status bits of the TD */\n\n        if (old_td_ctrl != td.ctrl) {\n\n            val = cpu_to_le32(td.ctrl);\n\n            cpu_physical_memory_write((link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n        }\n\n        if (ret == 2) {\n\n            s->async_frame_addr = frame_addr;\n\n        } else if (ret == 0) {\n\n            /* update qh element link */\n\n            val = cpu_to_le32(td.link);\n\n            cpu_physical_memory_write(frame_addr,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n        }\n\n        return;\n\n    }\n\n\n\n    link = s->async_qh;\n\n    if (!link) {\n\n        /* This should never happen. It means a TD somehow got removed\n\n           without cancelling the associated async IO request.  */\n\n        return;\n\n    }\n\n    cpu_physical_memory_read(link & ~0xf, (uint8_t *)&qh, sizeof(qh));\n\n    le32_to_cpus(&qh.link);\n\n    le32_to_cpus(&qh.el_link);\n\n    /* Re-process the queue containing the async packet.  */\n\n    while (1) {\n\n        cpu_physical_memory_read(qh.el_link & ~0xf,\n\n                                 (uint8_t *)&td, sizeof(td));\n\n        le32_to_cpus(&td.link);\n\n        le32_to_cpus(&td.ctrl);\n\n        le32_to_cpus(&td.token);\n\n        le32_to_cpus(&td.buffer);\n\n        old_td_ctrl = td.ctrl;\n\n        ret = uhci_handle_td(s, &td, &s->pending_int_mask, 1);\n\n\n\n        /* update the status bits of the TD */\n\n        if (old_td_ctrl != td.ctrl) {\n\n            val = cpu_to_le32(td.ctrl);\n\n            cpu_physical_memory_write((qh.el_link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n        }\n\n        if (ret < 0)\n\n            break; /* interrupted frame */\n\n        if (ret == 2) {\n\n            s->async_qh = link;\n\n            break;\n\n        } else if (ret == 0) {\n\n            /* update qh element link */\n\n            qh.el_link = td.link;\n\n            val = cpu_to_le32(qh.el_link);\n\n            cpu_physical_memory_write((link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n            if (!(qh.el_link & 4))\n\n                break;\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 25925, "_split": "test", "_hash": "935d74e8bbe681362018c49a4b4657ff"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void tracked_request_end(BdrvTrackedRequest *req)\n\n{\n\n    if (req->serialising) {\n\n        req->bs->serialising_in_flight--;\n\n    }\n\n\n\n    QLIST_REMOVE(req, list);\n\n    qemu_co_queue_restart_all(&req->wait_queue);\n\n}\n", "idx": 25932, "_split": "test", "_hash": "b416143152ec8e7f891d783500073a04"}
{"project": "qemu", "commit_id": "dc38852aaa4ac187d8b44201f75fc2835241912d", "target": 0, "func": "static int discard_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, qflag = 0;\n\n    int c, ret;\n\n    int64_t offset, count;\n\n\n\n    while ((c = getopt(argc, argv, \"Cq\")) != -1) {\n\n        switch (c) {\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        default:\n\n            return qemuio_command_usage(&discard_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind != argc - 2) {\n\n        return qemuio_command_usage(&discard_cmd);\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        print_cvtnum_err(offset, argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    optind++;\n\n    count = cvtnum(argv[optind]);\n\n    if (count < 0) {\n\n        print_cvtnum_err(count, argv[optind]);\n\n        return 0;\n\n    } else if (count >> BDRV_SECTOR_BITS > INT_MAX) {\n\n        printf(\"length cannot exceed %\"PRIu64\", given %s\\n\",\n\n               (uint64_t)INT_MAX << BDRV_SECTOR_BITS,\n\n               argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    gettimeofday(&t1, NULL);\n\n    ret = blk_discard(blk, offset >> BDRV_SECTOR_BITS,\n\n                      count >> BDRV_SECTOR_BITS);\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"discard failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    if (!qflag) {\n\n        t2 = tsub(t2, t1);\n\n        print_report(\"discard\", &t2, offset, count, count, 1, Cflag);\n\n    }\n\n\n\nout:\n\n    return 0;\n\n}\n", "idx": 25958, "_split": "test", "_hash": "1791c0064142b696d15a982e18486534"}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,\n\n                             hwaddr size)\n\n{\n\n    assert(mr->terminates);\n\n    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,\n\n                                        memory_region_get_dirty_log_mask(mr));\n\n}\n", "idx": 25997, "_split": "test", "_hash": "8869b51dcf62c2c313fe867edb5b0acd"}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static void vnc_display_print_local_addr(VncDisplay *vd)\n\n{\n\n    SocketAddressLegacy *addr;\n\n    Error *err = NULL;\n\n\n\n    if (!vd->nlsock) {\n\n        return;\n\n    }\n\n\n\n    addr = qio_channel_socket_get_local_address(vd->lsock[0], &err);\n\n    if (!addr) {\n\n        return;\n\n    }\n\n\n\n    if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {\n\n        qapi_free_SocketAddressLegacy(addr);\n\n        return;\n\n    }\n\n    error_printf_unless_qmp(\"VNC server running on %s:%s\\n\",\n\n                            addr->u.inet.data->host,\n\n                            addr->u.inet.data->port);\n\n    qapi_free_SocketAddressLegacy(addr);\n\n}\n", "idx": 26003, "_split": "test", "_hash": "cd4683e3f96cdc0403b25857ac4c4396"}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_lstat(FsContext *fs_ctx,\n\n                            V9fsPath *fs_path, struct stat *stbuf)\n\n{\n\n    V9fsSynthNode *node = *(V9fsSynthNode **)fs_path->data;\n\n\n\n    v9fs_synth_fill_statbuf(node, stbuf);\n\n    return 0;\n\n}\n", "idx": 26008, "_split": "test", "_hash": "40b12611815bbdaf122ccaea0e6b1b8a"}
{"project": "qemu", "commit_id": "2fb50a33401a2415b71ddc291e8a77bcd2f9e547", "target": 0, "func": "static void armv7m_nvic_clear_pending(void *opaque, int irq)\n\n{\n\n    NVICState *s = (NVICState *)opaque;\n\n    VecInfo *vec;\n\n\n\n    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);\n\n\n\n    vec = &s->vectors[irq];\n\n    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);\n\n    if (vec->pending) {\n\n        vec->pending = 0;\n\n        nvic_irq_update(s);\n\n    }\n\n}\n", "idx": 26059, "_split": "test", "_hash": "86071df958aec9efb2e0e9a836ced0e4"}
{"project": "qemu", "commit_id": "363e13f86eb60bce1e112a35a4c107505a69c9fe", "target": 0, "func": "static void vararg_string(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *decoded;\n\n    } test_cases[] = {\n\n        { \"hello world\" },\n\n        { \"the quick brown fox jumped over the fence\" },\n\n        {}\n\n    };\n\n\n\n    for (i = 0; test_cases[i].decoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_jsonf(\"%s\", test_cases[i].decoded);\n\n\n\n        g_assert(obj != NULL);\n\n        g_assert(qobject_type(obj) == QTYPE_QSTRING);\n\n        \n\n        str = qobject_to_qstring(obj);\n\n        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);\n\n\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 26061, "_split": "test", "_hash": "b695296e4fc0e7a55f0bd0e31de05849"}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static int scsi_qdev_exit(DeviceState *qdev)\n\n{\n\n    SCSIDevice *dev = SCSI_DEVICE(qdev);\n\n\n\n    if (dev->vmsentry) {\n\n        qemu_del_vm_change_state_handler(dev->vmsentry);\n\n    }\n\n    scsi_device_destroy(dev);\n\n    return 0;\n\n}\n", "idx": 26069, "_split": "test", "_hash": "e500d575064d4777fd8e27e113753b11"}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void slavio_misc_init(target_phys_addr_t base,\n\n                             target_phys_addr_t aux1_base,\n\n                             target_phys_addr_t aux2_base, qemu_irq irq,\n\n                             qemu_irq fdc_tc)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"slavio_misc\");\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    if (base) {\n\n        /* 8 bit registers */\n\n        /* Slavio control */\n\n        sysbus_mmio_map(s, 0, base + MISC_CFG);\n\n        /* Diagnostics */\n\n        sysbus_mmio_map(s, 1, base + MISC_DIAG);\n\n        /* Modem control */\n\n        sysbus_mmio_map(s, 2, base + MISC_MDM);\n\n        /* 16 bit registers */\n\n        /* ss600mp diag LEDs */\n\n        sysbus_mmio_map(s, 3, base + MISC_LEDS);\n\n        /* 32 bit registers */\n\n        /* System control */\n\n        sysbus_mmio_map(s, 4, base + MISC_SYS);\n\n    }\n\n    if (aux1_base) {\n\n        /* AUX 1 (Misc System Functions) */\n\n        sysbus_mmio_map(s, 5, aux1_base);\n\n    }\n\n    if (aux2_base) {\n\n        /* AUX 2 (Software Powerdown Control) */\n\n        sysbus_mmio_map(s, 6, aux2_base);\n\n    }\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_connect_irq(s, 1, fdc_tc);\n\n    qemu_system_powerdown = qdev_get_gpio_in(dev, 0);\n\n}\n", "idx": 26090, "_split": "test", "_hash": "7f98a2ecc204d5f5c1762667c386f7ae"}
{"project": "qemu", "commit_id": "871d2f079661323a7645b388eb5ae8d7eeb3117c", "target": 0, "func": "static void bdrv_put_buffer(void *opaque, const uint8_t *buf,\n\n                            int64_t pos, int size)\n\n{\n\n    QEMUFileBdrv *s = opaque;\n\n    bdrv_pwrite(s->bs, s->base_offset + pos, buf, size);\n\n}\n", "idx": 26113, "_split": "test", "_hash": "e85f353612dfc54d8e09f3effa49b9f4"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void qemu_clock_init(QEMUClockType type)\n\n{\n\n    QEMUClock *clock = qemu_clock_ptr(type);\n\n\n\n    /* Assert that the clock of type TYPE has not been initialized yet. */\n\n    assert(main_loop_tlg.tl[type] == NULL);\n\n\n\n    clock->type = type;\n\n    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);\n\n    clock->last = INT64_MIN;\n\n    QLIST_INIT(&clock->timerlists);\n\n    notifier_list_init(&clock->reset_notifiers);\n\n    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);\n\n}\n", "idx": 26117, "_split": "test", "_hash": "a19aed18f1b3547e2c688df20685986c"}
{"project": "qemu", "commit_id": "586502189edf9fd0f89a83de96717a2ea826fdb0", "target": 1, "func": "static CharDriverState *qemu_chr_open_pty(QemuOpts *opts)\n\n{\n\n    CharDriverState *chr;\n\n    PtyCharDriver *s;\n\n    struct termios tty;\n\n    int master_fd, slave_fd, len;\n\n#if defined(__OpenBSD__) || defined(__DragonFly__)\n\n    char pty_name[PATH_MAX];\n\n#define q_ptsname(x) pty_name\n\n#else\n\n    char *pty_name = NULL;\n\n#define q_ptsname(x) ptsname(x)\n\n#endif\n\n\n\n    if (openpty(&master_fd, &slave_fd, pty_name, NULL, NULL) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    /* Set raw attributes on the pty. */\n\n    tcgetattr(slave_fd, &tty);\n\n    cfmakeraw(&tty);\n\n    tcsetattr(slave_fd, TCSAFLUSH, &tty);\n\n    close(slave_fd);\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n\n\n    len = strlen(q_ptsname(master_fd)) + 5;\n\n    chr->filename = g_malloc(len);\n\n    snprintf(chr->filename, len, \"pty:%s\", q_ptsname(master_fd));\n\n    qemu_opt_set(opts, \"path\", q_ptsname(master_fd));\n\n    fprintf(stderr, \"char device redirected to %s\\n\", q_ptsname(master_fd));\n\n\n\n    s = g_malloc0(sizeof(PtyCharDriver));\n\n    chr->opaque = s;\n\n    chr->chr_write = pty_chr_write;\n\n    chr->chr_update_read_handler = pty_chr_update_read_handler;\n\n    chr->chr_close = pty_chr_close;\n\n\n\n    s->fd = master_fd;\n\n    s->timer = qemu_new_timer_ms(rt_clock, pty_chr_timer, chr);\n\n\n\n    return chr;\n\n}\n", "idx": 26136, "_split": "test", "_hash": "5a5c98d5c372aa06fea92de87ed821cd"}
{"project": "qemu", "commit_id": "601b9a9008c5a612d76073bb3f178621cff41980", "target": 0, "func": "uint32_t HELPER(sigp)(CPUS390XState *env, uint64_t order_code, uint32_t r1,\n\n                      uint64_t cpu_addr)\n\n{\n\n    int cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n\n\n    HELPER_LOG(\"%s: %016\" PRIx64 \" %08x %016\" PRIx64 \"\\n\",\n\n               __func__, order_code, r1, cpu_addr);\n\n\n\n    /* Remember: Use \"R1 or R1 + 1, whichever is the odd-numbered register\"\n\n       as parameter (input). Status (output) is always R1. */\n\n\n\n    switch (order_code) {\n\n    case SIGP_SET_ARCH:\n\n        /* switch arch */\n\n        break;\n\n    case SIGP_SENSE:\n\n        /* enumerate CPU status */\n\n        if (cpu_addr) {\n\n            /* XXX implement when SMP comes */\n\n            return 3;\n\n        }\n\n        env->regs[r1] &= 0xffffffff00000000ULL;\n\n        cc = 1;\n\n        break;\n\n#if !defined(CONFIG_USER_ONLY)\n\n    case SIGP_RESTART:\n\n        qemu_system_reset_request();\n\n        cpu_loop_exit(CPU(s390_env_get_cpu(env)));\n\n        break;\n\n    case SIGP_STOP:\n\n        qemu_system_shutdown_request();\n\n        cpu_loop_exit(CPU(s390_env_get_cpu(env)));\n\n        break;\n\n#endif\n\n    default:\n\n        /* unknown sigp */\n\n        fprintf(stderr, \"XXX unknown sigp: 0x%\" PRIx64 \"\\n\", order_code);\n\n        cc = SIGP_CC_NOT_OPERATIONAL;\n\n    }\n\n\n\n    return cc;\n\n}\n", "idx": 26152, "_split": "test", "_hash": "8617407a755716006f5a34f925e34b96"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline int onenand_prog_main(OneNANDState *s, int sec, int secn,\n\n                void *src)\n\n{\n\n    int result = 0;\n\n\n\n    if (secn > 0) {\n\n        uint32_t size = (uint32_t)secn * 512;\n\n        const uint8_t *sp = (const uint8_t *)src;\n\n        uint8_t *dp = 0;\n\n        if (s->bdrv_cur) {\n\n            dp = g_malloc(size);\n\n            if (!dp || bdrv_read(s->bdrv_cur, sec, dp, secn) < 0) {\n\n                result = 1;\n\n            }\n\n        } else {\n\n            if (sec + secn > s->secs_cur) {\n\n                result = 1;\n\n            } else {\n\n                dp = (uint8_t *)s->current + (sec << 9);\n\n            }\n\n        }\n\n        if (!result) {\n\n            uint32_t i;\n\n            for (i = 0; i < size; i++) {\n\n                dp[i] &= sp[i];\n\n            }\n\n            if (s->bdrv_cur) {\n\n                result = bdrv_write(s->bdrv_cur, sec, dp, secn) < 0;\n\n            }\n\n        }\n\n        if (dp && s->bdrv_cur) {\n\n            g_free(dp);\n\n        }\n\n    }\n\n\n\n    return result;\n\n}\n", "idx": 26158, "_split": "test", "_hash": "2657d41eedbfafa08e973be599b1adef"}
{"project": "qemu", "commit_id": "943cec86d0864464ab29b42940c49d1ccbe8d268", "target": 0, "func": "static int nbd_receive_list(QIOChannel *ioc, char **name, Error **errp)\n\n{\n\n    uint64_t magic;\n\n    uint32_t opt;\n\n    uint32_t type;\n\n    uint32_t len;\n\n    uint32_t namelen;\n\n    int error;\n\n\n\n    *name = NULL;\n\n    if (read_sync(ioc, &magic, sizeof(magic)) != sizeof(magic)) {\n\n        error_setg(errp, \"failed to read list option magic\");\n\n        return -1;\n\n    }\n\n    magic = be64_to_cpu(magic);\n\n    if (magic != NBD_REP_MAGIC) {\n\n        error_setg(errp, \"Unexpected option list magic\");\n\n        return -1;\n\n    }\n\n    if (read_sync(ioc, &opt, sizeof(opt)) != sizeof(opt)) {\n\n        error_setg(errp, \"failed to read list option\");\n\n        return -1;\n\n    }\n\n    opt = be32_to_cpu(opt);\n\n    if (opt != NBD_OPT_LIST) {\n\n        error_setg(errp, \"Unexpected option type %\" PRIx32 \" expected %x\",\n\n                   opt, NBD_OPT_LIST);\n\n        return -1;\n\n    }\n\n\n\n    if (read_sync(ioc, &type, sizeof(type)) != sizeof(type)) {\n\n        error_setg(errp, \"failed to read list option type\");\n\n        return -1;\n\n    }\n\n    type = be32_to_cpu(type);\n\n    error = nbd_handle_reply_err(ioc, opt, type, errp);\n\n    if (error <= 0) {\n\n        return error;\n\n    }\n\n\n\n    if (read_sync(ioc, &len, sizeof(len)) != sizeof(len)) {\n\n        error_setg(errp, \"failed to read option length\");\n\n        return -1;\n\n    }\n\n    len = be32_to_cpu(len);\n\n\n\n    if (type == NBD_REP_ACK) {\n\n        if (len != 0) {\n\n            error_setg(errp, \"length too long for option end\");\n\n            return -1;\n\n        }\n\n    } else if (type == NBD_REP_SERVER) {\n\n        if (len < sizeof(namelen) || len > NBD_MAX_BUFFER_SIZE) {\n\n            error_setg(errp, \"incorrect option length\");\n\n            return -1;\n\n        }\n\n        if (read_sync(ioc, &namelen, sizeof(namelen)) != sizeof(namelen)) {\n\n            error_setg(errp, \"failed to read option name length\");\n\n            return -1;\n\n        }\n\n        namelen = be32_to_cpu(namelen);\n\n        len -= sizeof(namelen);\n\n        if (len < namelen) {\n\n            error_setg(errp, \"incorrect option name length\");\n\n            return -1;\n\n        }\n\n        if (namelen > 255) {\n\n            error_setg(errp, \"export name length too long %\" PRIu32, namelen);\n\n            return -1;\n\n        }\n\n\n\n        *name = g_new0(char, namelen + 1);\n\n        if (read_sync(ioc, *name, namelen) != namelen) {\n\n            error_setg(errp, \"failed to read export name\");\n\n            g_free(*name);\n\n            *name = NULL;\n\n            return -1;\n\n        }\n\n        (*name)[namelen] = '\\0';\n\n        len -= namelen;\n\n        if (len) {\n\n            char *buf = g_malloc(len + 1);\n\n            if (read_sync(ioc, buf, len) != len) {\n\n                error_setg(errp, \"failed to read export description\");\n\n                g_free(*name);\n\n                g_free(buf);\n\n                *name = NULL;\n\n                return -1;\n\n            }\n\n            buf[len] = '\\0';\n\n            TRACE(\"Ignoring export description: %s\", buf);\n\n            g_free(buf);\n\n        }\n\n    } else {\n\n        error_setg(errp, \"Unexpected reply type %\" PRIx32 \" expected %x\",\n\n                   type, NBD_REP_SERVER);\n\n        return -1;\n\n    }\n\n    return 1;\n\n}\n", "idx": 26160, "_split": "test", "_hash": "735645bedaebedeb0ddd6b03849e48c6"}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n    char *msg1, *msg2;\n\n\n\n    if (errp == NULL) {\n\n        return;\n\n    }\n\n\n\n    va_start(ap, fmt);\n\n    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);\n\n    va_end(ap);\n\n\n\n    if (win32_err != 0) {\n\n        msg1 = (*errp)->msg;\n\n        msg2 = g_win32_error_message(win32_err);\n\n        (*errp)->msg = g_strdup_printf(\"%s: %s (error: %x)\", msg1, msg2,\n\n                                       (unsigned)win32_err);\n\n        g_free(msg2);\n\n        g_free(msg1);\n\n    }\n\n}\n", "idx": 26175, "_split": "test", "_hash": "54aac3c592410f9c8787f693e290d067"}
{"project": "qemu", "commit_id": "b9ce1454e14ec918acb90d899ce7724f69682f45", "target": 0, "func": "int qemu_get_buffer(QEMUFile *f, uint8_t *buf, int size1)\n\n{\n\n    int size, l;\n\n\n\n    if (f->is_write)\n\n        abort();\n\n\n\n    size = size1;\n\n    while (size > 0) {\n\n        l = f->buf_size - f->buf_index;\n\n        if (l == 0) {\n\n            qemu_fill_buffer(f);\n\n            l = f->buf_size - f->buf_index;\n\n            if (l == 0)\n\n                break;\n\n        }\n\n        if (l > size)\n\n            l = size;\n\n        memcpy(buf, f->buf + f->buf_index, l);\n\n        f->buf_index += l;\n\n        buf += l;\n\n        size -= l;\n\n    }\n\n    return size1 - size;\n\n}\n", "idx": 26191, "_split": "test", "_hash": "f2ab97141cf2641b7569ef843a6ccec2"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void *rom_ptr(target_phys_addr_t addr)\n\n{\n\n    Rom *rom;\n\n\n\n    rom = find_rom(addr);\n\n    if (!rom || !rom->data)\n\n        return NULL;\n\n    return rom->data + (addr - rom->addr);\n\n}\n", "idx": 26225, "_split": "test", "_hash": "8e49715737e35924bf2f2233e29266f9"}
{"project": "qemu", "commit_id": "90e56fb46d0a7add88ed463efa4e723a6238f692", "target": 0, "func": "static void *do_data_decompress(void *opaque)\n\n{\n\n    DecompressParam *param = opaque;\n\n    unsigned long pagesize;\n\n\n\n    while (!quit_decomp_thread) {\n\n        qemu_mutex_lock(&param->mutex);\n\n        while (!param->start && !quit_decomp_thread) {\n\n            qemu_cond_wait(&param->cond, &param->mutex);\n\n        }\n\n        if (!quit_decomp_thread) {\n\n            pagesize = TARGET_PAGE_SIZE;\n\n            /* uncompress() will return failed in some case, especially\n\n             * when the page is dirted when doing the compression, it's\n\n             * not a problem because the dirty page will be retransferred\n\n             * and uncompress() won't break the data in other pages.\n\n             */\n\n            uncompress((Bytef *)param->des, &pagesize,\n\n                       (const Bytef *)param->compbuf, param->len);\n\n        }\n\n        param->start = false;\n\n        qemu_mutex_unlock(&param->mutex);\n\n\n\n        qemu_mutex_lock(&decomp_done_lock);\n\n        param->done = true;\n\n        qemu_cond_signal(&decomp_done_cond);\n\n        qemu_mutex_unlock(&decomp_done_lock);\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 26226, "_split": "test", "_hash": "5f03eabb999eade89c76edc3f4f18ad9"}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "long do_sigreturn(CPUSH4State *regs)\n\n{\n\n    struct target_sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    sigset_t blocked;\n\n    target_sigset_t target_set;\n\n    target_ulong r0;\n\n    int i;\n\n    int err = 0;\n\n\n\n#if defined(DEBUG_SIGNAL)\n\n    fprintf(stderr, \"do_sigreturn\\n\");\n\n#endif\n\n    frame_addr = regs->gregs[15];\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n   \tgoto badframe;\n\n\n\n    __get_user(target_set.sig[0], &frame->sc.oldmask);\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        __get_user(target_set.sig[i], &frame->extramask[i - 1]);\n\n    }\n\n\n\n    if (err)\n\n        goto badframe;\n\n\n\n    target_to_host_sigset_internal(&blocked, &target_set);\n\n    do_sigprocmask(SIG_SETMASK, &blocked, NULL);\n\n\n\n    if (restore_sigcontext(regs, &frame->sc, &r0))\n\n        goto badframe;\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return r0;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 26234, "_split": "test", "_hash": "28e4a1b2c74b65e4617abcde13195932"}
{"project": "qemu", "commit_id": "b8eb5512fd8a115f164edbbe897cdf8884920ccb", "target": 0, "func": "static void apic_reset_common(DeviceState *dev)\n\n{\n\n    APICCommonState *s = APIC_COMMON(dev);\n\n    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);\n\n    bool bsp;\n\n\n\n    bsp = cpu_is_bsp(s->cpu);\n\n    s->apicbase = APIC_DEFAULT_ADDRESS |\n\n        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;\n\n\n\n    s->vapic_paddr = 0;\n\n    info->vapic_base_update(s);\n\n\n\n    apic_init_reset(dev);\n\n\n\n    if (bsp) {\n\n        /*\n\n         * LINT0 delivery mode on CPU #0 is set to ExtInt at initialization\n\n         * time typically by BIOS, so PIC interrupt can be delivered to the\n\n         * processor when local APIC is enabled.\n\n         */\n\n        s->lvt[APIC_LVT_LINT0] = 0x700;\n\n    }\n\n}\n", "idx": 26242, "_split": "test", "_hash": "74739af8d0902f0882f97f22f3057b43"}
{"project": "qemu", "commit_id": "b854bc196f5c4b4e3299c0b0ee63cf828ece9e77", "target": 0, "func": "static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,\n\n                omap_clk clk)\n\n{\n\n    int iomemtype;\n\n\n\n    s->pwt.base = base;\n\n    s->pwt.clk = clk;\n\n    omap_pwt_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,\n\n                    omap_pwt_writefn, s);\n\n    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);\n\n}\n", "idx": 26243, "_split": "test", "_hash": "fe8556b2a02d36ad2e41ce9757e161a9"}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "int vnc_hextile_send_framebuffer_update(VncState *vs, int x,\n\n                                        int y, int w, int h)\n\n{\n\n    int i, j;\n\n    int has_fg, has_bg;\n\n    uint8_t *last_fg, *last_bg;\n\n    VncDisplay *vd = vs->vd;\n\n\n\n    last_fg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);\n\n    last_bg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);\n\n    has_fg = has_bg = 0;\n\n    for (j = y; j < (y + h); j += 16) {\n\n        for (i = x; i < (x + w); i += 16) {\n\n            vs->send_hextile_tile(vs, i, j,\n\n                                  MIN(16, x + w - i), MIN(16, y + h - j),\n\n                                  last_bg, last_fg, &has_bg, &has_fg);\n\n        }\n\n    }\n\n    free(last_fg);\n\n    free(last_bg);\n\n\n\n    return 1;\n\n}\n", "idx": 26245, "_split": "test", "_hash": "ad7caa352d3cbc0a77775194a9f27d3e"}
{"project": "qemu", "commit_id": "f8c35c1d59c9fecf79f6d5a02cd09f472a6f411d", "target": 0, "func": "static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,\n\n                        uint8_t *buf, int nb_sectors)\n\n{\n\n    int async_ret;\n\n    BlockDriverAIOCB *acb;\n\n    struct iovec iov;\n\n    QEMUIOVector qiov;\n\n\n\n    async_ret = NOT_DONE;\n\n    iov.iov_base = (void *)buf;\n\n    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,\n\n                                  bdrv_rw_em_cb, &async_ret);\n\n    if (acb == NULL) {\n\n        async_ret = -1;\n\n        goto fail;\n\n    }\n\n\n\n    while (async_ret == NOT_DONE) {\n\n        qemu_aio_wait();\n\n    }\n\n\n\n\n\nfail:\n\n    return async_ret;\n\n}\n", "idx": 26251, "_split": "test", "_hash": "2cf84b2bbe1f04e4a1918df57593c2cd"}
{"project": "qemu", "commit_id": "e57ca75ce3b2bd33102573a8c0555d62e1bcfceb", "target": 0, "func": "static int kvmppc_get_books_sregs(PowerPCCPU *cpu)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    struct kvm_sregs sregs;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_SREGS, &sregs);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (!env->external_htab) {\n\n        ppc_store_sdr1(env, sregs.u.s.sdr1);\n\n    }\n\n\n\n    /* Sync SLB */\n\n#ifdef TARGET_PPC64\n\n    /*\n\n     * The packed SLB array we get from KVM_GET_SREGS only contains\n\n     * information about valid entries. So we flush our internal copy\n\n     * to get rid of stale ones, then put all valid SLB entries back\n\n     * in.\n\n     */\n\n    memset(env->slb, 0, sizeof(env->slb));\n\n    for (i = 0; i < ARRAY_SIZE(env->slb); i++) {\n\n        target_ulong rb = sregs.u.s.ppc64.slb[i].slbe;\n\n        target_ulong rs = sregs.u.s.ppc64.slb[i].slbv;\n\n        /*\n\n         * Only restore valid entries\n\n         */\n\n        if (rb & SLB_ESID_V) {\n\n            ppc_store_slb(cpu, rb & 0xfff, rb & ~0xfffULL, rs);\n\n        }\n\n    }\n\n#endif\n\n\n\n    /* Sync SRs */\n\n    for (i = 0; i < 16; i++) {\n\n        env->sr[i] = sregs.u.s.ppc32.sr[i];\n\n    }\n\n\n\n    /* Sync BATs */\n\n    for (i = 0; i < 8; i++) {\n\n        env->DBAT[0][i] = sregs.u.s.ppc32.dbat[i] & 0xffffffff;\n\n        env->DBAT[1][i] = sregs.u.s.ppc32.dbat[i] >> 32;\n\n        env->IBAT[0][i] = sregs.u.s.ppc32.ibat[i] & 0xffffffff;\n\n        env->IBAT[1][i] = sregs.u.s.ppc32.ibat[i] >> 32;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26257, "_split": "test", "_hash": "e9c8f7fe9e8d606a8a3dae02e4eeba30"}
{"project": "qemu", "commit_id": "0ae18ceeaaa2c1749e742c4b112f6c3bf0896408", "target": 0, "func": "static void integratorcp_init(ram_addr_t ram_size, int vga_ram_size,\n\n                     const char *boot_device, DisplayState *ds,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    uint32_t ram_offset;\n\n    qemu_irq *pic;\n\n    qemu_irq *cpu_pic;\n\n    int sd;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"arm926\";\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    ram_offset = qemu_ram_alloc(ram_size);\n\n    /* ??? On a real system the first 1Mb is mapped as SSRAM or boot flash.  */\n\n    /* ??? RAM should repeat to fill physical memory space.  */\n\n    /* SDRAM at address zero*/\n\n    cpu_register_physical_memory(0, ram_size, ram_offset | IO_MEM_RAM);\n\n    /* And again at address 0x80000000 */\n\n    cpu_register_physical_memory(0x80000000, ram_size, ram_offset | IO_MEM_RAM);\n\n\n\n    integratorcm_init(ram_size >> 20);\n\n    cpu_pic = arm_pic_init_cpu(env);\n\n    pic = icp_pic_init(0x14000000, cpu_pic[ARM_PIC_CPU_IRQ],\n\n                       cpu_pic[ARM_PIC_CPU_FIQ]);\n\n    icp_pic_init(0xca000000, pic[26], NULL);\n\n    icp_pit_init(0x13000000, pic, 5);\n\n    pl031_init(0x15000000, pic[8]);\n\n    pl011_init(0x16000000, pic[1], serial_hds[0], PL011_ARM);\n\n    pl011_init(0x17000000, pic[2], serial_hds[1], PL011_ARM);\n\n    icp_control_init(0xcb000000);\n\n    pl050_init(0x18000000, pic[3], 0);\n\n    pl050_init(0x19000000, pic[4], 1);\n\n    sd = drive_get_index(IF_SD, 0, 0);\n\n    if (sd == -1) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital card\\n\");\n\n        exit(1);\n\n    }\n\n    pl181_init(0x1c000000, drives_table[sd].bdrv, pic[23], pic[24]);\n\n    if (nd_table[0].vlan) {\n\n        if (nd_table[0].model == NULL\n\n            || strcmp(nd_table[0].model, \"smc91c111\") == 0) {\n\n            smc91c111_init(&nd_table[0], 0xc8000000, pic[27]);\n\n        } else if (strcmp(nd_table[0].model, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported NICs: smc91c111\\n\");\n\n            exit (1);\n\n        } else {\n\n            fprintf(stderr, \"qemu: Unsupported NIC: %s\\n\", nd_table[0].model);\n\n            exit (1);\n\n        }\n\n    }\n\n    pl110_init(ds, 0xc0000000, pic[22], 0);\n\n\n\n    integrator_binfo.ram_size = ram_size;\n\n    integrator_binfo.kernel_filename = kernel_filename;\n\n    integrator_binfo.kernel_cmdline = kernel_cmdline;\n\n    integrator_binfo.initrd_filename = initrd_filename;\n\n    arm_load_kernel(env, &integrator_binfo);\n\n}\n", "idx": 26259, "_split": "test", "_hash": "f7cecf3faa3cb01e2e13f75a5436d85b"}
{"project": "qemu", "commit_id": "788cf9f8c8cbda53843e060540f3e91a060eb744", "target": 1, "func": "void hmp_cont(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockInfoList *bdev_list, *bdev;\n\n    Error *err = NULL;\n\n\n\n    bdev_list = qmp_query_block(NULL);\n\n    for (bdev = bdev_list; bdev; bdev = bdev->next) {\n\n        if (key_is_missing(bdev->value)) {\n\n            monitor_read_block_device_key(mon, bdev->value->device,\n\n                                          hmp_cont_cb, NULL);\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    qmp_cont(&err);\n\n    hmp_handle_error(mon, &err);\n\n\n\nout:\n\n    qapi_free_BlockInfoList(bdev_list);\n\n}\n", "idx": 26291, "_split": "test", "_hash": "28b425ae86e621d2dbf80be19a4ecf26"}
{"project": "qemu", "commit_id": "e0dadc1e9ef1f35208e5d2af9c7740c18a0b769f", "target": 1, "func": "static void aux_bridge_init(Object *obj)\n\n{\n\n    AUXTOI2CState *s = AUXTOI2C(obj);\n\n\n\n    s->i2c_bus = i2c_init_bus(DEVICE(obj), \"aux-i2c\");\n\n}\n", "idx": 26306, "_split": "test", "_hash": "8ab918ca80e43f20f64afbbb14f579b4"}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void bdrv_co_drain_bh_cb(void *opaque)\n\n{\n\n    BdrvCoDrainData *data = opaque;\n\n    Coroutine *co = data->co;\n\n\n\n    qemu_bh_delete(data->bh);\n\n    bdrv_drain_poll(data->bs);\n\n    data->done = true;\n\n    qemu_coroutine_enter(co, NULL);\n\n}\n", "idx": 26315, "_split": "test", "_hash": "52ee7dba97f9480dcab83f93745619f2"}
{"project": "qemu", "commit_id": "b224e5e2162a767dd56dbc366f796fbe45ca5baa", "target": 1, "func": "static int add_graphics_client(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    const char *protocol  = qdict_get_str(qdict, \"protocol\");\n\n    const char *fdname = qdict_get_str(qdict, \"fdname\");\n\n    CharDriverState *s;\n\n\n\n    if (strcmp(protocol, \"spice\") == 0) {\n\n        int fd = monitor_get_fd(mon, fdname, NULL);\n\n        int skipauth = qdict_get_try_bool(qdict, \"skipauth\", 0);\n\n        int tls = qdict_get_try_bool(qdict, \"tls\", 0);\n\n        if (!using_spice) {\n\n            /* correct one? spice isn't a device ,,, */\n\n            qerror_report(QERR_DEVICE_NOT_ACTIVE, \"spice\");\n\n            return -1;\n\n        }\n\n        if (qemu_spice_display_add_client(fd, skipauth, tls) < 0) {\n\n            close(fd);\n\n        }\n\n        return 0;\n\n#ifdef CONFIG_VNC\n\n    } else if (strcmp(protocol, \"vnc\") == 0) {\n\n\tint fd = monitor_get_fd(mon, fdname, NULL);\n\n        int skipauth = qdict_get_try_bool(qdict, \"skipauth\", 0);\n\n\tvnc_display_add_client(NULL, fd, skipauth);\n\n\treturn 0;\n\n#endif\n\n    } else if ((s = qemu_chr_find(protocol)) != NULL) {\n\n\tint fd = monitor_get_fd(mon, fdname, NULL);\n\n\tif (qemu_chr_add_client(s, fd) < 0) {\n\n\t    qerror_report(QERR_ADD_CLIENT_FAILED);\n\n\t    return -1;\n\n\t}\n\n\treturn 0;\n\n    }\n\n\n\n    qerror_report(QERR_INVALID_PARAMETER, \"protocol\");\n\n    return -1;\n\n}\n", "idx": 26320, "_split": "test", "_hash": "4b672194a00dc0fb8412c60b06d4cbbc"}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "static gboolean qio_channel_tls_handshake_io(QIOChannel *ioc,\n\n                                             GIOCondition condition,\n\n                                             gpointer user_data)\n\n{\n\n    QIOTask *task = user_data;\n\n    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(\n\n        qio_task_get_source(task));\n\n\n\n    qio_channel_tls_handshake_task(\n\n       tioc, task);\n\n\n\n    object_unref(OBJECT(tioc));\n\n\n\n    return FALSE;\n\n}\n", "idx": 26330, "_split": "test", "_hash": "e41bcad318e334c7b67d7ace18007187"}
{"project": "qemu", "commit_id": "2886be1b01c274570fa139748a402207482405bd", "target": 1, "func": "static void pm_update_sci(VT686PMState *s)\n\n{\n\n    int sci_level, pmsts;\n\n\n\n    pmsts = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);\n\n    sci_level = (((pmsts & s->ar.pm1.evt.en) &\n\n                  (ACPI_BITMASK_RT_CLOCK_ENABLE |\n\n                   ACPI_BITMASK_POWER_BUTTON_ENABLE |\n\n                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |\n\n                   ACPI_BITMASK_TIMER_ENABLE)) != 0);\n\n    qemu_set_irq(s->dev.irq[0], sci_level);\n\n    /* schedule a timer interruption if needed */\n\n    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&\n\n                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));\n\n}\n", "idx": 26333, "_split": "test", "_hash": "96738504bef98305ebb71004bd5d94c4"}
{"project": "qemu", "commit_id": "ba2ab2f2ca4150a7e314fbb19fa158bd8ddc36eb", "target": 1, "func": "static int qcow2_create2(const char *filename, int64_t total_size,\n                         const char *backing_file, const char *backing_format,\n                         int flags, size_t cluster_size, int prealloc,\n                         QEMUOptionParameter *options, int version,\n                         Error **errp)\n{\n    /* Calculate cluster_bits */\n    int cluster_bits;\n    cluster_bits = ffs(cluster_size) - 1;\n    if (cluster_bits < MIN_CLUSTER_BITS || cluster_bits > MAX_CLUSTER_BITS ||\n        (1 << cluster_bits) != cluster_size)\n    {\n        error_setg(errp, \"Cluster size must be a power of two between %d and \"\n                   \"%dk\", 1 << MIN_CLUSTER_BITS, 1 << (MAX_CLUSTER_BITS - 10));\n        return -EINVAL;\n    /*\n     * Open the image file and write a minimal qcow2 header.\n     *\n     * We keep things simple and start with a zero-sized image. We also\n     * do without refcount blocks or a L1 table for now. We'll fix the\n     * inconsistency later.\n     *\n     * We do need a refcount table because growing the refcount table means\n     * allocating two new refcount blocks - the seconds of which would be at\n     * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file\n     * size for any qcow2 image.\n     */\n    BlockDriverState* bs;\n    QCowHeader header;\n    uint8_t* refcount_table;\n    Error *local_err = NULL;\n    int ret;\n    ret = bdrv_create_file(filename, options, &local_err);\n    if (ret < 0) {\n        return ret;\n    ret = bdrv_file_open(&bs, filename, NULL, BDRV_O_RDWR, &local_err);\n    if (ret < 0) {\n        return ret;\n    /* Write the header */\n    memset(&header, 0, sizeof(header));\n    header.magic = cpu_to_be32(QCOW_MAGIC);\n    header.version = cpu_to_be32(version);\n    header.cluster_bits = cpu_to_be32(cluster_bits);\n    header.size = cpu_to_be64(0);\n    header.l1_table_offset = cpu_to_be64(0);\n    header.l1_size = cpu_to_be32(0);\n    header.refcount_table_offset = cpu_to_be64(cluster_size);\n    header.refcount_table_clusters = cpu_to_be32(1);\n    header.refcount_order = cpu_to_be32(3 + REFCOUNT_SHIFT);\n    header.header_length = cpu_to_be32(sizeof(header));\n    if (flags & BLOCK_FLAG_ENCRYPT) {\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_AES);\n    } else {\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);\n    if (flags & BLOCK_FLAG_LAZY_REFCOUNTS) {\n        header.compatible_features |=\n            cpu_to_be64(QCOW2_COMPAT_LAZY_REFCOUNTS);\n    ret = bdrv_pwrite(bs, 0, &header, sizeof(header));\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not write qcow2 header\");\n    /* Write an empty refcount table */\n    refcount_table = g_malloc0(cluster_size);\n    ret = bdrv_pwrite(bs, cluster_size, refcount_table, cluster_size);\n    g_free(refcount_table);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not write refcount table\");\n    /*\n     * And now open the image and make it consistent first (i.e. increase the\n     * refcount of the cluster that is occupied by the header and the refcount\n     * table)\n     */\n    BlockDriver* drv = bdrv_find_format(\"qcow2\");\n    assert(drv != NULL);\n        BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH, drv, &local_err);\n    if (ret < 0) {\n    ret = qcow2_alloc_clusters(bs, 2 * cluster_size);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not allocate clusters for qcow2 \"\n                         \"header and refcount table\");\n    } else if (ret != 0) {\n        error_report(\"Huh, first cluster in empty image is already in use?\");\n        abort();\n    /* Okay, now that we have a valid image, let's give it the right size */\n    ret = bdrv_truncate(bs, total_size * BDRV_SECTOR_SIZE);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not resize image\");\n    /* Want a backing file? There you go.*/\n    if (backing_file) {\n        ret = bdrv_change_backing_file(bs, backing_file, backing_format);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not assign backing file '%s' \"\n                             \"with format '%s'\", backing_file, backing_format);\n    /* And if we're supposed to preallocate metadata, do that now */\n    if (prealloc) {\n        BDRVQcowState *s = bs->opaque;\n        qemu_co_mutex_lock(&s->lock);\n        ret = preallocate(bs);\n        qemu_co_mutex_unlock(&s->lock);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not preallocate metadata\");\n    ret = 0;\nout:\n    bdrv_unref(bs);\n    return ret;", "idx": 26388, "_split": "test", "_hash": "b39e6175f91b090fb3ec316ab519f427"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    intel_hda_reg_write(d, reg, val, 0xffffffff);\n\n}\n", "idx": 26396, "_split": "test", "_hash": "40d1882cf41d18c3c4136d4180ce1f1b"}
{"project": "qemu", "commit_id": "167351020420c285b67cdf0603501b3d3b15e3f7", "target": 1, "func": "static int jazz_led_init(SysBusDevice *dev)\n\n{\n\n    LedState *s = FROM_SYSBUS(LedState, dev);\n\n\n\n    memory_region_init_io(&s->iomem, &led_ops, s, \"led\", 1);\n\n    sysbus_init_mmio(dev, &s->iomem);\n\n\n\n    s->ds = graphic_console_init(jazz_led_update_display,\n\n                                 jazz_led_invalidate_display,\n\n                                 jazz_led_screen_dump,\n\n                                 jazz_led_text_update, s);\n\n\n\n    return 0;\n\n}\n", "idx": 26443, "_split": "test", "_hash": "b553d0d12903deee4165d884aa8846e3"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "dma_read(void *opaque, target_phys_addr_t addr, unsigned int size)\n\n{\n\n        struct fs_dma_ctrl *ctrl = opaque;\n\n\tint c;\n\n\tuint32_t r = 0;\n\n\n\n\tif (size != 4) {\n\n\t\tdma_rinvalid(opaque, addr);\n\n\t}\n\n\n\n\t/* Make addr relative to this channel and bounded to nr regs.  */\n\n\tc = fs_channel(addr);\n\n\taddr &= 0xff;\n\n\taddr >>= 2;\n\n\tswitch (addr)\n\n\t{\n\n\t\tcase RW_STAT:\n\n\t\t\tr = ctrl->channels[c].state & 7;\n\n\t\t\tr |= ctrl->channels[c].eol << 5;\n\n\t\t\tr |= ctrl->channels[c].stream_cmd_src << 8;\n\n\t\t\tbreak;\n\n\n\n\t\tdefault:\n\n\t\t\tr = ctrl->channels[c].regs[addr];\n\n\t\t\tD(printf (\"%s c=%d addr=\" TARGET_FMT_plx \"\\n\",\n\n\t\t\t\t  __func__, c, addr));\n\n\t\t\tbreak;\n\n\t}\n\n\treturn r;\n\n}\n", "idx": 26451, "_split": "test", "_hash": "cb26eb871ed1e239d9570bd7f94f66e7"}
{"project": "qemu", "commit_id": "b0457b69209fca3fb40a85bd54d7f27eb4bad7e7", "target": 0, "func": "static void pxa2xx_descriptor_load(struct pxa2xx_lcdc_s *s)\n\n{\n\n    struct pxa_frame_descriptor_s desc;\n\n    target_phys_addr_t descptr;\n\n    int i;\n\n\n\n    for (i = 0; i < PXA_LCDDMA_CHANS; i ++) {\n\n        s->dma_ch[i].source = 0;\n\n\n\n        if (!s->dma_ch[i].up)\n\n            continue;\n\n\n\n        if (s->dma_ch[i].branch & FBR_BRA) {\n\n            descptr = s->dma_ch[i].branch & FBR_SRCADDR;\n\n            if (s->dma_ch[i].branch & FBR_BINT)\n\n                pxa2xx_dma_bs_set(s, i);\n\n            s->dma_ch[i].branch &= ~FBR_BRA;\n\n        } else\n\n            descptr = s->dma_ch[i].descriptor;\n\n\n\n        if (!(descptr >= PXA2XX_SDRAM_BASE && descptr +\n\n                    sizeof(desc) <= PXA2XX_SDRAM_BASE + phys_ram_size))\n\n            continue;\n\n\n\n        cpu_physical_memory_read(descptr, (void *)&desc, sizeof(desc));\n\n        s->dma_ch[i].descriptor = tswap32(desc.fdaddr);\n\n        s->dma_ch[i].source = tswap32(desc.fsaddr);\n\n        s->dma_ch[i].id = tswap32(desc.fidr);\n\n        s->dma_ch[i].command = tswap32(desc.ldcmd);\n\n    }\n\n}\n", "idx": 26458, "_split": "test", "_hash": "8fa9f9bb7bc7c1fd0c04316ea7b9c8c9"}
{"project": "qemu", "commit_id": "5f1d1fc5928a6f8f63089b3d0768e0dc42c05fbb", "target": 0, "func": "int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)\n\n{\n\n    DeviceState *qdev, **qdevs;\n\n    BusChild *kid;\n\n    int i, num, ret = 0;\n\n\n\n    /* Count qdevs on the bus list */\n\n    num = 0;\n\n    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {\n\n        num++;\n\n    }\n\n\n\n    /* Copy out into an array of pointers */\n\n    qdevs = g_malloc(sizeof(qdev) * num);\n\n    num = 0;\n\n    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {\n\n        qdevs[num++] = kid->child;\n\n    }\n\n\n\n    /* Sort the array */\n\n    qsort(qdevs, num, sizeof(qdev), compare_reg);\n\n\n\n    /* Hack alert. Give the devices to libfdt in reverse order, we happen\n\n     * to know that will mean they are in forward order in the tree. */\n\n    for (i = num - 1; i >= 0; i--) {\n\n        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);\n\n\n\n        ret = vio_make_devnode(dev, fdt);\n\n\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    free(qdevs);\n\n\n\n    return ret;\n\n}\n", "idx": 26468, "_split": "test", "_hash": "e96e7442f38704943b43f297990da78b"}
{"project": "qemu", "commit_id": "4656e1f01289cc3aa20986deb6a407165826abe5", "target": 1, "func": "void ppc_tlb_invalidate_all(CPUPPCState *env)\n\n{\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n        ppc6xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        ppc4xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_REAL:\n\n        cpu_abort(env, \"No TLB for PowerPC 4xx in real mode\\n\");\n\n        break;\n\n    case POWERPC_MMU_MPC8xx:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE:\n\n        tlb_flush(env, 1);\n\n        break;\n\n    case POWERPC_MMU_BOOKE206:\n\n        booke206_flush_tlb(env, -1, 0);\n\n        break;\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_601:\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_620:\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_2_06:\n\n\n#endif /* defined(TARGET_PPC64) */\n\n        tlb_flush(env, 1);\n\n        break;\n\n    default:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Unknown MMU model\\n\");\n\n        break;\n\n    }\n\n}", "idx": 26472, "_split": "test", "_hash": "b81c88370d6a343c35b5d33e2385ff40"}
{"project": "qemu", "commit_id": "5d7fd045cafeac1831c1999cb9e1251b7906c6b2", "target": 0, "func": "uint32_t HELPER(lcebr)(CPUS390XState *env, uint32_t f1, uint32_t f2)\n\n{\n\n    env->fregs[f1].l.upper = float32_chs(env->fregs[f2].l.upper);\n\n\n\n    return set_cc_nz_f32(env->fregs[f1].l.upper);\n\n}\n", "idx": 26480, "_split": "test", "_hash": "0df0c7fd471f3d80a7d25ab866fee097"}
{"project": "qemu", "commit_id": "1dbd2fd9cbf29c74131e439ce80fb2efde56ee32", "target": 0, "func": "static int qemu_rdma_dest_init(RDMAContext *rdma, Error **errp)\n\n{\n\n    int ret = -EINVAL, idx;\n\n    struct rdma_cm_id *listen_id;\n\n    char ip[40] = \"unknown\";\n\n    struct rdma_addrinfo *res;\n\n    char port_str[16];\n\n\n\n    for (idx = 0; idx < RDMA_WRID_MAX; idx++) {\n\n        rdma->wr_data[idx].control_len = 0;\n\n        rdma->wr_data[idx].control_curr = NULL;\n\n    }\n\n\n\n    if (rdma->host == NULL) {\n\n        ERROR(errp, \"RDMA host is not set!\");\n\n        rdma->error_state = -EINVAL;\n\n        return -1;\n\n    }\n\n    /* create CM channel */\n\n    rdma->channel = rdma_create_event_channel();\n\n    if (!rdma->channel) {\n\n        ERROR(errp, \"could not create rdma event channel\");\n\n        rdma->error_state = -EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    /* create CM id */\n\n    ret = rdma_create_id(rdma->channel, &listen_id, NULL, RDMA_PS_TCP);\n\n    if (ret) {\n\n        ERROR(errp, \"could not create cm_id!\");\n\n        goto err_dest_init_create_listen_id;\n\n    }\n\n\n\n    snprintf(port_str, 16, \"%d\", rdma->port);\n\n    port_str[15] = '\\0';\n\n\n\n    if (rdma->host && strcmp(\"\", rdma->host)) {\n\n        struct rdma_addrinfo *e;\n\n\n\n        ret = rdma_getaddrinfo(rdma->host, port_str, NULL, &res);\n\n        if (ret < 0) {\n\n            ERROR(errp, \"could not rdma_getaddrinfo address %s\", rdma->host);\n\n            goto err_dest_init_bind_addr;\n\n        }\n\n\n\n        for (e = res; e != NULL; e = e->ai_next) {\n\n            inet_ntop(e->ai_family,\n\n                &((struct sockaddr_in *) e->ai_dst_addr)->sin_addr, ip, sizeof ip);\n\n            trace_qemu_rdma_dest_init_trying(rdma->host, ip);\n\n            ret = rdma_bind_addr(listen_id, e->ai_dst_addr);\n\n            if (!ret) {\n\n                if (e->ai_family == AF_INET6) {\n\n                    ret = qemu_rdma_broken_ipv6_kernel(errp, listen_id->verbs);\n\n                    if (ret) {\n\n                        continue;\n\n                    }\n\n                }\n\n                    \n\n                goto listen;\n\n            }\n\n        }\n\n\n\n        ERROR(errp, \"Error: could not rdma_bind_addr!\");\n\n        goto err_dest_init_bind_addr;\n\n    } else {\n\n        ERROR(errp, \"migration host and port not specified!\");\n\n        ret = -EINVAL;\n\n        goto err_dest_init_bind_addr;\n\n    }\n\nlisten:\n\n\n\n    rdma->listen_id = listen_id;\n\n    qemu_rdma_dump_gid(\"dest_init\", listen_id);\n\n    return 0;\n\n\n\nerr_dest_init_bind_addr:\n\n    rdma_destroy_id(listen_id);\n\nerr_dest_init_create_listen_id:\n\n    rdma_destroy_event_channel(rdma->channel);\n\n    rdma->channel = NULL;\n\n    rdma->error_state = ret;\n\n    return ret;\n\n\n\n}\n", "idx": 26485, "_split": "test", "_hash": "fc83879db397771ba08c59615fcd01e2"}
{"project": "qemu", "commit_id": "2d26512b45b5236fa521c4492608fe9fb5bedf46", "target": 0, "func": "int cksum(struct mbuf *m, int len)\n\n{\n\n\tregister uint16_t *w;\n\n\tregister int sum = 0;\n\n\tregister int mlen = 0;\n\n\tint byte_swapped = 0;\n\n\n\n\tunion {\n\n\t\tuint8_t  c[2];\n\n\t\tuint16_t s;\n\n\t} s_util;\n\n\tunion {\n\n\t\tuint16_t s[2];\n\n\t\tuint32_t l;\n\n\t} l_util;\n\n\n\n\tif (m->m_len == 0)\n\n\t   goto cont;\n\n\tw = mtod(m, uint16_t *);\n\n\n\n\tmlen = m->m_len;\n\n\n\n\tif (len < mlen)\n\n\t   mlen = len;\n\n#ifdef DEBUG\n\n\tlen -= mlen;\n\n#endif\n\n\t/*\n\n\t * Force to even boundary.\n\n\t */\n\n\tif ((1 & (long) w) && (mlen > 0)) {\n\n\t\tREDUCE;\n\n\t\tsum <<= 8;\n\n\t\ts_util.c[0] = *(uint8_t *)w;\n\n\t\tw = (uint16_t *)((int8_t *)w + 1);\n\n\t\tmlen--;\n\n\t\tbyte_swapped = 1;\n\n\t}\n\n\t/*\n\n\t * Unroll the loop to make overhead from\n\n\t * branches &c small.\n\n\t */\n\n\twhile ((mlen -= 32) >= 0) {\n\n\t\tsum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];\n\n\t\tsum += w[4]; sum += w[5]; sum += w[6]; sum += w[7];\n\n\t\tsum += w[8]; sum += w[9]; sum += w[10]; sum += w[11];\n\n\t\tsum += w[12]; sum += w[13]; sum += w[14]; sum += w[15];\n\n\t\tw += 16;\n\n\t}\n\n\tmlen += 32;\n\n\twhile ((mlen -= 8) >= 0) {\n\n\t\tsum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];\n\n\t\tw += 4;\n\n\t}\n\n\tmlen += 8;\n\n\tif (mlen == 0 && byte_swapped == 0)\n\n\t   goto cont;\n\n\tREDUCE;\n\n\twhile ((mlen -= 2) >= 0) {\n\n\t\tsum += *w++;\n\n\t}\n\n\n\n\tif (byte_swapped) {\n\n\t\tREDUCE;\n\n\t\tsum <<= 8;\n\n\t\tif (mlen == -1) {\n\n\t\t\ts_util.c[1] = *(uint8_t *)w;\n\n\t\t\tsum += s_util.s;\n\n\t\t\tmlen = 0;\n\n\t\t} else\n\n\n\n\t\t   mlen = -1;\n\n\t} else if (mlen == -1)\n\n\t   s_util.c[0] = *(uint8_t *)w;\n\n\n\ncont:\n\n#ifdef DEBUG\n\n\tif (len) {\n\n\t\tDEBUG_ERROR((dfd, \"cksum: out of data\\n\"));\n\n\t\tDEBUG_ERROR((dfd, \" len = %d\\n\", len));\n\n\t}\n\n#endif\n\n\tif (mlen == -1) {\n\n\t\t/* The last mbuf has odd # of bytes. Follow the\n\n\t\t standard (the odd byte may be shifted left by 8 bits\n\n\t\t\t   or not as determined by endian-ness of the machine) */\n\n\t\ts_util.c[1] = 0;\n\n\t\tsum += s_util.s;\n\n\t}\n\n\tREDUCE;\n\n\treturn (~sum & 0xffff);\n\n}\n", "idx": 26489, "_split": "test", "_hash": "36f794cf0108828223054268b7ab10f6"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,\n\n                         int is_write, target_phys_addr_t access_len)\n\n{\n\n    if (buffer != bounce.buffer) {\n\n        if (is_write) {\n\n            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);\n\n            while (access_len) {\n\n                unsigned l;\n\n                l = TARGET_PAGE_SIZE;\n\n                if (l > access_len)\n\n                    l = access_len;\n\n                invalidate_and_set_dirty(addr1, l);\n\n                addr1 += l;\n\n                access_len -= l;\n\n            }\n\n        }\n\n        if (xen_enabled()) {\n\n            xen_invalidate_map_cache_entry(buffer);\n\n        }\n\n        return;\n\n    }\n\n    if (is_write) {\n\n        address_space_write(as, bounce.addr, bounce.buffer, access_len);\n\n    }\n\n    qemu_vfree(bounce.buffer);\n\n    bounce.buffer = NULL;\n\n    cpu_notify_map_clients();\n\n}\n", "idx": 26496, "_split": "test", "_hash": "2434a2e0c1f2866ecd1397b7e107192f"}
{"project": "qemu", "commit_id": "b14ef7c9ab41ea824c3ccadb070ad95567cca84e", "target": 1, "func": "static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n#ifdef DEBUG_UNASSIGNED\n\n    printf(\"Unassigned mem read \" TARGET_FMT_plx \"\\n\", addr);\n\n#endif\n\n#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)\n\n    do_unassigned_access(addr, 0, 0, 0, 4);\n\n#endif\n\n    return 0;\n\n}\n", "idx": 26530, "_split": "test", "_hash": "ed1286172fe72723a38e630af959dd50"}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b)\n\n{\n\n    TCGv_i64 tmp64 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_extu_i32_i64(tmp64, b);\n\n    dead_tmp(b);\n\n    tcg_gen_shli_i64(tmp64, tmp64, 32);\n\n    tcg_gen_add_i64(a, tmp64, a);\n\n\n\n    tcg_temp_free_i64(tmp64);\n\n    return a;\n\n}\n", "idx": 26531, "_split": "test", "_hash": "99b4ca86c26613a4655de17e958f2be7"}
{"project": "qemu", "commit_id": "a980f7f2c2f4d7e9a1eba4f804cd66dbd458b6d4", "target": 0, "func": "static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < vs->num_queues + 2; i++) {\n\n        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);\n\n    }\n\n    pc_alloc_uninit(vs->alloc);\n\n    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));\n\n    g_free(vs->dev);\n\n    qpci_free_pc(vs->bus);\n\n    g_free(vs);\n\n}\n", "idx": 26535, "_split": "test", "_hash": "ac5346b1847e88bc36690388d3bbda30"}
{"project": "qemu", "commit_id": "d492a75cfefd9a09125ba2b007c817c1417c3820", "target": 0, "func": "void spapr_clear_pending_events(sPAPRMachineState *spapr)\n\n{\n\n    sPAPREventLogEntry *entry = NULL;\n\n\n\n    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {\n\n        QTAILQ_REMOVE(&spapr->pending_events, entry, next);\n\n        g_free(entry->extended_log);\n\n        g_free(entry);\n\n    }\n\n}\n", "idx": 26538, "_split": "test", "_hash": "27d8a0425e06e87d2698eafde3a354fa"}
{"project": "qemu", "commit_id": "abd696e4f74a9d30801c6ae2693efe4e5979c2f2", "target": 0, "func": "static void sclp_set_write_mask(void)\n\n{\n\n    WriteEventMask *sccb = (void*)_sccb;\n\n\n\n    sccb->h.length = sizeof(WriteEventMask);\n\n    sccb->mask_length = sizeof(unsigned int);\n\n    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n\n\n    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);\n\n}\n", "idx": 26540, "_split": "test", "_hash": "2c3e64ce69ae8beb0482f769c7bc2bb1"}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "void json_prop_int(QJSON *json, const char *name, int64_t val)\n\n{\n\n    json_emit_element(json, name);\n\n    qstring_append_int(json->str, val);\n\n}\n", "idx": 26543, "_split": "test", "_hash": "7784fa5eb014551f708178684ce2d8b0"}
{"project": "qemu", "commit_id": "e4f308bbf9f360ee2af5b94b87aef170d8f20dc4", "target": 0, "func": "static void pm_update_sci(PIIX4PMState *s)\n\n{\n\n    int sci_level, pmsts;\n\n\n\n    pmsts = acpi_pm1_evt_get_sts(&s->ar);\n\n    sci_level = (((pmsts & s->ar.pm1.evt.en) &\n\n                  (ACPI_BITMASK_RT_CLOCK_ENABLE |\n\n                   ACPI_BITMASK_POWER_BUTTON_ENABLE |\n\n                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |\n\n                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||\n\n        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &\n\n          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);\n\n\n\n    qemu_set_irq(s->irq, sci_level);\n\n    /* schedule a timer interruption if needed */\n\n    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&\n\n                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));\n\n}\n", "idx": 26552, "_split": "test", "_hash": "fd8ada68a2d66ec7fee3c41acf2d045b"}
{"project": "qemu", "commit_id": "b248ede2ef2792d364bd305e5e92e24921c924a8", "target": 1, "func": "if_start(Slirp *slirp)\n\n{\n\n    uint64_t now = qemu_get_clock_ns(rt_clock);\n\n    int requeued = 0;\n\n\tstruct mbuf *ifm, *ifqt;\n\n\n\n\tDEBUG_CALL(\"if_start\");\n\n\n\n\tif (slirp->if_queued == 0)\n\n\t   return; /* Nothing to do */\n\n\n\n again:\n\n        /* check if we can really output */\n\n        if (!slirp_can_output(slirp->opaque))\n\n            return;\n\n\n\n\t/*\n\n\t * See which queue to get next packet from\n\n\t * If there's something in the fastq, select it immediately\n\n\t */\n\n\tif (slirp->if_fastq.ifq_next != &slirp->if_fastq) {\n\n\t\tifm = slirp->if_fastq.ifq_next;\n\n\t} else {\n\n\t\t/* Nothing on fastq, see if next_m is valid */\n\n\t\tif (slirp->next_m != &slirp->if_batchq)\n\n\t\t   ifm = slirp->next_m;\n\n\t\telse\n\n\t\t   ifm = slirp->if_batchq.ifq_next;\n\n\n\n\t\t/* Set which packet to send on next iteration */\n\n\t\tslirp->next_m = ifm->ifq_next;\n\n\t}\n\n\t/* Remove it from the queue */\n\n\tifqt = ifm->ifq_prev;\n\n\tremque(ifm);\n\n\tslirp->if_queued--;\n\n\n\n\t/* If there are more packets for this session, re-queue them */\n\n\tif (ifm->ifs_next != /* ifm->ifs_prev != */ ifm) {\n\n\t\tinsque(ifm->ifs_next, ifqt);\n\n\t\tifs_remque(ifm);\n\n\t}\n\n\n\n\t/* Update so_queued */\n\n\tif (ifm->ifq_so) {\n\n\t\tif (--ifm->ifq_so->so_queued == 0)\n\n\t\t   /* If there's no more queued, reset nqueued */\n\n\t\t   ifm->ifq_so->so_nqueued = 0;\n\n\t}\n\n\n\n        if (ifm->expiration_date < now) {\n\n            /* Expired */\n\n            m_free(ifm);\n\n        } else {\n\n            /* Encapsulate the packet for sending */\n\n            if (if_encap(slirp, ifm)) {\n\n                m_free(ifm);\n\n            } else {\n\n                /* re-queue */\n\n                insque(ifm, ifqt);\n\n                requeued++;\n\n            }\n\n        }\n\n\n\n\tif (slirp->if_queued)\n\n\t   goto again;\n\n\n\n        slirp->if_queued = requeued;\n\n}\n", "idx": 26587, "_split": "test", "_hash": "f59d0fe7e55a0c79de4ef940b029b74c"}
{"project": "qemu", "commit_id": "c9fc50839863f05545caca92bb9fbead8b1c91bd", "target": 0, "func": "static void dump_human_image_check(ImageCheck *check)\n\n{\n\n    if (!(check->corruptions || check->leaks || check->check_errors)) {\n\n        printf(\"No errors were found on the image.\\n\");\n\n    } else {\n\n        if (check->corruptions) {\n\n            printf(\"\\n%\" PRId64 \" errors were found on the image.\\n\"\n\n                \"Data may be corrupted, or further writes to the image \"\n\n                \"may corrupt it.\\n\",\n\n                check->corruptions);\n\n        }\n\n\n\n        if (check->leaks) {\n\n            printf(\"\\n%\" PRId64 \" leaked clusters were found on the image.\\n\"\n\n                \"This means waste of disk space, but no harm to data.\\n\",\n\n                check->leaks);\n\n        }\n\n\n\n        if (check->check_errors) {\n\n            printf(\"\\n%\" PRId64 \" internal errors have occurred during the check.\\n\",\n\n                check->check_errors);\n\n        }\n\n    }\n\n\n\n    if (check->total_clusters != 0 && check->allocated_clusters != 0) {\n\n        printf(\"%\" PRId64 \"/%\" PRId64 \"= %0.2f%% allocated, %0.2f%% fragmented\\n\",\n\n        check->allocated_clusters, check->total_clusters,\n\n        check->allocated_clusters * 100.0 / check->total_clusters,\n\n        check->fragmented_clusters * 100.0 / check->allocated_clusters);\n\n    }\n\n\n\n    if (check->image_end_offset) {\n\n        printf(\"Image end offset: %\" PRId64 \"\\n\", check->image_end_offset);\n\n    }\n\n}\n", "idx": 26595, "_split": "test", "_hash": "7fb8289cb2d4864fd17697fd38002229"}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "float32 int32_to_float32( int32 a STATUS_PARAM )\n\n{\n\n    flag zSign;\n\n\n\n    if ( a == 0 ) return 0;\n\n    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );\n\n    zSign = ( a < 0 );\n\n    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );\n\n\n\n}\n", "idx": 26599, "_split": "test", "_hash": "d169a6b6904c48f61984e6d6315cd530"}
{"project": "qemu", "commit_id": "58892b447f0ffcd0967bc6f1bcb40df288ebeebc", "target": 1, "func": "static int vfio_start_eventfd_injection(VFIOINTp *intp)\n\n{\n\n    int ret;\n\n\n\n    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: Failed to pass IRQ fd to the driver: %m\");\n\n    }\n\n    return ret;\n\n}\n", "idx": 26620, "_split": "test", "_hash": "d149facc76262954c44a6c5b43bb5c1f"}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int bt_hid_in(struct bt_hid_device_s *s)\n\n{\n\n    USBPacket p;\n\n\n\n    p.pid = USB_TOKEN_IN;\n\n    p.devep = 1;\n\n    p.data = s->datain.buffer;\n\n    p.len = sizeof(s->datain.buffer);\n\n    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);\n\n\n\n    return s->datain.len;\n\n}\n", "idx": 26642, "_split": "test", "_hash": "785b21277905784df63d5dcc50197199"}
{"project": "qemu", "commit_id": "1453e6627d19a8d6d54480c6980f5cef5dfc6833", "target": 0, "func": "void qmp_inject_nmi(Error **errp)\n\n{\n\n#if defined(TARGET_I386)\n\n    CPUState *cs;\n\n\n\n    CPU_FOREACH(cs) {\n\n        X86CPU *cpu = X86_CPU(cs);\n\n\n\n        if (!cpu->apic_state) {\n\n            cpu_interrupt(cs, CPU_INTERRUPT_NMI);\n\n        } else {\n\n            apic_deliver_nmi(cpu->apic_state);\n\n        }\n\n    }\n\n#else\n\n    nmi_monitor_handle(monitor_get_cpu_index(), errp);\n\n#endif\n\n}\n", "idx": 26653, "_split": "test", "_hash": "4d011eabe3dc0849b7f314086346c526"}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,\n\n                            void *l3hdr, size_t l3hdr_len,\n\n                            size_t l3payload_len,\n\n                            size_t frag_offset, bool more_frags)\n\n{\n\n    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {\n\n        uint16_t orig_flags;\n\n        struct ip_header *iphdr = (struct ip_header *) l3hdr;\n\n        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;\n\n        uint16_t new_ip_off;\n\n\n\n        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);\n\n        assert((frag_off_units & ~IP_OFFMASK) == 0);\n\n\n\n        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);\n\n        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);\n\n        iphdr->ip_off = cpu_to_be16(new_ip_off);\n\n        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);\n\n    }\n\n}\n", "idx": 26663, "_split": "test", "_hash": "7d97fd2b4dda26881343ae9657cfc127"}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float32 HELPER(ucf64_subs)(float32 a, float32 b, CPUUniCore32State *env)\n\n{\n\n    return float32_sub(a, b, &env->ucf64.fp_status);\n\n}\n", "idx": 26671, "_split": "test", "_hash": "3ed0acdb12cb79be3af00ed01d2a3424"}
{"project": "qemu", "commit_id": "c6a6a5e3bb7120e1eb33eca6364a290229c1e72e", "target": 0, "func": "do_cksum(uint8_t *dp, uint8_t *de)\n\n{\n\n    unsigned int bsum[2] = {0, 0}, i, sum;\n\n\n\n    for (i = 1; dp < de; bsum[i^=1] += *dp++)\n\n        ;\n\n    sum = (bsum[0] << 8) + bsum[1];\n\n    sum = (sum >> 16) + (sum & 0xffff);\n\n    return ~(sum + (sum >> 16));\n\n}\n", "idx": 26673, "_split": "test", "_hash": "47da0e4fd8bdae4b14baba9e6737d09a"}
{"project": "qemu", "commit_id": "100f738850639a108d6767316ce4dcc1d1ea4ae4", "target": 0, "func": "static void ics_simple_realize(DeviceState *dev, Error **errp)\n\n{\n\n    ICSState *ics = ICS_SIMPLE(dev);\n\n\n\n    if (!ics->nr_irqs) {\n\n        error_setg(errp, \"Number of interrupts needs to be greater 0\");\n\n        return;\n\n    }\n\n    ics->irqs = g_malloc0(ics->nr_irqs * sizeof(ICSIRQState));\n\n    ics->qirqs = qemu_allocate_irqs(ics_simple_set_irq, ics, ics->nr_irqs);\n\n\n\n    qemu_register_reset(ics_simple_reset, dev);\n\n}\n", "idx": 26680, "_split": "test", "_hash": "3f06f95005748878b7c192995f88d20e"}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static void vnc_flush(VncState *vs)\n\n{\n\n    if (vs->output.offset)\n\n\tvnc_client_write(vs);\n\n}\n", "idx": 26701, "_split": "test", "_hash": "907dba92d48afe06b02c5ee62eb274e1"}
{"project": "qemu", "commit_id": "bab482d7405f9fe3cac9c213d60f9ca9442c047b", "target": 0, "func": "static void do_subchannel_work(SubchDev *sch, ORB *orb)\n\n{\n\n\n\n    SCSW *s = &sch->curr_status.scsw;\n\n\n\n    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {\n\n        sch_handle_clear_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {\n\n        sch_handle_halt_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {\n\n        /* Triggered by both ssch and rsch. */\n\n        sch_handle_start_func(sch, orb);\n\n    } else {\n\n        /* Cannot happen. */\n\n        return;\n\n    }\n\n    css_inject_io_interrupt(sch);\n\n}\n", "idx": 26711, "_split": "test", "_hash": "e949f489fc3e48bb21dad438c80ce159"}
{"project": "qemu", "commit_id": "e25cad6921ef78c8e2b7a4f59b03545bd675a9ad", "target": 1, "func": "static int sd_snapshot_delete(BlockDriverState *bs,\n\n                              const char *snapshot_id,\n\n                              const char *name,\n\n                              Error **errp)\n\n{\n\n    unsigned long snap_id = 0;\n\n    char snap_tag[SD_MAX_VDI_TAG_LEN];\n\n    Error *local_err = NULL;\n\n    int fd, ret;\n\n    char buf[SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN];\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    unsigned int wlen = SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN, rlen = 0;\n\n    uint32_t vid;\n\n    SheepdogVdiReq hdr = {\n\n        .opcode = SD_OP_DEL_VDI,\n\n        .data_length = wlen,\n\n        .flags = SD_FLAG_CMD_WRITE,\n\n    };\n\n    SheepdogVdiRsp *rsp = (SheepdogVdiRsp *)&hdr;\n\n\n\n    if (!remove_objects(s)) {\n\n        return -1;\n\n    }\n\n\n\n    memset(buf, 0, sizeof(buf));\n\n    memset(snap_tag, 0, sizeof(snap_tag));\n\n    pstrcpy(buf, SD_MAX_VDI_LEN, s->name);\n\n    ret = qemu_strtoul(snapshot_id, NULL, 10, &snap_id);\n\n    if (ret || snap_id > UINT32_MAX) {\n\n        error_setg(errp, \"Invalid snapshot ID: %s\",\n\n                         snapshot_id ? snapshot_id : \"<null>\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (snap_id) {\n\n        hdr.snapid = (uint32_t) snap_id;\n\n    } else {\n\n        pstrcpy(snap_tag, sizeof(snap_tag), snapshot_id);\n\n        pstrcpy(buf + SD_MAX_VDI_LEN, SD_MAX_VDI_TAG_LEN, snap_tag);\n\n    }\n\n\n\n    ret = find_vdi_name(s, s->name, snap_id, snap_tag, &vid, true,\n\n                        &local_err);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    fd = connect_to_sdog(s, &local_err);\n\n    if (fd < 0) {\n\n        error_report_err(local_err);\n\n        return -1;\n\n    }\n\n\n\n    ret = do_req(fd, s->bs, (SheepdogReq *)&hdr,\n\n                 buf, &wlen, &rlen);\n\n    closesocket(fd);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    switch (rsp->result) {\n\n    case SD_RES_NO_VDI:\n\n        error_report(\"%s was already deleted\", s->name);\n\n    case SD_RES_SUCCESS:\n\n        break;\n\n    default:\n\n        error_report(\"%s, %s\", sd_strerror(rsp->result), s->name);\n\n        return -1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 26725, "_split": "test", "_hash": "d6fd99df46f1e71478cec026f6241d6b"}
{"project": "qemu", "commit_id": "ebd9fbd7e102c533143c2c8372312b75c2b2678a", "target": 1, "func": "static int block_save_iterate(QEMUFile *f, void *opaque)\n\n{\n\n    int ret;\n\n    int64_t last_ftell = qemu_ftell(f);\n\n\n\n    DPRINTF(\"Enter save live iterate submitted %d transferred %d\\n\",\n\n            block_mig_state.submitted, block_mig_state.transferred);\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    blk_mig_reset_dirty_cursor();\n\n\n\n    /* control the rate of transfer */\n\n    blk_mig_lock();\n\n    while ((block_mig_state.submitted +\n\n            block_mig_state.read_done) * BLOCK_SIZE <\n\n           qemu_file_get_rate_limit(f)) {\n\n        blk_mig_unlock();\n\n        if (block_mig_state.bulk_completed == 0) {\n\n            /* first finish the bulk phase */\n\n            if (blk_mig_save_bulked_block(f) == 0) {\n\n                /* finished saving bulk on all devices */\n\n                block_mig_state.bulk_completed = 1;\n\n            }\n\n            ret = 0;\n\n        } else {\n\n            /* Always called with iothread lock taken for\n\n             * simplicity, block_save_complete also calls it.\n\n             */\n\n            qemu_mutex_lock_iothread();\n\n            ret = blk_mig_save_dirty_block(f, 1);\n\n            qemu_mutex_unlock_iothread();\n\n        }\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        blk_mig_lock();\n\n        if (ret != 0) {\n\n            /* no more dirty blocks */\n\n            break;\n\n        }\n\n    }\n\n    blk_mig_unlock();\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    qemu_put_be64(f, BLK_MIG_FLAG_EOS);\n\n    return qemu_ftell(f) - last_ftell;\n\n}\n", "idx": 26726, "_split": "test", "_hash": "26f23de188088d6dc6f0e4afcd775859"}
{"project": "qemu", "commit_id": "ed1dda53d073acdb52889aa30f9d251061b053bd", "target": 1, "func": "static always_inline void gen_intermediate_code_internal (CPUState *env,\n\n                                                          TranslationBlock *tb,\n\n                                                          int search_pc)\n\n{\n\n#if defined ALPHA_DEBUG_DISAS\n\n    static int insn_count;\n\n#endif\n\n    DisasContext ctx, *ctxp = &ctx;\n\n    target_ulong pc_start;\n\n    uint32_t insn;\n\n    uint16_t *gen_opc_end;\n\n    CPUBreakpoint *bp;\n\n    int j, lj = -1;\n\n    int ret;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    ctx.pc = pc_start;\n\n    ctx.amask = env->amask;\n\n#if defined (CONFIG_USER_ONLY)\n\n    ctx.mem_idx = 0;\n\n#else\n\n    ctx.mem_idx = ((env->ps >> 3) & 3);\n\n    ctx.pal_mode = env->ipr[IPR_EXC_ADDR] & 1;\n\n#endif\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n\n\n    gen_icount_start();\n\n    for (ret = 0; ret == 0;) {\n\n        if (unlikely(!TAILQ_EMPTY(&env->breakpoints))) {\n\n            TAILQ_FOREACH(bp, &env->breakpoints, entry) {\n\n                if (bp->pc == ctx.pc) {\n\n                    gen_excp(&ctx, EXCP_DEBUG, 0);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (search_pc) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n                gen_opc_pc[lj] = ctx.pc;\n\n                gen_opc_instr_start[lj] = 1;\n\n                gen_opc_icount[lj] = num_insns;\n\n            }\n\n        }\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n#if defined ALPHA_DEBUG_DISAS\n\n        insn_count++;\n\n        LOG_DISAS(\"pc \" TARGET_FMT_lx \" mem_idx %d\\n\",\n\n                  ctx.pc, ctx.mem_idx);\n\n#endif\n\n        insn = ldl_code(ctx.pc);\n\n#if defined ALPHA_DEBUG_DISAS\n\n        insn_count++;\n\n        LOG_DISAS(\"opcode %08x %d\\n\", insn, insn_count);\n\n#endif\n\n        num_insns++;\n\n        ctx.pc += 4;\n\n        ret = translate_one(ctxp, insn);\n\n        if (ret != 0)\n\n            break;\n\n        /* if we reach a page boundary or are single stepping, stop\n\n         * generation\n\n         */\n\n        if (((ctx.pc & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n            num_insns >= max_insns) {\n\n            break;\n\n        }\n\n\n\n        if (env->singlestep_enabled) {\n\n            gen_excp(&ctx, EXCP_DEBUG, 0);\n\n            break;\n\n\t}\n\n\n\n#if defined (DO_SINGLE_STEP)\n\n        break;\n\n#endif\n\n    }\n\n    if (ret != 1 && ret != 3) {\n\n        tcg_gen_movi_i64(cpu_pc, ctx.pc);\n\n    }\n\n#if defined (DO_TB_FLUSH)\n\n    gen_helper_tb_flush();\n\n#endif\n\n    if (tb->cflags & CF_LAST_IO)\n\n        gen_io_end();\n\n    /* Generate the return instruction */\n\n    tcg_gen_exit_tb(0);\n\n    gen_icount_end(tb, num_insns);\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = ctx.pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n#if defined ALPHA_DEBUG_DISAS\n\n    log_cpu_state_mask(CPU_LOG_TB_CPU, env, 0);\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(pc_start, ctx.pc - pc_start, 1);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n}\n", "idx": 26734, "_split": "test", "_hash": "7621b273160a94f917c22209e57c750b"}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "VncJob *vnc_job_new(VncState *vs)\n\n{\n\n    VncJob *job = g_malloc0(sizeof(VncJob));\n\n\n\n    job->vs = vs;\n\n    vnc_lock_queue(queue);\n\n    QLIST_INIT(&job->rectangles);\n\n    vnc_unlock_queue(queue);\n\n    return job;\n\n}\n", "idx": 26738, "_split": "test", "_hash": "983a0a10f6e6117ebb3665b7066aa3ec"}
{"project": "qemu", "commit_id": "0c9390d978cbf61e8f16c9f580fa96b305c43568", "target": 1, "func": "static void nbd_client_closed(NBDClient *client)\n\n{\n\n    nb_fds--;\n\n    if (nb_fds == 0 && !persistent && state == RUNNING) {\n\n        state = TERMINATE;\n\n    }\n\n    nbd_update_server_watch();\n\n    nbd_client_put(client);\n\n}\n", "idx": 26745, "_split": "test", "_hash": "6cce7bc165aabbc0ccfdf4089f819861"}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_create_sq(NvmeCtrl *n, NvmeCmd *cmd)\n\n{\n\n    NvmeSQueue *sq;\n\n    NvmeCreateSq *c = (NvmeCreateSq *)cmd;\n\n\n\n    uint16_t cqid = le16_to_cpu(c->cqid);\n\n    uint16_t sqid = le16_to_cpu(c->sqid);\n\n    uint16_t qsize = le16_to_cpu(c->qsize);\n\n    uint16_t qflags = le16_to_cpu(c->sq_flags);\n\n    uint64_t prp1 = le64_to_cpu(c->prp1);\n\n\n\n    if (!cqid || nvme_check_cqid(n, cqid)) {\n\n        return NVME_INVALID_CQID | NVME_DNR;\n\n    }\n\n    if (!sqid || !nvme_check_sqid(n, sqid)) {\n\n        return NVME_INVALID_QID | NVME_DNR;\n\n    }\n\n    if (!qsize || qsize > NVME_CAP_MQES(n->bar.cap)) {\n\n        return NVME_MAX_QSIZE_EXCEEDED | NVME_DNR;\n\n    }\n\n    if (!prp1 || prp1 & (n->page_size - 1)) {\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    if (!(NVME_SQ_FLAGS_PC(qflags))) {\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    sq = g_malloc0(sizeof(*sq));\n\n    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);\n\n    return NVME_SUCCESS;\n\n}\n", "idx": 26749, "_split": "test", "_hash": "43f7e68e73203572da9df6c37545c260"}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *s,\n\n                int x, int y, int w, int h)\n\n{\n\n    struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last ++];\n\n    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;\n\n    rect->x = x;\n\n    rect->y = y;\n\n    rect->w = w;\n\n    rect->h = h;\n\n}\n", "idx": 26776, "_split": "test", "_hash": "2bbe63b10fe81cc57b8a5640ed211aa1"}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)\n\n{\n\n\tif (dc->flagx_known) {\n\n\t\tif (dc->flags_x) {\n\n\t\t\tTCGv c;\n\n            \n\n\t\t\tc = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\tt_gen_mov_TN_preg(c, PR_CCS);\n\n\t\t\t/* C flag is already at bit 0.  */\n\n\t\t\ttcg_gen_andi_tl(c, c, C_FLAG);\n\n\t\t\ttcg_gen_add_tl(d, d, c);\n\n\t\t\ttcg_temp_free(c);\n\n\t\t}\n\n\t} else {\n\n\t\tTCGv x, c;\n\n\n\n\t\tx = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tc = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tt_gen_mov_TN_preg(x, PR_CCS);\n\n\t\ttcg_gen_mov_tl(c, x);\n\n\n\n\t\t/* Propagate carry into d if X is set. Branch free.  */\n\n\t\ttcg_gen_andi_tl(c, c, C_FLAG);\n\n\t\ttcg_gen_andi_tl(x, x, X_FLAG);\n\n\t\ttcg_gen_shri_tl(x, x, 4);\n\n\n\n\t\ttcg_gen_and_tl(x, x, c);\n\n\t\ttcg_gen_add_tl(d, d, x);        \n\n\t\ttcg_temp_free(x);\n\n\t\ttcg_temp_free(c);\n\n\t}\n\n}\n", "idx": 26777, "_split": "test", "_hash": "0438b4e58566fd79a942cb51dc84c4cc"}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void rtas_start_cpu(sPAPREnvironment *spapr,\n\n                           uint32_t token, uint32_t nargs,\n\n                           target_ulong args,\n\n                           uint32_t nret, target_ulong rets)\n\n{\n\n    target_ulong id, start, r3;\n\n    CPUState *cs;\n\n\n\n    if (nargs != 3 || nret != 1) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n\n\n    id = rtas_ld(args, 0);\n\n    start = rtas_ld(args, 1);\n\n    r3 = rtas_ld(args, 2);\n\n\n\n    cs = qemu_get_cpu(id);\n\n    if (cs != NULL) {\n\n        PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n        CPUPPCState *env = &cpu->env;\n\n\n\n        if (!cs->halted) {\n\n            rtas_st(rets, 0, -1);\n\n            return;\n\n        }\n\n\n\n        /* This will make sure qemu state is up to date with kvm, and\n\n         * mark it dirty so our changes get flushed back before the\n\n         * new cpu enters */\n\n        kvm_cpu_synchronize_state(cs);\n\n\n\n        env->msr = (1ULL << MSR_SF) | (1ULL << MSR_ME);\n\n        env->nip = start;\n\n        env->gpr[3] = r3;\n\n        cs->halted = 0;\n\n\n\n        qemu_cpu_kick(cs);\n\n\n\n        rtas_st(rets, 0, 0);\n\n        return;\n\n    }\n\n\n\n    /* Didn't find a matching cpu */\n\n    rtas_st(rets, 0, -3);\n\n}\n", "idx": 26780, "_split": "test", "_hash": "ac829e19212e4909e1bd8c7b2038a70f"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int i2c_start_transfer(i2c_bus *bus, int address, int recv)\n\n{\n\n    DeviceState *qdev;\n\n    i2c_slave *slave = NULL;\n\n\n\n    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {\n\n        slave = I2C_SLAVE_FROM_QDEV(qdev);\n\n        if (slave->address == address)\n\n            break;\n\n    }\n\n\n\n    if (!slave)\n\n        return 1;\n\n\n\n    /* If the bus is already busy, assume this is a repeated\n\n       start condition.  */\n\n    bus->current_dev = slave;\n\n    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);\n\n    return 0;\n\n}\n", "idx": 26792, "_split": "test", "_hash": "a3fcab125021e5337d2cfafcd2327afc"}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)\n\n{\n\n    unsigned i;\n\n\n\n    /* Check that there is free space left in a buffer */\n\n    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {\n\n        ERRPRINT(\"Can't write to data buffer: buffer full\\n\");\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < size; i++) {\n\n        s->fifo_buffer[s->data_count] = value & 0xFF;\n\n        s->data_count++;\n\n        value >>= 8;\n\n        if (s->data_count >= (s->blksize & 0x0fff)) {\n\n            DPRINT_L2(\"write buffer filled with %u bytes of data\\n\",\n\n                    s->data_count);\n\n            s->data_count = 0;\n\n            s->prnsts &= ~SDHC_SPACE_AVAILABLE;\n\n            if (s->prnsts & SDHC_DOING_WRITE) {\n\n                sdhci_write_block_to_card(s);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 26841, "_split": "test", "_hash": "07a2d8a90135c7ebde231ca680e1c1f7"}
{"project": "qemu", "commit_id": "2d528d45ecf5ee3c1a566a9f3d664464925ef830", "target": 1, "func": "static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)\n\n{\n\n    const char *filename = opts->device;\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = qemu_chr_alloc();\n\n    s = g_malloc0(sizeof(WinCharState));\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    chr->chr_close = win_chr_close;\n\n\n\n    if (win_chr_pipe_init(chr, filename) < 0) {\n\n        g_free(s);\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n    return chr;\n\n}\n", "idx": 26848, "_split": "test", "_hash": "237b2803caf79be2e89ce59f84c1014a"}
{"project": "qemu", "commit_id": "977ec47de06bdcb24f01c93bc125b7c6c221a1c5", "target": 0, "func": "static void *thread_func(void *p)\n\n{\n\n    struct thread_info *info = p;\n\n\n\n    rcu_register_thread();\n\n\n\n    atomic_inc(&n_ready_threads);\n\n    while (!atomic_mb_read(&test_start)) {\n\n        cpu_relax();\n\n    }\n\n\n\n    rcu_read_lock();\n\n    while (!atomic_read(&test_stop)) {\n\n        info->r = xorshift64star(info->r);\n\n        info->func(info);\n\n    }\n\n    rcu_read_unlock();\n\n\n\n    rcu_unregister_thread();\n\n    return NULL;\n\n}\n", "idx": 26873, "_split": "test", "_hash": "558144e4db4f7235a5fdddf0a0410bc9"}
{"project": "qemu", "commit_id": "0c402e5abb8c2755390eee864b43a98280fc2453", "target": 0, "func": "static int usb_host_scan_dev(void *opaque, USBScanFunc *func)\n\n{\n\n    FILE *f = NULL;\n\n    char line[1024];\n\n    char buf[1024];\n\n    int bus_num, addr, speed, device_count, class_id, product_id, vendor_id;\n\n    char product_name[512];\n\n    int ret = 0;\n\n\n\n    if (!usb_host_device_path) {\n\n        perror(\"husb: USB Host Device Path not set\");\n\n        goto the_end;\n\n    }\n\n    snprintf(line, sizeof(line), \"%s/devices\", usb_host_device_path);\n\n    f = fopen(line, \"r\");\n\n    if (!f) {\n\n        perror(\"husb: cannot open devices file\");\n\n        goto the_end;\n\n    }\n\n\n\n    device_count = 0;\n\n    bus_num = addr = class_id = product_id = vendor_id = 0;\n\n    speed = -1; /* Can't get the speed from /[proc|dev]/bus/usb/devices */\n\n    for(;;) {\n\n        if (fgets(line, sizeof(line), f) == NULL) {\n\n            break;\n\n        }\n\n        if (strlen(line) > 0) {\n\n            line[strlen(line) - 1] = '\\0';\n\n        }\n\n        if (line[0] == 'T' && line[1] == ':') {\n\n            if (device_count && (vendor_id || product_id)) {\n\n                /* New device.  Add the previously discovered device.  */\n\n                ret = func(opaque, bus_num, addr, 0, class_id, vendor_id,\n\n                           product_id, product_name, speed);\n\n                if (ret) {\n\n                    goto the_end;\n\n                }\n\n            }\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Bus=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            bus_num = atoi(buf);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Dev#=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            addr = atoi(buf);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Spd=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            if (!strcmp(buf, \"5000\")) {\n\n                speed = USB_SPEED_SUPER;\n\n            } else if (!strcmp(buf, \"480\")) {\n\n                speed = USB_SPEED_HIGH;\n\n            } else if (!strcmp(buf, \"1.5\")) {\n\n                speed = USB_SPEED_LOW;\n\n            } else {\n\n                speed = USB_SPEED_FULL;\n\n            }\n\n            product_name[0] = '\\0';\n\n            class_id = 0xff;\n\n            device_count++;\n\n            product_id = 0;\n\n            vendor_id = 0;\n\n        } else if (line[0] == 'P' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Vendor=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            vendor_id = strtoul(buf, NULL, 16);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"ProdID=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            product_id = strtoul(buf, NULL, 16);\n\n        } else if (line[0] == 'S' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Product=\", \"\") < 0) {\n\n                goto fail;\n\n            }\n\n            pstrcpy(product_name, sizeof(product_name), buf);\n\n        } else if (line[0] == 'D' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Cls=\", \" (\") < 0) {\n\n                goto fail;\n\n            }\n\n            class_id = strtoul(buf, NULL, 16);\n\n        }\n\n    fail: ;\n\n    }\n\n    if (device_count && (vendor_id || product_id)) {\n\n        /* Add the last device.  */\n\n        ret = func(opaque, bus_num, addr, 0, class_id, vendor_id,\n\n                   product_id, product_name, speed);\n\n    }\n\n the_end:\n\n    if (f) {\n\n        fclose(f);\n\n    }\n\n    return ret;\n\n}\n", "idx": 26884, "_split": "test", "_hash": "07d92aa144466784b1f53b0e4ce234d9"}
{"project": "qemu", "commit_id": "03ae4133ab8675d4c67e6fdc8032de7c53a89514", "target": 0, "func": "static void ppc_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    pcc->parent_realize = dc->realize;\n\n    pcc->pvr = CPU_POWERPC_DEFAULT_MASK;\n\n    pcc->pvr_mask = CPU_POWERPC_DEFAULT_MASK;\n\n    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_always;\n\n    dc->realize = ppc_cpu_realizefn;\n\n    dc->unrealize = ppc_cpu_unrealizefn;\n\n\n\n    pcc->parent_reset = cc->reset;\n\n    cc->reset = ppc_cpu_reset;\n\n\n\n    cc->class_by_name = ppc_cpu_class_by_name;\n\n    cc->has_work = ppc_cpu_has_work;\n\n    cc->do_interrupt = ppc_cpu_do_interrupt;\n\n    cc->dump_state = ppc_cpu_dump_state;\n\n    cc->dump_statistics = ppc_cpu_dump_statistics;\n\n    cc->set_pc = ppc_cpu_set_pc;\n\n    cc->gdb_read_register = ppc_cpu_gdb_read_register;\n\n    cc->gdb_write_register = ppc_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = ppc_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_phys_page_debug = ppc_cpu_get_phys_page_debug;\n\n    cc->vmsd = &vmstate_ppc_cpu;\n\n#if defined(TARGET_PPC64)\n\n    cc->write_elf64_note = ppc64_cpu_write_elf64_note;\n\n    cc->write_elf64_qemunote = ppc64_cpu_write_elf64_qemunote;\n\n#endif\n\n#endif\n\n\n\n    cc->gdb_num_core_regs = 71;\n\n\n\n#ifdef USE_APPLE_GDB\n\n    cc->gdb_read_register = ppc_cpu_gdb_read_register_apple;\n\n    cc->gdb_write_register = ppc_cpu_gdb_write_register_apple;\n\n    cc->gdb_num_core_regs = 71 + 32;\n\n#endif\n\n\n\n#if defined(TARGET_PPC64)\n\n    cc->gdb_core_xml_file = \"power64-core.xml\";\n\n#else\n\n    cc->gdb_core_xml_file = \"power-core.xml\";\n\n#endif\n\n#ifndef CONFIG_USER_ONLY\n\n    cc->virtio_is_big_endian = ppc_cpu_is_big_endian;\n\n#endif\n\n\n\n    dc->fw_name = \"PowerPC,UNKNOWN\";\n\n}\n", "idx": 26886, "_split": "test", "_hash": "24311472c6b3a02c7dffd2db11e81908"}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)\n\n{\n\n    VLANClientState *vc;\n\n\n\n    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {\n\n        if (vc != sender && !vc->link_down) {\n\n            vc->receive(vc->opaque, buf, size);\n\n        }\n\n    }\n\n}\n", "idx": 26904, "_split": "test", "_hash": "b51136772ac0dea872f236d48db04ee8"}
{"project": "qemu", "commit_id": "7b62a955047934bab158e84ecb63cb432c193ace", "target": 1, "func": "void ppc970_irq_init (CPUState *env)\n\n{\n\n    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);\n\n}\n", "idx": 26935, "_split": "test", "_hash": "e92e69312922276a850ac3c405f1d020"}
{"project": "qemu", "commit_id": "1110bfe6f5600017258fa6578f9c17ec25b32277", "target": 0, "func": "static void do_interrupt_protected(CPUX86State *env, int intno, int is_int,\n\n                                   int error_code, unsigned int next_eip,\n\n                                   int is_hw)\n\n{\n\n    SegmentCache *dt;\n\n    target_ulong ptr, ssp;\n\n    int type, dpl, selector, ss_dpl, cpl;\n\n    int has_error_code, new_stack, shift;\n\n    uint32_t e1, e2, offset, ss = 0, esp, ss_e1 = 0, ss_e2 = 0;\n\n    uint32_t old_eip, sp_mask;\n\n    int vm86 = env->eflags & VM_MASK;\n\n\n\n    has_error_code = 0;\n\n    if (!is_int && !is_hw) {\n\n        has_error_code = exception_has_error_code(intno);\n\n    }\n\n    if (is_int) {\n\n        old_eip = next_eip;\n\n    } else {\n\n        old_eip = env->eip;\n\n    }\n\n\n\n    dt = &env->idt;\n\n    if (intno * 8 + 7 > dt->limit) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n    }\n\n    ptr = dt->base + intno * 8;\n\n    e1 = cpu_ldl_kernel(env, ptr);\n\n    e2 = cpu_ldl_kernel(env, ptr + 4);\n\n    /* check gate type */\n\n    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;\n\n    switch (type) {\n\n    case 5: /* task gate */\n\n        /* must do that check here to return the correct error code */\n\n        if (!(e2 & DESC_P_MASK)) {\n\n            raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);\n\n        }\n\n        switch_tss(env, intno * 8, e1, e2, SWITCH_TSS_CALL, old_eip);\n\n        if (has_error_code) {\n\n            int type;\n\n            uint32_t mask;\n\n\n\n            /* push the error code */\n\n            type = (env->tr.flags >> DESC_TYPE_SHIFT) & 0xf;\n\n            shift = type >> 3;\n\n            if (env->segs[R_SS].flags & DESC_B_MASK) {\n\n                mask = 0xffffffff;\n\n            } else {\n\n                mask = 0xffff;\n\n            }\n\n            esp = (env->regs[R_ESP] - (2 << shift)) & mask;\n\n            ssp = env->segs[R_SS].base + esp;\n\n            if (shift) {\n\n                cpu_stl_kernel(env, ssp, error_code);\n\n            } else {\n\n                cpu_stw_kernel(env, ssp, error_code);\n\n            }\n\n            SET_ESP(esp, mask);\n\n        }\n\n        return;\n\n    case 6: /* 286 interrupt gate */\n\n    case 7: /* 286 trap gate */\n\n    case 14: /* 386 interrupt gate */\n\n    case 15: /* 386 trap gate */\n\n        break;\n\n    default:\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n        break;\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    /* check privilege if software int */\n\n    if (is_int && dpl < cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n    }\n\n    /* check valid bit */\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);\n\n    }\n\n    selector = e1 >> 16;\n\n    offset = (e2 & 0xffff0000) | (e1 & 0x0000ffff);\n\n    if ((selector & 0xfffc) == 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n    if (load_segment(env, &e1, &e2, selector) != 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    if (dpl > cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_C_MASK) && dpl < cpl) {\n\n        /* to inner privilege */\n\n        get_ss_esp_from_tss(env, &ss, &esp, dpl, 0);\n\n        if ((ss & 0xfffc) == 0) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if ((ss & 3) != dpl) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (load_segment(env, &ss_e1, &ss_e2, ss) != 0) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        ss_dpl = (ss_e2 >> DESC_DPL_SHIFT) & 3;\n\n        if (ss_dpl != dpl) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (!(ss_e2 & DESC_S_MASK) ||\n\n            (ss_e2 & DESC_CS_MASK) ||\n\n            !(ss_e2 & DESC_W_MASK)) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (!(ss_e2 & DESC_P_MASK)) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        new_stack = 1;\n\n        sp_mask = get_sp_mask(ss_e2);\n\n        ssp = get_seg_base(ss_e1, ss_e2);\n\n    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {\n\n        /* to same privilege */\n\n        if (vm86) {\n\n            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        }\n\n        new_stack = 0;\n\n        sp_mask = get_sp_mask(env->segs[R_SS].flags);\n\n        ssp = env->segs[R_SS].base;\n\n        esp = env->regs[R_ESP];\n\n        dpl = cpl;\n\n    } else {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        new_stack = 0; /* avoid warning */\n\n        sp_mask = 0; /* avoid warning */\n\n        ssp = 0; /* avoid warning */\n\n        esp = 0; /* avoid warning */\n\n    }\n\n\n\n    shift = type >> 3;\n\n\n\n#if 0\n\n    /* XXX: check that enough room is available */\n\n    push_size = 6 + (new_stack << 2) + (has_error_code << 1);\n\n    if (vm86) {\n\n        push_size += 8;\n\n    }\n\n    push_size <<= shift;\n\n#endif\n\n    if (shift == 1) {\n\n        if (new_stack) {\n\n            if (vm86) {\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_GS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_FS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_DS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_ES].selector);\n\n            }\n\n            PUSHL(ssp, esp, sp_mask, env->segs[R_SS].selector);\n\n            PUSHL(ssp, esp, sp_mask, env->regs[R_ESP]);\n\n        }\n\n        PUSHL(ssp, esp, sp_mask, cpu_compute_eflags(env));\n\n        PUSHL(ssp, esp, sp_mask, env->segs[R_CS].selector);\n\n        PUSHL(ssp, esp, sp_mask, old_eip);\n\n        if (has_error_code) {\n\n            PUSHL(ssp, esp, sp_mask, error_code);\n\n        }\n\n    } else {\n\n        if (new_stack) {\n\n            if (vm86) {\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_GS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_FS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_DS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_ES].selector);\n\n            }\n\n            PUSHW(ssp, esp, sp_mask, env->segs[R_SS].selector);\n\n            PUSHW(ssp, esp, sp_mask, env->regs[R_ESP]);\n\n        }\n\n        PUSHW(ssp, esp, sp_mask, cpu_compute_eflags(env));\n\n        PUSHW(ssp, esp, sp_mask, env->segs[R_CS].selector);\n\n        PUSHW(ssp, esp, sp_mask, old_eip);\n\n        if (has_error_code) {\n\n            PUSHW(ssp, esp, sp_mask, error_code);\n\n        }\n\n    }\n\n\n\n    /* interrupt gate clear IF mask */\n\n    if ((type & 1) == 0) {\n\n        env->eflags &= ~IF_MASK;\n\n    }\n\n    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);\n\n\n\n    if (new_stack) {\n\n        if (vm86) {\n\n            cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0, 0);\n\n        }\n\n        ss = (ss & ~3) | dpl;\n\n        cpu_x86_load_seg_cache(env, R_SS, ss,\n\n                               ssp, get_seg_limit(ss_e1, ss_e2), ss_e2);\n\n    }\n\n    SET_ESP(esp, sp_mask);\n\n\n\n    selector = (selector & ~3) | dpl;\n\n    cpu_x86_load_seg_cache(env, R_CS, selector,\n\n                   get_seg_base(e1, e2),\n\n                   get_seg_limit(e1, e2),\n\n                   e2);\n\n    env->eip = offset;\n\n}\n", "idx": 26941, "_split": "test", "_hash": "597b3a3a413f5fb234c00907cfedf423"}
{"project": "qemu", "commit_id": "7e97cd88148876bad36ee7c66d526dcaed328d0d", "target": 0, "func": "static void kvm_start_vcpu(CPUState *env)\n\n{\n\n    env->thread = qemu_mallocz(sizeof(QemuThread));\n\n    env->halt_cond = qemu_mallocz(sizeof(QemuCond));\n\n    qemu_cond_init(env->halt_cond);\n\n    qemu_thread_create(env->thread, kvm_cpu_thread_fn, env);\n\n    while (env->created == 0)\n\n        qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);\n\n}\n", "idx": 26945, "_split": "test", "_hash": "b6649e3a8f097babf4a9e9f8551fa41a"}
{"project": "qemu", "commit_id": "c18ad9a54b75495ce61e8b28d353f8eec51768fc", "target": 0, "func": "static hwaddr ppc_hash64_pteg_search(PowerPCCPU *cpu, hwaddr hash,\n\n                                     bool secondary, target_ulong ptem,\n\n                                     ppc_hash_pte64_t *pte)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    int i;\n\n    uint64_t token;\n\n    target_ulong pte0, pte1;\n\n    target_ulong pte_index;\n\n\n\n    pte_index = (hash & env->htab_mask) * HPTES_PER_GROUP;\n\n    token = ppc_hash64_start_access(cpu, pte_index);\n\n    if (!token) {\n\n        return -1;\n\n    }\n\n    for (i = 0; i < HPTES_PER_GROUP; i++) {\n\n        pte0 = ppc_hash64_load_hpte0(cpu, token, i);\n\n        pte1 = ppc_hash64_load_hpte1(cpu, token, i);\n\n\n\n        if ((pte0 & HPTE64_V_VALID)\n\n            && (secondary == !!(pte0 & HPTE64_V_SECONDARY))\n\n            && HPTE64_V_COMPARE(pte0, ptem)) {\n\n            pte->pte0 = pte0;\n\n            pte->pte1 = pte1;\n\n            ppc_hash64_stop_access(token);\n\n            return (pte_index + i) * HASH_PTE_SIZE_64;\n\n        }\n\n    }\n\n    ppc_hash64_stop_access(token);\n\n    /*\n\n     * We didn't find a valid entry.\n\n     */\n\n    return -1;\n\n}\n", "idx": 26946, "_split": "test", "_hash": "a8e714d1595d93e0c2d5a0bd6f66ceb9"}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)\n\n{\n\n    val = tswap64(val);\n\n    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));\n\n}\n", "idx": 26987, "_split": "test", "_hash": "627368382a464e4e9a63d439f9b165c1"}
{"project": "qemu", "commit_id": "21f88d021d0d2b4ecee8f6cd6ca63a943a3ce71d", "target": 1, "func": "test_opts_dict_unvisited(void)\n\n{\n\n    QemuOpts *opts;\n\n    Visitor *v;\n\n    UserDefOptions *userdef;\n\n\n\n    opts = qemu_opts_parse(qemu_find_opts(\"userdef\"), \"i64x=0,bogus=1\", false,\n\n                           &error_abort);\n\n\n\n    v = opts_visitor_new(opts);\n\n    /* BUG: bogus should be diagnosed */\n\n    visit_type_UserDefOptions(v, NULL, &userdef, &error_abort);\n\n    visit_free(v);\n\n    qemu_opts_del(opts);\n\n    qapi_free_UserDefOptions(userdef);\n\n}\n", "idx": 26993, "_split": "test", "_hash": "323c0239d6b62011686fa19652aa1947"}
{"project": "qemu", "commit_id": "67a0fd2a9bca204d2b39f910a97c7137636a0715", "target": 0, "func": "static int64_t coroutine_fn parallels_co_get_block_status(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *pnum)\n\n{\n\n    BDRVParallelsState *s = bs->opaque;\n\n    int64_t offset;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    offset = block_status(s, sector_num, nb_sectors, pnum);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    if (offset < 0) {\n\n        return 0;\n\n    }\n\n\n\n    return (offset << BDRV_SECTOR_BITS) |\n\n        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;\n\n}\n", "idx": 27000, "_split": "test", "_hash": "0d3f1391f3ebbc60b349f6715aa5208f"}
{"project": "qemu", "commit_id": "c5b9729ae918b890905e00870ffc08c9b56e6d17", "target": 0, "func": "void helper_4xx_tlbwe_hi (target_ulong entry, target_ulong val)\n\n{\n\n    ppcemb_tlb_t *tlb;\n\n    target_ulong page, end;\n\n\n\n    LOG_SWTLB(\"%s entry %d val \" TARGET_FMT_lx \"\\n\", __func__, (int)entry,\n\n              val);\n\n    entry &= 0x3F;\n\n    tlb = &env->tlb[entry].tlbe;\n\n    /* Invalidate previous TLB (if it's valid) */\n\n    if (tlb->prot & PAGE_VALID) {\n\n        end = tlb->EPN + tlb->size;\n\n        LOG_SWTLB(\"%s: invalidate old TLB %d start \" TARGET_FMT_lx \" end \"\n\n                  TARGET_FMT_lx \"\\n\", __func__, (int)entry, tlb->EPN, end);\n\n        for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE)\n\n            tlb_flush_page(env, page);\n\n    }\n\n    tlb->size = booke_tlb_to_page_size((val >> 7) & 0x7);\n\n    /* We cannot handle TLB size < TARGET_PAGE_SIZE.\n\n     * If this ever occurs, one should use the ppcemb target instead\n\n     * of the ppc or ppc64 one\n\n     */\n\n    if ((val & 0x40) && tlb->size < TARGET_PAGE_SIZE) {\n\n        cpu_abort(env, \"TLB size \" TARGET_FMT_lu \" < %u \"\n\n                  \"are not supported (%d)\\n\",\n\n                  tlb->size, TARGET_PAGE_SIZE, (int)((val >> 7) & 0x7));\n\n    }\n\n    tlb->EPN = val & ~(tlb->size - 1);\n\n    if (val & 0x40)\n\n        tlb->prot |= PAGE_VALID;\n\n    else\n\n        tlb->prot &= ~PAGE_VALID;\n\n    if (val & 0x20) {\n\n        /* XXX: TO BE FIXED */\n\n        cpu_abort(env, \"Little-endian TLB entries are not supported by now\\n\");\n\n    }\n\n    tlb->PID = env->spr[SPR_40x_PID]; /* PID */\n\n    LOG_SWTLB(\"%s: set up TLB %d RPN \" TARGET_FMT_plx \" EPN \" TARGET_FMT_lx\n\n              \" size \" TARGET_FMT_lx \" prot %c%c%c%c PID %d\\n\", __func__,\n\n              (int)entry, tlb->RPN, tlb->EPN, tlb->size,\n\n              tlb->prot & PAGE_READ ? 'r' : '-',\n\n              tlb->prot & PAGE_WRITE ? 'w' : '-',\n\n              tlb->prot & PAGE_EXEC ? 'x' : '-',\n\n              tlb->prot & PAGE_VALID ? 'v' : '-', (int)tlb->PID);\n\n    /* Invalidate new TLB (if valid) */\n\n    if (tlb->prot & PAGE_VALID) {\n\n        end = tlb->EPN + tlb->size;\n\n        LOG_SWTLB(\"%s: invalidate TLB %d start \" TARGET_FMT_lx \" end \"\n\n                  TARGET_FMT_lx \"\\n\", __func__, (int)entry, tlb->EPN, end);\n\n        for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE)\n\n            tlb_flush_page(env, page);\n\n    }\n\n}\n", "idx": 27007, "_split": "test", "_hash": "3523e02b227501add08f2b76a9998f7e"}
{"project": "qemu", "commit_id": "fd563564222f308e1d86847efdec8555fb472536", "target": 1, "func": "static void kvm_update_msi_routes_all(void *private, bool global,\n\n                                      uint32_t index, uint32_t mask)\n\n{\n\n    int cnt = 0;\n\n    MSIRouteEntry *entry;\n\n    MSIMessage msg;\n\n    /* TODO: explicit route update */\n\n    QLIST_FOREACH(entry, &msi_route_list, list) {\n\n        cnt++;\n\n        msg = pci_get_msi_message(entry->dev, entry->vector);\n\n        kvm_irqchip_update_msi_route(kvm_state, entry->virq,\n\n                                     msg, entry->dev);\n\n    }\n\n    kvm_irqchip_commit_routes(kvm_state);\n\n    trace_kvm_x86_update_msi_routes(cnt);\n\n}\n", "idx": 27021, "_split": "test", "_hash": "79b5ace0ccbb2de44123108f2d53bb9c"}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "static void spr_write_601_ubatu (void *opaque, int sprn)\n\n{\n\n    DisasContext *ctx = opaque;\n\n\n\n    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);\n\n    RET_STOP(ctx);\n\n}\n", "idx": 27045, "_split": "test", "_hash": "a1027fceef43a9e585d4787bdf455f86"}
{"project": "qemu", "commit_id": "e774a278d82c9391c9fb6c9af42cd08bb9364b9f", "target": 0, "func": "static void ide_sector_write(IDEState *s)\n\n{\n\n    int64_t sector_num;\n\n    int ret, n, n1;\n\n\n\n    s->status = READY_STAT | SEEK_STAT;\n\n    sector_num = ide_get_sector(s);\n\n#if defined(DEBUG_IDE)\n\n    printf(\"write sector=%Ld\\n\", sector_num);\n\n#endif\n\n    n = s->nsector;\n\n    if (n > s->req_nb_sectors)\n\n        n = s->req_nb_sectors;\n\n    ret = bdrv_write(s->bs, sector_num, s->io_buffer, n);\n\n    s->nsector -= n;\n\n    if (s->nsector == 0) {\n\n        /* no more sector to write */\n\n        ide_transfer_stop(s);\n\n    } else {\n\n        n1 = s->nsector;\n\n        if (n1 > s->req_nb_sectors)\n\n            n1 = s->req_nb_sectors;\n\n        ide_transfer_start(s, s->io_buffer, 512 * n1, ide_sector_write);\n\n    }\n\n    ide_set_sector(s, sector_num + n);\n\n    \n\n#ifdef TARGET_I386\n\n    if (win2k_install_hack) {\n\n        /* It seems there is a bug in the Windows 2000 installer HDD\n\n           IDE driver which fills the disk with empty logs when the\n\n           IDE write IRQ comes too early. This hack tries to correct\n\n           that at the expense of slower write performances. Use this\n\n           option _only_ to install Windows 2000. You must disable it\n\n           for normal use. */\n\n        qemu_mod_timer(s->sector_write_timer, \n\n                       qemu_get_clock(vm_clock) + (ticks_per_sec / 1000));\n\n    } else \n\n#endif\n\n    {\n\n        ide_set_irq(s);\n\n    }\n\n}\n", "idx": 27046, "_split": "test", "_hash": "5614090af174f7f55e9f0dbe5ca1cab6"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "AioContext *iohandler_get_aio_context(void)\n\n{\n\n    iohandler_init();\n\n    return iohandler_ctx;\n\n}\n", "idx": 27048, "_split": "test", "_hash": "57a8f18931c1bbbedddfa05fd6942f24"}
{"project": "qemu", "commit_id": "6049f4f831c6f409031dfa09282b38d0cbaecad8", "target": 0, "func": "abi_long do_syscall(void *cpu_env, int num, abi_long arg1,\n\n                    abi_long arg2, abi_long arg3, abi_long arg4,\n\n                    abi_long arg5, abi_long arg6)\n\n{\n\n    abi_long ret;\n\n    struct stat st;\n\n    struct statfs stfs;\n\n    void *p;\n\n\n\n#ifdef DEBUG\n\n    gemu_log(\"syscall %d\", num);\n\n#endif\n\n    if(do_strace)\n\n        print_syscall(num, arg1, arg2, arg3, arg4, arg5, arg6);\n\n\n\n    switch(num) {\n\n    case TARGET_NR_exit:\n\n#ifdef CONFIG_USE_NPTL\n\n      /* In old applications this may be used to implement _exit(2).\n\n         However in threaded applictions it is used for thread termination,\n\n         and _exit_group is used for application termination.\n\n         Do thread termination if we have more then one thread.  */\n\n      /* FIXME: This probably breaks if a signal arrives.  We should probably\n\n         be disabling signals.  */\n\n      if (first_cpu->next_cpu) {\n\n          TaskState *ts;\n\n          CPUState **lastp;\n\n          CPUState *p;\n\n\n\n          cpu_list_lock();\n\n          lastp = &first_cpu;\n\n          p = first_cpu;\n\n          while (p && p != (CPUState *)cpu_env) {\n\n              lastp = &p->next_cpu;\n\n              p = p->next_cpu;\n\n          }\n\n          /* If we didn't find the CPU for this thread then something is\n\n             horribly wrong.  */\n\n          if (!p)\n\n              abort();\n\n          /* Remove the CPU from the list.  */\n\n          *lastp = p->next_cpu;\n\n          cpu_list_unlock();\n\n          ts = ((CPUState *)cpu_env)->opaque;\n\n          if (ts->child_tidptr) {\n\n              put_user_u32(0, ts->child_tidptr);\n\n              sys_futex(g2h(ts->child_tidptr), FUTEX_WAKE, INT_MAX,\n\n                        NULL, NULL, 0);\n\n          }\n\n          /* TODO: Free CPU state.  */\n\n          pthread_exit(NULL);\n\n      }\n\n#endif\n\n#ifdef TARGET_GPROF\n\n        _mcleanup();\n\n#endif\n\n        gdb_exit(cpu_env, arg1);\n\n        _exit(arg1);\n\n        ret = 0; /* avoid warning */\n\n        break;\n\n    case TARGET_NR_read:\n\n        if (arg3 == 0)\n\n            ret = 0;\n\n        else {\n\n            if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n                goto efault;\n\n            ret = get_errno(read(arg1, p, arg3));\n\n            unlock_user(p, arg2, ret);\n\n        }\n\n        break;\n\n    case TARGET_NR_write:\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(write(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n    case TARGET_NR_open:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(open(path(p),\n\n                             target_to_host_bitmask(arg2, fcntl_flags_tbl),\n\n                             arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_openat) && defined(__NR_openat)\n\n    case TARGET_NR_openat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_openat(arg1,\n\n                                   path(p),\n\n                                   target_to_host_bitmask(arg3, fcntl_flags_tbl),\n\n                                   arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_close:\n\n        ret = get_errno(close(arg1));\n\n        break;\n\n    case TARGET_NR_brk:\n\n        ret = do_brk(arg1);\n\n        break;\n\n    case TARGET_NR_fork:\n\n        ret = get_errno(do_fork(cpu_env, SIGCHLD, 0, 0, 0, 0));\n\n        break;\n\n#ifdef TARGET_NR_waitpid\n\n    case TARGET_NR_waitpid:\n\n        {\n\n            int status;\n\n            ret = get_errno(waitpid(arg1, &status, arg3));\n\n            if (!is_error(ret) && arg2\n\n                && put_user_s32(host_to_target_waitstatus(status), arg2))\n\n                goto efault;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_waitid\n\n    case TARGET_NR_waitid:\n\n        {\n\n            siginfo_t info;\n\n            info.si_pid = 0;\n\n            ret = get_errno(waitid(arg1, arg2, &info, arg4));\n\n            if (!is_error(ret) && arg3 && info.si_pid != 0) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_siginfo_t), 0)))\n\n                    goto efault;\n\n                host_to_target_siginfo(p, &info);\n\n                unlock_user(p, arg3, sizeof(target_siginfo_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_creat /* not on alpha */\n\n    case TARGET_NR_creat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(creat(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_link:\n\n        {\n\n            void * p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(link(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_linkat) && defined(__NR_linkat)\n\n    case TARGET_NR_linkat:\n\n        {\n\n            void * p2 = NULL;\n\n            if (!arg2 || !arg4)\n\n                goto efault;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user_string(arg4);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_linkat(arg1, p, arg3, p2, arg5));\n\n            unlock_user(p, arg2, 0);\n\n            unlock_user(p2, arg4, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_unlink:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(unlink(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_unlinkat) && defined(__NR_unlinkat)\n\n    case TARGET_NR_unlinkat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_unlinkat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_execve:\n\n        {\n\n            char **argp, **envp;\n\n            int argc, envc;\n\n            abi_ulong gp;\n\n            abi_ulong guest_argp;\n\n            abi_ulong guest_envp;\n\n            abi_ulong addr;\n\n            char **q;\n\n\n\n            argc = 0;\n\n            guest_argp = arg2;\n\n            for (gp = guest_argp; gp; gp += sizeof(abi_ulong)) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto efault;\n\n                if (!addr)\n\n                    break;\n\n                argc++;\n\n            }\n\n            envc = 0;\n\n            guest_envp = arg3;\n\n            for (gp = guest_envp; gp; gp += sizeof(abi_ulong)) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto efault;\n\n                if (!addr)\n\n                    break;\n\n                envc++;\n\n            }\n\n\n\n            argp = alloca((argc + 1) * sizeof(void *));\n\n            envp = alloca((envc + 1) * sizeof(void *));\n\n\n\n            for (gp = guest_argp, q = argp; gp;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto execve_efault;\n\n                if (!addr)\n\n                    break;\n\n                if (!(*q = lock_user_string(addr)))\n\n                    goto execve_efault;\n\n            }\n\n            *q = NULL;\n\n\n\n            for (gp = guest_envp, q = envp; gp;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto execve_efault;\n\n                if (!addr)\n\n                    break;\n\n                if (!(*q = lock_user_string(addr)))\n\n                    goto execve_efault;\n\n            }\n\n            *q = NULL;\n\n\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto execve_efault;\n\n            ret = get_errno(execve(p, argp, envp));\n\n            unlock_user(p, arg1, 0);\n\n\n\n            goto execve_end;\n\n\n\n        execve_efault:\n\n            ret = -TARGET_EFAULT;\n\n\n\n        execve_end:\n\n            for (gp = guest_argp, q = argp; *q;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp)\n\n                    || !addr)\n\n                    break;\n\n                unlock_user(*q, addr, 0);\n\n            }\n\n            for (gp = guest_envp, q = envp; *q;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp)\n\n                    || !addr)\n\n                    break;\n\n                unlock_user(*q, addr, 0);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_chdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chdir(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_time\n\n    case TARGET_NR_time:\n\n        {\n\n            time_t host_time;\n\n            ret = get_errno(time(&host_time));\n\n            if (!is_error(ret)\n\n                && arg1\n\n                && put_user_sal(host_time, arg1))\n\n                goto efault;\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_mknod:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(mknod(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_mknodat) && defined(__NR_mknodat)\n\n    case TARGET_NR_mknodat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_mknodat(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_chmod:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chmod(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_break\n\n    case TARGET_NR_break:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_oldstat\n\n    case TARGET_NR_oldstat:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_lseek:\n\n        ret = get_errno(lseek(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_getxpid\n\n    case TARGET_NR_getxpid:\n\n#else\n\n    case TARGET_NR_getpid:\n\n#endif\n\n        ret = get_errno(getpid());\n\n        break;\n\n    case TARGET_NR_mount:\n\n\t\t{\n\n\t\t\t/* need to look at the data field */\n\n\t\t\tvoid *p2, *p3;\n\n\t\t\tp = lock_user_string(arg1);\n\n\t\t\tp2 = lock_user_string(arg2);\n\n\t\t\tp3 = lock_user_string(arg3);\n\n                        if (!p || !p2 || !p3)\n\n                            ret = -TARGET_EFAULT;\n\n                        else {\n\n                            /* FIXME - arg5 should be locked, but it isn't clear how to\n\n                             * do that since it's not guaranteed to be a NULL-terminated\n\n                             * string.\n\n                             */\n\n                            if ( ! arg5 )\n\n                                ret = get_errno(mount(p, p2, p3, (unsigned long)arg4, NULL));\n\n                            else\n\n                                ret = get_errno(mount(p, p2, p3, (unsigned long)arg4, g2h(arg5)));\n\n                        }\n\n                        unlock_user(p, arg1, 0);\n\n                        unlock_user(p2, arg2, 0);\n\n                        unlock_user(p3, arg3, 0);\n\n\t\t\tbreak;\n\n\t\t}\n\n#ifdef TARGET_NR_umount\n\n    case TARGET_NR_umount:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(umount(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_stime /* not on alpha */\n\n    case TARGET_NR_stime:\n\n        {\n\n            time_t host_time;\n\n            if (get_user_sal(host_time, arg1))\n\n                goto efault;\n\n            ret = get_errno(stime(&host_time));\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_ptrace:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_alarm /* not on alpha */\n\n    case TARGET_NR_alarm:\n\n        ret = alarm(arg1);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_oldfstat\n\n    case TARGET_NR_oldfstat:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_pause /* not on alpha */\n\n    case TARGET_NR_pause:\n\n        ret = get_errno(pause());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_utime\n\n    case TARGET_NR_utime:\n\n        {\n\n            struct utimbuf tbuf, *host_tbuf;\n\n            struct target_utimbuf *target_tbuf;\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, target_tbuf, arg2, 1))\n\n                    goto efault;\n\n                tbuf.actime = tswapl(target_tbuf->actime);\n\n                tbuf.modtime = tswapl(target_tbuf->modtime);\n\n                unlock_user_struct(target_tbuf, arg2, 0);\n\n                host_tbuf = &tbuf;\n\n            } else {\n\n                host_tbuf = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(utime(p, host_tbuf));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_utimes:\n\n        {\n\n            struct timeval *tvp, tv[2];\n\n            if (arg2) {\n\n                if (copy_from_user_timeval(&tv[0], arg2)\n\n                    || copy_from_user_timeval(&tv[1],\n\n                                              arg2 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n                tvp = tv;\n\n            } else {\n\n                tvp = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(utimes(p, tvp));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_futimesat) && defined(__NR_futimesat)\n\n    case TARGET_NR_futimesat:\n\n        {\n\n            struct timeval *tvp, tv[2];\n\n            if (arg3) {\n\n                if (copy_from_user_timeval(&tv[0], arg3)\n\n                    || copy_from_user_timeval(&tv[1],\n\n                                              arg3 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n                tvp = tv;\n\n            } else {\n\n                tvp = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg2)))\n\n                goto efault;\n\n            ret = get_errno(sys_futimesat(arg1, path(p), tvp));\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_stty\n\n    case TARGET_NR_stty:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_gtty\n\n    case TARGET_NR_gtty:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_access:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(access(path(p), arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_faccessat) && defined(__NR_faccessat)\n\n    case TARGET_NR_faccessat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_faccessat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_nice /* not on alpha */\n\n    case TARGET_NR_nice:\n\n        ret = get_errno(nice(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ftime\n\n    case TARGET_NR_ftime:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sync:\n\n        sync();\n\n        ret = 0;\n\n        break;\n\n    case TARGET_NR_kill:\n\n        ret = get_errno(kill(arg1, target_to_host_signal(arg2)));\n\n        break;\n\n    case TARGET_NR_rename:\n\n        {\n\n            void *p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(rename(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_renameat) && defined(__NR_renameat)\n\n    case TARGET_NR_renameat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user_string(arg4);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_renameat(arg1, p, arg3, p2));\n\n            unlock_user(p2, arg4, 0);\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_mkdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(mkdir(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_mkdirat) && defined(__NR_mkdirat)\n\n    case TARGET_NR_mkdirat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_mkdirat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_rmdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(rmdir(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_dup:\n\n        ret = get_errno(dup(arg1));\n\n        break;\n\n    case TARGET_NR_pipe:\n\n        ret = do_pipe(cpu_env, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_pipe2\n\n    case TARGET_NR_pipe2:\n\n        ret = do_pipe(cpu_env, arg1, arg2);\n\n        break;\n\n#endif\n\n    case TARGET_NR_times:\n\n        {\n\n            struct target_tms *tmsp;\n\n            struct tms tms;\n\n            ret = get_errno(times(&tms));\n\n            if (arg1) {\n\n                tmsp = lock_user(VERIFY_WRITE, arg1, sizeof(struct target_tms), 0);\n\n                if (!tmsp)\n\n                    goto efault;\n\n                tmsp->tms_utime = tswapl(host_to_target_clock_t(tms.tms_utime));\n\n                tmsp->tms_stime = tswapl(host_to_target_clock_t(tms.tms_stime));\n\n                tmsp->tms_cutime = tswapl(host_to_target_clock_t(tms.tms_cutime));\n\n                tmsp->tms_cstime = tswapl(host_to_target_clock_t(tms.tms_cstime));\n\n            }\n\n            if (!is_error(ret))\n\n                ret = host_to_target_clock_t(ret);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_prof\n\n    case TARGET_NR_prof:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_signal\n\n    case TARGET_NR_signal:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_acct:\n\n        if (arg1 == 0) {\n\n            ret = get_errno(acct(NULL));\n\n        } else {\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(acct(path(p)));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_umount2 /* not on alpha */\n\n    case TARGET_NR_umount2:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(umount2(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_lock\n\n    case TARGET_NR_lock:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_ioctl:\n\n        ret = do_ioctl(arg1, arg2, arg3);\n\n        break;\n\n    case TARGET_NR_fcntl:\n\n        ret = do_fcntl(arg1, arg2, arg3);\n\n        break;\n\n#ifdef TARGET_NR_mpx\n\n    case TARGET_NR_mpx:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_setpgid:\n\n        ret = get_errno(setpgid(arg1, arg2));\n\n        break;\n\n#ifdef TARGET_NR_ulimit\n\n    case TARGET_NR_ulimit:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_oldolduname\n\n    case TARGET_NR_oldolduname:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_umask:\n\n        ret = get_errno(umask(arg1));\n\n        break;\n\n    case TARGET_NR_chroot:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chroot(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_ustat:\n\n        goto unimplemented;\n\n    case TARGET_NR_dup2:\n\n        ret = get_errno(dup2(arg1, arg2));\n\n        break;\n\n#if defined(CONFIG_DUP3) && defined(TARGET_NR_dup3)\n\n    case TARGET_NR_dup3:\n\n        ret = get_errno(dup3(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getppid /* not on alpha */\n\n    case TARGET_NR_getppid:\n\n        ret = get_errno(getppid());\n\n        break;\n\n#endif\n\n    case TARGET_NR_getpgrp:\n\n        ret = get_errno(getpgrp());\n\n        break;\n\n    case TARGET_NR_setsid:\n\n        ret = get_errno(setsid());\n\n        break;\n\n#ifdef TARGET_NR_sigaction\n\n    case TARGET_NR_sigaction:\n\n        {\n\n#if !defined(TARGET_MIPS)\n\n            struct target_old_sigaction *old_act;\n\n            struct target_sigaction act, oact, *pact;\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n\n                    goto efault;\n\n                act._sa_handler = old_act->_sa_handler;\n\n                target_siginitset(&act.sa_mask, old_act->sa_mask);\n\n                act.sa_flags = old_act->sa_flags;\n\n                act.sa_restorer = old_act->sa_restorer;\n\n                unlock_user_struct(old_act, arg2, 0);\n\n                pact = &act;\n\n            } else {\n\n                pact = NULL;\n\n            }\n\n            ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n\n                    goto efault;\n\n                old_act->_sa_handler = oact._sa_handler;\n\n                old_act->sa_mask = oact.sa_mask.sig[0];\n\n                old_act->sa_flags = oact.sa_flags;\n\n                old_act->sa_restorer = oact.sa_restorer;\n\n                unlock_user_struct(old_act, arg3, 1);\n\n            }\n\n#else\n\n\t    struct target_sigaction act, oact, *pact, *old_act;\n\n\n\n\t    if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n\n                    goto efault;\n\n\t\tact._sa_handler = old_act->_sa_handler;\n\n\t\ttarget_siginitset(&act.sa_mask, old_act->sa_mask.sig[0]);\n\n\t\tact.sa_flags = old_act->sa_flags;\n\n\t\tunlock_user_struct(old_act, arg2, 0);\n\n\t\tpact = &act;\n\n\t    } else {\n\n\t\tpact = NULL;\n\n\t    }\n\n\n\n\t    ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n\n\n\t    if (!is_error(ret) && arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n\n                    goto efault;\n\n\t\told_act->_sa_handler = oact._sa_handler;\n\n\t\told_act->sa_flags = oact.sa_flags;\n\n\t\told_act->sa_mask.sig[0] = oact.sa_mask.sig[0];\n\n\t\told_act->sa_mask.sig[1] = 0;\n\n\t\told_act->sa_mask.sig[2] = 0;\n\n\t\told_act->sa_mask.sig[3] = 0;\n\n\t\tunlock_user_struct(old_act, arg3, 1);\n\n\t    }\n\n#endif\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigaction:\n\n        {\n\n            struct target_sigaction *act;\n\n            struct target_sigaction *oact;\n\n\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, act, arg2, 1))\n\n                    goto efault;\n\n            } else\n\n                act = NULL;\n\n            if (arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, oact, arg3, 0)) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto rt_sigaction_fail;\n\n                }\n\n            } else\n\n                oact = NULL;\n\n            ret = get_errno(do_sigaction(arg1, act, oact));\n\n\trt_sigaction_fail:\n\n            if (act)\n\n                unlock_user_struct(act, arg2, 0);\n\n            if (oact)\n\n                unlock_user_struct(oact, arg3, 1);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sgetmask /* not on alpha */\n\n    case TARGET_NR_sgetmask:\n\n        {\n\n            sigset_t cur_set;\n\n            abi_ulong target_set;\n\n            sigprocmask(0, NULL, &cur_set);\n\n            host_to_target_old_sigset(&target_set, &cur_set);\n\n            ret = target_set;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ssetmask /* not on alpha */\n\n    case TARGET_NR_ssetmask:\n\n        {\n\n            sigset_t set, oset, cur_set;\n\n            abi_ulong target_set = arg1;\n\n            sigprocmask(0, NULL, &cur_set);\n\n            target_to_host_old_sigset(&set, &target_set);\n\n            sigorset(&set, &set, &cur_set);\n\n            sigprocmask(SIG_SETMASK, &set, &oset);\n\n            host_to_target_old_sigset(&target_set, &oset);\n\n            ret = target_set;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sigprocmask\n\n    case TARGET_NR_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n\n\n            if (arg2) {\n\n                switch(how) {\n\n                case TARGET_SIG_BLOCK:\n\n                    how = SIG_BLOCK;\n\n                    break;\n\n                case TARGET_SIG_UNBLOCK:\n\n                    how = SIG_UNBLOCK;\n\n                    break;\n\n                case TARGET_SIG_SETMASK:\n\n                    how = SIG_SETMASK;\n\n                    break;\n\n                default:\n\n                    ret = -TARGET_EINVAL;\n\n                    goto fail;\n\n                }\n\n                if (!(p = lock_user(VERIFY_READ, arg2, sizeof(target_sigset_t), 1)))\n\n                    goto efault;\n\n                target_to_host_old_sigset(&set, p);\n\n                unlock_user(p, arg2, 0);\n\n                set_ptr = &set;\n\n            } else {\n\n                how = 0;\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(arg1, set_ptr, &oldset));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_old_sigset(p, &oldset);\n\n                unlock_user(p, arg3, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n\n\n            if (arg2) {\n\n                switch(how) {\n\n                case TARGET_SIG_BLOCK:\n\n                    how = SIG_BLOCK;\n\n                    break;\n\n                case TARGET_SIG_UNBLOCK:\n\n                    how = SIG_UNBLOCK;\n\n                    break;\n\n                case TARGET_SIG_SETMASK:\n\n                    how = SIG_SETMASK;\n\n                    break;\n\n                default:\n\n                    ret = -TARGET_EINVAL;\n\n                    goto fail;\n\n                }\n\n                if (!(p = lock_user(VERIFY_READ, arg2, sizeof(target_sigset_t), 1)))\n\n                    goto efault;\n\n                target_to_host_sigset(&set, p);\n\n                unlock_user(p, arg2, 0);\n\n                set_ptr = &set;\n\n            } else {\n\n                how = 0;\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(how, set_ptr, &oldset));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_sigset(p, &oldset);\n\n                unlock_user(p, arg3, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigpending\n\n    case TARGET_NR_sigpending:\n\n        {\n\n            sigset_t set;\n\n            ret = get_errno(sigpending(&set));\n\n            if (!is_error(ret)) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg1, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_old_sigset(p, &set);\n\n                unlock_user(p, arg1, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigpending:\n\n        {\n\n            sigset_t set;\n\n            ret = get_errno(sigpending(&set));\n\n            if (!is_error(ret)) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg1, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_sigset(p, &set);\n\n                unlock_user(p, arg1, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigsuspend\n\n    case TARGET_NR_sigsuspend:\n\n        {\n\n            sigset_t set;\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_old_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sigsuspend(&set));\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigsuspend:\n\n        {\n\n            sigset_t set;\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sigsuspend(&set));\n\n        }\n\n        break;\n\n    case TARGET_NR_rt_sigtimedwait:\n\n        {\n\n            sigset_t set;\n\n            struct timespec uts, *puts;\n\n            siginfo_t uinfo;\n\n\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            if (arg3) {\n\n                puts = &uts;\n\n                target_to_host_timespec(puts, arg3);\n\n            } else {\n\n                puts = NULL;\n\n            }\n\n            ret = get_errno(sigtimedwait(&set, &uinfo, puts));\n\n            if (!is_error(ret) && arg2) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg2, sizeof(target_siginfo_t), 0)))\n\n                    goto efault;\n\n                host_to_target_siginfo(p, &uinfo);\n\n                unlock_user(p, arg2, sizeof(target_siginfo_t));\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_rt_sigqueueinfo:\n\n        {\n\n            siginfo_t uinfo;\n\n            if (!(p = lock_user(VERIFY_READ, arg3, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_siginfo(&uinfo, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sys_rt_sigqueueinfo(arg1, arg2, &uinfo));\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigreturn\n\n    case TARGET_NR_sigreturn:\n\n        /* NOTE: ret is eax, so not transcoding must be done */\n\n        ret = do_sigreturn(cpu_env);\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigreturn:\n\n        /* NOTE: ret is eax, so not transcoding must be done */\n\n        ret = do_rt_sigreturn(cpu_env);\n\n        break;\n\n    case TARGET_NR_sethostname:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(sethostname(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_setrlimit:\n\n        {\n\n            /* XXX: convert resource ? */\n\n            int resource = arg1;\n\n            struct target_rlimit *target_rlim;\n\n            struct rlimit rlim;\n\n            if (!lock_user_struct(VERIFY_READ, target_rlim, arg2, 1))\n\n                goto efault;\n\n            rlim.rlim_cur = tswapl(target_rlim->rlim_cur);\n\n            rlim.rlim_max = tswapl(target_rlim->rlim_max);\n\n            unlock_user_struct(target_rlim, arg2, 0);\n\n            ret = get_errno(setrlimit(resource, &rlim));\n\n        }\n\n        break;\n\n    case TARGET_NR_getrlimit:\n\n        {\n\n            /* XXX: convert resource ? */\n\n            int resource = arg1;\n\n            struct target_rlimit *target_rlim;\n\n            struct rlimit rlim;\n\n\n\n            ret = get_errno(getrlimit(resource, &rlim));\n\n            if (!is_error(ret)) {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))\n\n                    goto efault;\n\n                target_rlim->rlim_cur = tswapl(rlim.rlim_cur);\n\n                target_rlim->rlim_max = tswapl(rlim.rlim_max);\n\n                unlock_user_struct(target_rlim, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_getrusage:\n\n        {\n\n            struct rusage rusage;\n\n            ret = get_errno(getrusage(arg1, &rusage));\n\n            if (!is_error(ret)) {\n\n                host_to_target_rusage(arg2, &rusage);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_gettimeofday:\n\n        {\n\n            struct timeval tv;\n\n            ret = get_errno(gettimeofday(&tv, NULL));\n\n            if (!is_error(ret)) {\n\n                if (copy_to_user_timeval(arg1, &tv))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_settimeofday:\n\n        {\n\n            struct timeval tv;\n\n            if (copy_from_user_timeval(&tv, arg1))\n\n                goto efault;\n\n            ret = get_errno(settimeofday(&tv, NULL));\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_select\n\n    case TARGET_NR_select:\n\n        {\n\n            struct target_sel_arg_struct *sel;\n\n            abi_ulong inp, outp, exp, tvp;\n\n            long nsel;\n\n\n\n            if (!lock_user_struct(VERIFY_READ, sel, arg1, 1))\n\n                goto efault;\n\n            nsel = tswapl(sel->n);\n\n            inp = tswapl(sel->inp);\n\n            outp = tswapl(sel->outp);\n\n            exp = tswapl(sel->exp);\n\n            tvp = tswapl(sel->tvp);\n\n            unlock_user_struct(sel, arg1, 0);\n\n            ret = do_select(nsel, inp, outp, exp, tvp);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_symlink:\n\n        {\n\n            void *p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(symlink(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_symlinkat) && defined(__NR_symlinkat)\n\n    case TARGET_NR_symlinkat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg3);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_symlinkat(p, arg2, p2));\n\n            unlock_user(p2, arg3, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_oldlstat\n\n    case TARGET_NR_oldlstat:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_readlink:\n\n        {\n\n            void *p2, *temp;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user(VERIFY_WRITE, arg2, arg3, 0);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else {\n\n                if (strncmp((const char *)p, \"/proc/self/exe\", 14) == 0) {\n\n                    char real[PATH_MAX];\n\n                    temp = realpath(exec_path,real);\n\n                    ret = (temp==NULL) ? get_errno(-1) : strlen(real) ;\n\n                    snprintf((char *)p2, arg3, \"%s\", real);\n\n                    }\n\n                else\n\n                    ret = get_errno(readlink(path(p), p2, arg3));\n\n            }\n\n            unlock_user(p2, arg2, ret);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_readlinkat) && defined(__NR_readlinkat)\n\n    case TARGET_NR_readlinkat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user(VERIFY_WRITE, arg3, arg4, 0);\n\n            if (!p || !p2)\n\n        \tret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_readlinkat(arg1, path(p), p2, arg4));\n\n            unlock_user(p2, arg3, ret);\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_uselib\n\n    case TARGET_NR_uselib:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_swapon\n\n    case TARGET_NR_swapon:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(swapon(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_reboot:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_readdir\n\n    case TARGET_NR_readdir:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_mmap\n\n    case TARGET_NR_mmap:\n\n#if (defined(TARGET_I386) && defined(TARGET_ABI32)) || defined(TARGET_ARM) || defined(TARGET_M68K) || defined(TARGET_CRIS) || defined(TARGET_MICROBLAZE)\n\n        {\n\n            abi_ulong *v;\n\n            abi_ulong v1, v2, v3, v4, v5, v6;\n\n            if (!(v = lock_user(VERIFY_READ, arg1, 6 * sizeof(abi_ulong), 1)))\n\n                goto efault;\n\n            v1 = tswapl(v[0]);\n\n            v2 = tswapl(v[1]);\n\n            v3 = tswapl(v[2]);\n\n            v4 = tswapl(v[3]);\n\n            v5 = tswapl(v[4]);\n\n            v6 = tswapl(v[5]);\n\n            unlock_user(v, arg1, 0);\n\n            ret = get_errno(target_mmap(v1, v2, v3,\n\n                                        target_to_host_bitmask(v4, mmap_flags_tbl),\n\n                                        v5, v6));\n\n        }\n\n#else\n\n        ret = get_errno(target_mmap(arg1, arg2, arg3,\n\n                                    target_to_host_bitmask(arg4, mmap_flags_tbl),\n\n                                    arg5,\n\n                                    arg6));\n\n#endif\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mmap2\n\n    case TARGET_NR_mmap2:\n\n#ifndef MMAP_SHIFT\n\n#define MMAP_SHIFT 12\n\n#endif\n\n        ret = get_errno(target_mmap(arg1, arg2, arg3,\n\n                                    target_to_host_bitmask(arg4, mmap_flags_tbl),\n\n                                    arg5,\n\n                                    arg6 << MMAP_SHIFT));\n\n        break;\n\n#endif\n\n    case TARGET_NR_munmap:\n\n        ret = get_errno(target_munmap(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_mprotect:\n\n        ret = get_errno(target_mprotect(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_mremap\n\n    case TARGET_NR_mremap:\n\n        ret = get_errno(target_mremap(arg1, arg2, arg3, arg4, arg5));\n\n        break;\n\n#endif\n\n        /* ??? msync/mlock/munlock are broken for softmmu.  */\n\n#ifdef TARGET_NR_msync\n\n    case TARGET_NR_msync:\n\n        ret = get_errno(msync(g2h(arg1), arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mlock\n\n    case TARGET_NR_mlock:\n\n        ret = get_errno(mlock(g2h(arg1), arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_munlock\n\n    case TARGET_NR_munlock:\n\n        ret = get_errno(munlock(g2h(arg1), arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mlockall\n\n    case TARGET_NR_mlockall:\n\n        ret = get_errno(mlockall(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_munlockall\n\n    case TARGET_NR_munlockall:\n\n        ret = get_errno(munlockall());\n\n        break;\n\n#endif\n\n    case TARGET_NR_truncate:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(truncate(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_ftruncate:\n\n        ret = get_errno(ftruncate(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchmod:\n\n        ret = get_errno(fchmod(arg1, arg2));\n\n        break;\n\n#if defined(TARGET_NR_fchmodat) && defined(__NR_fchmodat)\n\n    case TARGET_NR_fchmodat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_fchmodat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_getpriority:\n\n        /* libc does special remapping of the return value of\n\n         * sys_getpriority() so it's just easiest to call\n\n         * sys_getpriority() directly rather than through libc. */\n\n        ret = get_errno(sys_getpriority(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setpriority:\n\n        ret = get_errno(setpriority(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_profil\n\n    case TARGET_NR_profil:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_statfs:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(statfs(path(p), &stfs));\n\n        unlock_user(p, arg1, 0);\n\n    convert_statfs:\n\n        if (!is_error(ret)) {\n\n            struct target_statfs *target_stfs;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg2, 0))\n\n                goto efault;\n\n            __put_user(stfs.f_type, &target_stfs->f_type);\n\n            __put_user(stfs.f_bsize, &target_stfs->f_bsize);\n\n            __put_user(stfs.f_blocks, &target_stfs->f_blocks);\n\n            __put_user(stfs.f_bfree, &target_stfs->f_bfree);\n\n            __put_user(stfs.f_bavail, &target_stfs->f_bavail);\n\n            __put_user(stfs.f_files, &target_stfs->f_files);\n\n            __put_user(stfs.f_ffree, &target_stfs->f_ffree);\n\n            __put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);\n\n            __put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);\n\n            __put_user(stfs.f_namelen, &target_stfs->f_namelen);\n\n            unlock_user_struct(target_stfs, arg2, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs:\n\n        ret = get_errno(fstatfs(arg1, &stfs));\n\n        goto convert_statfs;\n\n#ifdef TARGET_NR_statfs64\n\n    case TARGET_NR_statfs64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(statfs(path(p), &stfs));\n\n        unlock_user(p, arg1, 0);\n\n    convert_statfs64:\n\n        if (!is_error(ret)) {\n\n            struct target_statfs64 *target_stfs;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg3, 0))\n\n                goto efault;\n\n            __put_user(stfs.f_type, &target_stfs->f_type);\n\n            __put_user(stfs.f_bsize, &target_stfs->f_bsize);\n\n            __put_user(stfs.f_blocks, &target_stfs->f_blocks);\n\n            __put_user(stfs.f_bfree, &target_stfs->f_bfree);\n\n            __put_user(stfs.f_bavail, &target_stfs->f_bavail);\n\n            __put_user(stfs.f_files, &target_stfs->f_files);\n\n            __put_user(stfs.f_ffree, &target_stfs->f_ffree);\n\n            __put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);\n\n            __put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);\n\n            __put_user(stfs.f_namelen, &target_stfs->f_namelen);\n\n            unlock_user_struct(target_stfs, arg3, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs64:\n\n        ret = get_errno(fstatfs(arg1, &stfs));\n\n        goto convert_statfs64;\n\n#endif\n\n#ifdef TARGET_NR_ioperm\n\n    case TARGET_NR_ioperm:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_socketcall\n\n    case TARGET_NR_socketcall:\n\n        ret = do_socketcall(arg1, arg2);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_accept\n\n    case TARGET_NR_accept:\n\n        ret = do_accept(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_bind\n\n    case TARGET_NR_bind:\n\n        ret = do_bind(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_connect\n\n    case TARGET_NR_connect:\n\n        ret = do_connect(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getpeername\n\n    case TARGET_NR_getpeername:\n\n        ret = do_getpeername(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getsockname\n\n    case TARGET_NR_getsockname:\n\n        ret = do_getsockname(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getsockopt\n\n    case TARGET_NR_getsockopt:\n\n        ret = do_getsockopt(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_listen\n\n    case TARGET_NR_listen:\n\n        ret = get_errno(listen(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recv\n\n    case TARGET_NR_recv:\n\n        ret = do_recvfrom(arg1, arg2, arg3, arg4, 0, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recvfrom\n\n    case TARGET_NR_recvfrom:\n\n        ret = do_recvfrom(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recvmsg\n\n    case TARGET_NR_recvmsg:\n\n        ret = do_sendrecvmsg(arg1, arg2, arg3, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_send\n\n    case TARGET_NR_send:\n\n        ret = do_sendto(arg1, arg2, arg3, arg4, 0, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sendmsg\n\n    case TARGET_NR_sendmsg:\n\n        ret = do_sendrecvmsg(arg1, arg2, arg3, 1);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sendto\n\n    case TARGET_NR_sendto:\n\n        ret = do_sendto(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shutdown\n\n    case TARGET_NR_shutdown:\n\n        ret = get_errno(shutdown(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_socket\n\n    case TARGET_NR_socket:\n\n        ret = do_socket(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_socketpair\n\n    case TARGET_NR_socketpair:\n\n        ret = do_socketpair(arg1, arg2, arg3, arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setsockopt\n\n    case TARGET_NR_setsockopt:\n\n        ret = do_setsockopt(arg1, arg2, arg3, arg4, (socklen_t) arg5);\n\n        break;\n\n#endif\n\n\n\n    case TARGET_NR_syslog:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_syslog((int)arg1, p, (int)arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n\n\n    case TARGET_NR_setitimer:\n\n        {\n\n            struct itimerval value, ovalue, *pvalue;\n\n\n\n            if (arg2) {\n\n                pvalue = &value;\n\n                if (copy_from_user_timeval(&pvalue->it_interval, arg2)\n\n                    || copy_from_user_timeval(&pvalue->it_value,\n\n                                              arg2 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n            } else {\n\n                pvalue = NULL;\n\n            }\n\n            ret = get_errno(setitimer(arg1, pvalue, &ovalue));\n\n            if (!is_error(ret) && arg3) {\n\n                if (copy_to_user_timeval(arg3,\n\n                                         &ovalue.it_interval)\n\n                    || copy_to_user_timeval(arg3 + sizeof(struct target_timeval),\n\n                                            &ovalue.it_value))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_getitimer:\n\n        {\n\n            struct itimerval value;\n\n\n\n            ret = get_errno(getitimer(arg1, &value));\n\n            if (!is_error(ret) && arg2) {\n\n                if (copy_to_user_timeval(arg2,\n\n                                         &value.it_interval)\n\n                    || copy_to_user_timeval(arg2 + sizeof(struct target_timeval),\n\n                                            &value.it_value))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_stat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(stat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        goto do_stat;\n\n    case TARGET_NR_lstat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lstat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        goto do_stat;\n\n    case TARGET_NR_fstat:\n\n        {\n\n            ret = get_errno(fstat(arg1, &st));\n\n        do_stat:\n\n            if (!is_error(ret)) {\n\n                struct target_stat *target_st;\n\n\n\n                if (!lock_user_struct(VERIFY_WRITE, target_st, arg2, 0))\n\n                    goto efault;\n\n                memset(target_st, 0, sizeof(*target_st));\n\n                __put_user(st.st_dev, &target_st->st_dev);\n\n                __put_user(st.st_ino, &target_st->st_ino);\n\n                __put_user(st.st_mode, &target_st->st_mode);\n\n                __put_user(st.st_uid, &target_st->st_uid);\n\n                __put_user(st.st_gid, &target_st->st_gid);\n\n                __put_user(st.st_nlink, &target_st->st_nlink);\n\n                __put_user(st.st_rdev, &target_st->st_rdev);\n\n                __put_user(st.st_size, &target_st->st_size);\n\n                __put_user(st.st_blksize, &target_st->st_blksize);\n\n                __put_user(st.st_blocks, &target_st->st_blocks);\n\n                __put_user(st.st_atime, &target_st->target_st_atime);\n\n                __put_user(st.st_mtime, &target_st->target_st_mtime);\n\n                __put_user(st.st_ctime, &target_st->target_st_ctime);\n\n                unlock_user_struct(target_st, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_olduname\n\n    case TARGET_NR_olduname:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_iopl\n\n    case TARGET_NR_iopl:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_vhangup:\n\n        ret = get_errno(vhangup());\n\n        break;\n\n#ifdef TARGET_NR_idle\n\n    case TARGET_NR_idle:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_syscall\n\n    case TARGET_NR_syscall:\n\n    \tret = do_syscall(cpu_env,arg1 & 0xffff,arg2,arg3,arg4,arg5,arg6,0);\n\n    \tbreak;\n\n#endif\n\n    case TARGET_NR_wait4:\n\n        {\n\n            int status;\n\n            abi_long status_ptr = arg2;\n\n            struct rusage rusage, *rusage_ptr;\n\n            abi_ulong target_rusage = arg4;\n\n            if (target_rusage)\n\n                rusage_ptr = &rusage;\n\n            else\n\n                rusage_ptr = NULL;\n\n            ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr));\n\n            if (!is_error(ret)) {\n\n                if (status_ptr) {\n\n                    status = host_to_target_waitstatus(status);\n\n                    if (put_user_s32(status, status_ptr))\n\n                        goto efault;\n\n                }\n\n                if (target_rusage)\n\n                    host_to_target_rusage(target_rusage, &rusage);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_swapoff\n\n    case TARGET_NR_swapoff:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(swapoff(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_sysinfo:\n\n        {\n\n            struct target_sysinfo *target_value;\n\n            struct sysinfo value;\n\n            ret = get_errno(sysinfo(&value));\n\n            if (!is_error(ret) && arg1)\n\n            {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_value, arg1, 0))\n\n                    goto efault;\n\n                __put_user(value.uptime, &target_value->uptime);\n\n                __put_user(value.loads[0], &target_value->loads[0]);\n\n                __put_user(value.loads[1], &target_value->loads[1]);\n\n                __put_user(value.loads[2], &target_value->loads[2]);\n\n                __put_user(value.totalram, &target_value->totalram);\n\n                __put_user(value.freeram, &target_value->freeram);\n\n                __put_user(value.sharedram, &target_value->sharedram);\n\n                __put_user(value.bufferram, &target_value->bufferram);\n\n                __put_user(value.totalswap, &target_value->totalswap);\n\n                __put_user(value.freeswap, &target_value->freeswap);\n\n                __put_user(value.procs, &target_value->procs);\n\n                __put_user(value.totalhigh, &target_value->totalhigh);\n\n                __put_user(value.freehigh, &target_value->freehigh);\n\n                __put_user(value.mem_unit, &target_value->mem_unit);\n\n                unlock_user_struct(target_value, arg1, 1);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_ipc\n\n    case TARGET_NR_ipc:\n\n\tret = do_ipc(arg1, arg2, arg3, arg4, arg5, arg6);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_semget\n\n    case TARGET_NR_semget:\n\n        ret = get_errno(semget(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_semop\n\n    case TARGET_NR_semop:\n\n        ret = get_errno(do_semop(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_semctl\n\n    case TARGET_NR_semctl:\n\n        ret = do_semctl(arg1, arg2, arg3, (union target_semun)(abi_ulong)arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgctl\n\n    case TARGET_NR_msgctl:\n\n        ret = do_msgctl(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgget\n\n    case TARGET_NR_msgget:\n\n        ret = get_errno(msgget(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgrcv\n\n    case TARGET_NR_msgrcv:\n\n        ret = do_msgrcv(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgsnd\n\n    case TARGET_NR_msgsnd:\n\n        ret = do_msgsnd(arg1, arg2, arg3, arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmget\n\n    case TARGET_NR_shmget:\n\n        ret = get_errno(shmget(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmctl\n\n    case TARGET_NR_shmctl:\n\n        ret = do_shmctl(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmat\n\n    case TARGET_NR_shmat:\n\n        ret = do_shmat(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmdt\n\n    case TARGET_NR_shmdt:\n\n        ret = do_shmdt(arg1);\n\n        break;\n\n#endif\n\n    case TARGET_NR_fsync:\n\n        ret = get_errno(fsync(arg1));\n\n        break;\n\n    case TARGET_NR_clone:\n\n#if defined(TARGET_SH4)\n\n        ret = get_errno(do_fork(cpu_env, arg1, arg2, arg3, arg5, arg4));\n\n#elif defined(TARGET_CRIS)\n\n        ret = get_errno(do_fork(cpu_env, arg2, arg1, arg3, arg4, arg5));\n\n#else\n\n        ret = get_errno(do_fork(cpu_env, arg1, arg2, arg3, arg4, arg5));\n\n#endif\n\n        break;\n\n#ifdef __NR_exit_group\n\n        /* new thread calls */\n\n    case TARGET_NR_exit_group:\n\n#ifdef TARGET_GPROF\n\n        _mcleanup();\n\n#endif\n\n        gdb_exit(cpu_env, arg1);\n\n        ret = get_errno(exit_group(arg1));\n\n        break;\n\n#endif\n\n    case TARGET_NR_setdomainname:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(setdomainname(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_uname:\n\n        /* no need to transcode because we use the linux syscall */\n\n        {\n\n            struct new_utsname * buf;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, buf, arg1, 0))\n\n                goto efault;\n\n            ret = get_errno(sys_uname(buf));\n\n            if (!is_error(ret)) {\n\n                /* Overrite the native machine name with whatever is being\n\n                   emulated. */\n\n                strcpy (buf->machine, cpu_to_uname_machine(cpu_env));\n\n                /* Allow the user to override the reported release.  */\n\n                if (qemu_uname_release && *qemu_uname_release)\n\n                  strcpy (buf->release, qemu_uname_release);\n\n            }\n\n            unlock_user_struct(buf, arg1, 1);\n\n        }\n\n        break;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_modify_ldt:\n\n        ret = do_modify_ldt(cpu_env, arg1, arg2, arg3);\n\n        break;\n\n#if !defined(TARGET_X86_64)\n\n    case TARGET_NR_vm86old:\n\n        goto unimplemented;\n\n    case TARGET_NR_vm86:\n\n        ret = do_vm86(cpu_env, arg1, arg2);\n\n        break;\n\n#endif\n\n#endif\n\n    case TARGET_NR_adjtimex:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_create_module\n\n    case TARGET_NR_create_module:\n\n#endif\n\n    case TARGET_NR_init_module:\n\n    case TARGET_NR_delete_module:\n\n#ifdef TARGET_NR_get_kernel_syms\n\n    case TARGET_NR_get_kernel_syms:\n\n#endif\n\n        goto unimplemented;\n\n    case TARGET_NR_quotactl:\n\n        goto unimplemented;\n\n    case TARGET_NR_getpgid:\n\n        ret = get_errno(getpgid(arg1));\n\n        break;\n\n    case TARGET_NR_fchdir:\n\n        ret = get_errno(fchdir(arg1));\n\n        break;\n\n#ifdef TARGET_NR_bdflush /* not on x86_64 */\n\n    case TARGET_NR_bdflush:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_sysfs\n\n    case TARGET_NR_sysfs:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_personality:\n\n        ret = get_errno(personality(arg1));\n\n        break;\n\n#ifdef TARGET_NR_afs_syscall\n\n    case TARGET_NR_afs_syscall:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR__llseek /* Not on alpha */\n\n    case TARGET_NR__llseek:\n\n        {\n\n#if defined (__x86_64__)\n\n            ret = get_errno(lseek(arg1, ((uint64_t )arg2 << 32) | arg3, arg5));\n\n            if (put_user_s64(ret, arg4))\n\n                goto efault;\n\n#else\n\n            int64_t res;\n\n            ret = get_errno(_llseek(arg1, arg2, arg3, &res, arg5));\n\n            if (put_user_s64(res, arg4))\n\n                goto efault;\n\n#endif\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_getdents:\n\n#if TARGET_ABI_BITS == 32 && HOST_LONG_BITS == 64\n\n        {\n\n            struct target_dirent *target_dirp;\n\n            struct linux_dirent *dirp;\n\n            abi_long count = arg3;\n\n\n\n\t    dirp = malloc(count);\n\n\t    if (!dirp) {\n\n                ret = -TARGET_ENOMEM;\n\n                goto fail;\n\n            }\n\n\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent *de;\n\n\t\tstruct target_dirent *tde;\n\n                int len = ret;\n\n                int reclen, treclen;\n\n\t\tint count1, tnamelen;\n\n\n\n\t\tcount1 = 0;\n\n                de = dirp;\n\n                if (!(target_dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                    goto efault;\n\n\t\ttde = target_dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n\t\t    treclen = reclen - (2 * (sizeof(long) - sizeof(abi_long)));\n\n                    tde->d_reclen = tswap16(treclen);\n\n                    tde->d_ino = tswapl(de->d_ino);\n\n                    tde->d_off = tswapl(de->d_off);\n\n\t\t    tnamelen = treclen - (2 * sizeof(abi_long) + 2);\n\n\t\t    if (tnamelen > 256)\n\n                        tnamelen = 256;\n\n                    /* XXX: may not be correct */\n\n                    pstrcpy(tde->d_name, tnamelen, de->d_name);\n\n                    de = (struct linux_dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                    tde = (struct target_dirent *)((char *)tde + treclen);\n\n\t\t    count1 += treclen;\n\n                }\n\n\t\tret = count1;\n\n                unlock_user(target_dirp, arg2, ret);\n\n            }\n\n\t    free(dirp);\n\n        }\n\n#else\n\n        {\n\n            struct linux_dirent *dirp;\n\n            abi_long count = arg3;\n\n\n\n            if (!(dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                goto efault;\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = tswap16(reclen);\n\n                    tswapls(&de->d_ino);\n\n                    tswapls(&de->d_off);\n\n                    de = (struct linux_dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n            unlock_user(dirp, arg2, ret);\n\n        }\n\n#endif\n\n        break;\n\n#if defined(TARGET_NR_getdents64) && defined(__NR_getdents64)\n\n    case TARGET_NR_getdents64:\n\n        {\n\n            struct linux_dirent64 *dirp;\n\n            abi_long count = arg3;\n\n            if (!(dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                goto efault;\n\n            ret = get_errno(sys_getdents64(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent64 *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = tswap16(reclen);\n\n                    tswap64s((uint64_t *)&de->d_ino);\n\n                    tswap64s((uint64_t *)&de->d_off);\n\n                    de = (struct linux_dirent64 *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n            unlock_user(dirp, arg2, ret);\n\n        }\n\n        break;\n\n#endif /* TARGET_NR_getdents64 */\n\n#ifdef TARGET_NR__newselect\n\n    case TARGET_NR__newselect:\n\n        ret = do_select(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_poll\n\n    case TARGET_NR_poll:\n\n        {\n\n            struct target_pollfd *target_pfd;\n\n            unsigned int nfds = arg2;\n\n            int timeout = arg3;\n\n            struct pollfd *pfd;\n\n            unsigned int i;\n\n\n\n            target_pfd = lock_user(VERIFY_WRITE, arg1, sizeof(struct target_pollfd) * nfds, 1);\n\n            if (!target_pfd)\n\n                goto efault;\n\n            pfd = alloca(sizeof(struct pollfd) * nfds);\n\n            for(i = 0; i < nfds; i++) {\n\n                pfd[i].fd = tswap32(target_pfd[i].fd);\n\n                pfd[i].events = tswap16(target_pfd[i].events);\n\n            }\n\n            ret = get_errno(poll(pfd, nfds, timeout));\n\n            if (!is_error(ret)) {\n\n                for(i = 0; i < nfds; i++) {\n\n                    target_pfd[i].revents = tswap16(pfd[i].revents);\n\n                }\n\n                ret += nfds * (sizeof(struct target_pollfd)\n\n                               - sizeof(struct pollfd));\n\n            }\n\n            unlock_user(target_pfd, arg1, ret);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_flock:\n\n        /* NOTE: the flock constant seems to be the same for every\n\n           Linux platform */\n\n        ret = get_errno(flock(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_readv:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_WRITE, vec, arg2, count, 0) < 0)\n\n                goto efault;\n\n            ret = get_errno(readv(arg1, vec, count));\n\n            unlock_iovec(vec, arg2, count, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_writev:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_READ, vec, arg2, count, 1) < 0)\n\n                goto efault;\n\n            ret = get_errno(writev(arg1, vec, count));\n\n            unlock_iovec(vec, arg2, count, 0);\n\n        }\n\n        break;\n\n    case TARGET_NR_getsid:\n\n        ret = get_errno(getsid(arg1));\n\n        break;\n\n#if defined(TARGET_NR_fdatasync) /* Not on alpha (osf_datasync ?) */\n\n    case TARGET_NR_fdatasync:\n\n        ret = get_errno(fdatasync(arg1));\n\n        break;\n\n#endif\n\n    case TARGET_NR__sysctl:\n\n        /* We don't implement this, but ENOTDIR is always a safe\n\n           return value. */\n\n        ret = -TARGET_ENOTDIR;\n\n        break;\n\n    case TARGET_NR_sched_setparam:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n\n\n            if (!lock_user_struct(VERIFY_READ, target_schp, arg2, 1))\n\n                goto efault;\n\n            schp.sched_priority = tswap32(target_schp->sched_priority);\n\n            unlock_user_struct(target_schp, arg2, 0);\n\n            ret = get_errno(sched_setparam(arg1, &schp));\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_getparam:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n            ret = get_errno(sched_getparam(arg1, &schp));\n\n            if (!is_error(ret)) {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_schp, arg2, 0))\n\n                    goto efault;\n\n                target_schp->sched_priority = tswap32(schp.sched_priority);\n\n                unlock_user_struct(target_schp, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_setscheduler:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n            if (!lock_user_struct(VERIFY_READ, target_schp, arg3, 1))\n\n                goto efault;\n\n            schp.sched_priority = tswap32(target_schp->sched_priority);\n\n            unlock_user_struct(target_schp, arg3, 0);\n\n            ret = get_errno(sched_setscheduler(arg1, arg2, &schp));\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_getscheduler:\n\n        ret = get_errno(sched_getscheduler(arg1));\n\n        break;\n\n    case TARGET_NR_sched_yield:\n\n        ret = get_errno(sched_yield());\n\n        break;\n\n    case TARGET_NR_sched_get_priority_max:\n\n        ret = get_errno(sched_get_priority_max(arg1));\n\n        break;\n\n    case TARGET_NR_sched_get_priority_min:\n\n        ret = get_errno(sched_get_priority_min(arg1));\n\n        break;\n\n    case TARGET_NR_sched_rr_get_interval:\n\n        {\n\n            struct timespec ts;\n\n            ret = get_errno(sched_rr_get_interval(arg1, &ts));\n\n            if (!is_error(ret)) {\n\n                host_to_target_timespec(arg2, &ts);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_nanosleep:\n\n        {\n\n            struct timespec req, rem;\n\n            target_to_host_timespec(&req, arg1);\n\n            ret = get_errno(nanosleep(&req, &rem));\n\n            if (is_error(ret) && arg2) {\n\n                host_to_target_timespec(arg2, &rem);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_query_module\n\n    case TARGET_NR_query_module:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_nfsservctl\n\n    case TARGET_NR_nfsservctl:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_prctl:\n\n        switch (arg1)\n\n            {\n\n            case PR_GET_PDEATHSIG:\n\n                {\n\n                    int deathsig;\n\n                    ret = get_errno(prctl(arg1, &deathsig, arg3, arg4, arg5));\n\n                    if (!is_error(ret) && arg2\n\n                        && put_user_ual(deathsig, arg2))\n\n                        goto efault;\n\n                }\n\n                break;\n\n            default:\n\n                ret = get_errno(prctl(arg1, arg2, arg3, arg4, arg5));\n\n                break;\n\n            }\n\n        break;\n\n#ifdef TARGET_NR_arch_prctl\n\n    case TARGET_NR_arch_prctl:\n\n#if defined(TARGET_I386) && !defined(TARGET_ABI32)\n\n        ret = do_arch_prctl(cpu_env, arg1, arg2);\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_pread\n\n    case TARGET_NR_pread:\n\n#ifdef TARGET_ARM\n\n        if (((CPUARMState *)cpu_env)->eabi)\n\n            arg4 = arg5;\n\n#endif\n\n        if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n            goto efault;\n\n        ret = get_errno(pread(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, ret);\n\n        break;\n\n    case TARGET_NR_pwrite:\n\n#ifdef TARGET_ARM\n\n        if (((CPUARMState *)cpu_env)->eabi)\n\n            arg4 = arg5;\n\n#endif\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(pwrite(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_pread64\n\n    case TARGET_NR_pread64:\n\n        if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n            goto efault;\n\n        ret = get_errno(pread64(arg1, p, arg3, target_offset64(arg4, arg5)));\n\n        unlock_user(p, arg2, ret);\n\n        break;\n\n    case TARGET_NR_pwrite64:\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(pwrite64(arg1, p, arg3, target_offset64(arg4, arg5)));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_getcwd:\n\n        if (!(p = lock_user(VERIFY_WRITE, arg1, arg2, 0)))\n\n            goto efault;\n\n        ret = get_errno(sys_getcwd1(p, arg2));\n\n        unlock_user(p, arg1, ret);\n\n        break;\n\n    case TARGET_NR_capget:\n\n        goto unimplemented;\n\n    case TARGET_NR_capset:\n\n        goto unimplemented;\n\n    case TARGET_NR_sigaltstack:\n\n#if defined(TARGET_I386) || defined(TARGET_ARM) || defined(TARGET_MIPS) || \\\n\n    defined(TARGET_SPARC) || defined(TARGET_PPC) || defined(TARGET_ALPHA) || \\\n\n    defined(TARGET_M68K)\n\n        ret = do_sigaltstack(arg1, arg2, get_sp_from_cpustate((CPUState *)cpu_env));\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sendfile:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_getpmsg\n\n    case TARGET_NR_getpmsg:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_putpmsg\n\n    case TARGET_NR_putpmsg:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_vfork\n\n    case TARGET_NR_vfork:\n\n        ret = get_errno(do_fork(cpu_env, CLONE_VFORK | CLONE_VM | SIGCHLD,\n\n                        0, 0, 0, 0));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ugetrlimit\n\n    case TARGET_NR_ugetrlimit:\n\n    {\n\n\tstruct rlimit rlim;\n\n\tret = get_errno(getrlimit(arg1, &rlim));\n\n\tif (!is_error(ret)) {\n\n\t    struct target_rlimit *target_rlim;\n\n            if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))\n\n                goto efault;\n\n\t    target_rlim->rlim_cur = tswapl(rlim.rlim_cur);\n\n\t    target_rlim->rlim_max = tswapl(rlim.rlim_max);\n\n            unlock_user_struct(target_rlim, arg2, 1);\n\n\t}\n\n\tbreak;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_truncate64\n\n    case TARGET_NR_truncate64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n\tret = target_truncate64(cpu_env, p, arg2, arg3, arg4);\n\n        unlock_user(p, arg1, 0);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_ftruncate64\n\n    case TARGET_NR_ftruncate64:\n\n\tret = target_ftruncate64(cpu_env, arg1, arg2, arg3, arg4);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_stat64\n\n    case TARGET_NR_stat64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(stat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_lstat64\n\n    case TARGET_NR_lstat64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lstat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_fstat64\n\n    case TARGET_NR_fstat64:\n\n        ret = get_errno(fstat(arg1, &st));\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#if (defined(TARGET_NR_fstatat64) || defined(TARGET_NR_newfstatat)) && \\\n\n        (defined(__NR_fstatat64) || defined(__NR_newfstatat))\n\n#ifdef TARGET_NR_fstatat64\n\n    case TARGET_NR_fstatat64:\n\n#endif\n\n#ifdef TARGET_NR_newfstatat\n\n    case TARGET_NR_newfstatat:\n\n#endif\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n#ifdef __NR_fstatat64\n\n        ret = get_errno(sys_fstatat64(arg1, path(p), &st, arg4));\n\n#else\n\n        ret = get_errno(sys_newfstatat(arg1, path(p), &st, arg4));\n\n#endif\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg3, &st);\n\n        break;\n\n#endif\n\n#ifdef USE_UID16\n\n    case TARGET_NR_lchown:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lchown(p, low2highuid(arg2), low2highgid(arg3)));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_getuid:\n\n        ret = get_errno(high2lowuid(getuid()));\n\n        break;\n\n    case TARGET_NR_getgid:\n\n        ret = get_errno(high2lowgid(getgid()));\n\n        break;\n\n    case TARGET_NR_geteuid:\n\n        ret = get_errno(high2lowuid(geteuid()));\n\n        break;\n\n    case TARGET_NR_getegid:\n\n        ret = get_errno(high2lowgid(getegid()));\n\n        break;\n\n    case TARGET_NR_setreuid:\n\n        ret = get_errno(setreuid(low2highuid(arg1), low2highuid(arg2)));\n\n        break;\n\n    case TARGET_NR_setregid:\n\n        ret = get_errno(setregid(low2highgid(arg1), low2highgid(arg2)));\n\n        break;\n\n    case TARGET_NR_getgroups:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint16_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            ret = get_errno(getgroups(gidsetsize, grouplist));\n\n            if (gidsetsize == 0)\n\n                break;\n\n            if (!is_error(ret)) {\n\n                target_grouplist = lock_user(VERIFY_WRITE, arg2, gidsetsize * 2, 0);\n\n                if (!target_grouplist)\n\n                    goto efault;\n\n                for(i = 0;i < ret; i++)\n\n                    target_grouplist[i] = tswap16(grouplist[i]);\n\n                unlock_user(target_grouplist, arg2, gidsetsize * 2);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_setgroups:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint16_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            target_grouplist = lock_user(VERIFY_READ, arg2, gidsetsize * 2, 1);\n\n            if (!target_grouplist) {\n\n                ret = -TARGET_EFAULT;\n\n                goto fail;\n\n            }\n\n            for(i = 0;i < gidsetsize; i++)\n\n                grouplist[i] = tswap16(target_grouplist[i]);\n\n            unlock_user(target_grouplist, arg2, 0);\n\n            ret = get_errno(setgroups(gidsetsize, grouplist));\n\n        }\n\n        break;\n\n    case TARGET_NR_fchown:\n\n        ret = get_errno(fchown(arg1, low2highuid(arg2), low2highgid(arg3)));\n\n        break;\n\n#if defined(TARGET_NR_fchownat) && defined(__NR_fchownat)\n\n    case TARGET_NR_fchownat:\n\n        if (!(p = lock_user_string(arg2))) \n\n            goto efault;\n\n        ret = get_errno(sys_fchownat(arg1, p, low2highuid(arg3), low2highgid(arg4), arg5));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresuid\n\n    case TARGET_NR_setresuid:\n\n        ret = get_errno(setresuid(low2highuid(arg1),\n\n                                  low2highuid(arg2),\n\n                                  low2highuid(arg3)));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresuid\n\n    case TARGET_NR_getresuid:\n\n        {\n\n            uid_t ruid, euid, suid;\n\n            ret = get_errno(getresuid(&ruid, &euid, &suid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u16(high2lowuid(ruid), arg1)\n\n                    || put_user_u16(high2lowuid(euid), arg2)\n\n                    || put_user_u16(high2lowuid(suid), arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid\n\n    case TARGET_NR_setresgid:\n\n        ret = get_errno(setresgid(low2highgid(arg1),\n\n                                  low2highgid(arg2),\n\n                                  low2highgid(arg3)));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid\n\n    case TARGET_NR_getresgid:\n\n        {\n\n            gid_t rgid, egid, sgid;\n\n            ret = get_errno(getresgid(&rgid, &egid, &sgid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u16(high2lowgid(rgid), arg1)\n\n                    || put_user_u16(high2lowgid(egid), arg2)\n\n                    || put_user_u16(high2lowgid(sgid), arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_chown:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chown(p, low2highuid(arg2), low2highgid(arg3)));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_setuid:\n\n        ret = get_errno(setuid(low2highuid(arg1)));\n\n        break;\n\n    case TARGET_NR_setgid:\n\n        ret = get_errno(setgid(low2highgid(arg1)));\n\n        break;\n\n    case TARGET_NR_setfsuid:\n\n        ret = get_errno(setfsuid(arg1));\n\n        break;\n\n    case TARGET_NR_setfsgid:\n\n        ret = get_errno(setfsgid(arg1));\n\n        break;\n\n#endif /* USE_UID16 */\n\n\n\n#ifdef TARGET_NR_lchown32\n\n    case TARGET_NR_lchown32:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lchown(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getuid32\n\n    case TARGET_NR_getuid32:\n\n        ret = get_errno(getuid());\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_getxuid) && defined(TARGET_ALPHA)\n\n   /* Alpha specific */\n\n    case TARGET_NR_getxuid:\n\n         {\n\n            uid_t euid;\n\n            euid=geteuid();\n\n            ((CPUAlphaState *)cpu_env)->ir[IR_A4]=euid;\n\n         }\n\n        ret = get_errno(getuid());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_getxgid) && defined(TARGET_ALPHA)\n\n   /* Alpha specific */\n\n    case TARGET_NR_getxgid:\n\n         {\n\n            uid_t egid;\n\n            egid=getegid();\n\n            ((CPUAlphaState *)cpu_env)->ir[IR_A4]=egid;\n\n         }\n\n        ret = get_errno(getgid());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_osf_getsysinfo) && defined(TARGET_ALPHA)\n\n    /* Alpha specific */\n\n    case TARGET_NR_osf_getsysinfo:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        switch (arg1) {\n\n          case TARGET_GSI_IEEE_FP_CONTROL:\n\n            {\n\n                uint64_t swcr, fpcr = cpu_alpha_load_fpcr (cpu_env);\n\n\n\n                /* Copied from linux ieee_fpcr_to_swcr.  */\n\n                swcr = (fpcr >> 35) & SWCR_STATUS_MASK;\n\n                swcr |= (fpcr >> 36) & SWCR_MAP_DMZ;\n\n                swcr |= (~fpcr >> 48) & (SWCR_TRAP_ENABLE_INV\n\n                                        | SWCR_TRAP_ENABLE_DZE\n\n                                        | SWCR_TRAP_ENABLE_OVF);\n\n                swcr |= (~fpcr >> 57) & (SWCR_TRAP_ENABLE_UNF\n\n                                        | SWCR_TRAP_ENABLE_INE);\n\n                swcr |= (fpcr >> 47) & SWCR_MAP_UMZ;\n\n                swcr |= (~fpcr >> 41) & SWCR_TRAP_ENABLE_DNO;\n\n\n\n                if (put_user_u64 (swcr, arg2))\n\n                        goto efault;\n\n                ret = 0;\n\n            }\n\n            break;\n\n\n\n          /* case GSI_IEEE_STATE_AT_SIGNAL:\n\n             -- Not implemented in linux kernel.\n\n             case GSI_UACPROC:\n\n             -- Retrieves current unaligned access state; not much used.\n\n             case GSI_PROC_TYPE:\n\n             -- Retrieves implver information; surely not used.\n\n             case GSI_GET_HWRPB:\n\n             -- Grabs a copy of the HWRPB; surely not used.\n\n          */\n\n        }\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_osf_setsysinfo) && defined(TARGET_ALPHA)\n\n    /* Alpha specific */\n\n    case TARGET_NR_osf_setsysinfo:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        switch (arg1) {\n\n          case TARGET_SSI_IEEE_FP_CONTROL:\n\n          case TARGET_SSI_IEEE_RAISE_EXCEPTION:\n\n            {\n\n                uint64_t swcr, fpcr, orig_fpcr;\n\n\n\n                if (get_user_u64 (swcr, arg2))\n\n                    goto efault;\n\n                orig_fpcr = cpu_alpha_load_fpcr (cpu_env);\n\n                fpcr = orig_fpcr & FPCR_DYN_MASK;\n\n\n\n                /* Copied from linux ieee_swcr_to_fpcr.  */\n\n                fpcr |= (swcr & SWCR_STATUS_MASK) << 35;\n\n                fpcr |= (swcr & SWCR_MAP_DMZ) << 36;\n\n                fpcr |= (~swcr & (SWCR_TRAP_ENABLE_INV\n\n                                  | SWCR_TRAP_ENABLE_DZE\n\n                                  | SWCR_TRAP_ENABLE_OVF)) << 48;\n\n                fpcr |= (~swcr & (SWCR_TRAP_ENABLE_UNF\n\n                                  | SWCR_TRAP_ENABLE_INE)) << 57;\n\n                fpcr |= (swcr & SWCR_MAP_UMZ ? FPCR_UNDZ | FPCR_UNFD : 0);\n\n                fpcr |= (~swcr & SWCR_TRAP_ENABLE_DNO) << 41;\n\n\n\n                cpu_alpha_store_fpcr (cpu_env, fpcr);\n\n                ret = 0;\n\n\n\n                if (arg1 == TARGET_SSI_IEEE_RAISE_EXCEPTION) {\n\n                    /* Old exceptions are not signaled.  */\n\n                    fpcr &= ~(orig_fpcr & FPCR_STATUS_MASK);\n\n\n\n                    /* If any exceptions set by this call, and are unmasked,\n\n                       send a signal.  */\n\n                    /* ??? FIXME */\n\n                }\n\n            }\n\n            break;\n\n\n\n          /* case SSI_NVPAIRS:\n\n             -- Used with SSIN_UACPROC to enable unaligned accesses.\n\n             case SSI_IEEE_STATE_AT_SIGNAL:\n\n             case SSI_IEEE_IGNORE_STATE_AT_SIGNAL:\n\n             -- Not implemented in linux kernel\n\n          */\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_osf_sigprocmask\n\n    /* Alpha specific.  */\n\n    case TARGET_NR_osf_sigprocmask:\n\n        {\n\n            abi_ulong mask;\n\n            int how = arg1;\n\n            sigset_t set, oldset;\n\n\n\n            switch(arg1) {\n\n            case TARGET_SIG_BLOCK:\n\n                how = SIG_BLOCK;\n\n                break;\n\n            case TARGET_SIG_UNBLOCK:\n\n                how = SIG_UNBLOCK;\n\n                break;\n\n            case TARGET_SIG_SETMASK:\n\n                how = SIG_SETMASK;\n\n                break;\n\n            default:\n\n                ret = -TARGET_EINVAL;\n\n                goto fail;\n\n            }\n\n            mask = arg2;\n\n            target_to_host_old_sigset(&set, &mask);\n\n            sigprocmask(arg1, &set, &oldset);\n\n            host_to_target_old_sigset(&mask, &oldset);\n\n            ret = mask;\n\n        }\n\n        break;\n\n#endif\n\n\n\n#ifdef TARGET_NR_getgid32\n\n    case TARGET_NR_getgid32:\n\n        ret = get_errno(getgid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_geteuid32\n\n    case TARGET_NR_geteuid32:\n\n        ret = get_errno(geteuid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getegid32\n\n    case TARGET_NR_getegid32:\n\n        ret = get_errno(getegid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setreuid32\n\n    case TARGET_NR_setreuid32:\n\n        ret = get_errno(setreuid(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setregid32\n\n    case TARGET_NR_setregid32:\n\n        ret = get_errno(setregid(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getgroups32\n\n    case TARGET_NR_getgroups32:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint32_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            ret = get_errno(getgroups(gidsetsize, grouplist));\n\n            if (gidsetsize == 0)\n\n                break;\n\n            if (!is_error(ret)) {\n\n                target_grouplist = lock_user(VERIFY_WRITE, arg2, gidsetsize * 4, 0);\n\n                if (!target_grouplist) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto fail;\n\n                }\n\n                for(i = 0;i < ret; i++)\n\n                    target_grouplist[i] = tswap32(grouplist[i]);\n\n                unlock_user(target_grouplist, arg2, gidsetsize * 4);\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setgroups32\n\n    case TARGET_NR_setgroups32:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint32_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            target_grouplist = lock_user(VERIFY_READ, arg2, gidsetsize * 4, 1);\n\n            if (!target_grouplist) {\n\n                ret = -TARGET_EFAULT;\n\n                goto fail;\n\n            }\n\n            for(i = 0;i < gidsetsize; i++)\n\n                grouplist[i] = tswap32(target_grouplist[i]);\n\n            unlock_user(target_grouplist, arg2, 0);\n\n            ret = get_errno(setgroups(gidsetsize, grouplist));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_fchown32\n\n    case TARGET_NR_fchown32:\n\n        ret = get_errno(fchown(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresuid32\n\n    case TARGET_NR_setresuid32:\n\n        ret = get_errno(setresuid(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresuid32\n\n    case TARGET_NR_getresuid32:\n\n        {\n\n            uid_t ruid, euid, suid;\n\n            ret = get_errno(getresuid(&ruid, &euid, &suid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u32(ruid, arg1)\n\n                    || put_user_u32(euid, arg2)\n\n                    || put_user_u32(suid, arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresgid32\n\n    case TARGET_NR_setresgid32:\n\n        ret = get_errno(setresgid(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid32\n\n    case TARGET_NR_getresgid32:\n\n        {\n\n            gid_t rgid, egid, sgid;\n\n            ret = get_errno(getresgid(&rgid, &egid, &sgid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u32(rgid, arg1)\n\n                    || put_user_u32(egid, arg2)\n\n                    || put_user_u32(sgid, arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_chown32\n\n    case TARGET_NR_chown32:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chown(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setuid32\n\n    case TARGET_NR_setuid32:\n\n        ret = get_errno(setuid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setgid32\n\n    case TARGET_NR_setgid32:\n\n        ret = get_errno(setgid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setfsuid32\n\n    case TARGET_NR_setfsuid32:\n\n        ret = get_errno(setfsuid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setfsgid32\n\n    case TARGET_NR_setfsgid32:\n\n        ret = get_errno(setfsgid(arg1));\n\n        break;\n\n#endif\n\n\n\n    case TARGET_NR_pivot_root:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_mincore\n\n    case TARGET_NR_mincore:\n\n        {\n\n            void *a;\n\n            ret = -TARGET_EFAULT;\n\n            if (!(a = lock_user(VERIFY_READ, arg1,arg2, 0)))\n\n                goto efault;\n\n            if (!(p = lock_user_string(arg3)))\n\n                goto mincore_fail;\n\n            ret = get_errno(mincore(a, arg2, p));\n\n            unlock_user(p, arg3, ret);\n\n            mincore_fail:\n\n            unlock_user(a, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_arm_fadvise64_64\n\n    case TARGET_NR_arm_fadvise64_64:\n\n\t{\n\n\t\t/*\n\n\t\t * arm_fadvise64_64 looks like fadvise64_64 but\n\n\t\t * with different argument order\n\n\t\t */\n\n\t\tabi_long temp;\n\n\t\ttemp = arg3;\n\n\t\targ3 = arg4;\n\n\t\targ4 = temp;\n\n\t}\n\n#endif\n\n#if defined(TARGET_NR_fadvise64_64) || defined(TARGET_NR_arm_fadvise64_64) || defined(TARGET_NR_fadvise64)\n\n#ifdef TARGET_NR_fadvise64_64\n\n    case TARGET_NR_fadvise64_64:\n\n#endif\n\n#ifdef TARGET_NR_fadvise64\n\n    case TARGET_NR_fadvise64:\n\n#endif\n\n#ifdef TARGET_S390X\n\n        switch (arg4) {\n\n        case 4: arg4 = POSIX_FADV_NOREUSE + 1; break; /* make sure it's an invalid value */\n\n        case 5: arg4 = POSIX_FADV_NOREUSE + 2; break; /* ditto */\n\n        case 6: arg4 = POSIX_FADV_DONTNEED; break;\n\n        case 7: arg4 = POSIX_FADV_NOREUSE; break;\n\n        default: break;\n\n        }\n\n#endif\n\n        ret = -posix_fadvise(arg1, arg2, arg3, arg4);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_madvise\n\n    case TARGET_NR_madvise:\n\n        /* A straight passthrough may not be safe because qemu sometimes\n\n           turns private flie-backed mappings into anonymous mappings.\n\n           This will break MADV_DONTNEED.\n\n           This is a hint, so ignoring and returning success is ok.  */\n\n        ret = get_errno(0);\n\n        break;\n\n#endif\n\n#if TARGET_ABI_BITS == 32\n\n    case TARGET_NR_fcntl64:\n\n    {\n\n\tint cmd;\n\n\tstruct flock64 fl;\n\n\tstruct target_flock64 *target_fl;\n\n#ifdef TARGET_ARM\n\n\tstruct target_eabi_flock64 *target_efl;\n\n#endif\n\n\n\n\tcmd = target_to_host_fcntl_cmd(arg2);\n\n\tif (cmd == -TARGET_EINVAL)\n\n\t\treturn cmd;\n\n\n\n        switch(arg2) {\n\n        case TARGET_F_GETLK64:\n\n#ifdef TARGET_ARM\n\n            if (((CPUARMState *)cpu_env)->eabi) {\n\n                if (!lock_user_struct(VERIFY_READ, target_efl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_efl->l_type);\n\n                fl.l_whence = tswap16(target_efl->l_whence);\n\n                fl.l_start = tswap64(target_efl->l_start);\n\n                fl.l_len = tswap64(target_efl->l_len);\n\n                fl.l_pid = tswap32(target_efl->l_pid);\n\n                unlock_user_struct(target_efl, arg3, 0);\n\n            } else\n\n#endif\n\n            {\n\n                if (!lock_user_struct(VERIFY_READ, target_fl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_fl->l_type);\n\n                fl.l_whence = tswap16(target_fl->l_whence);\n\n                fl.l_start = tswap64(target_fl->l_start);\n\n                fl.l_len = tswap64(target_fl->l_len);\n\n                fl.l_pid = tswap32(target_fl->l_pid);\n\n                unlock_user_struct(target_fl, arg3, 0);\n\n            }\n\n            ret = get_errno(fcntl(arg1, cmd, &fl));\n\n\t    if (ret == 0) {\n\n#ifdef TARGET_ARM\n\n                if (((CPUARMState *)cpu_env)->eabi) {\n\n                    if (!lock_user_struct(VERIFY_WRITE, target_efl, arg3, 0)) \n\n                        goto efault;\n\n                    target_efl->l_type = tswap16(fl.l_type);\n\n                    target_efl->l_whence = tswap16(fl.l_whence);\n\n                    target_efl->l_start = tswap64(fl.l_start);\n\n                    target_efl->l_len = tswap64(fl.l_len);\n\n                    target_efl->l_pid = tswap32(fl.l_pid);\n\n                    unlock_user_struct(target_efl, arg3, 1);\n\n                } else\n\n#endif\n\n                {\n\n                    if (!lock_user_struct(VERIFY_WRITE, target_fl, arg3, 0)) \n\n                        goto efault;\n\n                    target_fl->l_type = tswap16(fl.l_type);\n\n                    target_fl->l_whence = tswap16(fl.l_whence);\n\n                    target_fl->l_start = tswap64(fl.l_start);\n\n                    target_fl->l_len = tswap64(fl.l_len);\n\n                    target_fl->l_pid = tswap32(fl.l_pid);\n\n                    unlock_user_struct(target_fl, arg3, 1);\n\n                }\n\n\t    }\n\n\t    break;\n\n\n\n        case TARGET_F_SETLK64:\n\n        case TARGET_F_SETLKW64:\n\n#ifdef TARGET_ARM\n\n            if (((CPUARMState *)cpu_env)->eabi) {\n\n                if (!lock_user_struct(VERIFY_READ, target_efl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_efl->l_type);\n\n                fl.l_whence = tswap16(target_efl->l_whence);\n\n                fl.l_start = tswap64(target_efl->l_start);\n\n                fl.l_len = tswap64(target_efl->l_len);\n\n                fl.l_pid = tswap32(target_efl->l_pid);\n\n                unlock_user_struct(target_efl, arg3, 0);\n\n            } else\n\n#endif\n\n            {\n\n                if (!lock_user_struct(VERIFY_READ, target_fl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_fl->l_type);\n\n                fl.l_whence = tswap16(target_fl->l_whence);\n\n                fl.l_start = tswap64(target_fl->l_start);\n\n                fl.l_len = tswap64(target_fl->l_len);\n\n                fl.l_pid = tswap32(target_fl->l_pid);\n\n                unlock_user_struct(target_fl, arg3, 0);\n\n            }\n\n            ret = get_errno(fcntl(arg1, cmd, &fl));\n\n\t    break;\n\n        default:\n\n            ret = do_fcntl(arg1, arg2, arg3);\n\n            break;\n\n        }\n\n\tbreak;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_cacheflush\n\n    case TARGET_NR_cacheflush:\n\n        /* self-modifying code is handled automatically, so nothing needed */\n\n        ret = 0;\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_security\n\n    case TARGET_NR_security:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_getpagesize\n\n    case TARGET_NR_getpagesize:\n\n        ret = TARGET_PAGE_SIZE;\n\n        break;\n\n#endif\n\n    case TARGET_NR_gettid:\n\n        ret = get_errno(gettid());\n\n        break;\n\n#ifdef TARGET_NR_readahead\n\n    case TARGET_NR_readahead:\n\n#if TARGET_ABI_BITS == 32\n\n#ifdef TARGET_ARM\n\n        if (((CPUARMState *)cpu_env)->eabi)\n\n        {\n\n            arg2 = arg3;\n\n            arg3 = arg4;\n\n            arg4 = arg5;\n\n        }\n\n#endif\n\n        ret = get_errno(readahead(arg1, ((off64_t)arg3 << 32) | arg2, arg4));\n\n#else\n\n        ret = get_errno(readahead(arg1, arg2, arg3));\n\n#endif\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setxattr\n\n    case TARGET_NR_setxattr:\n\n    case TARGET_NR_lsetxattr:\n\n    case TARGET_NR_fsetxattr:\n\n    case TARGET_NR_getxattr:\n\n    case TARGET_NR_lgetxattr:\n\n    case TARGET_NR_fgetxattr:\n\n    case TARGET_NR_listxattr:\n\n    case TARGET_NR_llistxattr:\n\n    case TARGET_NR_flistxattr:\n\n    case TARGET_NR_removexattr:\n\n    case TARGET_NR_lremovexattr:\n\n    case TARGET_NR_fremovexattr:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_set_thread_area\n\n    case TARGET_NR_set_thread_area:\n\n#if defined(TARGET_MIPS)\n\n      ((CPUMIPSState *) cpu_env)->tls_value = arg1;\n\n      ret = 0;\n\n      break;\n\n#elif defined(TARGET_CRIS)\n\n      if (arg1 & 0xff)\n\n          ret = -TARGET_EINVAL;\n\n      else {\n\n          ((CPUCRISState *) cpu_env)->pregs[PR_PID] = arg1;\n\n          ret = 0;\n\n      }\n\n      break;\n\n#elif defined(TARGET_I386) && defined(TARGET_ABI32)\n\n      ret = do_set_thread_area(cpu_env, arg1);\n\n      break;\n\n#else\n\n      goto unimplemented_nowarn;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_get_thread_area\n\n    case TARGET_NR_get_thread_area:\n\n#if defined(TARGET_I386) && defined(TARGET_ABI32)\n\n        ret = do_get_thread_area(cpu_env, arg1);\n\n#else\n\n        goto unimplemented_nowarn;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_getdomainname\n\n    case TARGET_NR_getdomainname:\n\n        goto unimplemented_nowarn;\n\n#endif\n\n\n\n#ifdef TARGET_NR_clock_gettime\n\n    case TARGET_NR_clock_gettime:\n\n    {\n\n        struct timespec ts;\n\n        ret = get_errno(clock_gettime(arg1, &ts));\n\n        if (!is_error(ret)) {\n\n            host_to_target_timespec(arg2, &ts);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_clock_getres\n\n    case TARGET_NR_clock_getres:\n\n    {\n\n        struct timespec ts;\n\n        ret = get_errno(clock_getres(arg1, &ts));\n\n        if (!is_error(ret)) {\n\n            host_to_target_timespec(arg2, &ts);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_clock_nanosleep\n\n    case TARGET_NR_clock_nanosleep:\n\n    {\n\n        struct timespec ts;\n\n        target_to_host_timespec(&ts, arg3);\n\n        ret = get_errno(clock_nanosleep(arg1, arg2, &ts, arg4 ? &ts : NULL));\n\n        if (arg4)\n\n            host_to_target_timespec(arg4, &ts);\n\n        break;\n\n    }\n\n#endif\n\n\n\n#if defined(TARGET_NR_set_tid_address) && defined(__NR_set_tid_address)\n\n    case TARGET_NR_set_tid_address:\n\n        ret = get_errno(set_tid_address((int *)g2h(arg1)));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_tkill) && defined(__NR_tkill)\n\n    case TARGET_NR_tkill:\n\n        ret = get_errno(sys_tkill((int)arg1, target_to_host_signal(arg2)));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_tgkill) && defined(__NR_tgkill)\n\n    case TARGET_NR_tgkill:\n\n\tret = get_errno(sys_tgkill((int)arg1, (int)arg2,\n\n                        target_to_host_signal(arg3)));\n\n\tbreak;\n\n#endif\n\n\n\n#ifdef TARGET_NR_set_robust_list\n\n    case TARGET_NR_set_robust_list:\n\n\tgoto unimplemented_nowarn;\n\n#endif\n\n\n\n#if defined(TARGET_NR_utimensat) && defined(__NR_utimensat)\n\n    case TARGET_NR_utimensat:\n\n        {\n\n            struct timespec *tsp, ts[2];\n\n            if (!arg3) {\n\n                tsp = NULL;\n\n            } else {\n\n                target_to_host_timespec(ts, arg3);\n\n                target_to_host_timespec(ts+1, arg3+sizeof(struct target_timespec));\n\n                tsp = ts;\n\n            }\n\n            if (!arg2)\n\n                ret = get_errno(sys_utimensat(arg1, NULL, tsp, arg4));\n\n            else {\n\n                if (!(p = lock_user_string(arg2))) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto fail;\n\n                }\n\n                ret = get_errno(sys_utimensat(arg1, path(p), tsp, arg4));\n\n                unlock_user(p, arg2, 0);\n\n            }\n\n        }\n\n\tbreak;\n\n#endif\n\n#if defined(CONFIG_USE_NPTL)\n\n    case TARGET_NR_futex:\n\n        ret = do_futex(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)\n\n    case TARGET_NR_inotify_init:\n\n        ret = get_errno(sys_inotify_init());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_add_watch) && defined(__NR_inotify_add_watch)\n\n    case TARGET_NR_inotify_add_watch:\n\n        p = lock_user_string(arg2);\n\n        ret = get_errno(sys_inotify_add_watch(arg1, path(p), arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_rm_watch) && defined(__NR_inotify_rm_watch)\n\n    case TARGET_NR_inotify_rm_watch:\n\n        ret = get_errno(sys_inotify_rm_watch(arg1, arg2));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_mq_open) && defined(__NR_mq_open)\n\n    case TARGET_NR_mq_open:\n\n        {\n\n            struct mq_attr posix_mq_attr;\n\n\n\n            p = lock_user_string(arg1 - 1);\n\n            if (arg4 != 0)\n\n                copy_from_user_mq_attr (&posix_mq_attr, arg4);\n\n            ret = get_errno(mq_open(p, arg2, arg3, &posix_mq_attr));\n\n            unlock_user (p, arg1, 0);\n\n        }\n\n        break;\n\n\n\n    case TARGET_NR_mq_unlink:\n\n        p = lock_user_string(arg1 - 1);\n\n        ret = get_errno(mq_unlink(p));\n\n        unlock_user (p, arg1, 0);\n\n        break;\n\n\n\n    case TARGET_NR_mq_timedsend:\n\n        {\n\n            struct timespec ts;\n\n\n\n            p = lock_user (VERIFY_READ, arg2, arg3, 1);\n\n            if (arg5 != 0) {\n\n                target_to_host_timespec(&ts, arg5);\n\n                ret = get_errno(mq_timedsend(arg1, p, arg3, arg4, &ts));\n\n                host_to_target_timespec(arg5, &ts);\n\n            }\n\n            else\n\n                ret = get_errno(mq_send(arg1, p, arg3, arg4));\n\n            unlock_user (p, arg2, arg3);\n\n        }\n\n        break;\n\n\n\n    case TARGET_NR_mq_timedreceive:\n\n        {\n\n            struct timespec ts;\n\n            unsigned int prio;\n\n\n\n            p = lock_user (VERIFY_READ, arg2, arg3, 1);\n\n            if (arg5 != 0) {\n\n                target_to_host_timespec(&ts, arg5);\n\n                ret = get_errno(mq_timedreceive(arg1, p, arg3, &prio, &ts));\n\n                host_to_target_timespec(arg5, &ts);\n\n            }\n\n            else\n\n                ret = get_errno(mq_receive(arg1, p, arg3, &prio));\n\n            unlock_user (p, arg2, arg3);\n\n            if (arg4 != 0)\n\n                put_user_u32(prio, arg4);\n\n        }\n\n        break;\n\n\n\n    /* Not implemented for now... */\n\n/*     case TARGET_NR_mq_notify: */\n\n/*         break; */\n\n\n\n    case TARGET_NR_mq_getsetattr:\n\n        {\n\n            struct mq_attr posix_mq_attr_in, posix_mq_attr_out;\n\n            ret = 0;\n\n            if (arg3 != 0) {\n\n                ret = mq_getattr(arg1, &posix_mq_attr_out);\n\n                copy_to_user_mq_attr(arg3, &posix_mq_attr_out);\n\n            }\n\n            if (arg2 != 0) {\n\n                copy_from_user_mq_attr(&posix_mq_attr_in, arg2);\n\n                ret |= mq_setattr(arg1, &posix_mq_attr_in, &posix_mq_attr_out);\n\n            }\n\n\n\n        }\n\n        break;\n\n#endif\n\n\n\n#ifdef CONFIG_SPLICE\n\n#ifdef TARGET_NR_tee\n\n    case TARGET_NR_tee:\n\n        {\n\n            ret = get_errno(tee(arg1,arg2,arg3,arg4));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_splice\n\n    case TARGET_NR_splice:\n\n        {\n\n            loff_t loff_in, loff_out;\n\n            loff_t *ploff_in = NULL, *ploff_out = NULL;\n\n            if(arg2) {\n\n                get_user_u64(loff_in, arg2);\n\n                ploff_in = &loff_in;\n\n            }\n\n            if(arg4) {\n\n                get_user_u64(loff_out, arg2);\n\n                ploff_out = &loff_out;\n\n            }\n\n            ret = get_errno(splice(arg1, ploff_in, arg3, ploff_out, arg5, arg6));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_vmsplice\n\n\tcase TARGET_NR_vmsplice:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_READ, vec, arg2, count, 1) < 0)\n\n                goto efault;\n\n            ret = get_errno(vmsplice(arg1, vec, count, arg4));\n\n            unlock_iovec(vec, arg2, count, 0);\n\n        }\n\n        break;\n\n#endif\n\n#endif /* CONFIG_SPLICE */\n\n#ifdef CONFIG_EVENTFD\n\n#if defined(TARGET_NR_eventfd)\n\n    case TARGET_NR_eventfd:\n\n        ret = get_errno(eventfd(arg1, 0));\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_eventfd2)\n\n    case TARGET_NR_eventfd2:\n\n        ret = get_errno(eventfd(arg1, arg2));\n\n        break;\n\n#endif\n\n#endif /* CONFIG_EVENTFD  */\n\n#if defined(CONFIG_FALLOCATE) && defined(TARGET_NR_fallocate)\n\n    case TARGET_NR_fallocate:\n\n        ret = get_errno(fallocate(arg1, arg2, arg3, arg4));\n\n        break;\n\n#endif\n\n    default:\n\n    unimplemented:\n\n        gemu_log(\"qemu: Unsupported syscall: %d\\n\", num);\n\n#if defined(TARGET_NR_setxattr) || defined(TARGET_NR_get_thread_area) || defined(TARGET_NR_getdomainname) || defined(TARGET_NR_set_robust_list)\n\n    unimplemented_nowarn:\n\n#endif\n\n        ret = -TARGET_ENOSYS;\n\n        break;\n\n    }\n\nfail:\n\n#ifdef DEBUG\n\n    gemu_log(\" = \" TARGET_ABI_FMT_ld \"\\n\", ret);\n\n#endif\n\n    if(do_strace)\n\n        print_syscall_ret(num, ret);\n\n    return ret;\n\nefault:\n\n    ret = -TARGET_EFAULT;\n\n    goto fail;\n\n}\n", "idx": 27056, "_split": "test", "_hash": "326045537a7c825e249fd7d8d17bf454"}
{"project": "qemu", "commit_id": "4058fd98fd7e9c476774717adbd49698dd273166", "target": 0, "func": "cpu_x86_dump_seg_cache(CPUState *env, FILE *f, fprintf_function cpu_fprintf,\n\n                       const char *name, struct SegmentCache *sc)\n\n{\n\n#ifdef TARGET_X86_64\n\n    if (env->hflags & HF_CS64_MASK) {\n\n        cpu_fprintf(f, \"%-3s=%04x %016\" PRIx64 \" %08x %08x\", name,\n\n                    sc->selector, sc->base, sc->limit, sc->flags);\n\n    } else\n\n#endif\n\n    {\n\n        cpu_fprintf(f, \"%-3s=%04x %08x %08x %08x\", name, sc->selector,\n\n                    (uint32_t)sc->base, sc->limit, sc->flags);\n\n    }\n\n\n\n    if (!(env->hflags & HF_PE_MASK) || !(sc->flags & DESC_P_MASK))\n\n        goto done;\n\n\n\n    cpu_fprintf(f, \" DPL=%d \", (sc->flags & DESC_DPL_MASK) >> DESC_DPL_SHIFT);\n\n    if (sc->flags & DESC_S_MASK) {\n\n        if (sc->flags & DESC_CS_MASK) {\n\n            cpu_fprintf(f, (sc->flags & DESC_L_MASK) ? \"CS64\" :\n\n                           ((sc->flags & DESC_B_MASK) ? \"CS32\" : \"CS16\"));\n\n            cpu_fprintf(f, \" [%c%c\", (sc->flags & DESC_C_MASK) ? 'C' : '-',\n\n                        (sc->flags & DESC_R_MASK) ? 'R' : '-');\n\n        } else {\n\n            cpu_fprintf(f, (sc->flags & DESC_B_MASK) ? \"DS  \" : \"DS16\");\n\n            cpu_fprintf(f, \" [%c%c\", (sc->flags & DESC_E_MASK) ? 'E' : '-',\n\n                        (sc->flags & DESC_W_MASK) ? 'W' : '-');\n\n        }\n\n        cpu_fprintf(f, \"%c]\", (sc->flags & DESC_A_MASK) ? 'A' : '-');\n\n    } else {\n\n        static const char *sys_type_name[2][16] = {\n\n            { /* 32 bit mode */\n\n                \"Reserved\", \"TSS16-avl\", \"LDT\", \"TSS16-busy\",\n\n                \"CallGate16\", \"TaskGate\", \"IntGate16\", \"TrapGate16\",\n\n                \"Reserved\", \"TSS32-avl\", \"Reserved\", \"TSS32-busy\",\n\n                \"CallGate32\", \"Reserved\", \"IntGate32\", \"TrapGate32\"\n\n            },\n\n            { /* 64 bit mode */\n\n                \"<hiword>\", \"Reserved\", \"LDT\", \"Reserved\", \"Reserved\",\n\n                \"Reserved\", \"Reserved\", \"Reserved\", \"Reserved\",\n\n                \"TSS64-avl\", \"Reserved\", \"TSS64-busy\", \"CallGate64\",\n\n                \"Reserved\", \"IntGate64\", \"TrapGate64\"\n\n            }\n\n        };\n\n        cpu_fprintf(f, \"%s\",\n\n                    sys_type_name[(env->hflags & HF_LMA_MASK) ? 1 : 0]\n\n                                 [(sc->flags & DESC_TYPE_MASK)\n\n                                  >> DESC_TYPE_SHIFT]);\n\n    }\n\ndone:\n\n    cpu_fprintf(f, \"\\n\");\n\n}\n", "idx": 27058, "_split": "test", "_hash": "73de1e467a157816aad587a659ca5b0c"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void disas_fp_ccomp(DisasContext *s, uint32_t insn)\n\n{\n\n    unsigned int mos, type, rm, cond, rn, op, nzcv;\n\n    TCGv_i64 tcg_flags;\n\n    int label_continue = -1;\n\n\n\n    mos = extract32(insn, 29, 3);\n\n    type = extract32(insn, 22, 2); /* 0 = single, 1 = double */\n\n    rm = extract32(insn, 16, 5);\n\n    cond = extract32(insn, 12, 4);\n\n    rn = extract32(insn, 5, 5);\n\n    op = extract32(insn, 4, 1);\n\n    nzcv = extract32(insn, 0, 4);\n\n\n\n    if (mos || type > 1) {\n\n        unallocated_encoding(s);\n\n        return;\n\n    }\n\n\n\n    if (!fp_access_check(s)) {\n\n        return;\n\n    }\n\n\n\n    if (cond < 0x0e) { /* not always */\n\n        int label_match = gen_new_label();\n\n        label_continue = gen_new_label();\n\n        arm_gen_test_cc(cond, label_match);\n\n        /* nomatch: */\n\n        tcg_flags = tcg_const_i64(nzcv << 28);\n\n        gen_set_nzcv(tcg_flags);\n\n        tcg_temp_free_i64(tcg_flags);\n\n        tcg_gen_br(label_continue);\n\n        gen_set_label(label_match);\n\n    }\n\n\n\n    handle_fp_compare(s, type, rn, rm, false, op);\n\n\n\n    if (cond < 0x0e) {\n\n        gen_set_label(label_continue);\n\n    }\n\n}\n", "idx": 27083, "_split": "test", "_hash": "5f074d1c0ff0b1447c59018013587323"}
{"project": "qemu", "commit_id": "ea6c5f8ffe6de12e04e63acbb9937683b30216e2", "target": 0, "func": "static inline int test_bit(unsigned int bit, const unsigned long *map)\n\n{\n\n    return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));\n\n}\n", "idx": 27088, "_split": "test", "_hash": "c8215e387d95cf403d09ffbc50b4ac8c"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static bool try_poll_mode(AioContext *ctx, bool blocking)\n\n{\n\n    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {\n\n        /* See qemu_soonest_timeout() uint64_t hack */\n\n        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),\n\n                             (uint64_t)ctx->poll_ns);\n\n\n\n        if (max_ns) {\n\n            poll_set_started(ctx, true);\n\n\n\n            if (run_poll_handlers(ctx, max_ns)) {\n\n                return true;\n\n            }\n\n        }\n\n    }\n\n\n\n    poll_set_started(ctx, false);\n\n\n\n    /* Even if we don't run busy polling, try polling once in case it can make\n\n     * progress and the caller will be able to avoid ppoll(2)/epoll_wait(2).\n\n     */\n\n    return run_poll_handlers_once(ctx);\n\n}\n", "idx": 27100, "_split": "test", "_hash": "98f7666e9939eab1019f28b516dfe53a"}
{"project": "qemu", "commit_id": "563890c7c7e977842e2a35afe7a24d06d2103242", "target": 1, "func": "static int qmp_tmp105_get_temperature(const char *id)\n\n{\n\n    QDict *response;\n\n    int ret;\n\n\n\n    response = qmp(\"{ 'execute': 'qom-get', 'arguments': { 'path': '%s', \"\n\n                   \"'property': 'temperature' } }\", id);\n\n    g_assert(qdict_haskey(response, \"return\"));\n\n    ret = qdict_get_int(response, \"return\");\n\n    QDECREF(response);\n\n    return ret;\n\n}\n", "idx": 27107, "_split": "test", "_hash": "897bb7a7cb21669bca70f705b8fd8ea4"}
{"project": "qemu", "commit_id": "f678f671ba654d4610f0e43d175c8c1b2fad10df", "target": 1, "func": "static void decode_sys_interrupts(CPUTriCoreState *env, DisasContext *ctx)\n\n{\n\n    uint32_t op2;\n\n    uint32_t r1;\n\n    TCGLabel *l1;\n\n    TCGv tmp;\n\n\n\n    op2 = MASK_OP_SYS_OP2(ctx->opcode);\n\n    r1  = MASK_OP_SYS_S1D(ctx->opcode);\n\n\n\n    switch (op2) {\n\n    case OPC2_32_SYS_DEBUG:\n\n        /* raise EXCP_DEBUG */\n\n        break;\n\n    case OPC2_32_SYS_DISABLE:\n\n        tcg_gen_andi_tl(cpu_ICR, cpu_ICR, ~MASK_ICR_IE);\n\n        break;\n\n    case OPC2_32_SYS_DSYNC:\n\n        break;\n\n    case OPC2_32_SYS_ENABLE:\n\n        tcg_gen_ori_tl(cpu_ICR, cpu_ICR, MASK_ICR_IE);\n\n        break;\n\n    case OPC2_32_SYS_ISYNC:\n\n        break;\n\n    case OPC2_32_SYS_NOP:\n\n        break;\n\n    case OPC2_32_SYS_RET:\n\n        gen_compute_branch(ctx, op2, 0, 0, 0, 0);\n\n        break;\n\n    case OPC2_32_SYS_FRET:\n\n        gen_fret(ctx);\n\n        break;\n\n    case OPC2_32_SYS_RFE:\n\n        gen_helper_rfe(cpu_env);\n\n        tcg_gen_exit_tb(0);\n\n        ctx->bstate = BS_BRANCH;\n\n        break;\n\n    case OPC2_32_SYS_RFM:\n\n        if ((ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_SM) {\n\n            tmp = tcg_temp_new();\n\n            l1 = gen_new_label();\n\n\n\n            tcg_gen_ld32u_tl(tmp, cpu_env, offsetof(CPUTriCoreState, DBGSR));\n\n            tcg_gen_andi_tl(tmp, tmp, MASK_DBGSR_DE);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, tmp, 1, l1);\n\n            gen_helper_rfm(cpu_env);\n\n            gen_set_label(l1);\n\n            tcg_gen_exit_tb(0);\n\n            ctx->bstate = BS_BRANCH;\n\n            tcg_temp_free(tmp);\n\n        } else {\n\n            /* generate privilege trap */\n\n        }\n\n        break;\n\n    case OPC2_32_SYS_RSLCX:\n\n        gen_helper_rslcx(cpu_env);\n\n        break;\n\n    case OPC2_32_SYS_SVLCX:\n\n        gen_helper_svlcx(cpu_env);\n\n        break;\n\n    case OPC2_32_SYS_RESTORE:\n\n        if (tricore_feature(env, TRICORE_FEATURE_16)) {\n\n            if ((ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_SM ||\n\n                (ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_UM1) {\n\n                tcg_gen_deposit_tl(cpu_ICR, cpu_ICR, cpu_gpr_d[r1], 8, 1);\n\n            } /* else raise privilege trap */\n\n        } /* else raise illegal opcode trap */\n\n        break;\n\n    case OPC2_32_SYS_TRAPSV:\n\n        l1 = gen_new_label();\n\n        tcg_gen_brcondi_tl(TCG_COND_GE, cpu_PSW_SV, 0, l1);\n\n        generate_trap(ctx, TRAPC_ASSERT, TIN5_SOVF);\n\n        gen_set_label(l1);\n\n        break;\n\n    case OPC2_32_SYS_TRAPV:\n\n        l1 = gen_new_label();\n\n        tcg_gen_brcondi_tl(TCG_COND_GE, cpu_PSW_V, 0, l1);\n\n        generate_trap(ctx, TRAPC_ASSERT, TIN5_OVF);\n\n        gen_set_label(l1);\n\n        break;\n\n    }\n\n}\n", "idx": 27129, "_split": "test", "_hash": "b145ad8523ec74b4ff5dc5da47d8dc90"}
{"project": "qemu", "commit_id": "80e1eea37a25a7696137e680285e36d0bfdc9f34", "target": 1, "func": "static void pci_hotplug(void)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QOSState *qs;\n\n    const char *arch = qtest_get_arch();\n\n\n\n    qs = pci_test_start();\n\n\n\n    /* plug secondary disk */\n\n    qpci_plug_device_test(\"virtio-blk-pci\", \"drv1\", PCI_SLOT_HP,\n\n                          \"'drive': 'drive1'\");\n\n\n\n    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);\n\n    g_assert(dev);\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev);\n\n\n\n    /* unplug secondary disk */\n\n    if (strcmp(arch, \"i386\") == 0 || strcmp(arch, \"x86_64\") == 0) {\n\n        qpci_unplug_acpi_device_test(\"drv1\", PCI_SLOT_HP);\n\n    }\n\n    qtest_shutdown(qs);\n\n}\n", "idx": 27148, "_split": "test", "_hash": "a457750e66df26cee8ad273cf86ab34e"}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "int gen_intermediate_code_internal (CPUState *env, TranslationBlock *tb,\n\n                                    int search_pc)\n\n{\n\n    DisasContext ctx, *ctxp = &ctx;\n\n    opc_handler_t **table, *handler;\n\n    target_ulong pc_start;\n\n    uint16_t *gen_opc_end;\n\n    int j, lj = -1;\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_ptr = gen_opc_buf;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    gen_opparam_ptr = gen_opparam_buf;\n\n    nb_gen_labels = 0;\n\n    ctx.nip = pc_start;\n\n    ctx.tb = tb;\n\n    ctx.exception = EXCP_NONE;\n\n    ctx.spr_cb = env->spr_cb;\n\n#if defined(CONFIG_USER_ONLY)\n\n    ctx.mem_idx = msr_le;\n\n#else\n\n    ctx.supervisor = 1 - msr_pr;\n\n    ctx.mem_idx = ((1 - msr_pr) << 1) | msr_le;\n\n#endif\n\n    ctx.fpu_enabled = msr_fp;\n\n    ctx.singlestep_enabled = env->singlestep_enabled;\n\n#if defined (DO_SINGLE_STEP) && 0\n\n    /* Single step trace mode */\n\n    msr_se = 1;\n\n#endif\n\n    /* Set env in case of segfault during code fetch */\n\n    while (ctx.exception == EXCP_NONE && gen_opc_ptr < gen_opc_end) {\n\n        if (unlikely(env->nb_breakpoints > 0)) {\n\n            for (j = 0; j < env->nb_breakpoints; j++) {\n\n                if (env->breakpoints[j] == ctx.nip) {\n\n                    gen_op_update_nip(ctx.nip); \n\n                    gen_op_debug();\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (unlikely(search_pc)) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n                gen_opc_pc[lj] = ctx.nip;\n\n                gen_opc_instr_start[lj] = 1;\n\n            }\n\n        }\n\n#if defined PPC_DEBUG_DISAS\n\n        if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n            fprintf(logfile, \"----------------\\n\");\n\n            fprintf(logfile, \"nip=%08x super=%d ir=%d\\n\",\n\n                    ctx.nip, 1 - msr_pr, msr_ir);\n\n        }\n\n#endif\n\n        ctx.opcode = ldl_code(ctx.nip);\n\n        if (msr_le) {\n\n            ctx.opcode = ((ctx.opcode & 0xFF000000) >> 24) |\n\n                ((ctx.opcode & 0x00FF0000) >> 8) |\n\n                ((ctx.opcode & 0x0000FF00) << 8) |\n\n                ((ctx.opcode & 0x000000FF) << 24);\n\n        }\n\n#if defined PPC_DEBUG_DISAS\n\n        if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n            fprintf(logfile, \"translate opcode %08x (%02x %02x %02x) (%s)\\n\",\n\n                    ctx.opcode, opc1(ctx.opcode), opc2(ctx.opcode),\n\n                    opc3(ctx.opcode), msr_le ? \"little\" : \"big\");\n\n        }\n\n#endif\n\n        ctx.nip += 4;\n\n        table = env->opcodes;\n\n        handler = table[opc1(ctx.opcode)];\n\n        if (is_indirect_opcode(handler)) {\n\n            table = ind_table(handler);\n\n            handler = table[opc2(ctx.opcode)];\n\n            if (is_indirect_opcode(handler)) {\n\n                table = ind_table(handler);\n\n                handler = table[opc3(ctx.opcode)];\n\n            }\n\n        }\n\n        /* Is opcode *REALLY* valid ? */\n\n        if (unlikely(handler->handler == &gen_invalid)) {\n\n            if (loglevel > 0) {\n\n                fprintf(logfile, \"invalid/unsupported opcode: \"\n\n                        \"%02x - %02x - %02x (%08x) 0x%08x %d\\n\",\n\n                        opc1(ctx.opcode), opc2(ctx.opcode),\n\n                        opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n\n            } else {\n\n                printf(\"invalid/unsupported opcode: \"\n\n                       \"%02x - %02x - %02x (%08x) 0x%08x %d\\n\",\n\n                       opc1(ctx.opcode), opc2(ctx.opcode),\n\n                       opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n\n            }\n\n        } else {\n\n            if (unlikely((ctx.opcode & handler->inval) != 0)) {\n\n                if (loglevel > 0) {\n\n                    fprintf(logfile, \"invalid bits: %08x for opcode: \"\n\n                            \"%02x -%02x - %02x (0x%08x) (0x%08x)\\n\",\n\n                            ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                            opc2(ctx.opcode), opc3(ctx.opcode),\n\n                            ctx.opcode, ctx.nip - 4);\n\n                } else {\n\n                    printf(\"invalid bits: %08x for opcode: \"\n\n                           \"%02x -%02x - %02x (0x%08x) (0x%08x)\\n\",\n\n                           ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                           opc2(ctx.opcode), opc3(ctx.opcode),\n\n                           ctx.opcode, ctx.nip - 4);\n\n                }\n\n                RET_INVAL(ctxp);\n\n                break;\n\n            }\n\n        }\n\n        (*(handler->handler))(&ctx);\n\n#if defined(DO_PPC_STATISTICS)\n\n        handler->count++;\n\n#endif\n\n        /* Check trace mode exceptions */\n\n        if (unlikely((msr_be && ctx.exception == EXCP_BRANCH) ||\n\n                     /* Check in single step trace mode\n\n                      * we need to stop except if:\n\n                      * - rfi, trap or syscall\n\n                      * - first instruction of an exception handler\n\n                      */\n\n                     (msr_se && (ctx.nip < 0x100 ||\n\n                                 ctx.nip > 0xF00 ||\n\n                                 (ctx.nip & 0xFC) != 0x04) &&\n\n                      ctx.exception != EXCP_SYSCALL &&\n\n                      ctx.exception != EXCP_SYSCALL_USER &&\n\n                      ctx.exception != EXCP_TRAP))) {\n\n            RET_EXCP(ctxp, EXCP_TRACE, 0);\n\n        }\n\n        /* if we reach a page boundary or are single stepping, stop\n\n         * generation\n\n         */\n\n        if (unlikely(((ctx.nip & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n                     (env->singlestep_enabled))) {\n\n            break;\n\n        }\n\n#if defined (DO_SINGLE_STEP)\n\n        break;\n\n#endif\n\n    }\n\n    if (ctx.exception == EXCP_NONE) {\n\n        gen_goto_tb(&ctx, 0, ctx.nip);\n\n    } else if (ctx.exception != EXCP_BRANCH) {\n\n        gen_op_reset_T0();\n\n        /* Generate the return instruction */\n\n        gen_op_exit_tb();\n\n    }\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (unlikely(search_pc)) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n        tb->size = 0;\n\n    } else {\n\n        tb->size = ctx.nip - pc_start;\n\n    }\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel & CPU_LOG_TB_CPU) {\n\n        fprintf(logfile, \"---------------- excp: %04x\\n\", ctx.exception);\n\n        cpu_dump_state(env, logfile, fprintf, 0);\n\n    }\n\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n        int flags;\n\n        flags = msr_le;\n\n        fprintf(logfile, \"IN: %s\\n\", lookup_symbol(pc_start));\n\n        target_disas(logfile, pc_start, ctx.nip - pc_start, flags);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n    if (loglevel & CPU_LOG_TB_OP) {\n\n        fprintf(logfile, \"OP:\\n\");\n\n        dump_ops(gen_opc_buf, gen_opparam_buf);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 27169, "_split": "test", "_hash": "80f9796867ad172d1c8a5a8f2104fba0"}
{"project": "qemu", "commit_id": "2c8f86961b6eaac705be21bc98299f5517eb0b6b", "target": 1, "func": "static void test_ide_drive_cd_0(void)\n\n{\n\n    char *argv[256];\n\n    int argc, ide_idx;\n\n    Backend i;\n\n\n\n    argc = setup_common(argv, ARRAY_SIZE(argv));\n\n    for (i = 0; i <= backend_empty; i++) {\n\n        ide_idx = backend_empty - i;\n\n        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];\n\n        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),\n\n                         ide_idx, NULL, i, mbr_blank, \"\");\n\n    }\n\n    qtest_start(g_strjoinv(\" \", argv));\n\n    test_cmos();\n\n    qtest_end();\n\n}\n", "idx": 27171, "_split": "test", "_hash": "234956e5d22d2d58c8ba14f3adb4b410"}
{"project": "qemu", "commit_id": "e91e972ccfbaeba1d1416202ad1b667810a33e1f", "target": 0, "func": "int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    int ret = 0;\n\n\n\n    switch (run->exit_reason) {\n\n        case KVM_EXIT_S390_SIEIC:\n\n            ret = handle_intercept(cpu);\n\n            break;\n\n        case KVM_EXIT_S390_RESET:\n\n            qemu_system_reset_request();\n\n            break;\n\n        case KVM_EXIT_S390_TSCH:\n\n            ret = handle_tsch(cpu);\n\n            break;\n\n        case KVM_EXIT_DEBUG:\n\n            ret = kvm_arch_handle_debug_exit(cpu);\n\n            break;\n\n        default:\n\n            fprintf(stderr, \"Unknown KVM exit: %d\\n\", run->exit_reason);\n\n            break;\n\n    }\n\n\n\n    if (ret == 0) {\n\n        ret = EXCP_INTERRUPT;\n\n    }\n\n    return ret;\n\n}\n", "idx": 27254, "_split": "test", "_hash": "34564b4e8fc7aab514a3c71b59e52fe7"}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)\n\n{\n\n    PCIBus *bus = PCI_BUS(dev->bus);\n\n    PCIBus *iommu_bus = bus;\n\n\n\n    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {\n\n        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);\n\n    }\n\n    if (iommu_bus && iommu_bus->iommu_fn) {\n\n        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);\n\n    }\n\n    return &address_space_memory;\n\n}\n", "idx": 27256, "_split": "test", "_hash": "fa60b718fb4225ca266542ed282707dd"}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_eval_fbo(TCGv dst, TCGv src,\n\n                                    unsigned int fcc_offset)\n\n{\n\n    gen_mov_reg_FCC0(dst, src, fcc_offset);\n\n    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);\n\n    tcg_gen_and_tl(dst, dst, cpu_tmp0);\n\n    tcg_gen_xori_tl(dst, dst, 0x1);\n\n}\n", "idx": 27257, "_split": "test", "_hash": "4ec2227831e8c63e0a758d5728e72ed9"}
{"project": "qemu", "commit_id": "04088adbe0c5adca66adb6022723362ad90ed0fc", "target": 0, "func": "static void *mpc8544_load_device_tree(target_phys_addr_t addr,\n\n                                     uint32_t ramsize,\n\n                                     target_phys_addr_t initrd_base,\n\n                                     target_phys_addr_t initrd_size,\n\n                                     const char *kernel_cmdline)\n\n{\n\n    void *fdt = NULL;\n\n#ifdef CONFIG_FDT\n\n    uint32_t mem_reg_property[] = {0, ramsize};\n\n    char *filename;\n\n    int fdt_size;\n\n    int ret;\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, BINARY_DEVICE_TREE_FILE);\n\n    if (!filename) {\n\n        goto out;\n\n    }\n\n    fdt = load_device_tree(filename, &fdt_size);\n\n    qemu_free(filename);\n\n    if (fdt == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    /* Manipulate device tree in memory. */\n\n    ret = qemu_devtree_setprop(fdt, \"/memory\", \"reg\", mem_reg_property,\n\n                               sizeof(mem_reg_property));\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /memory/reg\\n\");\n\n\n\n    ret = qemu_devtree_setprop_cell(fdt, \"/chosen\", \"linux,initrd-start\",\n\n                                    initrd_base);\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/linux,initrd-start\\n\");\n\n\n\n    ret = qemu_devtree_setprop_cell(fdt, \"/chosen\", \"linux,initrd-end\",\n\n                                    (initrd_base + initrd_size));\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/linux,initrd-end\\n\");\n\n\n\n    ret = qemu_devtree_setprop_string(fdt, \"/chosen\", \"bootargs\",\n\n                                      kernel_cmdline);\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n\n\n    if (kvm_enabled()) {\n\n        struct dirent *dirp;\n\n        DIR *dp;\n\n        char buf[128];\n\n\n\n        if ((dp = opendir(\"/proc/device-tree/cpus/\")) == NULL) {\n\n            printf(\"Can't open directory /proc/device-tree/cpus/\\n\");\n\n            goto out;\n\n        }\n\n\n\n        buf[0] = '\\0';\n\n        while ((dirp = readdir(dp)) != NULL) {\n\n            if (strncmp(dirp->d_name, \"PowerPC\", 7) == 0) {\n\n                snprintf(buf, 128, \"/cpus/%s\", dirp->d_name);\n\n                break;\n\n            }\n\n        }\n\n        closedir(dp);\n\n        if (buf[0] == '\\0') {\n\n            printf(\"Unknow host!\\n\");\n\n            goto out;\n\n        }\n\n\n\n        mpc8544_copy_soc_cell(fdt, buf, \"clock-frequency\");\n\n        mpc8544_copy_soc_cell(fdt, buf, \"timebase-frequency\");\n\n    }\n\n\n\n    cpu_physical_memory_write (addr, (void *)fdt, fdt_size);\n\n\n\nout:\n\n#endif\n\n\n\n    return fdt;\n\n}\n", "idx": 27266, "_split": "test", "_hash": "422152e52d1ccf53a9566dfcd36e7086"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_mcbsp_s *omap_mcbsp_init(MemoryRegion *system_memory,\n\n                                            target_phys_addr_t base,\n\n                                            qemu_irq txirq, qemu_irq rxirq,\n\n                                            qemu_irq *dma, omap_clk clk)\n\n{\n\n    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *)\n\n            g_malloc0(sizeof(struct omap_mcbsp_s));\n\n\n\n    s->txirq = txirq;\n\n    s->rxirq = rxirq;\n\n    s->txdrq = dma[0];\n\n    s->rxdrq = dma[1];\n\n    s->sink_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_sink_tick, s);\n\n    s->source_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_source_tick, s);\n\n    omap_mcbsp_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_mcbsp_ops, s, \"omap-mcbsp\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 27311, "_split": "test", "_hash": "1c69e5911b353e00bc16aef71bde8bf4"}
