{"project": "qemu", "commit_id": "aa1530dec499f7525d2ccaa0e3a876dc8089ed1e", "target": 1, "func": "static void filter_mirror_setup(NetFilterState *nf, Error **errp)\n{\n    MirrorState *s = FILTER_MIRROR(nf);\n    Chardev *chr;\n    chr = qemu_chr_find(s->outdev);\n    if (chr == NULL) {\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n                  \"Device '%s' not found\", s->outdev);\n    qemu_chr_fe_init(&s->chr_out, chr, errp);", "idx": 8, "_split": "valid", "_hash": "1609c8ba869db7eace291adf01c04d42"}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int64_t sub64(const int64_t a, const int64_t b)\n\n{\n\n\treturn a - b;\n\n}\n", "idx": 10, "_split": "valid", "_hash": "3e67ef55122009d163cfee31bf1d7b97"}
{"project": "qemu", "commit_id": "089da572b956ef0f8f5b8d5917358e07892a77c2", "target": 1, "func": "void fw_cfg_add_callback(FWCfgState *s, uint16_t key, FWCfgCallback callback,\n\n                         void *callback_opaque, uint8_t *data, size_t len)\n\n{\n\n    int arch = !!(key & FW_CFG_ARCH_LOCAL);\n\n\n\n    assert(key & FW_CFG_WRITE_CHANNEL);\n\n\n\n    key &= FW_CFG_ENTRY_MASK;\n\n\n\n    assert(key < FW_CFG_MAX_ENTRY && len <= 65535);\n\n\n\n    s->entries[arch][key].data = data;\n\n    s->entries[arch][key].len = len;\n\n    s->entries[arch][key].callback_opaque = callback_opaque;\n\n    s->entries[arch][key].callback = callback;\n\n}\n", "idx": 15, "_split": "valid", "_hash": "d53d05145eccf3fa91d93fe9b380730f"}
{"project": "qemu", "commit_id": "98f343395e937fa1db3a28dfb4f303f97cfddd6c", "target": 1, "func": "static void emulated_push_error(EmulatedState *card, uint64_t code)\n\n{\n\n    EmulEvent *event = (EmulEvent *)g_malloc(sizeof(EmulEvent));\n\n\n\n    assert(event);\n\n    event->p.error.type = EMUL_ERROR;\n\n    event->p.error.code = code;\n\n    emulated_push_event(card, event);\n\n}\n", "idx": 22, "_split": "valid", "_hash": "bec514b201166b857da84d44feb1712b"}
{"project": "qemu", "commit_id": "c39ce112b60ffafbaf700853e32bea74cbb2c148", "target": 0, "func": "static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid)\n\n{\n\n    int32_t datalen;\n\n    int lun;\n\n\n\n    DPRINTF(\"do_busid_cmd: busid 0x%x\\n\", busid);\n\n    lun = busid & 7;\n\n    s->current_req = scsi_req_new(s->current_dev, 0, lun, NULL);\n\n    datalen = scsi_req_enqueue(s->current_req, buf);\n\n    s->ti_size = datalen;\n\n    if (datalen != 0) {\n\n        s->rregs[ESP_RSTAT] = STAT_TC;\n\n        s->dma_left = 0;\n\n        s->dma_counter = 0;\n\n        if (datalen > 0) {\n\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n\n        } else {\n\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n\n        }\n\n        scsi_req_continue(s->current_req);\n\n    }\n\n    s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n\n    s->rregs[ESP_RSEQ] = SEQ_CD;\n\n    esp_raise_irq(s);\n\n}\n", "idx": 51, "_split": "valid", "_hash": "ae4ca1c43d4f5d01ece8fba7d3d472b6"}
{"project": "qemu", "commit_id": "d4a63ac8b19eb208465f27fde63f3cff7018fdfd", "target": 0, "func": "static void rtas_ibm_change_msi(PowerPCCPU *cpu, sPAPRMachineState *spapr,\n\n                                uint32_t token, uint32_t nargs,\n\n                                target_ulong args, uint32_t nret,\n\n                                target_ulong rets)\n\n{\n\n    uint32_t config_addr = rtas_ld(args, 0);\n\n    uint64_t buid = rtas_ldq(args, 1);\n\n    unsigned int func = rtas_ld(args, 3);\n\n    unsigned int req_num = rtas_ld(args, 4); /* 0 == remove all */\n\n    unsigned int seq_num = rtas_ld(args, 5);\n\n    unsigned int ret_intr_type;\n\n    unsigned int irq, max_irqs = 0, num = 0;\n\n    sPAPRPHBState *phb = NULL;\n\n    PCIDevice *pdev = NULL;\n\n    spapr_pci_msi *msi;\n\n    int *config_addr_key;\n\n\n\n    switch (func) {\n\n    case RTAS_CHANGE_MSI_FN:\n\n    case RTAS_CHANGE_FN:\n\n        ret_intr_type = RTAS_TYPE_MSI;\n\n        break;\n\n    case RTAS_CHANGE_MSIX_FN:\n\n        ret_intr_type = RTAS_TYPE_MSIX;\n\n        break;\n\n    default:\n\n        error_report(\"rtas_ibm_change_msi(%u) is not implemented\", func);\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* Fins sPAPRPHBState */\n\n    phb = spapr_pci_find_phb(spapr, buid);\n\n    if (phb) {\n\n        pdev = spapr_pci_find_dev(spapr, buid, config_addr);\n\n    }\n\n    if (!phb || !pdev) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* Releasing MSIs */\n\n    if (!req_num) {\n\n        msi = (spapr_pci_msi *) g_hash_table_lookup(phb->msi, &config_addr);\n\n        if (!msi) {\n\n            trace_spapr_pci_msi(\"Releasing wrong config\", config_addr);\n\n            rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n            return;\n\n        }\n\n\n\n        xics_free(spapr->icp, msi->first_irq, msi->num);\n\n        if (msi_present(pdev)) {\n\n            spapr_msi_setmsg(pdev, 0, false, 0, num);\n\n        }\n\n        if (msix_present(pdev)) {\n\n            spapr_msi_setmsg(pdev, 0, true, 0, num);\n\n        }\n\n        g_hash_table_remove(phb->msi, &config_addr);\n\n\n\n        trace_spapr_pci_msi(\"Released MSIs\", config_addr);\n\n        rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n        rtas_st(rets, 1, 0);\n\n        return;\n\n    }\n\n\n\n    /* Enabling MSI */\n\n\n\n    /* Check if the device supports as many IRQs as requested */\n\n    if (ret_intr_type == RTAS_TYPE_MSI) {\n\n        max_irqs = msi_nr_vectors_allocated(pdev);\n\n    } else if (ret_intr_type == RTAS_TYPE_MSIX) {\n\n        max_irqs = pdev->msix_entries_nr;\n\n    }\n\n    if (!max_irqs) {\n\n        error_report(\"Requested interrupt type %d is not enabled for device %x\",\n\n                     ret_intr_type, config_addr);\n\n        rtas_st(rets, 0, -1); /* Hardware error */\n\n        return;\n\n    }\n\n    /* Correct the number if the guest asked for too many */\n\n    if (req_num > max_irqs) {\n\n        trace_spapr_pci_msi_retry(config_addr, req_num, max_irqs);\n\n        req_num = max_irqs;\n\n        irq = 0; /* to avoid misleading trace */\n\n        goto out;\n\n    }\n\n\n\n    /* Allocate MSIs */\n\n    irq = xics_alloc_block(spapr->icp, 0, req_num, false,\n\n                           ret_intr_type == RTAS_TYPE_MSI);\n\n    if (!irq) {\n\n        error_report(\"Cannot allocate MSIs for device %x\", config_addr);\n\n        rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* Setup MSI/MSIX vectors in the device (via cfgspace or MSIX BAR) */\n\n    spapr_msi_setmsg(pdev, SPAPR_PCI_MSI_WINDOW, ret_intr_type == RTAS_TYPE_MSIX,\n\n                     irq, req_num);\n\n\n\n    /* Add MSI device to cache */\n\n    msi = g_new(spapr_pci_msi, 1);\n\n    msi->first_irq = irq;\n\n    msi->num = req_num;\n\n    config_addr_key = g_new(int, 1);\n\n    *config_addr_key = config_addr;\n\n    g_hash_table_insert(phb->msi, config_addr_key, msi);\n\n\n\nout:\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    rtas_st(rets, 1, req_num);\n\n    rtas_st(rets, 2, ++seq_num);\n\n    if (nret > 3) {\n\n        rtas_st(rets, 3, ret_intr_type);\n\n    }\n\n\n\n    trace_spapr_pci_rtas_ibm_change_msi(config_addr, func, req_num, irq);\n\n}\n", "idx": 62, "_split": "valid", "_hash": "49596ff8fb6bfd0c9921f92954e3bfe6"}
{"project": "qemu", "commit_id": "3098dba01c7daab60762b6f6624ea88c0d6cb65a", "target": 0, "func": "void gdb_do_syscall(gdb_syscall_complete_cb cb, const char *fmt, ...)\n\n{\n\n    va_list va;\n\n    char buf[256];\n\n    char *p;\n\n    target_ulong addr;\n\n    uint64_t i64;\n\n    GDBState *s;\n\n\n\n    s = gdbserver_state;\n\n    if (!s)\n\n        return;\n\n    gdb_current_syscall_cb = cb;\n\n    s->state = RS_SYSCALL;\n\n#ifndef CONFIG_USER_ONLY\n\n    vm_stop(EXCP_DEBUG);\n\n#endif\n\n    s->state = RS_IDLE;\n\n    va_start(va, fmt);\n\n    p = buf;\n\n    *(p++) = 'F';\n\n    while (*fmt) {\n\n        if (*fmt == '%') {\n\n            fmt++;\n\n            switch (*fmt++) {\n\n            case 'x':\n\n                addr = va_arg(va, target_ulong);\n\n                p += snprintf(p, &buf[sizeof(buf)] - p, TARGET_FMT_lx, addr);\n\n                break;\n\n            case 'l':\n\n                if (*(fmt++) != 'x')\n\n                    goto bad_format;\n\n                i64 = va_arg(va, uint64_t);\n\n                p += snprintf(p, &buf[sizeof(buf)] - p, \"%\" PRIx64, i64);\n\n                break;\n\n            case 's':\n\n                addr = va_arg(va, target_ulong);\n\n                p += snprintf(p, &buf[sizeof(buf)] - p, TARGET_FMT_lx \"/%x\",\n\n                              addr, va_arg(va, int));\n\n                break;\n\n            default:\n\n            bad_format:\n\n                fprintf(stderr, \"gdbstub: Bad syscall format string '%s'\\n\",\n\n                        fmt - 1);\n\n                break;\n\n            }\n\n        } else {\n\n            *(p++) = *(fmt++);\n\n        }\n\n    }\n\n    *p = 0;\n\n    va_end(va);\n\n    put_packet(s, buf);\n\n#ifdef CONFIG_USER_ONLY\n\n    gdb_handlesig(s->c_cpu, 0);\n\n#else\n\n    cpu_interrupt(s->c_cpu, CPU_INTERRUPT_EXIT);\n\n#endif\n\n}\n", "idx": 71, "_split": "valid", "_hash": "6e2c2590c33465b8b6213433fd511e30"}
{"project": "qemu", "commit_id": "df1561e22df42643d769aacdcc7d6d239f243366", "target": 0, "func": "static void gen_cp0 (CPUState *env, DisasContext *ctx, uint32_t opc, int rt, int rd)\n\n{\n\n    const char *opn = \"ldst\";\n\n\n\n    switch (opc) {\n\n    case OPC_MFC0:\n\n        if (rt == 0) {\n\n            /* Treat as NOP */\n\n            return;\n\n        }\n\n        gen_mfc0(ctx, rd, ctx->opcode & 0x7);\n\n        gen_op_store_T0_gpr(rt);\n\n        opn = \"mfc0\";\n\n        break;\n\n    case OPC_MTC0:\n\n        GEN_LOAD_REG_TN(T0, rt);\n\n        gen_mtc0(ctx, rd, ctx->opcode & 0x7);\n\n        opn = \"mtc0\";\n\n        break;\n\n#ifdef TARGET_MIPS64\n\n    case OPC_DMFC0:\n\n        if (rt == 0) {\n\n            /* Treat as NOP */\n\n            return;\n\n        }\n\n        gen_dmfc0(ctx, rd, ctx->opcode & 0x7);\n\n        gen_op_store_T0_gpr(rt);\n\n        opn = \"dmfc0\";\n\n        break;\n\n    case OPC_DMTC0:\n\n        GEN_LOAD_REG_TN(T0, rt);\n\n        gen_dmtc0(ctx, rd, ctx->opcode & 0x7);\n\n        opn = \"dmtc0\";\n\n        break;\n\n#endif\n\n    case OPC_TLBWI:\n\n        opn = \"tlbwi\";\n\n        if (!env->do_tlbwi)\n\n            goto die;\n\n        gen_op_tlbwi();\n\n        break;\n\n    case OPC_TLBWR:\n\n        opn = \"tlbwr\";\n\n        if (!env->do_tlbwr)\n\n            goto die;\n\n        gen_op_tlbwr();\n\n        break;\n\n    case OPC_TLBP:\n\n        opn = \"tlbp\";\n\n        if (!env->do_tlbp)\n\n            goto die;\n\n        gen_op_tlbp();\n\n        break;\n\n    case OPC_TLBR:\n\n        opn = \"tlbr\";\n\n        if (!env->do_tlbr)\n\n            goto die;\n\n        gen_op_tlbr();\n\n        break;\n\n    case OPC_ERET:\n\n        opn = \"eret\";\n\n        save_cpu_state(ctx, 0);\n\n        gen_op_eret();\n\n        ctx->bstate = BS_EXCP;\n\n        break;\n\n    case OPC_DERET:\n\n        opn = \"deret\";\n\n        if (!(ctx->hflags & MIPS_HFLAG_DM)) {\n\n            MIPS_INVAL(opn);\n\n            generate_exception(ctx, EXCP_RI);\n\n        } else {\n\n            save_cpu_state(ctx, 0);\n\n            gen_op_deret();\n\n            ctx->bstate = BS_EXCP;\n\n        }\n\n        break;\n\n    case OPC_WAIT:\n\n        opn = \"wait\";\n\n        /* If we get an exception, we want to restart at next instruction */\n\n        ctx->pc += 4;\n\n        save_cpu_state(ctx, 1);\n\n        ctx->pc -= 4;\n\n        gen_op_wait();\n\n        ctx->bstate = BS_EXCP;\n\n        break;\n\n    default:\n\n die:\n\n        MIPS_INVAL(opn);\n\n        generate_exception(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n    MIPS_DEBUG(\"%s %s %d\", opn, regnames[rt], rd);\n\n}\n", "idx": 75, "_split": "valid", "_hash": "dc1c15346b14e1c3faed16c001b97198"}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void tricore_cpu_initfn(Object *obj)\n\n{\n\n    CPUState *cs = CPU(obj);\n\n    TriCoreCPU *cpu = TRICORE_CPU(obj);\n\n    CPUTriCoreState *env = &cpu->env;\n\n\n\n    cs->env_ptr = env;\n\n    cpu_exec_init(cs, &error_abort);\n\n\n\n    if (tcg_enabled()) {\n\n        tricore_tcg_init();\n\n    }\n\n}\n", "idx": 88, "_split": "valid", "_hash": "d39eee74e8289dd51c0697c0734111dc"}
{"project": "qemu", "commit_id": "35f754620615138aaae0ef72602f84c88fd8de0f", "target": 1, "func": "struct vhost_net *vhost_net_init(VLANClientState *backend, int devfd,\n\n                                 bool force)\n\n{\n\n\n    return NULL;\n\n}", "idx": 143, "_split": "valid", "_hash": "cb997af2607440682ea1b3848c927d53"}
{"project": "qemu", "commit_id": "3e4f910c8d490a1490409a7e381dbbb229f9d272", "target": 1, "func": "static void ehci_mem_writew(void *ptr, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    fprintf(stderr, \"EHCI doesn't handle 16-bit writes to MMIO\\n\");\n\n    exit(1);\n\n}\n", "idx": 155, "_split": "valid", "_hash": "c0845d1e9f453bf09b74276c8fba732f"}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void xendev_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->props = xendev_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n\n\n\n\n\n}", "idx": 161, "_split": "valid", "_hash": "abf1a881857ef25901fbcc9ae3b864ca"}
{"project": "qemu", "commit_id": "1fa795a853255fcc93e5d3e2a92d161a2ed96eb8", "target": 1, "func": "static uint64_t qdev_get_prop_mask64(Property *prop)\n\n{\n\n    assert(prop->info == &qdev_prop_bit);\n\n    return 0x1 << prop->bitnr;\n\n}\n", "idx": 162, "_split": "valid", "_hash": "cd13a176a877739c80e2538c9611de6d"}
{"project": "qemu", "commit_id": "2662a059aa2affddfbe42e78b11c802cf30a970f", "target": 0, "func": "static int create_ppc_opcodes (CPUPPCState *env, ppc_def_t *def)\n\n{\n\n    opcode_t *opc, *start, *end;\n\n\n\n    fill_new_table(env->opcodes, 0x40);\n\n#if defined(PPC_DUMP_CPU)\n\n    printf(\"* PowerPC instructions for PVR %08x: %s flags %016\" PRIx64\n\n           \" %08x\\n\",\n\n           def->pvr, def->name, def->insns_flags, def->flags);\n\n#endif\n\n    if (&opc_start < &opc_end) {\n\n        start = &opc_start;\n\n        end = &opc_end;\n\n    } else {\n\n        start = &opc_end;\n\n        end = &opc_start;\n\n    }\n\n    for (opc = start + 1; opc != end; opc++) {\n\n        if ((opc->handler.type & def->insns_flags) != 0) {\n\n            if (register_insn(env->opcodes, opc) < 0) {\n\n                printf(\"*** ERROR initializing PowerPC instruction \"\n\n                       \"0x%02x 0x%02x 0x%02x\\n\", opc->opc1, opc->opc2,\n\n                       opc->opc3);\n\n                return -1;\n\n            }\n\n#if defined(PPC_DUMP_CPU)\n\n            if (opc1 != 0x00) {\n\n                if (opc->opc3 == 0xFF) {\n\n                    if (opc->opc2 == 0xFF) {\n\n                        printf(\" %02x -- -- (%2d ----) : %s\\n\",\n\n                               opc->opc1, opc->opc1, opc->oname);\n\n                    } else {\n\n                        printf(\" %02x %02x -- (%2d %4d) : %s\\n\",\n\n                               opc->opc1, opc->opc2, opc->opc1, opc->opc2,\n\n                               opc->oname);\n\n                    }\n\n                } else {\n\n                    printf(\" %02x %02x %02x (%2d %4d) : %s\\n\",\n\n                           opc->opc1, opc->opc2, opc->opc3,\n\n                           opc->opc1, (opc->opc3 << 5) | opc->opc2,\n\n                           opc->oname);\n\n                }\n\n            }\n\n#endif\n\n        }\n\n    }\n\n    fix_opcode_tables(env->opcodes);\n\n    fflush(stdout);\n\n    fflush(stderr);\n\n\n\n    return 0;\n\n}\n", "idx": 166, "_split": "valid", "_hash": "257bb363ffdd928cb8545b1662116f48"}
{"project": "qemu", "commit_id": "12b7f57e2cfcd665cf5a21b4ae3c23b9361c5c05", "target": 0, "func": "static void smp_parse(const char *optarg)\n\n{\n\n    int smp, sockets = 0, threads = 0, cores = 0;\n\n    char *endptr;\n\n    char option[128];\n\n\n\n    smp = strtoul(optarg, &endptr, 10);\n\n    if (endptr != optarg) {\n\n        if (*endptr == ',') {\n\n            endptr++;\n\n        }\n\n    }\n\n    if (get_param_value(option, 128, \"sockets\", endptr) != 0)\n\n        sockets = strtoull(option, NULL, 10);\n\n    if (get_param_value(option, 128, \"cores\", endptr) != 0)\n\n        cores = strtoull(option, NULL, 10);\n\n    if (get_param_value(option, 128, \"threads\", endptr) != 0)\n\n        threads = strtoull(option, NULL, 10);\n\n    if (get_param_value(option, 128, \"maxcpus\", endptr) != 0)\n\n        max_cpus = strtoull(option, NULL, 10);\n\n\n\n    /* compute missing values, prefer sockets over cores over threads */\n\n    if (smp == 0 || sockets == 0) {\n\n        sockets = sockets > 0 ? sockets : 1;\n\n        cores = cores > 0 ? cores : 1;\n\n        threads = threads > 0 ? threads : 1;\n\n        if (smp == 0) {\n\n            smp = cores * threads * sockets;\n\n        }\n\n    } else {\n\n        if (cores == 0) {\n\n            threads = threads > 0 ? threads : 1;\n\n            cores = smp / (sockets * threads);\n\n        } else {\n\n            threads = smp / (cores * sockets);\n\n        }\n\n    }\n\n    smp_cpus = smp;\n\n    smp_cores = cores > 0 ? cores : 1;\n\n    smp_threads = threads > 0 ? threads : 1;\n\n    if (max_cpus == 0)\n\n        max_cpus = smp_cpus;\n\n}\n", "idx": 174, "_split": "valid", "_hash": "2cde30853765dff0dbed14f88d7f265c"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_pwt_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n\n\n    if (size != 1) {\n\n        return omap_badwidth_read8(opaque, addr);\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* FRC */\n\n        return s->frc;\n\n    case 0x04:\t/* VCR */\n\n        return s->vrc;\n\n    case 0x08:\t/* GCR */\n\n        return s->gcr;\n\n    }\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 227, "_split": "valid", "_hash": "97fbfc758ed77493bc2449b28ad958bf"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "uint32_t lduw_be_phys(target_phys_addr_t addr)\n\n{\n\n    return lduw_phys_internal(addr, DEVICE_BIG_ENDIAN);\n\n}\n", "idx": 235, "_split": "valid", "_hash": "c0bc487650b3874ecf1e11a65b4a371d"}
{"project": "qemu", "commit_id": "240ce26a0533a6e5ee472789fbfbd9f7f939197e", "target": 1, "func": "gen_intermediate_code_internal(MIPSCPU *cpu, TranslationBlock *tb,\n\n                               bool search_pc)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUMIPSState *env = &cpu->env;\n\n    DisasContext ctx;\n\n    target_ulong pc_start;\n\n    uint16_t *gen_opc_end;\n\n    CPUBreakpoint *bp;\n\n    int j, lj = -1;\n\n    int num_insns;\n\n    int max_insns;\n\n    int insn_bytes;\n\n    int is_branch;\n\n\n\n    if (search_pc)\n\n        qemu_log(\"search pc %d\\n\", search_pc);\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;\n\n    ctx.pc = pc_start;\n\n    ctx.saved_pc = -1;\n\n    ctx.singlestep_enabled = cs->singlestep_enabled;\n\n    ctx.insn_flags = env->insn_flags;\n\n    ctx.tb = tb;\n\n    ctx.bstate = BS_NONE;\n\n    /* Restore delay slot state from the tb context.  */\n\n    ctx.hflags = (uint32_t)tb->flags; /* FIXME: maybe use 64 bits here? */\n\n    restore_cpu_state(env, &ctx);\n\n#ifdef CONFIG_USER_ONLY\n\n        ctx.mem_idx = MIPS_HFLAG_UM;\n\n#else\n\n        ctx.mem_idx = ctx.hflags & MIPS_HFLAG_KSU;\n\n#endif\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n    LOG_DISAS(\"\\ntb %p idx %d hflags %04x\\n\", tb, ctx.mem_idx, ctx.hflags);\n\n    gen_tb_start();\n\n    while (ctx.bstate == BS_NONE) {\n\n        if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {\n\n            QTAILQ_FOREACH(bp, &env->breakpoints, entry) {\n\n                if (bp->pc == ctx.pc) {\n\n                    save_cpu_state(&ctx, 1);\n\n                    ctx.bstate = BS_BRANCH;\n\n                    gen_helper_0e0i(raise_exception, EXCP_DEBUG);\n\n                    /* Include the breakpoint location or the tb won't\n\n                     * be flushed when it must be.  */\n\n                    ctx.pc += 4;\n\n                    goto done_generating;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (search_pc) {\n\n            j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n            }\n\n            tcg_ctx.gen_opc_pc[lj] = ctx.pc;\n\n            gen_opc_hflags[lj] = ctx.hflags & MIPS_HFLAG_BMASK;\n\n            gen_opc_btarget[lj] = ctx.btarget;\n\n            tcg_ctx.gen_opc_instr_start[lj] = 1;\n\n            tcg_ctx.gen_opc_icount[lj] = num_insns;\n\n        }\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n\n\n        is_branch = 0;\n\n        if (!(ctx.hflags & MIPS_HFLAG_M16)) {\n\n            ctx.opcode = cpu_ldl_code(env, ctx.pc);\n\n            insn_bytes = 4;\n\n            decode_opc(env, &ctx, &is_branch);\n\n        } else if (ctx.insn_flags & ASE_MICROMIPS) {\n\n            ctx.opcode = cpu_lduw_code(env, ctx.pc);\n\n            insn_bytes = decode_micromips_opc(env, &ctx, &is_branch);\n\n        } else if (ctx.insn_flags & ASE_MIPS16) {\n\n            ctx.opcode = cpu_lduw_code(env, ctx.pc);\n\n            insn_bytes = decode_mips16_opc(env, &ctx, &is_branch);\n\n        } else {\n\n            generate_exception(&ctx, EXCP_RI);\n\n            ctx.bstate = BS_STOP;\n\n            break;\n\n        }\n\n        if (!is_branch) {\n\n            handle_delay_slot(&ctx, insn_bytes);\n\n        }\n\n        ctx.pc += insn_bytes;\n\n\n\n        num_insns++;\n\n\n\n        /* Execute a branch and its delay slot as a single instruction.\n\n           This is what GDB expects and is consistent with what the\n\n           hardware does (e.g. if a delay slot instruction faults, the\n\n           reported PC is the PC of the branch).  */\n\n        if (cs->singlestep_enabled && (ctx.hflags & MIPS_HFLAG_BMASK) == 0) {\n\n            break;\n\n        }\n\n\n\n        if ((ctx.pc & (TARGET_PAGE_SIZE - 1)) == 0)\n\n            break;\n\n\n\n        if (tcg_ctx.gen_opc_ptr >= gen_opc_end) {\n\n            break;\n\n        }\n\n\n\n        if (num_insns >= max_insns)\n\n            break;\n\n\n\n        if (singlestep)\n\n            break;\n\n    }\n\n    if (tb->cflags & CF_LAST_IO) {\n\n        gen_io_end();\n\n    }\n\n    if (cs->singlestep_enabled && ctx.bstate != BS_BRANCH) {\n\n        save_cpu_state(&ctx, ctx.bstate == BS_NONE);\n\n        gen_helper_0e0i(raise_exception, EXCP_DEBUG);\n\n    } else {\n\n        switch (ctx.bstate) {\n\n        case BS_STOP:\n\n            gen_goto_tb(&ctx, 0, ctx.pc);\n\n            break;\n\n        case BS_NONE:\n\n            save_cpu_state(&ctx, 0);\n\n            gen_goto_tb(&ctx, 0, ctx.pc);\n\n            break;\n\n        case BS_EXCP:\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case BS_BRANCH:\n\n        default:\n\n            break;\n\n        }\n\n    }\n\ndone_generating:\n\n    gen_tb_end(tb, num_insns);\n\n    *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = ctx.pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n#ifdef DEBUG_DISAS\n\n    LOG_DISAS(\"\\n\");\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(env, pc_start, ctx.pc - pc_start, 0);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n}\n", "idx": 255, "_split": "valid", "_hash": "9d7a95fbbd5ce40713eb969b42f68255"}
{"project": "qemu", "commit_id": "f332e830e38b3ff3953ef02ac04e409ae53769c5", "target": 1, "func": "static void parse_type_bool(Visitor *v, const char *name, bool *obj,\n\n                            Error **errp)\n\n{\n\n    StringInputVisitor *siv = to_siv(v);\n\n\n\n    if (siv->string) {\n\n        if (!strcasecmp(siv->string, \"on\") ||\n\n            !strcasecmp(siv->string, \"yes\") ||\n\n            !strcasecmp(siv->string, \"true\")) {\n\n            *obj = true;\n\n            return;\n\n        }\n\n        if (!strcasecmp(siv->string, \"off\") ||\n\n            !strcasecmp(siv->string, \"no\") ||\n\n            !strcasecmp(siv->string, \"false\")) {\n\n            *obj = false;\n\n            return;\n\n        }\n\n    }\n\n\n\n    error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n               \"boolean\");\n\n}\n", "idx": 257, "_split": "valid", "_hash": "52614dd09f4af124adf6864e69b188ce"}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void musb_rx_req(MUSBState *s, int epnum)\n\n{\n\n    MUSBEndPoint *ep = s->ep + epnum;\n\n    int total;\n\n\n\n    /* If we already have a packet, which didn't fit into the\n\n     * 64 bytes of the FIFO, only move the FIFO start and return. (Obsolete) */\n\n    if (ep->packey[1].p.pid == USB_TOKEN_IN && ep->status[1] >= 0 &&\n\n                    (ep->fifostart[1]) + ep->rxcount <\n\n                    ep->packey[1].p.len) {\n\n        TRACE(\"0x%08x, %d\",  ep->fifostart[1], ep->rxcount );\n\n        ep->fifostart[1] += ep->rxcount;\n\n        ep->fifolen[1] = 0;\n\n\n\n        ep->rxcount = MIN(ep->packey[0].p.len - (ep->fifostart[1]),\n\n                        ep->maxp[1]);\n\n\n\n        ep->csr[1] &= ~MGC_M_RXCSR_H_REQPKT;\n\n        if (!epnum)\n\n            ep->csr[0] &= ~MGC_M_CSR0_H_REQPKT;\n\n\n\n        /* Clear all of the error bits first */\n\n        ep->csr[1] &= ~(MGC_M_RXCSR_H_ERROR | MGC_M_RXCSR_H_RXSTALL |\n\n                        MGC_M_RXCSR_DATAERROR);\n\n        if (!epnum)\n\n            ep->csr[0] &= ~(MGC_M_CSR0_H_ERROR | MGC_M_CSR0_H_RXSTALL |\n\n                            MGC_M_CSR0_H_NAKTIMEOUT | MGC_M_CSR0_H_NO_PING);\n\n\n\n        ep->csr[1] |= MGC_M_RXCSR_FIFOFULL | MGC_M_RXCSR_RXPKTRDY;\n\n        if (!epnum)\n\n            ep->csr[0] |= MGC_M_CSR0_RXPKTRDY;\n\n        musb_rx_intr_set(s, epnum, 1);\n\n        return;\n\n    }\n\n\n\n    /* The driver sets maxp[1] to 64 or less because it knows the hardware\n\n     * FIFO is this deep.  Bigger packets get split in\n\n     * usb_generic_handle_packet but we can also do the splitting locally\n\n     * for performance.  It turns out we can also have a bigger FIFO and\n\n     * ignore the limit set in ep->maxp[1].  The Linux MUSB driver deals\n\n     * OK with single packets of even 32KB and we avoid splitting, however\n\n     * usb_msd.c sometimes sends a packet bigger than what Linux expects\n\n     * (e.g. 8192 bytes instead of 4096) and we get an OVERRUN.  Splitting\n\n     * hides this overrun from Linux.  Up to 4096 everything is fine\n\n     * though.  Currently this is disabled.\n\n     *\n\n     * XXX: mind ep->fifosize.  */\n\n    total = MIN(ep->maxp[1] & 0x3ff, sizeof(s->buf));\n\n\n\n#ifdef SETUPLEN_HACK\n\n    /* Why should *we* do that instead of Linux?  */\n\n    if (!epnum) {\n\n        if (ep->packey[0].p.devaddr == 2) {\n\n            total = MIN(s->setup_len, 8);\n\n        } else {\n\n            total = MIN(s->setup_len, 64);\n\n        }\n\n        s->setup_len -= total;\n\n    }\n\n#endif\n\n\n\n    return musb_packet(s, ep, epnum, USB_TOKEN_IN,\n\n                    total, musb_rx_packet_complete, 1);\n\n}\n", "idx": 274, "_split": "valid", "_hash": "15c599c5fb787025f4d20fdc492b07f8"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t sp804_read(void *opaque, target_phys_addr_t offset,\n\n                           unsigned size)\n\n{\n\n    sp804_state *s = (sp804_state *)opaque;\n\n\n\n    if (offset < 0x20) {\n\n        return arm_timer_read(s->timer[0], offset);\n\n    }\n\n    if (offset < 0x40) {\n\n        return arm_timer_read(s->timer[1], offset - 0x20);\n\n    }\n\n\n\n    /* TimerPeriphID */\n\n    if (offset >= 0xfe0 && offset <= 0xffc) {\n\n        return sp804_ids[(offset - 0xfe0) >> 2];\n\n    }\n\n\n\n    switch (offset) {\n\n    /* Integration Test control registers, which we won't support */\n\n    case 0xf00: /* TimerITCR */\n\n    case 0xf04: /* TimerITOP (strictly write only but..) */\n\n        return 0;\n\n    }\n\n\n\n    hw_error(\"%s: Bad offset %x\\n\", __func__, (int)offset);\n\n    return 0;\n\n}\n", "idx": 292, "_split": "valid", "_hash": "d69150c7336ea93236fe561adbe7cec9"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void timerlist_rearm(QEMUTimerList *timer_list)\n\n{\n\n    /* Interrupt execution to force deadline recalculation.  */\n\n    if (timer_list->clock->type == QEMU_CLOCK_VIRTUAL) {\n\n        qemu_start_warp_timer();\n\n    }\n\n    timerlist_notify(timer_list);\n\n}\n", "idx": 298, "_split": "valid", "_hash": "6fefce5e96afb488237a5b97872fdb31"}
{"project": "qemu", "commit_id": "c21bbcfa3ff4f6dc49fb01080ef598851aa424dd", "target": 0, "func": "CharDriverState *text_console_init(DisplayState *ds, const char *p)\n\n{\n\n    CharDriverState *chr;\n\n    TextConsole *s;\n\n    unsigned width;\n\n    unsigned height;\n\n    static int color_inited;\n\n\n\n    chr = qemu_mallocz(sizeof(CharDriverState));\n\n    if (!chr)\n\n        return NULL;\n\n    s = new_console(ds, TEXT_CONSOLE);\n\n    if (!s) {\n\n        free(chr);\n\n        return NULL;\n\n    }\n\n    if (!p)\n\n        p = DEFAULT_MONITOR_SIZE;\n\n\n\n    chr->opaque = s;\n\n    chr->chr_write = console_puts;\n\n    chr->chr_send_event = console_send_event;\n\n\n\n    s->chr = chr;\n\n    s->out_fifo.buf = s->out_fifo_buf;\n\n    s->out_fifo.buf_size = sizeof(s->out_fifo_buf);\n\n    s->kbd_timer = qemu_new_timer(rt_clock, kbd_send_chars, s);\n\n\n\n    if (!color_inited) {\n\n        color_inited = 1;\n\n        console_color_init(s->ds);\n\n    }\n\n    s->y_displayed = 0;\n\n    s->y_base = 0;\n\n    s->total_height = DEFAULT_BACKSCROLL;\n\n    s->x = 0;\n\n    s->y = 0;\n\n    width = s->ds->width;\n\n    height = s->ds->height;\n\n    if (p != 0) {\n\n        width = strtoul(p, (char **)&p, 10);\n\n        if (*p == 'C') {\n\n            p++;\n\n            width *= FONT_WIDTH;\n\n        }\n\n        if (*p == 'x') {\n\n            p++;\n\n            height = strtoul(p, (char **)&p, 10);\n\n            if (*p == 'C') {\n\n                p++;\n\n                height *= FONT_HEIGHT;\n\n            }\n\n        }\n\n    }\n\n    s->g_width = width;\n\n    s->g_height = height;\n\n\n\n    s->hw_invalidate = text_console_invalidate;\n\n    s->hw_text_update = text_console_update;\n\n    s->hw = s;\n\n\n\n    /* Set text attribute defaults */\n\n    s->t_attrib_default.bold = 0;\n\n    s->t_attrib_default.uline = 0;\n\n    s->t_attrib_default.blink = 0;\n\n    s->t_attrib_default.invers = 0;\n\n    s->t_attrib_default.unvisible = 0;\n\n    s->t_attrib_default.fgcol = COLOR_WHITE;\n\n    s->t_attrib_default.bgcol = COLOR_BLACK;\n\n\n\n    /* set current text attributes to default */\n\n    s->t_attrib = s->t_attrib_default;\n\n    text_console_resize(s);\n\n\n\n    qemu_chr_reset(chr);\n\n\n\n    return chr;\n\n}\n", "idx": 300, "_split": "valid", "_hash": "c1f09c9e185960bcbe0c9673532d648c"}
{"project": "qemu", "commit_id": "c19f47bf5e8fe3dbd10206a52d0e6e348f803933", "target": 0, "func": "static void tcg_liveness_analysis(TCGContext *s)\n\n{\n\n    uint8_t *dead_temps, *mem_temps;\n\n    int oi, oi_prev, nb_ops;\n\n\n\n    nb_ops = s->gen_next_op_idx;\n\n    s->op_dead_args = tcg_malloc(nb_ops * sizeof(uint16_t));\n\n    s->op_sync_args = tcg_malloc(nb_ops * sizeof(uint8_t));\n\n    \n\n    dead_temps = tcg_malloc(s->nb_temps);\n\n    mem_temps = tcg_malloc(s->nb_temps);\n\n    tcg_la_func_end(s, dead_temps, mem_temps);\n\n\n\n    for (oi = s->gen_last_op_idx; oi >= 0; oi = oi_prev) {\n\n        int i, nb_iargs, nb_oargs;\n\n        TCGOpcode opc_new, opc_new2;\n\n        bool have_opc_new2;\n\n        uint16_t dead_args;\n\n        uint8_t sync_args;\n\n        TCGArg arg;\n\n\n\n        TCGOp * const op = &s->gen_op_buf[oi];\n\n        TCGArg * const args = &s->gen_opparam_buf[op->args];\n\n        TCGOpcode opc = op->opc;\n\n        const TCGOpDef *def = &tcg_op_defs[opc];\n\n\n\n        oi_prev = op->prev;\n\n\n\n        switch (opc) {\n\n        case INDEX_op_call:\n\n            {\n\n                int call_flags;\n\n\n\n                nb_oargs = op->callo;\n\n                nb_iargs = op->calli;\n\n                call_flags = args[nb_oargs + nb_iargs + 1];\n\n\n\n                /* pure functions can be removed if their result is unused */\n\n                if (call_flags & TCG_CALL_NO_SIDE_EFFECTS) {\n\n                    for (i = 0; i < nb_oargs; i++) {\n\n                        arg = args[i];\n\n                        if (!dead_temps[arg] || mem_temps[arg]) {\n\n                            goto do_not_remove_call;\n\n                        }\n\n                    }\n\n                    goto do_remove;\n\n                } else {\n\n                do_not_remove_call:\n\n\n\n                    /* output args are dead */\n\n                    dead_args = 0;\n\n                    sync_args = 0;\n\n                    for (i = 0; i < nb_oargs; i++) {\n\n                        arg = args[i];\n\n                        if (dead_temps[arg]) {\n\n                            dead_args |= (1 << i);\n\n                        }\n\n                        if (mem_temps[arg]) {\n\n                            sync_args |= (1 << i);\n\n                        }\n\n                        dead_temps[arg] = 1;\n\n                        mem_temps[arg] = 0;\n\n                    }\n\n\n\n                    if (!(call_flags & TCG_CALL_NO_READ_GLOBALS)) {\n\n                        /* globals should be synced to memory */\n\n                        memset(mem_temps, 1, s->nb_globals);\n\n                    }\n\n                    if (!(call_flags & (TCG_CALL_NO_WRITE_GLOBALS |\n\n                                        TCG_CALL_NO_READ_GLOBALS))) {\n\n                        /* globals should go back to memory */\n\n                        memset(dead_temps, 1, s->nb_globals);\n\n                    }\n\n\n\n                    /* input args are live */\n\n                    for (i = nb_oargs; i < nb_iargs + nb_oargs; i++) {\n\n                        arg = args[i];\n\n                        if (arg != TCG_CALL_DUMMY_ARG) {\n\n                            if (dead_temps[arg]) {\n\n                                dead_args |= (1 << i);\n\n                            }\n\n                            dead_temps[arg] = 0;\n\n                        }\n\n                    }\n\n                    s->op_dead_args[oi] = dead_args;\n\n                    s->op_sync_args[oi] = sync_args;\n\n                }\n\n            }\n\n            break;\n\n        case INDEX_op_debug_insn_start:\n\n            break;\n\n        case INDEX_op_discard:\n\n            /* mark the temporary as dead */\n\n            dead_temps[args[0]] = 1;\n\n            mem_temps[args[0]] = 0;\n\n            break;\n\n\n\n        case INDEX_op_add2_i32:\n\n            opc_new = INDEX_op_add_i32;\n\n            goto do_addsub2;\n\n        case INDEX_op_sub2_i32:\n\n            opc_new = INDEX_op_sub_i32;\n\n            goto do_addsub2;\n\n        case INDEX_op_add2_i64:\n\n            opc_new = INDEX_op_add_i64;\n\n            goto do_addsub2;\n\n        case INDEX_op_sub2_i64:\n\n            opc_new = INDEX_op_sub_i64;\n\n        do_addsub2:\n\n            nb_iargs = 4;\n\n            nb_oargs = 2;\n\n            /* Test if the high part of the operation is dead, but not\n\n               the low part.  The result can be optimized to a simple\n\n               add or sub.  This happens often for x86_64 guest when the\n\n               cpu mode is set to 32 bit.  */\n\n            if (dead_temps[args[1]] && !mem_temps[args[1]]) {\n\n                if (dead_temps[args[0]] && !mem_temps[args[0]]) {\n\n                    goto do_remove;\n\n                }\n\n                /* Replace the opcode and adjust the args in place,\n\n                   leaving 3 unused args at the end.  */\n\n                op->opc = opc = opc_new;\n\n                args[1] = args[2];\n\n                args[2] = args[4];\n\n                /* Fall through and mark the single-word operation live.  */\n\n                nb_iargs = 2;\n\n                nb_oargs = 1;\n\n            }\n\n            goto do_not_remove;\n\n\n\n        case INDEX_op_mulu2_i32:\n\n            opc_new = INDEX_op_mul_i32;\n\n            opc_new2 = INDEX_op_muluh_i32;\n\n            have_opc_new2 = TCG_TARGET_HAS_muluh_i32;\n\n            goto do_mul2;\n\n        case INDEX_op_muls2_i32:\n\n            opc_new = INDEX_op_mul_i32;\n\n            opc_new2 = INDEX_op_mulsh_i32;\n\n            have_opc_new2 = TCG_TARGET_HAS_mulsh_i32;\n\n            goto do_mul2;\n\n        case INDEX_op_mulu2_i64:\n\n            opc_new = INDEX_op_mul_i64;\n\n            opc_new2 = INDEX_op_muluh_i64;\n\n            have_opc_new2 = TCG_TARGET_HAS_muluh_i64;\n\n            goto do_mul2;\n\n        case INDEX_op_muls2_i64:\n\n            opc_new = INDEX_op_mul_i64;\n\n            opc_new2 = INDEX_op_mulsh_i64;\n\n            have_opc_new2 = TCG_TARGET_HAS_mulsh_i64;\n\n            goto do_mul2;\n\n        do_mul2:\n\n            nb_iargs = 2;\n\n            nb_oargs = 2;\n\n            if (dead_temps[args[1]] && !mem_temps[args[1]]) {\n\n                if (dead_temps[args[0]] && !mem_temps[args[0]]) {\n\n                    /* Both parts of the operation are dead.  */\n\n                    goto do_remove;\n\n                }\n\n                /* The high part of the operation is dead; generate the low. */\n\n                op->opc = opc = opc_new;\n\n                args[1] = args[2];\n\n                args[2] = args[3];\n\n            } else if (have_opc_new2 && dead_temps[args[0]]\n\n                       && !mem_temps[args[0]]) {\n\n                /* The low part of the operation is dead; generate the high. */\n\n                op->opc = opc = opc_new2;\n\n                args[0] = args[1];\n\n                args[1] = args[2];\n\n                args[2] = args[3];\n\n            } else {\n\n                goto do_not_remove;\n\n            }\n\n            /* Mark the single-word operation live.  */\n\n            nb_oargs = 1;\n\n            goto do_not_remove;\n\n\n\n        default:\n\n            /* XXX: optimize by hardcoding common cases (e.g. triadic ops) */\n\n            nb_iargs = def->nb_iargs;\n\n            nb_oargs = def->nb_oargs;\n\n\n\n            /* Test if the operation can be removed because all\n\n               its outputs are dead. We assume that nb_oargs == 0\n\n               implies side effects */\n\n            if (!(def->flags & TCG_OPF_SIDE_EFFECTS) && nb_oargs != 0) {\n\n                for (i = 0; i < nb_oargs; i++) {\n\n                    arg = args[i];\n\n                    if (!dead_temps[arg] || mem_temps[arg]) {\n\n                        goto do_not_remove;\n\n                    }\n\n                }\n\n            do_remove:\n\n                tcg_op_remove(s, op);\n\n            } else {\n\n            do_not_remove:\n\n                /* output args are dead */\n\n                dead_args = 0;\n\n                sync_args = 0;\n\n                for (i = 0; i < nb_oargs; i++) {\n\n                    arg = args[i];\n\n                    if (dead_temps[arg]) {\n\n                        dead_args |= (1 << i);\n\n                    }\n\n                    if (mem_temps[arg]) {\n\n                        sync_args |= (1 << i);\n\n                    }\n\n                    dead_temps[arg] = 1;\n\n                    mem_temps[arg] = 0;\n\n                }\n\n\n\n                /* if end of basic block, update */\n\n                if (def->flags & TCG_OPF_BB_END) {\n\n                    tcg_la_bb_end(s, dead_temps, mem_temps);\n\n                } else if (def->flags & TCG_OPF_SIDE_EFFECTS) {\n\n                    /* globals should be synced to memory */\n\n                    memset(mem_temps, 1, s->nb_globals);\n\n                }\n\n\n\n                /* input args are live */\n\n                for (i = nb_oargs; i < nb_oargs + nb_iargs; i++) {\n\n                    arg = args[i];\n\n                    if (dead_temps[arg]) {\n\n                        dead_args |= (1 << i);\n\n                    }\n\n                    dead_temps[arg] = 0;\n\n                }\n\n                s->op_dead_args[oi] = dead_args;\n\n                s->op_sync_args[oi] = sync_args;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 301, "_split": "valid", "_hash": "f096b14dbb080521ef17d59f99e67412"}
{"project": "qemu", "commit_id": "13f59ae8157e8ec238fa8aefe5309909a1eeb7e2", "target": 0, "func": "bool error_is_type(Error *err, const char *fmt)\n\n{\n\n    const char *error_class;\n\n    char *ptr;\n\n    char *end;\n\n\n\n    if (!err) {\n\n        return false;\n\n    }\n\n\n\n    ptr = strstr(fmt, \"'class': '\");\n\n    assert(ptr != NULL);\n\n    ptr += strlen(\"'class': '\");\n\n\n\n    end = strchr(ptr, '\\'');\n\n    assert(end != NULL);\n\n\n\n    error_class = error_get_field(err, \"class\");\n\n    if (strlen(error_class) != end - ptr) {\n\n        return false;\n\n    }\n\n\n\n    return strncmp(ptr, error_class, end - ptr) == 0;\n\n}\n", "idx": 311, "_split": "valid", "_hash": "fe13c1aa9062ac8fa7e1a20981a31ca2"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline int onenand_load_main(OneNANDState *s, int sec, int secn,\n\n                void *dest)\n\n{\n\n    if (s->bdrv_cur)\n\n        return bdrv_read(s->bdrv_cur, sec, dest, secn) < 0;\n\n    else if (sec + secn > s->secs_cur)\n\n        return 1;\n\n\n\n    memcpy(dest, s->current + (sec << 9), secn << 9);\n\n\n\n    return 0;\n\n}\n", "idx": 319, "_split": "valid", "_hash": "b38e276b7a987aed46685d54dbdb890c"}
{"project": "qemu", "commit_id": "c527e0afcd7d719abc3a5ca5e4c8ac2fe48b999f", "target": 1, "func": "vmxnet3_pop_next_tx_descr(VMXNET3State *s,\n\n                          int qidx,\n\n                          struct Vmxnet3_TxDesc *txd,\n\n                          uint32_t *descr_idx)\n\n{\n\n    Vmxnet3Ring *ring = &s->txq_descr[qidx].tx_ring;\n\n    PCIDevice *d = PCI_DEVICE(s);\n\n\n\n    vmxnet3_ring_read_curr_cell(d, ring, txd);\n\n    if (txd->gen == vmxnet3_ring_curr_gen(ring)) {\n\n        /* Only read after generation field verification */\n\n        smp_rmb();\n\n        /* Re-read to be sure we got the latest version */\n\n        vmxnet3_ring_read_curr_cell(d, ring, txd);\n\n        VMXNET3_RING_DUMP(VMW_RIPRN, \"TX\", qidx, ring);\n\n        *descr_idx = vmxnet3_ring_curr_cell_idx(ring);\n\n        vmxnet3_inc_tx_consumption_counter(s, qidx);\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 345, "_split": "valid", "_hash": "e6960d03a0ea16145f4dd0d1ae2b2430"}
{"project": "qemu", "commit_id": "faadf50e2962dd54175647a80bd6fc4319c91973", "target": 1, "func": "static void init_excp_BookE (CPUPPCState *env)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->excp_vectors[POWERPC_EXCP_CRITICAL] = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_APU]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_FIT]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_WDT]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_DTLB]     = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_ITLB]     = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_DEBUG]    = 0x00000000;\n\n    env->excp_prefix = 0x00000000;\n\n    env->ivor_mask = 0x0000FFE0;\n\n    env->ivpr_mask = 0xFFFF0000;\n\n    /* Hardware reset vector */\n\n    env->hreset_vector = 0xFFFFFFFCUL;\n\n#endif\n\n}\n", "idx": 346, "_split": "valid", "_hash": "5bdf40a084e40fe2d52eddbefabd3dd1"}
{"project": "qemu", "commit_id": "0ccb9c1d8128a020720d5c6abf99a470742a1b94", "target": 1, "func": "DISAS_INSN(divw)\n\n{\n\n    TCGv reg;\n\n    TCGv tmp;\n\n    TCGv src;\n\n    int sign;\n\n\n\n    sign = (insn & 0x100) != 0;\n\n    reg = DREG(insn, 9);\n\n    if (sign) {\n\n        tcg_gen_ext16s_i32(QREG_DIV1, reg);\n\n    } else {\n\n        tcg_gen_ext16u_i32(QREG_DIV1, reg);\n\n    }\n\n    SRC_EA(env, src, OS_WORD, sign, NULL);\n\n    tcg_gen_mov_i32(QREG_DIV2, src);\n\n    if (sign) {\n\n        gen_helper_divs(cpu_env, tcg_const_i32(1));\n\n    } else {\n\n        gen_helper_divu(cpu_env, tcg_const_i32(1));\n\n    }\n\n\n\n    tmp = tcg_temp_new();\n\n    src = tcg_temp_new();\n\n    tcg_gen_ext16u_i32(tmp, QREG_DIV1);\n\n    tcg_gen_shli_i32(src, QREG_DIV2, 16);\n\n    tcg_gen_or_i32(reg, tmp, src);\n\n\n\n    set_cc_op(s, CC_OP_FLAGS);\n\n}\n", "idx": 354, "_split": "valid", "_hash": "38dfa1200393d47550e2e7ccd069e513"}
{"project": "qemu", "commit_id": "65207c59d99f2260c5f1d3b9c491146616a522aa", "target": 1, "func": "static void handle_user_command(Monitor *mon, const char *cmdline)\n\n{\n\n    QDict *qdict;\n\n    const mon_cmd_t *cmd;\n\n\n\n    qdict = qdict_new();\n\n\n\n    cmd = monitor_parse_command(mon, cmdline, 0, mon->cmd_table, qdict);\n\n    if (!cmd)\n\n        goto out;\n\n\n\n    if (handler_is_async(cmd)) {\n\n        user_async_cmd_handler(mon, cmd, qdict);\n\n    } else if (handler_is_qobject(cmd)) {\n\n        QObject *data = NULL;\n\n\n\n        /* XXX: ignores the error code */\n\n        cmd->mhandler.cmd_new(mon, qdict, &data);\n\n        assert(!monitor_has_error(mon));\n\n        if (data) {\n\n            cmd->user_print(mon, data);\n\n            qobject_decref(data);\n\n        }\n\n    } else {\n\n        cmd->mhandler.cmd(mon, qdict);\n\n    }\n\n\n\nout:\n\n    QDECREF(qdict);\n\n}\n", "idx": 378, "_split": "valid", "_hash": "df3680a677a6db60aec79501a541ac97"}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_exception_return(DisasContext *s, TCGv pc)\n\n{\n\n    TCGv tmp;\n\n    store_reg(s, 15, pc);\n\n    tmp = load_cpu_field(spsr);\n\n    gen_set_cpsr(tmp, 0xffffffff);\n\n    dead_tmp(tmp);\n\n    s->is_jmp = DISAS_UPDATE;\n\n}\n", "idx": 390, "_split": "valid", "_hash": "f359a6629dc446b125a5cd71ba0fe268"}
{"project": "qemu", "commit_id": "db0289b9b26cb653d5662f5d6a2a52d70243cd56", "target": 1, "func": "static bool bdrv_drain_recurse(BlockDriverState *bs, bool begin)\n\n{\n\n    BdrvChild *child, *tmp;\n\n    bool waited;\n\n\n\n    /* Ensure any pending metadata writes are submitted to bs->file.  */\n\n    bdrv_drain_invoke(bs, begin);\n\n\n\n    /* Wait for drained requests to finish */\n\n    waited = BDRV_POLL_WHILE(bs, atomic_read(&bs->in_flight) > 0);\n\n\n\n    QLIST_FOREACH_SAFE(child, &bs->children, next, tmp) {\n\n        BlockDriverState *bs = child->bs;\n\n        bool in_main_loop =\n\n            qemu_get_current_aio_context() == qemu_get_aio_context();\n\n        assert(bs->refcnt > 0);\n\n        if (in_main_loop) {\n\n            /* In case the recursive bdrv_drain_recurse processes a\n\n             * block_job_defer_to_main_loop BH and modifies the graph,\n\n             * let's hold a reference to bs until we are done.\n\n             *\n\n             * IOThread doesn't have such a BH, and it is not safe to call\n\n             * bdrv_unref without BQL, so skip doing it there.\n\n             */\n\n            bdrv_ref(bs);\n\n        }\n\n        waited |= bdrv_drain_recurse(bs, begin);\n\n        if (in_main_loop) {\n\n            bdrv_unref(bs);\n\n        }\n\n    }\n\n\n\n    return waited;\n\n}\n", "idx": 396, "_split": "valid", "_hash": "5bc7446fa1eb0c51deec2b9d332e73ef"}
{"project": "qemu", "commit_id": "ecbb5ea1041d2894f5efb9317acd519c4fd81ad5", "target": 1, "func": "uint64_t helper_sublv (uint64_t op1, uint64_t op2)\n\n{\n\n    uint64_t tmp = op1;\n\n    op1 = (uint32_t)(op1 - op2);\n\n    if (unlikely(((~tmp) ^ op1 ^ (-1UL)) & ((~tmp) ^ op2) & (1UL << 31))) {\n\n        helper_excp(EXCP_ARITH, EXCP_ARITH_OVERFLOW);\n\n    }\n\n    return op1;\n\n}\n", "idx": 427, "_split": "valid", "_hash": "ddb8423c01911ffc855d3d2cde30d7ec"}
{"project": "qemu", "commit_id": "c8057f951d64de93bfd01569c0a725baa9f94372", "target": 1, "func": "void configure_alarms(char const *opt)\n\n{\n\n    int i;\n\n    int cur = 0;\n\n    int count = ARRAY_SIZE(alarm_timers) - 1;\n\n    char *arg;\n\n    char *name;\n\n    struct qemu_alarm_timer tmp;\n\n\n\n    if (!strcmp(opt, \"?\")) {\n\n        show_available_alarms();\n\n        exit(0);\n\n    }\n\n\n\n    arg = g_strdup(opt);\n\n\n\n    /* Reorder the array */\n\n    name = strtok(arg, \",\");\n\n    while (name) {\n\n        for (i = 0; i < count && alarm_timers[i].name; i++) {\n\n            if (!strcmp(alarm_timers[i].name, name))\n\n                break;\n\n        }\n\n\n\n        if (i == count) {\n\n            fprintf(stderr, \"Unknown clock %s\\n\", name);\n\n            goto next;\n\n        }\n\n\n\n        if (i < cur)\n\n            /* Ignore */\n\n            goto next;\n\n\n\n\t/* Swap */\n\n        tmp = alarm_timers[i];\n\n        alarm_timers[i] = alarm_timers[cur];\n\n        alarm_timers[cur] = tmp;\n\n\n\n        cur++;\n\nnext:\n\n        name = strtok(NULL, \",\");\n\n    }\n\n\n\n    g_free(arg);\n\n\n\n    if (cur) {\n\n        /* Disable remaining timers */\n\n        for (i = cur; i < count; i++)\n\n            alarm_timers[i].name = NULL;\n\n    } else {\n\n        show_available_alarms();\n\n        exit(1);\n\n    }\n\n}\n", "idx": 449, "_split": "valid", "_hash": "99632af194f2080482489c86ff97901a"}
{"project": "qemu", "commit_id": "bef0fd5958120542f126f2dedbfce65d8839a94d", "target": 0, "func": "void ide_sector_read(IDEState *s)\n\n{\n\n    int64_t sector_num;\n\n    int ret, n;\n\n\n\n    s->status = READY_STAT | SEEK_STAT;\n\n    s->error = 0; /* not needed by IDE spec, but needed by Windows */\n\n    sector_num = ide_get_sector(s);\n\n    n = s->nsector;\n\n    if (n == 0) {\n\n        /* no more sector to read from disk */\n\n        ide_transfer_stop(s);\n\n    } else {\n\n#if defined(DEBUG_IDE)\n\n        printf(\"read sector=%\" PRId64 \"\\n\", sector_num);\n\n#endif\n\n        if (n > s->req_nb_sectors)\n\n            n = s->req_nb_sectors;\n\n\n\n        bdrv_acct_start(s->bs, &s->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ);\n\n        ret = bdrv_read(s->bs, sector_num, s->io_buffer, n);\n\n        bdrv_acct_done(s->bs, &s->acct);\n\n        if (ret != 0) {\n\n            if (ide_handle_rw_error(s, -ret,\n\n                BM_STATUS_PIO_RETRY | BM_STATUS_RETRY_READ))\n\n            {\n\n                return;\n\n            }\n\n        }\n\n        ide_transfer_start(s, s->io_buffer, 512 * n, ide_sector_read);\n\n        ide_set_irq(s->bus);\n\n        ide_set_sector(s, sector_num + n);\n\n        s->nsector -= n;\n\n    }\n\n}\n", "idx": 497, "_split": "valid", "_hash": "2eb54002a2785ea903b4d590a9d9f0a6"}
{"project": "qemu", "commit_id": "249e7e0fff080df0eff54730f3b6459d92d61e5a", "target": 0, "func": "static void cpu_ioreq_pio(ioreq_t *req)\n\n{\n\n    int i;\n\n\n\n    if (req->dir == IOREQ_READ) {\n\n        if (!req->data_is_ptr) {\n\n            req->data = do_inp(req->addr, req->size);\n\n        } else {\n\n            uint32_t tmp;\n\n\n\n            for (i = 0; i < req->count; i++) {\n\n                tmp = do_inp(req->addr, req->size);\n\n                write_phys_req_item(req->data, req, i, &tmp);\n\n            }\n\n        }\n\n    } else if (req->dir == IOREQ_WRITE) {\n\n        if (!req->data_is_ptr) {\n\n            do_outp(req->addr, req->size, req->data);\n\n        } else {\n\n            for (i = 0; i < req->count; i++) {\n\n                uint32_t tmp = 0;\n\n\n\n                read_phys_req_item(req->data, req, i, &tmp);\n\n                do_outp(req->addr, req->size, tmp);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 498, "_split": "valid", "_hash": "02e5c16c7c4b8ccbcd276a88ec86a3b9"}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void rtas_display_character(sPAPREnvironment *spapr,\n\n                                   uint32_t token, uint32_t nargs,\n\n                                   target_ulong args,\n\n                                   uint32_t nret, target_ulong rets)\n\n{\n\n    uint8_t c = rtas_ld(args, 0);\n\n    VIOsPAPRDevice *sdev = vty_lookup(spapr, 0);\n\n\n\n    if (!sdev) {\n\n        rtas_st(rets, 0, -1);\n\n    } else {\n\n        vty_putchars(sdev, &c, sizeof(c));\n\n        rtas_st(rets, 0, 0);\n\n    }\n\n}\n", "idx": 512, "_split": "valid", "_hash": "1e6fc892aef455dd14de3d2bf04d796a"}
{"project": "qemu", "commit_id": "b5eff355460643d09e533024360fe0522f368c07", "target": 1, "func": "static int bdrv_rd_badreq_sectors(BlockDriverState *bs,\n\n                                  int64_t sector_num, int nb_sectors)\n\n{\n\n    return\n\n        nb_sectors < 0 ||\n\n        sector_num < 0 ||\n\n        nb_sectors > bs->total_sectors ||\n\n        sector_num > bs->total_sectors - nb_sectors;\n\n}\n", "idx": 521, "_split": "valid", "_hash": "e34cc95b500de0257f008db4af2418e1"}
{"project": "qemu", "commit_id": "2d40564aaab3a99fe6ce00fc0fc893c02e9443ec", "target": 1, "func": "static int handle_update_file_cred(int dirfd, const char *name, FsCred *credp)\n\n{\n\n    int fd, ret;\n\n    fd = openat(dirfd, name, O_NONBLOCK | O_NOFOLLOW);\n\n    if (fd < 0) {\n\n        return fd;\n\n    }\n\n    ret = fchmod(fd, credp->fc_mode & 07777);\n\n    if (ret < 0) {\n\n        goto err_out;\n\n    }\n\n    ret = fchownat(fd, \"\", credp->fc_uid, credp->fc_gid, AT_EMPTY_PATH);\n\nerr_out:\n\n    close(fd);\n\n    return ret;\n\n}\n", "idx": 526, "_split": "valid", "_hash": "3fd253a57d6142fe96f527537df8b9a7"}
{"project": "qemu", "commit_id": "ccbcfedd17fd2d13521fcee66810d0df464ec1cc", "target": 1, "func": "int qemu_devtree_setprop(void *fdt, const char *node_path,\n\n                         const char *property, void *val_array, int size)\n\n{\n\n    int offset;\n\n\n\n    offset = fdt_path_offset(fdt, node_path);\n\n    if (offset < 0)\n\n        return offset;\n\n\n\n    return fdt_setprop(fdt, offset, property, val_array, size);\n\n}\n", "idx": 536, "_split": "valid", "_hash": "3d1cc56cfa74aabdb21aa3f1c3a13e95"}
{"project": "qemu", "commit_id": "c9f4b77ad5783bd84bca4ab99d4b3d6ee61de01c", "target": 1, "func": "static void pc_dimm_check_memdev_is_busy(Object *obj, const char *name,\n\n                                      Object *val, Error **errp)\n\n{\n\n    MemoryRegion *mr;\n\n\n\n    mr = host_memory_backend_get_memory(MEMORY_BACKEND(val), errp);\n\n    if (memory_region_is_mapped(mr)) {\n\n        char *path = object_get_canonical_path_component(val);\n\n        error_setg(errp, \"can't use already busy memdev: %s\", path);\n\n        g_free(path);\n\n    } else {\n\n        qdev_prop_allow_set_link_before_realize(obj, name, val, errp);\n\n    }\n\n}\n", "idx": 670, "_split": "valid", "_hash": "c84efdde5e2f91e4336b5ca7892e4f3f"}
{"project": "qemu", "commit_id": "83d768b5640946b7da55ce8335509df297e2c7cd", "target": 1, "func": "static void virtio_scsi_complete_req(VirtIOSCSIReq *req)\n\n{\n\n    VirtIOSCSI *s = req->dev;\n\n    VirtQueue *vq = req->vq;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n\n\n    qemu_iovec_from_buf(&req->resp_iov, 0, &req->resp, req->resp_size);\n\n    virtqueue_push(vq, &req->elem, req->qsgl.size + req->resp_iov.size);\n\n    if (s->dataplane_started && !s->dataplane_fenced) {\n\n        virtio_scsi_dataplane_notify(vdev, req);\n\n    } else {\n\n        virtio_notify(vdev, vq);\n\n    }\n\n\n\n    if (req->sreq) {\n\n        req->sreq->hba_private = NULL;\n\n        scsi_req_unref(req->sreq);\n\n    }\n\n    virtio_scsi_free_req(req);\n\n}\n", "idx": 696, "_split": "valid", "_hash": "f71ca5dd2fc9fab7e4fdf99861553866"}
{"project": "qemu", "commit_id": "233aa5c2d1cf4655ffe335025a68cf5454f87dad", "target": 1, "func": "static int inet_connect_addr(struct addrinfo *addr, bool block,\n\n                             bool *in_progress)\n\n{\n\n    int sock, rc;\n\n\n\n    if (in_progress) {\n\n        *in_progress = false;\n\n    }\n\n\n\n    sock = qemu_socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);\n\n    if (sock < 0) {\n\n        fprintf(stderr, \"%s: socket(%s): %s\\n\", __func__,\n\n                inet_strfamily(addr->ai_family), strerror(errno));\n\n        return -1;\n\n    }\n\n    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));\n\n    if (!block) {\n\n        socket_set_nonblock(sock);\n\n    }\n\n    /* connect to peer */\n\n    do {\n\n        rc = 0;\n\n        if (connect(sock, addr->ai_addr, addr->ai_addrlen) < 0) {\n\n            rc = -socket_error();\n\n        }\n\n    } while (rc == -EINTR);\n\n\n\n    if (!block && QEMU_SOCKET_RC_INPROGRESS(rc)) {\n\n        if (in_progress) {\n\n            *in_progress = true;\n\n        }\n\n    } else if (rc < 0) {\n\n        closesocket(sock);\n\n        return -1;\n\n    }\n\n    return sock;\n\n}\n", "idx": 705, "_split": "valid", "_hash": "deae78fffe4c50bec1b30960a18c650c"}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_rfci(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    /* Restore CPU state */\n\n    gen_helper_rfci(cpu_env);\n\n    gen_sync_exception(ctx);\n\n#endif\n\n}\n", "idx": 712, "_split": "valid", "_hash": "6d19161b39ba80910f11609c173ce4f2"}
{"project": "qemu", "commit_id": "ce137829e7e58fcdc5ba63b5e256f972e80be438", "target": 1, "func": "static void vvfat_close(BlockDriverState *bs)\n\n{\n\n    BDRVVVFATState *s = bs->opaque;\n\n\n\n    vvfat_close_current_file(s);\n\n    array_free(&(s->fat));\n\n    array_free(&(s->directory));\n\n    array_free(&(s->mapping));\n\n    if(s->cluster_buffer)\n\n        free(s->cluster_buffer);\n\n}\n", "idx": 782, "_split": "valid", "_hash": "6a59b03c3fa8d30b6dbb5a7164c67e22"}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static void test_io_channel_setup_sync(SocketAddressLegacy *listen_addr,\n\n                                       SocketAddressLegacy *connect_addr,\n\n                                       QIOChannel **src,\n\n                                       QIOChannel **dst)\n\n{\n\n    QIOChannelSocket *lioc;\n\n\n\n    lioc = qio_channel_socket_new();\n\n    qio_channel_socket_listen_sync(lioc, listen_addr, &error_abort);\n\n\n\n    if (listen_addr->type == SOCKET_ADDRESS_LEGACY_KIND_INET) {\n\n        SocketAddressLegacy *laddr = qio_channel_socket_get_local_address(\n\n            lioc, &error_abort);\n\n\n\n        g_free(connect_addr->u.inet.data->port);\n\n        connect_addr->u.inet.data->port = g_strdup(laddr->u.inet.data->port);\n\n\n\n        qapi_free_SocketAddressLegacy(laddr);\n\n    }\n\n\n\n    *src = QIO_CHANNEL(qio_channel_socket_new());\n\n    qio_channel_socket_connect_sync(\n\n        QIO_CHANNEL_SOCKET(*src), connect_addr, &error_abort);\n\n    qio_channel_set_delay(*src, false);\n\n\n\n    qio_channel_wait(QIO_CHANNEL(lioc), G_IO_IN);\n\n    *dst = QIO_CHANNEL(qio_channel_socket_accept(lioc, &error_abort));\n\n    g_assert(*dst);\n\n\n\n    test_io_channel_set_socket_bufs(*src, *dst);\n\n\n\n    object_unref(OBJECT(lioc));\n\n}\n", "idx": 814, "_split": "valid", "_hash": "e00ca9b3f51020e8039c59a57ebe7cc1"}
{"project": "qemu", "commit_id": "bb5fc20f7c1c65e95030da3629dd0d7a0cce38cd", "target": 0, "func": "static void monitor_readline(const char *prompt, int is_password,\n\n                             char *buf, int buf_size)\n\n{\n\n    readline_start(prompt, is_password, monitor_readline_cb, NULL);\n\n    readline_show_prompt();\n\n    monitor_readline_buf = buf;\n\n    monitor_readline_buf_size = buf_size;\n\n    monitor_readline_started = 1;\n\n    while (monitor_readline_started) {\n\n        main_loop_wait(10);\n\n    }\n\n}\n", "idx": 815, "_split": "valid", "_hash": "ec48ff98b5fff4f22987f2ff14146b73"}
{"project": "qemu", "commit_id": "72f0d0bf51362011c4d841a89fb8f5cfb16e0bf3", "target": 1, "func": "static int mp_pacl_removexattr(FsContext *ctx,\n\n                               const char *path, const char *name)\n\n{\n\n    int ret;\n\n    char *buffer;\n\n\n\n    buffer = rpath(ctx, path);\n\n    ret  = lremovexattr(buffer, MAP_ACL_ACCESS);\n\n    if (ret == -1 && errno == ENODATA) {\n\n        /*\n\n         * We don't get ENODATA error when trying to remove a\n\n         * posix acl that is not present. So don't throw the error\n\n         * even in case of mapped security model\n\n         */\n\n        errno = 0;\n\n        ret = 0;\n\n    }\n\n    g_free(buffer);\n\n    return ret;\n\n}\n", "idx": 859, "_split": "valid", "_hash": "ddd1a5af0a6130dfcf62a40f0a91b247"}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static void openpic_load_IRQ_queue(QEMUFile* f, IRQQueue *q)\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)\n\n        qemu_get_be32s(f, &q->queue[i]);\n\n\n\n    qemu_get_sbe32s(f, &q->next);\n\n    qemu_get_sbe32s(f, &q->priority);\n\n}\n", "idx": 882, "_split": "valid", "_hash": "5c8caeb0ae1ddcbb52893adc0d02c489"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void cs_write (void *opaque, target_phys_addr_t addr,\n\n                      uint64_t val64, unsigned size)\n\n{\n\n    CSState *s = opaque;\n\n    uint32_t saddr, iaddr, val;\n\n\n\n    saddr = addr;\n\n    val = val64;\n\n\n\n    switch (saddr) {\n\n    case Index_Address:\n\n        if (!(s->regs[Index_Address] & MCE) && (val & MCE)\n\n            && (s->dregs[Interface_Configuration] & (3 << 3)))\n\n            s->aci_counter = conf.aci_counter;\n\n\n\n        s->regs[Index_Address] = val & ~(1 << 7);\n\n        break;\n\n\n\n    case Index_Data:\n\n        if (!(s->dregs[MODE_And_ID] & MODE2))\n\n            iaddr = s->regs[Index_Address] & 0x0f;\n\n        else\n\n            iaddr = s->regs[Index_Address] & 0x1f;\n\n\n\n        switch (iaddr) {\n\n        case RESERVED:\n\n        case RESERVED_2:\n\n        case RESERVED_3:\n\n            lwarn (\"attempt to write %#x to reserved indirect register %d\\n\",\n\n                   val, iaddr);\n\n            break;\n\n\n\n        case FS_And_Playback_Data_Format:\n\n            if (s->regs[Index_Address] & MCE) {\n\n                cs_reset_voices (s, val);\n\n            }\n\n            else {\n\n                if (s->dregs[Alternate_Feature_Status] & PMCE) {\n\n                    val = (val & ~0x0f) | (s->dregs[iaddr] & 0x0f);\n\n                    cs_reset_voices (s, val);\n\n                }\n\n                else {\n\n                    lwarn (\"[P]MCE(%#x, %#x) is not set, val=%#x\\n\",\n\n                           s->regs[Index_Address],\n\n                           s->dregs[Alternate_Feature_Status],\n\n                           val);\n\n                    break;\n\n                }\n\n            }\n\n            s->dregs[iaddr] = val;\n\n            break;\n\n\n\n        case Interface_Configuration:\n\n            val &= ~(1 << 5);   /* D5 is reserved */\n\n            s->dregs[iaddr] = val;\n\n            if (val & PPIO) {\n\n                lwarn (\"PIO is not supported (%#x)\\n\", val);\n\n                break;\n\n            }\n\n            if (val & PEN) {\n\n                if (!s->dma_running) {\n\n                    cs_reset_voices (s, s->dregs[FS_And_Playback_Data_Format]);\n\n                }\n\n            }\n\n            else {\n\n                if (s->dma_running) {\n\n                    DMA_release_DREQ (s->dma);\n\n                    AUD_set_active_out (s->voice, 0);\n\n                    s->dma_running = 0;\n\n                }\n\n            }\n\n            break;\n\n\n\n        case Error_Status_And_Initialization:\n\n            lwarn (\"attempt to write to read only register %d\\n\", iaddr);\n\n            break;\n\n\n\n        case MODE_And_ID:\n\n            dolog (\"val=%#x\\n\", val);\n\n            if (val & MODE2)\n\n                s->dregs[iaddr] |= MODE2;\n\n            else\n\n                s->dregs[iaddr] &= ~MODE2;\n\n            break;\n\n\n\n        case Alternate_Feature_Enable_I:\n\n            if (val & TE)\n\n                lerr (\"timer is not yet supported\\n\");\n\n            s->dregs[iaddr] = val;\n\n            break;\n\n\n\n        case Alternate_Feature_Status:\n\n            if ((s->dregs[iaddr] & PI) && !(val & PI)) {\n\n                /* XXX: TI CI */\n\n                qemu_irq_lower (s->pic);\n\n                s->regs[Status] &= ~INT;\n\n            }\n\n            s->dregs[iaddr] = val;\n\n            break;\n\n\n\n        case Version_Chip_ID:\n\n            lwarn (\"write to Version_Chip_ID register %#x\\n\", val);\n\n            s->dregs[iaddr] = val;\n\n            break;\n\n\n\n        default:\n\n            s->dregs[iaddr] = val;\n\n            break;\n\n        }\n\n        dolog (\"written value %#x to indirect register %d\\n\", val, iaddr);\n\n        break;\n\n\n\n    case Status:\n\n        if (s->regs[Status] & INT) {\n\n            qemu_irq_lower (s->pic);\n\n        }\n\n        s->regs[Status] &= ~INT;\n\n        s->dregs[Alternate_Feature_Status] &= ~(PI | CI | TI);\n\n        break;\n\n\n\n    case PIO_Data:\n\n        lwarn (\"attempt to write value %#x to PIO register\\n\", val);\n\n        break;\n\n    }\n\n}\n", "idx": 914, "_split": "valid", "_hash": "c80ceed243fd99c0100b2270148ccda2"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_pin_cfg_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque;\n\n\n\n    if (size != 4) {\n\n        return omap_badwidth_read32(opaque, addr);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x00:\t/* FUNC_MUX_CTRL_0 */\n\n    case 0x04:\t/* FUNC_MUX_CTRL_1 */\n\n    case 0x08:\t/* FUNC_MUX_CTRL_2 */\n\n        return s->func_mux_ctrl[addr >> 2];\n\n\n\n    case 0x0c:\t/* COMP_MODE_CTRL_0 */\n\n        return s->comp_mode_ctrl[0];\n\n\n\n    case 0x10:\t/* FUNC_MUX_CTRL_3 */\n\n    case 0x14:\t/* FUNC_MUX_CTRL_4 */\n\n    case 0x18:\t/* FUNC_MUX_CTRL_5 */\n\n    case 0x1c:\t/* FUNC_MUX_CTRL_6 */\n\n    case 0x20:\t/* FUNC_MUX_CTRL_7 */\n\n    case 0x24:\t/* FUNC_MUX_CTRL_8 */\n\n    case 0x28:\t/* FUNC_MUX_CTRL_9 */\n\n    case 0x2c:\t/* FUNC_MUX_CTRL_A */\n\n    case 0x30:\t/* FUNC_MUX_CTRL_B */\n\n    case 0x34:\t/* FUNC_MUX_CTRL_C */\n\n    case 0x38:\t/* FUNC_MUX_CTRL_D */\n\n        return s->func_mux_ctrl[(addr >> 2) - 1];\n\n\n\n    case 0x40:\t/* PULL_DWN_CTRL_0 */\n\n    case 0x44:\t/* PULL_DWN_CTRL_1 */\n\n    case 0x48:\t/* PULL_DWN_CTRL_2 */\n\n    case 0x4c:\t/* PULL_DWN_CTRL_3 */\n\n        return s->pull_dwn_ctrl[(addr & 0xf) >> 2];\n\n\n\n    case 0x50:\t/* GATE_INH_CTRL_0 */\n\n        return s->gate_inh_ctrl[0];\n\n\n\n    case 0x60:\t/* VOLTAGE_CTRL_0 */\n\n        return s->voltage_ctrl[0];\n\n\n\n    case 0x70:\t/* TEST_DBG_CTRL_0 */\n\n        return s->test_dbg_ctrl[0];\n\n\n\n    case 0x80:\t/* MOD_CONF_CTRL_0 */\n\n        return s->mod_conf_ctrl[0];\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 979, "_split": "valid", "_hash": "a9ac2e16a62d754c9ea724536b71358b"}
{"project": "qemu", "commit_id": "271a916e8a4188b0ec94bafff18aa93de0047820", "target": 1, "func": "static always_inline void gen_rldimi (DisasContext *ctx, int mbn, int shn)\n\n{\n\n    uint64_t mask;\n\n    uint32_t sh, mb;\n\n\n\n    sh = SH(ctx->opcode) | (shn << 5);\n\n    mb = MB(ctx->opcode) | (mbn << 5);\n\n    if (likely(sh == 0)) {\n\n        if (likely(mb == 0)) {\n\n            gen_op_load_gpr_T0(rS(ctx->opcode));\n\n            goto do_store;\n\n        } else if (likely(mb == 63)) {\n\n            gen_op_load_gpr_T0(rA(ctx->opcode));\n\n            goto do_store;\n\n        }\n\n        gen_op_load_gpr_T0(rS(ctx->opcode));\n\n        gen_op_load_gpr_T1(rA(ctx->opcode));\n\n        goto do_mask;\n\n    }\n\n    gen_op_load_gpr_T0(rS(ctx->opcode));\n\n    gen_op_load_gpr_T1(rA(ctx->opcode));\n\n    gen_op_rotli64_T0(sh);\n\n do_mask:\n\n    mask = MASK(mb, 63 - sh);\n\n    gen_andi_T0_64(ctx, mask);\n\n    gen_andi_T1_64(ctx, ~mask);\n\n    gen_op_or();\n\n do_store:\n\n    gen_op_store_T0_gpr(rA(ctx->opcode));\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx);\n\n}\n", "idx": 1033, "_split": "valid", "_hash": "d568de00045a38a6e11396a07130d535"}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void kqemu_set_notdirty(CPUState *env, ram_addr_t ram_addr)\n\n{\n\n    LOG_INT(\"kqemu_set_notdirty: addr=%08lx\\n\", \n\n                (unsigned long)ram_addr);\n\n    /* we only track transitions to dirty state */\n\n    if (phys_ram_dirty[ram_addr >> TARGET_PAGE_BITS] != 0xff)\n\n        return;\n\n    if (nb_ram_pages_to_update >= KQEMU_MAX_RAM_PAGES_TO_UPDATE)\n\n        nb_ram_pages_to_update = KQEMU_RAM_PAGES_UPDATE_ALL;\n\n    else\n\n        ram_pages_to_update[nb_ram_pages_to_update++] = ram_addr;\n\n}\n", "idx": 1064, "_split": "valid", "_hash": "3d3a37cdbab0a4ffd415255ff0afbcb1"}
{"project": "qemu", "commit_id": "8da1e18b0cf46b6c95c88bbad1cc50d6dd1bef4b", "target": 0, "func": "static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct iscsi_context *iscsi = NULL;\n\n    struct iscsi_url *iscsi_url = NULL;\n\n    struct IscsiTask task;\n\n    char *initiator_name = NULL;\n\n    int ret;\n\n\n\n    if ((BDRV_SECTOR_SIZE % 512) != 0) {\n\n        error_report(\"iSCSI: Invalid BDRV_SECTOR_SIZE. \"\n\n                     \"BDRV_SECTOR_SIZE(%lld) is not a multiple \"\n\n                     \"of 512\", BDRV_SECTOR_SIZE);\n\n        return -EINVAL;\n\n    }\n\n\n\n    iscsi_url = iscsi_parse_full_url(iscsi, filename);\n\n    if (iscsi_url == NULL) {\n\n        error_report(\"Failed to parse URL : %s %s\", filename,\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n\n\n    initiator_name = parse_initiator_name(iscsi_url->target);\n\n\n\n    iscsi = iscsi_create_context(initiator_name);\n\n    if (iscsi == NULL) {\n\n        error_report(\"iSCSI: Failed to create iSCSI context.\");\n\n        ret = -ENOMEM;\n\n        goto out;\n\n    }\n\n\n\n    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {\n\n        error_report(\"iSCSI: Failed to set target name.\");\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    if (iscsi_url->user != NULL) {\n\n        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,\n\n                                              iscsi_url->passwd);\n\n        if (ret != 0) {\n\n            error_report(\"Failed to set initiator username and password\");\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    /* check if we got CHAP username/password via the options */\n\n    if (parse_chap(iscsi, iscsi_url->target) != 0) {\n\n        error_report(\"iSCSI: Failed to set CHAP user/password\");\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) {\n\n        error_report(\"iSCSI: Failed to set session type to normal.\");\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n\n\n\n    /* check if we got HEADER_DIGEST via the options */\n\n    parse_header_digest(iscsi, iscsi_url->target);\n\n\n\n    task.iscsilun = iscsilun;\n\n    task.status = 0;\n\n    task.complete = 0;\n\n    task.bs = bs;\n\n\n\n    iscsilun->iscsi = iscsi;\n\n    iscsilun->lun   = iscsi_url->lun;\n\n\n\n    if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun,\n\n                                 iscsi_connect_cb, &task)\n\n        != 0) {\n\n        error_report(\"iSCSI: Failed to start async connect.\");\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    while (!task.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_aio_wait();\n\n    }\n\n    if (task.status != 0) {\n\n        error_report(\"iSCSI: Failed to connect to LUN : %s\",\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    /* Medium changer or tape. We dont have any emulation for this so this must\n\n     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try\n\n     * to read from the device to guess the image format.\n\n     */\n\n    if (iscsilun->type == TYPE_MEDIUM_CHANGER ||\n\n        iscsilun->type == TYPE_TAPE) {\n\n        bs->sg = 1;\n\n    }\n\n\n\n    ret = 0;\n\n\n\nout:\n\n    if (initiator_name != NULL) {\n\n        g_free(initiator_name);\n\n    }\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n\n\n    if (ret) {\n\n        if (iscsi != NULL) {\n\n            iscsi_destroy_context(iscsi);\n\n        }\n\n        memset(iscsilun, 0, sizeof(IscsiLun));\n\n    }\n\n    return ret;\n\n}\n", "idx": 1075, "_split": "valid", "_hash": "2f143f7bf2e02787b1a975f66861ec99"}
{"project": "qemu", "commit_id": "c34d2451ed32651e14e309f94009be07d231ee96", "target": 1, "func": "static inline int seek_to_sector(BlockDriverState *bs, int64_t sector_num)\n\n{\n\n    BDRVParallelsState *s = bs->opaque;\n\n    uint32_t index, offset, position;\n\n\n\n    index = sector_num / s->tracks;\n\n    offset = sector_num % s->tracks;\n\n\n\n    // not allocated\n\n    if ((index > s->catalog_size) || (s->catalog_bitmap[index] == 0))\n\n\treturn -1;\n\n\n\n    position = (s->catalog_bitmap[index] + offset) * 512;\n\n\n\n//    fprintf(stderr, \"sector: %llx index=%x offset=%x pointer=%x position=%x\\n\",\n\n//\tsector_num, index, offset, s->catalog_bitmap[index], position);\n\n\n\n    if (lseek(s->fd, position, SEEK_SET) != position)\n\n\treturn -1;\n\n\n\n    return 0;\n\n}\n", "idx": 1091, "_split": "valid", "_hash": "e336eec2020634dc29c432c093c35b67"}
{"project": "qemu", "commit_id": "203d65a4706be345c209f3408d3a011a3e48f0c9", "target": 0, "func": "static void imx_epit_reload_compare_timer(IMXEPITState *s)\n\n{\n\n    if ((s->cr & (CR_EN | CR_OCIEN)) == (CR_EN | CR_OCIEN))  {\n\n        /* if the compare feature is on and timers are running */\n\n        uint32_t tmp = imx_epit_update_count(s);\n\n        uint64_t next;\n\n        if (tmp > s->cmp) {\n\n            /* It'll fire in this round of the timer */\n\n            next = tmp - s->cmp;\n\n        } else { /* catch it next time around */\n\n            next = tmp - s->cmp + ((s->cr & CR_RLD) ? TIMER_MAX : s->lr);\n\n        }\n\n        ptimer_set_count(s->timer_cmp, next);\n\n    }\n\n}\n", "idx": 1101, "_split": "valid", "_hash": "fe26c1d03aea0c6a13fbebccd7f8c2fd"}
{"project": "qemu", "commit_id": "eca3ed0343ba413937f34ad4f8c4822dc82924e5", "target": 1, "func": "static int handle_intercept(CPUS390XState *env)\n\n{\n\n    struct kvm_run *run = env->kvm_run;\n\n    int icpt_code = run->s390_sieic.icptcode;\n\n    int r = 0;\n\n\n\n    dprintf(\"intercept: 0x%x (at 0x%lx)\\n\", icpt_code,\n\n            (long)env->kvm_run->psw_addr);\n\n    switch (icpt_code) {\n\n        case ICPT_INSTRUCTION:\n\n            r = handle_instruction(env, run);\n\n\n        case ICPT_WAITPSW:\n\n\n\n\n\n\n\n        case ICPT_CPU_STOP:\n\n            if (s390_del_running_cpu(env) == 0) {\n\n\n\n\n\n        case ICPT_SOFT_INTERCEPT:\n\n            fprintf(stderr, \"KVM unimplemented icpt SOFT\\n\");\n\n            exit(1);\n\n\n        case ICPT_IO:\n\n            fprintf(stderr, \"KVM unimplemented icpt IO\\n\");\n\n            exit(1);\n\n\n        default:\n\n            fprintf(stderr, \"Unknown intercept code: %d\\n\", icpt_code);\n\n            exit(1);\n\n\n\n\n\n    return r;\n", "idx": 1131, "_split": "valid", "_hash": "7f5f639637029d7b40cb1a7b88c46cf3"}
{"project": "qemu", "commit_id": "f69a8bde29354493ff8aea64cc9cb3b531d16337", "target": 1, "func": "static gboolean qio_channel_websock_handshake_send(QIOChannel *ioc,\n\n                                                   GIOCondition condition,\n\n                                                   gpointer user_data)\n\n{\n\n    QIOTask *task = user_data;\n\n    QIOChannelWebsock *wioc = QIO_CHANNEL_WEBSOCK(\n\n        qio_task_get_source(task));\n\n    Error *err = NULL;\n\n    ssize_t ret;\n\n\n\n    ret = qio_channel_write(wioc->master,\n\n                            (char *)wioc->encoutput.buffer,\n\n                            wioc->encoutput.offset,\n\n                            &err);\n\n\n\n    if (ret < 0) {\n\n        trace_qio_channel_websock_handshake_fail(ioc);\n\n        qio_task_set_error(task, err);\n\n        qio_task_complete(task);\n\n        return FALSE;\n\n    }\n\n\n\n    buffer_advance(&wioc->encoutput, ret);\n\n    if (wioc->encoutput.offset == 0) {\n\n        trace_qio_channel_websock_handshake_complete(ioc);\n\n        qio_task_complete(task);\n\n        return FALSE;\n\n    }\n\n    trace_qio_channel_websock_handshake_pending(ioc, G_IO_OUT);\n\n    return TRUE;\n\n}\n", "idx": 1150, "_split": "valid", "_hash": "c1ed8b3c15e1b364f4f13ce1c9f27417"}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_in_native_list_uint8(TestInputVisitorData *data,\n\n                                             const void *unused)\n\n{\n\n    test_native_list_integer_helper(data, unused,\n\n                                    USER_DEF_NATIVE_LIST_UNION_KIND_U8);\n\n}\n", "idx": 1161, "_split": "valid", "_hash": "dac139f3bef141c53af75de592395549"}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static void scsi_disk_class_initfn(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SCSIDeviceClass *sc = SCSI_DEVICE_CLASS(klass);\n\n\n\n    sc->init         = scsi_disk_initfn;\n\n    sc->destroy      = scsi_destroy;\n\n    sc->alloc_req    = scsi_new_request;\n\n    sc->unit_attention_reported = scsi_disk_unit_attention_reported;\n\n    dc->fw_name = \"disk\";\n\n    dc->desc = \"virtual SCSI disk or CD-ROM (legacy)\";\n\n    dc->reset = scsi_disk_reset;\n\n    dc->props = scsi_disk_properties;\n\n    dc->vmsd  = &vmstate_scsi_disk_state;\n\n}\n", "idx": 1180, "_split": "valid", "_hash": "71c28942cf59f6bd57c9eba4ba1cfd25"}
{"project": "qemu", "commit_id": "5add35bec1e249bb5345a47008c8f298d4760be4", "target": 0, "func": "static void test_tco2_status_bits(void)\n\n{\n\n    TestData d;\n\n    uint16_t ticks = 8;\n\n    uint16_t val;\n\n    int ret;\n\n\n\n    d.args = \"-watchdog-action none\";\n\n    test_init(&d);\n\n\n\n    stop_tco(&d);\n\n    clear_tco_status(&d);\n\n    reset_on_second_timeout(true);\n\n    set_tco_timeout(&d, ticks);\n\n    load_tco(&d);\n\n    start_tco(&d);\n\n    clock_step(ticks * TCO_TICK_NSEC * 2);\n\n\n\n    val = qpci_io_readw(d.dev, d.tco_io_base + TCO2_STS);\n\n    ret = val & (TCO_SECOND_TO_STS | TCO_BOOT_STS) ? 1 : 0;\n\n    g_assert(ret == 1);\n\n    qpci_io_writew(d.dev, d.tco_io_base + TCO2_STS, val);\n\n    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO2_STS), ==, 0);\n\n    qtest_end();\n\n}\n", "idx": 1193, "_split": "valid", "_hash": "990d6d2b8da2fde126dee58b67c4f4ad"}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "sdhci_write(SDHCIState *s, unsigned int offset, uint32_t value, unsigned size)\n\n{\n\n    unsigned shift =  8 * (offset & 0x3);\n\n    uint32_t mask = ~(((1ULL << (size * 8)) - 1) << shift);\n\n    value <<= shift;\n\n\n\n    switch (offset & ~0x3) {\n\n    case SDHC_SYSAD:\n\n        s->sdmasysad = (s->sdmasysad & mask) | value;\n\n        MASKED_WRITE(s->sdmasysad, mask, value);\n\n        /* Writing to last byte of sdmasysad might trigger transfer */\n\n        if (!(mask & 0xFF000000) && TRANSFERRING_DATA(s->prnsts) && s->blkcnt &&\n\n                s->blksize && SDHC_DMA_TYPE(s->hostctl) == SDHC_CTRL_SDMA) {\n\n            SDHCI_GET_CLASS(s)->do_sdma_multi(s);\n\n        }\n\n        break;\n\n    case SDHC_BLKSIZE:\n\n        if (!TRANSFERRING_DATA(s->prnsts)) {\n\n            MASKED_WRITE(s->blksize, mask, value);\n\n            MASKED_WRITE(s->blkcnt, mask >> 16, value >> 16);\n\n        }\n\n        break;\n\n    case SDHC_ARGUMENT:\n\n        MASKED_WRITE(s->argument, mask, value);\n\n        break;\n\n    case SDHC_TRNMOD:\n\n        /* DMA can be enabled only if it is supported as indicated by\n\n         * capabilities register */\n\n        if (!(s->capareg & SDHC_CAN_DO_DMA)) {\n\n            value &= ~SDHC_TRNS_DMA;\n\n        }\n\n        MASKED_WRITE(s->trnmod, mask, value);\n\n        MASKED_WRITE(s->cmdreg, mask >> 16, value >> 16);\n\n\n\n        /* Writing to the upper byte of CMDREG triggers SD command generation */\n\n        if ((mask & 0xFF000000) || !SDHCI_GET_CLASS(s)->can_issue_command(s)) {\n\n            break;\n\n        }\n\n\n\n        SDHCI_GET_CLASS(s)->send_command(s);\n\n        break;\n\n    case  SDHC_BDATA:\n\n        if (sdhci_buff_access_is_sequential(s, offset - SDHC_BDATA)) {\n\n            SDHCI_GET_CLASS(s)->bdata_write(s, value >> shift, size);\n\n        }\n\n        break;\n\n    case SDHC_HOSTCTL:\n\n        if (!(mask & 0xFF0000)) {\n\n            sdhci_blkgap_write(s, value >> 16);\n\n        }\n\n        MASKED_WRITE(s->hostctl, mask, value);\n\n        MASKED_WRITE(s->pwrcon, mask >> 8, value >> 8);\n\n        MASKED_WRITE(s->wakcon, mask >> 24, value >> 24);\n\n        if (!(s->prnsts & SDHC_CARD_PRESENT) || ((s->pwrcon >> 1) & 0x7) < 5 ||\n\n                !(s->capareg & (1 << (31 - ((s->pwrcon >> 1) & 0x7))))) {\n\n            s->pwrcon &= ~SDHC_POWER_ON;\n\n        }\n\n        break;\n\n    case SDHC_CLKCON:\n\n        if (!(mask & 0xFF000000)) {\n\n            sdhci_reset_write(s, value >> 24);\n\n        }\n\n        MASKED_WRITE(s->clkcon, mask, value);\n\n        MASKED_WRITE(s->timeoutcon, mask >> 16, value >> 16);\n\n        if (s->clkcon & SDHC_CLOCK_INT_EN) {\n\n            s->clkcon |= SDHC_CLOCK_INT_STABLE;\n\n        } else {\n\n            s->clkcon &= ~SDHC_CLOCK_INT_STABLE;\n\n        }\n\n        break;\n\n    case SDHC_NORINTSTS:\n\n        if (s->norintstsen & SDHC_NISEN_CARDINT) {\n\n            value &= ~SDHC_NIS_CARDINT;\n\n        }\n\n        s->norintsts &= mask | ~value;\n\n        s->errintsts &= (mask >> 16) | ~(value >> 16);\n\n        if (s->errintsts) {\n\n            s->norintsts |= SDHC_NIS_ERR;\n\n        } else {\n\n            s->norintsts &= ~SDHC_NIS_ERR;\n\n        }\n\n        sdhci_update_irq(s);\n\n        break;\n\n    case SDHC_NORINTSTSEN:\n\n        MASKED_WRITE(s->norintstsen, mask, value);\n\n        MASKED_WRITE(s->errintstsen, mask >> 16, value >> 16);\n\n        s->norintsts &= s->norintstsen;\n\n        s->errintsts &= s->errintstsen;\n\n        if (s->errintsts) {\n\n            s->norintsts |= SDHC_NIS_ERR;\n\n        } else {\n\n            s->norintsts &= ~SDHC_NIS_ERR;\n\n        }\n\n        sdhci_update_irq(s);\n\n        break;\n\n    case SDHC_NORINTSIGEN:\n\n        MASKED_WRITE(s->norintsigen, mask, value);\n\n        MASKED_WRITE(s->errintsigen, mask >> 16, value >> 16);\n\n        sdhci_update_irq(s);\n\n        break;\n\n    case SDHC_ADMAERR:\n\n        MASKED_WRITE(s->admaerr, mask, value);\n\n        break;\n\n    case SDHC_ADMASYSADDR:\n\n        s->admasysaddr = (s->admasysaddr & (0xFFFFFFFF00000000ULL |\n\n                (uint64_t)mask)) | (uint64_t)value;\n\n        break;\n\n    case SDHC_ADMASYSADDR + 4:\n\n        s->admasysaddr = (s->admasysaddr & (0x00000000FFFFFFFFULL |\n\n                ((uint64_t)mask << 32))) | ((uint64_t)value << 32);\n\n        break;\n\n    case SDHC_FEAER:\n\n        s->acmd12errsts |= value;\n\n        s->errintsts |= (value >> 16) & s->errintstsen;\n\n        if (s->acmd12errsts) {\n\n            s->errintsts |= SDHC_EIS_CMD12ERR;\n\n        }\n\n        if (s->errintsts) {\n\n            s->norintsts |= SDHC_NIS_ERR;\n\n        }\n\n        sdhci_update_irq(s);\n\n        break;\n\n    default:\n\n        ERRPRINT(\"bad %ub write offset: addr[0x%04x] <- %u(0x%x)\\n\",\n\n                size, offset, value >> shift, value >> shift);\n\n        break;\n\n    }\n\n    DPRINT_L2(\"write %ub: addr[0x%04x] <- %u(0x%x)\\n\",\n\n            size, offset, value >> shift, value >> shift);\n\n}\n", "idx": 1199, "_split": "valid", "_hash": "c3156f82efd1c52db52017f595347710"}
{"project": "qemu", "commit_id": "9bcc80cd71892df42605e0c097d85c0237ff45d1", "target": 0, "func": "build_ssdt(GArray *table_data, GArray *linker,\n\n           AcpiCpuInfo *cpu, AcpiPmInfo *pm, AcpiMiscInfo *misc,\n\n           PcPciInfo *pci, PcGuestInfo *guest_info)\n\n{\n\n    int acpi_cpus = MIN(0xff, guest_info->apic_id_limit);\n\n    int ssdt_start = table_data->len;\n\n    uint8_t *ssdt_ptr;\n\n    int i;\n\n\n\n    /* Copy header and patch values in the S3_ / S4_ / S5_ packages */\n\n    ssdt_ptr = acpi_data_push(table_data, sizeof(ssdp_misc_aml));\n\n    memcpy(ssdt_ptr, ssdp_misc_aml, sizeof(ssdp_misc_aml));\n\n    if (pm->s3_disabled) {\n\n        ssdt_ptr[acpi_s3_name[0]] = 'X';\n\n    }\n\n    if (pm->s4_disabled) {\n\n        ssdt_ptr[acpi_s4_name[0]] = 'X';\n\n    } else {\n\n        ssdt_ptr[acpi_s4_pkg[0] + 1] = ssdt_ptr[acpi_s4_pkg[0] + 3] =\n\n            pm->s4_val;\n\n    }\n\n\n\n    patch_pci_windows(pci, ssdt_ptr, sizeof(ssdp_misc_aml));\n\n\n\n    ACPI_BUILD_SET_LE(ssdt_ptr, sizeof(ssdp_misc_aml),\n\n                      ssdt_isa_pest[0], 16, misc->pvpanic_port);\n\n\n\n    {\n\n        GArray *sb_scope = build_alloc_array();\n\n        uint8_t op = 0x10; /* ScopeOp */\n\n\n\n        build_append_nameseg(sb_scope, \"_SB_\");\n\n\n\n        /* build Processor object for each processor */\n\n        for (i = 0; i < acpi_cpus; i++) {\n\n            uint8_t *proc = acpi_data_push(sb_scope, ACPI_PROC_SIZEOF);\n\n            memcpy(proc, ACPI_PROC_AML, ACPI_PROC_SIZEOF);\n\n            proc[ACPI_PROC_OFFSET_CPUHEX] = acpi_get_hex(i >> 4);\n\n            proc[ACPI_PROC_OFFSET_CPUHEX+1] = acpi_get_hex(i);\n\n            proc[ACPI_PROC_OFFSET_CPUID1] = i;\n\n            proc[ACPI_PROC_OFFSET_CPUID2] = i;\n\n        }\n\n\n\n        /* build this code:\n\n         *   Method(NTFY, 2) {If (LEqual(Arg0, 0x00)) {Notify(CP00, Arg1)} ...}\n\n         */\n\n        /* Arg0 = Processor ID = APIC ID */\n\n        build_append_notify_method(sb_scope, \"NTFY\", \"CP%0.02X\", acpi_cpus);\n\n\n\n        /* build \"Name(CPON, Package() { One, One, ..., Zero, Zero, ... })\" */\n\n        build_append_byte(sb_scope, 0x08); /* NameOp */\n\n        build_append_nameseg(sb_scope, \"CPON\");\n\n\n\n        {\n\n            GArray *package = build_alloc_array();\n\n            uint8_t op = 0x12; /* PackageOp */\n\n\n\n            build_append_byte(package, acpi_cpus); /* NumElements */\n\n            for (i = 0; i < acpi_cpus; i++) {\n\n                uint8_t b = test_bit(i, cpu->found_cpus) ? 0x01 : 0x00;\n\n                build_append_byte(package, b);\n\n            }\n\n\n\n            build_package(package, op, 2);\n\n            build_append_array(sb_scope, package);\n\n            build_free_array(package);\n\n        }\n\n\n\n        {\n\n            AcpiBuildPciBusHotplugState hotplug_state;\n\n            Object *pci_host;\n\n            PCIBus *bus = NULL;\n\n            bool ambiguous;\n\n\n\n            pci_host = object_resolve_path_type(\"\", TYPE_PCI_HOST_BRIDGE, &ambiguous);\n\n            if (!ambiguous && pci_host) {\n\n                bus = PCI_HOST_BRIDGE(pci_host)->bus;\n\n            }\n\n\n\n            build_pci_bus_state_init(&hotplug_state, NULL);\n\n\n\n            if (bus) {\n\n                /* Scan all PCI buses. Generate tables to support hotplug. */\n\n                pci_for_each_bus_depth_first(bus, build_pci_bus_begin,\n\n                                             build_pci_bus_end, &hotplug_state);\n\n            }\n\n\n\n            build_append_array(sb_scope, hotplug_state.device_table);\n\n            build_pci_bus_state_cleanup(&hotplug_state);\n\n        }\n\n\n\n        build_package(sb_scope, op, 3);\n\n        build_append_array(table_data, sb_scope);\n\n        build_free_array(sb_scope);\n\n    }\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)(table_data->data + ssdt_start),\n\n                 ACPI_SSDT_SIGNATURE, table_data->len - ssdt_start, 1);\n\n}\n", "idx": 1211, "_split": "valid", "_hash": "c9d0e29f2128f21fe70ad3954ba953ef"}
{"project": "qemu", "commit_id": "46181129eac9a56d9a948667282dd03d5015f096", "target": 0, "func": "int bdrv_child_check_perm(BdrvChild *c, uint64_t perm, uint64_t shared,\n\n                          Error **errp)\n\n{\n\n    return bdrv_check_update_perm(c->bs, perm, shared, c, errp);\n\n}\n", "idx": 1219, "_split": "valid", "_hash": "041fa00fa415a57e04d28473aa10f1f3"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void ide_flush_cb(void *opaque, int ret)\n\n{\n\n    IDEState *s = opaque;\n\n\n\n    s->pio_aiocb = NULL;\n\n\n\n    if (ret == -ECANCELED) {\n\n        return;\n\n    }\n\n    if (ret < 0) {\n\n        /* XXX: What sector number to set here? */\n\n        if (ide_handle_rw_error(s, -ret, IDE_RETRY_FLUSH)) {\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (s->bs) {\n\n        block_acct_done(bdrv_get_stats(s->bs), &s->acct);\n\n    }\n\n    s->status = READY_STAT | SEEK_STAT;\n\n    ide_cmd_done(s);\n\n    ide_set_irq(s->bus);\n\n}\n", "idx": 1249, "_split": "valid", "_hash": "842f45b7011f08ee8bb9454c6e1cf8dc"}
{"project": "qemu", "commit_id": "adbecc89731cf3e0ae656d50ea9fa58c589c4bdc", "target": 0, "func": "static int ehci_init_transfer(EHCIPacket *p)\n\n{\n\n    uint32_t cpage, offset, bytes, plen;\n\n    dma_addr_t page;\n\n    USBBus *bus = &p->queue->ehci->bus;\n\n    BusState *qbus = BUS(bus);\n\n\n\n    cpage  = get_field(p->qtd.token, QTD_TOKEN_CPAGE);\n\n    bytes  = get_field(p->qtd.token, QTD_TOKEN_TBYTES);\n\n    offset = p->qtd.bufptr[0] & ~QTD_BUFPTR_MASK;\n\n    qemu_sglist_init(&p->sgl, qbus->parent, 5, p->queue->ehci->as);\n\n\n\n    while (bytes > 0) {\n\n        if (cpage > 4) {\n\n            fprintf(stderr, \"cpage out of range (%d)\\n\", cpage);\n\n            return -1;\n\n        }\n\n\n\n        page  = p->qtd.bufptr[cpage] & QTD_BUFPTR_MASK;\n\n        page += offset;\n\n        plen  = bytes;\n\n        if (plen > 4096 - offset) {\n\n            plen = 4096 - offset;\n\n            offset = 0;\n\n            cpage++;\n\n        }\n\n\n\n        qemu_sglist_add(&p->sgl, page, plen);\n\n        bytes -= plen;\n\n    }\n\n    return 0;\n\n}\n", "idx": 1265, "_split": "valid", "_hash": "7c1ffb49751a81a7df6e397456a85716"}
{"project": "qemu", "commit_id": "c5a49c63fa26e8825ad101dfe86339ae4c216539", "target": 1, "func": "void gen_intermediate_code(CPUState *cs, TranslationBlock *tb)\n\n{\n\n    CPUM68KState *env = cs->env_ptr;\n\n    DisasContext dc1, *dc = &dc1;\n\n    target_ulong pc_start;\n\n    int pc_offset;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    /* generate intermediate code */\n\n    pc_start = tb->pc;\n\n\n\n    dc->tb = tb;\n\n\n\n    dc->env = env;\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->pc = pc_start;\n\n    dc->cc_op = CC_OP_DYNAMIC;\n\n    dc->cc_op_synced = 1;\n\n    dc->singlestep_enabled = cs->singlestep_enabled;\n\n    dc->user = (env->sr & SR_S) == 0;\n\n    dc->done_mac = 0;\n\n    dc->writeback_mask = 0;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0) {\n\n        max_insns = CF_COUNT_MASK;\n\n    }\n\n    if (max_insns > TCG_MAX_INSNS) {\n\n        max_insns = TCG_MAX_INSNS;\n\n    }\n\n\n\n    gen_tb_start(tb);\n\n    do {\n\n        pc_offset = dc->pc - pc_start;\n\n        gen_throws_exception = NULL;\n\n        tcg_gen_insn_start(dc->pc, dc->cc_op);\n\n        num_insns++;\n\n\n\n        if (unlikely(cpu_breakpoint_test(cs, dc->pc, BP_ANY))) {\n\n            gen_exception(dc, dc->pc, EXCP_DEBUG);\n\n            dc->is_jmp = DISAS_JUMP;\n\n            /* The address covered by the breakpoint must be included in\n\n               [tb->pc, tb->pc + tb->size) in order to for it to be\n\n               properly cleared -- thus we increment the PC here so that\n\n               the logic setting tb->size below does the right thing.  */\n\n            dc->pc += 2;\n\n            break;\n\n        }\n\n\n\n        if (num_insns == max_insns && (tb->cflags & CF_LAST_IO)) {\n\n            gen_io_start();\n\n        }\n\n\n\n        dc->insn_pc = dc->pc;\n\n\tdisas_m68k_insn(env, dc);\n\n    } while (!dc->is_jmp && !tcg_op_buf_full() &&\n\n             !cs->singlestep_enabled &&\n\n             !singlestep &&\n\n             (pc_offset) < (TARGET_PAGE_SIZE - 32) &&\n\n             num_insns < max_insns);\n\n\n\n    if (tb->cflags & CF_LAST_IO)\n\n        gen_io_end();\n\n    if (unlikely(cs->singlestep_enabled)) {\n\n        /* Make sure the pc is updated, and raise a debug exception.  */\n\n        if (!dc->is_jmp) {\n\n            update_cc_op(dc);\n\n            tcg_gen_movi_i32(QREG_PC, dc->pc);\n\n        }\n\n        gen_helper_raise_exception(cpu_env, tcg_const_i32(EXCP_DEBUG));\n\n    } else {\n\n        switch(dc->is_jmp) {\n\n        case DISAS_NEXT:\n\n            update_cc_op(dc);\n\n            gen_jmp_tb(dc, 0, dc->pc);\n\n            break;\n\n        default:\n\n        case DISAS_JUMP:\n\n        case DISAS_UPDATE:\n\n            update_cc_op(dc);\n\n            /* indicate that the hash table must be used to find the next TB */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case DISAS_TB_JUMP:\n\n            /* nothing more to generate */\n\n            break;\n\n        }\n\n    }\n\n    gen_tb_end(tb, num_insns);\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)\n\n        && qemu_log_in_addr_range(pc_start)) {\n\n        qemu_log_lock();\n\n        qemu_log(\"----------------\\n\");\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(cs, pc_start, dc->pc - pc_start, 0);\n\n        qemu_log(\"\\n\");\n\n        qemu_log_unlock();\n\n    }\n\n#endif\n\n    tb->size = dc->pc - pc_start;\n\n    tb->icount = num_insns;\n\n}\n", "idx": 1278, "_split": "valid", "_hash": "d40925757f5dfb5f85a7621c87a6cc38"}
{"project": "qemu", "commit_id": "260fecf13b0d30621dc88da03dc1b502b7358c6b", "target": 0, "func": "BdrvChild *bdrv_open_child(const char *filename,\n\n                           QDict *options, const char *bdref_key,\n\n                           BlockDriverState* parent,\n\n                           const BdrvChildRole *child_role,\n\n                           bool allow_none, Error **errp)\n\n{\n\n    BdrvChild *c = NULL;\n\n    BlockDriverState *bs;\n\n    QDict *image_options;\n\n    int ret;\n\n    char *bdref_key_dot;\n\n    const char *reference;\n\n\n\n    assert(child_role != NULL);\n\n\n\n    bdref_key_dot = g_strdup_printf(\"%s.\", bdref_key);\n\n    qdict_extract_subqdict(options, &image_options, bdref_key_dot);\n\n    g_free(bdref_key_dot);\n\n\n\n    reference = qdict_get_try_str(options, bdref_key);\n\n    if (!filename && !reference && !qdict_size(image_options)) {\n\n        if (!allow_none) {\n\n            error_setg(errp, \"A block device must be specified for \\\"%s\\\"\",\n\n                       bdref_key);\n\n        }\n\n        QDECREF(image_options);\n\n        goto done;\n\n    }\n\n\n\n    bs = NULL;\n\n    ret = bdrv_open_inherit(&bs, filename, reference, image_options, 0,\n\n                            parent, child_role, errp);\n\n    if (ret < 0) {\n\n        goto done;\n\n    }\n\n\n\n    c = bdrv_attach_child(parent, bs, child_role);\n\n\n\ndone:\n\n    qdict_del(options, bdref_key);\n\n    return c;\n\n}\n", "idx": 1292, "_split": "valid", "_hash": "955a2dfe9653e54463da515bbe058fe0"}
{"project": "qemu", "commit_id": "4c1396cb576c9b14425558b73de1584c7a9735d7", "target": 1, "func": "static void vapic_write(void *opaque, hwaddr addr, uint64_t data,\n\n                        unsigned int size)\n\n{\n\n    CPUState *cs = current_cpu;\n\n    X86CPU *cpu = X86_CPU(cs);\n\n    CPUX86State *env = &cpu->env;\n\n    hwaddr rom_paddr;\n\n    VAPICROMState *s = opaque;\n\n\n\n    cpu_synchronize_state(cs);\n\n\n\n    /*\n\n     * The VAPIC supports two PIO-based hypercalls, both via port 0x7E.\n\n     *  o 16-bit write access:\n\n     *    Reports the option ROM initialization to the hypervisor. Written\n\n     *    value is the offset of the state structure in the ROM.\n\n     *  o 8-bit write access:\n\n     *    Reactivates the VAPIC after a guest hibernation, i.e. after the\n\n     *    option ROM content has been re-initialized by a guest power cycle.\n\n     *  o 32-bit write access:\n\n     *    Poll for pending IRQs, considering the current VAPIC state.\n\n     */\n\n    switch (size) {\n\n    case 2:\n\n        if (s->state == VAPIC_INACTIVE) {\n\n            rom_paddr = (env->segs[R_CS].base + env->eip) & ROM_BLOCK_MASK;\n\n            s->rom_state_paddr = rom_paddr + data;\n\n\n\n            s->state = VAPIC_STANDBY;\n\n        }\n\n        if (vapic_prepare(s) < 0) {\n\n            s->state = VAPIC_INACTIVE;\n\n            s->rom_state_paddr = 0;\n\n            break;\n\n        }\n\n        break;\n\n    case 1:\n\n        if (kvm_enabled()) {\n\n            /*\n\n             * Disable triggering instruction in ROM by writing a NOP.\n\n             *\n\n             * We cannot do this in TCG mode as the reported IP is not\n\n             * accurate.\n\n             */\n\n            pause_all_vcpus();\n\n            patch_byte(cpu, env->eip - 2, 0x66);\n\n            patch_byte(cpu, env->eip - 1, 0x90);\n\n            resume_all_vcpus();\n\n        }\n\n\n\n        if (s->state == VAPIC_ACTIVE) {\n\n            break;\n\n        }\n\n        if (update_rom_mapping(s, env, env->eip) < 0) {\n\n            break;\n\n        }\n\n        if (find_real_tpr_addr(s, env) < 0) {\n\n            break;\n\n        }\n\n        vapic_enable(s, cpu);\n\n        break;\n\n    default:\n\n    case 4:\n\n        if (!kvm_irqchip_in_kernel()) {\n\n            apic_poll_irq(cpu->apic_state);\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 1337, "_split": "valid", "_hash": "8abb9448f84f038a5ad48c7359a8f42b"}
{"project": "qemu", "commit_id": "7c72ac49ae9f38fa0125296e05988655157decb5", "target": 0, "func": "static bool riccb_needed(void *opaque)\n\n{\n\n#ifdef CONFIG_KVM\n\n    if (kvm_enabled()) {\n\n        return kvm_s390_get_ri();\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 1347, "_split": "valid", "_hash": "a2474093b3af232f457aea17c69f622f"}
{"project": "qemu", "commit_id": "dde522bbc5feb2862afb243bb49c590fe65dce66", "target": 0, "func": "static int virtio_ccw_load_config(DeviceState *d, QEMUFile *f)\n\n{\n\n    VirtioCcwDevice *dev = VIRTIO_CCW_DEVICE(d);\n\n    CcwDevice *ccw_dev = CCW_DEVICE(d);\n\n    CCWDeviceClass *ck = CCW_DEVICE_GET_CLASS(ccw_dev);\n\n    SubchDev *s = ccw_dev->sch;\n\n    VirtIODevice *vdev = virtio_ccw_get_vdev(s);\n\n    int len;\n\n\n\n    s->driver_data = dev;\n\n    subch_device_load(s, f);\n\n    /* Re-fill subch_id after loading the subchannel states.*/\n\n    if (ck->refill_ids) {\n\n        ck->refill_ids(ccw_dev);\n\n    }\n\n    len = qemu_get_be32(f);\n\n    if (len != 0) {\n\n        dev->indicators = get_indicator(qemu_get_be64(f), len);\n\n    } else {\n\n        qemu_get_be64(f);\n\n        dev->indicators = NULL;\n\n    }\n\n    len = qemu_get_be32(f);\n\n    if (len != 0) {\n\n        dev->indicators2 = get_indicator(qemu_get_be64(f), len);\n\n    } else {\n\n        qemu_get_be64(f);\n\n        dev->indicators2 = NULL;\n\n    }\n\n    len = qemu_get_be32(f);\n\n    if (len != 0) {\n\n        dev->summary_indicator = get_indicator(qemu_get_be64(f), len);\n\n    } else {\n\n        qemu_get_be64(f);\n\n        dev->summary_indicator = NULL;\n\n    }\n\n    qemu_get_be16s(f, &vdev->config_vector);\n\n    dev->routes.adapter.ind_offset = qemu_get_be64(f);\n\n    dev->thinint_isc = qemu_get_byte(f);\n\n    dev->revision = qemu_get_be32(f);\n\n    if (s->thinint_active) {\n\n        return css_register_io_adapter(CSS_IO_ADAPTER_VIRTIO,\n\n                                       dev->thinint_isc, true, false,\n\n                                       &dev->routes.adapter.adapter_id);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 1361, "_split": "valid", "_hash": "4cf49c873fc7be13d3ffab0548a50694"}
{"project": "qemu", "commit_id": "8a0e11045d5f50d300e0ab1ba05f4c8217fb5dcb", "target": 0, "func": "PCIBus *pci_pmac_u3_init(qemu_irq *pic,\n\n                         MemoryRegion *address_space_mem,\n\n                         MemoryRegion *address_space_io)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    PCIHostState *h;\n\n    UNINState *d;\n\n\n\n    /* Uninorth AGP bus */\n\n\n\n    dev = qdev_create(NULL, TYPE_U3_AGP_HOST_BRIDGE);\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n    h = PCI_HOST_BRIDGE(dev);\n\n    d = U3_AGP_HOST_BRIDGE(dev);\n\n\n\n    memory_region_init(&d->pci_mmio, OBJECT(d), \"pci-mmio\", 0x100000000ULL);\n\n    memory_region_init_alias(&d->pci_hole, OBJECT(d), \"pci-hole\", &d->pci_mmio,\n\n                             0x80000000ULL, 0x70000000ULL);\n\n    memory_region_add_subregion(address_space_mem, 0x80000000ULL,\n\n                                &d->pci_hole);\n\n\n\n    h->bus = pci_register_bus(dev, \"pci\",\n\n                              pci_unin_set_irq, pci_unin_map_irq,\n\n                              pic,\n\n                              &d->pci_mmio,\n\n                              address_space_io,\n\n                              PCI_DEVFN(11, 0), 4, TYPE_PCI_BUS);\n\n\n\n    sysbus_mmio_map(s, 0, 0xf0800000);\n\n    sysbus_mmio_map(s, 1, 0xf0c00000);\n\n\n\n    pci_create_simple(h->bus, 11 << 3, \"u3-agp\");\n\n\n\n    return h->bus;\n\n}\n", "idx": 1366, "_split": "valid", "_hash": "f9139d671bc31af537ebac3f9973309e"}
{"project": "qemu", "commit_id": "0e438cdc932a785de72166af4641aafa103a6670", "target": 1, "func": "void coroutine_fn qemu_co_mutex_lock(CoMutex *mutex)\n\n{\n\n    Coroutine *self = qemu_coroutine_self();\n\n\n\n    trace_qemu_co_mutex_lock_entry(mutex, self);\n\n\n\n    while (mutex->locked) {\n\n        qemu_co_queue_wait(&mutex->queue);\n\n    }\n\n\n\n    mutex->locked = true;\n\n\n\n\n    trace_qemu_co_mutex_lock_return(mutex, self);\n\n}", "idx": 1385, "_split": "valid", "_hash": "2e8788fff9c4ed9c91ffa6ba594df103"}
{"project": "qemu", "commit_id": "3e9fab690d59ac15956c3733fe0794ce1ae4c4af", "target": 1, "func": "void hmp_info_block(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockInfoList *block_list, *info;\n\n    ImageInfo *image_info;\n\n    const char *device = qdict_get_try_str(qdict, \"device\");\n\n    bool verbose = qdict_get_try_bool(qdict, \"verbose\", 0);\n\n\n\n    block_list = qmp_query_block(NULL);\n\n\n\n    for (info = block_list; info; info = info->next) {\n\n        if (device && strcmp(device, info->value->device)) {\n\n            continue;\n\n        }\n\n\n\n        if (info != block_list) {\n\n            monitor_printf(mon, \"\\n\");\n\n        }\n\n\n\n        monitor_printf(mon, \"%s\", info->value->device);\n\n        if (info->value->has_inserted) {\n\n            monitor_printf(mon, \": %s (%s%s%s)\\n\",\n\n                           info->value->inserted->file,\n\n                           info->value->inserted->drv,\n\n                           info->value->inserted->ro ? \", read-only\" : \"\",\n\n                           info->value->inserted->encrypted ? \", encrypted\" : \"\");\n\n        } else {\n\n            monitor_printf(mon, \": [not inserted]\\n\");\n\n        }\n\n\n\n        if (info->value->has_io_status && info->value->io_status != BLOCK_DEVICE_IO_STATUS_OK) {\n\n            monitor_printf(mon, \"    I/O status:       %s\\n\",\n\n                           BlockDeviceIoStatus_lookup[info->value->io_status]);\n\n        }\n\n\n\n        if (info->value->removable) {\n\n            monitor_printf(mon, \"    Removable device: %slocked, tray %s\\n\",\n\n                           info->value->locked ? \"\" : \"not \",\n\n                           info->value->tray_open ? \"open\" : \"closed\");\n\n        }\n\n\n\n\n\n        if (!info->value->has_inserted) {\n\n            continue;\n\n        }\n\n\n\n        if (info->value->inserted->has_backing_file) {\n\n            monitor_printf(mon,\n\n                           \"    Backing file:     %s \"\n\n                           \"(chain depth: %\" PRId64 \")\\n\",\n\n                           info->value->inserted->backing_file,\n\n                           info->value->inserted->backing_file_depth);\n\n        }\n\n\n\n        if (info->value->inserted->bps\n\n            || info->value->inserted->bps_rd\n\n            || info->value->inserted->bps_wr\n\n            || info->value->inserted->iops\n\n            || info->value->inserted->iops_rd\n\n            || info->value->inserted->iops_wr)\n\n        {\n\n            monitor_printf(mon, \"    I/O throttling:   bps=%\" PRId64\n\n                            \" bps_rd=%\" PRId64  \" bps_wr=%\" PRId64\n\n                            \" iops=%\" PRId64 \" iops_rd=%\" PRId64\n\n                            \" iops_wr=%\" PRId64 \"\\n\",\n\n                            info->value->inserted->bps,\n\n                            info->value->inserted->bps_rd,\n\n                            info->value->inserted->bps_wr,\n\n                            info->value->inserted->iops,\n\n                            info->value->inserted->iops_rd,\n\n                            info->value->inserted->iops_wr);\n\n        }\n\n\n\n        if (verbose) {\n\n            monitor_printf(mon, \"\\nImages:\\n\");\n\n            image_info = info->value->inserted->image;\n\n            while (1) {\n\n                    bdrv_image_info_dump((fprintf_function)monitor_printf,\n\n                                         mon, image_info);\n\n                if (image_info->has_backing_image) {\n\n                    image_info = image_info->backing_image;\n\n                } else {\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    qapi_free_BlockInfoList(block_list);\n\n}\n", "idx": 1387, "_split": "valid", "_hash": "9e39588ffd9ce75f1c4f9a44f4def619"}
{"project": "qemu", "commit_id": "962d4b2834e6a3b37784391a906b5fe2a7e96b74", "target": 1, "func": "static void fw_cfg_write(FWCfgState *s, uint8_t value)\n\n{\n\n    int arch = !!(s->cur_entry & FW_CFG_ARCH_LOCAL);\n\n    FWCfgEntry *e = &s->entries[arch][s->cur_entry & FW_CFG_ENTRY_MASK];\n\n\n\n    FW_CFG_DPRINTF(\"write %d\\n\", value);\n\n\n\n    if (s->cur_entry & FW_CFG_WRITE_CHANNEL && s->cur_offset < e->len) {\n\n        e->data[s->cur_offset++] = value;\n\n        if (s->cur_offset == e->len) {\n\n            e->callback(e->callback_opaque, e->data);\n\n            s->cur_offset = 0;\n\n        }\n\n    }\n\n}\n", "idx": 1407, "_split": "valid", "_hash": "e665a028e73adf9a42ba725ab962947c"}
{"project": "qemu", "commit_id": "548f52ea06951c20f0b91cae6cde0512ec073c83", "target": 1, "func": "int qemu_peek_buffer(QEMUFile *f, uint8_t *buf, int size, size_t offset)\n\n{\n\n    int pending;\n\n    int index;\n\n\n\n    assert(!qemu_file_is_writable(f));\n\n\n\n    index = f->buf_index + offset;\n\n    pending = f->buf_size - index;\n\n    if (pending < size) {\n\n        qemu_fill_buffer(f);\n\n        index = f->buf_index + offset;\n\n        pending = f->buf_size - index;\n\n    }\n\n\n\n    if (pending <= 0) {\n\n        return 0;\n\n    }\n\n    if (size > pending) {\n\n        size = pending;\n\n    }\n\n\n\n    memcpy(buf, f->buf + index, size);\n\n    return size;\n\n}\n", "idx": 1409, "_split": "valid", "_hash": "aff7bf996f70983c236e8172dc61ceb1"}
{"project": "qemu", "commit_id": "61f52e06f0a21bab782f98ef3ea789aa6d0aa046", "target": 1, "func": "static int ahci_dma_rw_buf(IDEDMA *dma, int is_write)\n\n{\n\n    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);\n\n    IDEState *s = &ad->port.ifs[0];\n\n    uint8_t *p = s->io_buffer + s->io_buffer_index;\n\n    int l = s->io_buffer_size - s->io_buffer_index;\n\n\n\n    if (ahci_populate_sglist(ad, &s->sg)) {\n\n        return 0;\n\n    }\n\n\n\n    if (is_write) {\n\n        dma_buf_read(p, l, &s->sg);\n\n    } else {\n\n        dma_buf_write(p, l, &s->sg);\n\n    }\n\n\n\n    /* update number of transferred bytes */\n\n    ad->cur_cmd->status = cpu_to_le32(le32_to_cpu(ad->cur_cmd->status) + l);\n\n    s->io_buffer_index += l;\n\n\n\n    DPRINTF(ad->port_no, \"len=%#x\\n\", l);\n\n\n\n    return 1;\n\n}\n", "idx": 1410, "_split": "valid", "_hash": "0c7fd84afba78e75e95a280ecaa8ddd5"}
{"project": "qemu", "commit_id": "ea375f9ab8c76686dca0af8cb4f87a4eb569cad3", "target": 1, "func": "void cpu_save(QEMUFile *f, void *opaque)\n\n{\n\n    CPUState *env = (CPUState *)opaque;\n\n    unsigned int i, j;\n\n\n\n    cpu_synchronize_state(env);\n\n\n\n    for (i = 0; i < 32; i++)\n\n        qemu_put_betls(f, &env->gpr[i]);\n\n#if !defined(TARGET_PPC64)\n\n    for (i = 0; i < 32; i++)\n\n        qemu_put_betls(f, &env->gprh[i]);\n\n#endif\n\n    qemu_put_betls(f, &env->lr);\n\n    qemu_put_betls(f, &env->ctr);\n\n    for (i = 0; i < 8; i++)\n\n        qemu_put_be32s(f, &env->crf[i]);\n\n    qemu_put_betls(f, &env->xer);\n\n    qemu_put_betls(f, &env->reserve_addr);\n\n    qemu_put_betls(f, &env->msr);\n\n    for (i = 0; i < 4; i++)\n\n        qemu_put_betls(f, &env->tgpr[i]);\n\n    for (i = 0; i < 32; i++) {\n\n        union {\n\n            float64 d;\n\n            uint64_t l;\n\n        } u;\n\n        u.d = env->fpr[i];\n\n        qemu_put_be64(f, u.l);\n\n    }\n\n    qemu_put_be32s(f, &env->fpscr);\n\n    qemu_put_sbe32s(f, &env->access_type);\n\n#if !defined(CONFIG_USER_ONLY)\n\n#if defined(TARGET_PPC64)\n\n    qemu_put_betls(f, &env->asr);\n\n    qemu_put_sbe32s(f, &env->slb_nr);\n\n#endif\n\n    qemu_put_betls(f, &env->sdr1);\n\n    for (i = 0; i < 32; i++)\n\n        qemu_put_betls(f, &env->sr[i]);\n\n    for (i = 0; i < 2; i++)\n\n        for (j = 0; j < 8; j++)\n\n            qemu_put_betls(f, &env->DBAT[i][j]);\n\n    for (i = 0; i < 2; i++)\n\n        for (j = 0; j < 8; j++)\n\n            qemu_put_betls(f, &env->IBAT[i][j]);\n\n    qemu_put_sbe32s(f, &env->nb_tlb);\n\n    qemu_put_sbe32s(f, &env->tlb_per_way);\n\n    qemu_put_sbe32s(f, &env->nb_ways);\n\n    qemu_put_sbe32s(f, &env->last_way);\n\n    qemu_put_sbe32s(f, &env->id_tlbs);\n\n    qemu_put_sbe32s(f, &env->nb_pids);\n\n    if (env->tlb) {\n\n        // XXX assumes 6xx\n\n        for (i = 0; i < env->nb_tlb; i++) {\n\n            qemu_put_betls(f, &env->tlb[i].tlb6.pte0);\n\n            qemu_put_betls(f, &env->tlb[i].tlb6.pte1);\n\n            qemu_put_betls(f, &env->tlb[i].tlb6.EPN);\n\n        }\n\n    }\n\n    for (i = 0; i < 4; i++)\n\n        qemu_put_betls(f, &env->pb[i]);\n\n#endif\n\n    for (i = 0; i < 1024; i++)\n\n        qemu_put_betls(f, &env->spr[i]);\n\n    qemu_put_be32s(f, &env->vscr);\n\n    qemu_put_be64s(f, &env->spe_acc);\n\n    qemu_put_be32s(f, &env->spe_fscr);\n\n    qemu_put_betls(f, &env->msr_mask);\n\n    qemu_put_be32s(f, &env->flags);\n\n    qemu_put_sbe32s(f, &env->error_code);\n\n    qemu_put_be32s(f, &env->pending_interrupts);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    qemu_put_be32s(f, &env->irq_input_state);\n\n    for (i = 0; i < POWERPC_EXCP_NB; i++)\n\n        qemu_put_betls(f, &env->excp_vectors[i]);\n\n    qemu_put_betls(f, &env->excp_prefix);\n\n    qemu_put_betls(f, &env->hreset_excp_prefix);\n\n    qemu_put_betls(f, &env->ivor_mask);\n\n    qemu_put_betls(f, &env->ivpr_mask);\n\n    qemu_put_betls(f, &env->hreset_vector);\n\n#endif\n\n    qemu_put_betls(f, &env->nip);\n\n    qemu_put_betls(f, &env->hflags);\n\n    qemu_put_betls(f, &env->hflags_nmsr);\n\n    qemu_put_sbe32s(f, &env->mmu_idx);\n\n    qemu_put_sbe32s(f, &env->power_mode);\n\n}\n", "idx": 1416, "_split": "valid", "_hash": "662931f9dce483f156a09797aaf8aa84"}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static DeviceState *sun4c_intctl_init(target_phys_addr_t addr,\n\n                                      qemu_irq *parent_irq)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    unsigned int i;\n\n\n\n    dev = qdev_create(NULL, \"sun4c_intctl\");\n\n    qdev_init(dev);\n\n\n\n    s = sysbus_from_qdev(dev);\n\n\n\n    for (i = 0; i < MAX_PILS; i++) {\n\n        sysbus_connect_irq(s, i, parent_irq[i]);\n\n    }\n\n    sysbus_mmio_map(s, 0, addr);\n\n\n\n    return dev;\n\n}\n", "idx": 1418, "_split": "valid", "_hash": "35003f56a8258a2e207f1c2056821ec1"}
{"project": "qemu", "commit_id": "fff895dfdbe41965f7b0430e3d9e8b7bd8fc8eda", "target": 1, "func": "static bool adding_first_cpu(void)\n\n{\n\n    CPUState *cpu;\n\n    size_t count = 0;\n\n    CPU_FOREACH(cpu) {\n\n        count++;\n\n        if (count > 1) {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n", "idx": 1451, "_split": "valid", "_hash": "b2aa778a83c16872675ed25564e083d4"}
{"project": "qemu", "commit_id": "b1b1dad31f3a092e046b09795f4476705c4e564e", "target": 1, "func": "static int aio_write_f(int argc, char **argv)\n\n{\n\n    int nr_iov, c;\n\n    int pattern = 0xcd;\n\n    struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));\n\n    BlockDriverAIOCB *acb;\n\n\n\n    while ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n        switch (c) {\n\n        case 'C':\n\n            ctx->Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            ctx->qflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n\n                return 0;\n\n            }\n\n            break;\n\n        default:\n\n\n            return command_usage(&aio_write_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n\n        return command_usage(&aio_write_cmd);\n\n    }\n\n\n\n    ctx->offset = cvtnum(argv[optind]);\n\n    if (ctx->offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (ctx->offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               ctx->offset);\n\n\n        return 0;\n\n    }\n\n\n\n    nr_iov = argc - optind;\n\n    ctx->buf = create_iovec(&ctx->qiov, &argv[optind], nr_iov, pattern);\n\n\n\n    gettimeofday(&ctx->t1, NULL);\n\n    acb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,\n\n                          ctx->qiov.size >> 9, aio_write_done, ctx);\n\n    if (!acb) {\n\n        free(ctx->buf);\n\n\n        return -EIO;\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 1509, "_split": "valid", "_hash": "dbcdb052a7596de803604c65123ab08e"}
{"project": "qemu", "commit_id": "924e8a2bbc7cc62b3996efe9a2a460f541c04520", "target": 1, "func": "static coroutine_fn int quorum_co_flush(BlockDriverState *bs)\n\n{\n\n    BDRVQuorumState *s = bs->opaque;\n\n    QuorumVoteVersion *winner = NULL;\n\n    QuorumVotes error_votes;\n\n    QuorumVoteValue result_value;\n\n    int i;\n\n    int result = 0;\n\n\n\n    QLIST_INIT(&error_votes.vote_list);\n\n    error_votes.compare = quorum_64bits_compare;\n\n\n\n    for (i = 0; i < s->num_children; i++) {\n\n        result = bdrv_co_flush(s->children[i]->bs);\n\n        result_value.l = result;\n\n        quorum_count_vote(&error_votes, &result_value, i);\n\n    }\n\n\n\n    winner = quorum_get_vote_winner(&error_votes);\n\n    result = winner->value.l;\n\n\n\n    quorum_free_vote_list(&error_votes);\n\n\n\n    return result;\n\n}\n", "idx": 1528, "_split": "valid", "_hash": "06da8af1c1878e7015f9d48d45112cce"}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_qemu_st(TCGContext *s, TCGReg data, TCGReg addr,\n\n                            TCGMemOpIdx oi)\n\n{\n\n    TCGMemOp memop = get_memop(oi);\n\n#ifdef CONFIG_SOFTMMU\n\n    unsigned memi = get_mmuidx(oi);\n\n    TCGReg addrz, param;\n\n    tcg_insn_unit *func;\n\n    tcg_insn_unit *label_ptr;\n\n\n\n    addrz = tcg_out_tlb_load(s, addr, memi, memop & MO_SIZE,\n\n                             offsetof(CPUTLBEntry, addr_write));\n\n\n\n    /* The fast path is exactly one insn.  Thus we can perform the entire\n\n       TLB Hit in the (annulled) delay slot of the branch over TLB Miss.  */\n\n    /* beq,a,pt %[xi]cc, label0 */\n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT\n\n                  | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);\n\n    /* delay slot */\n\n    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,\n\n                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);\n\n\n\n    /* TLB Miss.  */\n\n\n\n    param = TCG_REG_O1;\n\n    if (!SPARC64 && TARGET_LONG_BITS == 64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, addr);\n\n    if (!SPARC64 && (memop & MO_SIZE) == MO_64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, data);\n\n\n\n    func = qemu_st_trampoline[memop & (MO_BSWAP | MO_SIZE)];\n\n    assert(func != NULL);\n\n    tcg_out_call_nodelay(s, func);\n\n    /* delay slot */\n\n    tcg_out_movi(s, TCG_TYPE_I32, param, oi);\n\n\n\n    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));\n\n#else\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);\n\n        addr = TCG_REG_T1;\n\n    }\n\n    tcg_out_ldst_rr(s, data, addr,\n\n                    (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0),\n\n                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);\n\n#endif /* CONFIG_SOFTMMU */\n\n}\n", "idx": 1563, "_split": "valid", "_hash": "bf1355f592deb8bb08b3a0f846a85361"}
{"project": "qemu", "commit_id": "9456c2fbcd82dd82328ac6e7602a815582b1043e", "target": 0, "func": "void r4k_helper_tlbr(CPUMIPSState *env)\n\n{\n\n    r4k_tlb_t *tlb;\n\n    uint8_t ASID;\n\n    int idx;\n\n\n\n    ASID = env->CP0_EntryHi & 0xFF;\n\n    idx = (env->CP0_Index & ~0x80000000) % env->tlb->nb_tlb;\n\n    tlb = &env->tlb->mmu.r4k.tlb[idx];\n\n\n\n    /* If this will change the current ASID, flush qemu's TLB.  */\n\n    if (ASID != tlb->ASID)\n\n        cpu_mips_tlb_flush (env, 1);\n\n\n\n    r4k_mips_tlb_flush_extra(env, env->tlb->nb_tlb);\n\n\n\n    env->CP0_EntryHi = tlb->VPN | tlb->ASID;\n\n    env->CP0_PageMask = tlb->PageMask;\n\n    env->CP0_EntryLo0 = tlb->G | (tlb->V0 << 1) | (tlb->D0 << 2) |\n\n                        ((target_ulong)tlb->RI0 << CP0EnLo_RI) |\n\n                        ((target_ulong)tlb->XI0 << CP0EnLo_XI) |\n\n                        (tlb->C0 << 3) | (tlb->PFN[0] >> 6);\n\n    env->CP0_EntryLo1 = tlb->G | (tlb->V1 << 1) | (tlb->D1 << 2) |\n\n                        ((target_ulong)tlb->RI1 << CP0EnLo_RI) |\n\n                        ((target_ulong)tlb->XI1 << CP0EnLo_XI) |\n\n                        (tlb->C1 << 3) | (tlb->PFN[1] >> 6);\n\n}\n", "idx": 1565, "_split": "valid", "_hash": "f5f8855921584d77e4606006b5555796"}
{"project": "qemu", "commit_id": "0ce470cd4ca88e84e547a3b95159d23ce6be419e", "target": 0, "func": "int kvmppc_fixup_cpu(PowerPCCPU *cpu)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    int smt;\n\n\n\n    /* Adjust cpu index for SMT */\n\n    smt = kvmppc_smt_threads();\n\n    cs->cpu_index = (cs->cpu_index / smp_threads) * smt\n\n        + (cs->cpu_index % smp_threads);\n\n\n\n    return 0;\n\n}\n", "idx": 1572, "_split": "valid", "_hash": "0abeaf8929f79bb7da54221b323586b4"}
{"project": "qemu", "commit_id": "2c9ee0291f8ca7e18f8e96a34e8f4be7867219d2", "target": 1, "func": "static void *spapr_create_fdt_skel(const char *cpu_model,\n\n                                   hwaddr initrd_base,\n\n                                   hwaddr initrd_size,\n\n                                   hwaddr kernel_size,\n\n                                   const char *boot_device,\n\n                                   const char *kernel_cmdline,\n\n                                   uint32_t epow_irq)\n\n{\n\n    void *fdt;\n\n    CPUPPCState *env;\n\n    uint32_t start_prop = cpu_to_be32(initrd_base);\n\n    uint32_t end_prop = cpu_to_be32(initrd_base + initrd_size);\n\n    char hypertas_prop[] = \"hcall-pft\\0hcall-term\\0hcall-dabr\\0hcall-interrupt\"\n\n        \"\\0hcall-tce\\0hcall-vio\\0hcall-splpar\\0hcall-bulk\";\n\n    char qemu_hypertas_prop[] = \"hcall-memop1\";\n\n    uint32_t refpoints[] = {cpu_to_be32(0x4), cpu_to_be32(0x4)};\n\n    uint32_t interrupt_server_ranges_prop[] = {0, cpu_to_be32(smp_cpus)};\n\n    char *modelname;\n\n    int i, smt = kvmppc_smt_threads();\n\n    unsigned char vec5[] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x80};\n\n\n\n    fdt = g_malloc0(FDT_MAX_SIZE);\n\n    _FDT((fdt_create(fdt, FDT_MAX_SIZE)));\n\n\n\n    if (kernel_size) {\n\n        _FDT((fdt_add_reservemap_entry(fdt, KERNEL_LOAD_ADDR, kernel_size)));\n\n    }\n\n    if (initrd_size) {\n\n        _FDT((fdt_add_reservemap_entry(fdt, initrd_base, initrd_size)));\n\n    }\n\n    _FDT((fdt_finish_reservemap(fdt)));\n\n\n\n    /* Root node */\n\n    _FDT((fdt_begin_node(fdt, \"\")));\n\n    _FDT((fdt_property_string(fdt, \"device_type\", \"chrp\")));\n\n    _FDT((fdt_property_string(fdt, \"model\", \"IBM pSeries (emulated by qemu)\")));\n\n\n\n    _FDT((fdt_property_cell(fdt, \"#address-cells\", 0x2)));\n\n    _FDT((fdt_property_cell(fdt, \"#size-cells\", 0x2)));\n\n\n\n    /* /chosen */\n\n    _FDT((fdt_begin_node(fdt, \"chosen\")));\n\n\n\n    /* Set Form1_affinity */\n\n    _FDT((fdt_property(fdt, \"ibm,architecture-vec-5\", vec5, sizeof(vec5))));\n\n\n\n    _FDT((fdt_property_string(fdt, \"bootargs\", kernel_cmdline)));\n\n    _FDT((fdt_property(fdt, \"linux,initrd-start\",\n\n                       &start_prop, sizeof(start_prop))));\n\n    _FDT((fdt_property(fdt, \"linux,initrd-end\",\n\n                       &end_prop, sizeof(end_prop))));\n\n    if (kernel_size) {\n\n        uint64_t kprop[2] = { cpu_to_be64(KERNEL_LOAD_ADDR),\n\n                              cpu_to_be64(kernel_size) };\n\n\n\n        _FDT((fdt_property(fdt, \"qemu,boot-kernel\", &kprop, sizeof(kprop))));\n\n    }\n\n    _FDT((fdt_property_string(fdt, \"qemu,boot-device\", boot_device)));\n\n    _FDT((fdt_property_cell(fdt, \"qemu,graphic-width\", graphic_width)));\n\n    _FDT((fdt_property_cell(fdt, \"qemu,graphic-height\", graphic_height)));\n\n    _FDT((fdt_property_cell(fdt, \"qemu,graphic-depth\", graphic_depth)));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* cpus */\n\n    _FDT((fdt_begin_node(fdt, \"cpus\")));\n\n\n\n    _FDT((fdt_property_cell(fdt, \"#address-cells\", 0x1)));\n\n    _FDT((fdt_property_cell(fdt, \"#size-cells\", 0x0)));\n\n\n\n    modelname = g_strdup(cpu_model);\n\n\n\n    for (i = 0; i < strlen(modelname); i++) {\n\n        modelname[i] = toupper(modelname[i]);\n\n    }\n\n\n\n    /* This is needed during FDT finalization */\n\n    spapr->cpu_model = g_strdup(modelname);\n\n\n\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n\n        CPUState *cpu = CPU(ppc_env_get_cpu(env));\n\n        int index = cpu->cpu_index;\n\n        uint32_t servers_prop[smp_threads];\n\n        uint32_t gservers_prop[smp_threads * 2];\n\n        char *nodename;\n\n        uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),\n\n                           0xffffffff, 0xffffffff};\n\n        uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq() : TIMEBASE_FREQ;\n\n        uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;\n\n        uint32_t page_sizes_prop[64];\n\n        size_t page_sizes_prop_size;\n\n\n\n        if ((index % smt) != 0) {\n\n            continue;\n\n        }\n\n\n\n        if (asprintf(&nodename, \"%s@%x\", modelname, index) < 0) {\n\n            fprintf(stderr, \"Allocation failure\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        _FDT((fdt_begin_node(fdt, nodename)));\n\n\n\n        free(nodename);\n\n\n\n        _FDT((fdt_property_cell(fdt, \"reg\", index)));\n\n        _FDT((fdt_property_string(fdt, \"device_type\", \"cpu\")));\n\n\n\n        _FDT((fdt_property_cell(fdt, \"cpu-version\", env->spr[SPR_PVR])));\n\n        _FDT((fdt_property_cell(fdt, \"dcache-block-size\",\n\n                                env->dcache_line_size)));\n\n        _FDT((fdt_property_cell(fdt, \"icache-block-size\",\n\n                                env->icache_line_size)));\n\n        _FDT((fdt_property_cell(fdt, \"timebase-frequency\", tbfreq)));\n\n        _FDT((fdt_property_cell(fdt, \"clock-frequency\", cpufreq)));\n\n        _FDT((fdt_property_cell(fdt, \"ibm,slb-size\", env->slb_nr)));\n\n        _FDT((fdt_property_string(fdt, \"status\", \"okay\")));\n\n        _FDT((fdt_property(fdt, \"64-bit\", NULL, 0)));\n\n\n\n        /* Build interrupt servers and gservers properties */\n\n        for (i = 0; i < smp_threads; i++) {\n\n            servers_prop[i] = cpu_to_be32(index + i);\n\n            /* Hack, direct the group queues back to cpu 0 */\n\n            gservers_prop[i*2] = cpu_to_be32(index + i);\n\n            gservers_prop[i*2 + 1] = 0;\n\n        }\n\n        _FDT((fdt_property(fdt, \"ibm,ppc-interrupt-server#s\",\n\n                           servers_prop, sizeof(servers_prop))));\n\n        _FDT((fdt_property(fdt, \"ibm,ppc-interrupt-gserver#s\",\n\n                           gservers_prop, sizeof(gservers_prop))));\n\n\n\n        if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n            _FDT((fdt_property(fdt, \"ibm,processor-segment-sizes\",\n\n                               segs, sizeof(segs))));\n\n        }\n\n\n\n        /* Advertise VMX/VSX (vector extensions) if available\n\n         *   0 / no property == no vector extensions\n\n         *   1               == VMX / Altivec available\n\n         *   2               == VSX available */\n\n        if (env->insns_flags & PPC_ALTIVEC) {\n\n            uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;\n\n\n\n            _FDT((fdt_property_cell(fdt, \"ibm,vmx\", vmx)));\n\n        }\n\n\n\n        /* Advertise DFP (Decimal Floating Point) if available\n\n         *   0 / no property == no DFP\n\n         *   1               == DFP available */\n\n        if (env->insns_flags2 & PPC2_DFP) {\n\n            _FDT((fdt_property_cell(fdt, \"ibm,dfp\", 1)));\n\n        }\n\n\n\n        page_sizes_prop_size = create_page_sizes_prop(env, page_sizes_prop,\n\n                                                      sizeof(page_sizes_prop));\n\n        if (page_sizes_prop_size) {\n\n            _FDT((fdt_property(fdt, \"ibm,segment-page-sizes\",\n\n                               page_sizes_prop, page_sizes_prop_size)));\n\n        }\n\n\n\n        _FDT((fdt_end_node(fdt)));\n\n    }\n\n\n\n    g_free(modelname);\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* RTAS */\n\n    _FDT((fdt_begin_node(fdt, \"rtas\")));\n\n\n\n    _FDT((fdt_property(fdt, \"ibm,hypertas-functions\", hypertas_prop,\n\n                       sizeof(hypertas_prop))));\n\n    _FDT((fdt_property(fdt, \"qemu,hypertas-functions\", qemu_hypertas_prop,\n\n                       sizeof(qemu_hypertas_prop))));\n\n\n\n    _FDT((fdt_property(fdt, \"ibm,associativity-reference-points\",\n\n        refpoints, sizeof(refpoints))));\n\n\n\n    _FDT((fdt_property_cell(fdt, \"rtas-error-log-max\", RTAS_ERROR_LOG_MAX)));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* interrupt controller */\n\n    _FDT((fdt_begin_node(fdt, \"interrupt-controller\")));\n\n\n\n    _FDT((fdt_property_string(fdt, \"device_type\",\n\n                              \"PowerPC-External-Interrupt-Presentation\")));\n\n    _FDT((fdt_property_string(fdt, \"compatible\", \"IBM,ppc-xicp\")));\n\n    _FDT((fdt_property(fdt, \"interrupt-controller\", NULL, 0)));\n\n    _FDT((fdt_property(fdt, \"ibm,interrupt-server-ranges\",\n\n                       interrupt_server_ranges_prop,\n\n                       sizeof(interrupt_server_ranges_prop))));\n\n    _FDT((fdt_property_cell(fdt, \"#interrupt-cells\", 2)));\n\n    _FDT((fdt_property_cell(fdt, \"linux,phandle\", PHANDLE_XICP)));\n\n    _FDT((fdt_property_cell(fdt, \"phandle\", PHANDLE_XICP)));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* vdevice */\n\n    _FDT((fdt_begin_node(fdt, \"vdevice\")));\n\n\n\n    _FDT((fdt_property_string(fdt, \"device_type\", \"vdevice\")));\n\n    _FDT((fdt_property_string(fdt, \"compatible\", \"IBM,vdevice\")));\n\n    _FDT((fdt_property_cell(fdt, \"#address-cells\", 0x1)));\n\n    _FDT((fdt_property_cell(fdt, \"#size-cells\", 0x0)));\n\n    _FDT((fdt_property_cell(fdt, \"#interrupt-cells\", 0x2)));\n\n    _FDT((fdt_property(fdt, \"interrupt-controller\", NULL, 0)));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* event-sources */\n\n    spapr_events_fdt_skel(fdt, epow_irq);\n\n\n\n    _FDT((fdt_end_node(fdt))); /* close root node */\n\n    _FDT((fdt_finish(fdt)));\n\n\n\n    return fdt;\n\n}\n", "idx": 1578, "_split": "valid", "_hash": "5580de871069a0cd7e3463fb65393490"}
{"project": "qemu", "commit_id": "2f859f80c2077e00237ea1dfae2523ebd8377f5f", "target": 0, "func": "static int create_header64(DumpState *s)\n\n{\n\n    int ret = 0;\n\n    DiskDumpHeader64 *dh = NULL;\n\n    KdumpSubHeader64 *kh = NULL;\n\n    size_t size;\n\n    int endian = s->dump_info.d_endian;\n\n    uint32_t block_size;\n\n    uint32_t sub_hdr_size;\n\n    uint32_t bitmap_blocks;\n\n    uint32_t status = 0;\n\n    uint64_t offset_note;\n\n\n\n    /* write common header, the version of kdump-compressed format is 6th */\n\n    size = sizeof(DiskDumpHeader64);\n\n    dh = g_malloc0(size);\n\n\n\n    strncpy(dh->signature, KDUMP_SIGNATURE, strlen(KDUMP_SIGNATURE));\n\n    dh->header_version = cpu_convert_to_target32(6, endian);\n\n    block_size = s->page_size;\n\n    dh->block_size = cpu_convert_to_target32(block_size, endian);\n\n    sub_hdr_size = sizeof(struct KdumpSubHeader64) + s->note_size;\n\n    sub_hdr_size = DIV_ROUND_UP(sub_hdr_size, block_size);\n\n    dh->sub_hdr_size = cpu_convert_to_target32(sub_hdr_size, endian);\n\n    /* dh->max_mapnr may be truncated, full 64bit is in kh.max_mapnr_64 */\n\n    dh->max_mapnr = cpu_convert_to_target32(MIN(s->max_mapnr, UINT_MAX),\n\n                                            endian);\n\n    dh->nr_cpus = cpu_convert_to_target32(s->nr_cpus, endian);\n\n    bitmap_blocks = DIV_ROUND_UP(s->len_dump_bitmap, block_size) * 2;\n\n    dh->bitmap_blocks = cpu_convert_to_target32(bitmap_blocks, endian);\n\n    strncpy(dh->utsname.machine, ELF_MACHINE_UNAME, sizeof(dh->utsname.machine));\n\n\n\n    if (s->flag_compress & DUMP_DH_COMPRESSED_ZLIB) {\n\n        status |= DUMP_DH_COMPRESSED_ZLIB;\n\n    }\n\n#ifdef CONFIG_LZO\n\n    if (s->flag_compress & DUMP_DH_COMPRESSED_LZO) {\n\n        status |= DUMP_DH_COMPRESSED_LZO;\n\n    }\n\n#endif\n\n#ifdef CONFIG_SNAPPY\n\n    if (s->flag_compress & DUMP_DH_COMPRESSED_SNAPPY) {\n\n        status |= DUMP_DH_COMPRESSED_SNAPPY;\n\n    }\n\n#endif\n\n    dh->status = cpu_convert_to_target32(status, endian);\n\n\n\n    if (write_buffer(s->fd, 0, dh, size) < 0) {\n\n        dump_error(s, \"dump: failed to write disk dump header.\\n\");\n\n        ret = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* write sub header */\n\n    size = sizeof(KdumpSubHeader64);\n\n    kh = g_malloc0(size);\n\n\n\n    /* 64bit max_mapnr_64 */\n\n    kh->max_mapnr_64 = cpu_convert_to_target64(s->max_mapnr, endian);\n\n    kh->phys_base = cpu_convert_to_target64(PHYS_BASE, endian);\n\n    kh->dump_level = cpu_convert_to_target32(DUMP_LEVEL, endian);\n\n\n\n    offset_note = DISKDUMP_HEADER_BLOCKS * block_size + size;\n\n    kh->offset_note = cpu_convert_to_target64(offset_note, endian);\n\n    kh->note_size = cpu_convert_to_target64(s->note_size, endian);\n\n\n\n    if (write_buffer(s->fd, DISKDUMP_HEADER_BLOCKS *\n\n                     block_size, kh, size) < 0) {\n\n        dump_error(s, \"dump: failed to write kdump sub header.\\n\");\n\n        ret = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* write note */\n\n    s->note_buf = g_malloc0(s->note_size);\n\n    s->note_buf_offset = 0;\n\n\n\n    /* use s->note_buf to store notes temporarily */\n\n    if (write_elf64_notes(buf_write_note, s) < 0) {\n\n        ret = -1;\n\n        goto out;\n\n    }\n\n\n\n    if (write_buffer(s->fd, offset_note, s->note_buf,\n\n                     s->note_size) < 0) {\n\n        dump_error(s, \"dump: failed to write notes\");\n\n        ret = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* get offset of dump_bitmap */\n\n    s->offset_dump_bitmap = (DISKDUMP_HEADER_BLOCKS + sub_hdr_size) *\n\n                             block_size;\n\n\n\n    /* get offset of page */\n\n    s->offset_page = (DISKDUMP_HEADER_BLOCKS + sub_hdr_size + bitmap_blocks) *\n\n                     block_size;\n\n\n\nout:\n\n    g_free(dh);\n\n    g_free(kh);\n\n    g_free(s->note_buf);\n\n\n\n    return ret;\n\n}\n", "idx": 1608, "_split": "valid", "_hash": "0c3fe6c993156dcc8d33c06ac0033c83"}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "unsigned int SingleCPDO(const unsigned int opcode)\n\n{\n\n   FPA11 *fpa11 = GET_FPA11();\n\n   float32 rFm, rFn = 0;\n\n   unsigned int Fd, Fm, Fn, nRc = 1;\n\n\n\n   Fm = getFm(opcode);\n\n   if (CONSTANT_FM(opcode))\n\n   {\n\n     rFm = getSingleConstant(Fm);\n\n   }\n\n   else\n\n   {\n\n     switch (fpa11->fType[Fm])\n\n     {\n\n        case typeSingle:\n\n          rFm = fpa11->fpreg[Fm].fSingle;\n\n        break;\n\n\n\n        default: return 0;\n\n     }\n\n   }\n\n\n\n   if (!MONADIC_INSTRUCTION(opcode))\n\n   {\n\n      Fn = getFn(opcode);\n\n      switch (fpa11->fType[Fn])\n\n      {\n\n        case typeSingle:\n\n          rFn = fpa11->fpreg[Fn].fSingle;\n\n        break;\n\n\n\n        default: return 0;\n\n      }\n\n   }\n\n\n\n   Fd = getFd(opcode);\n\n   switch (opcode & MASK_ARITHMETIC_OPCODE)\n\n   {\n\n      /* dyadic opcodes */\n\n      case ADF_CODE:\n\n         fpa11->fpreg[Fd].fSingle = float32_add(rFn,rFm, &fpa11->fp_status);\n\n      break;\n\n\n\n      case MUF_CODE:\n\n      case FML_CODE:\n\n        fpa11->fpreg[Fd].fSingle = float32_mul(rFn,rFm, &fpa11->fp_status);\n\n      break;\n\n\n\n      case SUF_CODE:\n\n         fpa11->fpreg[Fd].fSingle = float32_sub(rFn,rFm, &fpa11->fp_status);\n\n      break;\n\n\n\n      case RSF_CODE:\n\n         fpa11->fpreg[Fd].fSingle = float32_sub(rFm,rFn, &fpa11->fp_status);\n\n      break;\n\n\n\n      case DVF_CODE:\n\n      case FDV_CODE:\n\n         fpa11->fpreg[Fd].fSingle = float32_div(rFn,rFm, &fpa11->fp_status);\n\n      break;\n\n\n\n      case RDF_CODE:\n\n      case FRD_CODE:\n\n         fpa11->fpreg[Fd].fSingle = float32_div(rFm,rFn, &fpa11->fp_status);\n\n      break;\n\n\n\n#if 0\n\n      case POW_CODE:\n\n         fpa11->fpreg[Fd].fSingle = float32_pow(rFn,rFm);\n\n      break;\n\n\n\n      case RPW_CODE:\n\n         fpa11->fpreg[Fd].fSingle = float32_pow(rFm,rFn);\n\n      break;\n\n#endif\n\n\n\n      case RMF_CODE:\n\n         fpa11->fpreg[Fd].fSingle = float32_rem(rFn,rFm, &fpa11->fp_status);\n\n      break;\n\n\n\n#if 0\n\n      case POL_CODE:\n\n         fpa11->fpreg[Fd].fSingle = float32_pol(rFn,rFm);\n\n      break;\n\n#endif\n\n\n\n      /* monadic opcodes */\n\n      case MVF_CODE:\n\n         fpa11->fpreg[Fd].fSingle = rFm;\n\n      break;\n\n\n\n      case MNF_CODE:\n\n         rFm ^= 0x80000000;\n\n         fpa11->fpreg[Fd].fSingle = rFm;\n\n      break;\n\n\n\n      case ABS_CODE:\n\n         rFm &= 0x7fffffff;\n\n         fpa11->fpreg[Fd].fSingle = rFm;\n\n      break;\n\n\n\n      case RND_CODE:\n\n      case URD_CODE:\n\n         fpa11->fpreg[Fd].fSingle = float32_round_to_int(rFm, &fpa11->fp_status);\n\n      break;\n\n\n\n      case SQT_CODE:\n\n         fpa11->fpreg[Fd].fSingle = float32_sqrt(rFm, &fpa11->fp_status);\n\n      break;\n\n\n\n#if 0\n\n      case LOG_CODE:\n\n         fpa11->fpreg[Fd].fSingle = float32_log(rFm);\n\n      break;\n\n\n\n      case LGN_CODE:\n\n         fpa11->fpreg[Fd].fSingle = float32_ln(rFm);\n\n      break;\n\n\n\n      case EXP_CODE:\n\n         fpa11->fpreg[Fd].fSingle = float32_exp(rFm);\n\n      break;\n\n\n\n      case SIN_CODE:\n\n         fpa11->fpreg[Fd].fSingle = float32_sin(rFm);\n\n      break;\n\n\n\n      case COS_CODE:\n\n         fpa11->fpreg[Fd].fSingle = float32_cos(rFm);\n\n      break;\n\n\n\n      case TAN_CODE:\n\n         fpa11->fpreg[Fd].fSingle = float32_tan(rFm);\n\n      break;\n\n\n\n      case ASN_CODE:\n\n         fpa11->fpreg[Fd].fSingle = float32_arcsin(rFm);\n\n      break;\n\n\n\n      case ACS_CODE:\n\n         fpa11->fpreg[Fd].fSingle = float32_arccos(rFm);\n\n      break;\n\n\n\n      case ATN_CODE:\n\n         fpa11->fpreg[Fd].fSingle = float32_arctan(rFm);\n\n      break;\n\n#endif\n\n\n\n      case NRM_CODE:\n\n      break;\n\n\n\n      default:\n\n      {\n\n        nRc = 0;\n\n      }\n\n   }\n\n\n\n   if (0 != nRc) fpa11->fType[Fd] = typeSingle;\n\n   return nRc;\n\n}\n", "idx": 1609, "_split": "valid", "_hash": "80be66da55b1fc05698277eb0dfda73f"}
{"project": "qemu", "commit_id": "341ebc2f81b14862347e4d4c1fcb3759f815237a", "target": 0, "func": "static void mirror_start_job(BlockDriverState *bs, BlockDriverState *target,\n\n                             const char *replaces,\n\n                             int64_t speed, uint32_t granularity,\n\n                             int64_t buf_size,\n\n                             BlockdevOnError on_source_error,\n\n                             BlockdevOnError on_target_error,\n\n                             BlockCompletionFunc *cb,\n\n                             void *opaque, Error **errp,\n\n                             const BlockJobDriver *driver,\n\n                             bool is_none_mode, BlockDriverState *base)\n\n{\n\n    MirrorBlockJob *s;\n\n\n\n    if (granularity == 0) {\n\n        /* Choose the default granularity based on the target file's cluster\n\n         * size, clamped between 4k and 64k.  */\n\n        BlockDriverInfo bdi;\n\n        if (bdrv_get_info(target, &bdi) >= 0 && bdi.cluster_size != 0) {\n\n            granularity = MAX(4096, bdi.cluster_size);\n\n            granularity = MIN(65536, granularity);\n\n        } else {\n\n            granularity = 65536;\n\n        }\n\n    }\n\n\n\n    assert ((granularity & (granularity - 1)) == 0);\n\n\n\n    if ((on_source_error == BLOCKDEV_ON_ERROR_STOP ||\n\n         on_source_error == BLOCKDEV_ON_ERROR_ENOSPC) &&\n\n        !bdrv_iostatus_is_enabled(bs)) {\n\n        error_set(errp, QERR_INVALID_PARAMETER, \"on-source-error\");\n\n        return;\n\n    }\n\n\n\n\n\n    s = block_job_create(driver, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->replaces = g_strdup(replaces);\n\n    s->on_source_error = on_source_error;\n\n    s->on_target_error = on_target_error;\n\n    s->target = target;\n\n    s->is_none_mode = is_none_mode;\n\n    s->base = base;\n\n    s->granularity = granularity;\n\n    s->buf_size = MAX(buf_size, granularity);\n\n\n\n    s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp);\n\n    if (!s->dirty_bitmap) {\n\n        return;\n\n    }\n\n    bdrv_set_enable_write_cache(s->target, true);\n\n    bdrv_set_on_error(s->target, on_target_error, on_target_error);\n\n    bdrv_iostatus_enable(s->target);\n\n    s->common.co = qemu_coroutine_create(mirror_run);\n\n    trace_mirror_start(bs, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}\n", "idx": 1622, "_split": "valid", "_hash": "6a90501f2d3a47f0e3957f304e11e0c9"}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "func": "static void v9fs_flush(void *opaque)\n\n{\n\n    int16_t tag;\n\n    size_t offset = 7;\n\n    V9fsPDU *cancel_pdu;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"w\", &tag);\n\n\n\n\n    QLIST_FOREACH(cancel_pdu, &s->active_list, next) {\n\n        if (cancel_pdu->tag == tag) {\n\n            break;\n\n        }\n\n    }\n\n    if (cancel_pdu) {\n\n        cancel_pdu->cancelled = 1;\n\n        /*\n\n         * Wait for pdu to complete.\n\n         */\n\n        qemu_co_queue_wait(&cancel_pdu->complete);\n\n        cancel_pdu->cancelled = 0;\n\n        free_pdu(pdu->s, cancel_pdu);\n\n    }\n\n    complete_pdu(s, pdu, 7);\n\n    return;\n\n}", "idx": 1673, "_split": "valid", "_hash": "acfd185343fe70c1b1e19c55cdb028ab"}
{"project": "qemu", "commit_id": "e8ca1db29b349e780743c504cb735c8e1d542a8c", "target": 1, "func": "void qemu_savevm_send_postcopy_advise(QEMUFile *f)\n\n{\n\n    uint64_t tmp[2];\n\n    tmp[0] = cpu_to_be64(getpagesize());\n\n    tmp[1] = cpu_to_be64(1ul << qemu_target_page_bits());\n\n\n\n    trace_qemu_savevm_send_postcopy_advise();\n\n    qemu_savevm_command_send(f, MIG_CMD_POSTCOPY_ADVISE, 16, (uint8_t *)tmp);\n\n}\n", "idx": 1675, "_split": "valid", "_hash": "a34b1205773c9b2cbe1f8db2b6be177a"}
{"project": "qemu", "commit_id": "4bac52f5c4b3dd5d0bd7568377ad7e957d5e3c6a", "target": 1, "func": "static void add_qemu_cpu_model_features(S390FeatBitmap fbm)\n\n{\n\n    static const int feats[] = {\n\n        S390_FEAT_DAT_ENH,\n\n        S390_FEAT_IDTE_SEGMENT,\n\n        S390_FEAT_STFLE,\n\n        S390_FEAT_SENSE_RUNNING_STATUS,\n\n        S390_FEAT_EXTENDED_IMMEDIATE,\n\n        S390_FEAT_EXTENDED_TRANSLATION_2,\n\n        S390_FEAT_MSA,\n\n        S390_FEAT_EXTENDED_TRANSLATION_3,\n\n        S390_FEAT_LONG_DISPLACEMENT,\n\n        S390_FEAT_LONG_DISPLACEMENT_FAST,\n\n        S390_FEAT_ETF2_ENH,\n\n        S390_FEAT_STORE_CLOCK_FAST,\n\n        S390_FEAT_MOVE_WITH_OPTIONAL_SPEC,\n\n        S390_FEAT_ETF3_ENH,\n\n\n        S390_FEAT_COMPARE_AND_SWAP_AND_STORE,\n\n        S390_FEAT_COMPARE_AND_SWAP_AND_STORE_2,\n\n        S390_FEAT_GENERAL_INSTRUCTIONS_EXT,\n\n        S390_FEAT_EXECUTE_EXT,\n\n        S390_FEAT_FLOATING_POINT_SUPPPORT_ENH,\n\n        S390_FEAT_STFLE_45,\n\n        S390_FEAT_STFLE_49,\n\n        S390_FEAT_LOCAL_TLB_CLEARING,\n\n        S390_FEAT_INTERLOCKED_ACCESS_2,\n\n        S390_FEAT_STFLE_53,\n\n        S390_FEAT_MSA_EXT_5,\n\n        S390_FEAT_MSA_EXT_3,\n\n        S390_FEAT_MSA_EXT_4,\n\n    };\n\n    int i;\n\n\n\n    for (i = 0; i < ARRAY_SIZE(feats); i++) {\n\n        set_bit(feats[i], fbm);\n\n    }\n\n}", "idx": 1677, "_split": "valid", "_hash": "c79cc8086ec29da0b801b40d5e6b221d"}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_decr (const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return cpu_ppc_load_decr(env);\n\n}\n", "idx": 1683, "_split": "valid", "_hash": "c9c79a0cfbc24765689ce72f32c8f87c"}
{"project": "qemu", "commit_id": "91479dd0b5bd3b087b92ddd7bc3f2c54982cfe17", "target": 0, "func": "START_TEST(qobject_to_qlist_test)\n\n{\n\n    QList *qlist;\n\n\n\n    qlist = qlist_new();\n\n\n\n    fail_unless(qobject_to_qlist(QOBJECT(qlist)) == qlist);\n\n\n\n    // destroy doesn't exist yet\n\n    g_free(qlist);\n\n}\n", "idx": 1688, "_split": "valid", "_hash": "88f3115c922dd354cd5bcd5065239d67"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "CharDriverState *qemu_chr_find(const char *name)\n\n{\n\n    CharDriverState *chr;\n\n\n\n    TAILQ_FOREACH(chr, &chardevs, next) {\n\n        if (strcmp(chr->label, name) != 0)\n\n            continue;\n\n        return chr;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 1701, "_split": "valid", "_hash": "59714e19fb54c98db5ca44851fa6dc53"}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "static void vm_completion(ReadLineState *rs, const char *str)\n\n{\n\n    size_t len;\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    len = strlen(str);\n\n    readline_set_completion_index(rs, len);\n\n\n\n    while ((it = bdrv_next(it, &bs))) {\n\n        SnapshotInfoList *snapshots, *snapshot;\n\n        AioContext *ctx = bdrv_get_aio_context(bs);\n\n        bool ok = false;\n\n\n\n        aio_context_acquire(ctx);\n\n        if (bdrv_can_snapshot(bs)) {\n\n            ok = bdrv_query_snapshot_info_list(bs, &snapshots, NULL) == 0;\n\n        }\n\n        aio_context_release(ctx);\n\n        if (!ok) {\n\n            continue;\n\n        }\n\n\n\n        snapshot = snapshots;\n\n        while (snapshot) {\n\n            char *completion = snapshot->value->name;\n\n            if (!strncmp(str, completion, len)) {\n\n                readline_add_completion(rs, completion);\n\n            }\n\n            completion = snapshot->value->id;\n\n            if (!strncmp(str, completion, len)) {\n\n                readline_add_completion(rs, completion);\n\n            }\n\n            snapshot = snapshot->next;\n\n        }\n\n        qapi_free_SnapshotInfoList(snapshots);\n\n    }\n\n\n\n}\n", "idx": 1750, "_split": "valid", "_hash": "a4e04402fe521e62e312603fbf43c4e6"}
{"project": "qemu", "commit_id": "229609dd45ee572fb343366a5bf440afb25cf614", "target": 1, "func": "static int check_for_evdev(void)\n\n{\n\n    SDL_SysWMinfo info;\n\n    XkbDescPtr desc;\n\n    int has_evdev = 0;\n\n    const char *keycodes;\n\n\n\n    SDL_VERSION(&info.version);\n\n    if (!SDL_GetWMInfo(&info))\n\n        return 0;\n\n\n\n    desc = XkbGetKeyboard(info.info.x11.display,\n\n                          XkbGBN_AllComponentsMask,\n\n                          XkbUseCoreKbd);\n\n    if (desc == NULL || desc->names == NULL)\n\n        return 0;\n\n\n\n    keycodes = XGetAtomName(info.info.x11.display, desc->names->keycodes);\n\n    if (keycodes == NULL)\n\n        fprintf(stderr, \"could not lookup keycode name\\n\");\n\n    else if (strstart(keycodes, \"evdev\", NULL))\n\n        has_evdev = 1;\n\n    else if (!strstart(keycodes, \"xfree86\", NULL))\n\n        fprintf(stderr,\n\n                \"unknown keycodes `%s', please report to qemu-devel@nongnu.org\\n\",\n\n                keycodes);\n\n\n\n    XkbFreeClientMap(desc, XkbGBN_AllComponentsMask, True);\n\n\n\n    return has_evdev;\n\n}\n", "idx": 1787, "_split": "valid", "_hash": "35b318ec7ccb99dee839c500e07d8a82"}
{"project": "qemu", "commit_id": "f2d089425d43735b5369f70f3a36b712440578e5", "target": 1, "func": "static MemTxResult memory_region_oldmmio_read_accessor(MemoryRegion *mr,\n\n                                                       hwaddr addr,\n\n                                                       uint64_t *value,\n\n                                                       unsigned size,\n\n                                                       unsigned shift,\n\n                                                       uint64_t mask,\n\n                                                       MemTxAttrs attrs)\n\n{\n\n    uint64_t tmp;\n\n\n\n    tmp = mr->ops->old_mmio.read[ctz32(size)](mr->opaque, addr);\n\n    if (mr->subpage) {\n\n        trace_memory_region_subpage_read(get_cpu_index(), mr, addr, tmp, size);\n\n\n\n\n\n\n    } else if (TRACE_MEMORY_REGION_OPS_READ_ENABLED) {\n\n        hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);\n\n        trace_memory_region_ops_read(get_cpu_index(), mr, abs_addr, tmp, size);\n\n    }\n\n    *value |= (tmp & mask) << shift;\n\n    return MEMTX_OK;\n\n}", "idx": 1798, "_split": "valid", "_hash": "1fd39246d8c082c65d9977c7ef64542b"}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "static uint32_t bonito_spciconf_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n    PCIBonitoState *s = opaque;\n\n    uint32_t pciaddr;\n\n    uint16_t status;\n\n\n\n    DPRINTF(\"bonito_spciconf_readb \"TARGET_FMT_plx\"  \\n\", addr);\n\n    pciaddr = bonito_sbridge_pciaddr(s, addr);\n\n\n\n    if (pciaddr == 0xffffffff) {\n\n        return 0xff;\n\n    }\n\n\n\n    /* set the pci address in s->config_reg */\n\n    s->pcihost->config_reg = (pciaddr) | (1u << 31);\n\n\n\n    /* clear PCI_STATUS_REC_MASTER_ABORT and PCI_STATUS_REC_TARGET_ABORT */\n\n    status = pci_get_word(s->dev.config + PCI_STATUS);\n\n    status &= ~(PCI_STATUS_REC_MASTER_ABORT | PCI_STATUS_REC_TARGET_ABORT);\n\n    pci_set_word(s->dev.config + PCI_STATUS, status);\n\n\n\n    return pci_data_read(s->pcihost->bus, s->pcihost->config_reg, 1);\n\n}\n", "idx": 1851, "_split": "valid", "_hash": "b714cfb9330777d45ef84c8838dde83f"}
{"project": "qemu", "commit_id": "e3cb6ba65d265f2cc1313ee26e879407ff24663c", "target": 0, "func": "static void qdev_get_legacy_property(DeviceState *dev, Visitor *v, void *opaque,\n\n                                     const char *name, Error **errp)\n\n{\n\n    Property *prop = opaque;\n\n\n\n    if (prop->info->print) {\n\n        char buffer[1024];\n\n        char *ptr = buffer;\n\n\n\n        prop->info->print(dev, prop, buffer, sizeof(buffer));\n\n        visit_type_str(v, &ptr, name, errp);\n\n    } else {\n\n        error_set(errp, QERR_PERMISSION_DENIED);\n\n    }\n\n}\n", "idx": 1856, "_split": "valid", "_hash": "9b32d450b71ccdabb9e2ab851b1234e0"}
{"project": "qemu", "commit_id": "5b003a40bb1ab14d0398e91f03393d3c6b9577cd", "target": 1, "func": "static target_ulong disas_insn(CPUX86State *env, DisasContext *s,\n\n                               target_ulong pc_start)\n\n{\n\n    int b, prefixes;\n\n    int shift;\n\n    TCGMemOp ot, aflag, dflag;\n\n    int modrm, reg, rm, mod, op, opreg, val;\n\n    target_ulong next_eip, tval;\n\n    int rex_w, rex_r;\n\n\n\n    s->pc_start = s->pc = pc_start;\n\n    prefixes = 0;\n\n    s->override = -1;\n\n    rex_w = -1;\n\n    rex_r = 0;\n\n#ifdef TARGET_X86_64\n\n    s->rex_x = 0;\n\n    s->rex_b = 0;\n\n    x86_64_hregs = 0;\n\n#endif\n\n    s->rip_offset = 0; /* for relative ip address */\n\n    s->vex_l = 0;\n\n    s->vex_v = 0;\n\n next_byte:\n\n    /* x86 has an upper limit of 15 bytes for an instruction. Since we\n\n     * do not want to decode and generate IR for an illegal\n\n     * instruction, the following check limits the instruction size to\n\n     * 25 bytes: 14 prefix + 1 opc + 6 (modrm+sib+ofs) + 4 imm */\n\n    if (s->pc - pc_start > 14) {\n\n        goto illegal_op;\n\n\n    b = cpu_ldub_code(env, s->pc);\n\n    s->pc++;\n\n    /* Collect prefixes.  */\n\n    switch (b) {\n\n    case 0xf3:\n\n        prefixes |= PREFIX_REPZ;\n\n        goto next_byte;\n\n    case 0xf2:\n\n        prefixes |= PREFIX_REPNZ;\n\n        goto next_byte;\n\n    case 0xf0:\n\n        prefixes |= PREFIX_LOCK;\n\n        goto next_byte;\n\n    case 0x2e:\n\n        s->override = R_CS;\n\n        goto next_byte;\n\n    case 0x36:\n\n        s->override = R_SS;\n\n        goto next_byte;\n\n    case 0x3e:\n\n        s->override = R_DS;\n\n        goto next_byte;\n\n    case 0x26:\n\n        s->override = R_ES;\n\n        goto next_byte;\n\n    case 0x64:\n\n        s->override = R_FS;\n\n        goto next_byte;\n\n    case 0x65:\n\n        s->override = R_GS;\n\n        goto next_byte;\n\n    case 0x66:\n\n        prefixes |= PREFIX_DATA;\n\n        goto next_byte;\n\n    case 0x67:\n\n        prefixes |= PREFIX_ADR;\n\n        goto next_byte;\n\n#ifdef TARGET_X86_64\n\n    case 0x40 ... 0x4f:\n\n        if (CODE64(s)) {\n\n            /* REX prefix */\n\n            rex_w = (b >> 3) & 1;\n\n            rex_r = (b & 0x4) << 1;\n\n            s->rex_x = (b & 0x2) << 2;\n\n            REX_B(s) = (b & 0x1) << 3;\n\n            x86_64_hregs = 1; /* select uniform byte register addressing */\n\n            goto next_byte;\n\n\n        break;\n\n#endif\n\n    case 0xc5: /* 2-byte VEX */\n\n    case 0xc4: /* 3-byte VEX */\n\n        /* VEX prefixes cannot be used except in 32-bit mode.\n\n           Otherwise the instruction is LES or LDS.  */\n\n        if (s->code32 && !s->vm86) {\n\n            static const int pp_prefix[4] = {\n\n                0, PREFIX_DATA, PREFIX_REPZ, PREFIX_REPNZ\n\n            };\n\n            int vex3, vex2 = cpu_ldub_code(env, s->pc);\n\n\n\n            if (!CODE64(s) && (vex2 & 0xc0) != 0xc0) {\n\n                /* 4.1.4.6: In 32-bit mode, bits [7:6] must be 11b,\n\n                   otherwise the instruction is LES or LDS.  */\n\n                break;\n\n\n            s->pc++;\n\n\n\n            /* 4.1.1-4.1.3: No preceding lock, 66, f2, f3, or rex prefixes. */\n\n            if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ\n\n                            | PREFIX_LOCK | PREFIX_DATA)) {\n\n                goto illegal_op;\n\n\n#ifdef TARGET_X86_64\n\n            if (x86_64_hregs) {\n\n                goto illegal_op;\n\n\n#endif\n\n            rex_r = (~vex2 >> 4) & 8;\n\n            if (b == 0xc5) {\n\n                vex3 = vex2;\n\n                b = cpu_ldub_code(env, s->pc++);\n\n            } else {\n\n#ifdef TARGET_X86_64\n\n                s->rex_x = (~vex2 >> 3) & 8;\n\n                s->rex_b = (~vex2 >> 2) & 8;\n\n#endif\n\n                vex3 = cpu_ldub_code(env, s->pc++);\n\n                rex_w = (vex3 >> 7) & 1;\n\n                switch (vex2 & 0x1f) {\n\n                case 0x01: /* Implied 0f leading opcode bytes.  */\n\n                    b = cpu_ldub_code(env, s->pc++) | 0x100;\n\n                    break;\n\n                case 0x02: /* Implied 0f 38 leading opcode bytes.  */\n\n                    b = 0x138;\n\n                    break;\n\n                case 0x03: /* Implied 0f 3a leading opcode bytes.  */\n\n                    b = 0x13a;\n\n                    break;\n\n                default:   /* Reserved for future use.  */\n\n                    goto unknown_op;\n\n\n\n            s->vex_v = (~vex3 >> 3) & 0xf;\n\n            s->vex_l = (vex3 >> 2) & 1;\n\n            prefixes |= pp_prefix[vex3 & 3] | PREFIX_VEX;\n\n\n        break;\n\n\n\n\n    /* Post-process prefixes.  */\n\n    if (CODE64(s)) {\n\n        /* In 64-bit mode, the default data size is 32-bit.  Select 64-bit\n\n           data with rex_w, and 16-bit data with 0x66; rex_w takes precedence\n\n           over 0x66 if both are present.  */\n\n        dflag = (rex_w > 0 ? MO_64 : prefixes & PREFIX_DATA ? MO_16 : MO_32);\n\n        /* In 64-bit mode, 0x67 selects 32-bit addressing.  */\n\n        aflag = (prefixes & PREFIX_ADR ? MO_32 : MO_64);\n\n    } else {\n\n        /* In 16/32-bit mode, 0x66 selects the opposite data size.  */\n\n        if (s->code32 ^ ((prefixes & PREFIX_DATA) != 0)) {\n\n            dflag = MO_32;\n\n        } else {\n\n            dflag = MO_16;\n\n\n        /* In 16/32-bit mode, 0x67 selects the opposite addressing.  */\n\n        if (s->code32 ^ ((prefixes & PREFIX_ADR) != 0)) {\n\n            aflag = MO_32;\n\n        }  else {\n\n            aflag = MO_16;\n\n\n\n\n\n    s->prefix = prefixes;\n\n    s->aflag = aflag;\n\n    s->dflag = dflag;\n\n\n\n    /* now check op code */\n\n reswitch:\n\n    switch(b) {\n\n    case 0x0f:\n\n        /**************************/\n\n        /* extended op code */\n\n        b = cpu_ldub_code(env, s->pc++) | 0x100;\n\n        goto reswitch;\n\n\n\n        /**************************/\n\n        /* arith & logic */\n\n    case 0x00 ... 0x05:\n\n    case 0x08 ... 0x0d:\n\n    case 0x10 ... 0x15:\n\n    case 0x18 ... 0x1d:\n\n    case 0x20 ... 0x25:\n\n    case 0x28 ... 0x2d:\n\n    case 0x30 ... 0x35:\n\n    case 0x38 ... 0x3d:\n\n        {\n\n            int op, f, val;\n\n            op = (b >> 3) & 7;\n\n            f = (b >> 1) & 3;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n\n\n            switch(f) {\n\n            case 0: /* OP Ev, Gv */\n\n                modrm = cpu_ldub_code(env, s->pc++);\n\n                reg = ((modrm >> 3) & 7) | rex_r;\n\n                mod = (modrm >> 6) & 3;\n\n                rm = (modrm & 7) | REX_B(s);\n\n                if (mod != 3) {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    opreg = OR_TMP0;\n\n                } else if (op == OP_XORL && rm == reg) {\n\n                xor_zero:\n\n                    /* xor reg, reg optimisation */\n\n                    set_cc_op(s, CC_OP_CLR);\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n                    gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n                    break;\n\n                } else {\n\n                    opreg = rm;\n\n\n                gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n                gen_op(s, op, ot, opreg);\n\n                break;\n\n            case 1: /* OP Gv, Ev */\n\n                modrm = cpu_ldub_code(env, s->pc++);\n\n                mod = (modrm >> 6) & 3;\n\n                reg = ((modrm >> 3) & 7) | rex_r;\n\n                rm = (modrm & 7) | REX_B(s);\n\n                if (mod != 3) {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n                } else if (op == OP_XORL && rm == reg) {\n\n                    goto xor_zero;\n\n                } else {\n\n                    gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n\n                gen_op(s, op, ot, reg);\n\n                break;\n\n            case 2: /* OP A, Iv */\n\n                val = insn_get(env, s, ot);\n\n                tcg_gen_movi_tl(cpu_T1, val);\n\n                gen_op(s, op, ot, OR_EAX);\n\n                break;\n\n\n\n        break;\n\n\n\n    case 0x82:\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n    case 0x80: /* GRP1 */\n\n    case 0x81:\n\n    case 0x83:\n\n        {\n\n            int val;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n\n\n            modrm = cpu_ldub_code(env, s->pc++);\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n            op = (modrm >> 3) & 7;\n\n\n\n            if (mod != 3) {\n\n                if (b == 0x83)\n\n                    s->rip_offset = 1;\n\n                else\n\n                    s->rip_offset = insn_const_size(ot);\n\n                gen_lea_modrm(env, s, modrm);\n\n                opreg = OR_TMP0;\n\n            } else {\n\n                opreg = rm;\n\n\n\n\n            switch(b) {\n\n            default:\n\n            case 0x80:\n\n            case 0x81:\n\n            case 0x82:\n\n                val = insn_get(env, s, ot);\n\n                break;\n\n            case 0x83:\n\n                val = (int8_t)insn_get(env, s, MO_8);\n\n                break;\n\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n            gen_op(s, op, ot, opreg);\n\n\n        break;\n\n\n\n        /**************************/\n\n        /* inc, dec, and other misc arith */\n\n    case 0x40 ... 0x47: /* inc Gv */\n\n        ot = dflag;\n\n        gen_inc(s, ot, OR_EAX + (b & 7), 1);\n\n        break;\n\n    case 0x48 ... 0x4f: /* dec Gv */\n\n        ot = dflag;\n\n        gen_inc(s, ot, OR_EAX + (b & 7), -1);\n\n        break;\n\n    case 0xf6: /* GRP3 */\n\n    case 0xf7:\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        op = (modrm >> 3) & 7;\n\n        if (mod != 3) {\n\n            if (op == 0) {\n\n                s->rip_offset = insn_const_size(ot);\n\n\n            gen_lea_modrm(env, s, modrm);\n\n            /* For those below that handle locked memory, don't load here.  */\n\n            if (!(s->prefix & PREFIX_LOCK)\n\n                || op != 2) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n\n\n\n        switch(op) {\n\n        case 0: /* test */\n\n            val = insn_get(env, s, ot);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n            gen_op_testl_T0_T1_cc();\n\n            set_cc_op(s, CC_OP_LOGICB + ot);\n\n            break;\n\n        case 2: /* not */\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n\n                tcg_gen_movi_tl(cpu_T0, ~0);\n\n                tcg_gen_atomic_xor_fetch_tl(cpu_T0, cpu_A0, cpu_T0,\n\n                                            s->mem_index, ot | MO_LE);\n\n            } else {\n\n                tcg_gen_not_tl(cpu_T0, cpu_T0);\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n\n\n            break;\n\n        case 3: /* neg */\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                TCGLabel *label1;\n\n                TCGv a0, t0, t1, t2;\n\n\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n\n                a0 = tcg_temp_local_new();\n\n                t0 = tcg_temp_local_new();\n\n                label1 = gen_new_label();\n\n\n\n                tcg_gen_mov_tl(a0, cpu_A0);\n\n                tcg_gen_mov_tl(t0, cpu_T0);\n\n\n\n                gen_set_label(label1);\n\n                t1 = tcg_temp_new();\n\n                t2 = tcg_temp_new();\n\n                tcg_gen_mov_tl(t2, t0);\n\n                tcg_gen_neg_tl(t1, t0);\n\n                tcg_gen_atomic_cmpxchg_tl(t0, a0, t0, t1,\n\n                                          s->mem_index, ot | MO_LE);\n\n                tcg_temp_free(t1);\n\n                tcg_gen_brcond_tl(TCG_COND_NE, t0, t2, label1);\n\n\n\n                tcg_temp_free(t2);\n\n                tcg_temp_free(a0);\n\n                tcg_gen_mov_tl(cpu_T0, t0);\n\n                tcg_temp_free(t0);\n\n            } else {\n\n                tcg_gen_neg_tl(cpu_T0, cpu_T0);\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n\n\n            gen_op_update_neg_cc();\n\n            set_cc_op(s, CC_OP_SUBB + ot);\n\n            break;\n\n        case 4: /* mul */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);\n\n                tcg_gen_ext8u_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext8u_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_andi_tl(cpu_cc_src, cpu_T0, 0xff00);\n\n                set_cc_op(s, CC_OP_MULB);\n\n                break;\n\n            case MO_16:\n\n                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext16u_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);\n\n                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n                set_cc_op(s, CC_OP_MULW);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);\n\n                tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                                  cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULL);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                tcg_gen_mulu2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],\n\n                                  cpu_T0, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULQ);\n\n                break;\n\n#endif\n\n\n            break;\n\n        case 5: /* imul */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);\n\n                tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext8s_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_ext8s_tl(cpu_tmp0, cpu_T0);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n                set_cc_op(s, CC_OP_MULB);\n\n                break;\n\n            case MO_16:\n\n                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);\n\n                tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext16s_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);\n\n                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n                set_cc_op(s, CC_OP_MULW);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);\n\n                tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                                  cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);\n\n                tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);\n\n                set_cc_op(s, CC_OP_MULL);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                tcg_gen_muls2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],\n\n                                  cpu_T0, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_sari_tl(cpu_cc_src, cpu_regs[R_EAX], 63);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULQ);\n\n                break;\n\n#endif\n\n\n            break;\n\n        case 6: /* div */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_helper_divb_AL(cpu_env, cpu_T0);\n\n                break;\n\n            case MO_16:\n\n                gen_helper_divw_AX(cpu_env, cpu_T0);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                gen_helper_divl_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                gen_helper_divq_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#endif\n\n\n            break;\n\n        case 7: /* idiv */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_helper_idivb_AL(cpu_env, cpu_T0);\n\n                break;\n\n            case MO_16:\n\n                gen_helper_idivw_AX(cpu_env, cpu_T0);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                gen_helper_idivl_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                gen_helper_idivq_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#endif\n\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n\n        break;\n\n\n\n    case 0xfe: /* GRP4 */\n\n    case 0xff: /* GRP5 */\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        op = (modrm >> 3) & 7;\n\n        if (op >= 2 && b == 0xfe) {\n\n            goto unknown_op;\n\n\n        if (CODE64(s)) {\n\n            if (op == 2 || op == 4) {\n\n                /* operand size for jumps is 64 bit */\n\n                ot = MO_64;\n\n            } else if (op == 3 || op == 5) {\n\n                ot = dflag != MO_16 ? MO_32 + (rex_w == 1) : MO_16;\n\n            } else if (op == 6) {\n\n                /* default push size is 64 bit */\n\n                ot = mo_pushpop(s, dflag);\n\n\n\n        if (mod != 3) {\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (op >= 2 && op != 3 && op != 5)\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n\n\n\n        switch(op) {\n\n        case 0: /* inc Ev */\n\n            if (mod != 3)\n\n                opreg = OR_TMP0;\n\n            else\n\n                opreg = rm;\n\n            gen_inc(s, ot, opreg, 1);\n\n            break;\n\n        case 1: /* dec Ev */\n\n            if (mod != 3)\n\n                opreg = OR_TMP0;\n\n            else\n\n                opreg = rm;\n\n            gen_inc(s, ot, opreg, -1);\n\n            break;\n\n        case 2: /* call Ev */\n\n            /* XXX: optimize if memory (no 'and' is necessary) */\n\n            if (dflag == MO_16) {\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n\n            next_eip = s->pc - s->cs_base;\n\n            tcg_gen_movi_tl(cpu_T1, next_eip);\n\n            gen_push_v(s, cpu_T1);\n\n            gen_op_jmp_v(cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jr(s, cpu_T0);\n\n            break;\n\n        case 3: /* lcall Ev */\n\n            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 1 << ot);\n\n            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        do_lcall:\n\n            if (s->pe && !s->vm86) {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lcall_protected(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                           tcg_const_i32(dflag - 1),\n\n                                           tcg_const_tl(s->pc - s->cs_base));\n\n            } else {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lcall_real(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                      tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(s->pc - s->cs_base));\n\n\n            tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip));\n\n            gen_jr(s, cpu_tmp4);\n\n            break;\n\n        case 4: /* jmp Ev */\n\n            if (dflag == MO_16) {\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n\n            gen_op_jmp_v(cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jr(s, cpu_T0);\n\n            break;\n\n        case 5: /* ljmp Ev */\n\n            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 1 << ot);\n\n            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        do_ljmp:\n\n            if (s->pe && !s->vm86) {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_ljmp_protected(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                          tcg_const_tl(s->pc - s->cs_base));\n\n            } else {\n\n                gen_op_movl_seg_T0_vm(R_CS);\n\n                gen_op_jmp_v(cpu_T1);\n\n\n            tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip));\n\n            gen_jr(s, cpu_tmp4);\n\n            break;\n\n        case 6: /* push Ev */\n\n            gen_push_v(s, cpu_T0);\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n\n        break;\n\n\n\n    case 0x84: /* test Ev, Gv */\n\n    case 0x85:\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n        gen_op_testl_T0_T1_cc();\n\n        set_cc_op(s, CC_OP_LOGICB + ot);\n\n        break;\n\n\n\n    case 0xa8: /* test eAX, Iv */\n\n    case 0xa9:\n\n        ot = mo_b_d(b, dflag);\n\n        val = insn_get(env, s, ot);\n\n\n\n        gen_op_mov_v_reg(ot, cpu_T0, OR_EAX);\n\n        tcg_gen_movi_tl(cpu_T1, val);\n\n        gen_op_testl_T0_T1_cc();\n\n        set_cc_op(s, CC_OP_LOGICB + ot);\n\n        break;\n\n\n\n    case 0x98: /* CWDE/CBW */\n\n        switch (dflag) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);\n\n            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_64, R_EAX, cpu_T0);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_32, R_EAX, cpu_T0);\n\n            break;\n\n        case MO_16:\n\n            gen_op_mov_v_reg(MO_8, cpu_T0, R_EAX);\n\n            tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n            break;\n\n        default:\n\n            tcg_abort();\n\n\n        break;\n\n    case 0x99: /* CDQ/CWD */\n\n        switch (dflag) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            gen_op_mov_v_reg(MO_64, cpu_T0, R_EAX);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 63);\n\n            gen_op_mov_reg_v(MO_64, R_EDX, cpu_T0);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);\n\n            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 31);\n\n            gen_op_mov_reg_v(MO_32, R_EDX, cpu_T0);\n\n            break;\n\n        case MO_16:\n\n            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 15);\n\n            gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n            break;\n\n        default:\n\n            tcg_abort();\n\n\n        break;\n\n    case 0x1af: /* imul Gv, Ev */\n\n    case 0x69: /* imul Gv, Ev, I */\n\n    case 0x6b:\n\n        ot = dflag;\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        if (b == 0x69)\n\n            s->rip_offset = insn_const_size(ot);\n\n        else if (b == 0x6b)\n\n            s->rip_offset = 1;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        if (b == 0x69) {\n\n            val = insn_get(env, s, ot);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n        } else if (b == 0x6b) {\n\n            val = (int8_t)insn_get(env, s, MO_8);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n\n        switch (ot) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            tcg_gen_muls2_i64(cpu_regs[reg], cpu_T1, cpu_T0, cpu_T1);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);\n\n            tcg_gen_sari_tl(cpu_cc_src, cpu_cc_dst, 63);\n\n            tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_T1);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n            tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                              cpu_tmp2_i32, cpu_tmp3_i32);\n\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n\n            tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);\n\n            tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n\n            tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);\n\n            break;\n\n        default:\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_ext16s_tl(cpu_T1, cpu_T1);\n\n            /* XXX: use 32 bit mul which could be faster */\n\n            tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n            tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);\n\n            tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n            break;\n\n\n        set_cc_op(s, CC_OP_MULB + ot);\n\n        break;\n\n    case 0x1c0:\n\n    case 0x1c1: /* xadd Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n        if (mod == 3) {\n\n            rm = (modrm & 7) | REX_B(s);\n\n            gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n            tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n        } else {\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                tcg_gen_atomic_fetch_add_tl(cpu_T1, cpu_A0, cpu_T0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            } else {\n\n                gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n\n        gen_op_update2_cc();\n\n        set_cc_op(s, CC_OP_ADDB + ot);\n\n        break;\n\n    case 0x1b0:\n\n    case 0x1b1: /* cmpxchg Ev, Gv */\n\n        {\n\n            TCGv oldv, newv, cmpv;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n            modrm = cpu_ldub_code(env, s->pc++);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            oldv = tcg_temp_new();\n\n            newv = tcg_temp_new();\n\n            cmpv = tcg_temp_new();\n\n            gen_op_mov_v_reg(ot, newv, reg);\n\n            tcg_gen_mov_tl(cmpv, cpu_regs[R_EAX]);\n\n\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n\n                gen_lea_modrm(env, s, modrm);\n\n                tcg_gen_atomic_cmpxchg_tl(oldv, cpu_A0, cmpv, newv,\n\n                                          s->mem_index, ot | MO_LE);\n\n                gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n            } else {\n\n                if (mod == 3) {\n\n                    rm = (modrm & 7) | REX_B(s);\n\n                    gen_op_mov_v_reg(ot, oldv, rm);\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    gen_op_ld_v(s, ot, oldv, cpu_A0);\n\n                    rm = 0; /* avoid warning */\n\n\n                gen_extu(ot, oldv);\n\n                gen_extu(ot, cmpv);\n\n                /* store value = (old == cmp ? new : old);  */\n\n                tcg_gen_movcond_tl(TCG_COND_EQ, newv, oldv, cmpv, newv, oldv);\n\n                if (mod == 3) {\n\n                    gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n                    gen_op_mov_reg_v(ot, rm, newv);\n\n                } else {\n\n                    /* Perform an unconditional store cycle like physical cpu;\n\n                       must be before changing accumulator to ensure\n\n                       idempotency if the store faults and the instruction\n\n                       is restarted */\n\n                    gen_op_st_v(s, ot, newv, cpu_A0);\n\n                    gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n\n\n            tcg_gen_mov_tl(cpu_cc_src, oldv);\n\n            tcg_gen_mov_tl(cpu_cc_srcT, cmpv);\n\n            tcg_gen_sub_tl(cpu_cc_dst, cmpv, oldv);\n\n            set_cc_op(s, CC_OP_SUBB + ot);\n\n            tcg_temp_free(oldv);\n\n            tcg_temp_free(newv);\n\n            tcg_temp_free(cmpv);\n\n\n        break;\n\n    case 0x1c7: /* cmpxchg8b */\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        if ((mod == 3) || ((modrm & 0x38) != 0x8))\n\n            goto illegal_op;\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_CX16))\n\n                goto illegal_op;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {\n\n                gen_helper_cmpxchg16b(cpu_env, cpu_A0);\n\n            } else {\n\n                gen_helper_cmpxchg16b_unlocked(cpu_env, cpu_A0);\n\n\n        } else\n\n#endif        \n\n        {\n\n            if (!(s->cpuid_features & CPUID_CX8))\n\n                goto illegal_op;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {\n\n                gen_helper_cmpxchg8b(cpu_env, cpu_A0);\n\n            } else {\n\n                gen_helper_cmpxchg8b_unlocked(cpu_env, cpu_A0);\n\n\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n\n\n        /**************************/\n\n        /* push/pop */\n\n    case 0x50 ... 0x57: /* push */\n\n        gen_op_mov_v_reg(MO_32, cpu_T0, (b & 7) | REX_B(s));\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x58 ... 0x5f: /* pop */\n\n        ot = gen_pop_T0(s);\n\n        /* NOTE: order is important for pop %sp */\n\n        gen_pop_update(s, ot);\n\n        gen_op_mov_reg_v(ot, (b & 7) | REX_B(s), cpu_T0);\n\n        break;\n\n    case 0x60: /* pusha */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_pusha(s);\n\n        break;\n\n    case 0x61: /* popa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_popa(s);\n\n        break;\n\n    case 0x68: /* push Iv */\n\n    case 0x6a:\n\n        ot = mo_pushpop(s, dflag);\n\n        if (b == 0x68)\n\n            val = insn_get(env, s, ot);\n\n        else\n\n            val = (int8_t)insn_get(env, s, MO_8);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x8f: /* pop Ev */\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        ot = gen_pop_T0(s);\n\n        if (mod == 3) {\n\n            /* NOTE: order is important for pop %sp */\n\n            gen_pop_update(s, ot);\n\n            rm = (modrm & 7) | REX_B(s);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n        } else {\n\n            /* NOTE: order is important too for MMU exceptions */\n\n            s->popl_esp_hack = 1 << ot;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            s->popl_esp_hack = 0;\n\n            gen_pop_update(s, ot);\n\n\n        break;\n\n    case 0xc8: /* enter */\n\n        {\n\n            int level;\n\n            val = cpu_lduw_code(env, s->pc);\n\n            s->pc += 2;\n\n            level = cpu_ldub_code(env, s->pc++);\n\n            gen_enter(s, val, level);\n\n\n        break;\n\n    case 0xc9: /* leave */\n\n        gen_leave(s);\n\n        break;\n\n    case 0x06: /* push es */\n\n    case 0x0e: /* push cs */\n\n    case 0x16: /* push ss */\n\n    case 0x1e: /* push ds */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_op_movl_T0_seg(b >> 3);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x1a0: /* push fs */\n\n    case 0x1a8: /* push gs */\n\n        gen_op_movl_T0_seg((b >> 3) & 7);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x07: /* pop es */\n\n    case 0x17: /* pop ss */\n\n    case 0x1f: /* pop ds */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        reg = b >> 3;\n\n        ot = gen_pop_T0(s);\n\n        gen_movl_seg_T0(s, reg);\n\n        gen_pop_update(s, ot);\n\n        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */\n\n        if (s->is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            if (reg == R_SS) {\n\n                s->tf = 0;\n\n                gen_eob_inhibit_irq(s, true);\n\n            } else {\n\n                gen_eob(s);\n\n\n\n        break;\n\n    case 0x1a1: /* pop fs */\n\n    case 0x1a9: /* pop gs */\n\n        ot = gen_pop_T0(s);\n\n        gen_movl_seg_T0(s, (b >> 3) & 7);\n\n        gen_pop_update(s, ot);\n\n        if (s->is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n\n        break;\n\n\n\n        /**************************/\n\n        /* mov */\n\n    case 0x88:\n\n    case 0x89: /* mov Gv, Ev */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        /* generate a generic store */\n\n        gen_ldst_modrm(env, s, modrm, ot, reg, 1);\n\n        break;\n\n    case 0xc6:\n\n    case 0xc7: /* mov Ev, Iv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod != 3) {\n\n            s->rip_offset = insn_const_size(ot);\n\n            gen_lea_modrm(env, s, modrm);\n\n\n        val = insn_get(env, s, ot);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        if (mod != 3) {\n\n            gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n        } else {\n\n            gen_op_mov_reg_v(ot, (modrm & 7) | REX_B(s), cpu_T0);\n\n\n        break;\n\n    case 0x8a:\n\n    case 0x8b: /* mov Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        break;\n\n    case 0x8e: /* mov seg, Gv */\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        reg = (modrm >> 3) & 7;\n\n        if (reg >= 6 || reg == R_CS)\n\n            goto illegal_op;\n\n        gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n        gen_movl_seg_T0(s, reg);\n\n        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */\n\n        if (s->is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            if (reg == R_SS) {\n\n                s->tf = 0;\n\n                gen_eob_inhibit_irq(s, true);\n\n            } else {\n\n                gen_eob(s);\n\n\n\n        break;\n\n    case 0x8c: /* mov Gv, seg */\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        reg = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        if (reg >= 6)\n\n            goto illegal_op;\n\n        gen_op_movl_T0_seg(reg);\n\n        ot = mod == 3 ? dflag : MO_16;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n        break;\n\n\n\n    case 0x1b6: /* movzbS Gv, Eb */\n\n    case 0x1b7: /* movzwS Gv, Eb */\n\n    case 0x1be: /* movsbS Gv, Eb */\n\n    case 0x1bf: /* movswS Gv, Eb */\n\n        {\n\n            TCGMemOp d_ot;\n\n            TCGMemOp s_ot;\n\n\n\n            /* d_ot is the size of destination */\n\n            d_ot = dflag;\n\n            /* ot is the size of source */\n\n            ot = (b & 1) + MO_8;\n\n            /* s_ot is the sign+size of source */\n\n            s_ot = b & 8 ? MO_SIGN | ot : ot;\n\n\n\n            modrm = cpu_ldub_code(env, s->pc++);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n\n\n            if (mod == 3) {\n\n                if (s_ot == MO_SB && byte_reg_is_xH(rm)) {\n\n                    tcg_gen_sextract_tl(cpu_T0, cpu_regs[rm - 4], 8, 8);\n\n                } else {\n\n                    gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                    switch (s_ot) {\n\n                    case MO_UB:\n\n                        tcg_gen_ext8u_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    case MO_SB:\n\n                        tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    case MO_UW:\n\n                        tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    default:\n\n                    case MO_SW:\n\n                        tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            } else {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, s_ot, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n\n\n        break;\n\n\n\n    case 0x8d: /* lea */\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        {\n\n            AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n            TCGv ea = gen_lea_modrm_1(a);\n\n            gen_lea_v_seg(s, s->aflag, ea, -1, -1);\n\n            gen_op_mov_reg_v(dflag, reg, cpu_A0);\n\n\n        break;\n\n\n\n    case 0xa0: /* mov EAX, Ov */\n\n    case 0xa1:\n\n    case 0xa2: /* mov Ov, EAX */\n\n    case 0xa3:\n\n        {\n\n            target_ulong offset_addr;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n            switch (s->aflag) {\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                offset_addr = cpu_ldq_code(env, s->pc);\n\n                s->pc += 8;\n\n                break;\n\n#endif\n\n            default:\n\n                offset_addr = insn_get(env, s, s->aflag);\n\n                break;\n\n\n            tcg_gen_movi_tl(cpu_A0, offset_addr);\n\n            gen_add_A0_ds_seg(s);\n\n            if ((b & 2) == 0) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(ot, R_EAX, cpu_T0);\n\n            } else {\n\n                gen_op_mov_v_reg(ot, cpu_T0, R_EAX);\n\n                gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n\n\n        break;\n\n    case 0xd7: /* xlat */\n\n        tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EBX]);\n\n        tcg_gen_ext8u_tl(cpu_T0, cpu_regs[R_EAX]);\n\n        tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T0);\n\n        gen_extu(s->aflag, cpu_A0);\n\n        gen_add_A0_ds_seg(s);\n\n        gen_op_ld_v(s, MO_8, cpu_T0, cpu_A0);\n\n        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);\n\n        break;\n\n    case 0xb0 ... 0xb7: /* mov R, Ib */\n\n        val = insn_get(env, s, MO_8);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_op_mov_reg_v(MO_8, (b & 7) | REX_B(s), cpu_T0);\n\n        break;\n\n    case 0xb8 ... 0xbf: /* mov R, Iv */\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            uint64_t tmp;\n\n            /* 64 bit case */\n\n            tmp = cpu_ldq_code(env, s->pc);\n\n            s->pc += 8;\n\n            reg = (b & 7) | REX_B(s);\n\n            tcg_gen_movi_tl(cpu_T0, tmp);\n\n            gen_op_mov_reg_v(MO_64, reg, cpu_T0);\n\n        } else\n\n#endif\n\n        {\n\n            ot = dflag;\n\n            val = insn_get(env, s, ot);\n\n            reg = (b & 7) | REX_B(s);\n\n            tcg_gen_movi_tl(cpu_T0, val);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n\n        break;\n\n\n\n    case 0x91 ... 0x97: /* xchg R, EAX */\n\n    do_xchg_reg_eax:\n\n        ot = dflag;\n\n        reg = (b & 7) | REX_B(s);\n\n        rm = R_EAX;\n\n        goto do_xchg_reg;\n\n    case 0x86:\n\n    case 0x87: /* xchg Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3) {\n\n            rm = (modrm & 7) | REX_B(s);\n\n        do_xchg_reg:\n\n            gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n            gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        } else {\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n            /* for xchg, lock is implicit */\n\n            tcg_gen_atomic_xchg_tl(cpu_T1, cpu_A0, cpu_T0,\n\n                                   s->mem_index, ot | MO_LE);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n\n        break;\n\n    case 0xc4: /* les Gv */\n\n        /* In CODE64 this is VEX3; see above.  */\n\n        op = R_ES;\n\n        goto do_lxx;\n\n    case 0xc5: /* lds Gv */\n\n        /* In CODE64 this is VEX2; see above.  */\n\n        op = R_DS;\n\n        goto do_lxx;\n\n    case 0x1b2: /* lss Gv */\n\n        op = R_SS;\n\n        goto do_lxx;\n\n    case 0x1b4: /* lfs Gv */\n\n        op = R_FS;\n\n        goto do_lxx;\n\n    case 0x1b5: /* lgs Gv */\n\n        op = R_GS;\n\n    do_lxx:\n\n        ot = dflag != MO_16 ? MO_32 : MO_16;\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_lea_modrm(env, s, modrm);\n\n        gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n        gen_add_A0_im(s, 1 << ot);\n\n        /* load the segment first to handle exceptions properly */\n\n        gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        gen_movl_seg_T0(s, op);\n\n        /* then put the data */\n\n        gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        if (s->is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n\n        break;\n\n\n\n        /************************/\n\n        /* shifts */\n\n    case 0xc0:\n\n    case 0xc1:\n\n        /* shift Ev,Ib */\n\n        shift = 2;\n\n    grp2:\n\n        {\n\n            ot = mo_b_d(b, dflag);\n\n            modrm = cpu_ldub_code(env, s->pc++);\n\n            mod = (modrm >> 6) & 3;\n\n            op = (modrm >> 3) & 7;\n\n\n\n            if (mod != 3) {\n\n                if (shift == 2) {\n\n                    s->rip_offset = 1;\n\n\n                gen_lea_modrm(env, s, modrm);\n\n                opreg = OR_TMP0;\n\n            } else {\n\n                opreg = (modrm & 7) | REX_B(s);\n\n\n\n\n            /* simpler op */\n\n            if (shift == 0) {\n\n                gen_shift(s, op, ot, opreg, OR_ECX);\n\n            } else {\n\n                if (shift == 2) {\n\n                    shift = cpu_ldub_code(env, s->pc++);\n\n\n                gen_shifti(s, op, ot, opreg, shift);\n\n\n\n        break;\n\n    case 0xd0:\n\n    case 0xd1:\n\n        /* shift Ev,1 */\n\n        shift = 1;\n\n        goto grp2;\n\n    case 0xd2:\n\n    case 0xd3:\n\n        /* shift Ev,cl */\n\n        shift = 0;\n\n        goto grp2;\n\n\n\n    case 0x1a4: /* shld imm */\n\n        op = 0;\n\n        shift = 1;\n\n        goto do_shiftd;\n\n    case 0x1a5: /* shld cl */\n\n        op = 0;\n\n        shift = 0;\n\n        goto do_shiftd;\n\n    case 0x1ac: /* shrd imm */\n\n        op = 1;\n\n        shift = 1;\n\n        goto do_shiftd;\n\n    case 0x1ad: /* shrd cl */\n\n        op = 1;\n\n        shift = 0;\n\n    do_shiftd:\n\n        ot = dflag;\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        if (mod != 3) {\n\n            gen_lea_modrm(env, s, modrm);\n\n            opreg = OR_TMP0;\n\n        } else {\n\n            opreg = rm;\n\n\n        gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n\n\n        if (shift) {\n\n            TCGv imm = tcg_const_tl(cpu_ldub_code(env, s->pc++));\n\n            gen_shiftd_rm_T1(s, ot, opreg, op, imm);\n\n            tcg_temp_free(imm);\n\n        } else {\n\n            gen_shiftd_rm_T1(s, ot, opreg, op, cpu_regs[R_ECX]);\n\n\n        break;\n\n\n\n        /************************/\n\n        /* floats */\n\n    case 0xd8 ... 0xdf:\n\n        if (s->flags & (HF_EM_MASK | HF_TS_MASK)) {\n\n            /* if CR0.EM or CR0.TS are set, generate an FPU exception */\n\n            /* XXX: what to do if illegal op ? */\n\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n            break;\n\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = modrm & 7;\n\n        op = ((b & 7) << 3) | ((modrm >> 3) & 7);\n\n        if (mod != 3) {\n\n            /* memory op */\n\n            gen_lea_modrm(env, s, modrm);\n\n            switch(op) {\n\n            case 0x00 ... 0x07: /* fxxxs */\n\n            case 0x10 ... 0x17: /* fixxxl */\n\n            case 0x20 ... 0x27: /* fxxxl */\n\n            case 0x30 ... 0x37: /* fixxx */\n\n                {\n\n                    int op1;\n\n                    op1 = op & 7;\n\n\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_flds_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 1:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 2:\n\n                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        gen_helper_fldl_FT0(cpu_env, cpu_tmp1_i64);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LESW);\n\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n\n\n\n                    gen_helper_fp_arith_ST0_FT0(op1);\n\n                    if (op1 == 3) {\n\n                        /* fcomp needs pop */\n\n                        gen_helper_fpop(cpu_env);\n\n\n\n                break;\n\n            case 0x08: /* flds */\n\n            case 0x0a: /* fsts */\n\n            case 0x0b: /* fstps */\n\n            case 0x18 ... 0x1b: /* fildl, fisttpl, fistl, fistpl */\n\n            case 0x28 ... 0x2b: /* fldl, fisttpll, fstl, fstpl */\n\n            case 0x38 ... 0x3b: /* filds, fisttps, fists, fistps */\n\n                switch(op & 7) {\n\n                case 0:\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_flds_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 1:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 2:\n\n                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        gen_helper_fldl_ST0(cpu_env, cpu_tmp1_i64);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LESW);\n\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n\n                    break;\n\n                case 1:\n\n                    /* XXX: the corresponding CPUID bit must be tested ! */\n\n                    switch(op >> 4) {\n\n                    case 1:\n\n                        gen_helper_fisttl_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fisttll_ST0(cpu_tmp1_i64, cpu_env);\n\n                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_helper_fistt_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUW);\n\n                        break;\n\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        gen_helper_fsts_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 1:\n\n                        gen_helper_fistl_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fstl_ST0(cpu_tmp1_i64, cpu_env);\n\n                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_helper_fist_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUW);\n\n                        break;\n\n\n                    if ((op & 7) == 3)\n\n                        gen_helper_fpop(cpu_env);\n\n                    break;\n\n\n                break;\n\n            case 0x0c: /* fldenv mem */\n\n                gen_helper_fldenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x0d: /* fldcw mem */\n\n                tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                gen_helper_fldcw(cpu_env, cpu_tmp2_i32);\n\n                break;\n\n            case 0x0e: /* fnstenv mem */\n\n                gen_helper_fstenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x0f: /* fnstcw mem */\n\n                gen_helper_fnstcw(cpu_tmp2_i32, cpu_env);\n\n                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                break;\n\n            case 0x1d: /* fldt mem */\n\n                gen_helper_fldt_ST0(cpu_env, cpu_A0);\n\n                break;\n\n            case 0x1f: /* fstpt mem */\n\n                gen_helper_fstt_ST0(cpu_env, cpu_A0);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x2c: /* frstor mem */\n\n                gen_helper_frstor(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x2e: /* fnsave mem */\n\n                gen_helper_fsave(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x2f: /* fnstsw mem */\n\n                gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n\n                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                break;\n\n            case 0x3c: /* fbld */\n\n                gen_helper_fbld_ST0(cpu_env, cpu_A0);\n\n                break;\n\n            case 0x3e: /* fbstp */\n\n                gen_helper_fbst_ST0(cpu_env, cpu_A0);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x3d: /* fildll */\n\n                tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);\n\n                gen_helper_fildll_ST0(cpu_env, cpu_tmp1_i64);\n\n                break;\n\n            case 0x3f: /* fistpll */\n\n                gen_helper_fistll_ST0(cpu_tmp1_i64, cpu_env);\n\n                tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n\n        } else {\n\n            /* register float ops */\n\n            opreg = rm;\n\n\n\n            switch(op) {\n\n            case 0x08: /* fld sti */\n\n                gen_helper_fpush(cpu_env);\n\n                gen_helper_fmov_ST0_STN(cpu_env,\n\n                                        tcg_const_i32((opreg + 1) & 7));\n\n                break;\n\n            case 0x09: /* fxchg sti */\n\n            case 0x29: /* fxchg4 sti, undocumented op */\n\n            case 0x39: /* fxchg7 sti, undocumented op */\n\n                gen_helper_fxchg_ST0_STN(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x0a: /* grp d9/2 */\n\n                switch(rm) {\n\n                case 0: /* fnop */\n\n                    /* check exceptions (FreeBSD FPU probe) */\n\n                    gen_helper_fwait(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n\n                break;\n\n            case 0x0c: /* grp d9/4 */\n\n                switch(rm) {\n\n                case 0: /* fchs */\n\n                    gen_helper_fchs_ST0(cpu_env);\n\n                    break;\n\n                case 1: /* fabs */\n\n                    gen_helper_fabs_ST0(cpu_env);\n\n                    break;\n\n                case 4: /* ftst */\n\n                    gen_helper_fldz_FT0(cpu_env);\n\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n\n                    break;\n\n                case 5: /* fxam */\n\n                    gen_helper_fxam_ST0(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n\n                break;\n\n            case 0x0d: /* grp d9/5 */\n\n                {\n\n                    switch(rm) {\n\n                    case 0:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fld1_ST0(cpu_env);\n\n                        break;\n\n                    case 1:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldl2t_ST0(cpu_env);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldl2e_ST0(cpu_env);\n\n                        break;\n\n                    case 3:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldpi_ST0(cpu_env);\n\n                        break;\n\n                    case 4:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldlg2_ST0(cpu_env);\n\n                        break;\n\n                    case 5:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldln2_ST0(cpu_env);\n\n                        break;\n\n                    case 6:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldz_ST0(cpu_env);\n\n                        break;\n\n                    default:\n\n                        goto unknown_op;\n\n\n\n                break;\n\n            case 0x0e: /* grp d9/6 */\n\n                switch(rm) {\n\n                case 0: /* f2xm1 */\n\n                    gen_helper_f2xm1(cpu_env);\n\n                    break;\n\n                case 1: /* fyl2x */\n\n                    gen_helper_fyl2x(cpu_env);\n\n                    break;\n\n                case 2: /* fptan */\n\n                    gen_helper_fptan(cpu_env);\n\n                    break;\n\n                case 3: /* fpatan */\n\n                    gen_helper_fpatan(cpu_env);\n\n                    break;\n\n                case 4: /* fxtract */\n\n                    gen_helper_fxtract(cpu_env);\n\n                    break;\n\n                case 5: /* fprem1 */\n\n                    gen_helper_fprem1(cpu_env);\n\n                    break;\n\n                case 6: /* fdecstp */\n\n                    gen_helper_fdecstp(cpu_env);\n\n                    break;\n\n                default:\n\n                case 7: /* fincstp */\n\n                    gen_helper_fincstp(cpu_env);\n\n                    break;\n\n\n                break;\n\n            case 0x0f: /* grp d9/7 */\n\n                switch(rm) {\n\n                case 0: /* fprem */\n\n                    gen_helper_fprem(cpu_env);\n\n                    break;\n\n                case 1: /* fyl2xp1 */\n\n                    gen_helper_fyl2xp1(cpu_env);\n\n                    break;\n\n                case 2: /* fsqrt */\n\n                    gen_helper_fsqrt(cpu_env);\n\n                    break;\n\n                case 3: /* fsincos */\n\n                    gen_helper_fsincos(cpu_env);\n\n                    break;\n\n                case 5: /* fscale */\n\n                    gen_helper_fscale(cpu_env);\n\n                    break;\n\n                case 4: /* frndint */\n\n                    gen_helper_frndint(cpu_env);\n\n                    break;\n\n                case 6: /* fsin */\n\n                    gen_helper_fsin(cpu_env);\n\n                    break;\n\n                default:\n\n                case 7: /* fcos */\n\n                    gen_helper_fcos(cpu_env);\n\n                    break;\n\n\n                break;\n\n            case 0x00: case 0x01: case 0x04 ... 0x07: /* fxxx st, sti */\n\n            case 0x20: case 0x21: case 0x24 ... 0x27: /* fxxx sti, st */\n\n            case 0x30: case 0x31: case 0x34 ... 0x37: /* fxxxp sti, st */\n\n                {\n\n                    int op1;\n\n\n\n                    op1 = op & 7;\n\n                    if (op >= 0x20) {\n\n                        gen_helper_fp_arith_STN_ST0(op1, opreg);\n\n                        if (op >= 0x30)\n\n                            gen_helper_fpop(cpu_env);\n\n                    } else {\n\n                        gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                        gen_helper_fp_arith_ST0_FT0(op1);\n\n\n\n                break;\n\n            case 0x02: /* fcom */\n\n            case 0x22: /* fcom2, undocumented op */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcom_ST0_FT0(cpu_env);\n\n                break;\n\n            case 0x03: /* fcomp */\n\n            case 0x23: /* fcomp3, undocumented op */\n\n            case 0x32: /* fcomp5, undocumented op */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcom_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x15: /* da/5 */\n\n                switch(rm) {\n\n                case 1: /* fucompp */\n\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n\n                    gen_helper_fucom_ST0_FT0(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n\n                break;\n\n            case 0x1c:\n\n                switch(rm) {\n\n                case 0: /* feni (287 only, just do nop here) */\n\n                    break;\n\n                case 1: /* fdisi (287 only, just do nop here) */\n\n                    break;\n\n                case 2: /* fclex */\n\n                    gen_helper_fclex(cpu_env);\n\n                    break;\n\n                case 3: /* fninit */\n\n                    gen_helper_fninit(cpu_env);\n\n                    break;\n\n                case 4: /* fsetpm (287 only, just do nop here) */\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n\n                break;\n\n            case 0x1d: /* fucomi */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x1e: /* fcomi */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x28: /* ffree sti */\n\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x2a: /* fst sti */\n\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x2b: /* fstp sti */\n\n            case 0x0b: /* fstp1 sti, undocumented op */\n\n            case 0x3a: /* fstp8 sti, undocumented op */\n\n            case 0x3b: /* fstp9 sti, undocumented op */\n\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x2c: /* fucom st(i) */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucom_ST0_FT0(cpu_env);\n\n                break;\n\n            case 0x2d: /* fucomp st(i) */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucom_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x33: /* de/3 */\n\n                switch(rm) {\n\n                case 1: /* fcompp */\n\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n\n                break;\n\n            case 0x38: /* ffreep sti, undocumented op */\n\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x3c: /* df/4 */\n\n                switch(rm) {\n\n                case 0:\n\n                    gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n\n                    tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);\n\n                    gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n\n                break;\n\n            case 0x3d: /* fucomip */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x3e: /* fcomip */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x10 ... 0x13: /* fcmovxx */\n\n            case 0x18 ... 0x1b:\n\n                {\n\n                    int op1;\n\n                    TCGLabel *l1;\n\n                    static const uint8_t fcmov_cc[8] = {\n\n                        (JCC_B << 1),\n\n                        (JCC_Z << 1),\n\n                        (JCC_BE << 1),\n\n                        (JCC_P << 1),\n\n                    };\n\n\n\n                    if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                        goto illegal_op;\n\n\n                    op1 = fcmov_cc[op & 3] | (((op >> 3) & 1) ^ 1);\n\n                    l1 = gen_new_label();\n\n                    gen_jcc1_noeob(s, op1, l1);\n\n                    gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32(opreg));\n\n                    gen_set_label(l1);\n\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n\n\n        break;\n\n        /************************/\n\n        /* string ops */\n\n\n\n    case 0xa4: /* movsS */\n\n    case 0xa5:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_movs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_movs(s, ot);\n\n\n        break;\n\n\n\n    case 0xaa: /* stosS */\n\n    case 0xab:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_stos(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_stos(s, ot);\n\n\n        break;\n\n    case 0xac: /* lodsS */\n\n    case 0xad:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_lods(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_lods(s, ot);\n\n\n        break;\n\n    case 0xae: /* scasS */\n\n    case 0xaf:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & PREFIX_REPNZ) {\n\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n\n        } else if (prefixes & PREFIX_REPZ) {\n\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n\n        } else {\n\n            gen_scas(s, ot);\n\n\n        break;\n\n\n\n    case 0xa6: /* cmpsS */\n\n    case 0xa7:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & PREFIX_REPNZ) {\n\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n\n        } else if (prefixes & PREFIX_REPZ) {\n\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n\n        } else {\n\n            gen_cmps(s, ot);\n\n\n        break;\n\n    case 0x6c: /* insS */\n\n    case 0x6d:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base, \n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes) | 4);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_ins(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_ins(s, ot);\n\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n\n\n        break;\n\n    case 0x6e: /* outsS */\n\n    case 0x6f:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes) | 4);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_outs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_outs(s, ot);\n\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n\n\n        break;\n\n\n\n        /************************/\n\n        /* port I/O */\n\n\n\n    case 0xe4:\n\n    case 0xe5:\n\n        ot = mo_b_d32(b, dflag);\n\n        val = cpu_ldub_code(env, s->pc++);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n\n\n\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, val);\n\n        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);\n\n        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n\n        break;\n\n    case 0xe6:\n\n    case 0xe7:\n\n        ot = mo_b_d32(b, dflag);\n\n        val = cpu_ldub_code(env, s->pc++);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes));\n\n        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);\n\n\n\n\n\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, val);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n\n        break;\n\n    case 0xec:\n\n    case 0xed:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n\n\n\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);\n\n        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n\n        break;\n\n    case 0xee:\n\n    case 0xef:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes));\n\n        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);\n\n\n\n\n\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n\n        break;\n\n\n\n        /************************/\n\n        /* control */\n\n    case 0xc2: /* ret im */\n\n        val = cpu_ldsw_code(env, s->pc);\n\n        s->pc += 2;\n\n        ot = gen_pop_T0(s);\n\n        gen_stack_update(s, val + (1 << ot));\n\n        /* Note that gen_pop_T0 uses a zero-extending load.  */\n\n        gen_op_jmp_v(cpu_T0);\n\n        gen_bnd_jmp(s);\n\n        gen_jr(s, cpu_T0);\n\n        break;\n\n    case 0xc3: /* ret */\n\n        ot = gen_pop_T0(s);\n\n        gen_pop_update(s, ot);\n\n        /* Note that gen_pop_T0 uses a zero-extending load.  */\n\n        gen_op_jmp_v(cpu_T0);\n\n        gen_bnd_jmp(s);\n\n        gen_jr(s, cpu_T0);\n\n        break;\n\n    case 0xca: /* lret im */\n\n        val = cpu_ldsw_code(env, s->pc);\n\n        s->pc += 2;\n\n    do_lret:\n\n        if (s->pe && !s->vm86) {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_lret_protected(cpu_env, tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(val));\n\n        } else {\n\n            gen_stack_A0(s);\n\n            /* pop offset */\n\n            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);\n\n            /* NOTE: keeping EIP updated is not a problem in case of\n\n               exception */\n\n            gen_op_jmp_v(cpu_T0);\n\n            /* pop selector */\n\n            gen_add_A0_im(s, 1 << dflag);\n\n            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);\n\n            gen_op_movl_seg_T0_vm(R_CS);\n\n            /* add stack offset */\n\n            gen_stack_update(s, val + (2 << dflag));\n\n\n        gen_eob(s);\n\n        break;\n\n    case 0xcb: /* lret */\n\n        val = 0;\n\n        goto do_lret;\n\n    case 0xcf: /* iret */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET);\n\n        if (!s->pe) {\n\n            /* real mode */\n\n            gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n        } else if (s->vm86) {\n\n            if (s->iopl != 3) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n\n        } else {\n\n            gen_helper_iret_protected(cpu_env, tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(s->pc - s->cs_base));\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n\n        gen_eob(s);\n\n        break;\n\n    case 0xe8: /* call im */\n\n        {\n\n            if (dflag != MO_16) {\n\n                tval = (int32_t)insn_get(env, s, MO_32);\n\n            } else {\n\n                tval = (int16_t)insn_get(env, s, MO_16);\n\n\n            next_eip = s->pc - s->cs_base;\n\n            tval += next_eip;\n\n            if (dflag == MO_16) {\n\n                tval &= 0xffff;\n\n            } else if (!CODE64(s)) {\n\n                tval &= 0xffffffff;\n\n\n            tcg_gen_movi_tl(cpu_T0, next_eip);\n\n            gen_push_v(s, cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jmp(s, tval);\n\n\n        break;\n\n    case 0x9a: /* lcall im */\n\n        {\n\n            unsigned int selector, offset;\n\n\n\n            if (CODE64(s))\n\n                goto illegal_op;\n\n            ot = dflag;\n\n            offset = insn_get(env, s, ot);\n\n            selector = insn_get(env, s, MO_16);\n\n\n\n            tcg_gen_movi_tl(cpu_T0, selector);\n\n            tcg_gen_movi_tl(cpu_T1, offset);\n\n\n        goto do_lcall;\n\n    case 0xe9: /* jmp im */\n\n        if (dflag != MO_16) {\n\n            tval = (int32_t)insn_get(env, s, MO_32);\n\n        } else {\n\n            tval = (int16_t)insn_get(env, s, MO_16);\n\n\n        tval += s->pc - s->cs_base;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n        } else if (!CODE64(s)) {\n\n            tval &= 0xffffffff;\n\n\n        gen_bnd_jmp(s);\n\n        gen_jmp(s, tval);\n\n        break;\n\n    case 0xea: /* ljmp im */\n\n        {\n\n            unsigned int selector, offset;\n\n\n\n            if (CODE64(s))\n\n                goto illegal_op;\n\n            ot = dflag;\n\n            offset = insn_get(env, s, ot);\n\n            selector = insn_get(env, s, MO_16);\n\n\n\n            tcg_gen_movi_tl(cpu_T0, selector);\n\n            tcg_gen_movi_tl(cpu_T1, offset);\n\n\n        goto do_ljmp;\n\n    case 0xeb: /* jmp Jb */\n\n        tval = (int8_t)insn_get(env, s, MO_8);\n\n        tval += s->pc - s->cs_base;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n\n        gen_jmp(s, tval);\n\n        break;\n\n    case 0x70 ... 0x7f: /* jcc Jb */\n\n        tval = (int8_t)insn_get(env, s, MO_8);\n\n        goto do_jcc;\n\n    case 0x180 ... 0x18f: /* jcc Jv */\n\n        if (dflag != MO_16) {\n\n            tval = (int32_t)insn_get(env, s, MO_32);\n\n        } else {\n\n            tval = (int16_t)insn_get(env, s, MO_16);\n\n\n    do_jcc:\n\n        next_eip = s->pc - s->cs_base;\n\n        tval += next_eip;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n\n        gen_bnd_jmp(s);\n\n        gen_jcc(s, b, tval, next_eip);\n\n        break;\n\n\n\n    case 0x190 ... 0x19f: /* setcc Gv */\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        gen_setcc1(s, b, cpu_T0);\n\n        gen_ldst_modrm(env, s, modrm, MO_8, OR_TMP0, 1);\n\n        break;\n\n    case 0x140 ... 0x14f: /* cmov Gv, Ev */\n\n        if (!(s->cpuid_features & CPUID_CMOV)) {\n\n            goto illegal_op;\n\n\n        ot = dflag;\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        gen_cmovcc1(env, s, ot, b, modrm, reg);\n\n        break;\n\n\n\n        /************************/\n\n        /* flags */\n\n    case 0x9c: /* pushf */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_helper_read_eflags(cpu_T0, cpu_env);\n\n            gen_push_v(s, cpu_T0);\n\n\n        break;\n\n    case 0x9d: /* popf */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            ot = gen_pop_T0(s);\n\n            if (s->cpl == 0) {\n\n                if (dflag != MO_16) {\n\n                    gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                           ID_MASK | NT_MASK |\n\n                                                           IF_MASK |\n\n                                                           IOPL_MASK)));\n\n                } else {\n\n                    gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                           ID_MASK | NT_MASK |\n\n                                                           IF_MASK | IOPL_MASK)\n\n                                                          & 0xffff));\n\n\n            } else {\n\n                if (s->cpl <= s->iopl) {\n\n                    if (dflag != MO_16) {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                                tcg_const_i32((TF_MASK |\n\n                                                               AC_MASK |\n\n                                                               ID_MASK |\n\n                                                               NT_MASK |\n\n                                                               IF_MASK)));\n\n                    } else {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                                tcg_const_i32((TF_MASK |\n\n                                                               AC_MASK |\n\n                                                               ID_MASK |\n\n                                                               NT_MASK |\n\n                                                               IF_MASK)\n\n                                                              & 0xffff));\n\n\n                } else {\n\n                    if (dflag != MO_16) {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                          ID_MASK | NT_MASK)));\n\n                    } else {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                          ID_MASK | NT_MASK)\n\n                                                         & 0xffff));\n\n\n\n\n            gen_pop_update(s, ot);\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            /* abort translation because TF/AC flag may change */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n\n        break;\n\n    case 0x9e: /* sahf */\n\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n\n            goto illegal_op;\n\n        gen_op_mov_v_reg(MO_8, cpu_T0, R_AH);\n\n        gen_compute_eflags(s);\n\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O);\n\n        tcg_gen_andi_tl(cpu_T0, cpu_T0, CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n        tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T0);\n\n        break;\n\n    case 0x9f: /* lahf */\n\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n\n            goto illegal_op;\n\n        gen_compute_eflags(s);\n\n        /* Note: gen_compute_eflags() only gives the condition codes */\n\n        tcg_gen_ori_tl(cpu_T0, cpu_cc_src, 0x02);\n\n        gen_op_mov_reg_v(MO_8, R_AH, cpu_T0);\n\n        break;\n\n    case 0xf5: /* cmc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n\n        break;\n\n    case 0xf8: /* clc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C);\n\n        break;\n\n    case 0xf9: /* stc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n\n        break;\n\n    case 0xfc: /* cld */\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, 1);\n\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n\n        break;\n\n    case 0xfd: /* std */\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, -1);\n\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n\n        break;\n\n\n\n        /************************/\n\n        /* bit operations */\n\n    case 0x1ba: /* bt/bts/btr/btc Gv, im */\n\n        ot = dflag;\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        op = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        if (mod != 3) {\n\n            s->rip_offset = 1;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (!(s->prefix & PREFIX_LOCK)) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n\n        /* load shift */\n\n        val = cpu_ldub_code(env, s->pc++);\n\n        tcg_gen_movi_tl(cpu_T1, val);\n\n        if (op < 4)\n\n            goto unknown_op;\n\n        op -= 4;\n\n        goto bt_op;\n\n    case 0x1a3: /* bt Gv, Ev */\n\n        op = 0;\n\n        goto do_btx;\n\n    case 0x1ab: /* bts */\n\n        op = 1;\n\n        goto do_btx;\n\n    case 0x1b3: /* btr */\n\n        op = 2;\n\n        goto do_btx;\n\n    case 0x1bb: /* btc */\n\n        op = 3;\n\n    do_btx:\n\n        ot = dflag;\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        gen_op_mov_v_reg(MO_32, cpu_T1, reg);\n\n        if (mod != 3) {\n\n            AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n            /* specific case: we need to add a displacement */\n\n            gen_exts(ot, cpu_T1);\n\n            tcg_gen_sari_tl(cpu_tmp0, cpu_T1, 3 + ot);\n\n            tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, ot);\n\n            tcg_gen_add_tl(cpu_A0, gen_lea_modrm_1(a), cpu_tmp0);\n\n            gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n            if (!(s->prefix & PREFIX_LOCK)) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n\n    bt_op:\n\n        tcg_gen_andi_tl(cpu_T1, cpu_T1, (1 << (3 + ot)) - 1);\n\n        tcg_gen_movi_tl(cpu_tmp0, 1);\n\n        tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T1);\n\n        if (s->prefix & PREFIX_LOCK) {\n\n            switch (op) {\n\n            case 0: /* bt */\n\n                /* Needs no atomic ops; we surpressed the normal\n\n                   memory load for LOCK above so do it now.  */\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n                break;\n\n            case 1: /* bts */\n\n                tcg_gen_atomic_fetch_or_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                           s->mem_index, ot | MO_LE);\n\n                break;\n\n            case 2: /* btr */\n\n                tcg_gen_not_tl(cpu_tmp0, cpu_tmp0);\n\n                tcg_gen_atomic_fetch_and_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                break;\n\n            default:\n\n            case 3: /* btc */\n\n                tcg_gen_atomic_fetch_xor_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                break;\n\n\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);\n\n        } else {\n\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);\n\n            switch (op) {\n\n            case 0: /* bt */\n\n                /* Data already loaded; nothing to do.  */\n\n                break;\n\n            case 1: /* bts */\n\n                tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n            case 2: /* btr */\n\n                tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n            default:\n\n            case 3: /* btc */\n\n                tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n\n            if (op != 0) {\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n\n\n\n\n\n        /* Delay all CC updates until after the store above.  Note that\n\n           C is the result of the test, Z is unchanged, and the others\n\n           are all undefined.  */\n\n        switch (s->cc_op) {\n\n        case CC_OP_MULB ... CC_OP_MULQ:\n\n        case CC_OP_ADDB ... CC_OP_ADDQ:\n\n        case CC_OP_ADCB ... CC_OP_ADCQ:\n\n        case CC_OP_SUBB ... CC_OP_SUBQ:\n\n        case CC_OP_SBBB ... CC_OP_SBBQ:\n\n        case CC_OP_LOGICB ... CC_OP_LOGICQ:\n\n        case CC_OP_INCB ... CC_OP_INCQ:\n\n        case CC_OP_DECB ... CC_OP_DECQ:\n\n        case CC_OP_SHLB ... CC_OP_SHLQ:\n\n        case CC_OP_SARB ... CC_OP_SARQ:\n\n        case CC_OP_BMILGB ... CC_OP_BMILGQ:\n\n            /* Z was going to be computed from the non-zero status of CC_DST.\n\n               We can get that same Z value (and the new C value) by leaving\n\n               CC_DST alone, setting CC_SRC, and using a CC_OP_SAR of the\n\n               same width.  */\n\n            tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4);\n\n            set_cc_op(s, ((s->cc_op - CC_OP_MULB) & 3) + CC_OP_SARB);\n\n            break;\n\n        default:\n\n            /* Otherwise, generate EFLAGS and replace the C bit.  */\n\n            gen_compute_eflags(s);\n\n            tcg_gen_deposit_tl(cpu_cc_src, cpu_cc_src, cpu_tmp4,\n\n                               ctz32(CC_C), 1);\n\n            break;\n\n\n        break;\n\n    case 0x1bc: /* bsf / tzcnt */\n\n    case 0x1bd: /* bsr / lzcnt */\n\n        ot = dflag;\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_extu(ot, cpu_T0);\n\n\n\n        /* Note that lzcnt and tzcnt are in different extensions.  */\n\n        if ((prefixes & PREFIX_REPZ)\n\n            && (b & 1\n\n                ? s->cpuid_ext3_features & CPUID_EXT3_ABM\n\n                : s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)) {\n\n            int size = 8 << ot;\n\n            /* For lzcnt/tzcnt, C bit is defined related to the input. */\n\n            tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n            if (b & 1) {\n\n                /* For lzcnt, reduce the target_ulong result by the\n\n                   number of zeros that we expect to find at the top.  */\n\n                tcg_gen_clzi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS);\n\n                tcg_gen_subi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - size);\n\n            } else {\n\n                /* For tzcnt, a zero input must return the operand size.  */\n\n                tcg_gen_ctzi_tl(cpu_T0, cpu_T0, size);\n\n\n            /* For lzcnt/tzcnt, Z bit is defined related to the result.  */\n\n            gen_op_update1_cc();\n\n            set_cc_op(s, CC_OP_BMILGB + ot);\n\n        } else {\n\n            /* For bsr/bsf, only the Z bit is defined and it is related\n\n               to the input and not the result.  */\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n            set_cc_op(s, CC_OP_LOGICB + ot);\n\n\n\n            /* ??? The manual says that the output is undefined when the\n\n               input is zero, but real hardware leaves it unchanged, and\n\n               real programs appear to depend on that.  Accomplish this\n\n               by passing the output as the value to return upon zero.  */\n\n            if (b & 1) {\n\n                /* For bsr, return the bit index of the first 1 bit,\n\n                   not the count of leading zeros.  */\n\n                tcg_gen_xori_tl(cpu_T1, cpu_regs[reg], TARGET_LONG_BITS - 1);\n\n                tcg_gen_clz_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                tcg_gen_xori_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - 1);\n\n            } else {\n\n                tcg_gen_ctz_tl(cpu_T0, cpu_T0, cpu_regs[reg]);\n\n\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        break;\n\n        /************************/\n\n        /* bcd */\n\n    case 0x27: /* daa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_daa(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x2f: /* das */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_das(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x37: /* aaa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_aaa(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x3f: /* aas */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_aas(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0xd4: /* aam */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        val = cpu_ldub_code(env, s->pc++);\n\n        if (val == 0) {\n\n            gen_exception(s, EXCP00_DIVZ, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_aam(cpu_env, tcg_const_i32(val));\n\n            set_cc_op(s, CC_OP_LOGICB);\n\n\n        break;\n\n    case 0xd5: /* aad */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        val = cpu_ldub_code(env, s->pc++);\n\n        gen_helper_aad(cpu_env, tcg_const_i32(val));\n\n        set_cc_op(s, CC_OP_LOGICB);\n\n        break;\n\n        /************************/\n\n        /* misc */\n\n    case 0x90: /* nop */\n\n        /* XXX: correct lock test for all insn */\n\n        if (prefixes & PREFIX_LOCK) {\n\n            goto illegal_op;\n\n\n        /* If REX_B is set, then this is xchg eax, r8d, not a nop.  */\n\n        if (REX_B(s)) {\n\n            goto do_xchg_reg_eax;\n\n\n        if (prefixes & PREFIX_REPZ) {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_pause(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            s->is_jmp = DISAS_TB_JUMP;\n\n\n        break;\n\n    case 0x9b: /* fwait */\n\n        if ((s->flags & (HF_MP_MASK | HF_TS_MASK)) ==\n\n            (HF_MP_MASK | HF_TS_MASK)) {\n\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_fwait(cpu_env);\n\n\n        break;\n\n    case 0xcc: /* int3 */\n\n        gen_interrupt(s, EXCP03_INT3, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        break;\n\n    case 0xcd: /* int N */\n\n        val = cpu_ldub_code(env, s->pc++);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_interrupt(s, val, pc_start - s->cs_base, s->pc - s->cs_base);\n\n\n        break;\n\n    case 0xce: /* into */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_into(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n        break;\n\n#ifdef WANT_ICEBP\n\n    case 0xf1: /* icebp (undocumented, exits to external debugger) */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_ICEBP);\n\n#if 1\n\n        gen_debug(s, pc_start - s->cs_base);\n\n#else\n\n        /* start debug */\n\n        tb_flush(CPU(x86_env_get_cpu(env)));\n\n        qemu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM);\n\n#endif\n\n        break;\n\n#endif\n\n    case 0xfa: /* cli */\n\n        if (!s->vm86) {\n\n            if (s->cpl <= s->iopl) {\n\n                gen_helper_cli(cpu_env);\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n\n        } else {\n\n            if (s->iopl == 3) {\n\n                gen_helper_cli(cpu_env);\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n\n\n        break;\n\n    case 0xfb: /* sti */\n\n        if (s->vm86 ? s->iopl == 3 : s->cpl <= s->iopl) {\n\n            gen_helper_sti(cpu_env);\n\n            /* interruptions are enabled only the first insn after sti */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob_inhibit_irq(s, true);\n\n        } else {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n\n        break;\n\n    case 0x62: /* bound */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        ot = dflag;\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        reg = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n        gen_lea_modrm(env, s, modrm);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        if (ot == MO_16) {\n\n            gen_helper_boundw(cpu_env, cpu_A0, cpu_tmp2_i32);\n\n        } else {\n\n            gen_helper_boundl(cpu_env, cpu_A0, cpu_tmp2_i32);\n\n\n        break;\n\n    case 0x1c8 ... 0x1cf: /* bswap reg */\n\n        reg = (b & 7) | REX_B(s);\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            gen_op_mov_v_reg(MO_64, cpu_T0, reg);\n\n            tcg_gen_bswap64_i64(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_64, reg, cpu_T0);\n\n        } else\n\n#endif\n\n        {\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, reg);\n\n            tcg_gen_ext32u_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_bswap32_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_32, reg, cpu_T0);\n\n\n        break;\n\n    case 0xd6: /* salc */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_compute_eflags_c(s, cpu_T0);\n\n        tcg_gen_neg_tl(cpu_T0, cpu_T0);\n\n        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);\n\n        break;\n\n    case 0xe0: /* loopnz */\n\n    case 0xe1: /* loopz */\n\n    case 0xe2: /* loop */\n\n    case 0xe3: /* jecxz */\n\n        {\n\n            TCGLabel *l1, *l2, *l3;\n\n\n\n            tval = (int8_t)insn_get(env, s, MO_8);\n\n            next_eip = s->pc - s->cs_base;\n\n            tval += next_eip;\n\n            if (dflag == MO_16) {\n\n                tval &= 0xffff;\n\n\n\n\n            l1 = gen_new_label();\n\n            l2 = gen_new_label();\n\n            l3 = gen_new_label();\n\n            b &= 3;\n\n            switch(b) {\n\n            case 0: /* loopnz */\n\n            case 1: /* loopz */\n\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n\n                gen_op_jz_ecx(s->aflag, l3);\n\n                gen_jcc1(s, (JCC_Z << 1) | (b ^ 1), l1);\n\n                break;\n\n            case 2: /* loop */\n\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n\n                gen_op_jnz_ecx(s->aflag, l1);\n\n                break;\n\n            default:\n\n            case 3: /* jcxz */\n\n                gen_op_jz_ecx(s->aflag, l1);\n\n                break;\n\n\n\n\n            gen_set_label(l3);\n\n            gen_jmp_im(next_eip);\n\n            tcg_gen_br(l2);\n\n\n\n            gen_set_label(l1);\n\n            gen_jmp_im(tval);\n\n            gen_set_label(l2);\n\n            gen_eob(s);\n\n\n        break;\n\n    case 0x130: /* wrmsr */\n\n    case 0x132: /* rdmsr */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            if (b & 2) {\n\n                gen_helper_rdmsr(cpu_env);\n\n            } else {\n\n                gen_helper_wrmsr(cpu_env);\n\n\n\n        break;\n\n    case 0x131: /* rdtsc */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n\n\n\n        gen_helper_rdtsc(cpu_env);\n\n\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n\n        break;\n\n    case 0x133: /* rdpmc */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_rdpmc(cpu_env);\n\n        break;\n\n    case 0x134: /* sysenter */\n\n        /* For Intel SYSENTER is valid on 64-bit */\n\n        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n\n            goto illegal_op;\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysenter(cpu_env);\n\n            gen_eob(s);\n\n\n        break;\n\n    case 0x135: /* sysexit */\n\n        /* For Intel SYSEXIT is valid on 64-bit */\n\n        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n\n            goto illegal_op;\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysexit(cpu_env, tcg_const_i32(dflag - 1));\n\n            gen_eob(s);\n\n\n        break;\n\n#ifdef TARGET_X86_64\n\n    case 0x105: /* syscall */\n\n        /* XXX: is it usable in real mode ? */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_syscall(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n        /* TF handling for the syscall insn is different. The TF bit is  checked\n\n           after the syscall insn completes. This allows #DB to not be\n\n           generated after one has entered CPL0 if TF is set in FMASK.  */\n\n        gen_eob_worker(s, false, true);\n\n        break;\n\n    case 0x107: /* sysret */\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysret(cpu_env, tcg_const_i32(dflag - 1));\n\n            /* condition codes are modified only in long mode */\n\n            if (s->lma) {\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n\n            /* TF handling for the sysret insn is different. The TF bit is\n\n               checked after the sysret insn completes. This allows #DB to be\n\n               generated \"as if\" the syscall insn in userspace has just\n\n               completed.  */\n\n            gen_eob_worker(s, false, true);\n\n\n        break;\n\n#endif\n\n    case 0x1a2: /* cpuid */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_cpuid(cpu_env);\n\n        break;\n\n    case 0xf4: /* hlt */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_hlt(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            s->is_jmp = DISAS_TB_JUMP;\n\n\n        break;\n\n    case 0x100:\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        switch(op) {\n\n        case 0: /* sldt */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_READ);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n\n                             offsetof(CPUX86State, ldt.selector));\n\n            ot = mod == 3 ? dflag : MO_16;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 2: /* lldt */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_WRITE);\n\n                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lldt(cpu_env, cpu_tmp2_i32);\n\n\n            break;\n\n        case 1: /* str */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_READ);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n\n                             offsetof(CPUX86State, tr.selector));\n\n            ot = mod == 3 ? dflag : MO_16;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 3: /* ltr */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_WRITE);\n\n                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_ltr(cpu_env, cpu_tmp2_i32);\n\n\n            break;\n\n        case 4: /* verr */\n\n        case 5: /* verw */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            gen_update_cc_op(s);\n\n            if (op == 4) {\n\n                gen_helper_verr(cpu_env, cpu_T0);\n\n            } else {\n\n                gen_helper_verw(cpu_env, cpu_T0);\n\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n\n        break;\n\n\n\n    case 0x101:\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        switch (modrm) {\n\n        CASE_MODRM_MEM_OP(0): /* sgdt */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_READ);\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0,\n\n                             cpu_env, offsetof(CPUX86State, gdt.limit));\n\n            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n\n            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        case 0xc8: /* monitor */\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {\n\n                goto illegal_op;\n\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EAX]);\n\n            gen_extu(s->aflag, cpu_A0);\n\n            gen_add_A0_ds_seg(s);\n\n            gen_helper_monitor(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        case 0xc9: /* mwait */\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {\n\n                goto illegal_op;\n\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_mwait(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xca: /* clac */\n\n            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)\n\n                || s->cpl != 0) {\n\n                goto illegal_op;\n\n\n            gen_helper_clac(cpu_env);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xcb: /* stac */\n\n            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)\n\n                || s->cpl != 0) {\n\n                goto illegal_op;\n\n\n            gen_helper_stac(cpu_env);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(1): /* sidt */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_READ);\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.limit));\n\n            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n\n            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        case 0xd0: /* xgetbv */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA\n\n                                 | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_xgetbv(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);\n\n            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);\n\n            break;\n\n\n\n        case 0xd1: /* xsetbv */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA\n\n                                 | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_xsetbv(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);\n\n            /* End TB because translation flags may change.  */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xd8: /* VMRUN */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmrun(cpu_env, tcg_const_i32(s->aflag - 1),\n\n                             tcg_const_i32(s->pc - pc_start));\n\n            tcg_gen_exit_tb(0);\n\n            s->is_jmp = DISAS_TB_JUMP;\n\n            break;\n\n\n\n        case 0xd9: /* VMMCALL */\n\n            if (!(s->flags & HF_SVME_MASK)) {\n\n                goto illegal_op;\n\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmmcall(cpu_env);\n\n            break;\n\n\n\n        case 0xda: /* VMLOAD */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmload(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        case 0xdb: /* VMSAVE */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmsave(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        case 0xdc: /* STGI */\n\n            if ((!(s->flags & HF_SVME_MASK)\n\n                   && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))\n\n                || !s->pe) {\n\n                goto illegal_op;\n\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_stgi(cpu_env);\n\n            break;\n\n\n\n        case 0xdd: /* CLGI */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_clgi(cpu_env);\n\n            break;\n\n\n\n        case 0xde: /* SKINIT */\n\n            if ((!(s->flags & HF_SVME_MASK)\n\n                 && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))\n\n                || !s->pe) {\n\n                goto illegal_op;\n\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_skinit(cpu_env);\n\n            break;\n\n\n\n        case 0xdf: /* INVLPGA */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_invlpga(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(2): /* lgdt */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_WRITE);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n\n            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));\n\n            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, gdt.limit));\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(3): /* lidt */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_WRITE);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n\n            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));\n\n            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, idt.limit));\n\n            break;\n\n\n\n        CASE_MODRM_OP(4): /* smsw */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_CR0);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, cr[0]));\n\n            if (CODE64(s)) {\n\n                mod = (modrm >> 6) & 3;\n\n                ot = (mod != 3 ? MO_16 : s->dflag);\n\n            } else {\n\n                ot = MO_16;\n\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 0xee: /* rdpkru */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_rdpkru(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);\n\n            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);\n\n            break;\n\n        case 0xef: /* wrpkru */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_wrpkru(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);\n\n            break;\n\n        CASE_MODRM_OP(6): /* lmsw */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            gen_helper_lmsw(cpu_env, cpu_T0);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(7): /* invlpg */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_invlpg(cpu_env, cpu_A0);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xf8: /* swapgs */\n\n#ifdef TARGET_X86_64\n\n            if (CODE64(s)) {\n\n                if (s->cpl != 0) {\n\n                    gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                } else {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_seg_base[R_GS]);\n\n                    tcg_gen_ld_tl(cpu_seg_base[R_GS], cpu_env,\n\n                                  offsetof(CPUX86State, kernelgsbase));\n\n                    tcg_gen_st_tl(cpu_T0, cpu_env,\n\n                                  offsetof(CPUX86State, kernelgsbase));\n\n\n                break;\n\n\n#endif\n\n            goto illegal_op;\n\n\n\n        case 0xf9: /* rdtscp */\n\n            if (!(s->cpuid_ext2_features & CPUID_EXT2_RDTSCP)) {\n\n                goto illegal_op;\n\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n\n\n\n            gen_helper_rdtscp(cpu_env);\n\n\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n\n            break;\n\n\n\n        default:\n\n            goto unknown_op;\n\n\n        break;\n\n\n\n    case 0x108: /* invd */\n\n    case 0x109: /* wbinvd */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_svm_check_intercept(s, pc_start, (b & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD);\n\n            /* nothing to do */\n\n\n        break;\n\n    case 0x63: /* arpl or movslS (x86_64) */\n\n#ifdef TARGET_X86_64\n\n        if (CODE64(s)) {\n\n            int d_ot;\n\n            /* d_ot is the size of destination */\n\n            d_ot = dflag;\n\n\n\n            modrm = cpu_ldub_code(env, s->pc++);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n\n\n            if (mod == 3) {\n\n                gen_op_mov_v_reg(MO_32, cpu_T0, rm);\n\n                /* sign extend */\n\n                if (d_ot == MO_64) {\n\n                    tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            } else {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, MO_32 | MO_SIGN, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n\n        } else\n\n#endif\n\n        {\n\n            TCGLabel *label1;\n\n            TCGv t0, t1, t2, a0;\n\n\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            t0 = tcg_temp_local_new();\n\n            t1 = tcg_temp_local_new();\n\n            t2 = tcg_temp_local_new();\n\n            ot = MO_16;\n\n            modrm = cpu_ldub_code(env, s->pc++);\n\n            reg = (modrm >> 3) & 7;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = modrm & 7;\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, ot, t0, cpu_A0);\n\n                a0 = tcg_temp_local_new();\n\n                tcg_gen_mov_tl(a0, cpu_A0);\n\n            } else {\n\n                gen_op_mov_v_reg(ot, t0, rm);\n\n                TCGV_UNUSED(a0);\n\n\n            gen_op_mov_v_reg(ot, t1, reg);\n\n            tcg_gen_andi_tl(cpu_tmp0, t0, 3);\n\n            tcg_gen_andi_tl(t1, t1, 3);\n\n            tcg_gen_movi_tl(t2, 0);\n\n            label1 = gen_new_label();\n\n            tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, t1, label1);\n\n            tcg_gen_andi_tl(t0, t0, ~3);\n\n            tcg_gen_or_tl(t0, t0, t1);\n\n            tcg_gen_movi_tl(t2, CC_Z);\n\n            gen_set_label(label1);\n\n            if (mod != 3) {\n\n                gen_op_st_v(s, ot, t0, a0);\n\n                tcg_temp_free(a0);\n\n           } else {\n\n                gen_op_mov_reg_v(ot, rm, t0);\n\n\n            gen_compute_eflags(s);\n\n            tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z);\n\n            tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, t2);\n\n            tcg_temp_free(t0);\n\n            tcg_temp_free(t1);\n\n            tcg_temp_free(t2);\n\n\n        break;\n\n    case 0x102: /* lar */\n\n    case 0x103: /* lsl */\n\n        {\n\n            TCGLabel *label1;\n\n            TCGv t0;\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            ot = dflag != MO_16 ? MO_32 : MO_16;\n\n            modrm = cpu_ldub_code(env, s->pc++);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            t0 = tcg_temp_local_new();\n\n            gen_update_cc_op(s);\n\n            if (b == 0x102) {\n\n                gen_helper_lar(t0, cpu_env, cpu_T0);\n\n            } else {\n\n                gen_helper_lsl(t0, cpu_env, cpu_T0);\n\n\n            tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z);\n\n            label1 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1);\n\n            gen_op_mov_reg_v(ot, reg, t0);\n\n            gen_set_label(label1);\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            tcg_temp_free(t0);\n\n\n        break;\n\n    case 0x118:\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        switch(op) {\n\n        case 0: /* prefetchnta */\n\n        case 1: /* prefetchnt0 */\n\n        case 2: /* prefetchnt0 */\n\n        case 3: /* prefetchnt0 */\n\n            if (mod == 3)\n\n                goto illegal_op;\n\n            gen_nop_modrm(env, s, modrm);\n\n            /* nothing more to do */\n\n            break;\n\n        default: /* nop (multi byte) */\n\n            gen_nop_modrm(env, s, modrm);\n\n            break;\n\n\n        break;\n\n    case 0x11a:\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        if (s->flags & HF_MPX_EN_MASK) {\n\n            mod = (modrm >> 6) & 3;\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (prefixes & PREFIX_REPZ) {\n\n                /* bndcl */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n\n                gen_bndck(env, s, modrm, TCG_COND_LTU, cpu_bndl[reg]);\n\n            } else if (prefixes & PREFIX_REPNZ) {\n\n                /* bndcu */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n\n                TCGv_i64 notu = tcg_temp_new_i64();\n\n                tcg_gen_not_i64(notu, cpu_bndu[reg]);\n\n                gen_bndck(env, s, modrm, TCG_COND_GTU, notu);\n\n                tcg_temp_free_i64(notu);\n\n            } else if (prefixes & PREFIX_DATA) {\n\n                /* bndmov -- from reg/mem */\n\n                if (reg >= 4 || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n\n                if (mod == 3) {\n\n                    int reg2 = (modrm & 7) | REX_B(s);\n\n                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {\n\n                        goto illegal_op;\n\n\n                    if (s->flags & HF_MPX_IU_MASK) {\n\n                        tcg_gen_mov_i64(cpu_bndl[reg], cpu_bndl[reg2]);\n\n                        tcg_gen_mov_i64(cpu_bndu[reg], cpu_bndu[reg2]);\n\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    if (CODE64(s)) {\n\n                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);\n\n                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                    } else {\n\n                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);\n\n                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n\n                    /* bnd registers are now in-use */\n\n                    gen_set_hflag(s, HF_MPX_IU_MASK);\n\n\n            } else if (mod != 3) {\n\n                /* bndldx */\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16\n\n                    || a.base < -1) {\n\n                    goto illegal_op;\n\n\n                if (a.base >= 0) {\n\n                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_A0, 0);\n\n\n                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n                if (a.index >= 0) {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n\n                if (CODE64(s)) {\n\n                    gen_helper_bndldx64(cpu_bndl[reg], cpu_env, cpu_A0, cpu_T0);\n\n                    tcg_gen_ld_i64(cpu_bndu[reg], cpu_env,\n\n                                   offsetof(CPUX86State, mmx_t0.MMX_Q(0)));\n\n                } else {\n\n                    gen_helper_bndldx32(cpu_bndu[reg], cpu_env, cpu_A0, cpu_T0);\n\n                    tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndu[reg]);\n\n                    tcg_gen_shri_i64(cpu_bndu[reg], cpu_bndu[reg], 32);\n\n\n                gen_set_hflag(s, HF_MPX_IU_MASK);\n\n\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x11b:\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        if (s->flags & HF_MPX_EN_MASK) {\n\n            mod = (modrm >> 6) & 3;\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (mod != 3 && (prefixes & PREFIX_REPZ)) {\n\n                /* bndmk */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (a.base >= 0) {\n\n                    tcg_gen_extu_tl_i64(cpu_bndl[reg], cpu_regs[a.base]);\n\n                    if (!CODE64(s)) {\n\n                        tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndl[reg]);\n\n\n                } else if (a.base == -1) {\n\n                    /* no base register has lower bound of 0 */\n\n                    tcg_gen_movi_i64(cpu_bndl[reg], 0);\n\n                } else {\n\n                    /* rip-relative generates #ud */\n\n                    goto illegal_op;\n\n\n                tcg_gen_not_tl(cpu_A0, gen_lea_modrm_1(a));\n\n                if (!CODE64(s)) {\n\n                    tcg_gen_ext32u_tl(cpu_A0, cpu_A0);\n\n\n                tcg_gen_extu_tl_i64(cpu_bndu[reg], cpu_A0);\n\n                /* bnd registers are now in-use */\n\n                gen_set_hflag(s, HF_MPX_IU_MASK);\n\n                break;\n\n            } else if (prefixes & PREFIX_REPNZ) {\n\n                /* bndcn */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n\n                gen_bndck(env, s, modrm, TCG_COND_GTU, cpu_bndu[reg]);\n\n            } else if (prefixes & PREFIX_DATA) {\n\n                /* bndmov -- to reg/mem */\n\n                if (reg >= 4 || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n\n                if (mod == 3) {\n\n                    int reg2 = (modrm & 7) | REX_B(s);\n\n                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {\n\n                        goto illegal_op;\n\n\n                    if (s->flags & HF_MPX_IU_MASK) {\n\n                        tcg_gen_mov_i64(cpu_bndl[reg2], cpu_bndl[reg]);\n\n                        tcg_gen_mov_i64(cpu_bndu[reg2], cpu_bndu[reg]);\n\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    if (CODE64(s)) {\n\n                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);\n\n                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                    } else {\n\n                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);\n\n                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n\n\n            } else if (mod != 3) {\n\n                /* bndstx */\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16\n\n                    || a.base < -1) {\n\n                    goto illegal_op;\n\n\n                if (a.base >= 0) {\n\n                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_A0, 0);\n\n\n                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n                if (a.index >= 0) {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n\n                if (CODE64(s)) {\n\n                    gen_helper_bndstx64(cpu_env, cpu_A0, cpu_T0,\n\n                                        cpu_bndl[reg], cpu_bndu[reg]);\n\n                } else {\n\n                    gen_helper_bndstx32(cpu_env, cpu_A0, cpu_T0,\n\n                                        cpu_bndl[reg], cpu_bndu[reg]);\n\n\n\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x119: case 0x11c ... 0x11f: /* nop (multi byte) */\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x120: /* mov reg, crN */\n\n    case 0x122: /* mov crN, reg */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            modrm = cpu_ldub_code(env, s->pc++);\n\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n\n             * AMD documentation (24594.pdf) and testing of\n\n             * intel 386 and 486 processors all show that the mod bits\n\n             * are assumed to be 1's, regardless of actual values.\n\n             */\n\n            rm = (modrm & 7) | REX_B(s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (CODE64(s))\n\n                ot = MO_64;\n\n            else\n\n                ot = MO_32;\n\n            if ((prefixes & PREFIX_LOCK) && (reg == 0) &&\n\n                (s->cpuid_ext3_features & CPUID_EXT3_CR8LEG)) {\n\n                reg = 8;\n\n\n            switch(reg) {\n\n            case 0:\n\n            case 2:\n\n            case 3:\n\n            case 4:\n\n            case 8:\n\n                gen_update_cc_op(s);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                if (b & 2) {\n\n\n\n\n                    gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                    gen_helper_write_crN(cpu_env, tcg_const_i32(reg),\n\n                                         cpu_T0);\n\n\n\n\n                    gen_jmp_im(s->pc - s->cs_base);\n\n                    gen_eob(s);\n\n                } else {\n\n\n\n\n                    gen_helper_read_crN(cpu_T0, cpu_env, tcg_const_i32(reg));\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n\n\n\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n\n\n        break;\n\n    case 0x121: /* mov reg, drN */\n\n    case 0x123: /* mov drN, reg */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            modrm = cpu_ldub_code(env, s->pc++);\n\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n\n             * AMD documentation (24594.pdf) and testing of\n\n             * intel 386 and 486 processors all show that the mod bits\n\n             * are assumed to be 1's, regardless of actual values.\n\n             */\n\n            rm = (modrm & 7) | REX_B(s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (CODE64(s))\n\n                ot = MO_64;\n\n            else\n\n                ot = MO_32;\n\n            if (reg >= 8) {\n\n                goto illegal_op;\n\n\n            if (b & 2) {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_DR0 + reg);\n\n                gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, reg);\n\n                gen_helper_set_dr(cpu_env, cpu_tmp2_i32, cpu_T0);\n\n                gen_jmp_im(s->pc - s->cs_base);\n\n                gen_eob(s);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_DR0 + reg);\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, reg);\n\n                gen_helper_get_dr(cpu_T0, cpu_env, cpu_tmp2_i32);\n\n                gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n\n\n        break;\n\n    case 0x106: /* clts */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n\n            gen_helper_clts(cpu_env);\n\n            /* abort block because static cpu state changed */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n\n        break;\n\n    /* MMX/3DNow!/SSE/SSE2/SSE3/SSSE3/SSE4 support */\n\n    case 0x1c3: /* MOVNTI reg, mem */\n\n        if (!(s->cpuid_features & CPUID_SSE2))\n\n            goto illegal_op;\n\n        ot = mo_64_32(dflag);\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        /* generate a generic store */\n\n        gen_ldst_modrm(env, s, modrm, ot, reg, 1);\n\n        break;\n\n    case 0x1ae:\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        switch (modrm) {\n\n        CASE_MODRM_MEM_OP(0): /* fxsave */\n\n            if (!(s->cpuid_features & CPUID_FXSR)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n\n            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_fxsave(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(1): /* fxrstor */\n\n            if (!(s->cpuid_features & CPUID_FXSR)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n\n            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_fxrstor(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(2): /* ldmxcsr */\n\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {\n\n                goto illegal_op;\n\n\n            if (s->flags & HF_TS_MASK) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL);\n\n            gen_helper_ldmxcsr(cpu_env, cpu_tmp2_i32);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(3): /* stmxcsr */\n\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {\n\n                goto illegal_op;\n\n\n            if (s->flags & HF_TS_MASK) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, mxcsr));\n\n            gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(4): /* xsave */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (prefixes & (PREFIX_LOCK | PREFIX_DATA\n\n                                | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            gen_helper_xsave(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(5): /* xrstor */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (prefixes & (PREFIX_LOCK | PREFIX_DATA\n\n                                | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            gen_helper_xrstor(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n            /* XRSTOR is how MPX is enabled, which changes how\n\n               we translate.  Thus we need to end the TB.  */\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(6): /* xsaveopt / clwb */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* clwb */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLWB)) {\n\n                    goto illegal_op;\n\n\n                gen_nop_modrm(env, s, modrm);\n\n            } else {\n\n                /* xsaveopt */\n\n                if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                    || (s->cpuid_xsave_features & CPUID_XSAVE_XSAVEOPT) == 0\n\n                    || (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                    goto illegal_op;\n\n\n                gen_lea_modrm(env, s, modrm);\n\n                tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                      cpu_regs[R_EDX]);\n\n                gen_helper_xsaveopt(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(7): /* clflush / clflushopt */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* clflushopt */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLFLUSHOPT)) {\n\n                    goto illegal_op;\n\n\n            } else {\n\n                /* clflush */\n\n                if ((s->prefix & (PREFIX_REPZ | PREFIX_REPNZ))\n\n                    || !(s->cpuid_features & CPUID_CLFLUSH)) {\n\n                    goto illegal_op;\n\n\n\n            gen_nop_modrm(env, s, modrm);\n\n            break;\n\n\n\n        case 0xc0 ... 0xc7: /* rdfsbase (f3 0f ae /0) */\n\n        case 0xc8 ... 0xc8: /* rdgsbase (f3 0f ae /1) */\n\n        case 0xd0 ... 0xd7: /* wrfsbase (f3 0f ae /2) */\n\n        case 0xd8 ... 0xd8: /* wrgsbase (f3 0f ae /3) */\n\n            if (CODE64(s)\n\n                && (prefixes & PREFIX_REPZ)\n\n                && !(prefixes & PREFIX_LOCK)\n\n                && (s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_FSGSBASE)) {\n\n                TCGv base, treg, src, dst;\n\n\n\n                /* Preserve hflags bits by testing CR4 at runtime.  */\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, CR4_FSGSBASE_MASK);\n\n                gen_helper_cr4_testbit(cpu_env, cpu_tmp2_i32);\n\n\n\n                base = cpu_seg_base[modrm & 8 ? R_GS : R_FS];\n\n                treg = cpu_regs[(modrm & 7) | REX_B(s)];\n\n\n\n                if (modrm & 0x10) {\n\n                    /* wr*base */\n\n                    dst = base, src = treg;\n\n                } else {\n\n                    /* rd*base */\n\n                    dst = treg, src = base;\n\n\n\n\n                if (s->dflag == MO_32) {\n\n                    tcg_gen_ext32u_tl(dst, src);\n\n                } else {\n\n                    tcg_gen_mov_tl(dst, src);\n\n\n                break;\n\n\n            goto unknown_op;\n\n\n\n        case 0xf8: /* sfence / pcommit */\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* pcommit */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_PCOMMIT)\n\n                    || (prefixes & PREFIX_LOCK)) {\n\n                    goto illegal_op;\n\n\n                break;\n\n\n            /* fallthru */\n\n        case 0xf9 ... 0xff: /* sfence */\n\n            if (!(s->cpuid_features & CPUID_SSE)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n\n            tcg_gen_mb(TCG_MO_ST_ST | TCG_BAR_SC);\n\n            break;\n\n        case 0xe8 ... 0xef: /* lfence */\n\n            if (!(s->cpuid_features & CPUID_SSE)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n\n            tcg_gen_mb(TCG_MO_LD_LD | TCG_BAR_SC);\n\n            break;\n\n        case 0xf0 ... 0xf7: /* mfence */\n\n            if (!(s->cpuid_features & CPUID_SSE2)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n\n            tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC);\n\n            break;\n\n\n\n        default:\n\n            goto unknown_op;\n\n\n        break;\n\n\n\n    case 0x10d: /* 3DNow! prefetch(w) */\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x1aa: /* rsm */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_RSM);\n\n        if (!(s->flags & HF_SMM_MASK))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(s->pc - s->cs_base);\n\n        gen_helper_rsm(cpu_env);\n\n        gen_eob(s);\n\n        break;\n\n    case 0x1b8: /* SSE4.2 popcnt */\n\n        if ((prefixes & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) !=\n\n             PREFIX_REPZ)\n\n            goto illegal_op;\n\n        if (!(s->cpuid_ext_features & CPUID_EXT_POPCNT))\n\n            goto illegal_op;\n\n\n\n        modrm = cpu_ldub_code(env, s->pc++);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        if (s->prefix & PREFIX_DATA) {\n\n            ot = MO_16;\n\n        } else {\n\n            ot = mo_64_32(dflag);\n\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_extu(ot, cpu_T0);\n\n        tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n        tcg_gen_ctpop_tl(cpu_T0, cpu_T0);\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n\n\n        set_cc_op(s, CC_OP_POPCNT);\n\n        break;\n\n    case 0x10e ... 0x10f:\n\n        /* 3DNow! instructions, ignore prefixes */\n\n        s->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA);\n\n    case 0x110 ... 0x117:\n\n    case 0x128 ... 0x12f:\n\n    case 0x138 ... 0x13a:\n\n    case 0x150 ... 0x179:\n\n    case 0x17c ... 0x17f:\n\n    case 0x1c2:\n\n    case 0x1c4 ... 0x1c6:\n\n    case 0x1d0 ... 0x1fe:\n\n        gen_sse(env, s, b, pc_start, rex_r);\n\n        break;\n\n    default:\n\n        goto unknown_op;\n\n\n    return s->pc;\n\n illegal_op:\n\n    gen_illegal_opcode(s);\n\n    return s->pc;\n\n unknown_op:\n\n    gen_unknown_opcode(env, s);\n\n    return s->pc;\n", "idx": 1882, "_split": "valid", "_hash": "a81a05db0fbb4706c6e1d6c9deacc047"}
{"project": "qemu", "commit_id": "6ee5920243cc5fe35d219fa2883a673b91808c0f", "target": 0, "func": "START_TEST(escaped_string)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        const char *decoded;\n\n    } test_cases[] = {\n\n        { \"\\\"\\\\\\\"\\\"\", \"\\\"\" },\n\n        { \"\\\"hello world \\\\\\\"embedded string\\\\\\\"\\\"\",\n\n          \"hello world \\\"embedded string\\\"\" },\n\n        { \"\\\"hello world\\\\nwith new line\\\"\", \"hello world\\nwith new line\" },\n\n        { \"\\\"single byte utf-8 \\\\u0020\\\"\", \"single byte utf-8  \" },\n\n        { \"\\\"double byte utf-8 \\\\u00A2\\\"\", \"double byte utf-8 \\xc2\\xa2\" },\n\n        { \"\\\"triple byte utf-8 \\\\u20AC\\\"\", \"triple byte utf-8 \\xe2\\x82\\xac\" },\n\n        {}\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded);\n\n\n\n        fail_unless(obj != NULL);\n\n        fail_unless(qobject_type(obj) == QTYPE_QSTRING);\n\n        \n\n        str = qobject_to_qstring(obj);\n\n        fail_unless(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);\n\n\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 1914, "_split": "valid", "_hash": "a5b68a2f79580947086df61828fa3847"}
{"project": "qemu", "commit_id": "fea505221eaf87889000378d4d33ad0dfd5f4d9d", "target": 0, "func": "static void handle_mrs(DisasContext *s, uint32_t insn, unsigned int op0,\n\n                       unsigned int op1, unsigned int op2,\n\n                       unsigned int crn, unsigned int crm, unsigned int rt)\n\n{\n\n    unsupported_encoding(s, insn);\n\n}\n", "idx": 1915, "_split": "valid", "_hash": "010acb34fd5bd0fafb03339e9dc2d99f"}
{"project": "qemu", "commit_id": "0fbc20740342713f282b118b4a446c4c43df3f4a", "target": 1, "func": "int kvm_irqchip_add_msi_route(KVMState *s, MSIMessage msg)\n\n{\n\n    struct kvm_irq_routing_entry kroute;\n\n    int virq;\n\n\n\n    if (!kvm_gsi_routing_enabled()) {\n\n        return -ENOSYS;\n\n    }\n\n\n\n    virq = kvm_irqchip_get_virq(s);\n\n    if (virq < 0) {\n\n        return virq;\n\n    }\n\n\n\n    kroute.gsi = virq;\n\n    kroute.type = KVM_IRQ_ROUTING_MSI;\n\n    kroute.flags = 0;\n\n    kroute.u.msi.address_lo = (uint32_t)msg.address;\n\n    kroute.u.msi.address_hi = msg.address >> 32;\n\n    kroute.u.msi.data = le32_to_cpu(msg.data);\n\n\n\n    kvm_add_routing_entry(s, &kroute);\n\n    kvm_irqchip_commit_routes(s);\n\n\n\n    return virq;\n\n}\n", "idx": 1956, "_split": "valid", "_hash": "2a087920d75ff0a322523bce87af3d1f"}
{"project": "qemu", "commit_id": "c599d4d6d6e9bfdb64e54c33a22cb26e3496b96d", "target": 1, "func": "long do_sigreturn(CPUS390XState *env)\n\n{\n\n    sigframe *frame;\n\n    abi_ulong frame_addr = env->regs[15];\n\n    target_sigset_t target_set;\n\n    sigset_t set;\n\n\n\n    trace_user_do_sigreturn(env, frame_addr);\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1)) {\n\n        goto badframe;\n\n    }\n\n    __get_user(target_set.sig[0], &frame->sc.oldmask[0]);\n\n\n\n    target_to_host_sigset_internal(&set, &target_set);\n\n    set_sigmask(&set); /* ~_BLOCKABLE? */\n\n\n\n    if (restore_sigregs(env, &frame->sregs)) {\n\n        goto badframe;\n\n    }\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return -TARGET_QEMU_ESIGRETURN;\n\n\n\nbadframe:\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 2014, "_split": "valid", "_hash": "bc498113e713283061933abe149b966c"}
{"project": "qemu", "commit_id": "65cdadd2e2de76f7db3bf6b7d8dd8c67abff9659", "target": 0, "func": "START_TEST(qobject_to_qint_test)\n\n{\n\n    QInt *qi;\n\n\n\n    qi = qint_from_int(0);\n\n    fail_unless(qobject_to_qint(QOBJECT(qi)) == qi);\n\n\n\n    QDECREF(qi);\n\n}\n", "idx": 2034, "_split": "valid", "_hash": "526dd201a7735f6f8375155a02aa77a4"}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_label(TCGContext *s, TCGLabel *l, tcg_insn_unit *ptr)\n\n{\n\n    intptr_t value = (intptr_t)ptr;\n\n    TCGRelocation *r;\n\n\n\n    assert(!l->has_value);\n\n\n\n    for (r = l->u.first_reloc; r != NULL; r = r->next) {\n\n        patch_reloc(r->ptr, r->type, value, r->addend);\n\n    }\n\n\n\n    l->has_value = 1;\n\n    l->u.value_ptr = ptr;\n\n}\n", "idx": 2055, "_split": "valid", "_hash": "755adc47d4e3377fadc54c0bf009a41a"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "BlockDriverState *bdrv_lookup_bs(const char *device,\n\n                                 const char *node_name,\n\n                                 Error **errp)\n\n{\n\n    BlockBackend *blk;\n\n    BlockDriverState *bs;\n\n\n\n    if (device) {\n\n        blk = blk_by_name(device);\n\n\n\n        if (blk) {\n\n            return blk_bs(blk);\n\n        }\n\n    }\n\n\n\n    if (node_name) {\n\n        bs = bdrv_find_node(node_name);\n\n\n\n        if (bs) {\n\n            return bs;\n\n        }\n\n    }\n\n\n\n    error_setg(errp, \"Cannot find device=%s nor node_name=%s\",\n\n                     device ? device : \"\",\n\n                     node_name ? node_name : \"\");\n\n    return NULL;\n\n}\n", "idx": 2068, "_split": "valid", "_hash": "a123b0308be7d3ba739bc41c538c9179"}
{"project": "qemu", "commit_id": "4652b8f3e1ec91bb9d6f00e40df7f96d1f1aafee", "target": 1, "func": "static int qcow2_set_up_encryption(BlockDriverState *bs, const char *encryptfmt,\n\n                                   QemuOpts *opts, Error **errp)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    QCryptoBlockCreateOptions *cryptoopts = NULL;\n\n    QCryptoBlock *crypto = NULL;\n\n    int ret = -EINVAL;\n\n    QDict *options, *encryptopts;\n\n\n\n    options = qemu_opts_to_qdict(opts, NULL);\n\n    qdict_extract_subqdict(options, &encryptopts, \"encrypt.\");\n\n    QDECREF(options);\n\n\n\n    if (!g_str_equal(encryptfmt, \"aes\")) {\n\n        error_setg(errp, \"Unknown encryption format '%s', expected 'aes'\",\n\n                   encryptfmt);\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n    cryptoopts = block_crypto_create_opts_init(\n\n        Q_CRYPTO_BLOCK_FORMAT_QCOW, encryptopts, errp);\n\n    if (!cryptoopts) {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n    s->crypt_method_header = QCOW_CRYPT_AES;\n\n\n\n    crypto = qcrypto_block_create(cryptoopts,\n\n                                  NULL, NULL,\n\n                                  bs, errp);\n\n    if (!crypto) {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    ret = qcow2_update_header(bs);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not write encryption header\");\n\n        goto out;\n\n    }\n\n\n\n out:\n\n    QDECREF(encryptopts);\n\n    qcrypto_block_free(crypto);\n\n    qapi_free_QCryptoBlockCreateOptions(cryptoopts);\n\n    return ret;\n\n}\n", "idx": 2143, "_split": "valid", "_hash": "13d1283a94b0764d069ff429e2b0ae89"}
{"project": "qemu", "commit_id": "4c315c27661502a0813b129e41c0bf640c34a8d6", "target": 1, "func": "static void tilegx_cpu_class_init(ObjectClass *oc, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(oc);\n    CPUClass *cc = CPU_CLASS(oc);\n    TileGXCPUClass *tcc = TILEGX_CPU_CLASS(oc);\n    tcc->parent_realize = dc->realize;\n    dc->realize = tilegx_cpu_realizefn;\n    tcc->parent_reset = cc->reset;\n    cc->reset = tilegx_cpu_reset;\n    cc->has_work = tilegx_cpu_has_work;\n    cc->do_interrupt = tilegx_cpu_do_interrupt;\n    cc->cpu_exec_interrupt = tilegx_cpu_exec_interrupt;\n    cc->dump_state = tilegx_cpu_dump_state;\n    cc->set_pc = tilegx_cpu_set_pc;\n    cc->handle_mmu_fault = tilegx_cpu_handle_mmu_fault;\n    cc->gdb_num_core_regs = 0;\n}", "idx": 2147, "_split": "valid", "_hash": "f583fdca981defb3648c905fb4fedb2e"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void dma_complete(DMAAIOCB *dbs, int ret)\n\n{\n\n    trace_dma_complete(dbs, ret, dbs->common.cb);\n\n\n\n    dma_bdrv_unmap(dbs);\n\n    if (dbs->common.cb) {\n\n        dbs->common.cb(dbs->common.opaque, ret);\n\n    }\n\n    qemu_iovec_destroy(&dbs->iov);\n\n    if (dbs->bh) {\n\n        qemu_bh_delete(dbs->bh);\n\n        dbs->bh = NULL;\n\n    }\n\n    qemu_aio_unref(dbs);\n\n}\n", "idx": 2183, "_split": "valid", "_hash": "4101d9292af0729d172edc4794c3eda1"}
{"project": "qemu", "commit_id": "da4bc86c540991902e32e4e840c6ada573240254", "target": 1, "func": "static int proxy_mkdir(FsContext *fs_ctx, V9fsPath *dir_path,\n\n                       const char *name, FsCred *credp)\n\n{\n\n    int retval;\n\n    V9fsString fullname;\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n\n\n    retval = v9fs_request(fs_ctx->private, T_MKDIR, NULL, &fullname,\n\n                          credp->fc_mode, credp->fc_uid, credp->fc_gid);\n\n    v9fs_string_free(&fullname);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n        retval = -1;\n\n    }\n\n    v9fs_string_free(&fullname);\n\n    return retval;\n\n}\n", "idx": 2209, "_split": "valid", "_hash": "73a58313c7a9972f81a31d98f6ec04c8"}
{"project": "qemu", "commit_id": "ef4760626e88bc3e7a1b46c7370378cbd12d379f", "target": 1, "func": "static uint32_t eepro100_read4(EEPRO100State * s, uint32_t addr)\n\n{\n\n    uint32_t val;\n\n    if (addr <= sizeof(s->mem) - sizeof(val)) {\n\n        memcpy(&val, &s->mem[addr], sizeof(val));\n\n    }\n\n\n\n    switch (addr) {\n\n    case SCBStatus:\n\n        TRACE(OTHER, logout(\"addr=%s val=0x%08x\\n\", regname(addr), val));\n\n        break;\n\n    case SCBPointer:\n\n#if 0\n\n        val = eepro100_read_pointer(s);\n\n#endif\n\n        TRACE(OTHER, logout(\"addr=%s val=0x%08x\\n\", regname(addr), val));\n\n        break;\n\n    case SCBPort:\n\n        val = eepro100_read_port(s);\n\n        TRACE(OTHER, logout(\"addr=%s val=0x%08x\\n\", regname(addr), val));\n\n        break;\n\n    case SCBCtrlMDI:\n\n        val = eepro100_read_mdi(s);\n\n        break;\n\n    default:\n\n        logout(\"addr=%s val=0x%08x\\n\", regname(addr), val);\n\n        missing(\"unknown longword read\");\n\n    }\n\n    return val;\n\n}\n", "idx": 2253, "_split": "valid", "_hash": "7cbaf52a29f065e4255c8c5c85fd7b74"}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "static abi_long do_setsockopt(int sockfd, int level, int optname,\n\n                              abi_ulong optval_addr, socklen_t optlen)\n\n{\n\n    abi_long ret;\n\n    int val;\n\n    struct ip_mreqn *ip_mreq;\n\n    struct ip_mreq_source *ip_mreq_source;\n\n\n\n    switch(level) {\n\n    case SOL_TCP:\n\n        /* TCP options all take an 'int' value.  */\n\n        if (optlen < sizeof(uint32_t))\n\n            return -TARGET_EINVAL;\n\n\n\n        if (get_user_u32(val, optval_addr))\n\n            return -TARGET_EFAULT;\n\n        ret = get_errno(setsockopt(sockfd, level, optname, &val, sizeof(val)));\n\n        break;\n\n    case SOL_IP:\n\n        switch(optname) {\n\n        case IP_TOS:\n\n        case IP_TTL:\n\n        case IP_HDRINCL:\n\n        case IP_ROUTER_ALERT:\n\n        case IP_RECVOPTS:\n\n        case IP_RETOPTS:\n\n        case IP_PKTINFO:\n\n        case IP_MTU_DISCOVER:\n\n        case IP_RECVERR:\n\n        case IP_RECVTOS:\n\n#ifdef IP_FREEBIND\n\n        case IP_FREEBIND:\n\n#endif\n\n        case IP_MULTICAST_TTL:\n\n        case IP_MULTICAST_LOOP:\n\n            val = 0;\n\n            if (optlen >= sizeof(uint32_t)) {\n\n                if (get_user_u32(val, optval_addr))\n\n                    return -TARGET_EFAULT;\n\n            } else if (optlen >= 1) {\n\n                if (get_user_u8(val, optval_addr))\n\n                    return -TARGET_EFAULT;\n\n            }\n\n            ret = get_errno(setsockopt(sockfd, level, optname, &val, sizeof(val)));\n\n            break;\n\n        case IP_ADD_MEMBERSHIP:\n\n        case IP_DROP_MEMBERSHIP:\n\n            if (optlen < sizeof (struct target_ip_mreq) ||\n\n                optlen > sizeof (struct target_ip_mreqn))\n\n                return -TARGET_EINVAL;\n\n\n\n            ip_mreq = (struct ip_mreqn *) alloca(optlen);\n\n            target_to_host_ip_mreq(ip_mreq, optval_addr, optlen);\n\n            ret = get_errno(setsockopt(sockfd, level, optname, ip_mreq, optlen));\n\n            break;\n\n\n\n        case IP_BLOCK_SOURCE:\n\n        case IP_UNBLOCK_SOURCE:\n\n        case IP_ADD_SOURCE_MEMBERSHIP:\n\n        case IP_DROP_SOURCE_MEMBERSHIP:\n\n            if (optlen != sizeof (struct target_ip_mreq_source))\n\n                return -TARGET_EINVAL;\n\n\n\n            ip_mreq_source = lock_user(VERIFY_READ, optval_addr, optlen, 1);\n\n            ret = get_errno(setsockopt(sockfd, level, optname, ip_mreq_source, optlen));\n\n            unlock_user (ip_mreq_source, optval_addr, 0);\n\n            break;\n\n\n\n        default:\n\n            goto unimplemented;\n\n        }\n\n        break;\n\n    case TARGET_SOL_SOCKET:\n\n        switch (optname) {\n\n            /* Options with 'int' argument.  */\n\n        case TARGET_SO_DEBUG:\n\n\t\toptname = SO_DEBUG;\n\n\t\tbreak;\n\n        case TARGET_SO_REUSEADDR:\n\n\t\toptname = SO_REUSEADDR;\n\n\t\tbreak;\n\n        case TARGET_SO_TYPE:\n\n\t\toptname = SO_TYPE;\n\n\t\tbreak;\n\n        case TARGET_SO_ERROR:\n\n\t\toptname = SO_ERROR;\n\n\t\tbreak;\n\n        case TARGET_SO_DONTROUTE:\n\n\t\toptname = SO_DONTROUTE;\n\n\t\tbreak;\n\n        case TARGET_SO_BROADCAST:\n\n\t\toptname = SO_BROADCAST;\n\n\t\tbreak;\n\n        case TARGET_SO_SNDBUF:\n\n\t\toptname = SO_SNDBUF;\n\n\t\tbreak;\n\n        case TARGET_SO_RCVBUF:\n\n\t\toptname = SO_RCVBUF;\n\n\t\tbreak;\n\n        case TARGET_SO_KEEPALIVE:\n\n\t\toptname = SO_KEEPALIVE;\n\n\t\tbreak;\n\n        case TARGET_SO_OOBINLINE:\n\n\t\toptname = SO_OOBINLINE;\n\n\t\tbreak;\n\n        case TARGET_SO_NO_CHECK:\n\n\t\toptname = SO_NO_CHECK;\n\n\t\tbreak;\n\n        case TARGET_SO_PRIORITY:\n\n\t\toptname = SO_PRIORITY;\n\n\t\tbreak;\n\n#ifdef SO_BSDCOMPAT\n\n        case TARGET_SO_BSDCOMPAT:\n\n\t\toptname = SO_BSDCOMPAT;\n\n\t\tbreak;\n\n#endif\n\n        case TARGET_SO_PASSCRED:\n\n\t\toptname = SO_PASSCRED;\n\n\t\tbreak;\n\n        case TARGET_SO_TIMESTAMP:\n\n\t\toptname = SO_TIMESTAMP;\n\n\t\tbreak;\n\n        case TARGET_SO_RCVLOWAT:\n\n\t\toptname = SO_RCVLOWAT;\n\n\t\tbreak;\n\n        case TARGET_SO_RCVTIMEO:\n\n\t\toptname = SO_RCVTIMEO;\n\n\t\tbreak;\n\n        case TARGET_SO_SNDTIMEO:\n\n\t\toptname = SO_SNDTIMEO;\n\n\t\tbreak;\n\n            break;\n\n        default:\n\n            goto unimplemented;\n\n        }\n\n\tif (optlen < sizeof(uint32_t))\n\n            return -TARGET_EINVAL;\n\n\n\n\tif (get_user_u32(val, optval_addr))\n\n            return -TARGET_EFAULT;\n\n\tret = get_errno(setsockopt(sockfd, SOL_SOCKET, optname, &val, sizeof(val)));\n\n        break;\n\n    default:\n\n    unimplemented:\n\n        gemu_log(\"Unsupported setsockopt level=%d optname=%d \\n\", level, optname);\n\n        ret = -TARGET_ENOPROTOOPT;\n\n    }\n\n    return ret;\n\n}\n", "idx": 2285, "_split": "valid", "_hash": "2713e5d37cfabf14d2682d15d7028ef7"}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "void vty_putchars(VIOsPAPRDevice *sdev, uint8_t *buf, int len)\n\n{\n\n    VIOsPAPRVTYDevice *dev = VIO_SPAPR_VTY_DEVICE(sdev);\n\n\n\n    /* FIXME: should check the qemu_chr_fe_write() return value */\n\n    qemu_chr_fe_write(dev->chardev, buf, len);\n\n}\n", "idx": 2326, "_split": "valid", "_hash": "4c031dc70563505b1343eeccabdf345c"}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int cris_addc_m(int a, const int *b)\n\n{\n\n\tasm volatile (\"addc [%1], %0\\n\" : \"+r\" (a) : \"r\" (b));\n\n\treturn a;\n\n}\n", "idx": 2330, "_split": "valid", "_hash": "f2628b5e68356c69ca2882a19d493a47"}
{"project": "qemu", "commit_id": "bd69fe8448024258d046e2a15d4cf5c498188144", "target": 1, "func": "QEMUOptionParameter *append_option_parameters(QEMUOptionParameter *dest,\n\n    QEMUOptionParameter *list)\n\n{\n\n    size_t num_options, num_dest_options;\n\n\n\n    num_options = count_option_parameters(dest);\n\n    num_dest_options = num_options;\n\n\n\n    num_options += count_option_parameters(list);\n\n\n\n    dest = qemu_realloc(dest, (num_options + 1) * sizeof(QEMUOptionParameter));\n\n\n\n\n    while (list && list->name) {\n\n        if (get_option_parameter(dest, list->name) == NULL) {\n\n            dest[num_dest_options++] = *list;\n\n\n        }\n\n        list++;\n\n    }\n\n\n\n    return dest;\n\n}", "idx": 2350, "_split": "valid", "_hash": "c6a02262147ff11785e3858749e8eace"}
{"project": "qemu", "commit_id": "525989a50a70ea0ffa2b1cdf56279765bb2b7de0", "target": 1, "func": "void stream_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, const char *backing_file_str,\n\n                  int64_t speed, BlockdevOnError on_error, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n    BlockDriverState *iter;\n\n    int orig_bs_flags;\n\n\n\n    /* Make sure that the image is opened in read-write mode */\n\n    orig_bs_flags = bdrv_get_flags(bs);\n\n    if (!(orig_bs_flags & BDRV_O_RDWR)) {\n\n        if (bdrv_reopen(bs, orig_bs_flags | BDRV_O_RDWR, errp) != 0) {\n\n            return;\n\n        }\n\n    }\n\n\n\n    /* Prevent concurrent jobs trying to modify the graph structure here, we\n\n     * already have our own plans. Also don't allow resize as the image size is\n\n     * queried only at the job start and then cached. */\n\n    s = block_job_create(job_id, &stream_job_driver, bs,\n\n                         BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE_UNCHANGED |\n\n                         BLK_PERM_GRAPH_MOD,\n\n                         BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE_UNCHANGED |\n\n                         BLK_PERM_WRITE,\n\n                         speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp);\n\n    if (!s) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Block all intermediate nodes between bs and base, because they will\n\n     * disappear from the chain after this operation. The streaming job reads\n\n     * every block only once, assuming that it doesn't change, so block writes\n\n     * and resizes. */\n\n    for (iter = backing_bs(bs); iter && iter != base; iter = backing_bs(iter)) {\n\n        block_job_add_bdrv(&s->common, \"intermediate node\", iter, 0,\n\n                           BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE_UNCHANGED,\n\n                           &error_abort);\n\n    }\n\n\n\n    s->base = base;\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n    s->bs_flags = orig_bs_flags;\n\n\n\n    s->on_error = on_error;\n\n    trace_stream_start(bs, base, s);\n\n    block_job_start(&s->common);\n\n    return;\n\n\n\nfail:\n\n    if (orig_bs_flags != bdrv_get_flags(bs)) {\n\n        bdrv_reopen(bs, s->bs_flags, NULL);\n\n    }\n\n}\n", "idx": 2352, "_split": "valid", "_hash": "81e10eaccf734ac1de3ef2f399af2d71"}
{"project": "qemu", "commit_id": "ea15fb067212bb79291f9b76c5c76d45b62f58e1", "target": 1, "func": "static void tcg_target_qemu_prologue(TCGContext *s)\n\n{\n\n    int i, frame_size;\n\n\n\n    /* reserve some stack space */\n\n    frame_size = ARRAY_SIZE(tcg_target_callee_save_regs) * 4\n\n                 + TCG_STATIC_CALL_ARGS_SIZE;\n\n    frame_size = (frame_size + TCG_TARGET_STACK_ALIGN - 1) &\n\n                 ~(TCG_TARGET_STACK_ALIGN - 1);\n\n\n\n    /* TB prologue */\n\n    tcg_out_addi(s, TCG_REG_SP, -frame_size);\n\n    for(i = 0 ; i < ARRAY_SIZE(tcg_target_callee_save_regs) ; i++) {\n\n        tcg_out_st(s, TCG_TYPE_I32, tcg_target_callee_save_regs[i],\n\n                   TCG_REG_SP, TCG_STATIC_CALL_ARGS_SIZE + i * 4);\n\n    }\n\n\n\n    /* Call generated code */\n\n    tcg_out_opc_reg(s, OPC_JR, 0, tcg_target_call_iarg_regs[1]), 0);\n\n    tcg_out_mov(s, TCG_TYPE_PTR, TCG_AREG0, tcg_target_call_iarg_regs[0]);\n\n    tb_ret_addr = s->code_ptr;\n\n\n\n    /* TB epilogue */\n\n    for(i = 0 ; i < ARRAY_SIZE(tcg_target_callee_save_regs) ; i++) {\n\n        tcg_out_ld(s, TCG_TYPE_I32, tcg_target_callee_save_regs[i],\n\n                   TCG_REG_SP, TCG_STATIC_CALL_ARGS_SIZE + i * 4);\n\n    }\n\n\n\n    tcg_out_opc_reg(s, OPC_JR, 0, TCG_REG_RA, 0);\n\n    tcg_out_addi(s, TCG_REG_SP, frame_size);\n\n}\n", "idx": 2367, "_split": "valid", "_hash": "df432fcd6ebca990990e4cc9e630d1cc"}
{"project": "qemu", "commit_id": "4020db0475b3e527b3bdc97dff873c2be9da2698", "target": 1, "func": "static void virtio_scsi_vring_teardown(VirtIOSCSI *s)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);\n\n    int i;\n\n\n\n    if (s->ctrl_vring) {\n\n        vring_teardown(&s->ctrl_vring->vring, vdev, 0);\n\n\n\n    }\n\n    if (s->event_vring) {\n\n        vring_teardown(&s->event_vring->vring, vdev, 1);\n\n\n\n    }\n\n    if (s->cmd_vrings) {\n\n        for (i = 0; i < vs->conf.num_queues && s->cmd_vrings[i]; i++) {\n\n            vring_teardown(&s->cmd_vrings[i]->vring, vdev, 2 + i);\n\n\n\n        }\n\n        free(s->cmd_vrings);\n\n        s->cmd_vrings = NULL;\n\n    }\n\n}", "idx": 2376, "_split": "valid", "_hash": "f75e7745190eb8155571721a0ca80df1"}
{"project": "qemu", "commit_id": "e5b8b0d4ba29fe1268ba049519a1b0cf8552a21a", "target": 0, "func": "set_rdt(E1000State *s, int index, uint32_t val)\n\n{\n\n    s->check_rxov = 0;\n\n    s->mac_reg[index] = val & 0xffff;\n\n    if (e1000_has_rxbufs(s, 1)) {\n\n        qemu_flush_queued_packets(&s->nic->nc);\n\n    }\n\n}\n", "idx": 2483, "_split": "valid", "_hash": "2b635a2fa73d89f0a54782e2918f5cb4"}
{"project": "qemu", "commit_id": "c9e659c9ee75d33ff11a8573cea738ad26bb6f86", "target": 1, "func": "unsigned int s390_cpu_set_state(uint8_t cpu_state, S390CPU *cpu)\n\n {\n\n    trace_cpu_set_state(CPU(cpu)->cpu_index, cpu_state);\n\n\n\n    switch (cpu_state) {\n\n    case CPU_STATE_STOPPED:\n\n    case CPU_STATE_CHECK_STOP:\n\n        /* halt the cpu for common infrastructure */\n\n        s390_cpu_halt(cpu);\n\n        break;\n\n    case CPU_STATE_OPERATING:\n\n    case CPU_STATE_LOAD:\n\n        /* unhalt the cpu for common infrastructure */\n\n        s390_cpu_unhalt(cpu);\n\n        break;\n\n    default:\n\n        error_report(\"Requested CPU state is not a valid S390 CPU state: %u\",\n\n                     cpu_state);\n\n        exit(1);\n\n\n\n\n\n    cpu->env.cpu_state = cpu_state;\n\n\n\n    return s390_count_running_cpus();\n", "idx": 2493, "_split": "valid", "_hash": "2eea1c485375bcdf45c5efdda1923384"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void e1000_io_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t val, unsigned size)\n\n{\n\n    E1000State *s = opaque;\n\n\n\n    (void)s;\n\n}\n", "idx": 2507, "_split": "valid", "_hash": "656bafe9663aacda07de8e9462dbd1cb"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_clkm_init(MemoryRegion *memory, target_phys_addr_t mpu_base,\n\n                target_phys_addr_t dsp_base, struct omap_mpu_state_s *s)\n\n{\n\n    memory_region_init_io(&s->clkm_iomem, &omap_clkm_ops, s,\n\n                          \"omap-clkm\", 0x100);\n\n    memory_region_init_io(&s->clkdsp_iomem, &omap_clkdsp_ops, s,\n\n                          \"omap-clkdsp\", 0x1000);\n\n\n\n    s->clkm.arm_idlect1 = 0x03ff;\n\n    s->clkm.arm_idlect2 = 0x0100;\n\n    s->clkm.dsp_idlect1 = 0x0002;\n\n    omap_clkm_reset(s);\n\n    s->clkm.cold_start = 0x3a;\n\n\n\n    memory_region_add_subregion(memory, mpu_base, &s->clkm_iomem);\n\n    memory_region_add_subregion(memory, dsp_base, &s->clkdsp_iomem);\n\n}\n", "idx": 2508, "_split": "valid", "_hash": "2050ceb19278bbd2528f6617d49a7040"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t bonito_pciconf_readl(void *opaque, target_phys_addr_t addr,\n\n                                     unsigned size)\n\n{\n\n\n\n    PCIBonitoState *s = opaque;\n\n    PCIDevice *d = PCI_DEVICE(s);\n\n\n\n    DPRINTF(\"bonito_pciconf_readl \"TARGET_FMT_plx\"\\n\", addr);\n\n    return d->config_read(d, addr, 4);\n\n}\n", "idx": 2521, "_split": "valid", "_hash": "0adf9f24622ecd0173ba48ca5c616235"}
{"project": "qemu", "commit_id": "17cce735780f0ff6a2ef173c34614bd47acd56e5", "target": 1, "func": "static void vdi_close(BlockDriverState *bs)\n\n{\n\n    BDRVVdiState *s = bs->opaque;\n\n\n\n    g_free(s->bmap);\n\n\n\n    migrate_del_blocker(s->migration_blocker);\n\n    error_free(s->migration_blocker);\n\n}\n", "idx": 2529, "_split": "valid", "_hash": "e05a7f49147c0ff7c86527cf3a1bb6f8"}
{"project": "qemu", "commit_id": "74b4c74d5efb0a489bdf0acc5b5d0197167e7649", "target": 0, "func": "static int handle_instruction(S390CPU *cpu, struct kvm_run *run)\n\n{\n\n    unsigned int ipa0 = (run->s390_sieic.ipa & 0xff00);\n\n    uint8_t ipa1 = run->s390_sieic.ipa & 0x00ff;\n\n    int r = -1;\n\n\n\n    DPRINTF(\"handle_instruction 0x%x 0x%x\\n\",\n\n            run->s390_sieic.ipa, run->s390_sieic.ipb);\n\n    switch (ipa0) {\n\n    case IPA0_B2:\n\n        r = handle_b2(cpu, run, ipa1);\n\n        break;\n\n    case IPA0_B9:\n\n        r = handle_b9(cpu, run, ipa1);\n\n        break;\n\n    case IPA0_EB:\n\n        r = handle_eb(cpu, run, run->s390_sieic.ipb & 0xff);\n\n        break;\n\n    case IPA0_E3:\n\n        r = handle_e3(cpu, run, run->s390_sieic.ipb & 0xff);\n\n        break;\n\n    case IPA0_DIAG:\n\n        r = handle_diag(cpu, run, run->s390_sieic.ipb);\n\n        break;\n\n    case IPA0_SIGP:\n\n        r = handle_sigp(cpu, ipa1, run->s390_sieic.ipb);\n\n        break;\n\n    }\n\n\n\n    if (r < 0) {\n\n        r = 0;\n\n        kvm_s390_program_interrupt(cpu, PGM_OPERATION);\n\n    }\n\n\n\n    return r;\n\n}\n", "idx": 2548, "_split": "valid", "_hash": "f012986baee4acc917589edf0c983469"}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_fstat(FsContext *fs_ctx, int fid_type,\n\n                            V9fsFidOpenState *fs, struct stat *stbuf)\n\n{\n\n    V9fsSynthOpenState *synth_open = fs->private;\n\n    v9fs_synth_fill_statbuf(synth_open->node, stbuf);\n\n    return 0;\n\n}\n", "idx": 2559, "_split": "valid", "_hash": "e0e9b7fedb99d0c1b3bb33c1df481ff8"}
{"project": "qemu", "commit_id": "8172539d21a03e982aa7f139ddc1607dc1422045", "target": 0, "func": "static uint32_t virtio_balloon_get_features(VirtIODevice *vdev)\n\n{\n\n    return 0;\n\n}\n", "idx": 2560, "_split": "valid", "_hash": "bd2581c50bef64d33392e820c4144b0c"}
{"project": "qemu", "commit_id": "4fc9af53d88c0a2a810704a06cb39a7182982e4e", "target": 0, "func": "BlockDriverAIOCB *bdrv_aio_write(BlockDriverState *bs, int64_t sector_num,\n\n                                 const uint8_t *buf, int nb_sectors,\n\n                                 BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    BlockDriverAIOCB *ret;\n\n\n\n    if (!drv)\n\n        return NULL;\n\n    if (bs->read_only)\n\n        return NULL;\n\n    if (sector_num == 0 && bs->boot_sector_enabled && nb_sectors > 0) {\n\n        memcpy(bs->boot_sector_data, buf, 512);\n\n    }\n\n\n\n    ret = drv->bdrv_aio_write(bs, sector_num, buf, nb_sectors, cb, opaque);\n\n\n\n    if (ret) {\n\n\t/* Update stats even though technically transfer has not happened. */\n\n\tbs->wr_bytes += (unsigned) nb_sectors * SECTOR_SIZE;\n\n\tbs->wr_ops ++;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 2561, "_split": "valid", "_hash": "6fb171ddea142d0fc5fd19869a163461"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t icp_pic_read(void *opaque, target_phys_addr_t offset,\n\n                             unsigned size)\n\n{\n\n    icp_pic_state *s = (icp_pic_state *)opaque;\n\n\n\n    switch (offset >> 2) {\n\n    case 0: /* IRQ_STATUS */\n\n        return s->level & s->irq_enabled;\n\n    case 1: /* IRQ_RAWSTAT */\n\n        return s->level;\n\n    case 2: /* IRQ_ENABLESET */\n\n        return s->irq_enabled;\n\n    case 4: /* INT_SOFTSET */\n\n        return s->level & 1;\n\n    case 8: /* FRQ_STATUS */\n\n        return s->level & s->fiq_enabled;\n\n    case 9: /* FRQ_RAWSTAT */\n\n        return s->level;\n\n    case 10: /* FRQ_ENABLESET */\n\n        return s->fiq_enabled;\n\n    case 3: /* IRQ_ENABLECLR */\n\n    case 5: /* INT_SOFTCLR */\n\n    case 11: /* FRQ_ENABLECLR */\n\n    default:\n\n        printf (\"icp_pic_read: Bad register offset 0x%x\\n\", (int)offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 2582, "_split": "valid", "_hash": "56bb06af9d17235fb69f6745ff5d467a"}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static int vmsvga_post_load(void *opaque, int version_id)\n\n{\n\n    struct vmsvga_state_s *s = opaque;\n\n\n\n    s->invalidated = 1;\n\n    if (s->config)\n\n        s->fifo = (uint32_t *) s->fifo_ptr;\n\n\n\n    return 0;\n\n}\n", "idx": 2584, "_split": "valid", "_hash": "8c3c94a8adf70a2f66ed895a9dc8caeb"}
{"project": "qemu", "commit_id": "8d2f850a5ab7579a852f23b28273940a47dfd7ff", "target": 0, "func": "static inline void check_alignment(CPUS390XState *env, uint64_t v,\n\n                                   int wordsize, uintptr_t ra)\n\n{\n\n    if (v % wordsize) {\n\n        CPUState *cs = CPU(s390_env_get_cpu(env));\n\n        cpu_restore_state(cs, ra);\n\n        program_interrupt(env, PGM_SPECIFICATION, 6);\n\n    }\n\n}\n", "idx": 2596, "_split": "valid", "_hash": "2bcde2215a8049aa38bb0bd9220ad024"}
{"project": "qemu", "commit_id": "40f08e87f613273f9dcc8df7d6a0f574b7d28d05", "target": 1, "func": "static int mm_start_timer(struct qemu_alarm_timer *t)\n\n{\n\n    TIMECAPS tc;\n\n\n\n    memset(&tc, 0, sizeof(tc));\n\n    timeGetDevCaps(&tc, sizeof(tc));\n\n\n\n    mm_period = tc.wPeriodMin;\n\n    timeBeginPeriod(mm_period);\n\n\n\n    mm_timer = timeSetEvent(1,                  /* interval (ms) */\n\n                            mm_period,          /* resolution */\n\n                            mm_alarm_handler,   /* function */\n\n                            (DWORD_PTR)t,       /* parameter */\n\n                            TIME_ONESHOT | TIME_CALLBACK_FUNCTION);\n\n\n\n    if (!mm_timer) {\n\n        fprintf(stderr, \"Failed to initialize win32 alarm timer: %ld\\n\",\n\n                GetLastError());\n\n        timeEndPeriod(mm_period);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2651, "_split": "valid", "_hash": "b7a112eb3e33738a1a2de910a41512ea"}
{"project": "qemu", "commit_id": "b18f1141d0afa00de11a8e079f4f5305c9e36893", "target": 1, "func": "static void test_validate_fail_union_native_list(TestInputVisitorData *data,\n\n                                                 const void *unused)\n\n{\n\n    UserDefNativeListUnion *tmp = NULL;\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data,\n\n                           \"{ 'type': 'integer', 'data' : [ 'string' ] }\");\n\n\n\n    visit_type_UserDefNativeListUnion(v, &tmp, NULL, &err);\n\n    g_assert(err);\n\n\n    qapi_free_UserDefNativeListUnion(tmp);\n\n}", "idx": 2669, "_split": "valid", "_hash": "e0eede3f90f2726e2602d2566d708772"}
{"project": "qemu", "commit_id": "8a8f5840082eb65d140ccfe7b128c92390cce1c3", "target": 1, "func": "static CURLState *curl_init_state(BDRVCURLState *s)\n\n{\n\n    CURLState *state = NULL;\n\n    int i, j;\n\n\n\n    do {\n\n        for (i=0; i<CURL_NUM_STATES; i++) {\n\n            for (j=0; j<CURL_NUM_ACB; j++)\n\n                if (s->states[i].acb[j])\n\n                    continue;\n\n            if (s->states[i].in_use)\n\n                continue;\n\n\n\n            state = &s->states[i];\n\n            state->in_use = 1;\n\n            break;\n\n        }\n\n        if (!state) {\n\n            g_usleep(100);\n\n            curl_multi_do(s);\n\n        }\n\n    } while(!state);\n\n\n\n    if (state->curl)\n\n        goto has_curl;\n\n\n\n    state->curl = curl_easy_init();\n\n    if (!state->curl)\n\n        return NULL;\n\n    curl_easy_setopt(state->curl, CURLOPT_URL, s->url);\n\n    curl_easy_setopt(state->curl, CURLOPT_TIMEOUT, 5);\n\n    curl_easy_setopt(state->curl, CURLOPT_WRITEFUNCTION, (void *)curl_read_cb);\n\n    curl_easy_setopt(state->curl, CURLOPT_WRITEDATA, (void *)state);\n\n    curl_easy_setopt(state->curl, CURLOPT_PRIVATE, (void *)state);\n\n    curl_easy_setopt(state->curl, CURLOPT_AUTOREFERER, 1);\n\n    curl_easy_setopt(state->curl, CURLOPT_FOLLOWLOCATION, 1);\n\n    curl_easy_setopt(state->curl, CURLOPT_NOSIGNAL, 1);\n\n    curl_easy_setopt(state->curl, CURLOPT_ERRORBUFFER, state->errmsg);\n\n    curl_easy_setopt(state->curl, CURLOPT_FAILONERROR, 1);\n\n\n\n    /* Restrict supported protocols to avoid security issues in the more\n\n     * obscure protocols.  For example, do not allow POP3/SMTP/IMAP see\n\n     * CVE-2013-0249.\n\n\n\n     */\n\n\n    curl_easy_setopt(state->curl, CURLOPT_PROTOCOLS, PROTOCOLS);\n\n    curl_easy_setopt(state->curl, CURLOPT_REDIR_PROTOCOLS, PROTOCOLS);\n\n\n\n\n#ifdef DEBUG_VERBOSE\n\n    curl_easy_setopt(state->curl, CURLOPT_VERBOSE, 1);\n\n\n\n\nhas_curl:\n\n\n\n    state->s = s;\n\n\n\n    return state;\n\n}", "idx": 2685, "_split": "valid", "_hash": "92f59d7284c7e55858583cb1f7d2ebe3"}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static int send_mono_rect(VncState *vs, int w, int h, uint32_t bg, uint32_t fg)\n\n{\n\n    size_t bytes;\n\n    int stream = 1;\n\n    int level = tight_conf[vs->tight_compression].mono_zlib_level;\n\n\n\n    bytes = ((w + 7) / 8) * h;\n\n\n\n    vnc_write_u8(vs, (stream | VNC_TIGHT_EXPLICIT_FILTER) << 4);\n\n    vnc_write_u8(vs, VNC_TIGHT_FILTER_PALETTE);\n\n    vnc_write_u8(vs, 1);\n\n\n\n    switch(vs->clientds.pf.bytes_per_pixel) {\n\n    case 4:\n\n    {\n\n        uint32_t buf[2] = {bg, fg};\n\n        size_t ret = sizeof (buf);\n\n\n\n        if (vs->tight_pixel24) {\n\n            tight_pack24(vs, (unsigned char*)buf, 2, &ret);\n\n        }\n\n        vnc_write(vs, buf, ret);\n\n\n\n        tight_encode_mono_rect32(vs->tight.buffer, w, h, bg, fg);\n\n        break;\n\n    }\n\n    case 2:\n\n        vnc_write(vs, &bg, 2);\n\n        vnc_write(vs, &fg, 2);\n\n        tight_encode_mono_rect16(vs->tight.buffer, w, h, bg, fg);\n\n        break;\n\n    default:\n\n        vnc_write_u8(vs, bg);\n\n        vnc_write_u8(vs, fg);\n\n        tight_encode_mono_rect8(vs->tight.buffer, w, h, bg, fg);\n\n        break;\n\n    }\n\n    vs->tight.offset = bytes;\n\n\n\n    bytes = tight_compress_data(vs, stream, bytes, level, Z_DEFAULT_STRATEGY);\n\n    return (bytes >= 0);\n\n}\n", "idx": 2713, "_split": "valid", "_hash": "b0136ed6d90c612d82501212507d883d"}
{"project": "qemu", "commit_id": "2c62f08ddbf3fa80dc7202eb9a2ea60ae44e2cc5", "target": 0, "func": "void qmp_screendump(const char *filename, Error **errp)\n\n{\n\n    QemuConsole *previous_active_console;\n\n    bool cswitch;\n\n\n\n    previous_active_console = active_console;\n\n    cswitch = previous_active_console && previous_active_console->index != 0;\n\n\n\n    /* There is currently no way of specifying which screen we want to dump,\n\n       so always dump the first one.  */\n\n    if (cswitch) {\n\n        console_select(0);\n\n    }\n\n    if (consoles[0] && consoles[0]->hw_screen_dump) {\n\n        consoles[0]->hw_screen_dump(consoles[0]->hw, filename, cswitch, errp);\n\n    } else {\n\n        error_setg(errp, \"device doesn't support screendump\");\n\n    }\n\n\n\n    if (cswitch) {\n\n        console_select(previous_active_console->index);\n\n    }\n\n}\n", "idx": 2763, "_split": "valid", "_hash": "ad192a0ae07ee63495677c01e67affa1"}
{"project": "qemu", "commit_id": "f0ddf11b23260f0af84fb529486a8f9ba2d19401", "target": 0, "func": "DISAS_INSN(cas2l)\n\n{\n\n    uint16_t ext1, ext2;\n\n    TCGv addr1, addr2, regs;\n\n\n\n    /* cas2 Dc1:Dc2,Du1:Du2,(Rn1):(Rn2) */\n\n\n\n    ext1 = read_im16(env, s);\n\n\n\n    if (ext1 & 0x8000) {\n\n        /* Address Register */\n\n        addr1 = AREG(ext1, 12);\n\n    } else {\n\n        /* Data Register */\n\n        addr1 = DREG(ext1, 12);\n\n    }\n\n\n\n    ext2 = read_im16(env, s);\n\n    if (ext2 & 0x8000) {\n\n        /* Address Register */\n\n        addr2 = AREG(ext2, 12);\n\n    } else {\n\n        /* Data Register */\n\n        addr2 = DREG(ext2, 12);\n\n    }\n\n\n\n    /* if (R1) == Dc1 && (R2) == Dc2 then\n\n     *     (R1) = Du1\n\n     *     (R2) = Du2\n\n     * else\n\n     *     Dc1 = (R1)\n\n     *     Dc2 = (R2)\n\n     */\n\n\n\n    regs = tcg_const_i32(REG(ext2, 6) |\n\n                         (REG(ext1, 6) << 3) |\n\n                         (REG(ext2, 0) << 6) |\n\n                         (REG(ext1, 0) << 9));\n\n    gen_helper_cas2l(cpu_env, regs, addr1, addr2);\n\n    tcg_temp_free(regs);\n\n\n\n    /* Note that cas2l also assigned to env->cc_op.  */\n\n    s->cc_op = CC_OP_CMPL;\n\n    s->cc_op_synced = 1;\n\n}\n", "idx": 2795, "_split": "valid", "_hash": "bddae8b375d1bb2c83cdd3063f873912"}
{"project": "qemu", "commit_id": "026aeffcb4752054830ba203020ed6eb05bcaba8", "target": 0, "func": "static void cirrus_bitblt_rop_nop(CirrusVGAState *s,\n\n                                  uint8_t *dst,const uint8_t *src,\n\n                                  int dstpitch,int srcpitch,\n\n                                  int bltwidth,int bltheight)\n\n{\n\n}\n", "idx": 2797, "_split": "valid", "_hash": "5cd4292e9dc7ebcd1b84d06da41ae244"}
{"project": "qemu", "commit_id": "03f4995781a64e106e6f73864a1e9c4163dac53b", "target": 0, "func": "static void page_flush_tb(void)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < V_L1_SIZE; i++) {\n\n        page_flush_tb_1(V_L1_SHIFT / L2_BITS - 1, l1_map + i);\n\n    }\n\n}\n", "idx": 2800, "_split": "valid", "_hash": "c2d4a18bd928091f2312c58ab5e5877e"}
{"project": "qemu", "commit_id": "1f00b27f17518a1bcb4cedca49eaec96a4d560bd", "target": 0, "func": "static void tcg_out_tlb_read(TCGContext *s, TCGReg addr_reg, TCGMemOp opc,\n\n                             tcg_insn_unit **label_ptr, int mem_index,\n\n                             bool is_read)\n\n{\n\n    int tlb_offset = is_read ?\n\n        offsetof(CPUArchState, tlb_table[mem_index][0].addr_read)\n\n        : offsetof(CPUArchState, tlb_table[mem_index][0].addr_write);\n\n    int s_mask = (1 << (opc & MO_SIZE)) - 1;\n\n    TCGReg base = TCG_AREG0, x3;\n\n    uint64_t tlb_mask;\n\n\n\n    /* For aligned accesses, we check the first byte and include the alignment\n\n       bits within the address.  For unaligned access, we check that we don't\n\n       cross pages using the address of the last byte of the access.  */\n\n    if ((opc & MO_AMASK) == MO_ALIGN || s_mask == 0) {\n\n        tlb_mask = TARGET_PAGE_MASK | s_mask;\n\n        x3 = addr_reg;\n\n    } else {\n\n        tcg_out_insn(s, 3401, ADDI, TARGET_LONG_BITS == 64,\n\n                     TCG_REG_X3, addr_reg, s_mask);\n\n        tlb_mask = TARGET_PAGE_MASK;\n\n        x3 = TCG_REG_X3;\n\n    }\n\n\n\n    /* Extract the TLB index from the address into X0.\n\n       X0<CPU_TLB_BITS:0> =\n\n       addr_reg<TARGET_PAGE_BITS+CPU_TLB_BITS:TARGET_PAGE_BITS> */\n\n    tcg_out_ubfm(s, TARGET_LONG_BITS == 64, TCG_REG_X0, addr_reg,\n\n                 TARGET_PAGE_BITS, TARGET_PAGE_BITS + CPU_TLB_BITS);\n\n\n\n    /* Store the page mask part of the address into X3.  */\n\n    tcg_out_logicali(s, I3404_ANDI, TARGET_LONG_BITS == 64,\n\n                     TCG_REG_X3, x3, tlb_mask);\n\n\n\n    /* Add any \"high bits\" from the tlb offset to the env address into X2,\n\n       to take advantage of the LSL12 form of the ADDI instruction.\n\n       X2 = env + (tlb_offset & 0xfff000) */\n\n    if (tlb_offset & 0xfff000) {\n\n        tcg_out_insn(s, 3401, ADDI, TCG_TYPE_I64, TCG_REG_X2, base,\n\n                     tlb_offset & 0xfff000);\n\n        base = TCG_REG_X2;\n\n    }\n\n\n\n    /* Merge the tlb index contribution into X2.\n\n       X2 = X2 + (X0 << CPU_TLB_ENTRY_BITS) */\n\n    tcg_out_insn(s, 3502S, ADD_LSL, TCG_TYPE_I64, TCG_REG_X2, base,\n\n                 TCG_REG_X0, CPU_TLB_ENTRY_BITS);\n\n\n\n    /* Merge \"low bits\" from tlb offset, load the tlb comparator into X0.\n\n       X0 = load [X2 + (tlb_offset & 0x000fff)] */\n\n    tcg_out_ldst(s, TARGET_LONG_BITS == 32 ? I3312_LDRW : I3312_LDRX,\n\n                 TCG_REG_X0, TCG_REG_X2, tlb_offset & 0xfff);\n\n\n\n    /* Load the tlb addend. Do that early to avoid stalling.\n\n       X1 = load [X2 + (tlb_offset & 0xfff) + offsetof(addend)] */\n\n    tcg_out_ldst(s, I3312_LDRX, TCG_REG_X1, TCG_REG_X2,\n\n                 (tlb_offset & 0xfff) + (offsetof(CPUTLBEntry, addend)) -\n\n                 (is_read ? offsetof(CPUTLBEntry, addr_read)\n\n                  : offsetof(CPUTLBEntry, addr_write)));\n\n\n\n    /* Perform the address comparison. */\n\n    tcg_out_cmp(s, (TARGET_LONG_BITS == 64), TCG_REG_X0, TCG_REG_X3, 0);\n\n\n\n    /* If not equal, we jump to the slow path. */\n\n    *label_ptr = s->code_ptr;\n\n    tcg_out_goto_cond_noaddr(s, TCG_COND_NE);\n\n}\n", "idx": 2805, "_split": "valid", "_hash": "5a3876c6378a941fc97064d70a0b988d"}
{"project": "qemu", "commit_id": "b4e237aae774a6dd3de2c3db9f87012d48ab6716", "target": 0, "func": "static int usb_host_scan_sys(void *opaque, USBScanFunc *func)\n\n{\n\n    DIR *dir = 0;\n\n    char line[1024];\n\n    int bus_num, addr, speed, class_id, product_id, vendor_id;\n\n    int ret = 0;\n\n    char product_name[512];\n\n    struct dirent *de;\n\n\n\n    dir = opendir(USBSYSBUS_PATH \"/devices\");\n\n    if (!dir) {\n\n        perror(\"husb: cannot open devices directory\");\n\n        goto the_end;\n\n    }\n\n\n\n    while ((de = readdir(dir))) {\n\n        if (de->d_name[0] != '.' && !strchr(de->d_name, ':')) {\n\n            char *tmpstr = de->d_name;\n\n            if (!strncmp(de->d_name, \"usb\", 3))\n\n                tmpstr += 3;\n\n            bus_num = atoi(tmpstr);\n\n\n\n            if (!usb_host_read_file(line, sizeof(line), USBSYSBUS_PATH \"/devices/%s/devnum\", de->d_name))\n\n                goto the_end;\n\n            if (sscanf(line, \"%d\", &addr) != 1)\n\n                goto the_end;\n\n\n\n            if (!usb_host_read_file(line, sizeof(line), USBSYSBUS_PATH \"/devices/%s/bDeviceClass\", de->d_name))\n\n                goto the_end;\n\n            if (sscanf(line, \"%x\", &class_id) != 1)\n\n                goto the_end;\n\n\n\n            if (!usb_host_read_file(line, sizeof(line), USBSYSBUS_PATH \"/devices/%s/idVendor\", de->d_name))\n\n                goto the_end;\n\n            if (sscanf(line, \"%x\", &vendor_id) != 1)\n\n                goto the_end;\n\n\n\n            if (!usb_host_read_file(line, sizeof(line), USBSYSBUS_PATH \"/devices/%s/idProduct\", de->d_name))\n\n                goto the_end;\n\n            if (sscanf(line, \"%x\", &product_id) != 1)\n\n                goto the_end;\n\n\n\n            if (!usb_host_read_file(line, sizeof(line), USBSYSBUS_PATH \"/devices/%s/product\", de->d_name)) {\n\n                *product_name = 0;\n\n            } else {\n\n                if (strlen(line) > 0)\n\n                    line[strlen(line) - 1] = '\\0';\n\n                pstrcpy(product_name, sizeof(product_name), line);\n\n            }\n\n\n\n            if (!usb_host_read_file(line, sizeof(line), USBSYSBUS_PATH \"/devices/%s/speed\", de->d_name))\n\n                goto the_end;\n\n            if (!strcmp(line, \"480\\n\"))\n\n                speed = USB_SPEED_HIGH;\n\n            else if (!strcmp(line, \"1.5\\n\"))\n\n                speed = USB_SPEED_LOW;\n\n            else\n\n                speed = USB_SPEED_FULL;\n\n\n\n            ret = func(opaque, bus_num, addr, class_id, vendor_id,\n\n                       product_id, product_name, speed);\n\n            if (ret)\n\n                goto the_end;\n\n        }\n\n    }\n\n the_end:\n\n    if (dir)\n\n        closedir(dir);\n\n    return ret;\n\n}\n", "idx": 2808, "_split": "valid", "_hash": "7ea3c89ba44a2472d1e4f00c2bf9b14d"}
{"project": "qemu", "commit_id": "b26177d7ec3f50157a5f37f804ffcace3b2a3945", "target": 0, "func": "int svm_check_intercept_param(uint32_t type, uint64_t param)\n\n{\n\n    switch(type) {\n\n    case SVM_EXIT_READ_CR0 ... SVM_EXIT_READ_CR0 + 8:\n\n        if (INTERCEPTEDw(_cr_read, (1 << (type - SVM_EXIT_READ_CR0)))) {\n\n            vmexit(type, param);\n\n            return 1;\n\n        }\n\n        break;\n\n    case SVM_EXIT_READ_DR0 ... SVM_EXIT_READ_DR0 + 8:\n\n        if (INTERCEPTEDw(_dr_read, (1 << (type - SVM_EXIT_READ_DR0)))) {\n\n            vmexit(type, param);\n\n            return 1;\n\n        }\n\n        break;\n\n    case SVM_EXIT_WRITE_CR0 ... SVM_EXIT_WRITE_CR0 + 8:\n\n        if (INTERCEPTEDw(_cr_write, (1 << (type - SVM_EXIT_WRITE_CR0)))) {\n\n            vmexit(type, param);\n\n            return 1;\n\n        }\n\n        break;\n\n    case SVM_EXIT_WRITE_DR0 ... SVM_EXIT_WRITE_DR0 + 8:\n\n        if (INTERCEPTEDw(_dr_write, (1 << (type - SVM_EXIT_WRITE_DR0)))) {\n\n            vmexit(type, param);\n\n            return 1;\n\n        }\n\n        break;\n\n    case SVM_EXIT_EXCP_BASE ... SVM_EXIT_EXCP_BASE + 16:\n\n        if (INTERCEPTEDl(_exceptions, (1 << (type - SVM_EXIT_EXCP_BASE)))) {\n\n            vmexit(type, param);\n\n            return 1;\n\n        }\n\n        break;\n\n    case SVM_EXIT_IOIO:\n\n        if (INTERCEPTED(1ULL << INTERCEPT_IOIO_PROT)) {\n\n            /* FIXME: this should be read in at vmrun (faster this way?) */\n\n            uint64_t addr = ldq_phys(env->vm_vmcb + offsetof(struct vmcb, control.iopm_base_pa));\n\n            uint16_t port = (uint16_t) (param >> 16);\n\n\n\n            if(ldub_phys(addr + port / 8) & (1 << (port % 8)))\n\n                vmexit(type, param);\n\n        }\n\n        break;\n\n\n\n    case SVM_EXIT_MSR:\n\n        if (INTERCEPTED(1ULL << INTERCEPT_MSR_PROT)) {\n\n            /* FIXME: this should be read in at vmrun (faster this way?) */\n\n            uint64_t addr = ldq_phys(env->vm_vmcb + offsetof(struct vmcb, control.msrpm_base_pa));\n\n            switch((uint32_t)ECX) {\n\n            case 0 ... 0x1fff:\n\n                T0 = (ECX * 2) % 8;\n\n                T1 = ECX / 8;\n\n                break;\n\n            case 0xc0000000 ... 0xc0001fff:\n\n                T0 = (8192 + ECX - 0xc0000000) * 2;\n\n                T1 = (T0 / 8);\n\n                T0 %= 8;\n\n                break;\n\n            case 0xc0010000 ... 0xc0011fff:\n\n                T0 = (16384 + ECX - 0xc0010000) * 2;\n\n                T1 = (T0 / 8);\n\n                T0 %= 8;\n\n                break;\n\n            default:\n\n                vmexit(type, param);\n\n                return 1;\n\n            }\n\n            if (ldub_phys(addr + T1) & ((1 << param) << T0))\n\n                vmexit(type, param);\n\n            return 1;\n\n        }\n\n        break;\n\n    default:\n\n        if (INTERCEPTED((1ULL << ((type - SVM_EXIT_INTR) + INTERCEPT_INTR)))) {\n\n            vmexit(type, param);\n\n            return 1;\n\n        }\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 2811, "_split": "valid", "_hash": "149160d1e6b9583a778d73723212ebcb"}
{"project": "qemu", "commit_id": "bb593904c18e22ea0671dfa1b02e24982f2bf0ea", "target": 0, "func": "int kvm_arch_get_registers(CPUState *env)\n\n{\n\n    struct kvm_regs regs;\n\n    struct kvm_sregs sregs;\n\n    int i, ret;\n\n\n\n    ret = kvm_vcpu_ioctl(env, KVM_GET_REGS, &regs);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    ret = kvm_vcpu_ioctl(env, KVM_GET_SREGS, &sregs);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    env->ctr = regs.ctr;\n\n    env->lr = regs.lr;\n\n    env->xer = regs.xer;\n\n    env->msr = regs.msr;\n\n    env->nip = regs.pc;\n\n\n\n    env->spr[SPR_SRR0] = regs.srr0;\n\n    env->spr[SPR_SRR1] = regs.srr1;\n\n\n\n    env->spr[SPR_SPRG0] = regs.sprg0;\n\n    env->spr[SPR_SPRG1] = regs.sprg1;\n\n    env->spr[SPR_SPRG2] = regs.sprg2;\n\n    env->spr[SPR_SPRG3] = regs.sprg3;\n\n    env->spr[SPR_SPRG4] = regs.sprg4;\n\n    env->spr[SPR_SPRG5] = regs.sprg5;\n\n    env->spr[SPR_SPRG6] = regs.sprg6;\n\n    env->spr[SPR_SPRG7] = regs.sprg7;\n\n\n\n    for (i = 0;i < 32; i++)\n\n        env->gpr[i] = regs.gpr[i];\n\n\n\n#ifdef KVM_CAP_PPC_SEGSTATE\n\n    if (kvm_check_extension(env->kvm_state, KVM_CAP_PPC_SEGSTATE)) {\n\n        env->sdr1 = sregs.u.s.sdr1;\n\n\n\n        /* Sync SLB */\n\n#ifdef TARGET_PPC64\n\n        for (i = 0; i < 64; i++) {\n\n            ppc_store_slb(env, sregs.u.s.ppc64.slb[i].slbe,\n\n                               sregs.u.s.ppc64.slb[i].slbv);\n\n        }\n\n#endif\n\n\n\n        /* Sync SRs */\n\n        for (i = 0; i < 16; i++) {\n\n            env->sr[i] = sregs.u.s.ppc32.sr[i];\n\n        }\n\n\n\n        /* Sync BATs */\n\n        for (i = 0; i < 8; i++) {\n\n            env->DBAT[0][i] = sregs.u.s.ppc32.dbat[i] & 0xffffffff;\n\n            env->DBAT[1][i] = sregs.u.s.ppc32.dbat[i] >> 32;\n\n            env->IBAT[0][i] = sregs.u.s.ppc32.ibat[i] & 0xffffffff;\n\n            env->IBAT[1][i] = sregs.u.s.ppc32.ibat[i] >> 32;\n\n        }\n\n    }\n\n#endif\n\n\n\n    return 0;\n\n}\n", "idx": 2815, "_split": "valid", "_hash": "637dea4b5157b345a43a48651a8bae98"}
{"project": "qemu", "commit_id": "12f8def0e02232d7c6416ad9b66640f973c531d1", "target": 1, "func": "void qemu_cond_wait(QemuCond *cond, QemuMutex *mutex)\n\n{\n\n    /*\n\n     * This access is protected under the mutex.\n\n     */\n\n    cond->waiters++;\n\n\n\n    /*\n\n     * Unlock external mutex and wait for signal.\n\n     * NOTE: we've held mutex locked long enough to increment\n\n     * waiters count above, so there's no problem with\n\n     * leaving mutex unlocked before we wait on semaphore.\n\n     */\n\n    qemu_mutex_unlock(mutex);\n\n    WaitForSingleObject(cond->sema, INFINITE);\n\n\n\n    /* Now waiters must rendez-vous with the signaling thread and\n\n     * let it continue.  For cond_broadcast this has heavy contention\n\n     * and triggers thundering herd.  So goes life.\n\n     *\n\n     * Decrease waiters count.  The mutex is not taken, so we have\n\n     * to do this atomically.\n\n     *\n\n     * All waiters contend for the mutex at the end of this function\n\n     * until the signaling thread relinquishes it.  To ensure\n\n     * each waiter consumes exactly one slice of the semaphore,\n\n     * the signaling thread stops until it is told by the last\n\n     * waiter that it can go on.\n\n     */\n\n    if (InterlockedDecrement(&cond->waiters) == cond->target) {\n\n        SetEvent(cond->continue_event);\n\n    }\n\n\n\n    qemu_mutex_lock(mutex);\n\n}\n", "idx": 2844, "_split": "valid", "_hash": "9707108212b4612d608f3f5844c10cbb"}
{"project": "qemu", "commit_id": "fe0bd475aa31e60674f7f53b85dc293108026202", "target": 1, "func": "static void gen_wsr(DisasContext *dc, uint32_t sr, TCGv_i32 s)\n\n{\n\n    static void (* const wsr_handler[256])(DisasContext *dc,\n\n            uint32_t sr, TCGv_i32 v) = {\n\n        [LBEG] = gen_wsr_lbeg,\n\n        [LEND] = gen_wsr_lend,\n\n        [SAR] = gen_wsr_sar,\n\n        [BR] = gen_wsr_br,\n\n        [LITBASE] = gen_wsr_litbase,\n\n        [ACCHI] = gen_wsr_acchi,\n\n        [WINDOW_BASE] = gen_wsr_windowbase,\n\n        [WINDOW_START] = gen_wsr_windowstart,\n\n        [PTEVADDR] = gen_wsr_ptevaddr,\n\n        [RASID] = gen_wsr_rasid,\n\n        [ITLBCFG] = gen_wsr_tlbcfg,\n\n        [DTLBCFG] = gen_wsr_tlbcfg,\n\n        [IBREAKENABLE] = gen_wsr_ibreakenable,\n\n        [ATOMCTL] = gen_wsr_atomctl,\n\n        [IBREAKA] = gen_wsr_ibreaka,\n\n        [IBREAKA + 1] = gen_wsr_ibreaka,\n\n        [DBREAKA] = gen_wsr_dbreaka,\n\n        [DBREAKA + 1] = gen_wsr_dbreaka,\n\n        [DBREAKC] = gen_wsr_dbreakc,\n\n        [DBREAKC + 1] = gen_wsr_dbreakc,\n\n        [CPENABLE] = gen_wsr_cpenable,\n\n        [INTSET] = gen_wsr_intset,\n\n        [INTCLEAR] = gen_wsr_intclear,\n\n        [INTENABLE] = gen_wsr_intenable,\n\n        [PS] = gen_wsr_ps,\n\n        [DEBUGCAUSE] = gen_wsr_debugcause,\n\n        [PRID] = gen_wsr_prid,\n\n        [ICOUNT] = gen_wsr_icount,\n\n        [ICOUNTLEVEL] = gen_wsr_icountlevel,\n\n        [CCOMPARE] = gen_wsr_ccompare,\n\n        [CCOMPARE + 1] = gen_wsr_ccompare,\n\n        [CCOMPARE + 2] = gen_wsr_ccompare,\n\n    };\n\n\n\n    if (sregnames[sr]) {\n\n        if (wsr_handler[sr]) {\n\n            wsr_handler[sr](dc, sr, s);\n\n        } else {\n\n            tcg_gen_mov_i32(cpu_SR[sr], s);\n\n        }\n\n    } else {\n\n        qemu_log(\"WSR %d not implemented, \", sr);\n\n    }\n\n}\n", "idx": 2862, "_split": "valid", "_hash": "02af8340b975e70ad39cbc7defeac227"}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int connect_namedsocket(const char *path)\n\n{\n\n    int sockfd, size;\n\n    struct sockaddr_un helper;\n\n\n\n    if (strlen(path) >= sizeof(helper.sun_path)) {\n\n        fprintf(stderr, \"Socket name too large\\n\");\n\n        return -1;\n\n    }\n\n    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\n    if (sockfd < 0) {\n\n        fprintf(stderr, \"failed to create socket: %s\\n\", strerror(errno));\n\n        return -1;\n\n    }\n\n    strcpy(helper.sun_path, path);\n\n    helper.sun_family = AF_UNIX;\n\n    size = strlen(helper.sun_path) + sizeof(helper.sun_family);\n\n    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {\n\n        fprintf(stderr, \"failed to connect to %s: %s\\n\", path, strerror(errno));\n\n        close(sockfd);\n\n        return -1;\n\n    }\n\n\n\n    /* remove the socket for security reasons */\n\n    unlink(path);\n\n    return sockfd;\n\n}\n", "idx": 2871, "_split": "valid", "_hash": "5fcd0b65ca12149949f9a06f2f9e998d"}
{"project": "qemu", "commit_id": "b4fe97c8230c34ebd407a9f23894b9c614807540", "target": 0, "func": "static void guest_file_init(void)\n\n{\n\n    QTAILQ_INIT(&guest_file_state.filehandles);\n\n}\n", "idx": 2892, "_split": "valid", "_hash": "49eef1ad51ce2e2b81500ebd1018199b"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void pchip_write(void *opaque, target_phys_addr_t addr,\n\n                        uint64_t v32, unsigned size)\n\n{\n\n    TyphoonState *s = opaque;\n\n    uint64_t val, oldval;\n\n\n\n    if (addr & 4) {\n\n        val = v32 << 32 | s->latch_tmp;\n\n        addr ^= 4;\n\n    } else {\n\n        s->latch_tmp = v32;\n\n        return;\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x0000:\n\n        /* WSBA0: Window Space Base Address Register.  */\n\n        s->pchip.win[0].base_addr = val;\n\n        break;\n\n    case 0x0040:\n\n        /* WSBA1 */\n\n        s->pchip.win[1].base_addr = val;\n\n        break;\n\n    case 0x0080:\n\n        /* WSBA2 */\n\n        s->pchip.win[2].base_addr = val;\n\n        break;\n\n    case 0x00c0:\n\n        /* WSBA3 */\n\n        s->pchip.win[3].base_addr = val;\n\n        break;\n\n\n\n    case 0x0100:\n\n        /* WSM0: Window Space Mask Register.  */\n\n        s->pchip.win[0].mask = val;\n\n        break;\n\n    case 0x0140:\n\n        /* WSM1 */\n\n        s->pchip.win[1].mask = val;\n\n        break;\n\n    case 0x0180:\n\n        /* WSM2 */\n\n        s->pchip.win[2].mask = val;\n\n        break;\n\n    case 0x01c0:\n\n        /* WSM3 */\n\n        s->pchip.win[3].mask = val;\n\n        break;\n\n\n\n    case 0x0200:\n\n        /* TBA0: Translated Base Address Register.  */\n\n        s->pchip.win[0].translated_base_pfn = val >> 10;\n\n        break;\n\n    case 0x0240:\n\n        /* TBA1 */\n\n        s->pchip.win[1].translated_base_pfn = val >> 10;\n\n        break;\n\n    case 0x0280:\n\n        /* TBA2 */\n\n        s->pchip.win[2].translated_base_pfn = val >> 10;\n\n        break;\n\n    case 0x02c0:\n\n        /* TBA3 */\n\n        s->pchip.win[3].translated_base_pfn = val >> 10;\n\n        break;\n\n\n\n    case 0x0300:\n\n        /* PCTL: Pchip Control Register.  */\n\n        oldval = s->pchip.ctl;\n\n        oldval &= ~0x00001cff0fc7ffull;       /* RW fields */\n\n        oldval |= val & 0x00001cff0fc7ffull;\n\n\n\n        s->pchip.ctl = oldval;\n\n        break;\n\n\n\n    case 0x0340:\n\n        /* PLAT: Pchip Master Latency Register.  */\n\n        break;\n\n    case 0x03c0:\n\n        /* PERROR: Pchip Error Register.  */\n\n        break;\n\n    case 0x0400:\n\n        /* PERRMASK: Pchip Error Mask Register.  */\n\n        break;\n\n    case 0x0440:\n\n        /* PERRSET: Pchip Error Set Register.  */\n\n        break;\n\n\n\n    case 0x0480:\n\n        /* TLBIV: Translation Buffer Invalidate Virtual Register.  */\n\n        break;\n\n\n\n    case 0x04c0:\n\n        /* TLBIA: Translation Buffer Invalidate All Register (WO).  */\n\n        break;\n\n\n\n    case 0x0500:\n\n        /* PMONCTL */\n\n    case 0x0540:\n\n        /* PMONCNT */\n\n    case 0x0800:\n\n        /* SPRST */\n\n        break;\n\n\n\n    default:\n\n        cpu_unassigned_access(cpu_single_env, addr, 1, 0, 0, size);\n\n        return;\n\n    }\n\n}\n", "idx": 2920, "_split": "valid", "_hash": "9fe25606998dcd3b67344fa4857d6b38"}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int usb_host_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    USBHostDevice *s = (USBHostDevice *)dev;\n\n    int ret, fd, mode;\n\n    int one = 1, shortpacket = 0, timeout = 50;\n\n    sigset_t new_mask, old_mask;\n\n    uint8_t devep = p->devep;\n\n\n\n    /* protect data transfers from SIGALRM signal */\n\n    sigemptyset(&new_mask);\n\n    sigaddset(&new_mask, SIGALRM);\n\n    sigprocmask(SIG_BLOCK, &new_mask, &old_mask);\n\n\n\n    if (p->pid == USB_TOKEN_IN) {\n\n        devep |= 0x80;\n\n        mode = O_RDONLY;\n\n        shortpacket = 1;\n\n    } else {\n\n        mode = O_WRONLY;\n\n    }\n\n\n\n    fd = ensure_ep_open(s, devep, mode);\n\n    if (fd < 0) {\n\n        sigprocmask(SIG_SETMASK, &old_mask, NULL);\n\n        return USB_RET_NODEV;\n\n    }\n\n\n\n    if (ioctl(fd, USB_SET_TIMEOUT, &timeout) < 0) {\n\n#ifdef DEBUG\n\n        printf(\"handle_data: failed to set timeout - %s\\n\",\n\n               strerror(errno));\n\n#endif\n\n    }\n\n\n\n    if (shortpacket) {\n\n        if (ioctl(fd, USB_SET_SHORT_XFER, &one) < 0) {\n\n#ifdef DEBUG\n\n            printf(\"handle_data: failed to set short xfer mode - %s\\n\",\n\n                   strerror(errno));\n\n#endif\n\n            sigprocmask(SIG_SETMASK, &old_mask, NULL);\n\n        }\n\n    }\n\n\n\n    if (p->pid == USB_TOKEN_IN)\n\n        ret = read(fd, p->data, p->len);\n\n    else\n\n        ret = write(fd, p->data, p->len);\n\n\n\n    sigprocmask(SIG_SETMASK, &old_mask, NULL);\n\n\n\n    if (ret < 0) {\n\n#ifdef DEBUG\n\n        printf(\"handle_data: error after %s data - %s\\n\",\n\n               pid == USB_TOKEN_IN ? \"reading\" : \"writing\", strerror(errno));\n\n#endif\n\n        switch(errno) {\n\n        case ETIMEDOUT:\n\n        case EINTR:\n\n            return USB_RET_NAK;\n\n        default:\n\n            return USB_RET_STALL;\n\n        }\n\n    } else {\n\n        return ret;\n\n    }\n\n}\n", "idx": 2936, "_split": "valid", "_hash": "fea96ef55dfba054b53636974aca8b74"}
{"project": "qemu", "commit_id": "6d74ca5aa83b83fb52332f7735c61ecb7a5328c1", "target": 1, "func": "static uint32_t virtio_ioport_read(VirtIOPCIProxy *proxy, uint32_t addr)\n\n{\n\n    VirtIODevice *vdev = proxy->vdev;\n\n    uint32_t ret = 0xFFFFFFFF;\n\n\n\n    switch (addr) {\n\n    case VIRTIO_PCI_HOST_FEATURES:\n\n        ret = vdev->get_features(vdev);\n\n        ret |= (1 << VIRTIO_F_NOTIFY_ON_EMPTY);\n\n        ret |= (1 << VIRTIO_RING_F_INDIRECT_DESC);\n\n        ret |= (1 << VIRTIO_F_BAD_FEATURE);\n\n        break;\n\n    case VIRTIO_PCI_GUEST_FEATURES:\n\n        ret = vdev->features;\n\n        break;\n\n    case VIRTIO_PCI_QUEUE_PFN:\n\n        ret = virtio_queue_get_addr(vdev, vdev->queue_sel)\n\n              >> VIRTIO_PCI_QUEUE_ADDR_SHIFT;\n\n        break;\n\n    case VIRTIO_PCI_QUEUE_NUM:\n\n        ret = virtio_queue_get_num(vdev, vdev->queue_sel);\n\n        break;\n\n    case VIRTIO_PCI_QUEUE_SEL:\n\n        ret = vdev->queue_sel;\n\n        break;\n\n    case VIRTIO_PCI_STATUS:\n\n        ret = vdev->status;\n\n        break;\n\n    case VIRTIO_PCI_ISR:\n\n        /* reading from the ISR also clears it. */\n\n        ret = vdev->isr;\n\n        vdev->isr = 0;\n\n        qemu_set_irq(proxy->pci_dev.irq[0], 0);\n\n        break;\n\n    case VIRTIO_MSI_CONFIG_VECTOR:\n\n        ret = vdev->config_vector;\n\n        break;\n\n    case VIRTIO_MSI_QUEUE_VECTOR:\n\n        ret = virtio_queue_vector(vdev, vdev->queue_sel);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 2948, "_split": "valid", "_hash": "2f166540fdca40abca4cae7b902d0942"}
{"project": "qemu", "commit_id": "7696414729b2d0f870c80ad1dd637d854bc78847", "target": 1, "func": "static void gen_st (DisasContext *ctx, uint32_t opc, int rt,\n\n                    int base, int16_t offset)\n\n{\n\n    TCGv t0 = tcg_temp_new();\n\n    TCGv t1 = tcg_temp_new();\n\n    int mem_idx = ctx->mem_idx;\n\n\n\n    gen_base_offset_addr(ctx, t0, base, offset);\n\n    gen_load_gpr(t1, rt);\n\n    switch (opc) {\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_SD:\n\n        tcg_gen_qemu_st_tl(t1, t0, mem_idx, MO_TEQ |\n\n                           ctx->default_tcg_memop_mask);\n\n        break;\n\n    case OPC_SDL:\n\n        gen_helper_0e2i(sdl, t1, t0, mem_idx);\n\n        break;\n\n    case OPC_SDR:\n\n        gen_helper_0e2i(sdr, t1, t0, mem_idx);\n\n        break;\n\n#endif\n\n\n\n\n    case OPC_SW:\n\n        tcg_gen_qemu_st_tl(t1, t0, mem_idx, MO_TEUL |\n\n                           ctx->default_tcg_memop_mask);\n\n        break;\n\n\n\n\n    case OPC_SH:\n\n        tcg_gen_qemu_st_tl(t1, t0, mem_idx, MO_TEUW |\n\n                           ctx->default_tcg_memop_mask);\n\n        break;\n\n\n\n\n    case OPC_SB:\n\n        tcg_gen_qemu_st_tl(t1, t0, mem_idx, MO_8);\n\n        break;\n\n\n\n\n    case OPC_SWL:\n\n        gen_helper_0e2i(swl, t1, t0, mem_idx);\n\n        break;\n\n\n\n\n    case OPC_SWR:\n\n        gen_helper_0e2i(swr, t1, t0, mem_idx);\n\n        break;\n\n    }\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}", "idx": 2965, "_split": "valid", "_hash": "2c83edee521f0a9a380818f4611d0dcd"}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static void *qpa_audio_init (void)\n\n{\n\n    return &conf;\n\n}\n", "idx": 2973, "_split": "valid", "_hash": "0723bb9ffe9c108ba849d66d9439bd0b"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void timer_deinit(QEMUTimer *ts)\n\n{\n\n    assert(ts->expire_time == -1);\n\n    ts->timer_list = NULL;\n\n}\n", "idx": 2978, "_split": "valid", "_hash": "e04aaad33de6807df40d2a28a9371f73"}
{"project": "qemu", "commit_id": "9db1c0f7a94c6382e2b3e1365566a9a8b8ae74c1", "target": 0, "func": "int ide_init_drive(IDEState *s, BlockDriverState *bs, IDEDriveKind kind,\n\n                   const char *version, const char *serial, const char *model,\n\n                   uint64_t wwn)\n\n{\n\n    int cylinders, heads, secs;\n\n    uint64_t nb_sectors;\n\n\n\n    s->bs = bs;\n\n    s->drive_kind = kind;\n\n\n\n    bdrv_get_geometry(bs, &nb_sectors);\n\n    bdrv_guess_geometry(bs, &cylinders, &heads, &secs);\n\n    if (cylinders < 1 || cylinders > 16383) {\n\n        error_report(\"cyls must be between 1 and 16383\");\n\n        return -1;\n\n    }\n\n    if (heads < 1 || heads > 16) {\n\n        error_report(\"heads must be between 1 and 16\");\n\n        return -1;\n\n    }\n\n    if (secs < 1 || secs > 63) {\n\n        error_report(\"secs must be between 1 and 63\");\n\n        return -1;\n\n    }\n\n    s->cylinders = cylinders;\n\n    s->heads = heads;\n\n    s->sectors = secs;\n\n    s->nb_sectors = nb_sectors;\n\n    s->wwn = wwn;\n\n    /* The SMART values should be preserved across power cycles\n\n       but they aren't.  */\n\n    s->smart_enabled = 1;\n\n    s->smart_autosave = 1;\n\n    s->smart_errors = 0;\n\n    s->smart_selftest_count = 0;\n\n    if (kind == IDE_CD) {\n\n        bdrv_set_dev_ops(bs, &ide_cd_block_ops, s);\n\n        bdrv_set_buffer_alignment(bs, 2048);\n\n    } else {\n\n        if (!bdrv_is_inserted(s->bs)) {\n\n            error_report(\"Device needs media, but drive is empty\");\n\n            return -1;\n\n        }\n\n        if (bdrv_is_read_only(bs)) {\n\n            error_report(\"Can't use a read-only drive\");\n\n            return -1;\n\n        }\n\n    }\n\n    if (serial) {\n\n        pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial);\n\n    } else {\n\n        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),\n\n                 \"QM%05d\", s->drive_serial);\n\n    }\n\n    if (model) {\n\n        pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model);\n\n    } else {\n\n        switch (kind) {\n\n        case IDE_CD:\n\n            strcpy(s->drive_model_str, \"QEMU DVD-ROM\");\n\n            break;\n\n        case IDE_CFATA:\n\n            strcpy(s->drive_model_str, \"QEMU MICRODRIVE\");\n\n            break;\n\n        default:\n\n            strcpy(s->drive_model_str, \"QEMU HARDDISK\");\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (version) {\n\n        pstrcpy(s->version, sizeof(s->version), version);\n\n    } else {\n\n        pstrcpy(s->version, sizeof(s->version), qemu_get_version());\n\n    }\n\n\n\n    ide_reset(s);\n\n    bdrv_iostatus_enable(bs);\n\n    return 0;\n\n}\n", "idx": 2981, "_split": "valid", "_hash": "df3100a81f41f36a2e07d3b20085c0b4"}
{"project": "qemu", "commit_id": "ca6b6e1e68ac44b2e8895da10dd1c80dc03d08b7", "target": 0, "func": "static QDict *qmp_check_input_obj(QObject *input_obj, Error **errp)\n\n{\n\n    const QDictEntry *ent;\n\n    int has_exec_key = 0;\n\n    QDict *input_dict;\n\n\n\n    if (qobject_type(input_obj) != QTYPE_QDICT) {\n\n        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, \"object\");\n\n        return NULL;\n\n    }\n\n\n\n    input_dict = qobject_to_qdict(input_obj);\n\n\n\n    for (ent = qdict_first(input_dict); ent; ent = qdict_next(input_dict, ent)){\n\n        const char *arg_name = qdict_entry_key(ent);\n\n        const QObject *arg_obj = qdict_entry_value(ent);\n\n\n\n        if (!strcmp(arg_name, \"execute\")) {\n\n            if (qobject_type(arg_obj) != QTYPE_QSTRING) {\n\n                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER,\n\n                           \"execute\", \"string\");\n\n                return NULL;\n\n            }\n\n            has_exec_key = 1;\n\n        } else if (!strcmp(arg_name, \"arguments\")) {\n\n            if (qobject_type(arg_obj) != QTYPE_QDICT) {\n\n                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER,\n\n                           \"arguments\", \"object\");\n\n                return NULL;\n\n            }\n\n        } else if (!strcmp(arg_name, \"id\")) {\n\n            /* Any string is acceptable as \"id\", so nothing to check */\n\n        } else {\n\n            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if (!has_exec_key) {\n\n        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, \"execute\");\n\n        return NULL;\n\n    }\n\n\n\n    return input_dict;\n\n}\n", "idx": 2982, "_split": "valid", "_hash": "1d33998b0226f011d969a9c185280542"}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_read(void *opaque, const uint8_t *buf, int size)\n\n{\n\n    int i;\n\n    for(i = 0; i < size; i++)\n\n        term_handle_byte(buf[i]);\n\n}\n", "idx": 2985, "_split": "valid", "_hash": "5f90827f7d9b152960b2f0aa9f07094a"}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_validate_fail_struct_missing(TestInputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n    QObject *any;\n\n    GenericAlternate *alt;\n\n    bool present;\n\n    int en;\n\n    int64_t i64;\n\n    uint32_t u32;\n\n    int8_t i8;\n\n    char *str;\n\n    double dbl;\n\n\n\n    v = validate_test_init(data, \"{}\");\n\n    visit_start_struct(v, NULL, NULL, 0, &error_abort);\n\n    visit_start_struct(v, \"struct\", NULL, 0, &err);\n\n    error_free_or_abort(&err);\n\n    visit_start_list(v, \"list\", NULL, 0, &err);\n\n    error_free_or_abort(&err);\n\n    visit_start_alternate(v, \"alternate\", &alt, sizeof(*alt), false, &err);\n\n    error_free_or_abort(&err);\n\n    visit_optional(v, \"optional\", &present);\n\n    g_assert(!present);\n\n    visit_type_enum(v, \"enum\", &en, EnumOne_lookup, &err);\n\n    error_free_or_abort(&err);\n\n    visit_type_int(v, \"i64\", &i64, &err);\n\n    error_free_or_abort(&err);\n\n    visit_type_uint32(v, \"u32\", &u32, &err);\n\n    error_free_or_abort(&err);\n\n    visit_type_int8(v, \"i8\", &i8, &err);\n\n    error_free_or_abort(&err);\n\n    visit_type_str(v, \"i8\", &str, &err);\n\n    error_free_or_abort(&err);\n\n    visit_type_number(v, \"dbl\", &dbl, &err);\n\n    error_free_or_abort(&err);\n\n    visit_type_any(v, \"any\", &any, &err);\n\n    error_free_or_abort(&err);\n\n    visit_type_null(v, \"null\", &err);\n\n    error_free_or_abort(&err);\n\n    visit_end_struct(v, NULL);\n\n}\n", "idx": 3013, "_split": "valid", "_hash": "e2dd6d2c7dab68ea27e739692d9eedf3"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void dma_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie,\n\n                    QEMUSGList *sg, enum BlockAcctType type)\n\n{\n\n    block_acct_start(bdrv_get_stats(bs), cookie, sg->size, type);\n\n}\n", "idx": 3019, "_split": "valid", "_hash": "2805d92c1dc6d39e2682a311c883bdeb"}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "xilinx_axienet_data_stream_push(StreamSlave *obj, uint8_t *buf, size_t size,\n\n                                uint32_t *hdr)\n\n{\n\n    XilinxAXIEnetStreamSlave *ds = XILINX_AXI_ENET_DATA_STREAM(obj);\n\n    XilinxAXIEnet *s = ds->enet;\n\n\n\n    /* TX enable ?  */\n\n    if (!(s->tc & TC_TX)) {\n\n        return size;\n\n    }\n\n\n\n    /* Jumbo or vlan sizes ?  */\n\n    if (!(s->tc & TC_JUM)) {\n\n        if (size > 1518 && size <= 1522 && !(s->tc & TC_VLAN)) {\n\n            return size;\n\n        }\n\n    }\n\n\n\n    if (hdr[0] & 1) {\n\n        unsigned int start_off = hdr[1] >> 16;\n\n        unsigned int write_off = hdr[1] & 0xffff;\n\n        uint32_t tmp_csum;\n\n        uint16_t csum;\n\n\n\n        tmp_csum = net_checksum_add(size - start_off,\n\n                                    (uint8_t *)buf + start_off);\n\n        /* Accumulate the seed.  */\n\n        tmp_csum += hdr[2] & 0xffff;\n\n\n\n        /* Fold the 32bit partial checksum.  */\n\n        csum = net_checksum_finish(tmp_csum);\n\n\n\n        /* Writeback.  */\n\n        buf[write_off] = csum >> 8;\n\n        buf[write_off + 1] = csum & 0xff;\n\n    }\n\n\n\n    qemu_send_packet(qemu_get_queue(s->nic), buf, size);\n\n\n\n    s->stats.tx_bytes += size;\n\n    s->regs[R_IS] |= IS_TX_COMPLETE;\n\n    enet_update_irq(s);\n\n\n\n    return size;\n\n}\n", "idx": 3039, "_split": "valid", "_hash": "63fcbb222783cfc266b456a8b22b3ea2"}
{"project": "qemu", "commit_id": "1ac157da77c863b62b1d2f467626a440d57cf17d", "target": 0, "func": "void cpu_x86_set_a20(CPUX86State *env, int a20_state)\n\n{\n\n    a20_state = (a20_state != 0);\n\n    if (a20_state != a20_enabled) {\n\n#if defined(DEBUG_MMU)\n\n        printf(\"A20 update: a20=%d\\n\", a20_state);\n\n#endif\n\n        /* if the cpu is currently executing code, we must unlink it and\n\n           all the potentially executing TB */\n\n        cpu_interrupt(env, 0);\n\n\n\n        /* when a20 is changed, all the MMU mappings are invalid, so\n\n           we must flush everything */\n\n        tlb_flush(env);\n\n        a20_enabled = a20_state;\n\n        if (a20_enabled)\n\n            a20_mask = 0xffffffff;\n\n        else\n\n            a20_mask = 0xffefffff;\n\n    }\n\n}\n", "idx": 3047, "_split": "valid", "_hash": "97d2cefed73a15e9b8e325d5a8608bee"}
{"project": "qemu", "commit_id": "92f2b4e71e988ad2751c71717e9fe3387753442a", "target": 0, "func": "uint64_t HELPER(cvd)(int32_t bin)\n\n{\n\n    /* positive 0 */\n\n    uint64_t dec = 0x0c;\n\n    int shift = 4;\n\n\n\n    if (bin < 0) {\n\n        bin = -bin;\n\n        dec = 0x0d;\n\n    }\n\n\n\n    for (shift = 4; (shift < 64) && bin; shift += 4) {\n\n        int current_number = bin % 10;\n\n\n\n        dec |= (current_number) << shift;\n\n        bin /= 10;\n\n    }\n\n\n\n    return dec;\n\n}\n", "idx": 3059, "_split": "valid", "_hash": "56b633deb9b1b94dc1364de6a2f797c9"}
{"project": "qemu", "commit_id": "cea5f9a28faa528b6b1b117c9ab2d8828f473fef", "target": 0, "func": "static void tcg_target_qemu_prologue(TCGContext *s)\n\n{\n\n    int frame_size, i;\n\n\n\n    /* Allocate space for the fixed frame marker.  */\n\n    frame_size = -TCG_TARGET_CALL_STACK_OFFSET;\n\n    frame_size += TCG_TARGET_STATIC_CALL_ARGS_SIZE;\n\n\n\n    /* Allocate space for the saved registers.  */\n\n    frame_size += ARRAY_SIZE(tcg_target_callee_save_regs) * 4;\n\n\n\n    /* Align the allocated space.  */\n\n    frame_size = ((frame_size + TCG_TARGET_STACK_ALIGN - 1)\n\n                  & -TCG_TARGET_STACK_ALIGN);\n\n\n\n    /* The return address is stored in the caller's frame.  */\n\n    tcg_out_st(s, TCG_TYPE_PTR, TCG_REG_RP, TCG_REG_SP, -20);\n\n\n\n    /* Allocate stack frame, saving the first register at the same time.  */\n\n    tcg_out_ldst(s, tcg_target_callee_save_regs[0],\n\n                 TCG_REG_SP, frame_size, INSN_STWM);\n\n\n\n    /* Save all callee saved registers.  */\n\n    for (i = 1; i < ARRAY_SIZE(tcg_target_callee_save_regs); i++) {\n\n        tcg_out_st(s, TCG_TYPE_PTR, tcg_target_callee_save_regs[i],\n\n                   TCG_REG_SP, -frame_size + i * 4);\n\n    }\n\n\n\n#ifdef CONFIG_USE_GUEST_BASE\n\n    if (GUEST_BASE != 0) {\n\n        tcg_out_movi(s, TCG_TYPE_PTR, TCG_GUEST_BASE_REG, GUEST_BASE);\n\n        tcg_regset_set_reg(s->reserved_regs, TCG_GUEST_BASE_REG);\n\n    }\n\n#endif\n\n\n\n    /* Jump to TB, and adjust R18 to be the return address.  */\n\n    tcg_out32(s, INSN_BLE_SR4 | INSN_R2(TCG_REG_R26));\n\n    tcg_out_mov(s, TCG_TYPE_I32, TCG_REG_R18, TCG_REG_R31);\n\n\n\n    /* Restore callee saved registers.  */\n\n    tcg_out_ld(s, TCG_TYPE_PTR, TCG_REG_RP, TCG_REG_SP, -frame_size - 20);\n\n    for (i = 1; i < ARRAY_SIZE(tcg_target_callee_save_regs); i++) {\n\n        tcg_out_ld(s, TCG_TYPE_PTR, tcg_target_callee_save_regs[i],\n\n                   TCG_REG_SP, -frame_size + i * 4);\n\n    }\n\n\n\n    /* Deallocate stack frame and return.  */\n\n    tcg_out32(s, INSN_BV | INSN_R2(TCG_REG_RP));\n\n    tcg_out_ldst(s, tcg_target_callee_save_regs[0],\n\n                 TCG_REG_SP, -frame_size, INSN_LDWM);\n\n}\n", "idx": 3061, "_split": "valid", "_hash": "6ff164959fc472ab38f2f0de37fc0264"}
{"project": "qemu", "commit_id": "cc05c43ad942165ecc6ffd39e41991bee43af044", "target": 1, "func": "bool io_mem_read(MemoryRegion *mr, hwaddr addr, uint64_t *pval, unsigned size)\n\n{\n\n    return memory_region_dispatch_read(mr, addr, pval, size);\n\n}\n", "idx": 3071, "_split": "valid", "_hash": "7c301d26bdba8ae0dafd8dad7bb89269"}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "static void qmp_input_end_list(Visitor *v)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n\n\n    qmp_input_pop(qiv, &error_abort);\n\n}\n", "idx": 3192, "_split": "valid", "_hash": "64cc7f63efa7014c9b9d8fafa9d52bbb"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint32(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint32_t *v = pv;\n\n    qemu_get_be32s(f, v);\n\n    return 0;\n\n}\n", "idx": 3195, "_split": "valid", "_hash": "4cb4f9228a44b4ac2db98bd6111a508b"}
{"project": "qemu", "commit_id": "cd7fdfe59f4f965665dcd9868fe3764f5256d6aa", "target": 1, "func": "static void *data_plane_thread(void *opaque)\n\n{\n\n    VirtIOBlockDataPlane *s = opaque;\n\n\n\n    do {\n\n        event_poll(&s->event_poll);\n\n    } while (s->started || s->num_reqs > 0);\n\n    return NULL;\n\n}\n", "idx": 3207, "_split": "valid", "_hash": "d23d3eaf0733b22eb830ceb598341926"}
{"project": "qemu", "commit_id": "ca9bd24cf1d53775169ba9adc17e265554d1afed", "target": 1, "func": "void bdrv_close_all(void)\n\n{\n\n    BlockDriverState *bs;\n\n\n\n    QTAILQ_FOREACH(bs, &bdrv_states, device_list) {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        aio_context_acquire(aio_context);\n\n        bdrv_close(bs);\n\n        aio_context_release(aio_context);\n\n    }\n\n}\n", "idx": 3215, "_split": "valid", "_hash": "aa57377fe013f1d471324a846604a696"}
{"project": "qemu", "commit_id": "06ac27f683c52890a6d174adba8c92354fa1eceb", "target": 1, "func": "void monitor_init(CharDriverState *chr, int flags)\n\n{\n\n    static int is_first_init = 1;\n\n    Monitor *mon;\n\n\n\n    if (is_first_init) {\n\n        monitor_qapi_event_init();\n\n        sortcmdlist();\n\n        is_first_init = 0;\n\n    }\n\n\n\n    mon = g_malloc(sizeof(*mon));\n\n    monitor_data_init(mon);\n\n\n\n    mon->chr = chr;\n\n    mon->flags = flags;\n\n    if (flags & MONITOR_USE_READLINE) {\n\n        mon->rs = readline_init(monitor_readline_printf,\n\n                                monitor_readline_flush,\n\n                                mon,\n\n                                monitor_find_completion);\n\n        monitor_read_command(mon, 0);\n\n    }\n\n\n\n    if (monitor_is_qmp(mon)) {\n\n        qemu_chr_add_handlers(chr, monitor_can_read, monitor_qmp_read,\n\n                              monitor_qmp_event, mon);\n\n        qemu_chr_fe_set_echo(chr, true);\n\n        json_message_parser_init(&mon->qmp.parser, handle_qmp_command);\n\n    } else {\n\n        qemu_chr_add_handlers(chr, monitor_can_read, monitor_read,\n\n                              monitor_event, mon);\n\n    }\n\n\n\n    qemu_mutex_lock(&monitor_lock);\n\n    QLIST_INSERT_HEAD(&mon_list, mon, entry);\n\n    qemu_mutex_unlock(&monitor_lock);\n\n\n\n    if (!default_mon || (flags & MONITOR_IS_DEFAULT))\n\n        default_mon = mon;\n\n}\n", "idx": 3219, "_split": "valid", "_hash": "c025d8bb1301341c83ce50b384d7dc1d"}
{"project": "qemu", "commit_id": "788d2599def0e26d92802593b07ec76e8701ccce", "target": 1, "func": "static sPAPRDRConnector *spapr_phb_get_pci_drc(sPAPRPHBState *phb,\n\n                                               PCIDevice *pdev)\n\n{\n\n    uint32_t busnr = pci_bus_num(PCI_BUS(qdev_get_parent_bus(DEVICE(pdev))));\n\n    return spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_PCI,\n\n                                    (phb->index << 16) |\n\n                                    (busnr << 8) |\n\n                                    pdev->devfn);\n\n}\n", "idx": 3224, "_split": "valid", "_hash": "d2228fa4a0cbcc9d2bb6201b5bb77365"}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static void adb_kbd_put_keycode(void *opaque, int keycode)\n\n{\n\n    KBDState *s = opaque;\n\n\n\n    if (s->count < sizeof(s->data)) {\n\n        s->data[s->wptr] = keycode;\n\n        if (++s->wptr == sizeof(s->data))\n\n            s->wptr = 0;\n\n        s->count++;\n\n    }\n\n}\n", "idx": 3234, "_split": "valid", "_hash": "ee366872d5dc2f3f1f24badb1b3dfac4"}
{"project": "qemu", "commit_id": "c8e6c93857885a19e959ec622d92a256d1cd98eb", "target": 1, "func": "static void nvdimm_build_nfit(GSList *device_list, GArray *table_offsets,\n\n                              GArray *table_data, GArray *linker)\n\n{\n\n    GArray *structures = nvdimm_build_device_structure(device_list);\n\n    void *header;\n\n\n\n    acpi_add_table(table_offsets, table_data);\n\n\n\n    /* NFIT header. */\n\n    header = acpi_data_push(table_data, sizeof(NvdimmNfitHeader));\n\n    /* NVDIMM device structures. */\n\n    g_array_append_vals(table_data, structures->data, structures->len);\n\n\n\n    build_header(linker, table_data, header, \"NFIT\",\n\n                 sizeof(NvdimmNfitHeader) + structures->len, 1, NULL);\n\n    g_array_free(structures, true);\n\n}\n", "idx": 3249, "_split": "valid", "_hash": "e4ce2a8b32ce0972a5acf89661d66ea6"}
{"project": "qemu", "commit_id": "63729c36924348e494d69adbbdec6fdda339b76b", "target": 0, "func": "static int v9fs_do_mksock(V9fsState *s, V9fsString *path)\n\n{\n\n    return s->ops->mksock(&s->ctx, path->data);\n\n}\n", "idx": 3255, "_split": "valid", "_hash": "eda84b989af278acf59f8b799e5d23d7"}
{"project": "qemu", "commit_id": "a904c91196a9c5dbd7b9abcd3d40b0824286fb1c", "target": 0, "func": "static ram_addr_t ram_block_add(RAMBlock *new_block, Error **errp)\n\n{\n\n    RAMBlock *block;\n\n    ram_addr_t old_ram_size, new_ram_size;\n\n\n\n    old_ram_size = last_ram_offset() >> TARGET_PAGE_BITS;\n\n\n\n    /* This assumes the iothread lock is taken here too.  */\n\n    qemu_mutex_lock_ramlist();\n\n    new_block->offset = find_ram_offset(new_block->max_length);\n\n\n\n    if (!new_block->host) {\n\n        if (xen_enabled()) {\n\n            xen_ram_alloc(new_block->offset, new_block->max_length,\n\n                          new_block->mr);\n\n        } else {\n\n            new_block->host = phys_mem_alloc(new_block->max_length,\n\n                                             &new_block->mr->align);\n\n            if (!new_block->host) {\n\n                error_setg_errno(errp, errno,\n\n                                 \"cannot set up guest memory '%s'\",\n\n                                 memory_region_name(new_block->mr));\n\n                qemu_mutex_unlock_ramlist();\n\n                return -1;\n\n            }\n\n            memory_try_enable_merging(new_block->host, new_block->max_length);\n\n        }\n\n    }\n\n\n\n    /* Keep the list sorted from biggest to smallest block.  */\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        if (block->max_length < new_block->max_length) {\n\n            break;\n\n        }\n\n    }\n\n    if (block) {\n\n        QTAILQ_INSERT_BEFORE(block, new_block, next);\n\n    } else {\n\n        QTAILQ_INSERT_TAIL(&ram_list.blocks, new_block, next);\n\n    }\n\n    ram_list.mru_block = NULL;\n\n\n\n    ram_list.version++;\n\n    qemu_mutex_unlock_ramlist();\n\n\n\n    new_ram_size = last_ram_offset() >> TARGET_PAGE_BITS;\n\n\n\n    if (new_ram_size > old_ram_size) {\n\n        int i;\n\n        for (i = 0; i < DIRTY_MEMORY_NUM; i++) {\n\n            ram_list.dirty_memory[i] =\n\n                bitmap_zero_extend(ram_list.dirty_memory[i],\n\n                                   old_ram_size, new_ram_size);\n\n       }\n\n    }\n\n    cpu_physical_memory_set_dirty_range(new_block->offset,\n\n                                        new_block->used_length);\n\n\n\n    qemu_ram_setup_dump(new_block->host, new_block->max_length);\n\n    qemu_madvise(new_block->host, new_block->max_length, QEMU_MADV_HUGEPAGE);\n\n    qemu_madvise(new_block->host, new_block->max_length, QEMU_MADV_DONTFORK);\n\n\n\n    if (kvm_enabled()) {\n\n        kvm_setup_guest_memory(new_block->host, new_block->max_length);\n\n    }\n\n\n\n    return new_block->offset;\n\n}\n", "idx": 3270, "_split": "valid", "_hash": "cbde968329c41c96ac37bfa6f4dbd690"}
{"project": "qemu", "commit_id": "f5aa4bdc766190b95d18be27d5cdf4d80c35b33c", "target": 1, "func": "static void make_dirty(uint8_t device)\n\n{\n\n    QPCIDevice *dev;\n\n    QPCIBar bmdma_bar, ide_bar;\n\n    uint8_t status;\n\n    size_t len = 512;\n\n    uintptr_t guest_buf;\n\n    void* buf;\n\n\n\n    dev = get_pci_device(&bmdma_bar, &ide_bar);\n\n\n\n    guest_buf = guest_alloc(guest_malloc, len);\n\n    buf = g_malloc(len);\n\n    memset(buf, rand() % 255 + 1, len);\n\n    g_assert(guest_buf);\n\n    g_assert(buf);\n\n\n\n    memwrite(guest_buf, buf, len);\n\n\n\n    PrdtEntry prdt[] = {\n\n        {\n\n            .addr = cpu_to_le32(guest_buf),\n\n            .size = cpu_to_le32(len | PRDT_EOT),\n\n        },\n\n    };\n\n\n\n    status = send_dma_request(CMD_WRITE_DMA, 1, 1, prdt,\n\n                              ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_bar, reg_status), DF | ERR);\n\n\n\n    g_free(buf);\n\n\n}", "idx": 3284, "_split": "valid", "_hash": "5a3c813a4ae95e4a7d400c15e83b8295"}
{"project": "qemu", "commit_id": "49f676a00ab540fac1d2008be26434cf85607722", "target": 0, "func": "unsigned long find_next_bit(const unsigned long *addr, unsigned long size,\n\n\t\t\t    unsigned long offset)\n\n{\n\n    const unsigned long *p = addr + BITOP_WORD(offset);\n\n    unsigned long result = offset & ~(BITS_PER_LONG-1);\n\n    unsigned long tmp;\n\n\n\n    if (offset >= size) {\n\n        return size;\n\n    }\n\n    size -= result;\n\n    offset %= BITS_PER_LONG;\n\n    if (offset) {\n\n        tmp = *(p++);\n\n        tmp &= (~0UL << offset);\n\n        if (size < BITS_PER_LONG) {\n\n            goto found_first;\n\n        }\n\n        if (tmp) {\n\n            goto found_middle;\n\n        }\n\n        size -= BITS_PER_LONG;\n\n        result += BITS_PER_LONG;\n\n    }\n\n    while (size & ~(BITS_PER_LONG-1)) {\n\n        if ((tmp = *(p++))) {\n\n            goto found_middle;\n\n        }\n\n        result += BITS_PER_LONG;\n\n        size -= BITS_PER_LONG;\n\n    }\n\n    if (!size) {\n\n        return result;\n\n    }\n\n    tmp = *p;\n\n\n\nfound_first:\n\n    tmp &= (~0UL >> (BITS_PER_LONG - size));\n\n    if (tmp == 0UL) {\t\t/* Are any bits set? */\n\n        return result + size;\t/* Nope. */\n\n    }\n\nfound_middle:\n\n    return result + ctzl(tmp);\n\n}\n", "idx": 3302, "_split": "valid", "_hash": "9689ad43db24c552c435d837b238c5df"}
{"project": "qemu", "commit_id": "5f2a80adc6fd2b2e4e0579a6613a9913e3cc9a05", "target": 0, "func": "uint64_t helper_cmpbge(uint64_t op1, uint64_t op2)\n\n{\n\n    uint8_t opa, opb, res;\n\n    int i;\n\n\n\n    res = 0;\n\n    for (i = 0; i < 8; i++) {\n\n        opa = op1 >> (i * 8);\n\n        opb = op2 >> (i * 8);\n\n        if (opa >= opb) {\n\n            res |= 1 << i;\n\n        }\n\n    }\n\n    return res;\n\n}\n", "idx": 3309, "_split": "valid", "_hash": "a2b683dba15b4b85737b20bc601365f0"}
{"project": "qemu", "commit_id": "81cf8d8adc64203567e03326c13ea4abec9fe5df", "target": 0, "func": "void helper_check_iol(CPUX86State *env, uint32_t t0)\n\n{\n\n    check_io(env, t0, 4);\n\n}\n", "idx": 3312, "_split": "valid", "_hash": "99e924ab1226c9f0e301dadba6745490"}
{"project": "qemu", "commit_id": "7e62255a4b3e0e2ab84a3ec7398640e8ed58620a", "target": 1, "func": "static void ccid_card_vscard_handle_message(PassthruState *card,\n\n    VSCMsgHeader *scr_msg_header)\n\n{\n\n    uint8_t *data = (uint8_t *)&scr_msg_header[1];\n\n\n\n    switch (scr_msg_header->type) {\n\n    case VSC_ATR:\n\n        DPRINTF(card, D_INFO, \"VSC_ATR %d\\n\", scr_msg_header->length);\n\n        if (scr_msg_header->length > MAX_ATR_SIZE) {\n\n            error_report(\"ATR size exceeds spec, ignoring\");\n\n            ccid_card_vscard_send_error(card, scr_msg_header->reader_id,\n\n                                        VSC_GENERAL_ERROR);\n\n\n        }\n\n        memcpy(card->atr, data, scr_msg_header->length);\n\n        card->atr_length = scr_msg_header->length;\n\n        ccid_card_card_inserted(&card->base);\n\n        ccid_card_vscard_send_error(card, scr_msg_header->reader_id,\n\n                                    VSC_SUCCESS);\n\n\n    case VSC_APDU:\n\n        ccid_card_send_apdu_to_guest(\n\n            &card->base, data, scr_msg_header->length);\n\n\n    case VSC_CardRemove:\n\n        DPRINTF(card, D_INFO, \"VSC_CardRemove\\n\");\n\n        ccid_card_card_removed(&card->base);\n\n        ccid_card_vscard_send_error(card,\n\n            scr_msg_header->reader_id, VSC_SUCCESS);\n\n\n    case VSC_Init:\n\n        ccid_card_vscard_handle_init(\n\n            card, scr_msg_header, (VSCMsgInit *)data);\n\n\n    case VSC_Error:\n\n        ccid_card_card_error(&card->base, *(uint32_t *)data);\n\n\n    case VSC_ReaderAdd:\n\n        if (ccid_card_ccid_attach(&card->base) < 0) {\n\n            ccid_card_vscard_send_error(card, VSCARD_UNDEFINED_READER_ID,\n\n                                      VSC_CANNOT_ADD_MORE_READERS);\n\n        } else {\n\n            ccid_card_vscard_send_error(card, VSCARD_MINIMAL_READER_ID,\n\n                                        VSC_SUCCESS);\n\n        }\n\n\n    case VSC_ReaderRemove:\n\n        ccid_card_ccid_detach(&card->base);\n\n        ccid_card_vscard_send_error(card,\n\n            scr_msg_header->reader_id, VSC_SUCCESS);\n\n\n    default:\n\n        printf(\"usb-ccid: chardev: unexpected message of type %X\\n\",\n\n               scr_msg_header->type);\n\n        ccid_card_vscard_send_error(card, scr_msg_header->reader_id,\n\n            VSC_GENERAL_ERROR);\n\n    }\n\n}", "idx": 3328, "_split": "valid", "_hash": "ac31f9b95069a97ac1858379c8687681"}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "static inline uint64_t do_fri(CPUPPCState *env, uint64_t arg,\n\n                              int rounding_mode)\n\n{\n\n    CPU_DoubleU farg;\n\n\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN round */\n\n        farg.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN |\n\n                                        POWERPC_EXCP_FP_VXCVI);\n\n    } else if (unlikely(float64_is_quiet_nan(farg.d) ||\n\n                        float64_is_infinity(farg.d))) {\n\n        /* qNan / infinity round */\n\n        farg.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXCVI);\n\n    } else {\n\n        set_float_rounding_mode(rounding_mode, &env->fp_status);\n\n        farg.ll = float64_round_to_int(farg.d, &env->fp_status);\n\n        /* Restore rounding mode from FPSCR */\n\n        fpscr_set_rounding_mode(env);\n\n    }\n\n    return farg.ll;\n\n}\n", "idx": 3339, "_split": "valid", "_hash": "0feea1fad0a45676fb6fc47571a77ff9"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int DMA_write_memory (int nchan, void *buf, int pos, int len)\n\n{\n\n    struct dma_regs *r = &dma_controllers[nchan > 3].regs[nchan & 3];\n\n    target_phys_addr_t addr = ((r->pageh & 0x7f) << 24) | (r->page << 16) | r->now[ADDR];\n\n\n\n    if (r->mode & 0x20) {\n\n        int i;\n\n        uint8_t *p = buf;\n\n\n\n        cpu_physical_memory_write (addr - pos - len, buf, len);\n\n        /* What about 16bit transfers? */\n\n        for (i = 0; i < len; i++) {\n\n            uint8_t b = p[len - i - 1];\n\n            p[i] = b;\n\n        }\n\n    }\n\n    else\n\n        cpu_physical_memory_write (addr + pos, buf, len);\n\n\n\n    return len;\n\n}\n", "idx": 3344, "_split": "valid", "_hash": "15ccf9772c311818d717dfaad33b6dd5"}
{"project": "qemu", "commit_id": "749763864208b14f100f1f8319aeb931134430fa", "target": 0, "func": "static void tcx_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n    TCXState *s = TCX(dev);\n\n    ram_addr_t vram_offset = 0;\n\n    int size, ret;\n\n    uint8_t *vram_base;\n\n    char *fcode_filename;\n\n\n\n    memory_region_init_ram(&s->vram_mem, OBJECT(s), \"tcx.vram\",\n\n                           s->vram_size * (1 + 4 + 4), &error_fatal);\n\n    vmstate_register_ram_global(&s->vram_mem);\n\n    memory_region_set_log(&s->vram_mem, true, DIRTY_MEMORY_VGA);\n\n    vram_base = memory_region_get_ram_ptr(&s->vram_mem);\n\n\n\n    /* 10/ROM : FCode ROM */\n\n    vmstate_register_ram_global(&s->rom);\n\n    fcode_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, TCX_ROM_FILE);\n\n    if (fcode_filename) {\n\n        ret = load_image_targphys(fcode_filename, s->prom_addr,\n\n                                  FCODE_MAX_ROM_SIZE);\n\n        g_free(fcode_filename);\n\n        if (ret < 0 || ret > FCODE_MAX_ROM_SIZE) {\n\n            error_report(\"tcx: could not load prom '%s'\", TCX_ROM_FILE);\n\n        }\n\n    }\n\n\n\n    /* 0/DFB8 : 8-bit plane */\n\n    s->vram = vram_base;\n\n    size = s->vram_size;\n\n    memory_region_init_alias(&s->vram_8bit, OBJECT(s), \"tcx.vram.8bit\",\n\n                             &s->vram_mem, vram_offset, size);\n\n    sysbus_init_mmio(sbd, &s->vram_8bit);\n\n    vram_offset += size;\n\n    vram_base += size;\n\n\n\n    /* 1/DFB24 : 24bit plane */\n\n    size = s->vram_size * 4;\n\n    s->vram24 = (uint32_t *)vram_base;\n\n    s->vram24_offset = vram_offset;\n\n    memory_region_init_alias(&s->vram_24bit, OBJECT(s), \"tcx.vram.24bit\",\n\n                             &s->vram_mem, vram_offset, size);\n\n    sysbus_init_mmio(sbd, &s->vram_24bit);\n\n    vram_offset += size;\n\n    vram_base += size;\n\n\n\n    /* 4/RDFB32 : Raw Framebuffer */\n\n    size = s->vram_size * 4;\n\n    s->cplane = (uint32_t *)vram_base;\n\n    s->cplane_offset = vram_offset;\n\n    memory_region_init_alias(&s->vram_cplane, OBJECT(s), \"tcx.vram.cplane\",\n\n                             &s->vram_mem, vram_offset, size);\n\n    sysbus_init_mmio(sbd, &s->vram_cplane);\n\n\n\n    /* 9/THC24bits : NetBSD writes here even with 8-bit display: dummy */\n\n    if (s->depth == 8) {\n\n        memory_region_init_io(&s->thc24, OBJECT(s), &tcx_dummy_ops, s,\n\n                              \"tcx.thc24\", TCX_THC_NREGS);\n\n        sysbus_init_mmio(sbd, &s->thc24);\n\n    }\n\n\n\n    sysbus_init_irq(sbd, &s->irq);\n\n\n\n    if (s->depth == 8) {\n\n        s->con = graphic_console_init(DEVICE(dev), 0, &tcx_ops, s);\n\n    } else {\n\n        s->con = graphic_console_init(DEVICE(dev), 0, &tcx24_ops, s);\n\n    }\n\n    s->thcmisc = 0;\n\n\n\n    qemu_console_resize(s->con, s->width, s->height);\n\n}\n", "idx": 3356, "_split": "valid", "_hash": "52436facb380afd756e0e46a7cf3a919"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "LinuxAioState *aio_get_linux_aio(AioContext *ctx)\n\n{\n\n    if (!ctx->linux_aio) {\n\n        ctx->linux_aio = laio_init();\n\n        laio_attach_aio_context(ctx->linux_aio, ctx);\n\n    }\n\n    return ctx->linux_aio;\n\n}\n", "idx": 3365, "_split": "valid", "_hash": "6599c4974e62cd97572a343cc93f4c6a"}
{"project": "qemu", "commit_id": "30fd3e27907dfd1c0c66cc1339657af1a2ce1d4b", "target": 0, "func": "static ssize_t qio_channel_command_readv(QIOChannel *ioc,\n\n                                         const struct iovec *iov,\n\n                                         size_t niov,\n\n                                         int **fds,\n\n                                         size_t *nfds,\n\n                                         Error **errp)\n\n{\n\n    QIOChannelCommand *cioc = QIO_CHANNEL_COMMAND(ioc);\n\n    ssize_t ret;\n\n\n\n retry:\n\n    ret = readv(cioc->readfd, iov, niov);\n\n    if (ret < 0) {\n\n        if (errno == EAGAIN ||\n\n            errno == EWOULDBLOCK) {\n\n            return QIO_CHANNEL_ERR_BLOCK;\n\n        }\n\n        if (errno == EINTR) {\n\n            goto retry;\n\n        }\n\n\n\n        error_setg_errno(errp, errno,\n\n                         \"Unable to read from command\");\n\n        return -1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 3436, "_split": "valid", "_hash": "4c0503a14097b018f7709cbf28e5744a"}
{"project": "qemu", "commit_id": "38e5756a614e9a492d1bb181166cd031bc87e159", "target": 0, "func": "vnc_display_setup_auth(VncDisplay *vs,\n\n                       bool password,\n\n                       bool sasl,\n\n                       bool websocket,\n\n                       Error **errp)\n\n{\n\n    /*\n\n     * We have a choice of 3 authentication options\n\n     *\n\n     *   1. none\n\n     *   2. vnc\n\n     *   3. sasl\n\n     *\n\n     * The channel can be run in 2 modes\n\n     *\n\n     *   1. clear\n\n     *   2. tls\n\n     *\n\n     * And TLS can use 2 types of credentials\n\n     *\n\n     *   1. anon\n\n     *   2. x509\n\n     *\n\n     * We thus have 9 possible logical combinations\n\n     *\n\n     *   1. clear + none\n\n     *   2. clear + vnc\n\n     *   3. clear + sasl\n\n     *   4. tls + anon + none\n\n     *   5. tls + anon + vnc\n\n     *   6. tls + anon + sasl\n\n     *   7. tls + x509 + none\n\n     *   8. tls + x509 + vnc\n\n     *   9. tls + x509 + sasl\n\n     *\n\n     * These need to be mapped into the VNC auth schemes\n\n     * in an appropriate manner. In regular VNC, all the\n\n     * TLS options get mapped into VNC_AUTH_VENCRYPT\n\n     * sub-auth types.\n\n     *\n\n     * In websockets, the https:// protocol already provides\n\n     * TLS support, so there is no need to make use of the\n\n     * VeNCrypt extension. Furthermore, websockets browser\n\n     * clients could not use VeNCrypt even if they wanted to,\n\n     * as they cannot control when the TLS handshake takes\n\n     * place. Thus there is no option but to rely on https://,\n\n     * meaning combinations 4->6 and 7->9 will be mapped to\n\n     * VNC auth schemes in the same way as combos 1->3.\n\n     *\n\n     * Regardless of fact that we have a different mapping to\n\n     * VNC auth mechs for plain VNC vs websockets VNC, the end\n\n     * result has the same security characteristics.\n\n     */\n\n    if (password) {\n\n        if (vs->tlscreds) {\n\n            vs->auth = VNC_AUTH_VENCRYPT;\n\n            if (websocket) {\n\n                vs->ws_tls = true;\n\n            }\n\n            if (object_dynamic_cast(OBJECT(vs->tlscreds),\n\n                                    TYPE_QCRYPTO_TLS_CREDS_X509)) {\n\n                VNC_DEBUG(\"Initializing VNC server with x509 password auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_X509VNC;\n\n            } else if (object_dynamic_cast(OBJECT(vs->tlscreds),\n\n                                           TYPE_QCRYPTO_TLS_CREDS_ANON)) {\n\n                VNC_DEBUG(\"Initializing VNC server with TLS password auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSVNC;\n\n            } else {\n\n                error_setg(errp,\n\n                           \"Unsupported TLS cred type %s\",\n\n                           object_get_typename(OBJECT(vs->tlscreds)));\n\n                return -1;\n\n            }\n\n        } else {\n\n            VNC_DEBUG(\"Initializing VNC server with password auth\\n\");\n\n            vs->auth = VNC_AUTH_VNC;\n\n            vs->subauth = VNC_AUTH_INVALID;\n\n        }\n\n        if (websocket) {\n\n            vs->ws_auth = VNC_AUTH_VNC;\n\n        } else {\n\n            vs->ws_auth = VNC_AUTH_INVALID;\n\n        }\n\n    } else if (sasl) {\n\n        if (vs->tlscreds) {\n\n            vs->auth = VNC_AUTH_VENCRYPT;\n\n            if (websocket) {\n\n                vs->ws_tls = true;\n\n            }\n\n            if (object_dynamic_cast(OBJECT(vs->tlscreds),\n\n                                    TYPE_QCRYPTO_TLS_CREDS_X509)) {\n\n                VNC_DEBUG(\"Initializing VNC server with x509 SASL auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_X509SASL;\n\n            } else if (object_dynamic_cast(OBJECT(vs->tlscreds),\n\n                                           TYPE_QCRYPTO_TLS_CREDS_ANON)) {\n\n                VNC_DEBUG(\"Initializing VNC server with TLS SASL auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSSASL;\n\n            } else {\n\n                error_setg(errp,\n\n                           \"Unsupported TLS cred type %s\",\n\n                           object_get_typename(OBJECT(vs->tlscreds)));\n\n                return -1;\n\n            }\n\n        } else {\n\n            VNC_DEBUG(\"Initializing VNC server with SASL auth\\n\");\n\n            vs->auth = VNC_AUTH_SASL;\n\n            vs->subauth = VNC_AUTH_INVALID;\n\n        }\n\n        if (websocket) {\n\n            vs->ws_auth = VNC_AUTH_SASL;\n\n        } else {\n\n            vs->ws_auth = VNC_AUTH_INVALID;\n\n        }\n\n    } else {\n\n        if (vs->tlscreds) {\n\n            vs->auth = VNC_AUTH_VENCRYPT;\n\n            if (websocket) {\n\n                vs->ws_tls = true;\n\n            }\n\n            if (object_dynamic_cast(OBJECT(vs->tlscreds),\n\n                                    TYPE_QCRYPTO_TLS_CREDS_X509)) {\n\n                VNC_DEBUG(\"Initializing VNC server with x509 no auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_X509NONE;\n\n            } else if (object_dynamic_cast(OBJECT(vs->tlscreds),\n\n                                           TYPE_QCRYPTO_TLS_CREDS_ANON)) {\n\n                VNC_DEBUG(\"Initializing VNC server with TLS no auth\\n\");\n\n                vs->subauth = VNC_AUTH_VENCRYPT_TLSNONE;\n\n            } else {\n\n                error_setg(errp,\n\n                           \"Unsupported TLS cred type %s\",\n\n                           object_get_typename(OBJECT(vs->tlscreds)));\n\n                return -1;\n\n            }\n\n        } else {\n\n            VNC_DEBUG(\"Initializing VNC server with no auth\\n\");\n\n            vs->auth = VNC_AUTH_NONE;\n\n            vs->subauth = VNC_AUTH_INVALID;\n\n        }\n\n        if (websocket) {\n\n            vs->ws_auth = VNC_AUTH_NONE;\n\n        } else {\n\n            vs->ws_auth = VNC_AUTH_INVALID;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 3437, "_split": "valid", "_hash": "ea83a0f0eaccfa58889caf0a7a655e57"}
{"project": "qemu", "commit_id": "016f5cf6ff465411733878a17c8f8febb7668321", "target": 1, "func": "void bdrv_flush(BlockDriverState *bs)\n{\n    if (bs->drv && bs->drv->bdrv_flush)\n        bs->drv->bdrv_flush(bs);", "idx": 3461, "_split": "valid", "_hash": "fd26c6f54b0ee92a0519739e016bfb43"}
{"project": "qemu", "commit_id": "fa4478d5c8b74a5f0c8b93cc00590ec007be5016", "target": 1, "func": "void block_job_cancel_sync(BlockJob *job)\n\n{\n\n    BlockDriverState *bs = job->bs;\n\n\n\n    assert(bs->job == job);\n\n    block_job_cancel(job);\n\n    while (bs->job != NULL && bs->job->busy) {\n\n        qemu_aio_wait();\n\n    }\n\n}\n", "idx": 3464, "_split": "valid", "_hash": "ec68a1136ef6300f52c8d3aafef7a662"}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void vtd_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    X86IOMMUClass *x86_class = X86_IOMMU_CLASS(klass);\n\n\n\n    dc->reset = vtd_reset;\n\n    dc->vmsd = &vtd_vmstate;\n\n    dc->props = vtd_properties;\n\n    dc->hotpluggable = false;\n\n    x86_class->realize = vtd_realize;\n\n    x86_class->int_remap = vtd_int_remap;\n\n\n\n\n\n\n}", "idx": 3477, "_split": "valid", "_hash": "6343273152a5c0f2085a16f14ec75be0"}
{"project": "qemu", "commit_id": "e2b72cb6e0443d90d7ab037858cb6834b6cca852", "target": 1, "func": "static void audio_capture(void *opaque, void *buf, int size)\n\n{\n\n    VncState *vs = opaque;\n\n\n\n    vnc_lock_output(vs);\n\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);\n\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);\n\n    vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_DATA);\n\n    vnc_write_u32(vs, size);\n\n    vnc_write(vs, buf, size);\n\n    vnc_unlock_output(vs);\n\n    vnc_flush(vs);\n\n}\n", "idx": 3494, "_split": "valid", "_hash": "c0d3dbade45bff2105323e14391251e7"}
{"project": "qemu", "commit_id": "540c79fec9e8b6a6582ec4c65aa2c4c5366e4b89", "target": 1, "func": "int inet_connect_opts(QemuOpts *opts, bool *in_progress, Error **errp)\n\n{\n\n    struct addrinfo ai,*res,*e;\n\n    const char *addr;\n\n    const char *port;\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int sock,rc;\n\n    bool block;\n\n\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;\n\n    ai.ai_family = PF_UNSPEC;\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    if (in_progress) {\n\n        *in_progress = false;\n\n    }\n\n\n\n    addr = qemu_opt_get(opts, \"host\");\n\n    port = qemu_opt_get(opts, \"port\");\n\n    block = qemu_opt_get_bool(opts, \"block\", 0);\n\n    if (addr == NULL || port == NULL) {\n\n        fprintf(stderr, \"inet_connect: host and/or port not specified\\n\");\n\n        error_set(errp, QERR_SOCKET_CREATE_FAILED);\n\n        return -1;\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"ipv4\", 0))\n\n        ai.ai_family = PF_INET;\n\n    if (qemu_opt_get_bool(opts, \"ipv6\", 0))\n\n        ai.ai_family = PF_INET6;\n\n\n\n    /* lookup */\n\n    if (0 != (rc = getaddrinfo(addr, port, &ai, &res))) {\n\n        fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port,\n\n                gai_strerror(rc));\n\n        error_set(errp, QERR_SOCKET_CREATE_FAILED);\n\n\treturn -1;\n\n    }\n\n\n\n    for (e = res; e != NULL; e = e->ai_next) {\n\n        if (getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,\n\n                            uaddr,INET6_ADDRSTRLEN,uport,32,\n\n                            NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n            fprintf(stderr,\"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n            continue;\n\n        }\n\n        sock = qemu_socket(e->ai_family, e->ai_socktype, e->ai_protocol);\n\n        if (sock < 0) {\n\n            fprintf(stderr,\"%s: socket(%s): %s\\n\", __FUNCTION__,\n\n            inet_strfamily(e->ai_family), strerror(errno));\n\n            continue;\n\n        }\n\n        setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on));\n\n        if (!block) {\n\n            socket_set_nonblock(sock);\n\n        }\n\n        /* connect to peer */\n\n        do {\n\n            rc = 0;\n\n            if (connect(sock, e->ai_addr, e->ai_addrlen) < 0) {\n\n                rc = -socket_error();\n\n            }\n\n        } while (rc == -EINTR);\n\n\n\n  #ifdef _WIN32\n\n        if (!block && (rc == -EINPROGRESS || rc == -EWOULDBLOCK\n\n                       || rc == -WSAEALREADY)) {\n\n  #else\n\n        if (!block && (rc == -EINPROGRESS)) {\n\n  #endif\n\n            if (in_progress) {\n\n                *in_progress = true;\n\n            }\n\n\n\n            error_set(errp, QERR_SOCKET_CONNECT_IN_PROGRESS);\n\n        } else if (rc < 0) {\n\n            if (NULL == e->ai_next)\n\n                fprintf(stderr, \"%s: connect(%s,%s,%s,%s): %s\\n\", __FUNCTION__,\n\n                        inet_strfamily(e->ai_family),\n\n                        e->ai_canonname, uaddr, uport, strerror(errno));\n\n            closesocket(sock);\n\n            continue;\n\n        }\n\n        freeaddrinfo(res);\n\n        return sock;\n\n    }\n\n    error_set(errp, QERR_SOCKET_CONNECT_FAILED);\n\n    freeaddrinfo(res);\n\n    return -1;\n\n}\n", "idx": 3546, "_split": "valid", "_hash": "f56f23bcd7a4a0c0da480c7c203bd2a5"}
{"project": "qemu", "commit_id": "4abf12f4ea866779b493ecf4606bd0b6d35f8348", "target": 1, "func": "static uint32_t rtl8139_io_readb(void *opaque, uint8_t addr)\n\n{\n\n    RTL8139State *s = opaque;\n\n    int ret;\n\n\n\n    addr &= 0xff;\n\n\n\n    switch (addr)\n\n    {\n\n        case MAC0 ... MAC0+5:\n\n            ret = s->phys[addr - MAC0];\n\n            break;\n\n        case MAC0+6 ... MAC0+7:\n\n            ret = 0;\n\n            break;\n\n        case MAR0 ... MAR0+7:\n\n            ret = s->mult[addr - MAR0];\n\n            break;\n\n        case ChipCmd:\n\n            ret = rtl8139_ChipCmd_read(s);\n\n            break;\n\n        case Cfg9346:\n\n            ret = rtl8139_Cfg9346_read(s);\n\n            break;\n\n        case Config0:\n\n            ret = rtl8139_Config0_read(s);\n\n            break;\n\n        case Config1:\n\n            ret = rtl8139_Config1_read(s);\n\n            break;\n\n        case Config3:\n\n            ret = rtl8139_Config3_read(s);\n\n            break;\n\n        case Config4:\n\n            ret = rtl8139_Config4_read(s);\n\n            break;\n\n        case Config5:\n\n            ret = rtl8139_Config5_read(s);\n\n            break;\n\n\n\n        case MediaStatus:\n\n            ret = 0xd0;\n\n            DPRINTF(\"MediaStatus read 0x%x\\n\", ret);\n\n            break;\n\n\n\n        case HltClk:\n\n            ret = s->clock_enabled;\n\n            DPRINTF(\"HltClk read 0x%x\\n\", ret);\n\n            break;\n\n\n\n        case PCIRevisionID:\n\n            ret = RTL8139_PCI_REVID;\n\n            DPRINTF(\"PCI Revision ID read 0x%x\\n\", ret);\n\n            break;\n\n\n\n        case TxThresh:\n\n            ret = s->TxThresh;\n\n            DPRINTF(\"C+ TxThresh read(b) val=0x%02x\\n\", ret);\n\n            break;\n\n\n\n        case 0x43: /* Part of TxConfig register. Windows driver tries to read it */\n\n            ret = s->TxConfig >> 24;\n\n            DPRINTF(\"RTL8139C TxConfig at 0x43 read(b) val=0x%02x\\n\", ret);\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"not implemented read(b) addr=0x%x\\n\", addr);\n\n            ret = 0;\n\n            break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 3600, "_split": "valid", "_hash": "aa7f3bf5ad9d5218fece7a28cc17996a"}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "void net_tx_pkt_update_ip_checksums(struct NetTxPkt *pkt)\n\n{\n\n    uint16_t csum;\n\n    uint32_t ph_raw_csum;\n\n    assert(pkt);\n\n    uint8_t gso_type = pkt->virt_hdr.gso_type & ~VIRTIO_NET_HDR_GSO_ECN;\n\n    struct ip_header *ip_hdr;\n\n\n\n    if (VIRTIO_NET_HDR_GSO_TCPV4 != gso_type &&\n\n        VIRTIO_NET_HDR_GSO_UDP != gso_type) {\n\n        return;\n\n    }\n\n\n\n    ip_hdr = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base;\n\n\n\n    if (pkt->payload_len + pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len >\n\n        ETH_MAX_IP_DGRAM_LEN) {\n\n        return;\n\n    }\n\n\n\n    ip_hdr->ip_len = cpu_to_be16(pkt->payload_len +\n\n        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len);\n\n\n\n    /* Calculate IP header checksum                    */\n\n    ip_hdr->ip_sum = 0;\n\n    csum = net_raw_checksum((uint8_t *)ip_hdr,\n\n        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len);\n\n    ip_hdr->ip_sum = cpu_to_be16(csum);\n\n\n\n    /* Calculate IP pseudo header checksum             */\n\n    ph_raw_csum = eth_calc_pseudo_hdr_csum(ip_hdr, pkt->payload_len);\n\n    csum = cpu_to_be16(~net_checksum_finish(ph_raw_csum));\n\n    iov_from_buf(&pkt->vec[NET_TX_PKT_PL_START_FRAG], pkt->payload_frags,\n\n                 pkt->virt_hdr.csum_offset, &csum, sizeof(csum));\n\n}\n", "idx": 3662, "_split": "valid", "_hash": "3285e56745d35ab808bbd460734db895"}
{"project": "qemu", "commit_id": "882b3b97697affb36ca3d174f42f846232008979", "target": 1, "func": "int css_create_css_image(uint8_t cssid, bool default_image)\n\n{\n\n    trace_css_new_image(cssid, default_image ? \"(default)\" : \"\");\n\n    if (cssid > MAX_CSSID) {\n\n        return -EINVAL;\n\n    }\n\n    if (channel_subsys.css[cssid]) {\n\n        return -EBUSY;\n\n    }\n\n    channel_subsys.css[cssid] = g_malloc0(sizeof(CssImage));\n\n    if (default_image) {\n\n        channel_subsys.default_cssid = cssid;\n\n    }\n\n    return 0;\n\n}\n", "idx": 3698, "_split": "valid", "_hash": "cdf4204865636c621dd75d61505f3359"}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "static void pxa2xx_pic_save(QEMUFile *f, void *opaque)\n\n{\n\n    PXA2xxPICState *s = (PXA2xxPICState *) opaque;\n\n    int i;\n\n\n\n    for (i = 0; i < 2; i ++)\n\n        qemu_put_be32s(f, &s->int_enabled[i]);\n\n    for (i = 0; i < 2; i ++)\n\n        qemu_put_be32s(f, &s->int_pending[i]);\n\n    for (i = 0; i < 2; i ++)\n\n        qemu_put_be32s(f, &s->is_fiq[i]);\n\n    qemu_put_be32s(f, &s->int_idle);\n\n    for (i = 0; i < PXA2XX_PIC_SRCS; i ++)\n\n        qemu_put_be32s(f, &s->priority[i]);\n\n}\n", "idx": 3747, "_split": "valid", "_hash": "c199233b957860fa42409e343020e2c4"}
{"project": "qemu", "commit_id": "185b43386ad999c80bdc58e41b87f05e5b3e8463", "target": 0, "func": "static int nbd_co_send_request(BDRVNBDState *s, struct nbd_request *request,\n\n                               struct iovec *iov, int offset)\n\n{\n\n    int rc, ret;\n\n\n\n    qemu_co_mutex_lock(&s->send_mutex);\n\n    s->send_coroutine = qemu_coroutine_self();\n\n    qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, nbd_restart_write,\n\n                            nbd_have_request, NULL, s);\n\n    rc = nbd_send_request(s->sock, request);\n\n    if (rc >= 0 && iov) {\n\n        ret = qemu_co_sendv(s->sock, iov, request->len, offset);\n\n        if (ret != request->len) {\n\n            errno = -EIO;\n\n            rc = -1;\n\n        }\n\n    }\n\n    qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL,\n\n                            nbd_have_request, NULL, s);\n\n    s->send_coroutine = NULL;\n\n    qemu_co_mutex_unlock(&s->send_mutex);\n\n    return rc;\n\n}\n", "idx": 3757, "_split": "valid", "_hash": "9a9e9c8b339e93c2fbfac2ba3515ce40"}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "void replay_save_input_event(InputEvent *evt)\n\n{\n\n    InputKeyEvent *key;\n\n    InputBtnEvent *btn;\n\n    InputMoveEvent *move;\n\n    replay_put_dword(evt->type);\n\n\n\n    switch (evt->type) {\n\n    case INPUT_EVENT_KIND_KEY:\n\n        key = evt->u.key;\n\n        replay_put_dword(key->key->type);\n\n\n\n        switch (key->key->type) {\n\n        case KEY_VALUE_KIND_NUMBER:\n\n            replay_put_qword(key->key->u.number);\n\n            replay_put_byte(key->down);\n\n            break;\n\n        case KEY_VALUE_KIND_QCODE:\n\n            replay_put_dword(key->key->u.qcode);\n\n            replay_put_byte(key->down);\n\n            break;\n\n        case KEY_VALUE_KIND__MAX:\n\n            /* keep gcc happy */\n\n            break;\n\n        }\n\n        break;\n\n    case INPUT_EVENT_KIND_BTN:\n\n        btn = evt->u.btn;\n\n        replay_put_dword(btn->button);\n\n        replay_put_byte(btn->down);\n\n        break;\n\n    case INPUT_EVENT_KIND_REL:\n\n        move = evt->u.rel;\n\n        replay_put_dword(move->axis);\n\n        replay_put_qword(move->value);\n\n        break;\n\n    case INPUT_EVENT_KIND_ABS:\n\n        move = evt->u.abs;\n\n        replay_put_dword(move->axis);\n\n        replay_put_qword(move->value);\n\n        break;\n\n    case INPUT_EVENT_KIND__MAX:\n\n        /* keep gcc happy */\n\n        break;\n\n    }\n\n}\n", "idx": 3761, "_split": "valid", "_hash": "e432ff42edfe46c7596a7c1195a54bf2"}
{"project": "qemu", "commit_id": "75dfd402a734e8080fa77a1bcf60ecc46e0e6158", "target": 0, "func": "static void internal_snapshot_prepare(BlkActionState *common,\n\n                                      Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    const char *device;\n\n    const char *name;\n\n    BlockBackend *blk;\n\n    BlockDriverState *bs;\n\n    QEMUSnapshotInfo old_sn, *sn;\n\n    bool ret;\n\n    qemu_timeval tv;\n\n    BlockdevSnapshotInternal *internal;\n\n    InternalSnapshotState *state;\n\n    int ret1;\n\n\n\n    g_assert(common->action->type ==\n\n             TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_INTERNAL_SYNC);\n\n    internal = common->action->u.blockdev_snapshot_internal_sync.data;\n\n    state = DO_UPCAST(InternalSnapshotState, common, common);\n\n\n\n    /* 1. parse input */\n\n    device = internal->device;\n\n    name = internal->name;\n\n\n\n    /* 2. check for validation */\n\n    if (action_check_completion_mode(common, errp) < 0) {\n\n        return;\n\n    }\n\n\n\n    blk = blk_by_name(device);\n\n    if (!blk) {\n\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n\n                  \"Device '%s' not found\", device);\n\n        return;\n\n    }\n\n\n\n    /* AioContext is released in .clean() */\n\n    state->aio_context = blk_get_aio_context(blk);\n\n    aio_context_acquire(state->aio_context);\n\n\n\n    if (!blk_is_available(blk)) {\n\n        error_setg(errp, QERR_DEVICE_HAS_NO_MEDIUM, device);\n\n        return;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    state->bs = bs;\n\n    bdrv_drained_begin(bs);\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_INTERNAL_SNAPSHOT, errp)) {\n\n        return;\n\n    }\n\n\n\n    if (bdrv_is_read_only(bs)) {\n\n        error_setg(errp, \"Device '%s' is read only\", device);\n\n        return;\n\n    }\n\n\n\n    if (!bdrv_can_snapshot(bs)) {\n\n        error_setg(errp, \"Block format '%s' used by device '%s' \"\n\n                   \"does not support internal snapshots\",\n\n                   bs->drv->format_name, device);\n\n        return;\n\n    }\n\n\n\n    if (!strlen(name)) {\n\n        error_setg(errp, \"Name is empty\");\n\n        return;\n\n    }\n\n\n\n    /* check whether a snapshot with name exist */\n\n    ret = bdrv_snapshot_find_by_id_and_name(bs, NULL, name, &old_sn,\n\n                                            &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    } else if (ret) {\n\n        error_setg(errp,\n\n                   \"Snapshot with name '%s' already exists on device '%s'\",\n\n                   name, device);\n\n        return;\n\n    }\n\n\n\n    /* 3. take the snapshot */\n\n    sn = &state->sn;\n\n    pstrcpy(sn->name, sizeof(sn->name), name);\n\n    qemu_gettimeofday(&tv);\n\n    sn->date_sec = tv.tv_sec;\n\n    sn->date_nsec = tv.tv_usec * 1000;\n\n    sn->vm_clock_nsec = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n\n\n    ret1 = bdrv_snapshot_create(bs, sn);\n\n    if (ret1 < 0) {\n\n        error_setg_errno(errp, -ret1,\n\n                         \"Failed to create snapshot '%s' on device '%s'\",\n\n                         name, device);\n\n        return;\n\n    }\n\n\n\n    /* 4. succeed, mark a snapshot is created */\n\n    state->created = true;\n\n}\n", "idx": 3771, "_split": "valid", "_hash": "d2a04c3313bbd509dcd3f5e0f806091f"}
{"project": "qemu", "commit_id": "4f2d3d705c1ae7dce29254e2c4645c84e77a74d4", "target": 0, "func": "void qdev_set_parent_bus(DeviceState *dev, BusState *bus)\n\n{\n\n    Property *prop;\n\n\n\n    if (qdev_hotplug) {\n\n        assert(bus->allow_hotplug);\n\n    }\n\n\n\n    dev->parent_bus = bus;\n\n    QTAILQ_INSERT_HEAD(&bus->children, dev, sibling);\n\n\n\n    qdev_prop_set_defaults(dev, dev->parent_bus->info->props);\n\n    for (prop = qdev_get_bus_info(dev)->props; prop && prop->name; prop++) {\n\n        qdev_property_add_legacy(dev, prop, NULL);\n\n        qdev_property_add_static(dev, prop, NULL);\n\n    }\n\n}\n", "idx": 3774, "_split": "valid", "_hash": "30dd536e282a94cb2edc1c92088d9860"}
{"project": "qemu", "commit_id": "e7ca56562990991bc614a43b9351ee0737f3045d", "target": 0, "func": "int object_property_get_enum(Object *obj, const char *name,\n\n                             const char *typename, Error **errp)\n\n{\n\n    Error *err = NULL;\n\n    StringOutputVisitor *sov;\n\n    Visitor *v;\n\n    char *str;\n\n    int ret;\n\n    ObjectProperty *prop = object_property_find(obj, name, errp);\n\n    EnumProperty *enumprop;\n\n\n\n    if (prop == NULL) {\n\n        return 0;\n\n    }\n\n\n\n    if (!g_str_equal(prop->type, typename)) {\n\n        error_setg(errp, \"Property %s on %s is not '%s' enum type\",\n\n                   name, object_class_get_name(\n\n                       object_get_class(obj)), typename);\n\n        return 0;\n\n    }\n\n\n\n    enumprop = prop->opaque;\n\n\n\n    sov = string_output_visitor_new(false);\n\n    object_property_get(obj, string_output_get_visitor(sov), name, &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        string_output_visitor_cleanup(sov);\n\n        return 0;\n\n    }\n\n    str = string_output_get_string(sov);\n\n    string_output_visitor_cleanup(sov);\n\n    v = string_input_visitor_new(str);\n\n    visit_type_enum(v, name, &ret, enumprop->strings, errp);\n\n\n\n    g_free(str);\n\n    visit_free(v);\n\n\n\n    return ret;\n\n}\n", "idx": 3786, "_split": "valid", "_hash": "8a0c7e651223b15e5815e05aa09baccb"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_sti_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    struct omap_sti_s *s = (struct omap_sti_s *) opaque;\n\n\n\n    if (size != 4) {\n\n        return omap_badwidth_read32(opaque, addr);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x00:\t/* STI_REVISION */\n\n        return 0x10;\n\n\n\n    case 0x10:\t/* STI_SYSCONFIG */\n\n        return s->sysconfig;\n\n\n\n    case 0x14:\t/* STI_SYSSTATUS / STI_RX_STATUS / XTI_SYSSTATUS */\n\n        return 0x00;\n\n\n\n    case 0x18:\t/* STI_IRQSTATUS */\n\n        return s->irqst;\n\n\n\n    case 0x1c:\t/* STI_IRQSETEN / STI_IRQCLREN */\n\n        return s->irqen;\n\n\n\n    case 0x24:\t/* STI_ER / STI_DR / XTI_TRACESELECT */\n\n    case 0x28:\t/* STI_RX_DR / XTI_RXDATA */\n\n        /* TODO */\n\n        return 0;\n\n\n\n    case 0x2c:\t/* STI_CLK_CTRL / XTI_SCLKCRTL */\n\n        return s->clkcontrol;\n\n\n\n    case 0x30:\t/* STI_SERIAL_CFG / XTI_SCONFIG */\n\n        return s->serial_config;\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 3789, "_split": "valid", "_hash": "5ed39d90f3129c4f50c3d3c6b2aa8ed6"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static int pollfds_fill(GArray *pollfds, fd_set *rfds, fd_set *wfds,\n\n                        fd_set *xfds)\n\n{\n\n    int nfds = -1;\n\n    int i;\n\n\n\n    for (i = 0; i < pollfds->len; i++) {\n\n        GPollFD *pfd = &g_array_index(pollfds, GPollFD, i);\n\n        int fd = pfd->fd;\n\n        int events = pfd->events;\n\n        if (events & G_IO_IN) {\n\n            FD_SET(fd, rfds);\n\n            nfds = MAX(nfds, fd);\n\n        }\n\n        if (events & G_IO_OUT) {\n\n            FD_SET(fd, wfds);\n\n            nfds = MAX(nfds, fd);\n\n        }\n\n        if (events & G_IO_PRI) {\n\n            FD_SET(fd, xfds);\n\n            nfds = MAX(nfds, fd);\n\n        }\n\n    }\n\n    return nfds;\n\n}\n", "idx": 3799, "_split": "valid", "_hash": "6bf213330079a01cfe27133f4ee9b197"}
{"project": "qemu", "commit_id": "dcc772e2f2b7c2a68644133fea2b874f6751a57b", "target": 0, "func": "void qemu_bh_schedule_idle(QEMUBH *bh)\n\n{\n\n    if (bh->scheduled)\n\n        return;\n\n    bh->scheduled = 1;\n\n    bh->idle = 1;\n\n}\n", "idx": 3800, "_split": "valid", "_hash": "19c68abe47a866d63994bc18ad03948e"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void stl_phys(target_phys_addr_t addr, uint32_t val)\n\n{\n\n    stl_phys_internal(addr, val, DEVICE_NATIVE_ENDIAN);\n\n}\n", "idx": 3814, "_split": "valid", "_hash": "60c9ecf7cd09b10e726101eb7473c197"}
{"project": "qemu", "commit_id": "907e7c94d1660cd477741eb449147d4fe243b02f", "target": 0, "func": "build_madt(GArray *table_data, GArray *linker, PCMachineState *pcms,\n\n           AcpiCpuInfo *cpu)\n\n{\n\n    int madt_start = table_data->len;\n\n\n\n    AcpiMultipleApicTable *madt;\n\n    AcpiMadtIoApic *io_apic;\n\n    AcpiMadtIntsrcovr *intsrcovr;\n\n    AcpiMadtLocalNmi *local_nmi;\n\n    int i;\n\n\n\n    madt = acpi_data_push(table_data, sizeof *madt);\n\n    madt->local_apic_address = cpu_to_le32(APIC_DEFAULT_ADDRESS);\n\n    madt->flags = cpu_to_le32(1);\n\n\n\n    for (i = 0; i < pcms->apic_id_limit; i++) {\n\n        AcpiMadtProcessorApic *apic = acpi_data_push(table_data, sizeof *apic);\n\n        apic->type = ACPI_APIC_PROCESSOR;\n\n        apic->length = sizeof(*apic);\n\n        apic->processor_id = i;\n\n        apic->local_apic_id = i;\n\n        if (test_bit(i, cpu->found_cpus)) {\n\n            apic->flags = cpu_to_le32(1);\n\n        } else {\n\n            apic->flags = cpu_to_le32(0);\n\n        }\n\n    }\n\n    io_apic = acpi_data_push(table_data, sizeof *io_apic);\n\n    io_apic->type = ACPI_APIC_IO;\n\n    io_apic->length = sizeof(*io_apic);\n\n#define ACPI_BUILD_IOAPIC_ID 0x0\n\n    io_apic->io_apic_id = ACPI_BUILD_IOAPIC_ID;\n\n    io_apic->address = cpu_to_le32(IO_APIC_DEFAULT_ADDRESS);\n\n    io_apic->interrupt = cpu_to_le32(0);\n\n\n\n    if (pcms->apic_xrupt_override) {\n\n        intsrcovr = acpi_data_push(table_data, sizeof *intsrcovr);\n\n        intsrcovr->type   = ACPI_APIC_XRUPT_OVERRIDE;\n\n        intsrcovr->length = sizeof(*intsrcovr);\n\n        intsrcovr->source = 0;\n\n        intsrcovr->gsi    = cpu_to_le32(2);\n\n        intsrcovr->flags  = cpu_to_le16(0); /* conforms to bus specifications */\n\n    }\n\n    for (i = 1; i < 16; i++) {\n\n#define ACPI_BUILD_PCI_IRQS ((1<<5) | (1<<9) | (1<<10) | (1<<11))\n\n        if (!(ACPI_BUILD_PCI_IRQS & (1 << i))) {\n\n            /* No need for a INT source override structure. */\n\n            continue;\n\n        }\n\n        intsrcovr = acpi_data_push(table_data, sizeof *intsrcovr);\n\n        intsrcovr->type   = ACPI_APIC_XRUPT_OVERRIDE;\n\n        intsrcovr->length = sizeof(*intsrcovr);\n\n        intsrcovr->source = i;\n\n        intsrcovr->gsi    = cpu_to_le32(i);\n\n        intsrcovr->flags  = cpu_to_le16(0xd); /* active high, level triggered */\n\n    }\n\n\n\n    local_nmi = acpi_data_push(table_data, sizeof *local_nmi);\n\n    local_nmi->type         = ACPI_APIC_LOCAL_NMI;\n\n    local_nmi->length       = sizeof(*local_nmi);\n\n    local_nmi->processor_id = 0xff; /* all processors */\n\n    local_nmi->flags        = cpu_to_le16(0);\n\n    local_nmi->lint         = 1; /* ACPI_LINT1 */\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)(table_data->data + madt_start), \"APIC\",\n\n                 table_data->len - madt_start, 1, NULL, NULL);\n\n}\n", "idx": 3819, "_split": "valid", "_hash": "4bd489a9d46128f8f68c88db26498974"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void multiwrite_user_cb(MultiwriteCB *mcb)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < mcb->num_callbacks; i++) {\n\n        mcb->callbacks[i].cb(mcb->callbacks[i].opaque, mcb->error);\n\n        if (mcb->callbacks[i].free_qiov) {\n\n            qemu_iovec_destroy(mcb->callbacks[i].free_qiov);\n\n        }\n\n        g_free(mcb->callbacks[i].free_qiov);\n\n    }\n\n}\n", "idx": 3858, "_split": "valid", "_hash": "e07a74d10420094facc6409137175739"}
{"project": "qemu", "commit_id": "4fd37a98d1248bae54a9f71ee1c252d2b2f1efd5", "target": 0, "func": "char *get_boot_devices_list(uint32_t *size)\n\n{\n\n    FWBootEntry *i;\n\n    uint32_t total = 0;\n\n    char *list = NULL;\n\n\n\n    QTAILQ_FOREACH(i, &fw_boot_order, link) {\n\n        char *devpath = NULL, *bootpath;\n\n        int len;\n\n\n\n        if (i->dev) {\n\n            devpath = qdev_get_fw_dev_path(i->dev);\n\n            assert(devpath);\n\n        }\n\n\n\n        if (i->suffix && devpath) {\n\n            bootpath = qemu_malloc(strlen(devpath) + strlen(i->suffix) + 1);\n\n            sprintf(bootpath, \"%s%s\", devpath, i->suffix);\n\n            qemu_free(devpath);\n\n        } else if (devpath) {\n\n            bootpath = devpath;\n\n        } else {\n\n            bootpath = strdup(i->suffix);\n\n            assert(bootpath);\n\n        }\n\n\n\n        if (total) {\n\n            list[total-1] = '\\n';\n\n        }\n\n        len = strlen(bootpath) + 1;\n\n        list = qemu_realloc(list, total + len);\n\n        memcpy(&list[total], bootpath, len);\n\n        total += len;\n\n        qemu_free(bootpath);\n\n    }\n\n\n\n    *size = total;\n\n\n\n    return list;\n\n}\n", "idx": 3859, "_split": "valid", "_hash": "92128cdce3b81b063a496a89553e8d93"}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static void framebuffer_update_request(VncState *vs, int incremental,\n\n                                       int x_position, int y_position,\n\n                                       int w, int h)\n\n{\n\n    int i;\n\n    const size_t width = surface_width(vs->vd->ds) / VNC_DIRTY_PIXELS_PER_BIT;\n\n    const size_t height = surface_height(vs->vd->ds);\n\n\n\n    if (y_position > height) {\n\n        y_position = height;\n\n    }\n\n    if (y_position + h >= height) {\n\n        h = height - y_position;\n\n    }\n\n\n\n    vs->need_update = 1;\n\n    if (!incremental) {\n\n        vs->force_update = 1;\n\n        for (i = 0; i < h; i++) {\n\n            bitmap_set(vs->dirty[y_position + i], 0, width);\n\n            bitmap_clear(vs->dirty[y_position + i], width,\n\n                         VNC_DIRTY_BITS - width);\n\n        }\n\n    }\n\n}\n", "idx": 3907, "_split": "valid", "_hash": "d21153b12d0626d7ca1177812203df02"}
{"project": "qemu", "commit_id": "e7658fcc4c29a29c578acde26f7714023b93b46e", "target": 1, "func": "static int tpm_passthrough_unix_write(int fd, const uint8_t *buf, uint32_t len)\n\n{\n\n    int ret, remain;\n\n\n\n    remain = len;\n\n    while (len > 0) {\n\n        ret = write(fd, buf, remain);\n\n        if (ret < 0) {\n\n            if (errno != EINTR && errno != EAGAIN) {\n\n                return -1;\n\n            }\n\n        } else if (ret == 0) {\n\n            break;\n\n        } else {\n\n            buf += ret;\n\n            remain -= ret;\n\n        }\n\n    }\n\n    return len - remain;\n\n}\n", "idx": 3917, "_split": "valid", "_hash": "ca5fcbd26b38ae7107811605c7066aec"}
{"project": "qemu", "commit_id": "7eff518b6c91bdd62710dd9868ec7a17bd6f1434", "target": 1, "func": "static struct iovec *lock_iovec(int type, abi_ulong target_addr,\n\n                                int count, int copy)\n\n{\n\n    struct target_iovec *target_vec;\n\n    struct iovec *vec;\n\n    abi_ulong total_len, max_len;\n\n    int i;\n\n    int err = 0;\n\n    bool bad_address = false;\n\n\n\n    if (count == 0) {\n\n        errno = 0;\n\n        return NULL;\n\n\n    if (count < 0 || count > IOV_MAX) {\n\n        errno = EINVAL;\n\n        return NULL;\n\n\n\n\n    vec = calloc(count, sizeof(struct iovec));\n\n    if (vec == NULL) {\n\n        errno = ENOMEM;\n\n        return NULL;\n\n\n\n\n    target_vec = lock_user(VERIFY_READ, target_addr,\n\n                           count * sizeof(struct target_iovec), 1);\n\n    if (target_vec == NULL) {\n\n        err = EFAULT;\n\n        goto fail2;\n\n\n\n\n    /* ??? If host page size > target page size, this will result in a\n\n       value larger than what we can actually support.  */\n\n    max_len = 0x7fffffff & TARGET_PAGE_MASK;\n\n    total_len = 0;\n\n\n\n    for (i = 0; i < count; i++) {\n\n        abi_ulong base = tswapal(target_vec[i].iov_base);\n\n        abi_long len = tswapal(target_vec[i].iov_len);\n\n\n\n        if (len < 0) {\n\n            err = EINVAL;\n\n            goto fail;\n\n        } else if (len == 0) {\n\n            /* Zero length pointer is ignored.  */\n\n            vec[i].iov_base = 0;\n\n        } else {\n\n            vec[i].iov_base = lock_user(type, base, len, copy);\n\n            /* If the first buffer pointer is bad, this is a fault.  But\n\n             * subsequent bad buffers will result in a partial write; this\n\n             * is realized by filling the vector with null pointers and\n\n             * zero lengths. */\n\n            if (!vec[i].iov_base) {\n\n                if (i == 0) {\n\n                    err = EFAULT;\n\n                    goto fail;\n\n                } else {\n\n                    bad_address = true;\n\n\n\n            if (bad_address) {\n\n                len = 0;\n\n\n            if (len > max_len - total_len) {\n\n                len = max_len - total_len;\n\n\n\n        vec[i].iov_len = len;\n\n        total_len += len;\n\n\n\n\n    unlock_user(target_vec, target_addr, 0);\n\n    return vec;\n\n\n\n fail:\n\n\n\n\n\n\n    unlock_user(target_vec, target_addr, 0);\n\n fail2:\n\n    free(vec);\n\n    errno = err;\n\n    return NULL;\n", "idx": 3955, "_split": "valid", "_hash": "039cc802f524d0ad50170f60834fc028"}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void cris_cpu_initfn(Object *obj)\n\n{\n\n    CPUState *cs = CPU(obj);\n\n    CRISCPU *cpu = CRIS_CPU(obj);\n\n    CRISCPUClass *ccc = CRIS_CPU_GET_CLASS(obj);\n\n    CPUCRISState *env = &cpu->env;\n\n    static bool tcg_initialized;\n\n\n\n    cs->env_ptr = env;\n\n    cpu_exec_init(cs, &error_abort);\n\n\n\n    env->pregs[PR_VR] = ccc->vr;\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    /* IRQ and NMI lines.  */\n\n    qdev_init_gpio_in(DEVICE(cpu), cris_cpu_set_irq, 2);\n\n#endif\n\n\n\n    if (tcg_enabled() && !tcg_initialized) {\n\n        tcg_initialized = true;\n\n        if (env->pregs[PR_VR] < 32) {\n\n            cris_initialize_crisv10_tcg();\n\n        } else {\n\n            cris_initialize_tcg();\n\n        }\n\n    }\n\n}\n", "idx": 3968, "_split": "valid", "_hash": "69d2dc5e16ba6b3a0fe4497b9120f1e3"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void exec_start_incoming_migration(const char *command, Error **errp)\n\n{\n\n    QEMUFile *f;\n\n\n\n    DPRINTF(\"Attempting to start an incoming migration\\n\");\n\n    f = qemu_popen_cmd(command, \"r\");\n\n    if(f == NULL) {\n\n        error_setg_errno(errp, errno, \"failed to popen the migration source\");\n\n        return;\n\n    }\n\n\n\n    qemu_set_fd_handler2(qemu_get_fd(f), NULL,\n\n\t\t\t exec_accept_incoming_migration, NULL, f);\n\n}\n", "idx": 3992, "_split": "valid", "_hash": "70e4bbd11a6d2fd7cf0bd962d50df0a7"}
{"project": "qemu", "commit_id": "6658ffb81ee56a510d7d77025872a508a9adce3a", "target": 1, "func": "static void io_mem_init(void)\n\n{\n\n    cpu_register_io_memory(IO_MEM_ROM >> IO_MEM_SHIFT, error_mem_read, unassigned_mem_write, NULL);\n\n    cpu_register_io_memory(IO_MEM_UNASSIGNED >> IO_MEM_SHIFT, unassigned_mem_read, unassigned_mem_write, NULL);\n\n    cpu_register_io_memory(IO_MEM_NOTDIRTY >> IO_MEM_SHIFT, error_mem_read, notdirty_mem_write, NULL);\n\n    io_mem_nb = 5;\n\n\n\n\n\n\n\n    /* alloc dirty bits array */\n\n    phys_ram_dirty = qemu_vmalloc(phys_ram_size >> TARGET_PAGE_BITS);\n\n    memset(phys_ram_dirty, 0xff, phys_ram_size >> TARGET_PAGE_BITS);\n\n}", "idx": 3994, "_split": "valid", "_hash": "a6f9ee8d5781c183d4db4d0603aad411"}
{"project": "qemu", "commit_id": "46abb8124006887d071921c5e657eeec3c50a9e2", "target": 1, "func": "static void virtio_balloon_device_realize(DeviceState *dev, Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    VirtIOBalloon *s = VIRTIO_BALLOON(dev);\n\n    int ret;\n\n\n\n    virtio_init(vdev, \"virtio-balloon\", VIRTIO_ID_BALLOON,\n\n                sizeof(struct virtio_balloon_config));\n\n\n\n    ret = qemu_add_balloon_handler(virtio_balloon_to_target,\n\n                                   virtio_balloon_stat, s);\n\n\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Adding balloon handler failed\");\n\n        virtio_cleanup(vdev);\n\n        return;\n\n    }\n\n\n\n    s->ivq = virtio_add_queue(vdev, 128, virtio_balloon_handle_output);\n\n    s->dvq = virtio_add_queue(vdev, 128, virtio_balloon_handle_output);\n\n    s->svq = virtio_add_queue(vdev, 128, virtio_balloon_receive_stats);\n\n\n\n    reset_stats(s);\n\n\n\n    register_savevm(dev, \"virtio-balloon\", -1, 1,\n\n                    virtio_balloon_save, virtio_balloon_load, s);\n\n\n\n    object_property_add(OBJECT(dev), \"guest-stats\", \"guest statistics\",\n\n                        balloon_stats_get_all, NULL, NULL, s, NULL);\n\n\n\n    object_property_add(OBJECT(dev), \"guest-stats-polling-interval\", \"int\",\n\n                        balloon_stats_get_poll_interval,\n\n                        balloon_stats_set_poll_interval,\n\n                        NULL, s, NULL);\n\n}\n", "idx": 4061, "_split": "valid", "_hash": "0cd0b0f75e7d676ef48e5d81b34dc4bd"}
{"project": "qemu", "commit_id": "54c16572a03e3c9c5694653361f9bfa3959fcb59", "target": 1, "func": "static int qcow_snapshot_create(BlockDriverState *bs,\n\n                                QEMUSnapshotInfo *sn_info)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowSnapshot *snapshots1, sn1, *sn = &sn1;\n\n    int i, ret;\n\n    uint64_t *l1_table = NULL;\n\n\n\n    memset(sn, 0, sizeof(*sn));\n\n\n\n    if (sn_info->id_str[0] == '\\0') {\n\n        /* compute a new id */\n\n        find_new_snapshot_id(bs, sn_info->id_str, sizeof(sn_info->id_str));\n\n    }\n\n\n\n    /* check that the ID is unique */\n\n    if (find_snapshot_by_id(bs, sn_info->id_str) >= 0)\n\n        return -ENOENT;\n\n\n\n    sn->id_str = qemu_strdup(sn_info->id_str);\n\n    if (!sn->id_str)\n\n        goto fail;\n\n    sn->name = qemu_strdup(sn_info->name);\n\n    if (!sn->name)\n\n        goto fail;\n\n    sn->vm_state_size = sn_info->vm_state_size;\n\n    sn->date_sec = sn_info->date_sec;\n\n    sn->date_nsec = sn_info->date_nsec;\n\n    sn->vm_clock_nsec = sn_info->vm_clock_nsec;\n\n\n\n    ret = update_snapshot_refcount(bs, s->l1_table_offset, s->l1_size, 1);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    /* create the L1 table of the snapshot */\n\n    sn->l1_table_offset = alloc_clusters(bs, s->l1_size * sizeof(uint64_t));\n\n    sn->l1_size = s->l1_size;\n\n\n\n    l1_table = qemu_malloc(s->l1_size * sizeof(uint64_t));\n\n    if (!l1_table)\n\n        goto fail;\n\n    for(i = 0; i < s->l1_size; i++) {\n\n        l1_table[i] = cpu_to_be64(s->l1_table[i]);\n\n    }\n\n    if (bdrv_pwrite(s->hd, sn->l1_table_offset,\n\n                    l1_table, s->l1_size * sizeof(uint64_t)) !=\n\n        (s->l1_size * sizeof(uint64_t)))\n\n        goto fail;\n\n    qemu_free(l1_table);\n\n    l1_table = NULL;\n\n\n\n    snapshots1 = qemu_malloc((s->nb_snapshots + 1) * sizeof(QCowSnapshot));\n\n    if (!snapshots1)\n\n        goto fail;\n\n    memcpy(snapshots1, s->snapshots, s->nb_snapshots * sizeof(QCowSnapshot));\n\n\n    s->snapshots = snapshots1;\n\n    s->snapshots[s->nb_snapshots++] = *sn;\n\n\n\n    if (qcow_write_snapshots(bs) < 0)\n\n        goto fail;\n\n#ifdef DEBUG_ALLOC\n\n    check_refcounts(bs);\n\n#endif\n\n    return 0;\n\n fail:\n\n    qemu_free(sn->name);\n\n    qemu_free(l1_table);\n\n    return -1;\n\n}", "idx": 4072, "_split": "valid", "_hash": "0dc044dae39683a93413fc16791debd7"}
{"project": "qemu", "commit_id": "cd9953f720e1d57cfa86bc0882abced45ba96d3c", "target": 1, "func": "static int resize_peers(IVShmemState *s, int new_min_size)\n\n{\n\n\n\n    int j, old_size;\n\n\n\n    /* limit number of max peers */\n\n    if (new_min_size <= 0 || new_min_size > IVSHMEM_MAX_PEERS) {\n\n        return -1;\n\n    }\n\n    if (new_min_size <= s->nb_peers) {\n\n        return 0;\n\n    }\n\n\n\n    old_size = s->nb_peers;\n\n    s->nb_peers = new_min_size;\n\n\n\n    IVSHMEM_DPRINTF(\"bumping storage to %d peers\\n\", s->nb_peers);\n\n\n\n    s->peers = g_realloc(s->peers, s->nb_peers * sizeof(Peer));\n\n\n\n    for (j = old_size; j < s->nb_peers; j++) {\n\n        s->peers[j].eventfds = g_new0(EventNotifier, s->vectors);\n\n        s->peers[j].nb_eventfds = 0;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4076, "_split": "valid", "_hash": "b64b4332608ea66a66310d99c84ef972"}
{"project": "qemu", "commit_id": "caffdac363801cd2cf2bf01ad013a8c1e1e43800", "target": 1, "func": "static int s390_virtio_blk_init(VirtIOS390Device *s390_dev)\n\n{\n\n    VirtIOBlkS390 *dev = VIRTIO_BLK_S390(s390_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n    virtio_blk_set_conf(vdev, &(dev->blk));\n\n    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));\n\n    if (qdev_init(vdev) < 0) {\n\n        return -1;\n\n    }\n\n    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));\n\n}\n", "idx": 4081, "_split": "valid", "_hash": "6e8eb638c260fc33da3f3f7317d6e227"}
{"project": "qemu", "commit_id": "52e60cdd342dc48116edb81b443ba8c0a0c6f1a3", "target": 1, "func": "static void aarch64_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n\n\n\n    cc->dump_state = aarch64_cpu_dump_state;\n\n    cc->set_pc = aarch64_cpu_set_pc;\n\n    cc->gdb_read_register = aarch64_cpu_gdb_read_register;\n\n    cc->gdb_write_register = aarch64_cpu_gdb_write_register;\n\n    cc->gdb_num_core_regs = 34;\n\n    cc->gdb_core_xml_file = \"aarch64-core.xml\";\n\n}", "idx": 4090, "_split": "valid", "_hash": "0a94e45901f5f3ecbf3b764733952ca5"}
{"project": "qemu", "commit_id": "e81a982aa5398269a2cc344091ffa4930bdd242f", "target": 0, "func": "void ppc_hw_interrupt(CPUPPCState *env)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n    int hdice;\n\n#if 0\n\n    CPUState *cs = CPU(cpu);\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"%s: %p pending %08x req %08x me %d ee %d\\n\",\n\n                  __func__, env, env->pending_interrupts,\n\n                  cs->interrupt_request, (int)msr_me, (int)msr_ee);\n\n#endif\n\n    /* External reset */\n\n    if (env->pending_interrupts & (1 << PPC_INTERRUPT_RESET)) {\n\n        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_RESET);\n\n        powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_RESET);\n\n        return;\n\n    }\n\n    /* Machine check exception */\n\n    if (env->pending_interrupts & (1 << PPC_INTERRUPT_MCK)) {\n\n        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_MCK);\n\n        powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_MCHECK);\n\n        return;\n\n    }\n\n#if 0 /* TODO */\n\n    /* External debug exception */\n\n    if (env->pending_interrupts & (1 << PPC_INTERRUPT_DEBUG)) {\n\n        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DEBUG);\n\n        powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_DEBUG);\n\n        return;\n\n    }\n\n#endif\n\n    if (0) {\n\n        /* XXX: find a suitable condition to enable the hypervisor mode */\n\n        hdice = env->spr[SPR_LPCR] & 1;\n\n    } else {\n\n        hdice = 0;\n\n    }\n\n    if ((msr_ee != 0 || msr_hv == 0 || msr_pr != 0) && hdice != 0) {\n\n        /* Hypervisor decrementer exception */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_HDECR)) {\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_HDECR);\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_HDECR);\n\n            return;\n\n        }\n\n    }\n\n    if (msr_ce != 0) {\n\n        /* External critical interrupt */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_CEXT)) {\n\n            /* Taking a critical external interrupt does not clear the external\n\n             * critical interrupt status\n\n             */\n\n#if 0\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_CEXT);\n\n#endif\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_CRITICAL);\n\n            return;\n\n        }\n\n    }\n\n    if (msr_ee != 0) {\n\n        /* Watchdog timer on embedded PowerPC */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_WDT)) {\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_WDT);\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_WDT);\n\n            return;\n\n        }\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_CDOORBELL)) {\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_CDOORBELL);\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_DOORCI);\n\n            return;\n\n        }\n\n        /* Fixed interval timer on embedded PowerPC */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_FIT)) {\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_FIT);\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_FIT);\n\n            return;\n\n        }\n\n        /* Programmable interval timer on embedded PowerPC */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_PIT)) {\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_PIT);\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_PIT);\n\n            return;\n\n        }\n\n        /* Decrementer exception */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_DECR)) {\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DECR);\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_DECR);\n\n            return;\n\n        }\n\n        /* External interrupt */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_EXT)) {\n\n            /* Taking an external interrupt does not clear the external\n\n             * interrupt status\n\n             */\n\n#if 0\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_EXT);\n\n#endif\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_EXTERNAL);\n\n            return;\n\n        }\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_DOORBELL)) {\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DOORBELL);\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_DOORI);\n\n            return;\n\n        }\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_PERFM)) {\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_PERFM);\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_PERFM);\n\n            return;\n\n        }\n\n        /* Thermal interrupt */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_THERM)) {\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_THERM);\n\n            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_THERM);\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 4102, "_split": "valid", "_hash": "e1c47c8c8fea1e873be8144676998dbe"}
{"project": "qemu", "commit_id": "a980a065fb5e86d6dec337e6cb6ff432f1a143c9", "target": 0, "func": "static int usb_net_handle_dataout(USBNetState *s, USBPacket *p)\n\n{\n\n    int ret = p->len;\n\n    int sz = sizeof(s->out_buf) - s->out_ptr;\n\n    struct rndis_packet_msg_type *msg =\n\n            (struct rndis_packet_msg_type *) s->out_buf;\n\n    uint32_t len;\n\n\n\n#ifdef TRAFFIC_DEBUG\n\n    fprintf(stderr, \"usbnet: data out len %u\\n\", p->len);\n\n    {\n\n        int i;\n\n        fprintf(stderr, \":\");\n\n        for (i = 0; i < p->len; i++) {\n\n            if (!(i & 15))\n\n                fprintf(stderr, \"\\n%04x:\", i);\n\n            fprintf(stderr, \" %02x\", p->data[i]);\n\n        }\n\n        fprintf(stderr, \"\\n\\n\");\n\n    }\n\n#endif\n\n\n\n    if (sz > ret)\n\n        sz = ret;\n\n    memcpy(&s->out_buf[s->out_ptr], p->data, sz);\n\n    s->out_ptr += sz;\n\n\n\n    if (!s->rndis) {\n\n        if (ret < 64) {\n\n            qemu_send_packet(&s->nic->nc, s->out_buf, s->out_ptr);\n\n            s->out_ptr = 0;\n\n        }\n\n        return ret;\n\n    }\n\n    len = le32_to_cpu(msg->MessageLength);\n\n    if (s->out_ptr < 8 || s->out_ptr < len)\n\n        return ret;\n\n    if (le32_to_cpu(msg->MessageType) == RNDIS_PACKET_MSG) {\n\n        uint32_t offs = 8 + le32_to_cpu(msg->DataOffset);\n\n        uint32_t size = le32_to_cpu(msg->DataLength);\n\n        if (offs + size <= len)\n\n            qemu_send_packet(&s->nic->nc, s->out_buf + offs, size);\n\n    }\n\n    s->out_ptr -= len;\n\n    memmove(s->out_buf, &s->out_buf[len], s->out_ptr);\n\n\n\n    return ret;\n\n}\n", "idx": 4112, "_split": "valid", "_hash": "e62032e510327c7260b8d34e05271224"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_get_backing_file_depth(BlockDriverState *bs)\n\n{\n\n    if (!bs->drv) {\n\n        return 0;\n\n    }\n\n\n\n    if (!bs->backing_hd) {\n\n        return 0;\n\n    }\n\n\n\n    return 1 + bdrv_get_backing_file_depth(bs->backing_hd);\n\n}\n", "idx": 4118, "_split": "valid", "_hash": "83c1732f045f80d6811b5d77f551fa49"}
{"project": "qemu", "commit_id": "369f7de9d57e4dd2f312255fc12271d5749c0a4e", "target": 0, "func": "static int parallels_create(const char *filename, QemuOpts *opts, Error **errp)\n\n{\n\n    int64_t total_size, cl_size;\n\n    uint8_t tmp[BDRV_SECTOR_SIZE];\n\n    Error *local_err = NULL;\n\n    BlockDriverState *file;\n\n    uint32_t cat_entries, cat_sectors;\n\n    ParallelsHeader header;\n\n    int ret;\n\n\n\n    total_size = ROUND_UP(qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0),\n\n                          BDRV_SECTOR_SIZE);\n\n    cl_size = ROUND_UP(qemu_opt_get_size_del(opts, BLOCK_OPT_CLUSTER_SIZE,\n\n                          DEFAULT_CLUSTER_SIZE), BDRV_SECTOR_SIZE);\n\n\n\n    ret = bdrv_create_file(filename, opts, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        return ret;\n\n    }\n\n\n\n    file = NULL;\n\n    ret = bdrv_open(&file, filename, NULL, NULL,\n\n                    BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        return ret;\n\n    }\n\n    ret = bdrv_truncate(file, 0);\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\n    cat_entries = DIV_ROUND_UP(total_size, cl_size);\n\n    cat_sectors = DIV_ROUND_UP(cat_entries * sizeof(uint32_t) +\n\n                               sizeof(ParallelsHeader), cl_size);\n\n    cat_sectors = (cat_sectors *  cl_size) >> BDRV_SECTOR_BITS;\n\n\n\n    memset(&header, 0, sizeof(header));\n\n    memcpy(header.magic, HEADER_MAGIC2, sizeof(header.magic));\n\n    header.version = cpu_to_le32(HEADER_VERSION);\n\n    /* don't care much about geometry, it is not used on image level */\n\n    header.heads = cpu_to_le32(16);\n\n    header.cylinders = cpu_to_le32(total_size / BDRV_SECTOR_SIZE / 16 / 32);\n\n    header.tracks = cpu_to_le32(cl_size >> BDRV_SECTOR_BITS);\n\n    header.catalog_entries = cpu_to_le32(cat_entries);\n\n    header.nb_sectors = cpu_to_le64(DIV_ROUND_UP(total_size, BDRV_SECTOR_SIZE));\n\n    header.data_off = cpu_to_le32(cat_sectors);\n\n\n\n    /* write all the data */\n\n    memset(tmp, 0, sizeof(tmp));\n\n    memcpy(tmp, &header, sizeof(header));\n\n\n\n    ret = bdrv_pwrite(file, 0, tmp, BDRV_SECTOR_SIZE);\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n    ret = bdrv_write_zeroes(file, 1, cat_sectors - 1, 0);\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n    ret = 0;\n\n\n\ndone:\n\n    bdrv_unref(file);\n\n    return ret;\n\n\n\nexit:\n\n    error_setg_errno(errp, -ret, \"Failed to create Parallels image\");\n\n    goto done;\n\n}\n", "idx": 4121, "_split": "valid", "_hash": "1e2c98b3a3f6f3bed4687951d2005a4d"}
{"project": "qemu", "commit_id": "0c17d68c1d3d6c35f37f5692042d2edb65c8bcc0", "target": 0, "func": "static void pxa2xx_pwrmode_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                                 uint64_t value)\n\n{\n\n    PXA2xxState *s = (PXA2xxState *)ri->opaque;\n\n    static const char *pwrmode[8] = {\n\n        \"Normal\", \"Idle\", \"Deep-idle\", \"Standby\",\n\n        \"Sleep\", \"reserved (!)\", \"reserved (!)\", \"Deep-sleep\",\n\n    };\n\n\n\n    if (value & 8) {\n\n        printf(\"%s: CPU voltage change attempt\\n\", __func__);\n\n    }\n\n    switch (value & 7) {\n\n    case 0:\n\n        /* Do nothing */\n\n        break;\n\n\n\n    case 1:\n\n        /* Idle */\n\n        if (!(s->cm_regs[CCCR >> 2] & (1U << 31))) { /* CPDIS */\n\n            cpu_interrupt(CPU(s->cpu), CPU_INTERRUPT_HALT);\n\n            break;\n\n        }\n\n        /* Fall through.  */\n\n\n\n    case 2:\n\n        /* Deep-Idle */\n\n        cpu_interrupt(CPU(s->cpu), CPU_INTERRUPT_HALT);\n\n        s->pm_regs[RCSR >> 2] |= 0x8; /* Set GPR */\n\n        goto message;\n\n\n\n    case 3:\n\n        s->cpu->env.uncached_cpsr = ARM_CPU_MODE_SVC;\n\n        s->cpu->env.daif = PSTATE_A | PSTATE_F | PSTATE_I;\n\n        s->cpu->env.cp15.sctlr_ns = 0;\n\n        s->cpu->env.cp15.c1_coproc = 0;\n\n        s->cpu->env.cp15.ttbr0_el[1] = 0;\n\n        s->cpu->env.cp15.c3 = 0;\n\n        s->pm_regs[PSSR >> 2] |= 0x8; /* Set STS */\n\n        s->pm_regs[RCSR >> 2] |= 0x8; /* Set GPR */\n\n\n\n        /*\n\n         * The scratch-pad register is almost universally used\n\n         * for storing the return address on suspend.  For the\n\n         * lack of a resuming bootloader, perform a jump\n\n         * directly to that address.\n\n         */\n\n        memset(s->cpu->env.regs, 0, 4 * 15);\n\n        s->cpu->env.regs[15] = s->pm_regs[PSPR >> 2];\n\n\n\n#if 0\n\n        buffer = 0xe59ff000; /* ldr     pc, [pc, #0] */\n\n        cpu_physical_memory_write(0, &buffer, 4);\n\n        buffer = s->pm_regs[PSPR >> 2];\n\n        cpu_physical_memory_write(8, &buffer, 4);\n\n#endif\n\n\n\n        /* Suspend */\n\n        cpu_interrupt(current_cpu, CPU_INTERRUPT_HALT);\n\n\n\n        goto message;\n\n\n\n    default:\n\n    message:\n\n        printf(\"%s: machine entered %s mode\\n\", __func__,\n\n               pwrmode[value & 7]);\n\n    }\n\n}\n", "idx": 4125, "_split": "valid", "_hash": "d2c7c41463907d9977764a15b8bb2141"}
{"project": "qemu", "commit_id": "c60bf3391bf4cb79b7adc6650094e21671ddaabd", "target": 0, "func": "static void hmp_change_read_arg(Monitor *mon, const char *password,\n\n                                void *opaque)\n\n{\n\n    qmp_change_vnc_password(password, NULL);\n\n    monitor_read_command(mon, 1);\n\n}\n", "idx": 4137, "_split": "valid", "_hash": "a44a637b8dfd6c3c85d0406fc4646eb3"}
{"project": "qemu", "commit_id": "9e559533bd825a3e371497875576137a8586c831", "target": 1, "func": "static int readv_f(int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, qflag = 0, vflag = 0;\n\n    int c, cnt;\n\n    char *buf;\n\n    int64_t offset;\n\n    /* Some compilers get confused and warn if this is not initialized.  */\n\n    int total = 0;\n\n    int nr_iov;\n\n    QEMUIOVector qiov;\n\n    int pattern = 0;\n\n    int Pflag = 0;\n\n\n\n    while ((c = getopt(argc, argv, \"CP:qv\")) != EOF) {\n\n        switch (c) {\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'P':\n\n            Pflag = 1;\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        case 'v':\n\n            vflag = 1;\n\n            break;\n\n        default:\n\n            return command_usage(&readv_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n        return command_usage(&readv_cmd);\n\n    }\n\n\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               offset);\n\n        return 0;\n\n    }\n\n\n\n    nr_iov = argc - optind;\n\n    buf = create_iovec(&qiov, &argv[optind], nr_iov, 0xab);\n\n    if (buf == NULL) {\n\n        return 0;\n\n    }\n\n\n\n    gettimeofday(&t1, NULL);\n\n    cnt = do_aio_readv(&qiov, offset, &total);\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"readv failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (Pflag) {\n\n        void *cmp_buf = g_malloc(qiov.size);\n\n        memset(cmp_buf, pattern, qiov.size);\n\n        if (memcmp(buf, cmp_buf, qiov.size)) {\n\n            printf(\"Pattern verification failed at offset %\"\n\n                   PRId64 \", %zd bytes\\n\", offset, qiov.size);\n\n        }\n\n        g_free(cmp_buf);\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    if (vflag) {\n\n        dump_buffer(buf, offset, qiov.size);\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"read\", &t2, offset, qiov.size, total, cnt, Cflag);\n\n\n\nout:\n\n\n    qemu_io_free(buf);\n\n    return 0;\n\n}", "idx": 4144, "_split": "valid", "_hash": "d876f96084536574f98abb8d2539878b"}
{"project": "qemu", "commit_id": "837f21aacf5a714c23ddaadbbc5212f9b661e3f7", "target": 1, "func": "ssize_t pcnet_receive(NetClientState *nc, const uint8_t *buf, size_t size_)\n\n{\n\n    PCNetState *s = qemu_get_nic_opaque(nc);\n\n    int is_padr = 0, is_bcast = 0, is_ladr = 0;\n\n    uint8_t buf1[60];\n\n    int remaining;\n\n    int crc_err = 0;\n\n    int size = size_;\n\n\n\n    if (CSR_DRX(s) || CSR_STOP(s) || CSR_SPND(s) || !size ||\n\n        (CSR_LOOP(s) && !s->looptest)) {\n\n        return -1;\n\n    }\n\n#ifdef PCNET_DEBUG\n\n    printf(\"pcnet_receive size=%d\\n\", size);\n\n#endif\n\n\n\n    /* if too small buffer, then expand it */\n\n    if (size < MIN_BUF_SIZE) {\n\n        memcpy(buf1, buf, size);\n\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n\n        buf = buf1;\n\n        size = MIN_BUF_SIZE;\n\n    }\n\n\n\n    if (CSR_PROM(s)\n\n        || (is_padr=padr_match(s, buf, size))\n\n        || (is_bcast=padr_bcast(s, buf, size))\n\n        || (is_ladr=ladr_match(s, buf, size))) {\n\n\n\n        pcnet_rdte_poll(s);\n\n\n\n        if (!(CSR_CRST(s) & 0x8000) && s->rdra) {\n\n            struct pcnet_RMD rmd;\n\n            int rcvrc = CSR_RCVRC(s)-1,i;\n\n            hwaddr nrda;\n\n            for (i = CSR_RCVRL(s)-1; i > 0; i--, rcvrc--) {\n\n                if (rcvrc <= 1)\n\n                    rcvrc = CSR_RCVRL(s);\n\n                nrda = s->rdra +\n\n                    (CSR_RCVRL(s) - rcvrc) *\n\n                    (BCR_SWSTYLE(s) ? 16 : 8 );\n\n                RMDLOAD(&rmd, nrda);\n\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n#ifdef PCNET_DEBUG_RMD\n\n                    printf(\"pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d\\n\",\n\n                                rcvrc, CSR_RCVRC(s));\n\n#endif\n\n                    CSR_RCVRC(s) = rcvrc;\n\n                    pcnet_rdte_poll(s);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (!(CSR_CRST(s) & 0x8000)) {\n\n#ifdef PCNET_DEBUG_RMD\n\n            printf(\"pcnet - no buffer: RCVRC=%d\\n\", CSR_RCVRC(s));\n\n#endif\n\n            s->csr[0] |= 0x1000; /* Set MISS flag */\n\n            CSR_MISSC(s)++;\n\n        } else {\n\n            uint8_t *src = s->buffer;\n\n            hwaddr crda = CSR_CRDA(s);\n\n            struct pcnet_RMD rmd;\n\n            int pktcount = 0;\n\n\n\n            if (!s->looptest) {\n\n                memcpy(src, buf, size);\n\n                /* no need to compute the CRC */\n\n                src[size] = 0;\n\n                src[size + 1] = 0;\n\n                src[size + 2] = 0;\n\n                src[size + 3] = 0;\n\n                size += 4;\n\n            } else if (s->looptest == PCNET_LOOPTEST_CRC ||\n\n                       !CSR_DXMTFCS(s) || size < MIN_BUF_SIZE+4) {\n\n                uint32_t fcs = ~0;\n\n                uint8_t *p = src;\n\n\n\n                while (p != &src[size])\n\n                    CRC(fcs, *p++);\n\n                *(uint32_t *)p = htonl(fcs);\n\n                size += 4;\n\n            } else {\n\n                uint32_t fcs = ~0;\n\n                uint8_t *p = src;\n\n\n\n                while (p != &src[size-4])\n\n                    CRC(fcs, *p++);\n\n                crc_err = (*(uint32_t *)p != htonl(fcs));\n\n            }\n\n\n\n#ifdef PCNET_DEBUG_MATCH\n\n            PRINT_PKTHDR(buf);\n\n#endif\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            /*if (!CSR_LAPPEN(s))*/\n\n                SET_FIELD(&rmd.status, RMDS, STP, 1);\n\n\n\n#define PCNET_RECV_STORE() do {                                 \\\n\n    int count = MIN(4096 - GET_FIELD(rmd.buf_length, RMDL, BCNT),remaining); \\\n\n    hwaddr rbadr = PHYSADDR(s, rmd.rbadr);          \\\n\n    s->phys_mem_write(s->dma_opaque, rbadr, src, count, CSR_BSWP(s)); \\\n\n    src += count; remaining -= count;                           \\\n\n    SET_FIELD(&rmd.status, RMDS, OWN, 0);                       \\\n\n    RMDSTORE(&rmd, PHYSADDR(s,crda));                           \\\n\n    pktcount++;                                                 \\\n\n} while (0)\n\n\n\n            remaining = size;\n\n            PCNET_RECV_STORE();\n\n            if ((remaining > 0) && CSR_NRDA(s)) {\n\n                hwaddr nrda = CSR_NRDA(s);\n\n#ifdef PCNET_DEBUG_RMD\n\n                PRINT_RMD(&rmd);\n\n#endif\n\n                RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n                    crda = nrda;\n\n                    PCNET_RECV_STORE();\n\n#ifdef PCNET_DEBUG_RMD\n\n                    PRINT_RMD(&rmd);\n\n#endif\n\n                    if ((remaining > 0) && (nrda=CSR_NNRD(s))) {\n\n                        RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                        if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n                            crda = nrda;\n\n                            PCNET_RECV_STORE();\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n\n\n#undef PCNET_RECV_STORE\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            if (remaining == 0) {\n\n                SET_FIELD(&rmd.msg_length, RMDM, MCNT, size);\n\n                SET_FIELD(&rmd.status, RMDS, ENP, 1);\n\n                SET_FIELD(&rmd.status, RMDS, PAM, !CSR_PROM(s) && is_padr);\n\n                SET_FIELD(&rmd.status, RMDS, LFAM, !CSR_PROM(s) && is_ladr);\n\n                SET_FIELD(&rmd.status, RMDS, BAM, !CSR_PROM(s) && is_bcast);\n\n                if (crc_err) {\n\n                    SET_FIELD(&rmd.status, RMDS, CRC, 1);\n\n                    SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n                }\n\n            } else {\n\n                SET_FIELD(&rmd.status, RMDS, OFLO, 1);\n\n                SET_FIELD(&rmd.status, RMDS, BUFF, 1);\n\n                SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n            }\n\n            RMDSTORE(&rmd, PHYSADDR(s,crda));\n\n            s->csr[0] |= 0x0400;\n\n\n\n#ifdef PCNET_DEBUG\n\n            printf(\"RCVRC=%d CRDA=0x%08x BLKS=%d\\n\",\n\n                CSR_RCVRC(s), PHYSADDR(s,CSR_CRDA(s)), pktcount);\n\n#endif\n\n#ifdef PCNET_DEBUG_RMD\n\n            PRINT_RMD(&rmd);\n\n#endif\n\n\n\n            while (pktcount--) {\n\n                if (CSR_RCVRC(s) <= 1)\n\n                    CSR_RCVRC(s) = CSR_RCVRL(s);\n\n                else\n\n                    CSR_RCVRC(s)--;\n\n            }\n\n\n\n            pcnet_rdte_poll(s);\n\n\n\n        }\n\n    }\n\n\n\n    pcnet_poll(s);\n\n    pcnet_update_irq(s);\n\n\n\n    return size_;\n\n}\n", "idx": 4170, "_split": "valid", "_hash": "ab7b73d16249b3060579366aaa5571b5"}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static bool pcie_has_upstream_port(PCIDevice *dev)\n\n{\n\n    PCIDevice *parent_dev = pci_bridge_get_device(dev->bus);\n\n\n\n    /* Device associated with an upstream port.\n\n     * As there are several types of these, it's easier to check the\n\n     * parent device: upstream ports are always connected to\n\n     * root or downstream ports.\n\n     */\n\n    return parent_dev &&\n\n        pci_is_express(parent_dev) &&\n\n        parent_dev->exp.exp_cap &&\n\n        (pcie_cap_get_type(parent_dev) == PCI_EXP_TYPE_ROOT_PORT ||\n\n         pcie_cap_get_type(parent_dev) == PCI_EXP_TYPE_DOWNSTREAM);\n\n}\n", "idx": 4194, "_split": "valid", "_hash": "428bd2dcd56f99f4266b637271e61a28"}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_gtdt(GArray *table_data, GArray *linker)\n\n{\n\n    int gtdt_start = table_data->len;\n\n    AcpiGenericTimerTable *gtdt;\n\n\n\n    gtdt = acpi_data_push(table_data, sizeof *gtdt);\n\n    /* The interrupt values are the same with the device tree when adding 16 */\n\n    gtdt->secure_el1_interrupt = ARCH_TIMER_S_EL1_IRQ + 16;\n\n    gtdt->secure_el1_flags = ACPI_EDGE_SENSITIVE;\n\n\n\n    gtdt->non_secure_el1_interrupt = ARCH_TIMER_NS_EL1_IRQ + 16;\n\n    gtdt->non_secure_el1_flags = ACPI_EDGE_SENSITIVE;\n\n\n\n    gtdt->virtual_timer_interrupt = ARCH_TIMER_VIRT_IRQ + 16;\n\n    gtdt->virtual_timer_flags = ACPI_EDGE_SENSITIVE;\n\n\n\n    gtdt->non_secure_el2_interrupt = ARCH_TIMER_NS_EL2_IRQ + 16;\n\n    gtdt->non_secure_el2_flags = ACPI_EDGE_SENSITIVE;\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)(table_data->data + gtdt_start), \"GTDT\",\n\n                 table_data->len - gtdt_start, 2, NULL);\n\n}\n", "idx": 4219, "_split": "valid", "_hash": "ebd179caedbc9238cb817c3186c8ead9"}
{"project": "qemu", "commit_id": "f1a6cf3ef734aab142d5f7ce52e219474ababf6b", "target": 1, "func": "static target_ulong h_random(PowerPCCPU *cpu, sPAPRMachineState *spapr,\n\n                             target_ulong opcode, target_ulong *args)\n\n{\n\n    sPAPRRngState *rngstate;\n\n    HRandomData hrdata;\n\n\n\n    rngstate = SPAPR_RNG(object_resolve_path_type(\"\", TYPE_SPAPR_RNG, NULL));\n\n\n\n    if (!rngstate || !rngstate->backend) {\n\n        return H_HARDWARE;\n\n    }\n\n\n\n    qemu_sem_init(&hrdata.sem, 0);\n\n    hrdata.val.v64 = 0;\n\n    hrdata.received = 0;\n\n\n\n    qemu_mutex_unlock_iothread();\n\n    while (hrdata.received < 8) {\n\n        rng_backend_request_entropy(rngstate->backend, 8 - hrdata.received,\n\n                                    random_recv, &hrdata);\n\n        qemu_sem_wait(&hrdata.sem);\n\n    }\n\n    qemu_mutex_lock_iothread();\n\n\n\n    qemu_sem_destroy(&hrdata.sem);\n\n    args[0] = hrdata.val.v64;\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 4232, "_split": "valid", "_hash": "b61eed11c0da9c9ee664a735582b4cc6"}
{"project": "qemu", "commit_id": "02e57e1c14a32aa1ed64e79d349d8e0e37cfaa27", "target": 1, "func": "static void sdhci_sysbus_realize(DeviceState *dev, Error ** errp)\n\n{\n\n    SDHCIState *s = SYSBUS_SDHCI(dev);\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n\n\n    sdhci_common_realize(s, errp);\n\n    if (errp && *errp) {\n\n        return;\n\n    }\n\n\n\n    if (s->dma_mr) {\n\n\n        address_space_init(s->dma_as, s->dma_mr, \"sdhci-dma\");\n\n    } else {\n\n        /* use system_memory() if property \"dma\" not set */\n\n        s->dma_as = &address_space_memory;\n\n    }\n\n\n\n    sysbus_init_irq(sbd, &s->irq);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n}", "idx": 4242, "_split": "valid", "_hash": "5bc88dde0cfc28cc6c8a55dc1aa7563f"}
{"project": "qemu", "commit_id": "36ab3c3400ac941e4d9afc044be08143ff9eea62", "target": 1, "func": "static int handle_cmd(AHCIState *s, int port, int slot)\n\n{\n\n    IDEState *ide_state;\n\n    uint32_t opts;\n\n    uint64_t tbl_addr;\n\n    AHCICmdHdr *cmd;\n\n    uint8_t *cmd_fis;\n\n    dma_addr_t cmd_len;\n\n\n\n    if (s->dev[port].port.ifs[0].status & (BUSY_STAT|DRQ_STAT)) {\n\n        /* Engine currently busy, try again later */\n\n        DPRINTF(port, \"engine busy\\n\");\n\n        return -1;\n\n    }\n\n\n\n    cmd = &((AHCICmdHdr *)s->dev[port].lst)[slot];\n\n\n\n    if (!s->dev[port].lst) {\n\n        DPRINTF(port, \"error: lst not given but cmd handled\");\n\n        return -1;\n\n    }\n\n\n\n    /* remember current slot handle for later */\n\n    s->dev[port].cur_cmd = cmd;\n\n\n\n    opts = le32_to_cpu(cmd->opts);\n\n    tbl_addr = le64_to_cpu(cmd->tbl_addr);\n\n\n\n    cmd_len = 0x80;\n\n    cmd_fis = dma_memory_map(s->as, tbl_addr, &cmd_len,\n\n                             DMA_DIRECTION_FROM_DEVICE);\n\n\n\n    if (!cmd_fis) {\n\n        DPRINTF(port, \"error: guest passed us an invalid cmd fis\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* The device we are working for */\n\n    ide_state = &s->dev[port].port.ifs[0];\n\n\n\n    if (!ide_state->blk) {\n\n        DPRINTF(port, \"error: guest accessed unused port\");\n\n        goto out;\n\n    }\n\n\n\n    debug_print_fis(cmd_fis, 0x90);\n\n    //debug_print_fis(cmd_fis, (opts & AHCI_CMD_HDR_CMD_FIS_LEN) * 4);\n\n\n\n    switch (cmd_fis[0]) {\n\n        case SATA_FIS_TYPE_REGISTER_H2D:\n\n            break;\n\n        default:\n\n            DPRINTF(port, \"unknown command cmd_fis[0]=%02x cmd_fis[1]=%02x \"\n\n                          \"cmd_fis[2]=%02x\\n\", cmd_fis[0], cmd_fis[1],\n\n                          cmd_fis[2]);\n\n            goto out;\n\n            break;\n\n    }\n\n\n\n    switch (cmd_fis[1]) {\n\n        case SATA_FIS_REG_H2D_UPDATE_COMMAND_REGISTER:\n\n            break;\n\n        case 0:\n\n            break;\n\n        default:\n\n            DPRINTF(port, \"unknown command cmd_fis[0]=%02x cmd_fis[1]=%02x \"\n\n                          \"cmd_fis[2]=%02x\\n\", cmd_fis[0], cmd_fis[1],\n\n                          cmd_fis[2]);\n\n            goto out;\n\n            break;\n\n    }\n\n\n\n    if (!(cmd_fis[1] & SATA_FIS_REG_H2D_UPDATE_COMMAND_REGISTER)) {\n\n        switch (s->dev[port].port_state) {\n\n        case STATE_RUN:\n\n            if (cmd_fis[15] & ATA_SRST) {\n\n                s->dev[port].port_state = STATE_RESET;\n\n            }\n\n            break;\n\n        case STATE_RESET:\n\n            if (!(cmd_fis[15] & ATA_SRST)) {\n\n                ahci_reset_port(s, port);\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    else if (cmd_fis[1] & SATA_FIS_REG_H2D_UPDATE_COMMAND_REGISTER) {\n\n\n\n        /* Check for NCQ command */\n\n        if (is_ncq(cmd_fis[2])) {\n\n            process_ncq_command(s, port, cmd_fis, slot);\n\n            goto out;\n\n        }\n\n\n\n        /* Decompose the FIS:\n\n         * AHCI does not interpret FIS packets, it only forwards them.\n\n         * SATA 1.0 describes how to decode LBA28 and CHS FIS packets.\n\n         * Later specifications, e.g, SATA 3.2, describe LBA48 FIS packets.\n\n         *\n\n         * ATA4 describes sector number for LBA28/CHS commands.\n\n         * ATA6 describes sector number for LBA48 commands.\n\n         * ATA8 deprecates CHS fully, describing only LBA28/48.\n\n         *\n\n         * We dutifully convert the FIS into IDE registers, and allow the\n\n         * core layer to interpret them as needed. */\n\n        ide_state->feature = cmd_fis[3];\n\n        ide_state->sector = cmd_fis[4];     /* LBA 7:0 */\n\n        ide_state->lcyl = cmd_fis[5];       /* LBA 15:8  */\n\n        ide_state->hcyl = cmd_fis[6];       /* LBA 23:16 */\n\n        ide_state->select = cmd_fis[7];     /* LBA 27:24 (LBA28) */\n\n        ide_state->hob_sector = cmd_fis[8]; /* LBA 31:24 */\n\n        ide_state->hob_lcyl = cmd_fis[9];   /* LBA 39:32 */\n\n        ide_state->hob_hcyl = cmd_fis[10];  /* LBA 47:40 */\n\n        ide_state->hob_feature = cmd_fis[11];\n\n        ide_state->nsector = (int64_t)((cmd_fis[13] << 8) | cmd_fis[12]);\n\n        /* 14, 16, 17, 18, 19: Reserved (SATA 1.0) */\n\n        /* 15: Only valid when UPDATE_COMMAND not set. */\n\n\n\n        /* Copy the ACMD field (ATAPI packet, if any) from the AHCI command\n\n         * table to ide_state->io_buffer\n\n         */\n\n        if (opts & AHCI_CMD_ATAPI) {\n\n            memcpy(ide_state->io_buffer, &cmd_fis[AHCI_COMMAND_TABLE_ACMD], 0x10);\n\n            debug_print_fis(ide_state->io_buffer, 0x10);\n\n            s->dev[port].done_atapi_packet = false;\n\n            /* XXX send PIO setup FIS */\n\n        }\n\n\n\n        ide_state->error = 0;\n\n\n\n        /* Reset transferred byte counter */\n\n        cmd->status = 0;\n\n\n\n        /* We're ready to process the command in FIS byte 2. */\n\n        ide_exec_cmd(&s->dev[port].port, cmd_fis[2]);\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(s->as, cmd_fis, cmd_len, DMA_DIRECTION_FROM_DEVICE,\n\n                     cmd_len);\n\n\n\n    if (s->dev[port].port.ifs[0].status & (BUSY_STAT|DRQ_STAT)) {\n\n        /* async command, complete later */\n\n        s->dev[port].busy_slot = slot;\n\n        return -1;\n\n    }\n\n\n\n    /* done handling the command */\n\n    return 0;\n\n}\n", "idx": 4263, "_split": "valid", "_hash": "e4ded2e06a1fa39cf2078d9d6f4e0e68"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void *rndis_queue_response(USBNetState *s, unsigned int length)\n\n{\n\n    struct rndis_response *r =\n\n            qemu_mallocz(sizeof(struct rndis_response) + length);\n\n\n\n    TAILQ_INSERT_TAIL(&s->rndis_resp, r, entries);\n\n    r->length = length;\n\n\n\n    return &r->buf[0];\n\n}\n", "idx": 4270, "_split": "valid", "_hash": "407c8525e11fc872d3433d01b361f572"}
{"project": "qemu", "commit_id": "3b098d56979d2f7fd707c5be85555d114353a28d", "target": 0, "func": "static char *visitor_get(TestOutputVisitorData *data)\n\n{\n\n    data->str = string_output_get_string(data->sov);\n\n    g_assert(data->str);\n\n    return data->str;\n\n}\n", "idx": 4273, "_split": "valid", "_hash": "6aa84c7d1c8e69ab467e0d7294b3b70f"}
{"project": "qemu", "commit_id": "2569da0cb64506ea05323544c26f3aaffbf3f9fe", "target": 0, "func": "static void do_change_vnc(const char *target)\n\n{\n\n    if (strcmp(target, \"passwd\") == 0 ||\n\n\tstrcmp(target, \"password\") == 0) {\n\n\tchar password[9];\n\n\tmonitor_readline(\"Password: \", 1, password, sizeof(password));\n\n\tif (vnc_display_password(NULL, password) < 0)\n\n\t    term_printf(\"could not set VNC server password\\n\");\n\n    } else {\n\n\tif (vnc_display_open(NULL, target) < 0)\n\n\t    term_printf(\"could not start VNC server on %s\\n\", target);\n\n    }\n\n}\n", "idx": 4294, "_split": "valid", "_hash": "47564f0d566edf830eb783a24d9760d6"}
{"project": "qemu", "commit_id": "b769d8fef6c06ddb39ef0337882a4f8872b9c2bc", "target": 0, "func": "void do_interrupt (CPUState *env)\n\n{\n\n#if defined (CONFIG_USER_ONLY)\n\n    env->exception_index |= 0x100;\n\n#else\n\n    uint32_t msr;\n\n    int excp = env->exception_index;\n\n\n\n    msr = _load_msr(env);\n\n#if defined (DEBUG_EXCEPTIONS)\n\n    if ((excp == EXCP_PROGRAM || excp == EXCP_DSI) && msr_pr == 1) \n\n    {\n\n        if (loglevel > 0) {\n\n            fprintf(logfile, \"Raise exception at 0x%08x => 0x%08x (%02x)\\n\",\n\n                    env->nip, excp << 8, env->error_code);\n\n    }\n\n\tif (loglevel > 0)\n\n\t    cpu_ppc_dump_state(env, logfile, 0);\n\n    }\n\n#endif\n\n    /* Generate informations in save/restore registers */\n\n    switch (excp) {\n\n    case EXCP_OFCALL:\n\n#if defined (USE_OPEN_FIRMWARE)\n\n        env->gpr[3] = OF_client_entry((void *)env->gpr[3]);\n\n#endif\n\n        return;\n\n    case EXCP_RTASCALL:\n\n#if defined (USE_OPEN_FIRMWARE)\n\n        printf(\"RTAS call !\\n\");\n\n        env->gpr[3] = RTAS_entry((void *)env->gpr[3]);\n\n        printf(\"RTAS call done\\n\");\n\n#endif\n\n        return;\n\n    case EXCP_NONE:\n\n        /* Do nothing */\n\n#if defined (DEBUG_EXCEPTIONS)\n\n        printf(\"%s: escape EXCP_NONE\\n\", __func__);\n\n#endif\n\n        return;\n\n    case EXCP_RESET:\n\n        if (msr_ip)\n\n            excp += 0xFFC00;\n\n        goto store_next;\n\n    case EXCP_MACHINE_CHECK:\n\n        if (msr_me == 0) {\n\n            cpu_abort(env, \"Machine check exception while not allowed\\n\");\n\n        }\n\n        msr_me = 0;\n\n        break;\n\n    case EXCP_DSI:\n\n        /* Store exception cause */\n\n        /* data location address has been stored\n\n         * when the fault has been detected\n\n     */\n\n\tmsr &= ~0xFFFF0000;\n\n\tenv->spr[DSISR] = 0;\n\n\tif (env->error_code &  EXCP_DSI_TRANSLATE)\n\n\t    env->spr[DSISR] |= 0x40000000;\n\n\telse if (env->error_code & EXCP_DSI_PROT)\n\n\t    env->spr[DSISR] |= 0x08000000;\n\n\telse if (env->error_code & EXCP_DSI_NOTSUP) {\n\n\t    env->spr[DSISR] |= 0x80000000;\n\n\t    if (env->error_code & EXCP_DSI_DIRECT)\n\n\t\tenv->spr[DSISR] |= 0x04000000;\n\n\t}\n\n\tif (env->error_code & EXCP_DSI_STORE)\n\n\t    env->spr[DSISR] |= 0x02000000;\n\n\tif ((env->error_code & 0xF) == EXCP_DSI_DABR)\n\n\t    env->spr[DSISR] |= 0x00400000;\n\n\tif (env->error_code & EXCP_DSI_ECXW)\n\n\t    env->spr[DSISR] |= 0x00100000;\n\n#if defined (DEBUG_EXCEPTIONS)\n\n\tif (loglevel) {\n\n\t    fprintf(logfile, \"DSI exception: DSISR=0x%08x, DAR=0x%08x\\n\",\n\n\t\t    env->spr[DSISR], env->spr[DAR]);\n\n\t} else {\n\n\t    printf(\"DSI exception: DSISR=0x%08x, DAR=0x%08x nip=0x%08x\\n\",\n\n\t\t   env->spr[DSISR], env->spr[DAR], env->nip);\n\n\t}\n\n#endif\n\n        goto store_next;\n\n    case EXCP_ISI:\n\n        /* Store exception cause */\n\n\tmsr &= ~0xFFFF0000;\n\n        if (env->error_code == EXCP_ISI_TRANSLATE)\n\n            msr |= 0x40000000;\n\n        else if (env->error_code == EXCP_ISI_NOEXEC ||\n\n\t\t env->error_code == EXCP_ISI_GUARD ||\n\n\t\t env->error_code == EXCP_ISI_DIRECT)\n\n            msr |= 0x10000000;\n\n        else\n\n            msr |= 0x08000000;\n\n#if defined (DEBUG_EXCEPTIONS)\n\n\tif (loglevel) {\n\n\t    fprintf(logfile, \"ISI exception: msr=0x%08x, nip=0x%08x\\n\",\n\n\t\t    msr, env->nip);\n\n\t} else {\n\n\t    printf(\"ISI exception: msr=0x%08x, nip=0x%08x tbl:0x%08x\\n\",\n\n\t\t   msr, env->nip, env->spr[V_TBL]);\n\n\t}\n\n#endif\n\n        goto store_next;\n\n    case EXCP_EXTERNAL:\n\n        if (msr_ee == 0) {\n\n#if defined (DEBUG_EXCEPTIONS)\n\n            if (loglevel > 0) {\n\n                fprintf(logfile, \"Skipping hardware interrupt\\n\");\n\n    }\n\n#endif\n\n            /* Requeue it */\n\n            do_raise_exception(EXCP_EXTERNAL);\n\n            return;\n\n            }\n\n        goto store_next;\n\n    case EXCP_ALIGN:\n\n        /* Store exception cause */\n\n        /* Get rS/rD and rA from faulting opcode */\n\n        env->spr[DSISR] |=\n\n            (ldl_code((void *)(env->nip - 4)) & 0x03FF0000) >> 16;\n\n        /* data location address has been stored\n\n         * when the fault has been detected\n\n         */\n\n        goto store_current;\n\n    case EXCP_PROGRAM:\n\n        msr &= ~0xFFFF0000;\n\n        switch (env->error_code & ~0xF) {\n\n        case EXCP_FP:\n\n            if (msr_fe0 == 0 && msr_fe1 == 0) {\n\n#if defined (DEBUG_EXCEPTIONS)\n\n                printf(\"Ignore floating point exception\\n\");\n\n#endif\n\n                return;\n\n        }\n\n            msr |= 0x00100000;\n\n            /* Set FX */\n\n            env->fpscr[7] |= 0x8;\n\n            /* Finally, update FEX */\n\n            if ((((env->fpscr[7] & 0x3) << 3) | (env->fpscr[6] >> 1)) &\n\n                ((env->fpscr[1] << 1) | (env->fpscr[0] >> 3)))\n\n                env->fpscr[7] |= 0x4;\n\n        break;\n\n        case EXCP_INVAL:\n\n            //\t    printf(\"Invalid instruction at 0x%08x\\n\", env->nip);\n\n            msr |= 0x00080000;\n\n        break;\n\n        case EXCP_PRIV:\n\n            msr |= 0x00040000;\n\n        break;\n\n        case EXCP_TRAP:\n\n            msr |= 0x00020000;\n\n            break;\n\n        default:\n\n            /* Should never occur */\n\n        break;\n\n    }\n\n        msr |= 0x00010000;\n\n        goto store_current;\n\n    case EXCP_NO_FP:\n\n        goto store_current;\n\n    case EXCP_DECR:\n\n        if (msr_ee == 0) {\n\n            /* Requeue it */\n\n            do_raise_exception(EXCP_DECR);\n\n            return;\n\n        }\n\n        goto store_next;\n\n    case EXCP_SYSCALL:\n\n#if defined (DEBUG_EXCEPTIONS)\n\n\tif (msr_pr) {\n\n\t    if (loglevel) {\n\n\t\tfprintf(logfile, \"syscall %d 0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\n\t\t\tenv->gpr[0], env->gpr[3], env->gpr[4],\n\n\t\t\tenv->gpr[5], env->gpr[6]);\n\n\t    } else {\n\n\t\tprintf(\"syscall %d from 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\n\t\t       env->gpr[0], env->nip, env->gpr[3], env->gpr[4],\n\n\t\t       env->gpr[5], env->gpr[6]);\n\n\t    }\n\n\t}\n\n#endif\n\n        goto store_next;\n\n    case EXCP_TRACE:\n\n        goto store_next;\n\n    case EXCP_FP_ASSIST:\n\n        goto store_next;\n\n    case EXCP_MTMSR:\n\n        /* Nothing to do */\n\n        return;\n\n    case EXCP_BRANCH:\n\n        /* Nothing to do */\n\n        return;\n\n    case EXCP_RFI:\n\n        /* Restore user-mode state */\n\n\ttb_flush(env);\n\n#if defined (DEBUG_EXCEPTIONS)\n\n\tif (msr_pr == 1)\n\n\t    printf(\"Return from exception => 0x%08x\\n\", (uint32_t)env->nip);\n\n#endif\n\n        return;\n\n    store_current:\n\n        /* SRR0 is set to current instruction */\n\n        env->spr[SRR0] = (uint32_t)env->nip - 4;\n\n        break;\n\n    store_next:\n\n        /* SRR0 is set to next instruction */\n\n        env->spr[SRR0] = (uint32_t)env->nip;\n\n        break;\n\n    }\n\n    env->spr[SRR1] = msr;\n\n    /* reload MSR with correct bits */\n\n    msr_pow = 0;\n\n    msr_ee = 0;\n\n    msr_pr = 0;\n\n    msr_fp = 0;\n\n    msr_fe0 = 0;\n\n    msr_se = 0;\n\n    msr_be = 0;\n\n    msr_fe1 = 0;\n\n    msr_ir = 0;\n\n    msr_dr = 0;\n\n    msr_ri = 0;\n\n    msr_le = msr_ile;\n\n    /* Jump to handler */\n\n    env->nip = excp << 8;\n\n    env->exception_index = EXCP_NONE;\n\n    /* Invalidate all TLB as we may have changed translation mode */\n\n    tlb_flush(env, 1);\n\n    /* ensure that no TB jump will be modified as\n\n       the program flow was changed */\n\n#ifdef __sparc__\n\n    tmp_T0 = 0;\n\n#else\n\n    T0 = 0;\n\n#endif\n\n#endif\n\n    env->exception_index = -1;\n\n}\n", "idx": 4318, "_split": "valid", "_hash": "bca44eed4576f0c908466bf9e63e97f1"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int rom_add_blob(const char *name, const void *blob, size_t len,\n\n                 target_phys_addr_t addr)\n\n{\n\n    Rom *rom;\n\n\n\n    rom = g_malloc0(sizeof(*rom));\n\n    rom->name    = g_strdup(name);\n\n    rom->addr    = addr;\n\n    rom->romsize = len;\n\n    rom->data    = g_malloc0(rom->romsize);\n\n    memcpy(rom->data, blob, len);\n\n    rom_insert(rom);\n\n    return 0;\n\n}\n", "idx": 4321, "_split": "valid", "_hash": "3e1670fdbc485dd1e2127fd09c536d33"}
{"project": "qemu", "commit_id": "f24582d6ad8a080e008974c000bf0ae635d036ac", "target": 1, "func": "void qmp_output_visitor_cleanup(QmpOutputVisitor *v)\n\n{\n\n    QStackEntry *e, *tmp;\n\n\n\n    QTAILQ_FOREACH_SAFE(e, &v->stack, node, tmp) {\n\n        QTAILQ_REMOVE(&v->stack, e, node);\n\n        if (e->value) {\n\n            qobject_decref(e->value);\n\n        }\n\n        g_free(e);\n\n    }\n\n\n\n    g_free(v);\n\n}\n", "idx": 4351, "_split": "valid", "_hash": "6ce871b324e3594d3cb47867d3090571"}
{"project": "qemu", "commit_id": "1f51470d044852592922f91000e741c381582cdc", "target": 1, "func": "static int qemu_chr_open_udp(QemuOpts *opts, CharDriverState **_chr)\n\n{\n\n    CharDriverState *chr = NULL;\n\n    NetCharDriver *s = NULL;\n\n    int fd = -1;\n\n    int ret;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    s = g_malloc0(sizeof(NetCharDriver));\n\n\n\n    fd = inet_dgram_opts(opts);\n\n    if (fd < 0) {\n\n        fprintf(stderr, \"inet_dgram_opts failed\\n\");\n\n        ret = -errno;\n\n        goto return_err;\n\n    }\n\n\n\n    s->fd = fd;\n\n    s->bufcnt = 0;\n\n    s->bufptr = 0;\n\n    chr->opaque = s;\n\n    chr->chr_write = udp_chr_write;\n\n    chr->chr_update_read_handler = udp_chr_update_read_handler;\n\n    chr->chr_close = udp_chr_close;\n\n\n\n    *_chr = chr;\n\n    return 0;\n\n\n\nreturn_err:\n\n    g_free(chr);\n\n    g_free(s);\n\n    if (fd >= 0) {\n\n        closesocket(fd);\n\n    }\n\n    return ret;\n\n}\n", "idx": 4352, "_split": "valid", "_hash": "ebbcd360fb58521e3d9eb7b818a3b9cc"}
{"project": "qemu", "commit_id": "5ee5993001cf32addb86a92e2ae8cb090fbc1462", "target": 1, "func": "void helper_wrpsr(CPUSPARCState *env, target_ulong new_psr)\n\n{\n\n    if ((new_psr & PSR_CWP) >= env->nwindows) {\n\n        cpu_raise_exception_ra(env, TT_ILL_INSN, GETPC());\n\n    } else {\n\n\n\n        cpu_put_psr(env, new_psr);\n\n\n    }\n\n}", "idx": 4354, "_split": "valid", "_hash": "d9a4af3c1306f9bc37298bf67e08ced2"}
{"project": "qemu", "commit_id": "5ee5993001cf32addb86a92e2ae8cb090fbc1462", "target": 1, "func": "void helper_wrpstate(CPUSPARCState *env, target_ulong new_state)\n\n{\n\n    cpu_change_pstate(env, new_state & 0xf3f);\n\n\n\n#if !defined(CONFIG_USER_ONLY)\n\n    if (cpu_interrupts_enabled(env)) {\n\n\n        cpu_check_irqs(env);\n\n\n    }\n\n#endif\n\n}", "idx": 4373, "_split": "valid", "_hash": "8f692d0a93bd6b77f41a71f2d8a49098"}
{"project": "qemu", "commit_id": "135a972b45203ba992afc99ef4f061be8a5acae0", "target": 1, "func": "void tb_flush(CPUState *cpu)\n\n{\n\n\n\n\n#if defined(DEBUG_FLUSH)\n\n    printf(\"qemu: flush code_size=%ld nb_tbs=%d avg_tb_size=%ld\\n\",\n\n           (unsigned long)(tcg_ctx.code_gen_ptr - tcg_ctx.code_gen_buffer),\n\n           tcg_ctx.tb_ctx.nb_tbs, tcg_ctx.tb_ctx.nb_tbs > 0 ?\n\n           ((unsigned long)(tcg_ctx.code_gen_ptr - tcg_ctx.code_gen_buffer)) /\n\n           tcg_ctx.tb_ctx.nb_tbs : 0);\n\n#endif\n\n    if ((unsigned long)(tcg_ctx.code_gen_ptr - tcg_ctx.code_gen_buffer)\n\n        > tcg_ctx.code_gen_buffer_size) {\n\n        cpu_abort(cpu, \"Internal error: code buffer overflow\\n\");\n\n\n    tcg_ctx.tb_ctx.nb_tbs = 0;\n\n\n\n    CPU_FOREACH(cpu) {\n\n        memset(cpu->tb_jmp_cache, 0, sizeof(cpu->tb_jmp_cache));\n\n        cpu->tb_flushed = true;\n\n\n\n\n    qht_reset_size(&tcg_ctx.tb_ctx.htable, CODE_GEN_HTABLE_SIZE);\n\n    page_flush_tb();\n\n\n\n    tcg_ctx.code_gen_ptr = tcg_ctx.code_gen_buffer;\n\n    /* XXX: flush processor icache at this point if cache flush is\n\n       expensive */\n\n    tcg_ctx.tb_ctx.tb_flush_count++;\n", "idx": 4380, "_split": "valid", "_hash": "3f184ac465ea581b2806557113339d9a"}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "int register_savevm(DeviceState *dev,\n\n                    const char *idstr,\n\n                    int instance_id,\n\n                    int version_id,\n\n                    SaveStateHandler *save_state,\n\n                    LoadStateHandler *load_state,\n\n                    void *opaque)\n\n{\n\n    SaveVMHandlers *ops = g_malloc0(sizeof(SaveVMHandlers));\n\n    ops->save_state = save_state;\n\n    ops->load_state = load_state;\n\n    return register_savevm_live(dev, idstr, instance_id, version_id,\n\n                                ops, opaque);\n\n}\n", "idx": 4381, "_split": "valid", "_hash": "2a9bdf1bba7cca0f6e4c21b08a6fac6e"}
{"project": "qemu", "commit_id": "805017b7791200f1b72deef17dc98fd272b941eb", "target": 0, "func": "static void test_validate_union(TestInputVisitorData *data,\n\n                                 const void *unused)\n\n{\n\n    UserDefUnion *tmp = NULL;\n\n    Visitor *v;\n\n    Error *err = NULL;\n\n\n\n    v = validate_test_init(data, \"{ 'type': 'b', 'integer': 41, 'data' : { 'integer': 42 } }\");\n\n\n\n    visit_type_UserDefUnion(v, &tmp, NULL, &err);\n\n    g_assert(!err);\n\n    qapi_free_UserDefUnion(tmp);\n\n}\n", "idx": 4408, "_split": "valid", "_hash": "fd147650c09e6da473ac29792f1c6160"}
{"project": "qemu", "commit_id": "541dc0d47f10973c241e9955afc2aefc96adec51", "target": 0, "func": "void test_misc(void)\n\n{\n\n    char table[256];\n\n    long res, i;\n\n\n\n    for(i=0;i<256;i++) table[i] = 256 - i;\n\n    res = 0x12345678;\n\n    asm (\"xlat\" : \"=a\" (res) : \"b\" (table), \"0\" (res));\n\n    printf(\"xlat: EAX=\" FMTLX \"\\n\", res);\n\n\n\n#if defined(__x86_64__)\n\n#if 0\n\n    {\n\n        /* XXX: see if Intel Core2 and AMD64 behavior really\n\n           differ. Here we implemented the Intel way which is not\n\n           compatible yet with QEMU. */\n\n        static struct __attribute__((packed)) {\n\n            uint64_t offset;\n\n            uint16_t seg;\n\n        } desc;\n\n        long cs_sel;\n\n\n\n        asm volatile (\"mov %%cs, %0\" : \"=r\" (cs_sel));\n\n\n\n        asm volatile (\"push %1\\n\"\n\n                      \"call func_lret\\n\"\n\n                      : \"=a\" (res)\n\n                      : \"r\" (cs_sel) : \"memory\", \"cc\");\n\n        printf(\"func_lret=\" FMTLX \"\\n\", res);\n\n\n\n        desc.offset = (long)&func_lret;\n\n        desc.seg = cs_sel;\n\n\n\n        asm volatile (\"xor %%rax, %%rax\\n\"\n\n                      \"rex64 lcall *(%%rcx)\\n\"\n\n                      : \"=a\" (res)\n\n                      : \"c\" (&desc)\n\n                      : \"memory\", \"cc\");\n\n        printf(\"func_lret2=\" FMTLX \"\\n\", res);\n\n\n\n        asm volatile (\"push %2\\n\"\n\n                      \"mov $ 1f, %%rax\\n\"\n\n                      \"push %%rax\\n\"\n\n                      \"rex64 ljmp *(%%rcx)\\n\"\n\n                      \"1:\\n\"\n\n                      : \"=a\" (res)\n\n                      : \"c\" (&desc), \"b\" (cs_sel)\n\n                      : \"memory\", \"cc\");\n\n        printf(\"func_lret3=\" FMTLX \"\\n\", res);\n\n    }\n\n#endif\n\n#else\n\n    asm volatile (\"push %%cs ; call %1\"\n\n                  : \"=a\" (res)\n\n                  : \"m\" (func_lret): \"memory\", \"cc\");\n\n    printf(\"func_lret=\" FMTLX \"\\n\", res);\n\n\n\n    asm volatile (\"pushf ; push %%cs ; call %1\"\n\n                  : \"=a\" (res)\n\n                  : \"m\" (func_iret): \"memory\", \"cc\");\n\n    printf(\"func_iret=\" FMTLX \"\\n\", res);\n\n#endif\n\n\n\n#if defined(__x86_64__)\n\n    /* specific popl test */\n\n    asm volatile (\"push $12345432 ; push $0x9abcdef ; pop (%%rsp) ; pop %0\"\n\n                  : \"=g\" (res));\n\n    printf(\"popl esp=\" FMTLX \"\\n\", res);\n\n#else\n\n    /* specific popl test */\n\n    asm volatile (\"pushl $12345432 ; pushl $0x9abcdef ; popl (%%esp) ; popl %0\"\n\n                  : \"=g\" (res));\n\n    printf(\"popl esp=\" FMTLX \"\\n\", res);\n\n\n\n    /* specific popw test */\n\n    asm volatile (\"pushl $12345432 ; pushl $0x9abcdef ; popw (%%esp) ; addl $2, %%esp ; popl %0\"\n\n                  : \"=g\" (res));\n\n    printf(\"popw esp=\" FMTLX \"\\n\", res);\n\n#endif\n\n}\n", "idx": 4442, "_split": "valid", "_hash": "5b9a6d3b8db9267f3523add0c2920262"}
{"project": "qemu", "commit_id": "7cba16a748b3ed7aba1a94304869fcfa9b5c0396", "target": 0, "func": "static int pci_rtl8139_init(PCIDevice *dev)\n\n{\n\n    RTL8139State * s = DO_UPCAST(RTL8139State, dev, dev);\n\n    uint8_t *pci_conf;\n\n\n\n    pci_conf = s->dev.config;\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_REALTEK);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_REALTEK_8139);\n\n    pci_conf[PCI_REVISION_ID] = RTL8139_PCI_REVID; /* >=0x20 is for 8139C+ */\n\n    pci_config_set_class(pci_conf, PCI_CLASS_NETWORK_ETHERNET);\n\n    pci_conf[PCI_INTERRUPT_PIN] = 1;    /* interrupt pin 0 */\n\n    /* TODO: start of capability list, but no capability\n\n     * list bit in status register, and offset 0xdc seems unused. */\n\n    pci_conf[PCI_CAPABILITY_LIST] = 0xdc;\n\n\n\n    /* I/O handler for memory-mapped I/O */\n\n    s->rtl8139_mmio_io_addr =\n\n        cpu_register_io_memory(rtl8139_mmio_read, rtl8139_mmio_write, s,\n\n                               DEVICE_LITTLE_ENDIAN);\n\n\n\n    pci_register_bar(&s->dev, 0, 0x100,\n\n                           PCI_BASE_ADDRESS_SPACE_IO,  rtl8139_ioport_map);\n\n\n\n    pci_register_bar_simple(&s->dev, 1, 0x100, 0, s->rtl8139_mmio_io_addr);\n\n\n\n    qemu_macaddr_default_if_unset(&s->conf.macaddr);\n\n\n\n    /* prepare eeprom */\n\n    s->eeprom.contents[0] = 0x8129;\n\n#if 1\n\n    /* PCI vendor and device ID should be mirrored here */\n\n    s->eeprom.contents[1] = PCI_VENDOR_ID_REALTEK;\n\n    s->eeprom.contents[2] = PCI_DEVICE_ID_REALTEK_8139;\n\n#endif\n\n    s->eeprom.contents[7] = s->conf.macaddr.a[0] | s->conf.macaddr.a[1] << 8;\n\n    s->eeprom.contents[8] = s->conf.macaddr.a[2] | s->conf.macaddr.a[3] << 8;\n\n    s->eeprom.contents[9] = s->conf.macaddr.a[4] | s->conf.macaddr.a[5] << 8;\n\n\n\n    s->nic = qemu_new_nic(&net_rtl8139_info, &s->conf,\n\n                          dev->qdev.info->name, dev->qdev.id, s);\n\n    qemu_format_nic_info_str(&s->nic->nc, s->conf.macaddr.a);\n\n\n\n    s->cplus_txbuffer = NULL;\n\n    s->cplus_txbuffer_len = 0;\n\n    s->cplus_txbuffer_offset = 0;\n\n\n\n    s->TimerExpire = 0;\n\n    s->timer = qemu_new_timer_ns(vm_clock, rtl8139_timer, s);\n\n    rtl8139_set_next_tctr_time(s, qemu_get_clock_ns(vm_clock));\n\n\n\n    add_boot_device_path(s->conf.bootindex, &dev->qdev, \"/ethernet-phy@0\");\n\n\n\n    return 0;\n\n}\n", "idx": 4443, "_split": "valid", "_hash": "e35b2e72d0d1521614351ccbc8d47e6c"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "VMChangeStateEntry *qemu_add_vm_change_state_handler(VMChangeStateHandler *cb,\n\n                                                     void *opaque)\n\n{\n\n    VMChangeStateEntry *e;\n\n\n\n    e = qemu_mallocz(sizeof (*e));\n\n\n\n    e->cb = cb;\n\n    e->opaque = opaque;\n\n    LIST_INSERT_HEAD(&vm_change_state_head, e, entries);\n\n    return e;\n\n}\n", "idx": 4461, "_split": "valid", "_hash": "af8ba14ca8a4856795fa41048e405407"}
{"project": "qemu", "commit_id": "88045ac55592cacc92567aa46cb6917854bf7241", "target": 0, "func": "static void rtas_read_pci_config(sPAPREnvironment *spapr,\n\n                                 uint32_t token, uint32_t nargs,\n\n                                 target_ulong args,\n\n                                 uint32_t nret, target_ulong rets)\n\n{\n\n    uint32_t val, size, addr;\n\n    PCIDevice *dev = find_dev(spapr, 0, rtas_ld(args, 0));\n\n\n\n    if (!dev) {\n\n        rtas_st(rets, 0, -1);\n\n        return;\n\n    }\n\n    size = rtas_ld(args, 1);\n\n    addr = rtas_pci_cfgaddr(rtas_ld(args, 0));\n\n    val = pci_host_config_read_common(dev, addr, pci_config_size(dev), size);\n\n    rtas_st(rets, 0, 0);\n\n    rtas_st(rets, 1, val);\n\n}\n", "idx": 4494, "_split": "valid", "_hash": "104d1788c0d0111a4b2dca129c24a137"}
{"project": "qemu", "commit_id": "5ee163e8ea2fb6610339f494e039159e08a69066", "target": 0, "func": "void qmp_dump_guest_memory(bool paging, const char *file, bool has_begin,\n\n                           int64_t begin, bool has_length, int64_t length,\n\n                           Error **errp)\n\n{\n\n    const char *p;\n\n    int fd = -1;\n\n    DumpState *s;\n\n    int ret;\n\n\n\n    if (has_begin && !has_length) {\n\n        error_set(errp, QERR_MISSING_PARAMETER, \"length\");\n\n        return;\n\n    }\n\n    if (!has_begin && has_length) {\n\n        error_set(errp, QERR_MISSING_PARAMETER, \"begin\");\n\n        return;\n\n    }\n\n\n\n#if !defined(WIN32)\n\n    if (strstart(file, \"fd:\", &p)) {\n\n        fd = monitor_get_fd(cur_mon, p, errp);\n\n        if (fd == -1) {\n\n            return;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if  (strstart(file, \"file:\", &p)) {\n\n        fd = qemu_open(p, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, S_IRUSR);\n\n        if (fd < 0) {\n\n            error_setg_file_open(errp, errno, p);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (fd == -1) {\n\n        error_set(errp, QERR_INVALID_PARAMETER, \"protocol\");\n\n        return;\n\n    }\n\n\n\n    s = g_malloc(sizeof(DumpState));\n\n\n\n    ret = dump_init(s, fd, paging, has_begin, begin, length, errp);\n\n    if (ret < 0) {\n\n        g_free(s);\n\n        return;\n\n    }\n\n\n\n    if (create_vmcore(s) < 0 && !error_is_set(s->errp)) {\n\n        error_set(errp, QERR_IO_ERROR);\n\n    }\n\n\n\n    g_free(s);\n\n}\n", "idx": 4495, "_split": "valid", "_hash": "a0218d20e9cdbc32d4d663d3e462be23"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static bool bdrv_requests_pending(BlockDriverState *bs)\n\n{\n\n    if (!QLIST_EMPTY(&bs->tracked_requests)) {\n\n        return true;\n\n    }\n\n    if (!qemu_co_queue_empty(&bs->throttled_reqs[0])) {\n\n        return true;\n\n    }\n\n    if (!qemu_co_queue_empty(&bs->throttled_reqs[1])) {\n\n        return true;\n\n    }\n\n    if (bs->file && bdrv_requests_pending(bs->file)) {\n\n        return true;\n\n    }\n\n    if (bs->backing_hd && bdrv_requests_pending(bs->backing_hd)) {\n\n        return true;\n\n    }\n\n    return false;\n\n}\n", "idx": 4511, "_split": "valid", "_hash": "e4cd4ee96da0f87e3156312a408259b6"}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void etsec_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = etsec_realize;\n\n    dc->reset = etsec_reset;\n\n    dc->props = etsec_properties;\n\n\n\n}", "idx": 4522, "_split": "valid", "_hash": "c89af83303bf9cd02a33f1cd6b68d417"}
{"project": "qemu", "commit_id": "384acbf46b70edf0d2c1648aa1a92a90bcf7057d", "target": 0, "func": "static int bdrv_qed_is_allocated(BlockDriverState *bs, int64_t sector_num,\n\n                                  int nb_sectors, int *pnum)\n\n{\n\n    BDRVQEDState *s = bs->opaque;\n\n    uint64_t pos = (uint64_t)sector_num * BDRV_SECTOR_SIZE;\n\n    size_t len = (size_t)nb_sectors * BDRV_SECTOR_SIZE;\n\n    QEDIsAllocatedCB cb = {\n\n        .is_allocated = -1,\n\n        .pnum = pnum,\n\n    };\n\n    QEDRequest request = { .l2_table = NULL };\n\n\n\n    async_context_push();\n\n\n\n    qed_find_cluster(s, &request, pos, len, qed_is_allocated_cb, &cb);\n\n\n\n    while (cb.is_allocated == -1) {\n\n        qemu_aio_wait();\n\n    }\n\n\n\n    async_context_pop();\n\n\n\n    qed_unref_l2_cache_entry(request.l2_table);\n\n\n\n    return cb.is_allocated;\n\n}\n", "idx": 4557, "_split": "valid", "_hash": "b48613a8e85c18b399f615b7b6bb73ed"}
{"project": "qemu", "commit_id": "7f4a930e64b9e69cd340395a7e4f0494aef4fcdd", "target": 1, "func": "static int vhost_user_get_u64(struct vhost_dev *dev, int request, uint64_t *u64)\n\n{\n\n    VhostUserMsg msg = {\n\n        .request = request,\n\n        .flags = VHOST_USER_VERSION,\n\n    };\n\n\n\n    if (vhost_user_one_time_request(request) && dev->vq_index != 0) {\n\n        return 0;\n\n    }\n\n\n\n    vhost_user_write(dev, &msg, NULL, 0);\n\n\n\n    if (vhost_user_read(dev, &msg) < 0) {\n\n        return 0;\n\n    }\n\n\n\n    if (msg.request != request) {\n\n        error_report(\"Received unexpected msg type. Expected %d received %d\",\n\n                     request, msg.request);\n\n        return -1;\n\n    }\n\n\n\n    if (msg.size != sizeof(m.u64)) {\n\n        error_report(\"Received bad msg size.\");\n\n        return -1;\n\n    }\n\n\n\n    *u64 = msg.u64;\n\n\n\n    return 0;\n\n}\n", "idx": 4578, "_split": "valid", "_hash": "f650bcf6475e7049f234b46c0f53993d"}
{"project": "qemu", "commit_id": "fa131d94a5c00c6bbea39358d4bca7bf98f6c1f5", "target": 1, "func": "ObjectClass *object_class_dynamic_cast_assert(ObjectClass *class,\n\n                                              const char *typename,\n\n                                              const char *file, int line,\n\n                                              const char *func)\n\n{\n\n    ObjectClass *ret = object_class_dynamic_cast(class, typename);\n\n\n\n    if (!ret && class) {\n\n        fprintf(stderr, \"%s:%d:%s: Object %p is not an instance of type %s\\n\",\n\n                file, line, func, class, typename);\n\n        abort();\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 4583, "_split": "valid", "_hash": "a7297422a65a12597c7000bf22668381"}
{"project": "qemu", "commit_id": "a907ec52cc1aefc820768b6e341b56f8f3caaca7", "target": 1, "func": "static void nvme_set_bootindex(Object *obj, Visitor *v, void *opaque,\n\n                                  const char *name, Error **errp)\n\n{\n\n    NvmeCtrl *s = NVME(obj);\n\n    int32_t boot_index;\n\n    Error *local_err = NULL;\n\n\n\n    visit_type_int32(v, &boot_index, name, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n    /* check whether bootindex is present in fw_boot_order list  */\n\n    check_boot_index(boot_index, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n    /* change bootindex to a new one */\n\n    s->conf.bootindex = boot_index;\n\n\n\nout:\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n    }\n\n}\n", "idx": 4594, "_split": "valid", "_hash": "e7c14fff6e01713adc925ebeb60ca1dc"}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(divwu)\n\n{\n\n    if (T1 == 0) {\n\n        T0 = 0;\n\n    } else {\n\n        T0 /= T1;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 4598, "_split": "valid", "_hash": "caa4b0744cafcd9172ac5a79bff165b6"}
{"project": "qemu", "commit_id": "ad5b88b1f198182642b6cbf3dacb4cade0c80fb9", "target": 1, "func": "void *rom_add_blob(const char *name, const void *blob, size_t len,\n\n                   hwaddr addr, const char *fw_file_name,\n\n                   FWCfgReadCallback fw_callback, void *callback_opaque)\n\n{\n\n    Rom *rom;\n\n    void *data = NULL;\n\n\n\n    rom           = g_malloc0(sizeof(*rom));\n\n    rom->name     = g_strdup(name);\n\n    rom->addr     = addr;\n\n    rom->romsize  = len;\n\n    rom->datasize = len;\n\n    rom->data     = g_malloc0(rom->datasize);\n\n    memcpy(rom->data, blob, len);\n\n    rom_insert(rom);\n\n    if (fw_file_name && fw_cfg) {\n\n        char devpath[100];\n\n\n\n        snprintf(devpath, sizeof(devpath), \"/rom@%s\", fw_file_name);\n\n\n\n        if (rom_file_has_mr) {\n\n            data = rom_set_mr(rom, OBJECT(fw_cfg), devpath);\n\n        } else {\n\n            data = rom->data;\n\n        }\n\n\n\n        fw_cfg_add_file_callback(fw_cfg, fw_file_name,\n\n                                 fw_callback, callback_opaque,\n\n                                 data, rom->romsize);\n\n    }\n\n    return data;\n\n}\n", "idx": 4600, "_split": "valid", "_hash": "740dd32cfeb9eadef05d0523e2a48871"}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static int qed_write_table(BDRVQEDState *s, uint64_t offset, QEDTable *table,\n\n                           unsigned int index, unsigned int n, bool flush)\n\n{\n\n    unsigned int sector_mask = BDRV_SECTOR_SIZE / sizeof(uint64_t) - 1;\n\n    unsigned int start, end, i;\n\n    QEDTable *new_table;\n\n    struct iovec iov;\n\n    QEMUIOVector qiov;\n\n    size_t len_bytes;\n\n    int ret;\n\n\n\n    trace_qed_write_table(s, offset, table, index, n);\n\n\n\n    /* Calculate indices of the first and one after last elements */\n\n    start = index & ~sector_mask;\n\n    end = (index + n + sector_mask) & ~sector_mask;\n\n\n\n    len_bytes = (end - start) * sizeof(uint64_t);\n\n\n\n    new_table = qemu_blockalign(s->bs, len_bytes);\n\n    iov = (struct iovec) {\n\n        .iov_base = new_table->offsets,\n\n        .iov_len = len_bytes,\n\n    };\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n    /* Byteswap table */\n\n    for (i = start; i < end; i++) {\n\n        uint64_t le_offset = cpu_to_le64(table->offsets[i]);\n\n        new_table->offsets[i - start] = le_offset;\n\n    }\n\n\n\n    /* Adjust for offset into table */\n\n    offset += start * sizeof(uint64_t);\n\n\n\n    ret = bdrv_pwritev(s->bs->file, offset, &qiov);\n\n    trace_qed_write_table_cb(s, table, flush, ret);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    if (flush) {\n\n        qed_acquire(s);\n\n        ret = bdrv_flush(s->bs);\n\n        qed_release(s);\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    qemu_vfree(new_table);\n\n    return ret;\n\n}\n", "idx": 4606, "_split": "valid", "_hash": "8bf2806de400a126c6c5f9aa22c97967"}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static void vnc_init_basic_info(SocketAddress *addr,\n\n                                VncBasicInfo *info,\n\n                                Error **errp)\n\n{\n\n    switch (addr->type) {\n\n    case SOCKET_ADDRESS_KIND_INET:\n\n        info->host = g_strdup(addr->u.inet->host);\n\n        info->service = g_strdup(addr->u.inet->port);\n\n        if (addr->u.inet->ipv6) {\n\n            info->family = NETWORK_ADDRESS_FAMILY_IPV6;\n\n        } else {\n\n            info->family = NETWORK_ADDRESS_FAMILY_IPV4;\n\n        }\n\n        break;\n\n\n\n    case SOCKET_ADDRESS_KIND_UNIX:\n\n        info->host = g_strdup(\"\");\n\n        info->service = g_strdup(addr->u.q_unix->path);\n\n        info->family = NETWORK_ADDRESS_FAMILY_UNIX;\n\n        break;\n\n\n\n    default:\n\n        error_setg(errp, \"Unsupported socket kind %d\",\n\n                   addr->type);\n\n        break;\n\n    }\n\n\n\n    return;\n\n}\n", "idx": 4612, "_split": "valid", "_hash": "b3cac3a2a427a54b889e7a41b8e434ef"}
{"project": "qemu", "commit_id": "273a2142176098fe2c27f263d86ad66b133b43cb", "target": 0, "func": "static void disable_interrupt(EEPRO100State * s)\n\n{\n\n    if (s->int_stat) {\n\n        logout(\"interrupt disabled\\n\");\n\n        qemu_irq_lower(s->pci_dev->irq[0]);\n\n        s->int_stat = 0;\n\n    }\n\n}\n", "idx": 4636, "_split": "valid", "_hash": "aaa915c577222963137518c2b75581a1"}
{"project": "qemu", "commit_id": "6c2934db949aa259ed47b126b5c6838ac57a3f6f", "target": 1, "func": "void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,\n\n                            int len, int is_write)\n\n{\n\n    int l, io_index;\n\n    uint8_t *ptr;\n\n    uint32_t val;\n\n    target_phys_addr_t page;\n\n    unsigned long pd;\n\n    PhysPageDesc *p;\n\n\n\n    while (len > 0) {\n\n        page = addr & TARGET_PAGE_MASK;\n\n        l = (page + TARGET_PAGE_SIZE) - addr;\n\n        if (l > len)\n\n            l = len;\n\n        p = phys_page_find(page >> TARGET_PAGE_BITS);\n\n        if (!p) {\n\n            pd = IO_MEM_UNASSIGNED;\n\n        } else {\n\n            pd = p->phys_offset;\n\n        }\n\n\n\n        if (is_write) {\n\n            if ((pd & ~TARGET_PAGE_MASK) != IO_MEM_RAM) {\n\n                io_index = (pd >> IO_MEM_SHIFT) & (IO_MEM_NB_ENTRIES - 1);\n\n                if (p)\n\n                    addr = (addr & ~TARGET_PAGE_MASK) + p->region_offset;\n\n                /* XXX: could force cpu_single_env to NULL to avoid\n\n                   potential bugs */\n\n                if (l >= 4 && ((addr & 3) == 0)) {\n\n                    /* 32 bit write access */\n\n                    val = ldl_p(buf);\n\n                    io_mem_write[io_index][2](io_mem_opaque[io_index], addr, val);\n\n                    l = 4;\n\n                } else if (l >= 2 && ((addr & 1) == 0)) {\n\n                    /* 16 bit write access */\n\n                    val = lduw_p(buf);\n\n                    io_mem_write[io_index][1](io_mem_opaque[io_index], addr, val);\n\n                    l = 2;\n\n                } else {\n\n                    /* 8 bit write access */\n\n                    val = ldub_p(buf);\n\n                    io_mem_write[io_index][0](io_mem_opaque[io_index], addr, val);\n\n                    l = 1;\n\n                }\n\n            } else {\n\n                unsigned long addr1;\n\n                addr1 = (pd & TARGET_PAGE_MASK) + (addr & ~TARGET_PAGE_MASK);\n\n                /* RAM case */\n\n                ptr = phys_ram_base + addr1;\n\n                memcpy(ptr, buf, l);\n\n                if (!cpu_physical_memory_is_dirty(addr1)) {\n\n                    /* invalidate code */\n\n                    tb_invalidate_phys_page_range(addr1, addr1 + l, 0);\n\n                    /* set dirty bit */\n\n                    phys_ram_dirty[addr1 >> TARGET_PAGE_BITS] |=\n\n                        (0xff & ~CODE_DIRTY_FLAG);\n\n                }\n\n            }\n\n        } else {\n\n            if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM &&\n\n                !(pd & IO_MEM_ROMD)) {\n\n                /* I/O case */\n\n                io_index = (pd >> IO_MEM_SHIFT) & (IO_MEM_NB_ENTRIES - 1);\n\n                if (p)\n\n                    addr = (addr & ~TARGET_PAGE_MASK) + p->region_offset;\n\n                if (l >= 4 && ((addr & 3) == 0)) {\n\n                    /* 32 bit read access */\n\n                    val = io_mem_read[io_index][2](io_mem_opaque[io_index], addr);\n\n                    stl_p(buf, val);\n\n                    l = 4;\n\n                } else if (l >= 2 && ((addr & 1) == 0)) {\n\n                    /* 16 bit read access */\n\n                    val = io_mem_read[io_index][1](io_mem_opaque[io_index], addr);\n\n                    stw_p(buf, val);\n\n                    l = 2;\n\n                } else {\n\n                    /* 8 bit read access */\n\n                    val = io_mem_read[io_index][0](io_mem_opaque[io_index], addr);\n\n                    stb_p(buf, val);\n\n                    l = 1;\n\n                }\n\n            } else {\n\n                /* RAM case */\n\n                ptr = phys_ram_base + (pd & TARGET_PAGE_MASK) +\n\n                    (addr & ~TARGET_PAGE_MASK);\n\n                memcpy(buf, ptr, l);\n\n            }\n\n        }\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n    }\n\n}\n", "idx": 4640, "_split": "valid", "_hash": "1b8ebebf214ad0586bfc59e0271a0309"}
{"project": "qemu", "commit_id": "5e52e5f903b2648c59030637e1610b32e965d615", "target": 1, "func": "VirtIODevice *virtio_serial_init(DeviceState *dev, virtio_serial_conf *conf)\n\n{\n\n    VirtIOSerial *vser;\n\n    VirtIODevice *vdev;\n\n    uint32_t i, max_supported_ports;\n\n\n\n    if (!conf->max_virtserial_ports)\n\n        return NULL;\n\n\n\n    /* Each port takes 2 queues, and one pair is for the control queue */\n\n    max_supported_ports = VIRTIO_PCI_QUEUE_MAX / 2 - 1;\n\n\n\n    if (conf->max_virtserial_ports > max_supported_ports) {\n\n        error_report(\"maximum ports supported: %u\", max_supported_ports);\n\n        return NULL;\n\n    }\n\n\n\n    vdev = virtio_common_init(\"virtio-serial\", VIRTIO_ID_CONSOLE,\n\n                              sizeof(struct virtio_console_config),\n\n                              sizeof(VirtIOSerial));\n\n\n\n    vser = DO_UPCAST(VirtIOSerial, vdev, vdev);\n\n\n\n    /* Spawn a new virtio-serial bus on which the ports will ride as devices */\n\n    vser->bus = virtser_bus_new(dev);\n\n    vser->bus->vser = vser;\n\n    QTAILQ_INIT(&vser->ports);\n\n\n\n    vser->bus->max_nr_ports = conf->max_virtserial_ports;\n\n    vser->ivqs = qemu_malloc(conf->max_virtserial_ports * sizeof(VirtQueue *));\n\n    vser->ovqs = qemu_malloc(conf->max_virtserial_ports * sizeof(VirtQueue *));\n\n\n\n    /* Add a queue for host to guest transfers for port 0 (backward compat) */\n\n    vser->ivqs[0] = virtio_add_queue(vdev, 128, handle_input);\n\n    /* Add a queue for guest to host transfers for port 0 (backward compat) */\n\n    vser->ovqs[0] = virtio_add_queue(vdev, 128, handle_output);\n\n\n\n    /* TODO: host to guest notifications can get dropped\n\n     * if the queue fills up. Implement queueing in host,\n\n     * this might also make it possible to reduce the control\n\n     * queue size: as guest preposts buffers there,\n\n     * this will save 4Kbyte of guest memory per entry. */\n\n\n\n    /* control queue: host to guest */\n\n    vser->c_ivq = virtio_add_queue(vdev, 32, control_in);\n\n    /* control queue: guest to host */\n\n    vser->c_ovq = virtio_add_queue(vdev, 32, control_out);\n\n\n\n    for (i = 1; i < vser->bus->max_nr_ports; i++) {\n\n        /* Add a per-port queue for host to guest transfers */\n\n        vser->ivqs[i] = virtio_add_queue(vdev, 128, handle_input);\n\n        /* Add a per-per queue for guest to host transfers */\n\n        vser->ovqs[i] = virtio_add_queue(vdev, 128, handle_output);\n\n    }\n\n\n\n    vser->config.max_nr_ports = tswap32(conf->max_virtserial_ports);\n\n    vser->ports_map = qemu_mallocz(((conf->max_virtserial_ports + 31) / 32)\n\n        * sizeof(vser->ports_map[0]));\n\n    /*\n\n     * Reserve location 0 for a console port for backward compat\n\n     * (old kernel, new qemu)\n\n     */\n\n    mark_port_added(vser, 0);\n\n\n\n    vser->vdev.get_features = get_features;\n\n    vser->vdev.get_config = get_config;\n\n    vser->vdev.set_config = set_config;\n\n\n\n    vser->qdev = dev;\n\n\n\n    /*\n\n     * Register for the savevm section with the virtio-console name\n\n     * to preserve backward compat\n\n     */\n\n    register_savevm(dev, \"virtio-console\", -1, 3, virtio_serial_save,\n\n                    virtio_serial_load, vser);\n\n\n\n    return vdev;\n\n}\n", "idx": 4676, "_split": "valid", "_hash": "10ed062e2a1256789e05d758787463a5"}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_fstat(FsContext *fs_ctx, int fid_type,\n\n                       V9fsFidOpenState *fs, struct stat *stbuf)\n\n{\n\n    int fd;\n\n\n\n    if (fid_type == P9_FID_DIR) {\n\n        fd = dirfd(fs->dir);\n\n    } else {\n\n        fd = fs->fd;\n\n    }\n\n    return fstat(fd, stbuf);\n\n}\n", "idx": 4708, "_split": "valid", "_hash": "f35beb74b85d84050de5ad6a1e7295ce"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t cmd646_data_read(void *opaque, target_phys_addr_t addr,\n\n                                 unsigned size)\n\n{\n\n    CMD646BAR *cmd646bar = opaque;\n\n\n\n    if (size == 1) {\n\n        return ide_ioport_read(cmd646bar->bus, addr);\n\n    } else if (addr == 0) {\n\n        if (size == 2) {\n\n            return ide_data_readw(cmd646bar->bus, addr);\n\n        } else {\n\n            return ide_data_readl(cmd646bar->bus, addr);\n\n        }\n\n    }\n\n    return ((uint64_t)1 << (size * 8)) - 1;\n\n}\n", "idx": 4713, "_split": "valid", "_hash": "274c3153bd7e59aa85c7463140def5be"}
{"project": "qemu", "commit_id": "b9bec74bcb16519a876ec21cd5277c526a9b512d", "target": 0, "func": "int kvm_arch_insert_sw_breakpoint(CPUState *env, struct kvm_sw_breakpoint *bp)\n\n{\n\n    static const uint8_t int3 = 0xcc;\n\n\n\n    if (cpu_memory_rw_debug(env, bp->pc, (uint8_t *)&bp->saved_insn, 1, 0) ||\n\n        cpu_memory_rw_debug(env, bp->pc, (uint8_t *)&int3, 1, 1))\n\n        return -EINVAL;\n\n    return 0;\n\n}\n", "idx": 4723, "_split": "valid", "_hash": "6fc6effc450554073a7ad48f0dda0a73"}
{"project": "qemu", "commit_id": "966439a67830239a6c520c5df6c55627b8153c8b", "target": 1, "func": "void OPPROTO op_check_addo (void)\n\n{\n\n    if (likely(!(((uint32_t)T2 ^ (uint32_t)T1 ^ UINT32_MAX) &\n\n                 ((uint32_t)T2 ^ (uint32_t)T0) & (1UL << 31)))) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 4757, "_split": "valid", "_hash": "02c4d931d097c9ebd8ef43008da25f67"}
{"project": "qemu", "commit_id": "b6b2c9628084f1672b92393cf84039a075a95301", "target": 1, "func": "static gpointer writeout_thread(gpointer opaque)\n\n{\n\n    TraceRecord *recordptr;\n\n    union {\n\n        TraceRecord rec;\n\n        uint8_t bytes[sizeof(TraceRecord) + sizeof(uint64_t)];\n\n    } dropped;\n\n    unsigned int idx = 0;\n\n    int dropped_count;\n\n    size_t unused __attribute__ ((unused));\n\n\n\n    for (;;) {\n\n        wait_for_trace_records_available();\n\n\n\n        if (g_atomic_int_get(&dropped_events)) {\n\n            dropped.rec.event = DROPPED_EVENT_ID,\n\n            dropped.rec.timestamp_ns = get_clock();\n\n            dropped.rec.length = sizeof(TraceRecord) + sizeof(uint64_t),\n\n            dropped.rec.reserved = 0;\n\n            while (1) {\n\n                dropped_count = g_atomic_int_get(&dropped_events);\n\n                if (g_atomic_int_compare_and_exchange(&dropped_events,\n\n                                                      dropped_count, 0)) {\n\n                    break;\n\n                }\n\n            }\n\n            dropped.rec.arguments[0] = dropped_count;\n\n            unused = fwrite(&dropped.rec, dropped.rec.length, 1, trace_fp);\n\n        }\n\n\n\n        while (get_trace_record(idx, &recordptr)) {\n\n            unused = fwrite(recordptr, recordptr->length, 1, trace_fp);\n\n            writeout_idx += recordptr->length;\n\n            free(recordptr); /* dont use g_free, can deadlock when traced */\n\n            idx = writeout_idx % TRACE_BUF_LEN;\n\n        }\n\n\n\n        fflush(trace_fp);\n\n    }\n\n    return NULL;\n\n}\n", "idx": 4767, "_split": "valid", "_hash": "dcc3b78a0bb11d552f23ae0dfbed05c8"}
{"project": "qemu", "commit_id": "ce137829e7e58fcdc5ba63b5e256f972e80be438", "target": 1, "func": "static int handle_renames_and_mkdirs(BDRVVVFATState* s)\n\n{\n\n    int i;\n\n\n\n#ifdef DEBUG\n\n    fprintf(stderr, \"handle_renames\\n\");\n\n    for (i = 0; i < s->commits.next; i++) {\n\n\tcommit_t* commit = array_get(&(s->commits), i);\n\n\tfprintf(stderr, \"%d, %s (%d, %d)\\n\", i, commit->path ? commit->path : \"(null)\", commit->param.rename.cluster, commit->action);\n\n    }\n\n#endif\n\n\n\n    for (i = 0; i < s->commits.next;) {\n\n\tcommit_t* commit = array_get(&(s->commits), i);\n\n\tif (commit->action == ACTION_RENAME) {\n\n\t    mapping_t* mapping = find_mapping_for_cluster(s,\n\n\t\t    commit->param.rename.cluster);\n\n\t    char* old_path = mapping->path;\n\n\n\n\t    assert(commit->path);\n\n\t    mapping->path = commit->path;\n\n\t    if (rename(old_path, mapping->path))\n\n\t\treturn -2;\n\n\n\n\t    if (mapping->mode & MODE_DIRECTORY) {\n\n\t\tint l1 = strlen(mapping->path);\n\n\t\tint l2 = strlen(old_path);\n\n\t\tint diff = l1 - l2;\n\n\t\tdirentry_t* direntry = array_get(&(s->directory),\n\n\t\t\tmapping->info.dir.first_dir_index);\n\n\t\tuint32_t c = mapping->begin;\n\n\t\tint i = 0;\n\n\n\n\t\t/* recurse */\n\n\t\twhile (!fat_eof(s, c)) {\n\n\t\t    do {\n\n\t\t\tdirentry_t* d = direntry + i;\n\n\n\n\t\t\tif (is_file(d) || (is_directory(d) && !is_dot(d))) {\n\n\t\t\t    mapping_t* m = find_mapping_for_cluster(s,\n\n\t\t\t\t    begin_of_direntry(d));\n\n\t\t\t    int l = strlen(m->path);\n\n\t\t\t    char* new_path = g_malloc(l + diff + 1);\n\n\n\n\t\t\t    assert(!strncmp(m->path, mapping->path, l2));\n\n\n\n                            pstrcpy(new_path, l + diff + 1, mapping->path);\n\n                            pstrcpy(new_path + l1, l + diff + 1 - l1,\n\n                                    m->path + l2);\n\n\n\n\t\t\t    schedule_rename(s, m->begin, new_path);\n\n\t\t\t}\n\n\t\t\ti++;\n\n\t\t    } while((i % (0x10 * s->sectors_per_cluster)) != 0);\n\n\t\t    c = fat_get(s, c);\n\n\t\t}\n\n\t    }\n\n\n\n\t    free(old_path);\n\n\t    array_remove(&(s->commits), i);\n\n\t    continue;\n\n\t} else if (commit->action == ACTION_MKDIR) {\n\n\t    mapping_t* mapping;\n\n\t    int j, parent_path_len;\n\n\n\n#ifdef __MINGW32__\n\n            if (mkdir(commit->path))\n\n                return -5;\n\n#else\n\n            if (mkdir(commit->path, 0755))\n\n                return -5;\n\n#endif\n\n\n\n\t    mapping = insert_mapping(s, commit->param.mkdir.cluster,\n\n\t\t    commit->param.mkdir.cluster + 1);\n\n\t    if (mapping == NULL)\n\n\t\treturn -6;\n\n\n\n\t    mapping->mode = MODE_DIRECTORY;\n\n\t    mapping->read_only = 0;\n\n\t    mapping->path = commit->path;\n\n\t    j = s->directory.next;\n\n\t    assert(j);\n\n\t    insert_direntries(s, s->directory.next,\n\n\t\t    0x10 * s->sectors_per_cluster);\n\n\t    mapping->info.dir.first_dir_index = j;\n\n\n\n\t    parent_path_len = strlen(commit->path)\n\n\t\t- strlen(get_basename(commit->path)) - 1;\n\n\t    for (j = 0; j < s->mapping.next; j++) {\n\n\t\tmapping_t* m = array_get(&(s->mapping), j);\n\n\t\tif (m->first_mapping_index < 0 && m != mapping &&\n\n\t\t\t!strncmp(m->path, mapping->path, parent_path_len) &&\n\n\t\t\tstrlen(m->path) == parent_path_len)\n\n\t\t    break;\n\n\t    }\n\n\t    assert(j < s->mapping.next);\n\n\t    mapping->info.dir.parent_mapping_index = j;\n\n\n\n\t    array_remove(&(s->commits), i);\n\n\t    continue;\n\n\t}\n\n\n\n\ti++;\n\n    }\n\n    return 0;\n\n}\n", "idx": 4783, "_split": "valid", "_hash": "1e3b892cc89796a37b2f8218f58da9ed"}
{"project": "qemu", "commit_id": "e0dadc1e9ef1f35208e5d2af9c7740c18a0b769f", "target": 1, "func": "AUXBus *aux_init_bus(DeviceState *parent, const char *name)\n\n{\n\n    AUXBus *bus;\n\n\n\n    bus = AUX_BUS(qbus_create(TYPE_AUX_BUS, parent, name));\n\n    bus->bridge = AUXTOI2C(qdev_create(BUS(bus), TYPE_AUXTOI2C));\n\n\n\n    /* Memory related. */\n\n    bus->aux_io = g_malloc(sizeof(*bus->aux_io));\n\n    memory_region_init(bus->aux_io, OBJECT(bus), \"aux-io\", (1 << 20));\n\n    address_space_init(&bus->aux_addr_space, bus->aux_io, \"aux-io\");\n\n    return bus;\n\n}\n", "idx": 4794, "_split": "valid", "_hash": "77ca0d73b7923dae3c524e2d0fad0ffd"}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void qdev_print_devinfo(DeviceClass *dc)\n\n{\n\n    error_printf(\"name \\\"%s\\\"\", object_class_get_name(OBJECT_CLASS(dc)));\n\n    if (dc->bus_type) {\n\n        error_printf(\", bus %s\", dc->bus_type);\n\n    }\n\n    if (qdev_class_has_alias(dc)) {\n\n        error_printf(\", alias \\\"%s\\\"\", qdev_class_get_alias(dc));\n\n    }\n\n    if (dc->desc) {\n\n        error_printf(\", desc \\\"%s\\\"\", dc->desc);\n\n    }\n\n    if (dc->no_user) {\n\n        error_printf(\", no-user\");\n\n    }\n\n    error_printf(\"\\n\");\n\n}\n", "idx": 4818, "_split": "valid", "_hash": "a0e01d4e51351b5cf3c330b572c4ff7d"}
{"project": "qemu", "commit_id": "1ac157da77c863b62b1d2f467626a440d57cf17d", "target": 0, "func": "static void switch_tss(int tss_selector, \n\n                       uint32_t e1, uint32_t e2, int source)\n\n{\n\n    int tss_limit, tss_limit_max, type, old_tss_limit_max, old_type, v1, v2, i;\n\n    uint8_t *tss_base;\n\n    uint32_t new_regs[8], new_segs[6];\n\n    uint32_t new_eflags, new_eip, new_cr3, new_ldt, new_trap;\n\n    uint32_t old_eflags, eflags_mask;\n\n    SegmentCache *dt;\n\n    int index;\n\n    uint8_t *ptr;\n\n\n\n    type = (e2 >> DESC_TYPE_SHIFT) & 0xf;\n\n#ifdef DEBUG_PCALL\n\n    if (loglevel)\n\n        fprintf(logfile, \"switch_tss: sel=0x%04x type=%d src=%d\\n\", tss_selector, type, source);\n\n#endif\n\n\n\n    /* if task gate, we read the TSS segment and we load it */\n\n    if (type == 5) {\n\n        if (!(e2 & DESC_P_MASK))\n\n            raise_exception_err(EXCP0B_NOSEG, tss_selector & 0xfffc);\n\n        tss_selector = e1 >> 16;\n\n        if (tss_selector & 4)\n\n            raise_exception_err(EXCP0A_TSS, tss_selector & 0xfffc);\n\n        if (load_segment(&e1, &e2, tss_selector) != 0)\n\n            raise_exception_err(EXCP0D_GPF, tss_selector & 0xfffc);\n\n        if (e2 & DESC_S_MASK)\n\n            raise_exception_err(EXCP0D_GPF, tss_selector & 0xfffc);\n\n        type = (e2 >> DESC_TYPE_SHIFT) & 0xf;\n\n        if ((type & 7) != 1)\n\n            raise_exception_err(EXCP0D_GPF, tss_selector & 0xfffc);\n\n    }\n\n\n\n    if (!(e2 & DESC_P_MASK))\n\n        raise_exception_err(EXCP0B_NOSEG, tss_selector & 0xfffc);\n\n\n\n    if (type & 8)\n\n        tss_limit_max = 103;\n\n    else\n\n        tss_limit_max = 43;\n\n    tss_limit = get_seg_limit(e1, e2);\n\n    tss_base = get_seg_base(e1, e2);\n\n    if ((tss_selector & 4) != 0 || \n\n        tss_limit < tss_limit_max)\n\n        raise_exception_err(EXCP0A_TSS, tss_selector & 0xfffc);\n\n    old_type = (env->tr.flags >> DESC_TYPE_SHIFT) & 0xf;\n\n    if (old_type & 8)\n\n        old_tss_limit_max = 103;\n\n    else\n\n        old_tss_limit_max = 43;\n\n\n\n    /* read all the registers from the new TSS */\n\n    if (type & 8) {\n\n        /* 32 bit */\n\n        new_cr3 = ldl_kernel(tss_base + 0x1c);\n\n        new_eip = ldl_kernel(tss_base + 0x20);\n\n        new_eflags = ldl_kernel(tss_base + 0x24);\n\n        for(i = 0; i < 8; i++)\n\n            new_regs[i] = ldl_kernel(tss_base + (0x28 + i * 4));\n\n        for(i = 0; i < 6; i++)\n\n            new_segs[i] = lduw_kernel(tss_base + (0x48 + i * 4));\n\n        new_ldt = lduw_kernel(tss_base + 0x60);\n\n        new_trap = ldl_kernel(tss_base + 0x64);\n\n    } else {\n\n        /* 16 bit */\n\n        new_cr3 = 0;\n\n        new_eip = lduw_kernel(tss_base + 0x0e);\n\n        new_eflags = lduw_kernel(tss_base + 0x10);\n\n        for(i = 0; i < 8; i++)\n\n            new_regs[i] = lduw_kernel(tss_base + (0x12 + i * 2)) | 0xffff0000;\n\n        for(i = 0; i < 4; i++)\n\n            new_segs[i] = lduw_kernel(tss_base + (0x22 + i * 4));\n\n        new_ldt = lduw_kernel(tss_base + 0x2a);\n\n        new_segs[R_FS] = 0;\n\n        new_segs[R_GS] = 0;\n\n        new_trap = 0;\n\n    }\n\n    \n\n    /* NOTE: we must avoid memory exceptions during the task switch,\n\n       so we make dummy accesses before */\n\n    /* XXX: it can still fail in some cases, so a bigger hack is\n\n       necessary to valid the TLB after having done the accesses */\n\n\n\n    v1 = ldub_kernel(env->tr.base);\n\n    v2 = ldub(env->tr.base + old_tss_limit_max);\n\n    stb_kernel(env->tr.base, v1);\n\n    stb_kernel(env->tr.base + old_tss_limit_max, v2);\n\n    \n\n    /* clear busy bit (it is restartable) */\n\n    if (source == SWITCH_TSS_JMP || source == SWITCH_TSS_IRET) {\n\n        uint8_t *ptr;\n\n        uint32_t e2;\n\n        ptr = env->gdt.base + (env->tr.selector << 3);\n\n        e2 = ldl_kernel(ptr + 4);\n\n        e2 &= ~DESC_TSS_BUSY_MASK;\n\n        stl_kernel(ptr + 4, e2);\n\n    }\n\n    old_eflags = compute_eflags();\n\n    if (source == SWITCH_TSS_IRET)\n\n        old_eflags &= ~NT_MASK;\n\n    \n\n    /* save the current state in the old TSS */\n\n    if (type & 8) {\n\n        /* 32 bit */\n\n        stl_kernel(env->tr.base + 0x20, env->eip);\n\n        stl_kernel(env->tr.base + 0x24, old_eflags);\n\n        for(i = 0; i < 8; i++)\n\n            stl_kernel(env->tr.base + (0x28 + i * 4), env->regs[i]);\n\n        for(i = 0; i < 6; i++)\n\n            stw_kernel(env->tr.base + (0x48 + i * 4), env->segs[i].selector);\n\n    } else {\n\n        /* 16 bit */\n\n        stw_kernel(env->tr.base + 0x0e, new_eip);\n\n        stw_kernel(env->tr.base + 0x10, old_eflags);\n\n        for(i = 0; i < 8; i++)\n\n            stw_kernel(env->tr.base + (0x12 + i * 2), env->regs[i]);\n\n        for(i = 0; i < 4; i++)\n\n            stw_kernel(env->tr.base + (0x22 + i * 4), env->segs[i].selector);\n\n    }\n\n    \n\n    /* now if an exception occurs, it will occurs in the next task\n\n       context */\n\n\n\n    if (source == SWITCH_TSS_CALL) {\n\n        stw_kernel(tss_base, env->tr.selector);\n\n        new_eflags |= NT_MASK;\n\n    }\n\n\n\n    /* set busy bit */\n\n    if (source == SWITCH_TSS_JMP || source == SWITCH_TSS_CALL) {\n\n        uint8_t *ptr;\n\n        uint32_t e2;\n\n        ptr = env->gdt.base + (tss_selector << 3);\n\n        e2 = ldl_kernel(ptr + 4);\n\n        e2 |= DESC_TSS_BUSY_MASK;\n\n        stl_kernel(ptr + 4, e2);\n\n    }\n\n\n\n    /* set the new CPU state */\n\n    /* from this point, any exception which occurs can give problems */\n\n    env->cr[0] |= CR0_TS_MASK;\n\n    env->tr.selector = tss_selector;\n\n    env->tr.base = tss_base;\n\n    env->tr.limit = tss_limit;\n\n    env->tr.flags = e2 & ~DESC_TSS_BUSY_MASK;\n\n    \n\n    if ((type & 8) && (env->cr[0] & CR0_PG_MASK)) {\n\n        env->cr[3] = new_cr3;\n\n        cpu_x86_update_cr3(env);\n\n    }\n\n    \n\n    /* load all registers without an exception, then reload them with\n\n       possible exception */\n\n    env->eip = new_eip;\n\n    eflags_mask = TF_MASK | AC_MASK | ID_MASK | \n\n        IF_MASK | IOPL_MASK | VM_MASK | RF_MASK | NT_MASK;\n\n    if (!(type & 8))\n\n        eflags_mask &= 0xffff;\n\n    load_eflags(new_eflags, eflags_mask);\n\n    for(i = 0; i < 8; i++)\n\n        env->regs[i] = new_regs[i];\n\n    if (new_eflags & VM_MASK) {\n\n        for(i = 0; i < 6; i++) \n\n            load_seg_vm(i, new_segs[i]);\n\n        /* in vm86, CPL is always 3 */\n\n        cpu_x86_set_cpl(env, 3);\n\n    } else {\n\n        /* CPL is set the RPL of CS */\n\n        cpu_x86_set_cpl(env, new_segs[R_CS] & 3);\n\n        /* first just selectors as the rest may trigger exceptions */\n\n        for(i = 0; i < 6; i++)\n\n            cpu_x86_load_seg_cache(env, i, new_segs[i], NULL, 0, 0);\n\n    }\n\n    \n\n    env->ldt.selector = new_ldt & ~4;\n\n    env->ldt.base = NULL;\n\n    env->ldt.limit = 0;\n\n    env->ldt.flags = 0;\n\n\n\n    /* load the LDT */\n\n    if (new_ldt & 4)\n\n        raise_exception_err(EXCP0A_TSS, new_ldt & 0xfffc);\n\n\n\n    if ((new_ldt & 0xfffc) != 0) {\n\n        dt = &env->gdt;\n\n        index = new_ldt & ~7;\n\n        if ((index + 7) > dt->limit)\n\n            raise_exception_err(EXCP0A_TSS, new_ldt & 0xfffc);\n\n        ptr = dt->base + index;\n\n        e1 = ldl_kernel(ptr);\n\n        e2 = ldl_kernel(ptr + 4);\n\n        if ((e2 & DESC_S_MASK) || ((e2 >> DESC_TYPE_SHIFT) & 0xf) != 2)\n\n            raise_exception_err(EXCP0A_TSS, new_ldt & 0xfffc);\n\n        if (!(e2 & DESC_P_MASK))\n\n            raise_exception_err(EXCP0A_TSS, new_ldt & 0xfffc);\n\n        load_seg_cache_raw_dt(&env->ldt, e1, e2);\n\n    }\n\n    \n\n    /* load the segments */\n\n    if (!(new_eflags & VM_MASK)) {\n\n        tss_load_seg(R_CS, new_segs[R_CS]);\n\n        tss_load_seg(R_SS, new_segs[R_SS]);\n\n        tss_load_seg(R_ES, new_segs[R_ES]);\n\n        tss_load_seg(R_DS, new_segs[R_DS]);\n\n        tss_load_seg(R_FS, new_segs[R_FS]);\n\n        tss_load_seg(R_GS, new_segs[R_GS]);\n\n    }\n\n    \n\n    /* check that EIP is in the CS segment limits */\n\n    if (new_eip > env->segs[R_CS].limit) {\n\n        raise_exception_err(EXCP0D_GPF, 0);\n\n    }\n\n}\n", "idx": 4830, "_split": "valid", "_hash": "b7d29e35d96524d7342d207d6969c56b"}
{"project": "qemu", "commit_id": "cab565c412a5634ce26f4d24ae65907c3108bdb0", "target": 0, "func": "uint32_t HELPER(neon_acgt_f32)(uint32_t a, uint32_t b)\n\n{\n\n    float32 f0 = float32_abs(make_float32(a));\n\n    float32 f1 = float32_abs(make_float32(b));\n\n    if (float32_compare_quiet(f0, f1, NFS) == float_relation_greater) {\n\n        return ~0;\n\n    }\n\n    return 0;\n\n}\n", "idx": 4832, "_split": "valid", "_hash": "83d3e9dd3c303821768a8690a26f27d3"}
{"project": "qemu", "commit_id": "5379229a2708df3a1506113315214c3ce5325859", "target": 0, "func": "sosendto(struct socket *so, struct mbuf *m)\n\n{\n\n\tSlirp *slirp = so->slirp;\n\n\tint ret;\n\n\tstruct sockaddr_in addr;\n\n\n\n\tDEBUG_CALL(\"sosendto\");\n\n\tDEBUG_ARG(\"so = %p\", so);\n\n\tDEBUG_ARG(\"m = %p\", m);\n\n\n\n        addr.sin_family = AF_INET;\n\n\tif ((so->so_faddr.s_addr & slirp->vnetwork_mask.s_addr) ==\n\n\t    slirp->vnetwork_addr.s_addr) {\n\n\t  /* It's an alias */\n\n\t  if (so->so_faddr.s_addr == slirp->vnameserver_addr.s_addr) {\n\n\t    if (get_dns_addr(&addr.sin_addr) < 0)\n\n\t      addr.sin_addr = loopback_addr;\n\n\t  } else {\n\n\t    addr.sin_addr = loopback_addr;\n\n\t  }\n\n\t} else\n\n\t  addr.sin_addr = so->so_faddr;\n\n\taddr.sin_port = so->so_fport;\n\n\n\n\tDEBUG_MISC((dfd, \" sendto()ing, addr.sin_port=%d, addr.sin_addr.s_addr=%.16s\\n\", ntohs(addr.sin_port), inet_ntoa(addr.sin_addr)));\n\n\n\n\t/* Don't care what port we get */\n\n\tret = sendto(so->s, m->m_data, m->m_len, 0,\n\n\t\t     (struct sockaddr *)&addr, sizeof (struct sockaddr));\n\n\tif (ret < 0)\n\n\t\treturn -1;\n\n\n\n\t/*\n\n\t * Kill the socket if there's no reply in 4 minutes,\n\n\t * but only if it's an expirable socket\n\n\t */\n\n\tif (so->so_expire)\n\n\t\tso->so_expire = curtime + SO_EXPIRE;\n\n\tso->so_state &= SS_PERSISTENT_MASK;\n\n\tso->so_state |= SS_ISFCONNECTED; /* So that it gets select()ed */\n\n\treturn 0;\n\n}\n", "idx": 4847, "_split": "valid", "_hash": "4ae829a5d7787b1c91fa5c247d72965c"}
{"project": "qemu", "commit_id": "ba41249678f8c1504bf07706ddb0eda0d36cccc2", "target": 0, "func": "long do_rt_sigreturn(CPUSH4State *regs)\n\n{\n\n    struct target_rt_sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    sigset_t blocked;\n\n    target_ulong r0;\n\n\n\n    frame_addr = regs->gregs[15];\n\n    trace_user_do_rt_sigreturn(regs, frame_addr);\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1)) {\n\n        goto badframe;\n\n    }\n\n\n\n    target_to_host_sigset(&blocked, &frame->uc.tuc_sigmask);\n\n    do_sigprocmask(SIG_SETMASK, &blocked, NULL);\n\n\n\n    restore_sigcontext(regs, &frame->uc.tuc_mcontext, &r0);\n\n\n\n    if (do_sigaltstack(frame_addr +\n\n                       offsetof(struct target_rt_sigframe, uc.tuc_stack),\n\n                       0, get_sp_from_cpustate(regs)) == -EFAULT) {\n\n        goto badframe;\n\n    }\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return r0;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 4886, "_split": "valid", "_hash": "b8a7caa77e103504f6ea612cb6865e6a"}
{"project": "qemu", "commit_id": "425532d71d5d295cc9c649500e4969ac621ce51d", "target": 0, "func": "static void patch_reloc(uint8_t *code_ptr, int type,\n\n                        intptr_t value, intptr_t addend)\n\n{\n\n    uint32_t insn;\n\n    value += addend;\n\n    switch (type) {\n\n    case R_SPARC_32:\n\n        if (value != (uint32_t)value) {\n\n            tcg_abort();\n\n        }\n\n        *(uint32_t *)code_ptr = value;\n\n        break;\n\n    case R_SPARC_WDISP16:\n\n        value -= (intptr_t)code_ptr;\n\n        if (!check_fit_tl(value >> 2, 16)) {\n\n            tcg_abort();\n\n        }\n\n        insn = *(uint32_t *)code_ptr;\n\n        insn &= ~INSN_OFF16(-1);\n\n        insn |= INSN_OFF16(value);\n\n        *(uint32_t *)code_ptr = insn;\n\n        break;\n\n    case R_SPARC_WDISP19:\n\n        value -= (intptr_t)code_ptr;\n\n        if (!check_fit_tl(value >> 2, 19)) {\n\n            tcg_abort();\n\n        }\n\n        insn = *(uint32_t *)code_ptr;\n\n        insn &= ~INSN_OFF19(-1);\n\n        insn |= INSN_OFF19(value);\n\n        *(uint32_t *)code_ptr = insn;\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n}\n", "idx": 4891, "_split": "valid", "_hash": "4cb412b3267804fbc58eac0b1d46d5df"}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_unlinkat(FsContext *ctx, V9fsPath *dir,\n\n                               const char *name, int flags)\n\n{\n\n    errno = EPERM;\n\n    return -1;\n\n}\n", "idx": 4903, "_split": "valid", "_hash": "cc822ed3dbca937d70b8589af8ac9b12"}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "void json_start_object(QJSON *json, const char *name)\n\n{\n\n    json_emit_element(json, name);\n\n    qstring_append(json->str, \"{ \");\n\n    json->omit_comma = true;\n\n}\n", "idx": 4909, "_split": "valid", "_hash": "7f4d6601702ffcb305f2ea8db153a676"}
{"project": "qemu", "commit_id": "ac531cb6e542b1e61d668604adf9dc5306a948c0", "target": 0, "func": "START_TEST(qdict_get_int_test)\n\n{\n\n    int ret;\n\n    const int value = 100;\n\n    const char *key = \"int\";\n\n\n\n    qdict_put(tests_dict, key, qint_from_int(value));\n\n\n\n    ret = qdict_get_int(tests_dict, key);\n\n    fail_unless(ret == value);\n\n}\n", "idx": 4913, "_split": "valid", "_hash": "fb75a0f1540c0649e716f8f81b5fc0ce"}
{"project": "qemu", "commit_id": "806c9d71abbcd283c0a6d8250e5a6db951ba9494", "target": 0, "func": "static void float64_maddsub_update_excp(CPUPPCState *env, float64 arg1,\n\n                                        float64 arg2, float64 arg3,\n\n                                        unsigned int madd_flags)\n\n{\n\n    if (unlikely((float64_is_infinity(arg1) && float64_is_zero(arg2)) ||\n\n                 (float64_is_zero(arg1) && float64_is_infinity(arg2)))) {\n\n        /* Multiplication of zero by infinity */\n\n        arg1 = float_invalid_op_excp(env, POWERPC_EXCP_FP_VXIMZ, 1);\n\n    } else if (unlikely(float64_is_signaling_nan(arg1, &env->fp_status) ||\n\n                        float64_is_signaling_nan(arg2, &env->fp_status) ||\n\n                        float64_is_signaling_nan(arg3, &env->fp_status))) {\n\n        /* sNaN operation */\n\n        float_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN, 1);\n\n    } else if ((float64_is_infinity(arg1) || float64_is_infinity(arg2)) &&\n\n               float64_is_infinity(arg3)) {\n\n        uint8_t aSign, bSign, cSign;\n\n\n\n        aSign = float64_is_neg(arg1);\n\n        bSign = float64_is_neg(arg2);\n\n        cSign = float64_is_neg(arg3);\n\n        if (madd_flags & float_muladd_negate_c) {\n\n            cSign ^= 1;\n\n        }\n\n        if (aSign ^ bSign ^ cSign) {\n\n            float_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI, 1);\n\n        }\n\n    }\n\n}\n", "idx": 4916, "_split": "valid", "_hash": "681842eda8b9929eebd127e88bb1b1b7"}
{"project": "qemu", "commit_id": "00cf57747db98c6a9e4219cea39ac3113dde6993", "target": 0, "func": "static uint32_t check_alarm(RTCState *s)\n\n{\n\n    uint8_t alarm_hour, alarm_min, alarm_sec;\n\n    uint8_t cur_hour, cur_min, cur_sec;\n\n\n\n    alarm_sec = rtc_from_bcd(s, s->cmos_data[RTC_SECONDS_ALARM]);\n\n    alarm_min = rtc_from_bcd(s, s->cmos_data[RTC_MINUTES_ALARM]);\n\n    alarm_hour = rtc_from_bcd(s, s->cmos_data[RTC_HOURS_ALARM]);\n\n    alarm_hour = convert_hour(s, alarm_hour);\n\n\n\n    cur_sec = rtc_from_bcd(s, s->cmos_data[RTC_SECONDS]);\n\n    cur_min = rtc_from_bcd(s, s->cmos_data[RTC_MINUTES]);\n\n    cur_hour = rtc_from_bcd(s, s->cmos_data[RTC_HOURS]);\n\n    cur_hour = convert_hour(s, cur_hour);\n\n\n\n    if (((s->cmos_data[RTC_SECONDS_ALARM] & 0xc0) == 0xc0\n\n                || alarm_sec == cur_sec) &&\n\n            ((s->cmos_data[RTC_MINUTES_ALARM] & 0xc0) == 0xc0\n\n             || alarm_min == cur_min) &&\n\n            ((s->cmos_data[RTC_HOURS_ALARM] & 0xc0) == 0xc0\n\n             || alarm_hour == cur_hour)) {\n\n        return 1;\n\n    }\n\n    return 0;\n\n\n\n}\n", "idx": 4930, "_split": "valid", "_hash": "ce60efd5b559a4ffdd553cfdadfe7b62"}
{"project": "qemu", "commit_id": "ce0bd027df9c62766a5417521d0f08f27359d43f", "target": 0, "func": "static int get_dns_addr(struct in_addr *pdns_addr)\n\n{\n\n    char buff[512];\n\n    char buff2[257];\n\n    FILE *f;\n\n    int found = 0;\n\n    struct in_addr tmp_addr;\n\n\n\n    f = fopen(\"/etc/resolv.conf\", \"r\");\n\n    if (!f)\n\n        return -1;\n\n\n\n#ifdef DEBUG\n\n    lprint(\"IP address of your DNS(s): \");\n\n#endif\n\n    while (fgets(buff, 512, f) != NULL) {\n\n        if (sscanf(buff, \"nameserver%*[ \\t]%256s\", buff2) == 1) {\n\n            if (!inet_aton(buff2, &tmp_addr))\n\n                continue;\n\n            if (tmp_addr.s_addr == loopback_addr.s_addr)\n\n                tmp_addr = our_addr;\n\n            /* If it's the first one, set it to dns_addr */\n\n            if (!found)\n\n                *pdns_addr = tmp_addr;\n\n#ifdef DEBUG\n\n            else\n\n                lprint(\", \");\n\n#endif\n\n            if (++found > 3) {\n\n#ifdef DEBUG\n\n                lprint(\"(more)\");\n\n#endif\n\n                break;\n\n            }\n\n#ifdef DEBUG\n\n            else\n\n                lprint(\"%s\", inet_ntoa(tmp_addr));\n\n#endif\n\n        }\n\n    }\n\n    fclose(f);\n\n    if (!found)\n\n        return -1;\n\n    return 0;\n\n}\n", "idx": 4937, "_split": "valid", "_hash": "2dc30c11c0d122edd33c331b72164152"}
{"project": "qemu", "commit_id": "2bbf11d753761ca537333c2bd7ddadb06758f62c", "target": 0, "func": "static bool aio_epoll_try_enable(AioContext *ctx)\n\n{\n\n    AioHandler *node;\n\n    struct epoll_event event;\n\n\n\n    QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n        int r;\n\n        if (node->deleted || !node->pfd.events) {\n\n            continue;\n\n        }\n\n        event.events = epoll_events_from_pfd(node->pfd.events);\n\n        event.data.ptr = node;\n\n        r = epoll_ctl(ctx->epollfd, EPOLL_CTL_ADD, node->pfd.fd, &event);\n\n        if (r) {\n\n            return false;\n\n        }\n\n    }\n\n    ctx->epoll_enabled = true;\n\n    return true;\n\n}\n", "idx": 4945, "_split": "valid", "_hash": "9ec1e5a017e41d35988f05ca77fe7b8a"}
{"project": "qemu", "commit_id": "f61eddcb2bb5cbbdd1d911b7e937db9affc29028", "target": 0, "func": "static int bt_parse(const char *opt)\n\n{\n\n    const char *endp, *p;\n\n    int vlan;\n\n\n\n    if (strstart(opt, \"hci\", &endp)) {\n\n        if (!*endp || *endp == ',') {\n\n            if (*endp)\n\n                if (!strstart(endp, \",vlan=\", 0))\n\n                    opt = endp + 1;\n\n\n\n            return bt_hci_parse(opt);\n\n       }\n\n    } else if (strstart(opt, \"vhci\", &endp)) {\n\n        if (!*endp || *endp == ',') {\n\n            if (*endp) {\n\n                if (strstart(endp, \",vlan=\", &p)) {\n\n                    vlan = strtol(p, (char **) &endp, 0);\n\n                    if (*endp) {\n\n                        fprintf(stderr, \"qemu: bad scatternet '%s'\\n\", p);\n\n                        return 1;\n\n                    }\n\n                } else {\n\n                    fprintf(stderr, \"qemu: bad parameter '%s'\\n\", endp + 1);\n\n                    return 1;\n\n                }\n\n            } else\n\n                vlan = 0;\n\n\n\n            bt_vhci_add(vlan);\n\n            return 0;\n\n        }\n\n    } else if (strstart(opt, \"device:\", &endp))\n\n        return !bt_device_add(endp);\n\n\n\n    fprintf(stderr, \"qemu: bad bluetooth parameter '%s'\\n\", opt);\n\n    return 1;\n\n}\n", "idx": 4948, "_split": "valid", "_hash": "215f1cc04a5a0a82ec88f26c6ab7034b"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_mpui_io_write(void *opaque, target_phys_addr_t addr,\n\n                               uint64_t value, unsigned size)\n\n{\n\n    /* FIXME: infinite loop */\n\n    omap_badwidth_write16(opaque, addr, value);\n\n}\n", "idx": 4949, "_split": "valid", "_hash": "0d29762e15c0f86cee9fbcbf3e0a54b5"}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void term_handle_command(char *cmdline)\n\n{\n\n    char *p, *pstart;\n\n    int argc;\n\n    const char *args[MAX_ARGS + 1];\n\n    term_cmd_t *cmd;\n\n\n\n#ifdef DEBUG\n\n    term_printf(\"command='%s'\\n\", cmdline);\n\n#endif\n\n    \n\n    /* split command in words */\n\n    argc = 0;\n\n    p = cmdline;\n\n    for(;;) {\n\n        while (isspace(*p))\n\n            p++;\n\n        if (*p == '\\0')\n\n            break;\n\n        pstart = p;\n\n        while (*p != '\\0' && !isspace(*p))\n\n            p++;\n\n        args[argc] = pstart;\n\n        argc++;\n\n        if (argc >= MAX_ARGS)\n\n            break;\n\n        if (*p == '\\0')\n\n            break;\n\n        *p++ = '\\0';\n\n    }\n\n    args[argc] = NULL;\n\n#ifdef DEBUG\n\n    for(i=0;i<argc;i++) {\n\n        term_printf(\" '%s'\", args[i]);\n\n    }\n\n    term_printf(\"\\n\");\n\n#endif\n\n    if (argc <= 0)\n\n        return;\n\n    for(cmd = term_cmds; cmd->name != NULL; cmd++) {\n\n        if (compare_cmd(args[0], cmd->name)) \n\n            goto found;\n\n    }\n\n    term_printf(\"unknown command: '%s'\\n\", args[0]);\n\n    return;\n\n found:\n\n    cmd->handler(argc, args);\n\n}\n", "idx": 4960, "_split": "valid", "_hash": "93b5e642975357fad7defb9fc2a8cb08"}
{"project": "qemu", "commit_id": "a32354e206895400d17c3de9a8df1de96d3df289", "target": 1, "func": "static void m5206_mbar_writew(void *opaque, target_phys_addr_t offset,\n\n                              uint32_t value)\n\n{\n\n    m5206_mbar_state *s = (m5206_mbar_state *)opaque;\n\n    int width;\n\n    offset &= 0x3ff;\n\n    if (offset > 0x200) {\n\n        hw_error(\"Bad MBAR write offset 0x%x\", (int)offset);\n\n    }\n\n    width = m5206_mbar_width[offset >> 2];\n\n    if (width > 2) {\n\n        uint32_t tmp;\n\n        tmp = m5206_mbar_readl(opaque, offset & ~3);\n\n        if (offset & 3) {\n\n            tmp = (tmp & 0xffff0000) | value;\n\n        } else {\n\n            tmp = (tmp & 0x0000ffff) | (value << 16);\n\n        }\n\n        m5206_mbar_writel(opaque, offset & ~3, tmp);\n\n        return;\n\n    } else if (width < 2) {\n\n        m5206_mbar_writeb(opaque, offset, value >> 8);\n\n        m5206_mbar_writeb(opaque, offset + 1, value & 0xff);\n\n        return;\n\n    }\n\n    m5206_mbar_write(s, offset, value, 2);\n\n}\n", "idx": 4971, "_split": "valid", "_hash": "2429556788c46bcb9ab2ac7ea683995c"}
{"project": "qemu", "commit_id": "3a55fc0f243104998bee5106b121cff257df5d33", "target": 1, "func": "static void test_ivshmem_server(bool msi)\n\n{\n\n    IVState state1, state2, *s1, *s2;\n\n    ServerThread thread;\n\n    IvshmemServer server;\n\n    int ret, vm1, vm2;\n\n    int nvectors = 2;\n\n    guint64 end_time = g_get_monotonic_time() + 5 * G_TIME_SPAN_SECOND;\n\n\n\n    ret = ivshmem_server_init(&server, tmpserver, tmpshm, true,\n\n                              TMPSHMSIZE, nvectors,\n\n                              g_test_verbose());\n\n    g_assert_cmpint(ret, ==, 0);\n\n\n\n    ret = ivshmem_server_start(&server);\n\n    g_assert_cmpint(ret, ==, 0);\n\n\n\n    setup_vm_with_server(&state1, nvectors, msi);\n\n    s1 = &state1;\n\n    setup_vm_with_server(&state2, nvectors, msi);\n\n    s2 = &state2;\n\n\n\n    /* check state before server sends stuff */\n\n    g_assert_cmpuint(in_reg(s1, IVPOSITION), ==, 0xffffffff);\n\n    g_assert_cmpuint(in_reg(s2, IVPOSITION), ==, 0xffffffff);\n\n    g_assert_cmpuint(qtest_readb(s1->qtest, (uintptr_t)s1->mem_base), ==, 0x00);\n\n\n\n    thread.server = &server;\n\n    ret = pipe(thread.pipe);\n\n    g_assert_cmpint(ret, ==, 0);\n\n    thread.thread = g_thread_new(\"ivshmem-server\", server_thread, &thread);\n\n    g_assert(thread.thread != NULL);\n\n\n\n    /* waiting for devices to become operational */\n\n    while (g_get_monotonic_time() < end_time) {\n\n        g_usleep(1000);\n\n        if ((int)in_reg(s1, IVPOSITION) >= 0 &&\n\n            (int)in_reg(s2, IVPOSITION) >= 0) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* check got different VM ids */\n\n    vm1 = in_reg(s1, IVPOSITION);\n\n    vm2 = in_reg(s2, IVPOSITION);\n\n    g_assert_cmpuint(vm1, !=, vm2);\n\n\n\n    /* check number of MSI-X vectors */\n\n    global_qtest = s1->qtest;\n\n    if (msi) {\n\n        ret = qpci_msix_table_size(s1->dev);\n\n        g_assert_cmpuint(ret, ==, nvectors);\n\n    }\n\n\n\n    /* TODO test behavior before MSI-X is enabled */\n\n\n\n    /* ping vm2 -> vm1 on vector 0 */\n\n    if (msi) {\n\n        ret = qpci_msix_pending(s1->dev, 0);\n\n        g_assert_cmpuint(ret, ==, 0);\n\n    } else {\n\n        g_assert_cmpuint(in_reg(s1, INTRSTATUS), ==, 0);\n\n    }\n\n    out_reg(s2, DOORBELL, vm1 << 16);\n\n    do {\n\n        g_usleep(10000);\n\n        ret = msi ? qpci_msix_pending(s1->dev, 0) : in_reg(s1, INTRSTATUS);\n\n    } while (ret == 0 && g_get_monotonic_time() < end_time);\n\n    g_assert_cmpuint(ret, !=, 0);\n\n\n\n    /* ping vm1 -> vm2 on vector 1 */\n\n    global_qtest = s2->qtest;\n\n    if (msi) {\n\n        ret = qpci_msix_pending(s2->dev, 1);\n\n        g_assert_cmpuint(ret, ==, 0);\n\n    } else {\n\n        g_assert_cmpuint(in_reg(s2, INTRSTATUS), ==, 0);\n\n    }\n\n    out_reg(s1, DOORBELL, vm2 << 16 | 1);\n\n    do {\n\n        g_usleep(10000);\n\n        ret = msi ? qpci_msix_pending(s2->dev, 1) : in_reg(s2, INTRSTATUS);\n\n    } while (ret == 0 && g_get_monotonic_time() < end_time);\n\n    g_assert_cmpuint(ret, !=, 0);\n\n\n\n    cleanup_vm(s2);\n\n    cleanup_vm(s1);\n\n\n\n    if (qemu_write_full(thread.pipe[1], \"q\", 1) != 1) {\n\n        g_error(\"qemu_write_full: %s\", g_strerror(errno));\n\n    }\n\n\n\n    g_thread_join(thread.thread);\n\n\n\n    ivshmem_server_close(&server);\n\n    close(thread.pipe[1]);\n\n    close(thread.pipe[0]);\n\n}\n", "idx": 4973, "_split": "valid", "_hash": "272754c08fda9f335e37a2fddc8e8654"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "int qemu_peek_byte(QEMUFile *f, int offset)\n\n{\n\n    int index = f->buf_index + offset;\n\n\n\n    assert(!qemu_file_is_writable(f));\n\n    assert(offset < IO_BUF_SIZE);\n\n\n\n    if (index >= f->buf_size) {\n\n        qemu_fill_buffer(f);\n\n        index = f->buf_index + offset;\n\n        if (index >= f->buf_size) {\n\n            return 0;\n\n        }\n\n    }\n\n    return f->buf[index];\n\n}\n", "idx": 4976, "_split": "valid", "_hash": "7361b6900ddba3add8a4a0dcd96d8939"}
{"project": "qemu", "commit_id": "c20b7fa4b2fedd979bcb0cc974bb5d08a10e3448", "target": 1, "func": "monitor_protocol_event_queue(MonitorEvent event,\n\n                             QObject *data)\n\n{\n\n    MonitorEventState *evstate;\n\n    int64_t now = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n    assert(event < QEVENT_MAX);\n\n\n\n    qemu_mutex_lock(&monitor_event_state_lock);\n\n    evstate = &(monitor_event_state[event]);\n\n    trace_monitor_protocol_event_queue(event,\n\n                                       data,\n\n                                       evstate->rate,\n\n                                       evstate->last,\n\n                                       now);\n\n\n\n    /* Rate limit of 0 indicates no throttling */\n\n    if (!evstate->rate) {\n\n        monitor_protocol_event_emit(event, data);\n\n        evstate->last = now;\n\n    } else {\n\n        int64_t delta = now - evstate->last;\n\n        if (evstate->data ||\n\n            delta < evstate->rate) {\n\n            /* If there's an existing event pending, replace\n\n             * it with the new event, otherwise schedule a\n\n             * timer for delayed emission\n\n             */\n\n            if (evstate->data) {\n\n                qobject_decref(evstate->data);\n\n            } else {\n\n                int64_t then = evstate->last + evstate->rate;\n\n                timer_mod_ns(evstate->timer, then);\n\n            }\n\n            evstate->data = data;\n\n            qobject_incref(evstate->data);\n\n        } else {\n\n            monitor_protocol_event_emit(event, data);\n\n            evstate->last = now;\n\n        }\n\n    }\n\n    qemu_mutex_unlock(&monitor_event_state_lock);\n\n}\n", "idx": 4992, "_split": "valid", "_hash": "8026e1317354ef06dd933be818050a4b"}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "static int qemu_gluster_create(const char *filename,\n\n                               QemuOpts *opts, Error **errp)\n\n{\n\n    struct glfs *glfs;\n\n    struct glfs_fd *fd;\n\n    int ret = 0;\n\n    int prealloc = 0;\n\n    int64_t total_size = 0;\n\n    char *tmp = NULL;\n\n    GlusterConf *gconf = g_malloc0(sizeof(GlusterConf));\n\n\n\n    glfs = qemu_gluster_init(gconf, filename, errp);\n\n    if (!glfs) {\n\n        ret = -errno;\n\n        goto out;\n\n    }\n\n\n\n    total_size =\n\n        qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0) / BDRV_SECTOR_SIZE;\n\n\n\n    tmp = qemu_opt_get_del(opts, BLOCK_OPT_PREALLOC);\n\n    if (!tmp || !strcmp(tmp, \"off\")) {\n\n        prealloc = 0;\n\n    } else if (!strcmp(tmp, \"full\") &&\n\n               gluster_supports_zerofill()) {\n\n        prealloc = 1;\n\n    } else {\n\n        error_setg(errp, \"Invalid preallocation mode: '%s'\"\n\n            \" or GlusterFS doesn't support zerofill API\",\n\n            tmp);\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    fd = glfs_creat(glfs, gconf->image,\n\n        O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, S_IRUSR | S_IWUSR);\n\n    if (!fd) {\n\n        ret = -errno;\n\n    } else {\n\n        if (!glfs_ftruncate(fd, total_size * BDRV_SECTOR_SIZE)) {\n\n            if (prealloc && qemu_gluster_zerofill(fd, 0,\n\n                    total_size * BDRV_SECTOR_SIZE)) {\n\n                ret = -errno;\n\n            }\n\n        } else {\n\n            ret = -errno;\n\n        }\n\n\n\n        if (glfs_close(fd) != 0) {\n\n            ret = -errno;\n\n        }\n\n    }\n\nout:\n\n    g_free(tmp);\n\n    qemu_gluster_gconf_free(gconf);\n\n    if (glfs) {\n\n        glfs_fini(glfs);\n\n    }\n\n    return ret;\n\n}\n", "idx": 4996, "_split": "valid", "_hash": "e3b8dcae5b7f13d4d6d277d58c7d6527"}
{"project": "qemu", "commit_id": "cd245a19329edfcd968b00d05ad92de7a0e2daa1", "target": 1, "func": "void *qemu_memalign(size_t alignment, size_t size)\n\n{\n\n    if (!size) {\n\n        abort();\n\n    }\n\n    return oom_check(VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE));\n\n}\n", "idx": 5002, "_split": "valid", "_hash": "804bb7988912f481a07d8fbd0c6fda14"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void slow_bar_writel(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    AssignedDevRegion *d = opaque;\n\n    uint32_t *out = (uint32_t *)(d->u.r_virtbase + addr);\n\n\n\n    DEBUG(\"slow_bar_writel addr=0x\" TARGET_FMT_plx \" val=0x%08x\\n\", addr, val);\n\n    *out = val;\n\n}\n", "idx": 5008, "_split": "valid", "_hash": "b4f068bc63cdd90518d758843208cfb2"}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "SCSIDevice *scsi_bus_legacy_add_drive(SCSIBus *bus, DriveInfo *dinfo, int unit)\n\n{\n\n    const char *driver;\n\n    DeviceState *dev;\n\n\n\n    driver = bdrv_is_sg(dinfo->bdrv) ? \"scsi-generic\" : \"scsi-disk\";\n\n    dev = qdev_create(&bus->qbus, driver);\n\n    qdev_prop_set_uint32(dev, \"scsi-id\", unit);\n\n    qdev_prop_set_drive(dev, \"drive\", dinfo);\n\n    if (qdev_init(dev) < 0)\n\n        return NULL;\n\n    return DO_UPCAST(SCSIDevice, qdev, dev);\n\n}\n", "idx": 5020, "_split": "valid", "_hash": "59591bacfef392663b86507296a4539b"}
{"project": "qemu", "commit_id": "b2dfd71c4843a762f2befe702adb249cf55baf66", "target": 0, "func": "static void xen_log_stop(MemoryListener *listener, MemoryRegionSection *section)\n\n{\n\n    XenIOState *state = container_of(listener, XenIOState, memory_listener);\n\n\n\n    state->log_for_dirtybit = NULL;\n\n    /* Disable dirty bit tracking */\n\n    xc_hvm_track_dirty_vram(xen_xc, xen_domid, 0, 0, NULL);\n\n}\n", "idx": 5027, "_split": "valid", "_hash": "f045db2680856d9b6a90fda04f50664e"}
{"project": "qemu", "commit_id": "ede9c94acf6cd1968de4188c0228b714ab871a86", "target": 0, "func": "static int vtd_int_remap(X86IOMMUState *iommu, MSIMessage *src,\n\n                         MSIMessage *dst, uint16_t sid)\n\n{\n\n    return vtd_interrupt_remap_msi(INTEL_IOMMU_DEVICE(iommu), src, dst);\n\n}\n", "idx": 5036, "_split": "valid", "_hash": "5440e34ad307e5a542733a1a25e22feb"}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "static void core_region_nop(MemoryListener *listener,\n\n                            MemoryRegionSection *section)\n\n{\n\n    cpu_register_physical_memory_log(section, section->readonly);\n\n}\n", "idx": 5041, "_split": "valid", "_hash": "19daa0b8751a1c4d60c6ef6e8d5bfcec"}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "float32 uint64_to_float32( uint64 a STATUS_PARAM )\n\n{\n\n    int8 shiftCount;\n\n\n\n    if ( a == 0 ) return 0;\n\n    shiftCount = countLeadingZeros64( a ) - 40;\n\n    if ( 0 <= shiftCount ) {\n\n        return packFloat32( 1 > 0, 0x95 - shiftCount, a<<shiftCount );\n\n    }\n\n    else {\n\n        shiftCount += 7;\n\n        if ( shiftCount < 0 ) {\n\n            shift64RightJamming( a, - shiftCount, &a );\n\n        }\n\n        else {\n\n            a <<= shiftCount;\n\n        }\n\n        return roundAndPackFloat32( 1 > 0, 0x9C - shiftCount, a STATUS_VAR );\n\n    }\n\n}\n", "idx": 5048, "_split": "valid", "_hash": "87fce28ff9bf17e387a0dea354da8cec"}
{"project": "qemu", "commit_id": "bb5fc20f7c1c65e95030da3629dd0d7a0cce38cd", "target": 0, "func": "static void do_change_vnc(const char *target, const char *arg)\n\n{\n\n    if (strcmp(target, \"passwd\") == 0 ||\n\n\tstrcmp(target, \"password\") == 0) {\n\n\tchar password[9];\n\n\tif (arg) {\n\n\t    strncpy(password, arg, sizeof(password));\n\n\t    password[sizeof(password) - 1] = '\\0';\n\n\t} else\n\n\t    monitor_readline(\"Password: \", 1, password, sizeof(password));\n\n\tif (vnc_display_password(NULL, password) < 0)\n\n\t    term_printf(\"could not set VNC server password\\n\");\n\n    } else {\n\n\tif (vnc_display_open(NULL, target) < 0)\n\n\t    term_printf(\"could not start VNC server on %s\\n\", target);\n\n    }\n\n}\n", "idx": 5051, "_split": "valid", "_hash": "86763b088a25a81365269c0233a1ca9a"}
{"project": "qemu", "commit_id": "24d3bd67aca958c8ea103646d9d326de00056e4d", "target": 0, "func": "static struct scsi_task *iscsi_do_inquiry(struct iscsi_context *iscsi, int lun,\n\n                                          int evpd, int pc, Error **errp)\n\n{\n\n    int full_size;\n\n    struct scsi_task *task = NULL;\n\n    task = iscsi_inquiry_sync(iscsi, lun, evpd, pc, 64);\n\n    if (task == NULL || task->status != SCSI_STATUS_GOOD) {\n\n        goto fail;\n\n    }\n\n    full_size = scsi_datain_getfullsize(task);\n\n    if (full_size > task->datain.size) {\n\n        scsi_free_scsi_task(task);\n\n\n\n        /* we need more data for the full list */\n\n        task = iscsi_inquiry_sync(iscsi, lun, evpd, pc, full_size);\n\n        if (task == NULL || task->status != SCSI_STATUS_GOOD) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    return task;\n\n\n\nfail:\n\n    error_setg(errp, \"iSCSI: Inquiry command failed : %s\",\n\n               iscsi_get_error(iscsi));\n\n    if (task) {\n\n        scsi_free_scsi_task(task);\n\n        return NULL;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 5052, "_split": "valid", "_hash": "f8905dd2fa884d7ac79dc86451861891"}
{"project": "qemu", "commit_id": "1c0fbfa3dedf49115e194e533a7b6a640a28447c", "target": 1, "func": "static void virtio_net_add_queue(VirtIONet *n, int index)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n\n\n    n->vqs[index].rx_vq = virtio_add_queue(vdev, 256, virtio_net_handle_rx);\n\n    if (n->net_conf.tx && !strcmp(n->net_conf.tx, \"timer\")) {\n\n        n->vqs[index].tx_vq =\n\n            virtio_add_queue(vdev, 256, virtio_net_handle_tx_timer);\n\n        n->vqs[index].tx_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n\n                                              virtio_net_tx_timer,\n\n                                              &n->vqs[index]);\n\n    } else {\n\n        n->vqs[index].tx_vq =\n\n            virtio_add_queue(vdev, 256, virtio_net_handle_tx_bh);\n\n        n->vqs[index].tx_bh = qemu_bh_new(virtio_net_tx_bh, &n->vqs[index]);\n\n    }\n\n\n\n    n->vqs[index].tx_waiting = 0;\n\n    n->vqs[index].n = n;\n\n}\n", "idx": 5072, "_split": "valid", "_hash": "fbeeac38202463dff4d0d37c4dc2b85e"}
{"project": "qemu", "commit_id": "a614f52dc70fd4c424a6248ae98c42494b9a89e7", "target": 0, "func": "static int grackle_pci_host_init(PCIDevice *d)\n\n{\n\n    pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_MOTOROLA);\n\n    pci_config_set_device_id(d->config, PCI_DEVICE_ID_MOTOROLA_MPC106);\n\n    d->config[0x08] = 0x00; // revision\n\n    d->config[0x09] = 0x01;\n\n    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_HOST);\n\n    return 0;\n\n}\n", "idx": 5081, "_split": "valid", "_hash": "cccbf6cf297ab1bdbd30439626aca8a1"}
{"project": "qemu", "commit_id": "100f738850639a108d6767316ce4dcc1d1ea4ae4", "target": 0, "func": "static void icp_realize(DeviceState *dev, Error **errp)\n\n{\n\n    ICPState *icp = ICP(dev);\n\n    ICPStateClass *icpc = ICP_GET_CLASS(dev);\n\n    Object *obj;\n\n    Error *err = NULL;\n\n\n\n    obj = object_property_get_link(OBJECT(dev), ICP_PROP_XICS, &err);\n\n    if (!obj) {\n\n        error_setg(errp, \"%s: required link '\" ICP_PROP_XICS \"' not found: %s\",\n\n                   __func__, error_get_pretty(err));\n\n        return;\n\n    }\n\n\n\n    icp->xics = XICS_FABRIC(obj);\n\n\n\n    if (icpc->realize) {\n\n        icpc->realize(dev, errp);\n\n    }\n\n\n\n    qemu_register_reset(icp_reset, dev);\n\n}\n", "idx": 5085, "_split": "valid", "_hash": "97ed33408993244262750c012c560471"}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_in_native_list_int(TestInputVisitorData *data,\n\n                                            const void *unused)\n\n{\n\n    test_native_list_integer_helper(data, unused,\n\n                                    USER_DEF_NATIVE_LIST_UNION_KIND_INTEGER);\n\n}\n", "idx": 5087, "_split": "valid", "_hash": "8ba027e00623cfe64e3c88f63c69df9c"}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoull_max(void)\n\n{\n\n    char *str = g_strdup_printf(\"%llu\", ULLONG_MAX);\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, ULLONG_MAX);\n\n    g_assert(endptr == str + strlen(str));\n\n    g_free(str);\n\n}\n", "idx": 5091, "_split": "valid", "_hash": "b346c5c3b94f4a1da48d197876319fc3"}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static inline void* array_get_next(array_t* array) {\n\n    unsigned int next = array->next;\n\n    void* result;\n\n\n\n    if (array_ensure_allocated(array, next) < 0)\n\n\treturn NULL;\n\n\n\n    array->next = next + 1;\n\n    result = array_get(array, next);\n\n\n\n    return result;\n\n}\n", "idx": 5098, "_split": "valid", "_hash": "367bc81fa3e59b983a554236caeaebf0"}
{"project": "qemu", "commit_id": "d8b7e0adf562277180f96ecbd7f1777a384a0308", "target": 0, "func": "static int raw_read(BlockDriverState *bs, int64_t sector_num,\n\n                    uint8_t *buf, int nb_sectors)\n\n{\n\n    return bdrv_read(bs->file, sector_num, buf, nb_sectors);\n\n}\n", "idx": 5101, "_split": "valid", "_hash": "9594f7158461ae440d0dcc62c742ad04"}
{"project": "qemu", "commit_id": "e1556ad5b8143a15c26067c3862fe20631c0053f", "target": 1, "func": "static uint32_t omap2_gpio_module_readp(void *opaque, target_phys_addr_t addr)\n\n{\n\n    return omap2_gpio_module_readp(opaque, addr) >> ((addr & 3) << 3);\n\n}\n", "idx": 5116, "_split": "valid", "_hash": "5f31aedd6504755d8061feabbf440ca9"}
{"project": "qemu", "commit_id": "6f6867493cc00974de594a509cee5a3be61c64aa", "target": 1, "func": "static void guest_fsfreeze_cleanup(void)\n\n{\n\n    int64_t ret;\n\n    Error *err = NULL;\n\n\n\n    if (ga_is_frozen(ga_state) == GUEST_FSFREEZE_STATUS_FROZEN) {\n\n        ret = qmp_guest_fsfreeze_thaw(&err);\n\n        if (ret < 0 || err) {\n\n            slog(\"failed to clean up frozen filesystems\");\n\n        }\n\n    }\n\n}\n", "idx": 5122, "_split": "valid", "_hash": "ed7e546169c66becb77794341aea36f1"}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "petalogix_s3adsp1800_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    DeviceState *dev;\n\n    MicroBlazeCPU *cpu;\n\n    DriveInfo *dinfo;\n\n    int i;\n\n    hwaddr ddr_base = MEMORY_BASEADDR;\n\n    MemoryRegion *phys_lmb_bram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n\n    qemu_irq irq[32];\n\n    MemoryRegion *sysmem = get_system_memory();\n\n\n\n    cpu = MICROBLAZE_CPU(object_new(TYPE_MICROBLAZE_CPU));\n\n    object_property_set_bool(OBJECT(cpu), true, \"realized\", &error_abort);\n\n\n\n    /* Attach emulated BRAM through the LMB.  */\n\n    memory_region_init_ram(phys_lmb_bram, NULL,\n\n                           \"petalogix_s3adsp1800.lmb_bram\", LMB_BRAM_SIZE,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(phys_lmb_bram);\n\n    memory_region_add_subregion(sysmem, 0x00000000, phys_lmb_bram);\n\n\n\n    memory_region_init_ram(phys_ram, NULL, \"petalogix_s3adsp1800.ram\",\n\n                           ram_size, &error_abort);\n\n    vmstate_register_ram_global(phys_ram);\n\n    memory_region_add_subregion(sysmem, ddr_base, phys_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    pflash_cfi01_register(FLASH_BASEADDR,\n\n                          NULL, \"petalogix_s3adsp1800.flash\", FLASH_SIZE,\n\n                          dinfo ? blk_by_legacy_dinfo(dinfo) : NULL,\n\n                          (64 * 1024), FLASH_SIZE >> 16,\n\n                          1, 0x89, 0x18, 0x0000, 0x0, 1);\n\n\n\n    dev = qdev_create(NULL, \"xlnx.xps-intc\");\n\n    qdev_prop_set_uint32(dev, \"kind-of-intr\",\n\n                         1 << ETHLITE_IRQ | 1 << UARTLITE_IRQ);\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, INTC_BASEADDR);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0,\n\n                       qdev_get_gpio_in(DEVICE(cpu), MB_CPU_IRQ));\n\n    for (i = 0; i < 32; i++) {\n\n        irq[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n\n\n    sysbus_create_simple(\"xlnx.xps-uartlite\", UARTLITE_BASEADDR,\n\n                         irq[UARTLITE_IRQ]);\n\n\n\n    /* 2 timers at irq 2 @ 62 Mhz.  */\n\n    dev = qdev_create(NULL, \"xlnx.xps-timer\");\n\n    qdev_prop_set_uint32(dev, \"one-timer-only\", 0);\n\n    qdev_prop_set_uint32(dev, \"clock-frequency\", 62 * 1000000);\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, TIMER_BASEADDR);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, irq[TIMER_IRQ]);\n\n\n\n    qemu_check_nic_model(&nd_table[0], \"xlnx.xps-ethernetlite\");\n\n    dev = qdev_create(NULL, \"xlnx.xps-ethernetlite\");\n\n    qdev_set_nic_properties(dev, &nd_table[0]);\n\n    qdev_prop_set_uint32(dev, \"tx-ping-pong\", 0);\n\n    qdev_prop_set_uint32(dev, \"rx-ping-pong\", 0);\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, ETHLITE_BASEADDR);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, irq[ETHLITE_IRQ]);\n\n\n\n    microblaze_load_kernel(cpu, ddr_base, ram_size,\n\n                           machine->initrd_filename,\n\n                           BINARY_DEVICE_TREE_FILE,\n\n                           NULL);\n\n}\n", "idx": 5156, "_split": "valid", "_hash": "686741ddeee91c49e418abfbf9ee1218"}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "static ssize_t flush_buf(VirtIOSerialPort *port,\n                         const uint8_t *buf, ssize_t len)\n{\n    VirtConsole *vcon = VIRTIO_CONSOLE(port);\n    ssize_t ret;\n    if (!vcon->chr) {\n        /* If there's no backend, we can just say we consumed all data. */\n        return len;\n    }\n    ret = qemu_chr_fe_write(vcon->chr, buf, len);\n    trace_virtio_console_flush_buf(port->id, len, ret);\n    if (ret < len) {\n        VirtIOSerialPortClass *k = VIRTIO_SERIAL_PORT_GET_CLASS(port);\n        /*\n         * Ideally we'd get a better error code than just -1, but\n         * that's what the chardev interface gives us right now.  If\n         * we had a finer-grained message, like -EPIPE, we could close\n         * this connection.\n        if (ret < 0)\n            ret = 0;\n        if (!k->is_console) {\n            virtio_serial_throttle_port(port, true);\n            if (!vcon->watch) {\n                vcon->watch = qemu_chr_fe_add_watch(vcon->chr,\n                                                    G_IO_OUT|G_IO_HUP,\n                                                    chr_write_unblocked, vcon);\n            }\n        }\n    }\n    return ret;\n}", "idx": 5157, "_split": "valid", "_hash": "9ae486e545c2be6cda00f61a03be623c"}
{"project": "qemu", "commit_id": "e53f27b9d9df73461308618151fa6e6392aebd85", "target": 1, "func": "static void tcp_chr_read(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    TCPCharDriver *s = chr->opaque;\n\n    uint8_t buf[READ_BUF_LEN];\n\n    int len, size;\n\n\n\n    if (!s->connected || s->max_size <= 0)\n\n        return;\n\n    len = sizeof(buf);\n\n    if (len > s->max_size)\n\n        len = s->max_size;\n\n    size = tcp_chr_recv(chr, (void *)buf, len);\n\n    if (size == 0) {\n\n        /* connection closed */\n\n        s->connected = 0;\n\n        if (s->listen_fd >= 0) {\n\n            qemu_set_fd_handler(s->listen_fd, tcp_chr_accept, NULL, chr);\n\n        }\n\n        qemu_set_fd_handler(s->fd, NULL, NULL, NULL);\n\n        closesocket(s->fd);\n\n        s->fd = -1;\n\n        qemu_chr_event(chr, CHR_EVENT_CLOSED);\n\n    } else if (size > 0) {\n\n        if (s->do_telnetopt)\n\n            tcp_chr_process_IAC_bytes(chr, s, buf, &size);\n\n        if (size > 0)\n\n            qemu_chr_read(chr, buf, size);\n\n        if (s->msgfd != -1) {\n\n            close(s->msgfd);\n\n            s->msgfd = -1;\n\n        }\n\n    }\n\n}\n", "idx": 5158, "_split": "valid", "_hash": "4e03729523410c2d12879df46c46a407"}
{"project": "qemu", "commit_id": "c9262e8a84a29f22fbb5edde5d17f4f6166d5ae1", "target": 1, "func": "void virtio_panic(const char *string)\n\n{\n\n    sclp_print(string);\n\n    disabled_wait();\n\n    while (1) { }\n\n}\n", "idx": 5177, "_split": "valid", "_hash": "c3eb771d904c84f60c702926322d8a19"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "bool migrate_zero_blocks(void)\n\n{\n\n    MigrationState *s;\n\n\n\n    s = migrate_get_current();\n\n\n\n    return s->enabled_capabilities[MIGRATION_CAPABILITY_ZERO_BLOCKS];\n\n}\n", "idx": 5180, "_split": "valid", "_hash": "99f50fa06fb8e715bd8702ff3911a282"}
{"project": "qemu", "commit_id": "574ef17191f5ec5a3cc4782c1f59dc5eb8279654", "target": 0, "func": "static int ehci_state_executing(EHCIQueue *q)\n\n{\n\n    EHCIPacket *p = QTAILQ_FIRST(&q->packets);\n\n    int again = 0;\n\n\n\n    assert(p != NULL);\n\n    assert(p->qtdaddr == q->qtdaddr);\n\n\n\n    ehci_execute_complete(q);\n\n    if (p->usb_status == USB_RET_ASYNC) {\n\n        goto out;\n\n    }\n\n    if (p->usb_status == USB_RET_PROCERR) {\n\n        again = -1;\n\n        goto out;\n\n    }\n\n\n\n    // 4.10.3\n\n    if (!q->async) {\n\n        int transactCtr = get_field(q->qh.epcap, QH_EPCAP_MULT);\n\n        transactCtr--;\n\n        set_field(&q->qh.epcap, transactCtr, QH_EPCAP_MULT);\n\n        // 4.10.3, bottom of page 82, should exit this state when transaction\n\n        // counter decrements to 0\n\n    }\n\n\n\n    /* 4.10.5 */\n\n    if (p->usb_status == USB_RET_NAK) {\n\n        ehci_set_state(q->ehci, q->async, EST_HORIZONTALQH);\n\n    } else {\n\n        ehci_set_state(q->ehci, q->async, EST_WRITEBACK);\n\n    }\n\n\n\n    again = 1;\n\n\n\nout:\n\n    ehci_flush_qh(q);\n\n    return again;\n\n}\n", "idx": 5197, "_split": "valid", "_hash": "6f3bbd64eb39d9d29bf59ea9a0057375"}
{"project": "qemu", "commit_id": "c6e484707f28b3e115e64122a0570f6b3c585489", "target": 0, "func": "static void qemu_spice_create_update(SimpleSpiceDisplay *ssd)\n\n{\n\n    static const int blksize = 32;\n\n    int blocks = (surface_width(ssd->ds) + blksize - 1) / blksize;\n\n    int dirty_top[blocks];\n\n    int y, yoff, x, xoff, blk, bw;\n\n    int bpp = surface_bytes_per_pixel(ssd->ds);\n\n    uint8_t *guest, *mirror;\n\n\n\n    if (qemu_spice_rect_is_empty(&ssd->dirty)) {\n\n        return;\n\n    };\n\n\n\n    for (blk = 0; blk < blocks; blk++) {\n\n        dirty_top[blk] = -1;\n\n    }\n\n\n\n    guest = surface_data(ssd->ds);\n\n    mirror = (void *)pixman_image_get_data(ssd->mirror);\n\n    for (y = ssd->dirty.top; y < ssd->dirty.bottom; y++) {\n\n        yoff = y * surface_stride(ssd->ds);\n\n        for (x = ssd->dirty.left; x < ssd->dirty.right; x += blksize) {\n\n            xoff = x * bpp;\n\n            blk = x / blksize;\n\n            bw = MIN(blksize, ssd->dirty.right - x);\n\n            if (memcmp(guest + yoff + xoff,\n\n                       mirror + yoff + xoff,\n\n                       bw * bpp) == 0) {\n\n                if (dirty_top[blk] != -1) {\n\n                    QXLRect update = {\n\n                        .top    = dirty_top[blk],\n\n                        .bottom = y,\n\n                        .left   = x,\n\n                        .right  = x + bw,\n\n                    };\n\n                    qemu_spice_create_one_update(ssd, &update);\n\n                    dirty_top[blk] = -1;\n\n                }\n\n            } else {\n\n                if (dirty_top[blk] == -1) {\n\n                    dirty_top[blk] = y;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    for (x = ssd->dirty.left; x < ssd->dirty.right; x += blksize) {\n\n        blk = x / blksize;\n\n        bw = MIN(blksize, ssd->dirty.right - x);\n\n        if (dirty_top[blk] != -1) {\n\n            QXLRect update = {\n\n                .top    = dirty_top[blk],\n\n                .bottom = ssd->dirty.bottom,\n\n                .left   = x,\n\n                .right  = x + bw,\n\n            };\n\n            qemu_spice_create_one_update(ssd, &update);\n\n            dirty_top[blk] = -1;\n\n        }\n\n    }\n\n\n\n    memset(&ssd->dirty, 0, sizeof(ssd->dirty));\n\n}\n", "idx": 5230, "_split": "valid", "_hash": "8c6df93e62478bb32e47962d1ff44aee"}
{"project": "qemu", "commit_id": "5379229a2708df3a1506113315214c3ce5325859", "target": 0, "func": "void tcp_connect(struct socket *inso)\n\n{\n\n    Slirp *slirp = inso->slirp;\n\n    struct socket *so;\n\n    struct sockaddr_in addr;\n\n    socklen_t addrlen = sizeof(struct sockaddr_in);\n\n    struct tcpcb *tp;\n\n    int s, opt;\n\n\n\n    DEBUG_CALL(\"tcp_connect\");\n\n    DEBUG_ARG(\"inso = %p\", inso);\n\n\n\n    /*\n\n     * If it's an SS_ACCEPTONCE socket, no need to socreate()\n\n     * another socket, just use the accept() socket.\n\n     */\n\n    if (inso->so_state & SS_FACCEPTONCE) {\n\n        /* FACCEPTONCE already have a tcpcb */\n\n        so = inso;\n\n    } else {\n\n        so = socreate(slirp);\n\n        if (so == NULL) {\n\n            /* If it failed, get rid of the pending connection */\n\n            closesocket(accept(inso->s, (struct sockaddr *)&addr, &addrlen));\n\n            return;\n\n        }\n\n        if (tcp_attach(so) < 0) {\n\n            free(so); /* NOT sofree */\n\n            return;\n\n        }\n\n        so->so_lfamily = AF_INET;\n\n        so->so_laddr = inso->so_laddr;\n\n        so->so_lport = inso->so_lport;\n\n    }\n\n\n\n    tcp_mss(sototcpcb(so), 0);\n\n\n\n    s = accept(inso->s, (struct sockaddr *)&addr, &addrlen);\n\n    if (s < 0) {\n\n        tcp_close(sototcpcb(so)); /* This will sofree() as well */\n\n        return;\n\n    }\n\n    qemu_set_nonblock(s);\n\n    socket_set_fast_reuse(s);\n\n    opt = 1;\n\n    qemu_setsockopt(s, SOL_SOCKET, SO_OOBINLINE, &opt, sizeof(int));\n\n    socket_set_nodelay(s);\n\n\n\n    so->so_ffamily = AF_INET;\n\n    so->so_fport = addr.sin_port;\n\n    so->so_faddr = addr.sin_addr;\n\n    /* Translate connections from localhost to the real hostname */\n\n    if (so->so_faddr.s_addr == 0 ||\n\n        (so->so_faddr.s_addr & loopback_mask) ==\n\n        (loopback_addr.s_addr & loopback_mask)) {\n\n        so->so_faddr = slirp->vhost_addr;\n\n    }\n\n\n\n    /* Close the accept() socket, set right state */\n\n    if (inso->so_state & SS_FACCEPTONCE) {\n\n        /* If we only accept once, close the accept() socket */\n\n        closesocket(so->s);\n\n\n\n        /* Don't select it yet, even though we have an FD */\n\n        /* if it's not FACCEPTONCE, it's already NOFDREF */\n\n        so->so_state = SS_NOFDREF;\n\n    }\n\n    so->s = s;\n\n    so->so_state |= SS_INCOMING;\n\n\n\n    so->so_iptos = tcp_tos(so);\n\n    tp = sototcpcb(so);\n\n\n\n    tcp_template(tp);\n\n\n\n    tp->t_state = TCPS_SYN_SENT;\n\n    tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;\n\n    tp->iss = slirp->tcp_iss;\n\n    slirp->tcp_iss += TCP_ISSINCR/2;\n\n    tcp_sendseqinit(tp);\n\n    tcp_output(tp);\n\n}\n", "idx": 5239, "_split": "valid", "_hash": "4f13b06b1582ddd7848f88e1c899264b"}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void check_exception(sPAPREnvironment *spapr,\n\n                            uint32_t token, uint32_t nargs,\n\n                            target_ulong args,\n\n                            uint32_t nret, target_ulong rets)\n\n{\n\n    uint32_t mask, buf, len;\n\n    uint64_t xinfo;\n\n\n\n    if ((nargs < 6) || (nargs > 7) || nret != 1) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n\n\n    xinfo = rtas_ld(args, 1);\n\n    mask = rtas_ld(args, 2);\n\n    buf = rtas_ld(args, 4);\n\n    len = rtas_ld(args, 5);\n\n    if (nargs == 7) {\n\n        xinfo |= (uint64_t)rtas_ld(args, 6) << 32;\n\n    }\n\n\n\n    if ((mask & EVENT_MASK_EPOW) && pending_epow) {\n\n        if (sizeof(*pending_epow) < len) {\n\n            len = sizeof(*pending_epow);\n\n        }\n\n\n\n        cpu_physical_memory_write(buf, pending_epow, len);\n\n        g_free(pending_epow);\n\n        pending_epow = NULL;\n\n        rtas_st(rets, 0, 0);\n\n    } else {\n\n        rtas_st(rets, 0, 1);\n\n    }\n\n}\n", "idx": 5252, "_split": "valid", "_hash": "5fdfe1f9f21a638cd36a7ebedff96af6"}
{"project": "qemu", "commit_id": "75b0713e189a981e5bfd087d5f35705446bbb12a", "target": 1, "func": "static void nvdimm_build_nfit(GSList *device_list, GArray *table_offsets,\n\n                              GArray *table_data, BIOSLinker *linker)\n\n{\n\n    GArray *structures = nvdimm_build_device_structure(device_list);\n\n    unsigned int header;\n\n\n\n    acpi_add_table(table_offsets, table_data);\n\n\n\n    /* NFIT header. */\n\n    header = table_data->len;\n\n    acpi_data_push(table_data, sizeof(NvdimmNfitHeader));\n\n    /* NVDIMM device structures. */\n\n    g_array_append_vals(table_data, structures->data, structures->len);\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)(table_data->data + header), \"NFIT\",\n\n                 sizeof(NvdimmNfitHeader) + structures->len, 1, NULL, NULL);\n\n    g_array_free(structures, true);\n\n}\n", "idx": 5255, "_split": "valid", "_hash": "85fadd0d3c9ad3c341dd5667ff459ba5"}
{"project": "qemu", "commit_id": "de82815db1c89da058b7fb941dab137d6d9ab738", "target": 1, "func": "static coroutine_fn int qcow2_co_writev(BlockDriverState *bs,\n\n                           int64_t sector_num,\n\n                           int remaining_sectors,\n\n                           QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    int ret;\n\n    int cur_nr_sectors; /* number of sectors in current iteration */\n\n    uint64_t cluster_offset;\n\n    QEMUIOVector hd_qiov;\n\n    uint64_t bytes_done = 0;\n\n    uint8_t *cluster_data = NULL;\n\n    QCowL2Meta *l2meta = NULL;\n\n\n\n    trace_qcow2_writev_start_req(qemu_coroutine_self(), sector_num,\n\n                                 remaining_sectors);\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    s->cluster_cache_offset = -1; /* disable compressed cache */\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (remaining_sectors != 0) {\n\n\n\n        l2meta = NULL;\n\n\n\n        trace_qcow2_writev_start_part(qemu_coroutine_self());\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        cur_nr_sectors = remaining_sectors;\n\n        if (s->crypt_method &&\n\n            cur_nr_sectors >\n\n            QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors - index_in_cluster) {\n\n            cur_nr_sectors =\n\n                QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors - index_in_cluster;\n\n        }\n\n\n\n        ret = qcow2_alloc_cluster_offset(bs, sector_num << 9,\n\n            &cur_nr_sectors, &cluster_offset, &l2meta);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        assert((cluster_offset & 511) == 0);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_concat(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (s->crypt_method) {\n\n            if (!cluster_data) {\n\n                cluster_data = qemu_blockalign(bs, QCOW_MAX_CRYPT_CLUSTERS *\n\n                                                 s->cluster_size);\n\n            }\n\n\n\n            assert(hd_qiov.size <=\n\n                   QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n            qemu_iovec_to_buf(&hd_qiov, 0, cluster_data, hd_qiov.size);\n\n\n\n            qcow2_encrypt_sectors(s, sector_num, cluster_data,\n\n                cluster_data, cur_nr_sectors, 1, &s->aes_encrypt_key);\n\n\n\n            qemu_iovec_reset(&hd_qiov);\n\n            qemu_iovec_add(&hd_qiov, cluster_data,\n\n                cur_nr_sectors * 512);\n\n        }\n\n\n\n        ret = qcow2_pre_write_overlap_check(bs, 0,\n\n                cluster_offset + index_in_cluster * BDRV_SECTOR_SIZE,\n\n                cur_nr_sectors * BDRV_SECTOR_SIZE);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n        trace_qcow2_writev_data(qemu_coroutine_self(),\n\n                                (cluster_offset >> 9) + index_in_cluster);\n\n        ret = bdrv_co_writev(bs->file,\n\n                             (cluster_offset >> 9) + index_in_cluster,\n\n                             cur_nr_sectors, &hd_qiov);\n\n        qemu_co_mutex_lock(&s->lock);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        while (l2meta != NULL) {\n\n            QCowL2Meta *next;\n\n\n\n            ret = qcow2_alloc_cluster_link_l2(bs, l2meta);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            /* Take the request off the list of running requests */\n\n            if (l2meta->nb_clusters != 0) {\n\n                QLIST_REMOVE(l2meta, next_in_flight);\n\n            }\n\n\n\n            qemu_co_queue_restart_all(&l2meta->dependent_requests);\n\n\n\n            next = l2meta->next;\n\n            g_free(l2meta);\n\n            l2meta = next;\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n        trace_qcow2_writev_done_part(qemu_coroutine_self(), cur_nr_sectors);\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    while (l2meta != NULL) {\n\n        QCowL2Meta *next;\n\n\n\n        if (l2meta->nb_clusters != 0) {\n\n            QLIST_REMOVE(l2meta, next_in_flight);\n\n        }\n\n        qemu_co_queue_restart_all(&l2meta->dependent_requests);\n\n\n\n        next = l2meta->next;\n\n        g_free(l2meta);\n\n        l2meta = next;\n\n    }\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n    qemu_vfree(cluster_data);\n\n    trace_qcow2_writev_done_req(qemu_coroutine_self(), ret);\n\n\n\n    return ret;\n\n}\n", "idx": 5275, "_split": "valid", "_hash": "e05605ec7ed089daa910860f469244fa"}
{"project": "qemu", "commit_id": "9adea5f7f7a23ef4a1231289a36a94c52347b142", "target": 0, "func": "do_send_recv(int sockfd, struct iovec *iov, unsigned iov_cnt, bool do_send)\n\n{\n\n#if defined CONFIG_IOVEC && defined CONFIG_POSIX\n\n    ssize_t ret;\n\n    struct msghdr msg;\n\n    memset(&msg, 0, sizeof(msg));\n\n    msg.msg_iov = iov;\n\n    msg.msg_iovlen = iov_cnt;\n\n    do {\n\n        ret = do_send\n\n            ? sendmsg(sockfd, &msg, 0)\n\n            : recvmsg(sockfd, &msg, 0);\n\n    } while (ret < 0 && errno == EINTR);\n\n    return ret;\n\n#else\n\n    /* else send piece-by-piece */\n\n    /*XXX Note: windows has WSASend() and WSARecv() */\n\n    unsigned i = 0;\n\n    ssize_t ret = 0;\n\n    while (i < iov_cnt) {\n\n        ssize_t r = do_send\n\n            ? send(sockfd, iov[i].iov_base, iov[i].iov_len, 0)\n\n            : recv(sockfd, iov[i].iov_base, iov[i].iov_len, 0);\n\n        if (r > 0) {\n\n            ret += r;\n\n        } else if (!r) {\n\n            break;\n\n        } else if (errno == EINTR) {\n\n            continue;\n\n        } else {\n\n            /* else it is some \"other\" error,\n\n             * only return if there was no data processed. */\n\n            if (ret == 0) {\n\n                ret = -1;\n\n            }\n\n            break;\n\n        }\n\n        i++;\n\n    }\n\n    return ret;\n\n#endif\n\n}\n", "idx": 5289, "_split": "valid", "_hash": "26218ad8fb07beef2cdba3c23ab89c0d"}
{"project": "qemu", "commit_id": "ef76dc59fa5203d146a2acf85a0ad5a5971a4824", "target": 0, "func": "START_TEST(keyword_literal)\n\n{\n\n    QObject *obj;\n\n    QBool *qbool;\n\n    QString *str;\n\n\n\n    obj = qobject_from_json(\"true\");\n\n    fail_unless(obj != NULL);\n\n    fail_unless(qobject_type(obj) == QTYPE_QBOOL);\n\n\n\n    qbool = qobject_to_qbool(obj);\n\n    fail_unless(qbool_get_int(qbool) != 0);\n\n\n\n    str = qobject_to_json(obj);\n\n    fail_unless(strcmp(qstring_get_str(str), \"true\") == 0);\n\n    QDECREF(str);\n\n\n\n    QDECREF(qbool);\n\n\n\n    obj = qobject_from_json(\"false\");\n\n    fail_unless(obj != NULL);\n\n    fail_unless(qobject_type(obj) == QTYPE_QBOOL);\n\n\n\n    qbool = qobject_to_qbool(obj);\n\n    fail_unless(qbool_get_int(qbool) == 0);\n\n\n\n    str = qobject_to_json(obj);\n\n    fail_unless(strcmp(qstring_get_str(str), \"false\") == 0);\n\n    QDECREF(str);\n\n\n\n    QDECREF(qbool);\n\n\n\n    obj = qobject_from_jsonf(\"%i\", false);\n\n    fail_unless(obj != NULL);\n\n    fail_unless(qobject_type(obj) == QTYPE_QBOOL);\n\n\n\n    qbool = qobject_to_qbool(obj);\n\n    fail_unless(qbool_get_int(qbool) == 0);\n\n\n\n    QDECREF(qbool);\n\n    \n\n    obj = qobject_from_jsonf(\"%i\", true);\n\n    fail_unless(obj != NULL);\n\n    fail_unless(qobject_type(obj) == QTYPE_QBOOL);\n\n\n\n    qbool = qobject_to_qbool(obj);\n\n    fail_unless(qbool_get_int(qbool) != 0);\n\n\n\n    QDECREF(qbool);\n\n}\n", "idx": 5290, "_split": "valid", "_hash": "73fded2bb03e6763208c198d300bb3ee"}
{"project": "qemu", "commit_id": "74b4c74d5efb0a489bdf0acc5b5d0197167e7649", "target": 0, "func": "static int handle_sigp_single_dst(S390CPU *dst_cpu, uint8_t order,\n\n                                  uint64_t param, uint64_t *status_reg)\n\n{\n\n    SigpInfo si = {\n\n        .param = param,\n\n        .status_reg = status_reg,\n\n    };\n\n\n\n    /* cpu available? */\n\n    if (dst_cpu == NULL) {\n\n        return SIGP_CC_NOT_OPERATIONAL;\n\n    }\n\n\n\n    /* only resets can break pending orders */\n\n    if (dst_cpu->env.sigp_order != 0 &&\n\n        order != SIGP_CPU_RESET &&\n\n        order != SIGP_INITIAL_CPU_RESET) {\n\n        return SIGP_CC_BUSY;\n\n    }\n\n\n\n    switch (order) {\n\n    case SIGP_START:\n\n        run_on_cpu(CPU(dst_cpu), sigp_start, RUN_ON_CPU_HOST_PTR(&si));\n\n        break;\n\n    case SIGP_STOP:\n\n        run_on_cpu(CPU(dst_cpu), sigp_stop, RUN_ON_CPU_HOST_PTR(&si));\n\n        break;\n\n    case SIGP_RESTART:\n\n        run_on_cpu(CPU(dst_cpu), sigp_restart, RUN_ON_CPU_HOST_PTR(&si));\n\n        break;\n\n    case SIGP_STOP_STORE_STATUS:\n\n        run_on_cpu(CPU(dst_cpu), sigp_stop_and_store_status, RUN_ON_CPU_HOST_PTR(&si));\n\n        break;\n\n    case SIGP_STORE_STATUS_ADDR:\n\n        run_on_cpu(CPU(dst_cpu), sigp_store_status_at_address, RUN_ON_CPU_HOST_PTR(&si));\n\n        break;\n\n    case SIGP_STORE_ADTL_STATUS:\n\n        run_on_cpu(CPU(dst_cpu), sigp_store_adtl_status, RUN_ON_CPU_HOST_PTR(&si));\n\n        break;\n\n    case SIGP_SET_PREFIX:\n\n        run_on_cpu(CPU(dst_cpu), sigp_set_prefix, RUN_ON_CPU_HOST_PTR(&si));\n\n        break;\n\n    case SIGP_INITIAL_CPU_RESET:\n\n        run_on_cpu(CPU(dst_cpu), sigp_initial_cpu_reset, RUN_ON_CPU_HOST_PTR(&si));\n\n        break;\n\n    case SIGP_CPU_RESET:\n\n        run_on_cpu(CPU(dst_cpu), sigp_cpu_reset, RUN_ON_CPU_HOST_PTR(&si));\n\n        break;\n\n    default:\n\n        set_sigp_status(&si, SIGP_STAT_INVALID_ORDER);\n\n    }\n\n\n\n    return si.cc;\n\n}\n", "idx": 5292, "_split": "valid", "_hash": "8195bf9ad9bb1ca6219ecef10b666a75"}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "long do_rt_sigreturn(CPUAlphaState *env)\n\n{\n\n    abi_ulong frame_addr = env->ir[IR_A0];\n\n    struct target_rt_sigframe *frame;\n\n    sigset_t set;\n\n\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1)) {\n\n        goto badframe;\n\n    }\n\n    target_to_host_sigset(&set, &frame->uc.tuc_sigmask);\n\n    do_sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n    if (restore_sigcontext(env, &frame->uc.tuc_mcontext)) {\n\n        goto badframe;\n\n    }\n\n    if (do_sigaltstack(frame_addr + offsetof(struct target_rt_sigframe,\n\n                                             uc.tuc_stack),\n\n                       0, env->ir[IR_SP]) == -EFAULT) {\n\n        goto badframe;\n\n    }\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return env->ir[IR_V0];\n\n\n\n\n\n badframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 5359, "_split": "valid", "_hash": "eed0e04165280f6ee258f6ca26bca156"}
{"project": "qemu", "commit_id": "f7838b5290de03f7cb2dbee5bd1ceae67b4a5ef0", "target": 0, "func": "static void cortex_a9_initfn(Object *obj)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(obj);\n\n\n\n    cpu->dtb_compatible = \"arm,cortex-a9\";\n\n    set_feature(&cpu->env, ARM_FEATURE_V7);\n\n    set_feature(&cpu->env, ARM_FEATURE_VFP3);\n\n    set_feature(&cpu->env, ARM_FEATURE_VFP_FP16);\n\n    set_feature(&cpu->env, ARM_FEATURE_NEON);\n\n    set_feature(&cpu->env, ARM_FEATURE_THUMB2EE);\n\n    /* Note that A9 supports the MP extensions even for\n\n     * A9UP and single-core A9MP (which are both different\n\n     * and valid configurations; we don't model A9UP).\n\n     */\n\n    set_feature(&cpu->env, ARM_FEATURE_V7MP);\n\n    set_feature(&cpu->env, ARM_FEATURE_CBAR);\n\n    cpu->midr = 0x410fc090;\n\n    cpu->reset_fpsid = 0x41033090;\n\n    cpu->mvfr0 = 0x11110222;\n\n    cpu->mvfr1 = 0x01111111;\n\n    cpu->ctr = 0x80038003;\n\n    cpu->reset_sctlr = 0x00c50078;\n\n    cpu->id_pfr0 = 0x1031;\n\n    cpu->id_pfr1 = 0x11;\n\n    cpu->id_dfr0 = 0x000;\n\n    cpu->id_afr0 = 0;\n\n    cpu->id_mmfr0 = 0x00100103;\n\n    cpu->id_mmfr1 = 0x20000000;\n\n    cpu->id_mmfr2 = 0x01230000;\n\n    cpu->id_mmfr3 = 0x00002111;\n\n    cpu->id_isar0 = 0x00101111;\n\n    cpu->id_isar1 = 0x13112111;\n\n    cpu->id_isar2 = 0x21232041;\n\n    cpu->id_isar3 = 0x11112131;\n\n    cpu->id_isar4 = 0x00111142;\n\n    cpu->dbgdidr = 0x35141000;\n\n    cpu->clidr = (1 << 27) | (1 << 24) | 3;\n\n    cpu->ccsidr[0] = 0xe00fe015; /* 16k L1 dcache. */\n\n    cpu->ccsidr[1] = 0x200fe015; /* 16k L1 icache. */\n\n    define_arm_cp_regs(cpu, cortexa9_cp_reginfo);\n\n}\n", "idx": 5366, "_split": "valid", "_hash": "9354e07754d4d601a742ed9738c55d1f"}
{"project": "qemu", "commit_id": "ef1e1e0782e99c9dcf2b35e5310cdd8ca9211374", "target": 0, "func": "static void bt_hci_reset(struct bt_hci_s *hci)\n\n{\n\n    hci->acl_len = 0;\n\n    hci->last_cmd = 0;\n\n    hci->lm.connecting = 0;\n\n\n\n    hci->event_mask[0] = 0xff;\n\n    hci->event_mask[1] = 0xff;\n\n    hci->event_mask[2] = 0xff;\n\n    hci->event_mask[3] = 0xff;\n\n    hci->event_mask[4] = 0xff;\n\n    hci->event_mask[5] = 0x1f;\n\n    hci->event_mask[6] = 0x00;\n\n    hci->event_mask[7] = 0x00;\n\n    hci->device.inquiry_scan = 0;\n\n    hci->device.page_scan = 0;\n\n    if (hci->device.lmp_name)\n\n        g_free((void *) hci->device.lmp_name);\n\n    hci->device.lmp_name = NULL;\n\n    hci->device.class[0] = 0x00;\n\n    hci->device.class[1] = 0x00;\n\n    hci->device.class[2] = 0x00;\n\n    hci->voice_setting = 0x0000;\n\n    hci->conn_accept_tout = 0x1f40;\n\n    hci->lm.inquiry_mode = 0x00;\n\n\n\n    hci->psb_handle = 0x000;\n\n    hci->asb_handle = 0x000;\n\n\n\n    /* XXX: timer_del(sl->acl_mode_timer); for all links */\n\n    timer_del(hci->lm.inquiry_done);\n\n    timer_del(hci->lm.inquiry_next);\n\n    timer_del(hci->conn_accept_timer);\n\n}\n", "idx": 5379, "_split": "valid", "_hash": "a87e7a17b99261cb17a9da14e0783d07"}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "static void net_tx_pkt_do_sw_csum(struct NetTxPkt *pkt)\n\n{\n\n    struct iovec *iov = &pkt->vec[NET_TX_PKT_L2HDR_FRAG];\n\n    uint32_t csum_cntr;\n\n    uint16_t csum = 0;\n\n    /* num of iovec without vhdr */\n\n    uint32_t iov_len = pkt->payload_frags + NET_TX_PKT_PL_START_FRAG - 1;\n\n    uint16_t csl;\n\n    struct ip_header *iphdr;\n\n    size_t csum_offset = pkt->virt_hdr.csum_start + pkt->virt_hdr.csum_offset;\n\n\n\n    /* Put zero to checksum field */\n\n    iov_from_buf(iov, iov_len, csum_offset, &csum, sizeof csum);\n\n\n\n    /* Calculate L4 TCP/UDP checksum */\n\n    csl = pkt->payload_len;\n\n\n\n    /* data checksum */\n\n    csum_cntr =\n\n        net_checksum_add_iov(iov, iov_len, pkt->virt_hdr.csum_start, csl);\n\n    /* add pseudo header to csum */\n\n    iphdr = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base;\n\n    csum_cntr += eth_calc_pseudo_hdr_csum(iphdr, csl);\n\n\n\n    /* Put the checksum obtained into the packet */\n\n    csum = cpu_to_be16(net_checksum_finish(csum_cntr));\n\n    iov_from_buf(iov, iov_len, csum_offset, &csum, sizeof csum);\n\n}\n", "idx": 5380, "_split": "valid", "_hash": "dd64e5fda9d271df6273d30cf1967764"}
{"project": "qemu", "commit_id": "9bcec938aab22a1b7ced916a6895e5029d4ed04f", "target": 1, "func": "void apic_reset_irq_delivered(void)\n\n{\n\n    trace_apic_reset_irq_delivered(apic_irq_delivered);\n\n\n\n    apic_irq_delivered = 0;\n\n}\n", "idx": 5402, "_split": "valid", "_hash": "fddf30533cd057dfac227958f1db72f9"}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static TAPState *net_tap_fd_init(VLANState *vlan, int fd)\n\n{\n\n    TAPState *s;\n\n\n\n    s = qemu_mallocz(sizeof(TAPState));\n\n    if (!s)\n\n        return NULL;\n\n    s->fd = fd;\n\n    s->vc = qemu_new_vlan_client(vlan, tap_receive, s);\n\n    qemu_set_fd_handler(s->fd, tap_send, NULL, s);\n\n    snprintf(s->vc->info_str, sizeof(s->vc->info_str), \"tap: fd=%d\", fd);\n\n    return s;\n\n}\n", "idx": 5403, "_split": "valid", "_hash": "2ec07d4961cb46b180e6bccdc2ffb9e7"}
{"project": "qemu", "commit_id": "231bb267644ee3a9ebfd9c7f42d5d41610194b45", "target": 1, "func": "int qcow2_check_metadata_overlap(BlockDriverState *bs, int chk, int64_t offset,\n\n                                 int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int i, j;\n\n\n\n    if (!size) {\n\n        return 0;\n\n    }\n\n\n\n    if (chk & QCOW2_OL_MAIN_HEADER) {\n\n        if (offset < s->cluster_size) {\n\n            return QCOW2_OL_MAIN_HEADER;\n\n        }\n\n    }\n\n\n\n    /* align range to test to cluster boundaries */\n\n    size = align_offset(offset_into_cluster(s, offset) + size, s->cluster_size);\n\n    offset = start_of_cluster(s, offset);\n\n\n\n    if ((chk & QCOW2_OL_ACTIVE_L1) && s->l1_size) {\n\n        if (overlaps_with(s->l1_table_offset, s->l1_size * sizeof(uint64_t))) {\n\n            return QCOW2_OL_ACTIVE_L1;\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_REFCOUNT_TABLE) && s->refcount_table_size) {\n\n        if (overlaps_with(s->refcount_table_offset,\n\n            s->refcount_table_size * sizeof(uint64_t))) {\n\n            return QCOW2_OL_REFCOUNT_TABLE;\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_SNAPSHOT_TABLE) && s->snapshots_size) {\n\n        if (overlaps_with(s->snapshots_offset, s->snapshots_size)) {\n\n            return QCOW2_OL_SNAPSHOT_TABLE;\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_INACTIVE_L1) && s->snapshots) {\n\n        for (i = 0; i < s->nb_snapshots; i++) {\n\n            if (s->snapshots[i].l1_size &&\n\n                overlaps_with(s->snapshots[i].l1_table_offset,\n\n                s->snapshots[i].l1_size * sizeof(uint64_t))) {\n\n                return QCOW2_OL_INACTIVE_L1;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_ACTIVE_L2) && s->l1_table) {\n\n        for (i = 0; i < s->l1_size; i++) {\n\n            if ((s->l1_table[i] & L1E_OFFSET_MASK) &&\n\n                overlaps_with(s->l1_table[i] & L1E_OFFSET_MASK,\n\n                s->cluster_size)) {\n\n                return QCOW2_OL_ACTIVE_L2;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_REFCOUNT_BLOCK) && s->refcount_table) {\n\n        for (i = 0; i < s->refcount_table_size; i++) {\n\n            if ((s->refcount_table[i] & REFT_OFFSET_MASK) &&\n\n                overlaps_with(s->refcount_table[i] & REFT_OFFSET_MASK,\n\n                s->cluster_size)) {\n\n                return QCOW2_OL_REFCOUNT_BLOCK;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_INACTIVE_L2) && s->snapshots) {\n\n        for (i = 0; i < s->nb_snapshots; i++) {\n\n            uint64_t l1_ofs = s->snapshots[i].l1_table_offset;\n\n            uint32_t l1_sz  = s->snapshots[i].l1_size;\n\n            uint64_t l1_sz2 = l1_sz * sizeof(uint64_t);\n\n            uint64_t *l1 = g_malloc(l1_sz2);\n\n            int ret;\n\n\n\n            ret = bdrv_pread(bs->file, l1_ofs, l1, l1_sz2);\n\n            if (ret < 0) {\n\n                g_free(l1);\n\n                return ret;\n\n            }\n\n\n\n            for (j = 0; j < l1_sz; j++) {\n\n                uint64_t l2_ofs = be64_to_cpu(l1[j]) & L1E_OFFSET_MASK;\n\n                if (l2_ofs && overlaps_with(l2_ofs, s->cluster_size)) {\n\n                    g_free(l1);\n\n                    return QCOW2_OL_INACTIVE_L2;\n\n                }\n\n            }\n\n\n\n            g_free(l1);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 5409, "_split": "valid", "_hash": "4e6265838cc6c454bc6f79c3657351f2"}
{"project": "qemu", "commit_id": "74c85296dc880568005b8e7572e08a39d66bcdca", "target": 0, "func": "static ram_addr_t s390_virtio_device_num_vq(VirtIOS390Device *dev)\n\n{\n\n    VirtIODevice *vdev = dev->vdev;\n\n    int num_vq;\n\n\n\n    for (num_vq = 0; num_vq < VIRTIO_PCI_QUEUE_MAX; num_vq++) {\n\n        if (!virtio_queue_get_num(vdev, num_vq)) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    return num_vq;\n\n}\n", "idx": 5459, "_split": "valid", "_hash": "c158889bb23c7cff0f2f50bfb5511b80"}
{"project": "qemu", "commit_id": "28143b409f698210d85165ca518235ac7e7c5ac5", "target": 0, "func": "static int kvm_get_xsave(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    struct kvm_xsave* xsave = env->kvm_xsave_buf;\n\n    int ret, i;\n\n    const uint8_t *xmm, *ymmh, *zmmh;\n\n    uint16_t cwd, swd, twd;\n\n\n\n    if (!kvm_has_xsave()) {\n\n        return kvm_get_fpu(cpu);\n\n    }\n\n\n\n    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_XSAVE, xsave);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    cwd = (uint16_t)xsave->region[XSAVE_FCW_FSW];\n\n    swd = (uint16_t)(xsave->region[XSAVE_FCW_FSW] >> 16);\n\n    twd = (uint16_t)xsave->region[XSAVE_FTW_FOP];\n\n    env->fpop = (uint16_t)(xsave->region[XSAVE_FTW_FOP] >> 16);\n\n    env->fpstt = (swd >> 11) & 7;\n\n    env->fpus = swd;\n\n    env->fpuc = cwd;\n\n    for (i = 0; i < 8; ++i) {\n\n        env->fptags[i] = !((twd >> i) & 1);\n\n    }\n\n    memcpy(&env->fpip, &xsave->region[XSAVE_CWD_RIP], sizeof(env->fpip));\n\n    memcpy(&env->fpdp, &xsave->region[XSAVE_CWD_RDP], sizeof(env->fpdp));\n\n    env->mxcsr = xsave->region[XSAVE_MXCSR];\n\n    memcpy(env->fpregs, &xsave->region[XSAVE_ST_SPACE],\n\n            sizeof env->fpregs);\n\n    env->xstate_bv = *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV];\n\n    memcpy(env->bnd_regs, &xsave->region[XSAVE_BNDREGS],\n\n            sizeof env->bnd_regs);\n\n    memcpy(&env->bndcs_regs, &xsave->region[XSAVE_BNDCSR],\n\n            sizeof(env->bndcs_regs));\n\n    memcpy(env->opmask_regs, &xsave->region[XSAVE_OPMASK],\n\n            sizeof env->opmask_regs);\n\n\n\n    xmm = (const uint8_t *)&xsave->region[XSAVE_XMM_SPACE];\n\n    ymmh = (const uint8_t *)&xsave->region[XSAVE_YMMH_SPACE];\n\n    zmmh = (const uint8_t *)&xsave->region[XSAVE_ZMM_Hi256];\n\n    for (i = 0; i < CPU_NB_REGS; i++, xmm += 16, ymmh += 16, zmmh += 32) {\n\n        env->xmm_regs[i].XMM_Q(0) = ldq_p(xmm);\n\n        env->xmm_regs[i].XMM_Q(1) = ldq_p(xmm+8);\n\n        env->xmm_regs[i].XMM_Q(2) = ldq_p(ymmh);\n\n        env->xmm_regs[i].XMM_Q(3) = ldq_p(ymmh+8);\n\n        env->xmm_regs[i].XMM_Q(4) = ldq_p(zmmh);\n\n        env->xmm_regs[i].XMM_Q(5) = ldq_p(zmmh+8);\n\n        env->xmm_regs[i].XMM_Q(6) = ldq_p(zmmh+16);\n\n        env->xmm_regs[i].XMM_Q(7) = ldq_p(zmmh+24);\n\n    }\n\n\n\n#ifdef TARGET_X86_64\n\n    memcpy(&env->xmm_regs[16], &xsave->region[XSAVE_Hi16_ZMM],\n\n           16 * sizeof env->xmm_regs[16]);\n\n#endif\n\n    return 0;\n\n}\n", "idx": 5460, "_split": "valid", "_hash": "5ca35378babce4f7681613589588c181"}
{"project": "qemu", "commit_id": "2c62f08ddbf3fa80dc7202eb9a2ea60ae44e2cc5", "target": 0, "func": "static int jazz_led_init(SysBusDevice *dev)\n\n{\n\n    LedState *s = FROM_SYSBUS(LedState, dev);\n\n\n\n    memory_region_init_io(&s->iomem, &led_ops, s, \"led\", 1);\n\n    sysbus_init_mmio(dev, &s->iomem);\n\n\n\n    s->con = graphic_console_init(jazz_led_update_display,\n\n                                  jazz_led_invalidate_display,\n\n                                  NULL,\n\n                                  jazz_led_text_update, s);\n\n\n\n    return 0;\n\n}\n", "idx": 5464, "_split": "valid", "_hash": "83ec8007f433c1e72b3156c3b465c207"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t hpet_ram_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n    printf(\"qemu: hpet_read b at %\" PRIx64 \"\\n\", addr);\n\n    return 0;\n\n}\n", "idx": 5467, "_split": "valid", "_hash": "87d555f544f5ca7c40d7b5ac6d862d08"}
{"project": "qemu", "commit_id": "60e68042cf70f271308dc6b4b22b609d054af929", "target": 0, "func": "static bool x86_cpu_has_work(CPUState *cs)\n\n{\n\n    X86CPU *cpu = X86_CPU(cs);\n\n    CPUX86State *env = &cpu->env;\n\n\n\n    return ((cs->interrupt_request & (CPU_INTERRUPT_HARD |\n\n                                      CPU_INTERRUPT_POLL)) &&\n\n            (env->eflags & IF_MASK)) ||\n\n           (cs->interrupt_request & (CPU_INTERRUPT_NMI |\n\n                                     CPU_INTERRUPT_INIT |\n\n                                     CPU_INTERRUPT_SIPI |\n\n                                     CPU_INTERRUPT_MCE));\n\n}\n", "idx": 5484, "_split": "valid", "_hash": "d823f3d15826abd653e26310d1bc3ee1"}
{"project": "qemu", "commit_id": "16b781aaef69c90d5f4f5456615f0c26a4f45740", "target": 0, "func": "static void sd_reset(SDState *sd, BlockBackend *blk)\n\n{\n\n    uint64_t size;\n\n    uint64_t sect;\n\n\n\n    if (blk) {\n\n        blk_get_geometry(blk, &sect);\n\n    } else {\n\n        sect = 0;\n\n    }\n\n    size = sect << 9;\n\n\n\n    sect = sd_addr_to_wpnum(size) + 1;\n\n\n\n    sd->state = sd_idle_state;\n\n    sd->rca = 0x0000;\n\n    sd_set_ocr(sd);\n\n    sd_set_scr(sd);\n\n    sd_set_cid(sd);\n\n    sd_set_csd(sd, size);\n\n    sd_set_cardstatus(sd);\n\n    sd_set_sdstatus(sd);\n\n\n\n    sd->blk = blk;\n\n\n\n    if (sd->wp_groups)\n\n        g_free(sd->wp_groups);\n\n    sd->wp_switch = blk ? blk_is_read_only(blk) : false;\n\n    sd->wpgrps_size = sect;\n\n    sd->wp_groups = bitmap_new(sd->wpgrps_size);\n\n    memset(sd->function_group, 0, sizeof(sd->function_group));\n\n    sd->erase_start = 0;\n\n    sd->erase_end = 0;\n\n    sd->size = size;\n\n    sd->blk_len = 0x200;\n\n    sd->pwd_len = 0;\n\n    sd->expecting_acmd = false;\n\n}\n", "idx": 5487, "_split": "valid", "_hash": "7ca987ae47b624c3692fc5d3f199eb33"}
{"project": "qemu", "commit_id": "f3a06403b82c7f036564e4caf18b52ce6885fcfb", "target": 1, "func": "struct GuestAgentInfo *qmp_guest_info(Error **errp)\n\n{\n\n    GuestAgentInfo *info = g_malloc0(sizeof(GuestAgentInfo));\n\n\n\n    info->version = g_strdup(QEMU_VERSION);\n\n    qmp_for_each_command(qmp_command_info, info);\n\n    return info;\n\n}\n", "idx": 5510, "_split": "valid", "_hash": "b657f3679b70524a9a32c44e365c7728"}
{"project": "qemu", "commit_id": "d9d3aaea0b3fbb5028e20316bdb93359487cd01f", "target": 1, "func": "void replay_configure(QemuOpts *opts)\n\n{\n\n    const char *fname;\n\n    const char *rr;\n\n    ReplayMode mode = REPLAY_MODE_NONE;\n\n    Location loc;\n\n\n\n    if (!opts) {\n\n        return;\n\n    }\n\n\n\n    loc_push_none(&loc);\n\n    qemu_opts_loc_restore(opts);\n\n\n\n    rr = qemu_opt_get(opts, \"rr\");\n\n    if (!rr) {\n\n        /* Just enabling icount */\n\n        return;\n\n    } else if (!strcmp(rr, \"record\")) {\n\n        mode = REPLAY_MODE_RECORD;\n\n    } else if (!strcmp(rr, \"replay\")) {\n\n        mode = REPLAY_MODE_PLAY;\n\n    } else {\n\n        error_report(\"Invalid icount rr option: %s\", rr);\n\n        exit(1);\n\n    }\n\n\n\n    fname = qemu_opt_get(opts, \"rrfile\");\n\n    if (!fname) {\n\n        error_report(\"File name not specified for replay\");\n\n        exit(1);\n\n    }\n\n\n\n    replay_enable(fname, mode);\n\n\n\n    loc_pop(&loc);\n\n}\n", "idx": 5521, "_split": "valid", "_hash": "e81fa34e6968265a6756fc6e7ac8c4d4"}
{"project": "qemu", "commit_id": "a1f0cce2ac0243572ff72aa561da67fe3766a395", "target": 1, "func": "void scsi_req_dequeue(SCSIRequest *req)\n\n{\n\n    trace_scsi_req_dequeue(req->dev->id, req->lun, req->tag);\n\n    if (req->enqueued) {\n\n        QTAILQ_REMOVE(&req->dev->requests, req, next);\n\n        req->enqueued = false;\n\n        scsi_req_unref(req);\n\n    }\n\n}\n", "idx": 5526, "_split": "valid", "_hash": "b97dd8957ae027983a0732b671ff3abf"}
{"project": "qemu", "commit_id": "1343a107e46feed8b901bf08ad8485bd5f302912", "target": 1, "func": "static int pci_rocker_init(PCIDevice *dev)\n\n{\n\n    Rocker *r = to_rocker(dev);\n\n    const MACAddr zero = { .a = { 0, 0, 0, 0, 0, 0 } };\n\n    const MACAddr dflt = { .a = { 0x52, 0x54, 0x00, 0x12, 0x35, 0x01 } };\n\n    static int sw_index;\n\n    int i, err = 0;\n\n\n\n    /* allocate worlds */\n\n\n\n    r->worlds[ROCKER_WORLD_TYPE_OF_DPA] = of_dpa_world_alloc(r);\n\n\n\n    if (!r->world_name) {\n\n        r->world_name = g_strdup(world_name(r->worlds[ROCKER_WORLD_TYPE_OF_DPA]));\n\n    }\n\n\n\n    r->world_dflt = rocker_world_type_by_name(r, r->world_name);\n\n    if (!r->world_dflt) {\n\n        fprintf(stderr,\n\n                \"rocker: requested world \\\"%s\\\" does not exist\\n\",\n\n                r->world_name);\n\n        err = -EINVAL;\n\n        goto err_world_type_by_name;\n\n    }\n\n\n\n    /* set up memory-mapped region at BAR0 */\n\n\n\n    memory_region_init_io(&r->mmio, OBJECT(r), &rocker_mmio_ops, r,\n\n                          \"rocker-mmio\", ROCKER_PCI_BAR0_SIZE);\n\n    pci_register_bar(dev, ROCKER_PCI_BAR0_IDX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &r->mmio);\n\n\n\n    /* set up memory-mapped region for MSI-X */\n\n\n\n    memory_region_init(&r->msix_bar, OBJECT(r), \"rocker-msix-bar\",\n\n                       ROCKER_PCI_MSIX_BAR_SIZE);\n\n    pci_register_bar(dev, ROCKER_PCI_MSIX_BAR_IDX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &r->msix_bar);\n\n\n\n    /* MSI-X init */\n\n\n\n    err = rocker_msix_init(r);\n\n    if (err) {\n\n        goto err_msix_init;\n\n    }\n\n\n\n    /* validate switch properties */\n\n\n\n    if (!r->name) {\n\n        r->name = g_strdup(ROCKER);\n\n    }\n\n\n\n    if (rocker_find(r->name)) {\n\n        err = -EEXIST;\n\n        goto err_duplicate;\n\n    }\n\n\n\n    /* Rocker name is passed in port name requests to OS with the intention\n\n     * that the name is used in interface names. Limit the length of the\n\n     * rocker name to avoid naming problems in the OS. Also, adding the\n\n     * port number as p# and unganged breakout b#, where # is at most 2\n\n     * digits, so leave room for it too (-1 for string terminator, -3 for\n\n     * p# and -3 for b#)\n\n     */\n\n#define ROCKER_IFNAMSIZ 16\n\n#define MAX_ROCKER_NAME_LEN  (ROCKER_IFNAMSIZ - 1 - 3 - 3)\n\n    if (strlen(r->name) > MAX_ROCKER_NAME_LEN) {\n\n        fprintf(stderr,\n\n                \"rocker: name too long; please shorten to at most %d chars\\n\",\n\n                MAX_ROCKER_NAME_LEN);\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (memcmp(&r->fp_start_macaddr, &zero, sizeof(zero)) == 0) {\n\n        memcpy(&r->fp_start_macaddr, &dflt, sizeof(dflt));\n\n        r->fp_start_macaddr.a[4] += (sw_index++);\n\n    }\n\n\n\n    if (!r->switch_id) {\n\n        memcpy(&r->switch_id, &r->fp_start_macaddr,\n\n               sizeof(r->fp_start_macaddr));\n\n    }\n\n\n\n    if (r->fp_ports > ROCKER_FP_PORTS_MAX) {\n\n        r->fp_ports = ROCKER_FP_PORTS_MAX;\n\n    }\n\n\n\n    r->rings = g_new(DescRing *, rocker_pci_ring_count(r));\n\n\n\n    /* Rings are ordered like this:\n\n     * - command ring\n\n     * - event ring\n\n     * - port0 tx ring\n\n     * - port0 rx ring\n\n     * - port1 tx ring\n\n     * - port1 rx ring\n\n     * .....\n\n     */\n\n\n\n    for (i = 0; i < rocker_pci_ring_count(r); i++) {\n\n        DescRing *ring = desc_ring_alloc(r, i);\n\n\n\n        if (i == ROCKER_RING_CMD) {\n\n            desc_ring_set_consume(ring, cmd_consume, ROCKER_MSIX_VEC_CMD);\n\n        } else if (i == ROCKER_RING_EVENT) {\n\n            desc_ring_set_consume(ring, NULL, ROCKER_MSIX_VEC_EVENT);\n\n        } else if (i % 2 == 0) {\n\n            desc_ring_set_consume(ring, tx_consume,\n\n                                  ROCKER_MSIX_VEC_TX((i - 2) / 2));\n\n        } else if (i % 2 == 1) {\n\n            desc_ring_set_consume(ring, NULL, ROCKER_MSIX_VEC_RX((i - 3) / 2));\n\n        }\n\n\n\n        r->rings[i] = ring;\n\n    }\n\n\n\n    for (i = 0; i < r->fp_ports; i++) {\n\n        FpPort *port =\n\n            fp_port_alloc(r, r->name, &r->fp_start_macaddr,\n\n                          i, &r->fp_ports_peers[i]);\n\n\n\n        r->fp_port[i] = port;\n\n        fp_port_set_world(port, r->world_dflt);\n\n    }\n\n\n\n    QLIST_INSERT_HEAD(&rockers, r, next);\n\n\n\n    return 0;\n\n\n\nerr_duplicate:\n\n    rocker_msix_uninit(r);\n\nerr_msix_init:\n\n    object_unparent(OBJECT(&r->msix_bar));\n\n    object_unparent(OBJECT(&r->mmio));\n\nerr_world_type_by_name:\n\n    for (i = 0; i < ROCKER_WORLD_TYPE_MAX; i++) {\n\n        if (r->worlds[i]) {\n\n            world_free(r->worlds[i]);\n\n        }\n\n    }\n\n    return err;\n\n}\n", "idx": 5529, "_split": "valid", "_hash": "50f48b4508060e5714b6b25ce4b0a582"}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static int cow_test_bit(int64_t bitnum, const uint8_t *bitmap)\n\n{\n\n    return (bitmap[bitnum / 8] & (1 << (bitnum & 7))) != 0;\n\n}\n", "idx": 5566, "_split": "valid", "_hash": "edcba5778c706346c7b752f26c9390b7"}
{"project": "qemu", "commit_id": "a007b1f85813ef6450ad3e761e46c189e3f40e04", "target": 0, "func": "static void create_gic(VirtBoardInfo *vbi, qemu_irq *pic)\n\n{\n\n    /* We create a standalone GIC v2 */\n\n    DeviceState *gicdev;\n\n    SysBusDevice *gicbusdev;\n\n    const char *gictype;\n\n    int i;\n\n\n\n    gictype = gic_class_name();\n\n\n\n    gicdev = qdev_create(NULL, gictype);\n\n    qdev_prop_set_uint32(gicdev, \"revision\", 2);\n\n    qdev_prop_set_uint32(gicdev, \"num-cpu\", smp_cpus);\n\n    /* Note that the num-irq property counts both internal and external\n\n     * interrupts; there are always 32 of the former (mandated by GIC spec).\n\n     */\n\n    qdev_prop_set_uint32(gicdev, \"num-irq\", NUM_IRQS + 32);\n\n    qdev_init_nofail(gicdev);\n\n    gicbusdev = SYS_BUS_DEVICE(gicdev);\n\n    sysbus_mmio_map(gicbusdev, 0, vbi->memmap[VIRT_GIC_DIST].base);\n\n    sysbus_mmio_map(gicbusdev, 1, vbi->memmap[VIRT_GIC_CPU].base);\n\n\n\n    /* Wire the outputs from each CPU's generic timer to the\n\n     * appropriate GIC PPI inputs, and the GIC's IRQ output to\n\n     * the CPU's IRQ input.\n\n     */\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        DeviceState *cpudev = DEVICE(qemu_get_cpu(i));\n\n        int ppibase = NUM_IRQS + i * GIC_INTERNAL + GIC_NR_SGIS;\n\n        /* physical timer; we wire it up to the non-secure timer's ID,\n\n         * since a real A15 always has TrustZone but QEMU doesn't.\n\n         */\n\n        qdev_connect_gpio_out(cpudev, 0,\n\n                              qdev_get_gpio_in(gicdev,\n\n                                             ppibase + ARCH_TIMER_NS_EL1_IRQ));\n\n        /* virtual timer */\n\n        qdev_connect_gpio_out(cpudev, 1,\n\n                              qdev_get_gpio_in(gicdev,\n\n                                               ppibase + ARCH_TIMER_VIRT_IRQ));\n\n        /* Hypervisor timer.  */\n\n        qdev_connect_gpio_out(cpudev, 2,\n\n                              qdev_get_gpio_in(gicdev,\n\n                                             ppibase + ARCH_TIMER_NS_EL2_IRQ));\n\n\n\n        sysbus_connect_irq(gicbusdev, i, qdev_get_gpio_in(cpudev, ARM_CPU_IRQ));\n\n        sysbus_connect_irq(gicbusdev, i + smp_cpus,\n\n                           qdev_get_gpio_in(cpudev, ARM_CPU_FIQ));\n\n    }\n\n\n\n    for (i = 0; i < NUM_IRQS; i++) {\n\n        pic[i] = qdev_get_gpio_in(gicdev, i);\n\n    }\n\n\n\n    fdt_add_gic_node(vbi);\n\n\n\n    create_v2m(vbi, pic);\n\n}\n", "idx": 5570, "_split": "valid", "_hash": "e2c17edf27c69ce99c5b84b36016c605"}
{"project": "qemu", "commit_id": "40fda982f2e887f7d5cc36b8a7e3b5a07a1e6704", "target": 0, "func": "static void kvmppc_host_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n    uint32_t vmx = kvmppc_get_vmx();\n\n    uint32_t dfp = kvmppc_get_dfp();\n\n    uint32_t dcache_size = kvmppc_read_int_cpu_dt(\"d-cache-size\");\n\n    uint32_t icache_size = kvmppc_read_int_cpu_dt(\"i-cache-size\");\n\n\n\n    /* Now fix up the class with information we can query from the host */\n\n    pcc->pvr = mfpvr();\n\n\n\n    if (vmx != -1) {\n\n        /* Only override when we know what the host supports */\n\n        alter_insns(&pcc->insns_flags, PPC_ALTIVEC, vmx > 0);\n\n        alter_insns(&pcc->insns_flags2, PPC2_VSX, vmx > 1);\n\n    }\n\n    if (dfp != -1) {\n\n        /* Only override when we know what the host supports */\n\n        alter_insns(&pcc->insns_flags2, PPC2_DFP, dfp);\n\n    }\n\n\n\n    if (dcache_size != -1) {\n\n        pcc->l1_dcache_size = dcache_size;\n\n    }\n\n\n\n    if (icache_size != -1) {\n\n        pcc->l1_icache_size = icache_size;\n\n    }\n\n\n\n    /* Reason: kvmppc_host_cpu_initfn() dies when !kvm_enabled() */\n\n    dc->cannot_destroy_with_object_finalize_yet = true;\n\n}\n", "idx": 5573, "_split": "valid", "_hash": "0afa81f9c226dcfa3656a73e0114ffa5"}
{"project": "qemu", "commit_id": "e6afc87f804abee7d0479be5e8e31c56d885fafb", "target": 1, "func": "static float128 addFloat128Sigs( float128 a, float128 b, flag zSign STATUS_PARAM)\n\n{\n\n    int32 aExp, bExp, zExp;\n\n    uint64_t aSig0, aSig1, bSig0, bSig1, zSig0, zSig1, zSig2;\n\n    int32 expDiff;\n\n\n\n    aSig1 = extractFloat128Frac1( a );\n\n    aSig0 = extractFloat128Frac0( a );\n\n    aExp = extractFloat128Exp( a );\n\n    bSig1 = extractFloat128Frac1( b );\n\n    bSig0 = extractFloat128Frac0( b );\n\n    bExp = extractFloat128Exp( b );\n\n    expDiff = aExp - bExp;\n\n    if ( 0 < expDiff ) {\n\n        if ( aExp == 0x7FFF ) {\n\n            if ( aSig0 | aSig1 ) return propagateFloat128NaN( a, b STATUS_VAR );\n\n            return a;\n\n        }\n\n        if ( bExp == 0 ) {\n\n            --expDiff;\n\n        }\n\n        else {\n\n            bSig0 |= LIT64( 0x0001000000000000 );\n\n        }\n\n        shift128ExtraRightJamming(\n\n            bSig0, bSig1, 0, expDiff, &bSig0, &bSig1, &zSig2 );\n\n        zExp = aExp;\n\n    }\n\n    else if ( expDiff < 0 ) {\n\n        if ( bExp == 0x7FFF ) {\n\n            if ( bSig0 | bSig1 ) return propagateFloat128NaN( a, b STATUS_VAR );\n\n            return packFloat128( zSign, 0x7FFF, 0, 0 );\n\n        }\n\n        if ( aExp == 0 ) {\n\n            ++expDiff;\n\n        }\n\n        else {\n\n            aSig0 |= LIT64( 0x0001000000000000 );\n\n        }\n\n        shift128ExtraRightJamming(\n\n            aSig0, aSig1, 0, - expDiff, &aSig0, &aSig1, &zSig2 );\n\n        zExp = bExp;\n\n    }\n\n    else {\n\n        if ( aExp == 0x7FFF ) {\n\n            if ( aSig0 | aSig1 | bSig0 | bSig1 ) {\n\n                return propagateFloat128NaN( a, b STATUS_VAR );\n\n            }\n\n            return a;\n\n        }\n\n        add128( aSig0, aSig1, bSig0, bSig1, &zSig0, &zSig1 );\n\n        if ( aExp == 0 ) {\n\n            if ( STATUS(flush_to_zero) ) return packFloat128( zSign, 0, 0, 0 );\n\n            return packFloat128( zSign, 0, zSig0, zSig1 );\n\n        }\n\n        zSig2 = 0;\n\n        zSig0 |= LIT64( 0x0002000000000000 );\n\n        zExp = aExp;\n\n        goto shiftRight1;\n\n    }\n\n    aSig0 |= LIT64( 0x0001000000000000 );\n\n    add128( aSig0, aSig1, bSig0, bSig1, &zSig0, &zSig1 );\n\n    --zExp;\n\n    if ( zSig0 < LIT64( 0x0002000000000000 ) ) goto roundAndPack;\n\n    ++zExp;\n\n shiftRight1:\n\n    shift128ExtraRightJamming(\n\n        zSig0, zSig1, zSig2, 1, &zSig0, &zSig1, &zSig2 );\n\n roundAndPack:\n\n    return roundAndPackFloat128( zSign, zExp, zSig0, zSig1, zSig2 STATUS_VAR );\n\n\n\n}\n", "idx": 5596, "_split": "valid", "_hash": "2f3a193cfdd2f4e3eba1e5beb020d59f"}
{"project": "qemu", "commit_id": "53333801e7bb41487147599e1b16b60ebea74695", "target": 1, "func": "static void test_acpi_one(const char *params)\n\n{\n\n    char *args;\n\n    uint8_t signature_low;\n\n    uint8_t signature_high;\n\n    uint16_t signature;\n\n    int i;\n\n    uint32_t off;\n\n\n\n\n\n    args = g_strdup_printf(\"-net none -display none %s %s\",\n\n                           params ? params : \"\", disk);\n\n    qtest_start(args);\n\n\n\n   /* Wait at most 1 minute */\n\n#define TEST_DELAY (1 * G_USEC_PER_SEC / 10)\n\n#define TEST_CYCLES MAX((60 * G_USEC_PER_SEC / TEST_DELAY), 1)\n\n\n\n    /* Poll until code has run and modified memory.  Once it has we know BIOS\n\n     * initialization is done.  TODO: check that IP reached the halt\n\n     * instruction.\n\n     */\n\n    for (i = 0; i < TEST_CYCLES; ++i) {\n\n        signature_low = readb(BOOT_SECTOR_ADDRESS + SIGNATURE_OFFSET);\n\n        signature_high = readb(BOOT_SECTOR_ADDRESS + SIGNATURE_OFFSET + 1);\n\n        signature = (signature_high << 8) | signature_low;\n\n        if (signature == SIGNATURE) {\n\n            break;\n\n        }\n\n        g_usleep(TEST_DELAY);\n\n    }\n\n    g_assert_cmphex(signature, ==, SIGNATURE);\n\n\n\n    /* OK, now find RSDP */\n\n    for (off = 0xf0000; off < 0x100000; off += 0x10)\n\n    {\n\n        uint8_t sig[] = \"RSD PTR \";\n\n        int i;\n\n\n\n        for (i = 0; i < sizeof sig - 1; ++i) {\n\n            sig[i] = readb(off + i);\n\n        }\n\n\n\n        if (!memcmp(sig, \"RSD PTR \", sizeof sig)) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    g_assert_cmphex(off, <, 0x100000);\n\n\n\n    qtest_quit(global_qtest);\n\n    g_free(args);\n\n}\n", "idx": 5601, "_split": "valid", "_hash": "d71ded9a55378dd0dd141fcf7ff2f8eb"}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void kqemu_set_phys_mem(uint64_t start_addr, ram_addr_t size, \n\n                        ram_addr_t phys_offset)\n\n{\n\n    struct kqemu_phys_mem kphys_mem1, *kphys_mem = &kphys_mem1;\n\n    uint64_t end;\n\n    int ret, io_index;\n\n\n\n    end = (start_addr + size + TARGET_PAGE_SIZE - 1) & TARGET_PAGE_MASK;\n\n    start_addr &= TARGET_PAGE_MASK;\n\n    kphys_mem->phys_addr = start_addr;\n\n    kphys_mem->size = end - start_addr;\n\n    kphys_mem->ram_addr = phys_offset & TARGET_PAGE_MASK;\n\n    io_index = phys_offset & ~TARGET_PAGE_MASK;\n\n    switch(io_index) {\n\n    case IO_MEM_RAM:\n\n        kphys_mem->io_index = KQEMU_IO_MEM_RAM;\n\n        break;\n\n    case IO_MEM_ROM:\n\n        kphys_mem->io_index = KQEMU_IO_MEM_ROM;\n\n        break;\n\n    default:\n\n        if (qpi_io_memory == io_index) {\n\n            kphys_mem->io_index = KQEMU_IO_MEM_COMM;\n\n        } else {\n\n            kphys_mem->io_index = KQEMU_IO_MEM_UNASSIGNED;\n\n        }\n\n        break;\n\n    }\n\n#ifdef _WIN32\n\n    {\n\n        DWORD temp;\n\n        ret = DeviceIoControl(kqemu_fd, KQEMU_SET_PHYS_MEM, \n\n                              kphys_mem, sizeof(*kphys_mem),\n\n                              NULL, 0, &temp, NULL) == TRUE ? 0 : -1;\n\n    }\n\n#else\n\n    ret = ioctl(kqemu_fd, KQEMU_SET_PHYS_MEM, kphys_mem);\n\n#endif\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"kqemu: KQEMU_SET_PHYS_PAGE error=%d: start_addr=0x%016\" PRIx64 \" size=0x%08lx phys_offset=0x%08lx\\n\",\n\n                ret, start_addr, \n\n                (unsigned long)size, (unsigned long)phys_offset);\n\n    }\n\n}\n", "idx": 5634, "_split": "valid", "_hash": "c45c874072c8988b9f50ea422cd8042f"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_dpll_write(void *opaque, target_phys_addr_t addr,\n\n                            uint64_t value, unsigned size)\n\n{\n\n    struct dpll_ctl_s *s = (struct dpll_ctl_s *) opaque;\n\n    uint16_t diff;\n\n    static const int bypass_div[4] = { 1, 2, 4, 4 };\n\n    int div, mult;\n\n\n\n    if (size != 2) {\n\n        return omap_badwidth_write16(opaque, addr, value);\n\n    }\n\n\n\n    if (addr == 0x00) {\t/* CTL_REG */\n\n        /* See omap_ulpd_pm_write() too */\n\n        diff = s->mode & value;\n\n        s->mode = value & 0x2fff;\n\n        if (diff & (0x3ff << 2)) {\n\n            if (value & (1 << 4)) {\t\t\t/* PLL_ENABLE */\n\n                div = ((value >> 5) & 3) + 1;\t\t/* PLL_DIV */\n\n                mult = MIN((value >> 7) & 0x1f, 1);\t/* PLL_MULT */\n\n            } else {\n\n                div = bypass_div[((value >> 2) & 3)];\t/* BYPASS_DIV */\n\n                mult = 1;\n\n            }\n\n            omap_clk_setrate(s->dpll, div, mult);\n\n        }\n\n\n\n        /* Enter the desired mode.  */\n\n        s->mode = (s->mode & 0xfffe) | ((s->mode >> 4) & 1);\n\n\n\n        /* Act as if the lock is restored.  */\n\n        s->mode |= 2;\n\n    } else {\n\n        OMAP_BAD_REG(addr);\n\n    }\n\n}\n", "idx": 5638, "_split": "valid", "_hash": "ad7e55bdd79941d3aac1d2741c21296d"}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_evfsneg(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);\n\n#else\n\n    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);\n\n    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);\n\n#endif\n\n}\n", "idx": 5640, "_split": "valid", "_hash": "de1e5a11222febff2db12901406264d6"}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "static void qmp_input_start_list(Visitor *v, const char *name, Error **errp)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qmp_input_get_object(qiv, name, true);\n\n\n\n    if (!qobj || qobject_type(qobj) != QTYPE_QLIST) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"list\");\n\n        return;\n\n    }\n\n\n\n    qmp_input_push(qiv, qobj, errp);\n\n}\n", "idx": 5648, "_split": "valid", "_hash": "6cd59af89402fd6b0a289a42b1c71158"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void nvic_sysreg_write(void *opaque, target_phys_addr_t addr,\n\n                              uint64_t value, unsigned size)\n\n{\n\n    uint32_t offset = addr;\n\n    if (size == 4) {\n\n        nvic_writel(opaque, offset, value);\n\n        return;\n\n    }\n\n    hw_error(\"NVIC: Bad write of size %d at offset 0x%x\\n\", size, offset);\n\n}\n", "idx": 5660, "_split": "valid", "_hash": "83b8c94c5676eb7cd95325d5f074d41a"}
{"project": "qemu", "commit_id": "3716d5902d743e9a395b7d82f48df4fa56ed1ad3", "target": 0, "func": "static void pci_init_bus_master(PCIDevice *pci_dev)\n\n{\n\n    AddressSpace *dma_as = pci_device_iommu_address_space(pci_dev);\n\n\n\n    memory_region_init_alias(&pci_dev->bus_master_enable_region,\n\n                             OBJECT(pci_dev), \"bus master\",\n\n                             dma_as->root, 0, memory_region_size(dma_as->root));\n\n    memory_region_set_enabled(&pci_dev->bus_master_enable_region, false);\n\n    address_space_init(&pci_dev->bus_master_as,\n\n                       &pci_dev->bus_master_enable_region, pci_dev->name);\n\n}\n", "idx": 5666, "_split": "valid", "_hash": "a79b604edec05cd5f2b4d6f71526ea22"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_set_event_notifier_poll(AioContext *ctx,\n\n                                 EventNotifier *notifier,\n\n                                 EventNotifierHandler *io_poll_begin,\n\n                                 EventNotifierHandler *io_poll_end)\n\n{\n\n    aio_set_fd_poll(ctx, event_notifier_get_fd(notifier),\n\n                    (IOHandler *)io_poll_begin,\n\n                    (IOHandler *)io_poll_end);\n\n}\n", "idx": 5674, "_split": "valid", "_hash": "f40c6210e016e691df2c88eba57272bc"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t m5208_sys_read(void *opaque, target_phys_addr_t addr,\n\n                               unsigned size)\n\n{\n\n    switch (addr) {\n\n    case 0x110: /* SDCS0 */\n\n        {\n\n            int n;\n\n            for (n = 0; n < 32; n++) {\n\n                if (ram_size < (2u << n))\n\n                    break;\n\n            }\n\n            return (n - 1)  | 0x40000000;\n\n        }\n\n    case 0x114: /* SDCS1 */\n\n        return 0;\n\n\n\n    default:\n\n        hw_error(\"m5208_sys_read: Bad offset 0x%x\\n\", (int)addr);\n\n        return 0;\n\n    }\n\n}\n", "idx": 5682, "_split": "valid", "_hash": "3d55586561911a3628ad06cfca3c62d7"}
{"project": "qemu", "commit_id": "c4843a45e3d4f3698b214275ab5e78cdb6a3d212", "target": 1, "func": "static int vhost_user_set_vring_addr(struct vhost_dev *dev,\n\n                                     struct vhost_vring_addr *addr)\n\n{\n\n    VhostUserMsg msg = {\n\n        .request = VHOST_USER_SET_VRING_ADDR,\n\n        .flags = VHOST_USER_VERSION,\n\n        .payload.addr = *addr,\n\n        .size = sizeof(msg.payload.addr),\n\n    };\n\n\n\n    vhost_user_write(dev, &msg, NULL, 0);\n\n\n\n    return 0;\n\n}\n", "idx": 5713, "_split": "valid", "_hash": "520b07b958081bcaf5201ed64d57db6a"}
{"project": "qemu", "commit_id": "3da9eebda96780ead8ba44b8140c54f4a54c61f6", "target": 1, "func": "static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,\n\n                                    void *opaque)\n\n{\n\n    const VMStateSubsection *sub = vmsd->subsections;\n\n\n\n    while (sub && sub->needed) {\n\n        if (sub->needed(opaque)) {\n\n            const VMStateDescription *vmsd = sub->vmsd;\n\n            uint8_t len;\n\n\n\n            qemu_put_byte(f, QEMU_VM_SUBSECTION);\n\n            len = strlen(vmsd->name);\n\n            qemu_put_byte(f, len);\n\n            qemu_put_buffer(f, (uint8_t *)vmsd->name, len);\n\n            qemu_put_be32(f, vmsd->version_id);\n\n            assert(!vmsd->subsections);\n\n            vmstate_save_state(f, vmsd, opaque);\n\n        }\n\n        sub++;\n\n    }\n\n}\n", "idx": 5768, "_split": "valid", "_hash": "c906237cd24ea5c17a93fc5cd54972ac"}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static const char *token_get_value(QObject *obj)\n\n{\n\n    return qdict_get_str(qobject_to_qdict(obj), \"token\");\n\n}\n", "idx": 5816, "_split": "valid", "_hash": "3949fe97bb1670e9cbdf71d189adc2d8"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void channel_store_d(struct fs_dma_ctrl *ctrl, int c)\n\n{\n\n\ttarget_phys_addr_t addr = channel_reg(ctrl, c, RW_SAVED_DATA);\n\n\n\n\t/* Encode and store. FIXME: handle endianness.  */\n\n\tD(printf(\"%s ch=%d addr=\" TARGET_FMT_plx \"\\n\", __func__, c, addr));\n\n\tcpu_physical_memory_write (addr,\n\n\t\t\t\t  (void *) &ctrl->channels[c].current_d, \n\n\t\t\t\t  sizeof ctrl->channels[c].current_d);\n\n}\n", "idx": 5825, "_split": "valid", "_hash": "a9632ef7bef96e9f3a7bd1acb25257db"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_ulpd_pm_init(MemoryRegion *system_memory,\n\n                target_phys_addr_t base,\n\n                struct omap_mpu_state_s *mpu)\n\n{\n\n    memory_region_init_io(&mpu->ulpd_pm_iomem, &omap_ulpd_pm_ops, mpu,\n\n                          \"omap-ulpd-pm\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &mpu->ulpd_pm_iomem);\n\n    omap_ulpd_pm_reset(mpu);\n\n}\n", "idx": 5827, "_split": "valid", "_hash": "47b3a0ca6ec51ae3a675b291a7b936f4"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void ahci_reset_port(AHCIState *s, int port)\n\n{\n\n    AHCIDevice *d = &s->dev[port];\n\n    AHCIPortRegs *pr = &d->port_regs;\n\n    IDEState *ide_state = &d->port.ifs[0];\n\n    int i;\n\n\n\n    DPRINTF(port, \"reset port\\n\");\n\n\n\n    ide_bus_reset(&d->port);\n\n    ide_state->ncq_queues = AHCI_MAX_CMDS;\n\n\n\n    pr->scr_stat = 0;\n\n    pr->scr_err = 0;\n\n    pr->scr_act = 0;\n\n    pr->tfdata = 0x7F;\n\n    pr->sig = 0xFFFFFFFF;\n\n    d->busy_slot = -1;\n\n    d->init_d2h_sent = false;\n\n\n\n    ide_state = &s->dev[port].port.ifs[0];\n\n    if (!ide_state->bs) {\n\n        return;\n\n    }\n\n\n\n    /* reset ncq queue */\n\n    for (i = 0; i < AHCI_MAX_CMDS; i++) {\n\n        NCQTransferState *ncq_tfs = &s->dev[port].ncq_tfs[i];\n\n        if (!ncq_tfs->used) {\n\n            continue;\n\n        }\n\n\n\n        if (ncq_tfs->aiocb) {\n\n            bdrv_aio_cancel(ncq_tfs->aiocb);\n\n            ncq_tfs->aiocb = NULL;\n\n        }\n\n\n\n        /* Maybe we just finished the request thanks to bdrv_aio_cancel() */\n\n        if (!ncq_tfs->used) {\n\n            continue;\n\n        }\n\n\n\n        qemu_sglist_destroy(&ncq_tfs->sglist);\n\n        ncq_tfs->used = 0;\n\n    }\n\n\n\n    s->dev[port].port_state = STATE_RUN;\n\n    if (!ide_state->bs) {\n\n        pr->sig = 0;\n\n        ide_state->status = SEEK_STAT | WRERR_STAT;\n\n    } else if (ide_state->drive_kind == IDE_CD) {\n\n        pr->sig = SATA_SIGNATURE_CDROM;\n\n        ide_state->lcyl = 0x14;\n\n        ide_state->hcyl = 0xeb;\n\n        DPRINTF(port, \"set lcyl = %d\\n\", ide_state->lcyl);\n\n        ide_state->status = SEEK_STAT | WRERR_STAT | READY_STAT;\n\n    } else {\n\n        pr->sig = SATA_SIGNATURE_DISK;\n\n        ide_state->status = SEEK_STAT | WRERR_STAT;\n\n    }\n\n\n\n    ide_state->error = 1;\n\n    ahci_init_d2h(d);\n\n}\n", "idx": 5829, "_split": "valid", "_hash": "ec933205b569072c259a08dcdc7a9b94"}
{"project": "qemu", "commit_id": "891fb2cd4592b6fe76106a69e0ca40efbf82726a", "target": 0, "func": "int usb_device_detach(USBDevice *dev)\n\n{\n\n    USBBus *bus = usb_bus_from_device(dev);\n\n    USBPort *port;\n\n\n\n    if (!dev->attached) {\n\n        error_report(\"Error: tried to detach unattached usb device %s\\n\",\n\n                dev->product_desc);\n\n        return -1;\n\n    }\n\n    dev->attached--;\n\n\n\n    QTAILQ_FOREACH(port, &bus->used, next) {\n\n        if (port->dev == dev)\n\n            break;\n\n    }\n\n    assert(port != NULL);\n\n\n\n    QTAILQ_REMOVE(&bus->used, port, next);\n\n    bus->nused--;\n\n\n\n    usb_attach(port, NULL);\n\n\n\n    QTAILQ_INSERT_TAIL(&bus->free, port, next);\n\n    bus->nfree++;\n\n    return 0;\n\n}\n", "idx": 5831, "_split": "valid", "_hash": "02b0cb55e7885a1c30b47ad05874bb7e"}
{"project": "qemu", "commit_id": "ddcb73b7782cb6104479503faea04cc224f982b5", "target": 1, "func": "e1000_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n\n{\n\n    E1000State *s = qemu_get_nic_opaque(nc);\n\n    struct e1000_rx_desc desc;\n\n    dma_addr_t base;\n\n    unsigned int n, rdt;\n\n    uint32_t rdh_start;\n\n    uint16_t vlan_special = 0;\n\n    uint8_t vlan_status = 0, vlan_offset = 0;\n\n    uint8_t min_buf[MIN_BUF_SIZE];\n\n    size_t desc_offset;\n\n    size_t desc_size;\n\n    size_t total_size;\n\n\n\n    if (!(s->mac_reg[RCTL] & E1000_RCTL_EN))\n\n        return -1;\n\n\n\n    /* Pad to minimum Ethernet frame length */\n\n    if (size < sizeof(min_buf)) {\n\n        memcpy(min_buf, buf, size);\n\n        memset(&min_buf[size], 0, sizeof(min_buf) - size);\n\n        buf = min_buf;\n\n        size = sizeof(min_buf);\n\n    }\n\n\n\n    /* Discard oversized packets if !LPE and !SBP. */\n\n    if ((size > MAXIMUM_ETHERNET_LPE_SIZE ||\n\n        (size > MAXIMUM_ETHERNET_VLAN_SIZE\n\n        && !(s->mac_reg[RCTL] & E1000_RCTL_LPE)))\n\n        && !(s->mac_reg[RCTL] & E1000_RCTL_SBP)) {\n\n        return size;\n\n    }\n\n\n\n    if (!receive_filter(s, buf, size))\n\n        return size;\n\n\n\n    if (vlan_enabled(s) && is_vlan_packet(s, buf)) {\n\n        vlan_special = cpu_to_le16(be16_to_cpup((uint16_t *)(buf + 14)));\n\n        memmove((uint8_t *)buf + 4, buf, 12);\n\n        vlan_status = E1000_RXD_STAT_VP;\n\n        vlan_offset = 4;\n\n        size -= 4;\n\n    }\n\n\n\n    rdh_start = s->mac_reg[RDH];\n\n    desc_offset = 0;\n\n    total_size = size + fcs_len(s);\n\n    if (!e1000_has_rxbufs(s, total_size)) {\n\n            set_ics(s, 0, E1000_ICS_RXO);\n\n            return -1;\n\n    }\n\n    do {\n\n        desc_size = total_size - desc_offset;\n\n        if (desc_size > s->rxbuf_size) {\n\n            desc_size = s->rxbuf_size;\n\n        }\n\n        base = rx_desc_base(s) + sizeof(desc) * s->mac_reg[RDH];\n\n        pci_dma_read(&s->dev, base, &desc, sizeof(desc));\n\n        desc.special = vlan_special;\n\n        desc.status |= (vlan_status | E1000_RXD_STAT_DD);\n\n        if (desc.buffer_addr) {\n\n            if (desc_offset < size) {\n\n                size_t copy_size = size - desc_offset;\n\n                if (copy_size > s->rxbuf_size) {\n\n                    copy_size = s->rxbuf_size;\n\n                }\n\n                pci_dma_write(&s->dev, le64_to_cpu(desc.buffer_addr),\n\n                              buf + desc_offset + vlan_offset, copy_size);\n\n            }\n\n            desc_offset += desc_size;\n\n            desc.length = cpu_to_le16(desc_size);\n\n            if (desc_offset >= total_size) {\n\n                desc.status |= E1000_RXD_STAT_EOP | E1000_RXD_STAT_IXSM;\n\n            } else {\n\n                /* Guest zeroing out status is not a hardware requirement.\n\n                   Clear EOP in case guest didn't do it. */\n\n                desc.status &= ~E1000_RXD_STAT_EOP;\n\n            }\n\n        } else { // as per intel docs; skip descriptors with null buf addr\n\n            DBGOUT(RX, \"Null RX descriptor!!\\n\");\n\n        }\n\n        pci_dma_write(&s->dev, base, &desc, sizeof(desc));\n\n\n\n        if (++s->mac_reg[RDH] * sizeof(desc) >= s->mac_reg[RDLEN])\n\n            s->mac_reg[RDH] = 0;\n\n        /* see comment in start_xmit; same here */\n\n        if (s->mac_reg[RDH] == rdh_start) {\n\n            DBGOUT(RXERR, \"RDH wraparound @%x, RDT %x, RDLEN %x\\n\",\n\n                   rdh_start, s->mac_reg[RDT], s->mac_reg[RDLEN]);\n\n            set_ics(s, 0, E1000_ICS_RXO);\n\n            return -1;\n\n        }\n\n    } while (desc_offset < total_size);\n\n\n\n    s->mac_reg[GPRC]++;\n\n    s->mac_reg[TPR]++;\n\n    /* TOR - Total Octets Received:\n\n     * This register includes bytes received in a packet from the <Destination\n\n     * Address> field through the <CRC> field, inclusively.\n\n     */\n\n    n = s->mac_reg[TORL] + size + /* Always include FCS length. */ 4;\n\n    if (n < s->mac_reg[TORL])\n\n        s->mac_reg[TORH]++;\n\n    s->mac_reg[TORL] = n;\n\n\n\n    n = E1000_ICS_RXT0;\n\n    if ((rdt = s->mac_reg[RDT]) < s->mac_reg[RDH])\n\n        rdt += s->mac_reg[RDLEN] / sizeof(desc);\n\n    if (((rdt - s->mac_reg[RDH]) * sizeof(desc)) <= s->mac_reg[RDLEN] >>\n\n        s->rxbuf_min_shift)\n\n        n |= E1000_ICS_RXDMT0;\n\n\n\n    set_ics(s, 0, n);\n\n\n\n    return size;\n\n}\n", "idx": 5852, "_split": "valid", "_hash": "ce4b9f0ebc816c25819f1a06aa4990ba"}
{"project": "qemu", "commit_id": "09aaa1602f9381c0e0fb539390b1793e51bdfc7b", "target": 1, "func": "int select_watchdog(const char *p)\n\n{\n\n    WatchdogTimerModel *model;\n\n\n\n    if (watchdog) {\n\n        fprintf(stderr,\n\n                 \"qemu: only one watchdog option may be given\\n\");\n\n        return 1;\n\n    }\n\n\n\n    /* -watchdog ? lists available devices and exits cleanly. */\n\n    if (strcmp(p, \"?\") == 0) {\n\n        LIST_FOREACH(model, &watchdog_list, entry) {\n\n            fprintf(stderr, \"\\t%s\\t%s\\n\",\n\n                     model->wdt_name, model->wdt_description);\n\n        }\n\n        return 2;\n\n    }\n\n\n\n    LIST_FOREACH(model, &watchdog_list, entry) {\n\n        if (strcasecmp(model->wdt_name, p) == 0) {\n\n            watchdog = model;\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    fprintf(stderr, \"Unknown -watchdog device. Supported devices are:\\n\");\n\n    LIST_FOREACH(model, &watchdog_list, entry) {\n\n        fprintf(stderr, \"\\t%s\\t%s\\n\",\n\n                 model->wdt_name, model->wdt_description);\n\n    }\n\n    return 1;\n\n}\n", "idx": 5867, "_split": "valid", "_hash": "878fd6ee2b6faaf934488a5bf5adf56d"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void mainstone_common_init(MemoryRegion *address_space_mem,\n\n                ram_addr_t ram_size,\n\n                const char *kernel_filename,\n\n                const char *kernel_cmdline, const char *initrd_filename,\n\n                const char *cpu_model, enum mainstone_model_e model, int arm_id)\n\n{\n\n    uint32_t sector_len = 256 * 1024;\n\n    target_phys_addr_t mainstone_flash_base[] = { MST_FLASH_0, MST_FLASH_1 };\n\n    PXA2xxState *mpu;\n\n    DeviceState *mst_irq;\n\n    DriveInfo *dinfo;\n\n    int i;\n\n    int be;\n\n    MemoryRegion *rom = g_new(MemoryRegion, 1);\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"pxa270-c5\";\n\n\n\n    /* Setup CPU & memory */\n\n    mpu = pxa270_init(address_space_mem, mainstone_binfo.ram_size, cpu_model);\n\n    memory_region_init_ram(rom, \"mainstone.rom\", MAINSTONE_ROM);\n\n    vmstate_register_ram_global(rom);\n\n    memory_region_set_readonly(rom, true);\n\n    memory_region_add_subregion(address_space_mem, 0, rom);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    /* There are two 32MiB flash devices on the board */\n\n    for (i = 0; i < 2; i ++) {\n\n        dinfo = drive_get(IF_PFLASH, 0, i);\n\n        if (!dinfo) {\n\n            fprintf(stderr, \"Two flash images must be given with the \"\n\n                    \"'pflash' parameter\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        if (!pflash_cfi01_register(mainstone_flash_base[i], NULL,\n\n                                   i ? \"mainstone.flash1\" : \"mainstone.flash0\",\n\n                                   MAINSTONE_FLASH,\n\n                                   dinfo->bdrv, sector_len,\n\n                                   MAINSTONE_FLASH / sector_len, 4, 0, 0, 0, 0,\n\n                                   be)) {\n\n            fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    mst_irq = sysbus_create_simple(\"mainstone-fpga\", MST_FPGA_PHYS,\n\n                    qdev_get_gpio_in(mpu->gpio, 0));\n\n\n\n    /* setup keypad */\n\n    printf(\"map addr %p\\n\", &map);\n\n    pxa27x_register_keypad(mpu->kp, map, 0xe0);\n\n\n\n    /* MMC/SD host */\n\n    pxa2xx_mmci_handlers(mpu->mmc, NULL, qdev_get_gpio_in(mst_irq, MMC_IRQ));\n\n\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[0],\n\n            qdev_get_gpio_in(mst_irq, S0_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S0_CD_IRQ));\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[1],\n\n            qdev_get_gpio_in(mst_irq, S1_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S1_CD_IRQ));\n\n\n\n    smc91c111_init(&nd_table[0], MST_ETH_PHYS,\n\n                    qdev_get_gpio_in(mst_irq, ETHERNET_IRQ));\n\n\n\n    mainstone_binfo.kernel_filename = kernel_filename;\n\n    mainstone_binfo.kernel_cmdline = kernel_cmdline;\n\n    mainstone_binfo.initrd_filename = initrd_filename;\n\n    mainstone_binfo.board_id = arm_id;\n\n    arm_load_kernel(mpu->cpu, &mainstone_binfo);\n\n}\n", "idx": 5874, "_split": "valid", "_hash": "5f5784ca8b248f3b3e2efa3c42d83a11"}
{"project": "qemu", "commit_id": "f7b9358e2cf12a5eb07f5f9301fdadc932f9ee03", "target": 0, "func": "static void gicv3_cpuif_el_change_hook(ARMCPU *cpu, void *opaque)\n\n{\n\n    /* Do nothing for now. */\n\n}\n", "idx": 5880, "_split": "valid", "_hash": "3a32020a76b6b30d15b86bd9a91ad797"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static ssize_t gem_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n\n{\n\n    unsigned    desc[2];\n\n    target_phys_addr_t packet_desc_addr, last_desc_addr;\n\n    GemState *s;\n\n    unsigned   rxbufsize, bytes_to_copy;\n\n    unsigned   rxbuf_offset;\n\n    uint8_t    rxbuf[2048];\n\n    uint8_t   *rxbuf_ptr;\n\n\n\n    s = DO_UPCAST(NICState, nc, nc)->opaque;\n\n\n\n    /* Do nothing if receive is not enabled. */\n\n    if (!(s->regs[GEM_NWCTRL] & GEM_NWCTRL_RXENA)) {\n\n        return -1;\n\n    }\n\n\n\n    /* Is this destination MAC address \"for us\" ? */\n\n    if (gem_mac_address_filter(s, buf) == GEM_RX_REJECT) {\n\n        return -1;\n\n    }\n\n\n\n    /* Discard packets with receive length error enabled ? */\n\n    if (s->regs[GEM_NWCFG] & GEM_NWCFG_LERR_DISC) {\n\n        unsigned type_len;\n\n\n\n        /* Fish the ethertype / length field out of the RX packet */\n\n        type_len = buf[12] << 8 | buf[13];\n\n        /* It is a length field, not an ethertype */\n\n        if (type_len < 0x600) {\n\n            if (size < type_len) {\n\n                /* discard */\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n\n\n    /*\n\n     * Determine configured receive buffer offset (probably 0)\n\n     */\n\n    rxbuf_offset = (s->regs[GEM_NWCFG] & GEM_NWCFG_BUFF_OFST_M) >>\n\n                   GEM_NWCFG_BUFF_OFST_S;\n\n\n\n    /* The configure size of each receive buffer.  Determines how many\n\n     * buffers needed to hold this packet.\n\n     */\n\n    rxbufsize = ((s->regs[GEM_DMACFG] & GEM_DMACFG_RBUFSZ_M) >>\n\n                 GEM_DMACFG_RBUFSZ_S) * GEM_DMACFG_RBUFSZ_MUL;\n\n    bytes_to_copy = size;\n\n\n\n    /* Strip of FCS field ? (usually yes) */\n\n    if (s->regs[GEM_NWCFG] & GEM_NWCFG_STRIP_FCS) {\n\n        rxbuf_ptr = (void *)buf;\n\n    } else {\n\n        unsigned crc_val;\n\n        int      crc_offset;\n\n\n\n        /* The application wants the FCS field, which QEMU does not provide.\n\n         * We must try and caclculate one.\n\n         */\n\n\n\n        memcpy(rxbuf, buf, size);\n\n        memset(rxbuf + size, 0, sizeof(rxbuf) - size);\n\n        rxbuf_ptr = rxbuf;\n\n        crc_val = cpu_to_le32(crc32(0, rxbuf, MAX(size, 60)));\n\n        if (size < 60) {\n\n            crc_offset = 60;\n\n        } else {\n\n            crc_offset = size;\n\n        }\n\n        memcpy(rxbuf + crc_offset, &crc_val, sizeof(crc_val));\n\n\n\n        bytes_to_copy += 4;\n\n        size += 4;\n\n    }\n\n\n\n    /* Pad to minimum length */\n\n    if (size < 64) {\n\n        size = 64;\n\n    }\n\n\n\n    DB_PRINT(\"config bufsize: %d packet size: %ld\\n\", rxbufsize, size);\n\n\n\n    packet_desc_addr = s->rx_desc_addr;\n\n    while (1) {\n\n        DB_PRINT(\"read descriptor 0x%x\\n\", packet_desc_addr);\n\n        /* read current descriptor */\n\n        cpu_physical_memory_read(packet_desc_addr,\n\n                                 (uint8_t *)&desc[0], sizeof(desc));\n\n\n\n        /* Descriptor owned by software ? */\n\n        if (rx_desc_get_ownership(desc) == 1) {\n\n            DB_PRINT(\"descriptor 0x%x owned by sw.\\n\", packet_desc_addr);\n\n            s->regs[GEM_RXSTATUS] |= GEM_RXSTATUS_NOBUF;\n\n            /* Handle interrupt consequences */\n\n            gem_update_int_status(s);\n\n            return -1;\n\n        }\n\n\n\n        DB_PRINT(\"copy %d bytes to 0x%x\\n\", MIN(bytes_to_copy, rxbufsize),\n\n                rx_desc_get_buffer(desc));\n\n\n\n        /*\n\n         * Let's have QEMU lend a helping hand.\n\n         */\n\n        if (rx_desc_get_buffer(desc) == 0) {\n\n            DB_PRINT(\"Invalid RX buffer (NULL) for descriptor 0x%x\\n\",\n\n                       packet_desc_addr);\n\n            break;\n\n        }\n\n\n\n        /* Copy packet data to emulated DMA buffer */\n\n        cpu_physical_memory_write(rx_desc_get_buffer(desc) + rxbuf_offset,\n\n                                  rxbuf_ptr, MIN(bytes_to_copy, rxbufsize));\n\n        bytes_to_copy -= MIN(bytes_to_copy, rxbufsize);\n\n        rxbuf_ptr += MIN(bytes_to_copy, rxbufsize);\n\n        if (bytes_to_copy == 0) {\n\n            break;\n\n        }\n\n\n\n        /* Next descriptor */\n\n        if (rx_desc_get_wrap(desc)) {\n\n            packet_desc_addr = s->regs[GEM_RXQBASE];\n\n        } else {\n\n            packet_desc_addr += 8;\n\n        }\n\n    }\n\n\n\n    DB_PRINT(\"set length: %ld, EOF on descriptor 0x%x\\n\", size,\n\n            (unsigned)packet_desc_addr);\n\n\n\n    /* Update last descriptor with EOF and total length */\n\n    rx_desc_set_eof(desc);\n\n    rx_desc_set_length(desc, size);\n\n    cpu_physical_memory_write(packet_desc_addr,\n\n                              (uint8_t *)&desc[0], sizeof(desc));\n\n\n\n    /* Advance RX packet descriptor Q */\n\n    last_desc_addr = packet_desc_addr;\n\n    packet_desc_addr = s->rx_desc_addr;\n\n    s->rx_desc_addr = last_desc_addr;\n\n    if (rx_desc_get_wrap(desc)) {\n\n        s->rx_desc_addr = s->regs[GEM_RXQBASE];\n\n    } else {\n\n        s->rx_desc_addr += 8;\n\n    }\n\n\n\n    DB_PRINT(\"set SOF, OWN on descriptor 0x%08x\\n\", packet_desc_addr);\n\n\n\n    /* Count it */\n\n    gem_receive_updatestats(s, buf, size);\n\n\n\n    /* Update first descriptor (which could also be the last) */\n\n    /* read descriptor */\n\n    cpu_physical_memory_read(packet_desc_addr,\n\n                             (uint8_t *)&desc[0], sizeof(desc));\n\n    rx_desc_set_sof(desc);\n\n    rx_desc_set_ownership(desc);\n\n    cpu_physical_memory_write(packet_desc_addr,\n\n                              (uint8_t *)&desc[0], sizeof(desc));\n\n\n\n    s->regs[GEM_RXSTATUS] |= GEM_RXSTATUS_FRMRCVD;\n\n\n\n    /* Handle interrupt consequences */\n\n    gem_update_int_status(s);\n\n\n\n    return size;\n\n}\n", "idx": 5887, "_split": "valid", "_hash": "d699f7dcc6e6606923b044eddee65efe"}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "static char *vnc_socket_remote_addr(const char *format, int fd) {\n\n    struct sockaddr_storage sa;\n\n    socklen_t salen;\n\n\n\n    salen = sizeof(sa);\n\n    if (getpeername(fd, (struct sockaddr*)&sa, &salen) < 0)\n\n        return NULL;\n\n\n\n    return addr_to_string(format, &sa, salen);\n\n}\n", "idx": 5913, "_split": "valid", "_hash": "0193d8a318373423427f710e5b98bbf9"}
{"project": "qemu", "commit_id": "e9db8ff38e539260a2cb5a7918d1155b7d92a264", "target": 1, "func": "static int qemu_gluster_open(BlockDriverState *bs,  QDict *options,\n\n                             int bdrv_flags, Error **errp)\n\n{\n\n    BDRVGlusterState *s = bs->opaque;\n\n    int open_flags = 0;\n\n    int ret = 0;\n\n    BlockdevOptionsGluster *gconf = NULL;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    const char *filename;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    filename = qemu_opt_get(opts, GLUSTER_OPT_FILENAME);\n\n\n\n    s->debug_level = qemu_opt_get_number(opts, GLUSTER_OPT_DEBUG,\n\n                                         GLUSTER_DEBUG_DEFAULT);\n\n    if (s->debug_level < 0) {\n\n        s->debug_level = 0;\n\n    } else if (s->debug_level > GLUSTER_DEBUG_MAX) {\n\n        s->debug_level = GLUSTER_DEBUG_MAX;\n\n    }\n\n\n\n    gconf = g_new0(BlockdevOptionsGluster, 1);\n\n    gconf->debug_level = s->debug_level;\n\n    gconf->has_debug_level = true;\n\n    s->glfs = qemu_gluster_init(gconf, filename, options, errp);\n\n    if (!s->glfs) {\n\n        ret = -errno;\n\n        goto out;\n\n    }\n\n\n\n#ifdef CONFIG_GLUSTERFS_XLATOR_OPT\n\n    /* Without this, if fsync fails for a recoverable reason (for instance,\n\n     * ENOSPC), gluster will dump its cache, preventing retries.  This means\n\n     * almost certain data loss.  Not all gluster versions support the\n\n     * 'resync-failed-syncs-after-fsync' key value, but there is no way to\n\n     * discover during runtime if it is supported (this api returns success for\n\n     * unknown key/value pairs) */\n\n    ret = glfs_set_xlator_option(s->glfs, \"*-write-behind\",\n\n                                          \"resync-failed-syncs-after-fsync\",\n\n                                          \"on\");\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, errno, \"Unable to set xlator key/value pair\");\n\n        ret = -errno;\n\n        goto out;\n\n    }\n\n#endif\n\n\n\n    qemu_gluster_parse_flags(bdrv_flags, &open_flags);\n\n\n\n    s->fd = glfs_open(s->glfs, gconf->path, open_flags);\n\n    if (!s->fd) {\n\n        ret = -errno;\n\n    }\n\n\n\n    s->supports_seek_data = qemu_gluster_test_seek(s->fd);\n\n\n\nout:\n\n    qemu_opts_del(opts);\n\n    qapi_free_BlockdevOptionsGluster(gconf);\n\n    if (!ret) {\n\n        return ret;\n\n    }\n\n    if (s->fd) {\n\n        glfs_close(s->fd);\n\n    }\n\n    if (s->glfs) {\n\n        glfs_fini(s->glfs);\n\n    }\n\n    return ret;\n\n}\n", "idx": 5915, "_split": "valid", "_hash": "f7df30b21f9f3d8c31f0a02b36cd2c0c"}
{"project": "qemu", "commit_id": "2e29bd04786003561303dcad940b38afe790fb9b", "target": 1, "func": "static uint32_t pci_unin_main_config_readl (void *opaque,\n\n                                            target_phys_addr_t addr)\n\n{\n\n    UNINState *s = opaque;\n\n    uint32_t val;\n\n\n\n    val = s->config_reg;\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    val = bswap32(val);\n\n#endif\n\n    UNIN_DPRINTF(\"config_readl addr \" TARGET_FMT_plx \" val %x\\n\", addr, val);\n\n\n\n    return val;\n\n}\n", "idx": 5928, "_split": "valid", "_hash": "edf402d4b89bf9d5f91cc83c53a9bce9"}
{"project": "qemu", "commit_id": "0827b9e97d443781a17a21c64695940675aa1f8a", "target": 1, "func": "static int ram_save_init_globals(void)\n\n{\n\n    int64_t ram_bitmap_pages; /* Size of bitmap in pages, including gaps */\n\n\n\n    dirty_rate_high_cnt = 0;\n\n    bitmap_sync_count = 0;\n\n    migration_bitmap_sync_init();\n\n    qemu_mutex_init(&migration_bitmap_mutex);\n\n\n\n    if (migrate_use_xbzrle()) {\n\n        XBZRLE_cache_lock();\n\n        ZERO_TARGET_PAGE = g_malloc0(TARGET_PAGE_SIZE);\n\n        XBZRLE.cache = cache_init(migrate_xbzrle_cache_size() /\n\n                                  TARGET_PAGE_SIZE,\n\n                                  TARGET_PAGE_SIZE);\n\n        if (!XBZRLE.cache) {\n\n            XBZRLE_cache_unlock();\n\n            error_report(\"Error creating cache\");\n\n            return -1;\n\n        }\n\n        XBZRLE_cache_unlock();\n\n\n\n        /* We prefer not to abort if there is no memory */\n\n        XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE);\n\n        if (!XBZRLE.encoded_buf) {\n\n            error_report(\"Error allocating encoded_buf\");\n\n            return -1;\n\n        }\n\n\n\n        XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE);\n\n        if (!XBZRLE.current_buf) {\n\n            error_report(\"Error allocating current_buf\");\n\n            g_free(XBZRLE.encoded_buf);\n\n            XBZRLE.encoded_buf = NULL;\n\n            return -1;\n\n        }\n\n\n\n        acct_clear();\n\n    }\n\n\n\n    /* For memory_global_dirty_log_start below.  */\n\n    qemu_mutex_lock_iothread();\n\n\n\n    qemu_mutex_lock_ramlist();\n\n    rcu_read_lock();\n\n    bytes_transferred = 0;\n\n    reset_ram_globals();\n\n\n\n    ram_bitmap_pages = last_ram_offset() >> TARGET_PAGE_BITS;\n\n    migration_bitmap_rcu = g_new0(struct BitmapRcu, 1);\n\n    migration_bitmap_rcu->bmap = bitmap_new(ram_bitmap_pages);\n\n    bitmap_set(migration_bitmap_rcu->bmap, 0, ram_bitmap_pages);\n\n\n\n    if (migrate_postcopy_ram()) {\n\n        migration_bitmap_rcu->unsentmap = bitmap_new(ram_bitmap_pages);\n\n        bitmap_set(migration_bitmap_rcu->unsentmap, 0, ram_bitmap_pages);\n\n    }\n\n\n\n    /*\n\n     * Count the total number of pages used by ram blocks not including any\n\n     * gaps due to alignment or unplugs.\n\n     */\n\n    migration_dirty_pages = ram_bytes_total() >> TARGET_PAGE_BITS;\n\n\n\n    memory_global_dirty_log_start();\n\n    migration_bitmap_sync();\n\n    qemu_mutex_unlock_ramlist();\n\n    qemu_mutex_unlock_iothread();\n\n    rcu_read_unlock();\n\n\n\n    return 0;\n\n}\n", "idx": 5934, "_split": "valid", "_hash": "f0226c2eb652f03b465d9428260317eb"}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_dma_read_prp(NvmeCtrl *n, uint8_t *ptr, uint32_t len,\n\n    uint64_t prp1, uint64_t prp2)\n\n{\n\n    QEMUSGList qsg;\n\n    QEMUIOVector iov;\n\n    uint16_t status = NVME_SUCCESS;\n\n\n\n    if (nvme_map_prp(&qsg, &iov, prp1, prp2, len, n)) {\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    if (qsg.nsg > 0) {\n\n        if (dma_buf_read(ptr, len, &qsg)) {\n\n            status = NVME_INVALID_FIELD | NVME_DNR;\n\n        }\n\n        qemu_sglist_destroy(&qsg);\n\n    } else {\n\n        if (qemu_iovec_to_buf(&iov, 0, ptr, len) != len) {\n\n            status = NVME_INVALID_FIELD | NVME_DNR;\n\n        }\n\n        qemu_iovec_destroy(&iov);\n\n    }\n\n    return status;\n\n}\n", "idx": 5937, "_split": "valid", "_hash": "eb38df22bcbea86b5de276acfbaf8e05"}
{"project": "qemu", "commit_id": "ad27390c85c50df402c7ec0d3864fc43e6559fb3", "target": 1, "func": "static int check_refcounts_l1(BlockDriverState *bs,\n\n                              BdrvCheckResult *res,\n\n                              uint16_t *refcount_table,\n\n                              int64_t refcount_table_size,\n\n                              int64_t l1_table_offset, int l1_size,\n\n                              int flags)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l1_table, l2_offset, l1_size2;\n\n    int i, ret;\n\n\n\n    l1_size2 = l1_size * sizeof(uint64_t);\n\n\n\n    /* Mark L1 table as used */\n\n    inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n        l1_table_offset, l1_size2);\n\n\n\n    /* Read L1 table entries from disk */\n\n    if (l1_size2 == 0) {\n\n        l1_table = NULL;\n\n    } else {\n\n        l1_table = g_try_malloc(l1_size2);\n\n        if (l1_table == NULL) {\n\n            ret = -ENOMEM;\n\n            goto fail;\n\n        }\n\n        if (bdrv_pread(bs->file, l1_table_offset,\n\n                       l1_table, l1_size2) != l1_size2)\n\n            goto fail;\n\n        for(i = 0;i < l1_size; i++)\n\n            be64_to_cpus(&l1_table[i]);\n\n    }\n\n\n\n    /* Do the actual checks */\n\n    for(i = 0; i < l1_size; i++) {\n\n        l2_offset = l1_table[i];\n\n        if (l2_offset) {\n\n            /* Mark L2 table as used */\n\n            l2_offset &= L1E_OFFSET_MASK;\n\n            inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                l2_offset, s->cluster_size);\n\n\n\n            /* L2 tables are cluster aligned */\n\n            if (offset_into_cluster(s, l2_offset)) {\n\n                fprintf(stderr, \"ERROR l2_offset=%\" PRIx64 \": Table is not \"\n\n                    \"cluster aligned; L1 entry corrupted\\n\", l2_offset);\n\n                res->corruptions++;\n\n            }\n\n\n\n            /* Process and check L2 entries */\n\n            ret = check_refcounts_l2(bs, res, refcount_table,\n\n                                     refcount_table_size, l2_offset, flags);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n    g_free(l1_table);\n\n    return 0;\n\n\n\nfail:\n\n    fprintf(stderr, \"ERROR: I/O error in check_refcounts_l1\\n\");\n\n    res->check_errors++;\n\n    g_free(l1_table);\n\n    return -EIO;\n\n}\n", "idx": 5967, "_split": "valid", "_hash": "a49f25fe54cf4f7f7d1cbf44367942f3"}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "DeviceState *i2c_create_slave(i2c_bus *bus, const char *name, uint8_t addr)\n\n{\n\n    DeviceState *dev;\n\n\n\n    dev = qdev_create(&bus->qbus, name);\n\n    qdev_prop_set_uint8(dev, \"address\", addr);\n\n    qdev_init(dev);\n\n    return dev;\n\n}\n", "idx": 5970, "_split": "valid", "_hash": "2770a0ea83cc57ded490e4f5c79fe849"}
{"project": "qemu", "commit_id": "92335a0d4021a3b44ccc88c9fc6c0fd2113f1882", "target": 1, "func": "static void strongarm_gpio_write(void *opaque, hwaddr offset,\n\n                                 uint64_t value, unsigned size)\n\n{\n\n    StrongARMGPIOInfo *s = opaque;\n\n\n\n    switch (offset) {\n\n    case GPDR:        /* GPIO Pin-Direction registers */\n\n        s->dir = value;\n\n        strongarm_gpio_handler_update(s);\n\n        break;\n\n\n\n    case GPSR:        /* GPIO Pin-Output Set registers */\n\n        s->olevel |= value;\n\n        strongarm_gpio_handler_update(s);\n\n        s->gpsr = value;\n\n        break;\n\n\n\n    case GPCR:        /* GPIO Pin-Output Clear registers */\n\n        s->olevel &= ~value;\n\n        strongarm_gpio_handler_update(s);\n\n        break;\n\n\n\n    case GRER:        /* GPIO Rising-Edge Detect Enable registers */\n\n        s->rising = value;\n\n        break;\n\n\n\n    case GFER:        /* GPIO Falling-Edge Detect Enable registers */\n\n        s->falling = value;\n\n        break;\n\n\n\n    case GAFR:        /* GPIO Alternate Function registers */\n\n        s->gafr = value;\n\n        break;\n\n\n\n    case GEDR:        /* GPIO Edge Detect Status registers */\n\n        s->status &= ~value;\n\n        strongarm_gpio_irq_update(s);\n\n        break;\n\n\n\n    default:\n\n        printf(\"%s: Bad offset 0x\" TARGET_FMT_plx \"\\n\", __func__, offset);\n\n    }\n\n}\n", "idx": 5983, "_split": "valid", "_hash": "eb082ecc690ba1ce20945a74e416f719"}
{"project": "qemu", "commit_id": "b7f26e523914b982a1c1bfa8295f77ff9787c33c", "target": 1, "func": "static void gen_bitops (DisasContext *ctx, uint32_t opc, int rt,\n\n                        int rs, int lsb, int msb)\n\n{\n\n    TCGv t0 = tcg_temp_new();\n\n    TCGv t1 = tcg_temp_new();\n\n\n\n    gen_load_gpr(t1, rs);\n\n    switch (opc) {\n\n    case OPC_EXT:\n\n        if (lsb + msb > 31)\n\n            goto fail;\n\n        tcg_gen_shri_tl(t0, t1, lsb);\n\n        if (msb != 31) {\n\n            tcg_gen_andi_tl(t0, t0, (1 << (msb + 1)) - 1);\n\n        } else {\n\n            tcg_gen_ext32s_tl(t0, t0);\n\n        }\n\n        break;\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_DEXTM:\n\n        tcg_gen_shri_tl(t0, t1, lsb);\n\n        if (msb != 31) {\n\n            tcg_gen_andi_tl(t0, t0, (1ULL << (msb + 1 + 32)) - 1);\n\n        }\n\n        break;\n\n    case OPC_DEXTU:\n\n        tcg_gen_shri_tl(t0, t1, lsb + 32);\n\n        tcg_gen_andi_tl(t0, t0, (1ULL << (msb + 1)) - 1);\n\n        break;\n\n    case OPC_DEXT:\n\n        tcg_gen_shri_tl(t0, t1, lsb);\n\n        tcg_gen_andi_tl(t0, t0, (1ULL << (msb + 1)) - 1);\n\n        break;\n\n#endif\n\n    case OPC_INS:\n\n        if (lsb > msb)\n\n            goto fail;\n\n        gen_load_gpr(t0, rt);\n\n        tcg_gen_deposit_tl(t0, t0, t1, lsb, msb - lsb + 1);\n\n        tcg_gen_ext32s_tl(t0, t0);\n\n        break;\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_DINSM:\n\n        gen_load_gpr(t0, rt);\n\n        tcg_gen_deposit_tl(t0, t0, t1, lsb, msb + 32 - lsb + 1);\n\n        break;\n\n    case OPC_DINSU:\n\n        gen_load_gpr(t0, rt);\n\n        tcg_gen_deposit_tl(t0, t0, t1, lsb + 32, msb - lsb + 1);\n\n        break;\n\n    case OPC_DINS:\n\n        gen_load_gpr(t0, rt);\n\n        tcg_gen_deposit_tl(t0, t0, t1, lsb, msb - lsb + 1);\n\n        break;\n\n#endif\n\n    default:\n\nfail:\n\n        MIPS_INVAL(\"bitops\");\n\n        generate_exception(ctx, EXCP_RI);\n\n        tcg_temp_free(t0);\n\n        tcg_temp_free(t1);\n\n        return;\n\n    }\n\n    gen_store_gpr(t0, rt);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n", "idx": 5995, "_split": "valid", "_hash": "dee954b901c6f28e43aa3aa55f1af6e4"}
{"project": "qemu", "commit_id": "e3c9d76acc984218264bbc6435b0c09f959ed9b8", "target": 1, "func": "static int vhost_scsi_exit(DeviceState *qdev)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);\n\n    VHostSCSI *s = VHOST_SCSI(qdev);\n\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);\n\n\n\n    migrate_del_blocker(s->migration_blocker);\n\n    error_free(s->migration_blocker);\n\n\n\n    /* This will stop vhost backend. */\n\n    vhost_scsi_set_status(vdev, 0);\n\n\n\n    g_free(s->dev.vqs);\n\n    return virtio_scsi_common_exit(vs);\n\n}\n", "idx": 5996, "_split": "valid", "_hash": "988440ba17c5a8d3756451d387de6efb"}
{"project": "qemu", "commit_id": "3604a76fea6ff37738d4a8f596be38407be74a83", "target": 1, "func": "static void dec_wcsr(DisasContext *dc)\n\n{\n\n    int no;\n\n\n\n    LOG_DIS(\"wcsr r%d, %d\\n\", dc->r1, dc->csr);\n\n\n\n    switch (dc->csr) {\n\n    case CSR_IE:\n\n        tcg_gen_mov_tl(cpu_ie, cpu_R[dc->r1]);\n\n        tcg_gen_movi_tl(cpu_pc, dc->pc + 4);\n\n        dc->is_jmp = DISAS_UPDATE;\n\n        break;\n\n    case CSR_IM:\n\n        /* mark as an io operation because it could cause an interrupt */\n\n        if (use_icount) {\n\n            gen_io_start();\n\n        }\n\n        gen_helper_wcsr_im(cpu_env, cpu_R[dc->r1]);\n\n        tcg_gen_movi_tl(cpu_pc, dc->pc + 4);\n\n        if (use_icount) {\n\n            gen_io_end();\n\n        }\n\n        dc->is_jmp = DISAS_UPDATE;\n\n        break;\n\n    case CSR_IP:\n\n        /* mark as an io operation because it could cause an interrupt */\n\n        if (use_icount) {\n\n            gen_io_start();\n\n        }\n\n        gen_helper_wcsr_ip(cpu_env, cpu_R[dc->r1]);\n\n        tcg_gen_movi_tl(cpu_pc, dc->pc + 4);\n\n        if (use_icount) {\n\n            gen_io_end();\n\n        }\n\n        dc->is_jmp = DISAS_UPDATE;\n\n        break;\n\n    case CSR_ICC:\n\n        /* TODO */\n\n        break;\n\n    case CSR_DCC:\n\n        /* TODO */\n\n        break;\n\n    case CSR_EBA:\n\n        tcg_gen_mov_tl(cpu_eba, cpu_R[dc->r1]);\n\n        break;\n\n    case CSR_DEBA:\n\n        tcg_gen_mov_tl(cpu_deba, cpu_R[dc->r1]);\n\n        break;\n\n    case CSR_JTX:\n\n        gen_helper_wcsr_jtx(cpu_env, cpu_R[dc->r1]);\n\n        break;\n\n    case CSR_JRX:\n\n        gen_helper_wcsr_jrx(cpu_env, cpu_R[dc->r1]);\n\n        break;\n\n    case CSR_DC:\n\n        tcg_gen_mov_tl(cpu_dc, cpu_R[dc->r1]);\n\n        break;\n\n    case CSR_BP0:\n\n    case CSR_BP1:\n\n    case CSR_BP2:\n\n    case CSR_BP3:\n\n        no = dc->csr - CSR_BP0;\n\n        if (dc->env->num_bps <= no) {\n\n            cpu_abort(dc->env, \"breakpoint #%i is not available\\n\", no);\n\n        }\n\n        tcg_gen_mov_tl(cpu_bp[no], cpu_R[dc->r1]);\n\n        break;\n\n    case CSR_WP0:\n\n    case CSR_WP1:\n\n    case CSR_WP2:\n\n    case CSR_WP3:\n\n        no = dc->csr - CSR_WP0;\n\n        if (dc->env->num_wps <= no) {\n\n            cpu_abort(dc->env, \"watchpoint #%i is not available\\n\", no);\n\n        }\n\n        tcg_gen_mov_tl(cpu_wp[no], cpu_R[dc->r1]);\n\n        break;\n\n    case CSR_CC:\n\n    case CSR_CFG:\n\n        cpu_abort(dc->env, \"invalid write access csr=%x\\n\", dc->csr);\n\n        break;\n\n    default:\n\n        cpu_abort(dc->env, \"write_csr unknown csr=%x\\n\", dc->csr);\n\n        break;\n\n    }\n\n}\n", "idx": 5999, "_split": "valid", "_hash": "f09ee3a8bd8da661be93b8baee32ec43"}
{"project": "qemu", "commit_id": "2d9907a3332888e43bc73fe9b98a32f8de662526", "target": 0, "func": "void pmac_format_nvram_partition (MacIONVRAMState *nvr, int len)\n\n{\n\n    unsigned int i;\n\n    uint32_t start = 0, end;\n\n    struct OpenBIOS_nvpart_v1 *part_header;\n\n\n\n    // OpenBIOS nvram variables\n\n    // Variable partition\n\n    part_header = (struct OpenBIOS_nvpart_v1 *)nvr->data;\n\n    part_header->signature = OPENBIOS_PART_SYSTEM;\n\n    pstrcpy(part_header->name, sizeof(part_header->name), \"system\");\n\n\n\n    end = start + sizeof(struct OpenBIOS_nvpart_v1);\n\n    for (i = 0; i < nb_prom_envs; i++)\n\n        end = OpenBIOS_set_var(nvr->data, end, prom_envs[i]);\n\n\n\n    // End marker\n\n    nvr->data[end++] = '\\0';\n\n\n\n    end = start + ((end - start + 15) & ~15);\n\n    /* XXX: OpenBIOS is not able to grow up a partition. Leave some space for\n\n       new variables. */\n\n    if (end < DEF_SYSTEM_SIZE)\n\n        end = DEF_SYSTEM_SIZE;\n\n    OpenBIOS_finish_partition(part_header, end - start);\n\n\n\n    // free partition\n\n    start = end;\n\n    part_header = (struct OpenBIOS_nvpart_v1 *)&nvr->data[start];\n\n    part_header->signature = OPENBIOS_PART_FREE;\n\n    pstrcpy(part_header->name, sizeof(part_header->name), \"free\");\n\n\n\n    end = len;\n\n    OpenBIOS_finish_partition(part_header, end - start);\n\n}\n", "idx": 6005, "_split": "valid", "_hash": "fc3cb0ac299798b309aac64e471529e1"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_slq(DisasContext *ctx)\n\n{\n\n    int l1 = gen_new_label();\n\n    TCGv t0 = tcg_temp_new();\n\n    TCGv t1 = tcg_temp_new();\n\n    tcg_gen_andi_tl(t1, cpu_gpr[rB(ctx->opcode)], 0x1F);\n\n    tcg_gen_shl_tl(t0, cpu_gpr[rS(ctx->opcode)], t1);\n\n    tcg_gen_subfi_tl(t1, 32, t1);\n\n    tcg_gen_shr_tl(t1, cpu_gpr[rS(ctx->opcode)], t1);\n\n    tcg_gen_or_tl(t1, t0, t1);\n\n    gen_store_spr(SPR_MQ, t1);\n\n    tcg_gen_andi_tl(t1, cpu_gpr[rB(ctx->opcode)], 0x20);\n\n    tcg_gen_mov_tl(cpu_gpr[rA(ctx->opcode)], t0);\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);\n\n    tcg_gen_movi_tl(cpu_gpr[rA(ctx->opcode)], 0);\n\n    gen_set_label(l1);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);\n\n}\n", "idx": 6012, "_split": "valid", "_hash": "bbdec93685dde00898f9a25b0f9c73f0"}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "vmxnet3_pop_rxc_descr(VMXNET3State *s, int qidx, uint32_t *descr_gen)\n\n{\n\n    uint8_t ring_gen;\n\n    struct Vmxnet3_RxCompDesc rxcd;\n\n\n\n    hwaddr daddr =\n\n        vmxnet3_ring_curr_cell_pa(&s->rxq_descr[qidx].comp_ring);\n\n\n\n    pci_dma_read(PCI_DEVICE(s), daddr,\n\n                 &rxcd, sizeof(struct Vmxnet3_RxCompDesc));\n\n\n\n    ring_gen = vmxnet3_ring_curr_gen(&s->rxq_descr[qidx].comp_ring);\n\n\n\n    if (rxcd.gen != ring_gen) {\n\n        *descr_gen = ring_gen;\n\n        vmxnet3_inc_rx_completion_counter(s, qidx);\n\n        return daddr;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6027, "_split": "valid", "_hash": "cd2f58dbd34bc2b3b1b420bd250d81ba"}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_madt(GArray *table_data, GArray *linker, AcpiCpuInfo *cpu)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(qdev_get_machine());\n\n    int madt_start = table_data->len;\n\n\n\n    AcpiMultipleApicTable *madt;\n\n    AcpiMadtIoApic *io_apic;\n\n    AcpiMadtIntsrcovr *intsrcovr;\n\n    AcpiMadtLocalNmi *local_nmi;\n\n    int i;\n\n\n\n    madt = acpi_data_push(table_data, sizeof *madt);\n\n    madt->local_apic_address = cpu_to_le32(APIC_DEFAULT_ADDRESS);\n\n    madt->flags = cpu_to_le32(1);\n\n\n\n    for (i = 0; i < pcms->apic_id_limit; i++) {\n\n        AcpiMadtProcessorApic *apic = acpi_data_push(table_data, sizeof *apic);\n\n        apic->type = ACPI_APIC_PROCESSOR;\n\n        apic->length = sizeof(*apic);\n\n        apic->processor_id = i;\n\n        apic->local_apic_id = i;\n\n        if (test_bit(i, cpu->found_cpus)) {\n\n            apic->flags = cpu_to_le32(1);\n\n        } else {\n\n            apic->flags = cpu_to_le32(0);\n\n        }\n\n    }\n\n    io_apic = acpi_data_push(table_data, sizeof *io_apic);\n\n    io_apic->type = ACPI_APIC_IO;\n\n    io_apic->length = sizeof(*io_apic);\n\n#define ACPI_BUILD_IOAPIC_ID 0x0\n\n    io_apic->io_apic_id = ACPI_BUILD_IOAPIC_ID;\n\n    io_apic->address = cpu_to_le32(IO_APIC_DEFAULT_ADDRESS);\n\n    io_apic->interrupt = cpu_to_le32(0);\n\n\n\n    if (pcms->apic_xrupt_override) {\n\n        intsrcovr = acpi_data_push(table_data, sizeof *intsrcovr);\n\n        intsrcovr->type   = ACPI_APIC_XRUPT_OVERRIDE;\n\n        intsrcovr->length = sizeof(*intsrcovr);\n\n        intsrcovr->source = 0;\n\n        intsrcovr->gsi    = cpu_to_le32(2);\n\n        intsrcovr->flags  = cpu_to_le16(0); /* conforms to bus specifications */\n\n    }\n\n    for (i = 1; i < 16; i++) {\n\n#define ACPI_BUILD_PCI_IRQS ((1<<5) | (1<<9) | (1<<10) | (1<<11))\n\n        if (!(ACPI_BUILD_PCI_IRQS & (1 << i))) {\n\n            /* No need for a INT source override structure. */\n\n            continue;\n\n        }\n\n        intsrcovr = acpi_data_push(table_data, sizeof *intsrcovr);\n\n        intsrcovr->type   = ACPI_APIC_XRUPT_OVERRIDE;\n\n        intsrcovr->length = sizeof(*intsrcovr);\n\n        intsrcovr->source = i;\n\n        intsrcovr->gsi    = cpu_to_le32(i);\n\n        intsrcovr->flags  = cpu_to_le16(0xd); /* active high, level triggered */\n\n    }\n\n\n\n    local_nmi = acpi_data_push(table_data, sizeof *local_nmi);\n\n    local_nmi->type         = ACPI_APIC_LOCAL_NMI;\n\n    local_nmi->length       = sizeof(*local_nmi);\n\n    local_nmi->processor_id = 0xff; /* all processors */\n\n    local_nmi->flags        = cpu_to_le16(0);\n\n    local_nmi->lint         = 1; /* ACPI_LINT1 */\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)(table_data->data + madt_start), \"APIC\",\n\n                 table_data->len - madt_start, 1, NULL);\n\n}\n", "idx": 6034, "_split": "valid", "_hash": "4ad7624cbe9acbdc0b4d296323f9d756"}
{"project": "qemu", "commit_id": "51941e4695c6f6c1f786bacef7e8c3a477570e04", "target": 0, "func": "void vncws_tls_handshake_peek(void *opaque)\n\n{\n\n    VncState *vs = opaque;\n\n    long ret;\n\n\n\n    if (!vs->ws_tls.session) {\n\n        char peek[4];\n\n        ret = qemu_recv(vs->csock, peek, sizeof(peek), MSG_PEEK);\n\n        if (ret && (strncmp(peek, \"\\x16\", 1) == 0\n\n                    || strncmp(peek, \"\\x80\", 1) == 0)) {\n\n            VNC_DEBUG(\"TLS Websocket connection recognized\");\n\n            vnc_tls_client_setup(vs, 1);\n\n            vncws_start_tls_handshake(vs);\n\n        } else {\n\n            vncws_handshake_read(vs);\n\n        }\n\n    } else {\n\n        qemu_set_fd_handler2(vs->csock, NULL, vncws_handshake_read, NULL, vs);\n\n    }\n\n}\n", "idx": 6047, "_split": "valid", "_hash": "39a5f54c69f4e7b43a3a042bdbb46fdb"}
{"project": "qemu", "commit_id": "dd941cdcfec536aad6a310a153778142ed9f3e92", "target": 0, "func": "bool check_hw_breakpoints(CPUX86State *env, bool force_dr6_update)\n\n{\n\n    target_ulong dr6;\n\n    int reg;\n\n    bool hit_enabled = false;\n\n\n\n    dr6 = env->dr[6] & ~0xf;\n\n    for (reg = 0; reg < DR7_MAX_BP; reg++) {\n\n        bool bp_match = false;\n\n        bool wp_match = false;\n\n\n\n        switch (hw_breakpoint_type(env->dr[7], reg)) {\n\n        case DR7_TYPE_BP_INST:\n\n            if (env->dr[reg] == env->eip) {\n\n                bp_match = true;\n\n            }\n\n            break;\n\n        case DR7_TYPE_DATA_WR:\n\n        case DR7_TYPE_DATA_RW:\n\n            if (env->cpu_watchpoint[reg] &&\n\n                env->cpu_watchpoint[reg]->flags & BP_WATCHPOINT_HIT) {\n\n                wp_match = true;\n\n            }\n\n            break;\n\n        case DR7_TYPE_IO_RW:\n\n            break;\n\n        }\n\n        if (bp_match || wp_match) {\n\n            dr6 |= 1 << reg;\n\n            if (hw_breakpoint_enabled(env->dr[7], reg)) {\n\n                hit_enabled = true;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (hit_enabled || force_dr6_update) {\n\n        env->dr[6] = dr6;\n\n    }\n\n\n\n    return hit_enabled;\n\n}\n", "idx": 6053, "_split": "valid", "_hash": "33a9c3534c5de42417715d499f20cb74"}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "void arm_translate_init(void)\n\n{\n\n    cpu_env = tcg_global_reg_new(TCG_TYPE_PTR, TCG_AREG0, \"env\");\n\n\n\n    cpu_T[0] = tcg_global_reg_new(TCG_TYPE_I32, TCG_AREG1, \"T0\");\n\n    cpu_T[1] = tcg_global_reg_new(TCG_TYPE_I32, TCG_AREG2, \"T1\");\n\n}\n", "idx": 6072, "_split": "valid", "_hash": "235607815fbd85d9ef2b20b3b3c68804"}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "void virtio_9p_push_and_notify(V9fsPDU *pdu)\n\n{\n\n    V9fsState *s = pdu->s;\n\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n\n    VirtQueueElement *elem = &v->elems[pdu->idx];\n\n\n\n    /* push onto queue and notify */\n\n    virtqueue_push(v->vq, elem, pdu->size);\n\n\n\n    /* FIXME: we should batch these completions */\n\n    virtio_notify(VIRTIO_DEVICE(v), v->vq);\n\n}\n", "idx": 6074, "_split": "valid", "_hash": "7860b2ee40e2951f62438184a84acdf5"}
{"project": "qemu", "commit_id": "a5b8dd2ce83208cd7d6eb4562339ecf5aae13574", "target": 0, "func": "int coroutine_fn bdrv_co_pwritev(BlockDriverState *bs,\n\n    int64_t offset, unsigned int bytes, QEMUIOVector *qiov,\n\n    BdrvRequestFlags flags)\n\n{\n\n    BdrvTrackedRequest req;\n\n    uint64_t align = bs->request_alignment;\n\n    uint8_t *head_buf = NULL;\n\n    uint8_t *tail_buf = NULL;\n\n    QEMUIOVector local_qiov;\n\n    bool use_local_qiov = false;\n\n    int ret;\n\n\n\n    if (!bs->drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n    if (bs->read_only) {\n\n        return -EPERM;\n\n    }\n\n    assert(!(bs->open_flags & BDRV_O_INACTIVE));\n\n\n\n    ret = bdrv_check_byte_request(bs, offset, bytes);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * Align write if necessary by performing a read-modify-write cycle.\n\n     * Pad qiov with the read parts and be sure to have a tracked request not\n\n     * only for bdrv_aligned_pwritev, but also for the reads of the RMW cycle.\n\n     */\n\n    tracked_request_begin(&req, bs, offset, bytes, BDRV_TRACKED_WRITE);\n\n\n\n    if (!qiov) {\n\n        ret = bdrv_co_do_zero_pwritev(bs, offset, bytes, flags, &req);\n\n        goto out;\n\n    }\n\n\n\n    if (offset & (align - 1)) {\n\n        QEMUIOVector head_qiov;\n\n        struct iovec head_iov;\n\n\n\n        mark_request_serialising(&req, align);\n\n        wait_serialising_requests(&req);\n\n\n\n        head_buf = qemu_blockalign(bs, align);\n\n        head_iov = (struct iovec) {\n\n            .iov_base   = head_buf,\n\n            .iov_len    = align,\n\n        };\n\n        qemu_iovec_init_external(&head_qiov, &head_iov, 1);\n\n\n\n        bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_HEAD);\n\n        ret = bdrv_aligned_preadv(bs, &req, offset & ~(align - 1), align,\n\n                                  align, &head_qiov, 0);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_AFTER_HEAD);\n\n\n\n        qemu_iovec_init(&local_qiov, qiov->niov + 2);\n\n        qemu_iovec_add(&local_qiov, head_buf, offset & (align - 1));\n\n        qemu_iovec_concat(&local_qiov, qiov, 0, qiov->size);\n\n        use_local_qiov = true;\n\n\n\n        bytes += offset & (align - 1);\n\n        offset = offset & ~(align - 1);\n\n\n\n        /* We have read the tail already if the request is smaller\n\n         * than one aligned block.\n\n         */\n\n        if (bytes < align) {\n\n            qemu_iovec_add(&local_qiov, head_buf + bytes, align - bytes);\n\n            bytes = align;\n\n        }\n\n    }\n\n\n\n    if ((offset + bytes) & (align - 1)) {\n\n        QEMUIOVector tail_qiov;\n\n        struct iovec tail_iov;\n\n        size_t tail_bytes;\n\n        bool waited;\n\n\n\n        mark_request_serialising(&req, align);\n\n        waited = wait_serialising_requests(&req);\n\n        assert(!waited || !use_local_qiov);\n\n\n\n        tail_buf = qemu_blockalign(bs, align);\n\n        tail_iov = (struct iovec) {\n\n            .iov_base   = tail_buf,\n\n            .iov_len    = align,\n\n        };\n\n        qemu_iovec_init_external(&tail_qiov, &tail_iov, 1);\n\n\n\n        bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_TAIL);\n\n        ret = bdrv_aligned_preadv(bs, &req, (offset + bytes) & ~(align - 1), align,\n\n                                  align, &tail_qiov, 0);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_AFTER_TAIL);\n\n\n\n        if (!use_local_qiov) {\n\n            qemu_iovec_init(&local_qiov, qiov->niov + 1);\n\n            qemu_iovec_concat(&local_qiov, qiov, 0, qiov->size);\n\n            use_local_qiov = true;\n\n        }\n\n\n\n        tail_bytes = (offset + bytes) & (align - 1);\n\n        qemu_iovec_add(&local_qiov, tail_buf + tail_bytes, align - tail_bytes);\n\n\n\n        bytes = ROUND_UP(bytes, align);\n\n    }\n\n\n\n    ret = bdrv_aligned_pwritev(bs, &req, offset, bytes, align,\n\n                               use_local_qiov ? &local_qiov : qiov,\n\n                               flags);\n\n\n\nfail:\n\n\n\n    if (use_local_qiov) {\n\n        qemu_iovec_destroy(&local_qiov);\n\n    }\n\n    qemu_vfree(head_buf);\n\n    qemu_vfree(tail_buf);\n\nout:\n\n    tracked_request_end(&req);\n\n    return ret;\n\n}\n", "idx": 6083, "_split": "valid", "_hash": "e9cd27178aae81be386cd6965da15caf"}
{"project": "qemu", "commit_id": "2b147555f78c3c20080b201fd1506467fa0ddf43", "target": 0, "func": "static int kvm_s390_check_clear_cmma(KVMState *s)\n\n{\n\n    struct kvm_device_attr attr = {\n\n        .group = KVM_S390_VM_MEM_CTRL,\n\n        .attr = KVM_S390_VM_MEM_CLR_CMMA,\n\n    };\n\n\n\n    return kvm_vm_ioctl(s, KVM_HAS_DEVICE_ATTR, &attr);\n\n}\n", "idx": 6087, "_split": "valid", "_hash": "e4fac14b4a0e860d07d77c718ba63d63"}
{"project": "qemu", "commit_id": "53a295131274c87914c97053e2ca00f19a9c2efa", "target": 0, "func": "static int bdrv_fill_options(QDict **options, const char **pfilename, int flags,\n\n                             BlockDriver *drv, Error **errp)\n\n{\n\n    const char *filename = *pfilename;\n\n    const char *drvname;\n\n    bool protocol = flags & BDRV_O_PROTOCOL;\n\n    bool parse_filename = false;\n\n    Error *local_err = NULL;\n\n\n\n    /* Parse json: pseudo-protocol */\n\n    if (filename && g_str_has_prefix(filename, \"json:\")) {\n\n        QDict *json_options = parse_json_filename(filename, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return -EINVAL;\n\n        }\n\n\n\n        /* Options given in the filename have lower priority than options\n\n         * specified directly */\n\n        qdict_join(*options, json_options, false);\n\n        QDECREF(json_options);\n\n        *pfilename = filename = NULL;\n\n    }\n\n\n\n    /* Fetch the file name from the options QDict if necessary */\n\n    if (protocol && filename) {\n\n        if (!qdict_haskey(*options, \"filename\")) {\n\n            qdict_put(*options, \"filename\", qstring_from_str(filename));\n\n            parse_filename = true;\n\n        } else {\n\n            error_setg(errp, \"Can't specify 'file' and 'filename' options at \"\n\n                             \"the same time\");\n\n            return -EINVAL;\n\n        }\n\n    }\n\n\n\n    /* Find the right block driver */\n\n    filename = qdict_get_try_str(*options, \"filename\");\n\n    drvname = qdict_get_try_str(*options, \"driver\");\n\n\n\n    if (drv) {\n\n        if (drvname) {\n\n            error_setg(errp, \"Driver specified twice\");\n\n            return -EINVAL;\n\n        }\n\n        drvname = drv->format_name;\n\n        qdict_put(*options, \"driver\", qstring_from_str(drvname));\n\n    } else {\n\n        if (!drvname && protocol) {\n\n            if (filename) {\n\n                drv = bdrv_find_protocol(filename, parse_filename, errp);\n\n                if (!drv) {\n\n                    return -EINVAL;\n\n                }\n\n\n\n                drvname = drv->format_name;\n\n                qdict_put(*options, \"driver\", qstring_from_str(drvname));\n\n            } else {\n\n                error_setg(errp, \"Must specify either driver or file\");\n\n                return -EINVAL;\n\n            }\n\n        } else if (drvname) {\n\n            drv = bdrv_find_format(drvname);\n\n            if (!drv) {\n\n                error_setg(errp, \"Unknown driver '%s'\", drvname);\n\n                return -ENOENT;\n\n            }\n\n        }\n\n    }\n\n\n\n    assert(drv || !protocol);\n\n\n\n    /* Driver-specific filename parsing */\n\n    if (drv && drv->bdrv_parse_filename && parse_filename) {\n\n        drv->bdrv_parse_filename(filename, *options, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (!drv->bdrv_needs_filename) {\n\n            qdict_del(*options, \"filename\");\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6097, "_split": "valid", "_hash": "359b6e86b314db4db9c73eddebf26568"}
{"project": "qemu", "commit_id": "7e486f7577764a07aa35588e119903c80a5c30a2", "target": 1, "func": "static inline uint32_t vmsvga_fifo_read_raw(struct vmsvga_state_s *s)\n\n{\n\n    uint32_t cmd = s->fifo[CMD(stop) >> 2];\n\n\n\n    s->cmd->stop = cpu_to_le32(CMD(stop) + 4);\n\n    if (CMD(stop) >= CMD(max)) {\n\n        s->cmd->stop = s->cmd->min;\n\n    }\n\n    return cmd;\n\n}\n", "idx": 6107, "_split": "valid", "_hash": "54a69f6dac1ed6d512ebb6939c7a799a"}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void dead_tmp(TCGv tmp)\n\n{\n\n    tcg_temp_free(tmp);\n\n    num_temps--;\n\n}\n", "idx": 6133, "_split": "valid", "_hash": "8f08a4a3698da84c43cd888ccb6eb4a6"}
{"project": "qemu", "commit_id": "3ac216270a62418519c08e88c17005a8f1539cf2", "target": 1, "func": "int bdrv_has_zero_init(BlockDriverState *bs)\n\n{\n\n    assert(bs->drv);\n\n\n\n    if (bs->drv->bdrv_has_zero_init) {\n\n        return bs->drv->bdrv_has_zero_init(bs);\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 6153, "_split": "valid", "_hash": "8d1f2fefdd1fa7cd94b1d388e1b72bc6"}
{"project": "qemu", "commit_id": "2d528d45ecf5ee3c1a566a9f3d664464925ef830", "target": 1, "func": "static CharDriverState *qemu_chr_open_mux(CharDriverState *drv)\n\n{\n\n    CharDriverState *chr;\n\n    MuxDriver *d;\n\n\n\n    chr = qemu_chr_alloc();\n\n    d = g_malloc0(sizeof(MuxDriver));\n\n\n\n    chr->opaque = d;\n\n    d->drv = drv;\n\n    d->focus = -1;\n\n    chr->chr_write = mux_chr_write;\n\n    chr->chr_update_read_handler = mux_chr_update_read_handler;\n\n    chr->chr_accept_input = mux_chr_accept_input;\n\n    /* Frontend guest-open / -close notification is not support with muxes */\n\n    chr->chr_set_fe_open = NULL;\n\n    if (drv->chr_add_watch) {\n\n        chr->chr_add_watch = mux_chr_add_watch;\n\n    }\n\n    /* only default to opened state if we've realized the initial\n\n     * set of muxes\n\n     */\n\n    chr->explicit_be_open = muxes_realized ? 0 : 1;\n\n    chr->is_mux = 1;\n\n\n\n    return chr;\n\n}\n", "idx": 6155, "_split": "valid", "_hash": "bf8c699cbf4ec04944a524b7e682a557"}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static void qmp_query_auth(VncDisplay *vd, VncInfo2 *info)\n\n{\n\n    switch (vd->auth) {\n\n    case VNC_AUTH_VNC:\n\n        info->auth = VNC_PRIMARY_AUTH_VNC;\n\n        break;\n\n    case VNC_AUTH_RA2:\n\n        info->auth = VNC_PRIMARY_AUTH_RA2;\n\n        break;\n\n    case VNC_AUTH_RA2NE:\n\n        info->auth = VNC_PRIMARY_AUTH_RA2NE;\n\n        break;\n\n    case VNC_AUTH_TIGHT:\n\n        info->auth = VNC_PRIMARY_AUTH_TIGHT;\n\n        break;\n\n    case VNC_AUTH_ULTRA:\n\n        info->auth = VNC_PRIMARY_AUTH_ULTRA;\n\n        break;\n\n    case VNC_AUTH_TLS:\n\n        info->auth = VNC_PRIMARY_AUTH_TLS;\n\n        break;\n\n    case VNC_AUTH_VENCRYPT:\n\n        info->auth = VNC_PRIMARY_AUTH_VENCRYPT;\n\n#ifdef CONFIG_VNC_TLS\n\n        info->has_vencrypt = true;\n\n        switch (vd->subauth) {\n\n        case VNC_AUTH_VENCRYPT_PLAIN:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_PLAIN;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_TLSNONE:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_TLS_NONE;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_TLSVNC:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_TLS_VNC;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_TLSPLAIN:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_TLS_PLAIN;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_X509NONE:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_X509_NONE;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_X509VNC:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_X509_VNC;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_X509PLAIN:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_X509_PLAIN;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_TLSSASL:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_TLS_SASL;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_X509SASL:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_X509_SASL;\n\n            break;\n\n        default:\n\n            info->has_vencrypt = false;\n\n            break;\n\n        }\n\n#endif\n\n        break;\n\n    case VNC_AUTH_SASL:\n\n        info->auth = VNC_PRIMARY_AUTH_SASL;\n\n        break;\n\n    case VNC_AUTH_NONE:\n\n    default:\n\n        info->auth = VNC_PRIMARY_AUTH_NONE;\n\n        break;\n\n    }\n\n}\n", "idx": 6174, "_split": "valid", "_hash": "ba83b7fdf42d96c2393de6b45ad49a20"}
{"project": "qemu", "commit_id": "b7394c8394d38cb38b6db14eb431cac7a91e7140", "target": 0, "func": "int hvf_vcpu_exec(CPUState *cpu)\n\n{\n\n    X86CPU *x86_cpu = X86_CPU(cpu);\n\n    CPUX86State *env = &x86_cpu->env;\n\n    int ret = 0;\n\n    uint64_t rip = 0;\n\n\n\n    cpu->halted = 0;\n\n\n\n    if (hvf_process_events(cpu)) {\n\n        return EXCP_HLT;\n\n    }\n\n\n\n    do {\n\n        if (cpu->vcpu_dirty) {\n\n            hvf_put_registers(cpu);\n\n            cpu->vcpu_dirty = false;\n\n        }\n\n\n\n        env->hvf_emul->interruptable =\n\n            !(rvmcs(cpu->hvf_fd, VMCS_GUEST_INTERRUPTIBILITY) &\n\n             (VMCS_INTERRUPTIBILITY_STI_BLOCKING |\n\n             VMCS_INTERRUPTIBILITY_MOVSS_BLOCKING));\n\n\n\n        hvf_inject_interrupts(cpu);\n\n        vmx_update_tpr(cpu);\n\n\n\n        qemu_mutex_unlock_iothread();\n\n        if (!cpu_is_bsp(X86_CPU(cpu)) && cpu->halted) {\n\n            qemu_mutex_lock_iothread();\n\n            return EXCP_HLT;\n\n        }\n\n\n\n        hv_return_t r  = hv_vcpu_run(cpu->hvf_fd);\n\n        assert_hvf_ok(r);\n\n\n\n        /* handle VMEXIT */\n\n        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);\n\n        uint64_t exit_qual = rvmcs(cpu->hvf_fd, VMCS_EXIT_QUALIFICATION);\n\n        uint32_t ins_len = (uint32_t)rvmcs(cpu->hvf_fd,\n\n                                           VMCS_EXIT_INSTRUCTION_LENGTH);\n\n        uint64_t idtvec_info = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n\n        rip = rreg(cpu->hvf_fd, HV_X86_RIP);\n\n        RFLAGS(env) = rreg(cpu->hvf_fd, HV_X86_RFLAGS);\n\n        env->eflags = RFLAGS(env);\n\n\n\n        qemu_mutex_lock_iothread();\n\n\n\n        update_apic_tpr(cpu);\n\n        current_cpu = cpu;\n\n\n\n        ret = 0;\n\n        switch (exit_reason) {\n\n        case EXIT_REASON_HLT: {\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            if (!((cpu->interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                (EFLAGS(env) & IF_MASK))\n\n                && !(cpu->interrupt_request & CPU_INTERRUPT_NMI) &&\n\n                !(idtvec_info & VMCS_IDT_VEC_VALID)) {\n\n                cpu->halted = 1;\n\n                ret = EXCP_HLT;\n\n            }\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n        case EXIT_REASON_MWAIT: {\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n            /* Need to check if MMIO or unmmaped fault */\n\n        case EXIT_REASON_EPT_FAULT:\n\n        {\n\n            hvf_slot *slot;\n\n            addr_t gpa = rvmcs(cpu->hvf_fd, VMCS_GUEST_PHYSICAL_ADDRESS);\n\n\n\n            if (((idtvec_info & VMCS_IDT_VEC_VALID) == 0) &&\n\n                ((exit_qual & EXIT_QUAL_NMIUDTI) != 0)) {\n\n                vmx_set_nmi_blocking(cpu);\n\n            }\n\n\n\n            slot = hvf_find_overlap_slot(gpa, gpa);\n\n            /* mmio */\n\n            if (ept_emulation_fault(slot, gpa, exit_qual)) {\n\n                struct x86_decode decode;\n\n\n\n                load_regs(cpu);\n\n                env->hvf_emul->fetch_rip = rip;\n\n\n\n                decode_instruction(env, &decode);\n\n                exec_instruction(env, &decode);\n\n                store_regs(cpu);\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n        case EXIT_REASON_INOUT:\n\n        {\n\n            uint32_t in = (exit_qual & 8) != 0;\n\n            uint32_t size =  (exit_qual & 7) + 1;\n\n            uint32_t string =  (exit_qual & 16) != 0;\n\n            uint32_t port =  exit_qual >> 16;\n\n            /*uint32_t rep = (exit_qual & 0x20) != 0;*/\n\n\n\n#if 1\n\n            if (!string && in) {\n\n                uint64_t val = 0;\n\n                load_regs(cpu);\n\n                hvf_handle_io(env, port, &val, 0, size, 1);\n\n                if (size == 1) {\n\n                    AL(env) = val;\n\n                } else if (size == 2) {\n\n                    AX(env) = val;\n\n                } else if (size == 4) {\n\n                    RAX(env) = (uint32_t)val;\n\n                } else {\n\n                    VM_PANIC(\"size\");\n\n                }\n\n                RIP(env) += ins_len;\n\n                store_regs(cpu);\n\n                break;\n\n            } else if (!string && !in) {\n\n                RAX(env) = rreg(cpu->hvf_fd, HV_X86_RAX);\n\n                hvf_handle_io(env, port, &RAX(env), 1, size, 1);\n\n                macvm_set_rip(cpu, rip + ins_len);\n\n                break;\n\n            }\n\n#endif\n\n            struct x86_decode decode;\n\n\n\n            load_regs(cpu);\n\n            env->hvf_emul->fetch_rip = rip;\n\n\n\n            decode_instruction(env, &decode);\n\n            VM_PANIC_ON(ins_len != decode.len);\n\n            exec_instruction(env, &decode);\n\n            store_regs(cpu);\n\n\n\n            break;\n\n        }\n\n        case EXIT_REASON_CPUID: {\n\n            uint32_t rax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);\n\n            uint32_t rbx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RBX);\n\n            uint32_t rcx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);\n\n            uint32_t rdx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);\n\n\n\n            cpu_x86_cpuid(env, rax, rcx, &rax, &rbx, &rcx, &rdx);\n\n\n\n            wreg(cpu->hvf_fd, HV_X86_RAX, rax);\n\n            wreg(cpu->hvf_fd, HV_X86_RBX, rbx);\n\n            wreg(cpu->hvf_fd, HV_X86_RCX, rcx);\n\n            wreg(cpu->hvf_fd, HV_X86_RDX, rdx);\n\n\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        }\n\n        case EXIT_REASON_XSETBV: {\n\n            X86CPU *x86_cpu = X86_CPU(cpu);\n\n            CPUX86State *env = &x86_cpu->env;\n\n            uint32_t eax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);\n\n            uint32_t ecx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);\n\n            uint32_t edx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);\n\n\n\n            if (ecx) {\n\n                macvm_set_rip(cpu, rip + ins_len);\n\n                break;\n\n            }\n\n            env->xcr0 = ((uint64_t)edx << 32) | eax;\n\n            wreg(cpu->hvf_fd, HV_X86_XCR0, env->xcr0 | 1);\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        }\n\n        case EXIT_REASON_INTR_WINDOW:\n\n            vmx_clear_int_window_exiting(cpu);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_NMI_WINDOW:\n\n            vmx_clear_nmi_window_exiting(cpu);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_EXT_INTR:\n\n            /* force exit and allow io handling */\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_RDMSR:\n\n        case EXIT_REASON_WRMSR:\n\n        {\n\n            load_regs(cpu);\n\n            if (exit_reason == EXIT_REASON_RDMSR) {\n\n                simulate_rdmsr(cpu);\n\n            } else {\n\n                simulate_wrmsr(cpu);\n\n            }\n\n            RIP(env) += rvmcs(cpu->hvf_fd, VMCS_EXIT_INSTRUCTION_LENGTH);\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_CR_ACCESS: {\n\n            int cr;\n\n            int reg;\n\n\n\n            load_regs(cpu);\n\n            cr = exit_qual & 15;\n\n            reg = (exit_qual >> 8) & 15;\n\n\n\n            switch (cr) {\n\n            case 0x0: {\n\n                macvm_set_cr0(cpu->hvf_fd, RRX(env, reg));\n\n                break;\n\n            }\n\n            case 4: {\n\n                macvm_set_cr4(cpu->hvf_fd, RRX(env, reg));\n\n                break;\n\n            }\n\n            case 8: {\n\n                X86CPU *x86_cpu = X86_CPU(cpu);\n\n                if (exit_qual & 0x10) {\n\n                    RRX(env, reg) = cpu_get_apic_tpr(x86_cpu->apic_state);\n\n                } else {\n\n                    int tpr = RRX(env, reg);\n\n                    cpu_set_apic_tpr(x86_cpu->apic_state, tpr);\n\n                    ret = EXCP_INTERRUPT;\n\n                }\n\n                break;\n\n            }\n\n            default:\n\n                error_report(\"Unrecognized CR %d\\n\", cr);\n\n                abort();\n\n            }\n\n            RIP(env) += ins_len;\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_APIC_ACCESS: { /* TODO */\n\n            struct x86_decode decode;\n\n\n\n            load_regs(cpu);\n\n            env->hvf_emul->fetch_rip = rip;\n\n\n\n            decode_instruction(env, &decode);\n\n            exec_instruction(env, &decode);\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_TPR: {\n\n            ret = 1;\n\n            break;\n\n        }\n\n        case EXIT_REASON_TASK_SWITCH: {\n\n            uint64_t vinfo = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n\n            x68_segment_selector sel = {.sel = exit_qual & 0xffff};\n\n            vmx_handle_task_switch(cpu, sel, (exit_qual >> 30) & 0x3,\n\n             vinfo & VMCS_INTR_VALID, vinfo & VECTORING_INFO_VECTOR_MASK, vinfo\n\n             & VMCS_INTR_T_MASK);\n\n            break;\n\n        }\n\n        case EXIT_REASON_TRIPLE_FAULT: {\n\n            qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n        case EXIT_REASON_RDPMC:\n\n            wreg(cpu->hvf_fd, HV_X86_RAX, 0);\n\n            wreg(cpu->hvf_fd, HV_X86_RDX, 0);\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        case VMX_REASON_VMCALL:\n\n            /* TODO: inject #GP fault */\n\n            break;\n\n        default:\n\n            error_report(\"%llx: unhandled exit %llx\\n\", rip, exit_reason);\n\n        }\n\n    } while (ret == 0);\n\n\n\n    return ret;\n\n}\n", "idx": 6183, "_split": "valid", "_hash": "9c60e5f5d67d1ad70c553dd1ff853073"}
{"project": "qemu", "commit_id": "d3b12f5dec4b27ebab58fb5797cb67bacced773b", "target": 0, "func": "static void dummy_event_handler(void *opaque)\n\n{\n\n}\n", "idx": 6185, "_split": "valid", "_hash": "c6b075efbc979e0cc1d01cb8a717c827"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void cpu_watchpoint_remove_by_ref(CPUState *env, CPUWatchpoint *watchpoint)\n\n{\n\n    TAILQ_REMOVE(&env->watchpoints, watchpoint, entry);\n\n\n\n    tlb_flush_page(env, watchpoint->vaddr);\n\n\n\n    qemu_free(watchpoint);\n\n}\n", "idx": 6197, "_split": "valid", "_hash": "cf4f6075c1d1d56ee52e12f5488d33b3"}
{"project": "qemu", "commit_id": "80ac2390358c906215a849670ca5b7a3d1d112a3", "target": 0, "func": "void armv7m_nvic_set_pending(void *opaque, int irq, bool secure)\n\n{\n\n    NVICState *s = (NVICState *)opaque;\n\n    bool banked = exc_is_banked(irq);\n\n    VecInfo *vec;\n\n\n\n    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);\n\n    assert(!secure || banked);\n\n\n\n    vec = (banked && secure) ? &s->sec_vectors[irq] : &s->vectors[irq];\n\n\n\n    trace_nvic_set_pending(irq, secure, vec->enabled, vec->prio);\n\n\n\n    if (irq >= ARMV7M_EXCP_HARD && irq < ARMV7M_EXCP_PENDSV) {\n\n        /* If a synchronous exception is pending then it may be\n\n         * escalated to HardFault if:\n\n         *  * it is equal or lower priority to current execution\n\n         *  * it is disabled\n\n         * (ie we need to take it immediately but we can't do so).\n\n         * Asynchronous exceptions (and interrupts) simply remain pending.\n\n         *\n\n         * For QEMU, we don't have any imprecise (asynchronous) faults,\n\n         * so we can assume that PREFETCH_ABORT and DATA_ABORT are always\n\n         * synchronous.\n\n         * Debug exceptions are awkward because only Debug exceptions\n\n         * resulting from the BKPT instruction should be escalated,\n\n         * but we don't currently implement any Debug exceptions other\n\n         * than those that result from BKPT, so we treat all debug exceptions\n\n         * as needing escalation.\n\n         *\n\n         * This all means we can identify whether to escalate based only on\n\n         * the exception number and don't (yet) need the caller to explicitly\n\n         * tell us whether this exception is synchronous or not.\n\n         */\n\n        int running = nvic_exec_prio(s);\n\n        bool escalate = false;\n\n\n\n        if (vec->prio >= running) {\n\n            trace_nvic_escalate_prio(irq, vec->prio, running);\n\n            escalate = true;\n\n        } else if (!vec->enabled) {\n\n            trace_nvic_escalate_disabled(irq);\n\n            escalate = true;\n\n        }\n\n\n\n        if (escalate) {\n\n            if (running < 0) {\n\n                /* We want to escalate to HardFault but we can't take a\n\n                 * synchronous HardFault at this point either. This is a\n\n                 * Lockup condition due to a guest bug. We don't model\n\n                 * Lockup, so report via cpu_abort() instead.\n\n                 */\n\n                cpu_abort(&s->cpu->parent_obj,\n\n                          \"Lockup: can't escalate %d to HardFault \"\n\n                          \"(current priority %d)\\n\", irq, running);\n\n            }\n\n\n\n            /* We can do the escalation, so we take HardFault instead.\n\n             * If BFHFNMINS is set then we escalate to the banked HF for\n\n             * the target security state of the original exception; otherwise\n\n             * we take a Secure HardFault.\n\n             */\n\n            irq = ARMV7M_EXCP_HARD;\n\n            if (arm_feature(&s->cpu->env, ARM_FEATURE_M_SECURITY) &&\n\n                (secure ||\n\n                 !(s->cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK))) {\n\n                vec = &s->sec_vectors[irq];\n\n            } else {\n\n                vec = &s->vectors[irq];\n\n            }\n\n            /* HF may be banked but there is only one shared HFSR */\n\n            s->cpu->env.v7m.hfsr |= R_V7M_HFSR_FORCED_MASK;\n\n        }\n\n    }\n\n\n\n    if (!vec->pending) {\n\n        vec->pending = 1;\n\n        nvic_irq_update(s);\n\n    }\n\n}\n", "idx": 6198, "_split": "valid", "_hash": "bb1aac60adb8fc069ee11aa61fd52dfd"}
{"project": "qemu", "commit_id": "b40acf99bef69fa8ab0f9092ff162fde945eec12", "target": 0, "func": "void portio_list_init(PortioList *piolist,\n\n                      const MemoryRegionPortio *callbacks,\n\n                      void *opaque, const char *name)\n\n{\n\n    unsigned n = 0;\n\n\n\n    while (callbacks[n].size) {\n\n        ++n;\n\n    }\n\n\n\n    piolist->ports = callbacks;\n\n    piolist->nr = 0;\n\n    piolist->regions = g_new0(MemoryRegion *, n);\n\n    piolist->aliases = g_new0(MemoryRegion *, n);\n\n    piolist->address_space = NULL;\n\n    piolist->opaque = opaque;\n\n    piolist->name = name;\n\n}\n", "idx": 6199, "_split": "valid", "_hash": "32534daa5df4802543e097fd60079783"}
{"project": "qemu", "commit_id": "398489018183d613306ab022653552247d93919f", "target": 1, "func": "static int mch_init(PCIDevice *d)\n\n{\n\n    int i;\n\n    hwaddr pci_hole64_size;\n\n    MCHPCIState *mch = MCH_PCI_DEVICE(d);\n\n\n\n    /* Leave enough space for the biggest MCFG BAR */\n\n    /* TODO: this matches current bios behaviour, but\n\n     * it's not a power of two, which means an MTRR\n\n     * can't cover it exactly.\n\n     */\n\n    mch->guest_info->pci_info.w32.begin = MCH_HOST_BRIDGE_PCIEXBAR_DEFAULT +\n\n        MCH_HOST_BRIDGE_PCIEXBAR_MAX;\n\n\n\n    /* setup pci memory regions */\n\n    memory_region_init_alias(&mch->pci_hole, OBJECT(mch), \"pci-hole\",\n\n                             mch->pci_address_space,\n\n                             mch->below_4g_mem_size,\n\n                             0x100000000ULL - mch->below_4g_mem_size);\n\n    memory_region_add_subregion(mch->system_memory, mch->below_4g_mem_size,\n\n                                &mch->pci_hole);\n\n    pci_hole64_size = (sizeof(hwaddr) == 4 ? 0 :\n\n                       ((uint64_t)1 << 62));\n\n    memory_region_init_alias(&mch->pci_hole_64bit, OBJECT(mch), \"pci-hole64\",\n\n                             mch->pci_address_space,\n\n                             0x100000000ULL + mch->above_4g_mem_size,\n\n                             pci_hole64_size);\n\n    if (pci_hole64_size) {\n\n        memory_region_add_subregion(mch->system_memory,\n\n                                    0x100000000ULL + mch->above_4g_mem_size,\n\n                                    &mch->pci_hole_64bit);\n\n    }\n\n    /* smram */\n\n    cpu_smm_register(&mch_set_smm, mch);\n\n    memory_region_init_alias(&mch->smram_region, OBJECT(mch), \"smram-region\",\n\n                             mch->pci_address_space, 0xa0000, 0x20000);\n\n    memory_region_add_subregion_overlap(mch->system_memory, 0xa0000,\n\n                                        &mch->smram_region, 1);\n\n    memory_region_set_enabled(&mch->smram_region, false);\n\n    init_pam(DEVICE(mch), mch->ram_memory, mch->system_memory, mch->pci_address_space,\n\n             &mch->pam_regions[0], PAM_BIOS_BASE, PAM_BIOS_SIZE);\n\n    for (i = 0; i < 12; ++i) {\n\n        init_pam(DEVICE(mch), mch->ram_memory, mch->system_memory, mch->pci_address_space,\n\n                 &mch->pam_regions[i+1], PAM_EXPAN_BASE + i * PAM_EXPAN_SIZE,\n\n                 PAM_EXPAN_SIZE);\n\n    }\n\n    return 0;\n\n}\n", "idx": 6202, "_split": "valid", "_hash": "649759e40985e41c8ab742b1f0ff98e8"}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mtsr(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    TCGv t0;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    t0 = tcg_const_tl(SR(ctx->opcode));\n\n    gen_helper_store_sr(cpu_env, t0, cpu_gpr[rS(ctx->opcode)]);\n\n    tcg_temp_free(t0);\n\n#endif\n\n}\n", "idx": 6207, "_split": "valid", "_hash": "fa5746b545a38aae791649cc12d853d9"}
{"project": "qemu", "commit_id": "36cccb8c575b74a691f685911fbb0301af19f924", "target": 1, "func": "static void device_initfn(Object *obj)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    ObjectClass *class;\n\n    Property *prop;\n\n\n\n    if (qdev_hotplug) {\n\n        dev->hotplugged = 1;\n\n        qdev_hot_added = true;\n\n    }\n\n\n\n    dev->instance_id_alias = -1;\n\n    dev->realized = false;\n\n\n\n    object_property_add_bool(obj, \"realized\",\n\n                             device_get_realized, device_set_realized, NULL);\n\n    object_property_add_bool(obj, \"hotpluggable\",\n\n                             device_get_hotpluggable, NULL, NULL);\n\n    object_property_add_bool(obj, \"hotplugged\",\n\n                             device_get_hotplugged, device_set_hotplugged,\n\n                             &error_abort);\n\n\n\n    class = object_get_class(OBJECT(dev));\n\n    do {\n\n        for (prop = DEVICE_CLASS(class)->props; prop && prop->name; prop++) {\n\n            qdev_property_add_legacy(dev, prop, &error_abort);\n\n            qdev_property_add_static(dev, prop, &error_abort);\n\n        }\n\n        class = object_class_get_parent(class);\n\n    } while (class != object_class_by_name(TYPE_DEVICE));\n\n\n\n    object_property_add_link(OBJECT(dev), \"parent_bus\", TYPE_BUS,\n\n                             (Object **)&dev->parent_bus, NULL, 0,\n\n                             &error_abort);\n\n    QLIST_INIT(&dev->gpios);\n\n}\n", "idx": 6275, "_split": "valid", "_hash": "6ad2d858327767477d1e5bcef27434d1"}
{"project": "qemu", "commit_id": "a8cf66bb393ff420d40ae172a4c817bf2752918a", "target": 0, "func": "static inline void cris_update_result(DisasContext *dc, TCGv res)\n\n{\n\n\tif (dc->update_cc) {\n\n\t\tif (dc->cc_size == 4 && \n\n\t\t    (dc->cc_op == CC_OP_SUB\n\n\t\t     || dc->cc_op == CC_OP_ADD))\n\n\t\t\treturn;\n\n\t\ttcg_gen_mov_tl(cc_result, res);\n\n\t}\n\n}\n", "idx": 6286, "_split": "valid", "_hash": "ebd548af6ca40e08d9013f42b91fa4d4"}
{"project": "qemu", "commit_id": "6d21e4208f382dd8ca1f7995a6dd9ea7ca281163", "target": 0, "func": "static inline TranslationBlock *tb_find_fast(CPUState *cpu,\n\n                                             TranslationBlock *last_tb,\n\n                                             int tb_exit)\n\n{\n\n    CPUArchState *env = (CPUArchState *)cpu->env_ptr;\n\n    TranslationBlock *tb;\n\n    target_ulong cs_base, pc;\n\n    uint32_t flags;\n\n\n\n    /* we record a subset of the CPU state. It will\n\n       always be the same before a given translated block\n\n       is executed. */\n\n    cpu_get_tb_cpu_state(env, &pc, &cs_base, &flags);\n\n    tb_lock();\n\n    tb = atomic_rcu_read(&cpu->tb_jmp_cache[tb_jmp_cache_hash_func(pc)]);\n\n    if (unlikely(!tb || tb->pc != pc || tb->cs_base != cs_base ||\n\n                 tb->flags != flags)) {\n\n        tb = tb_find_slow(cpu, pc, cs_base, flags);\n\n    }\n\n#ifndef CONFIG_USER_ONLY\n\n    /* We don't take care of direct jumps when address mapping changes in\n\n     * system emulation. So it's not safe to make a direct jump to a TB\n\n     * spanning two pages because the mapping for the second page can change.\n\n     */\n\n    if (tb->page_addr[1] != -1) {\n\n        last_tb = NULL;\n\n    }\n\n#endif\n\n    /* See if we can patch the calling TB. */\n\n    if (last_tb && !qemu_loglevel_mask(CPU_LOG_TB_NOCHAIN)) {\n\n        /* Check if translation buffer has been flushed */\n\n        if (cpu->tb_flushed) {\n\n            cpu->tb_flushed = false;\n\n        } else {\n\n            tb_add_jump(last_tb, tb_exit, tb);\n\n        }\n\n    }\n\n    tb_unlock();\n\n    return tb;\n\n}\n", "idx": 6287, "_split": "valid", "_hash": "841d5f4411d62061e37575ef937014b6"}
{"project": "qemu", "commit_id": "80cba1b71eb9a75404d1effddec8ffa9f0d6d6fb", "target": 1, "func": "static int proxy_init(FsContext *ctx)\n\n{\n\n    V9fsProxy *proxy = g_malloc(sizeof(V9fsProxy));\n\n    int sock_id;\n\n\n\n    if (ctx->export_flags & V9FS_PROXY_SOCK_NAME) {\n\n        sock_id = connect_namedsocket(ctx->fs_root);\n\n    } else {\n\n        sock_id = atoi(ctx->fs_root);\n\n        if (sock_id < 0) {\n\n            fprintf(stderr, \"socket descriptor not initialized\\n\");\n\n\n            return -1;\n\n        }\n\n    }\n\n    g_free(ctx->fs_root);\n\n\n\n\n    proxy->in_iovec.iov_base  = g_malloc(PROXY_MAX_IO_SZ + PROXY_HDR_SZ);\n\n    proxy->in_iovec.iov_len   = PROXY_MAX_IO_SZ + PROXY_HDR_SZ;\n\n    proxy->out_iovec.iov_base = g_malloc(PROXY_MAX_IO_SZ + PROXY_HDR_SZ);\n\n    proxy->out_iovec.iov_len  = PROXY_MAX_IO_SZ + PROXY_HDR_SZ;\n\n\n\n    ctx->private = proxy;\n\n    proxy->sockfd = sock_id;\n\n    qemu_mutex_init(&proxy->mutex);\n\n\n\n    ctx->export_flags |= V9FS_PATHNAME_FSCONTEXT;\n\n    ctx->exops.get_st_gen = proxy_ioc_getversion;\n\n    return 0;\n\n}", "idx": 6308, "_split": "valid", "_hash": "82b9a1c9a046a0172c9edc812b2edf3e"}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "int kvm_arch_init(MachineState *ms, KVMState *s)\n\n{\n\n    MachineClass *mc = MACHINE_GET_CLASS(ms);\n\n\n\n    mc->default_cpu_type = S390_CPU_TYPE_NAME(\"host\");\n\n    cap_sync_regs = kvm_check_extension(s, KVM_CAP_SYNC_REGS);\n\n    cap_async_pf = kvm_check_extension(s, KVM_CAP_ASYNC_PF);\n\n    cap_mem_op = kvm_check_extension(s, KVM_CAP_S390_MEM_OP);\n\n    cap_s390_irq = kvm_check_extension(s, KVM_CAP_S390_INJECT_IRQ);\n\n\n\n    if (!kvm_check_extension(s, KVM_CAP_S390_GMAP)\n\n        || !kvm_check_extension(s, KVM_CAP_S390_COW)) {\n\n        phys_mem_set_alloc(legacy_s390_alloc);\n\n    }\n\n\n\n    kvm_vm_enable_cap(s, KVM_CAP_S390_USER_SIGP, 0);\n\n    kvm_vm_enable_cap(s, KVM_CAP_S390_VECTOR_REGISTERS, 0);\n\n    kvm_vm_enable_cap(s, KVM_CAP_S390_USER_STSI, 0);\n\n    if (ri_allowed()) {\n\n        if (kvm_vm_enable_cap(s, KVM_CAP_S390_RI, 0) == 0) {\n\n            cap_ri = 1;\n\n        }\n\n    }\n\n    if (gs_allowed()) {\n\n        if (kvm_vm_enable_cap(s, KVM_CAP_S390_GS, 0) == 0) {\n\n            cap_gs = 1;\n\n        }\n\n    }\n\n\n\n    /*\n\n     * The migration interface for ais was introduced with kernel 4.13\n\n     * but the capability itself had been active since 4.12. As migration\n\n     * support is considered necessary let's disable ais in the 2.10\n\n     * machine.\n\n     */\n\n    /* kvm_vm_enable_cap(s, KVM_CAP_S390_AIS, 0); */\n\n\n\n    return 0;\n\n}\n", "idx": 6314, "_split": "valid", "_hash": "84b929b319478da4668e748eac8bfa68"}
{"project": "qemu", "commit_id": "366d4f7e0007a5540897fbac6e377c57d8c79a73", "target": 1, "func": "static void cg3_reg_write(void *opaque, hwaddr addr, uint64_t val,\n\n                          unsigned size)\n\n{\n\n    CG3State *s = opaque;\n\n    uint8_t regval;\n\n    int i;\n\n\n\n    DPRINTF(\"write %\" PRIx64 \" to reg %\" HWADDR_PRIx \" size %d\\n\",\n\n            val, addr, size);\n\n\n\n    switch (addr) {\n\n    case CG3_REG_BT458_ADDR:\n\n        s->dac_index = val;\n\n        s->dac_state = 0;\n\n        break;\n\n    case CG3_REG_BT458_COLMAP:\n\n        /* This register can be written to as either a long word or a byte */\n\n        if (size == 1) {\n\n            val <<= 24;\n\n        }\n\n\n\n        for (i = 0; i < size; i++) {\n\n            regval = val >> 24;\n\n\n\n            switch (s->dac_state) {\n\n            case 0:\n\n                s->r[s->dac_index] = regval;\n\n                s->dac_state++;\n\n                break;\n\n            case 1:\n\n                s->g[s->dac_index] = regval;\n\n                s->dac_state++;\n\n                break;\n\n            case 2:\n\n                s->b[s->dac_index] = regval;\n\n                /* Index autoincrement */\n\n                s->dac_index = (s->dac_index + 1) & 0xff;\n\n            default:\n\n                s->dac_state = 0;\n\n                break;\n\n            }\n\n            val <<= 8;\n\n        }\n\n        s->full_update = 1;\n\n        break;\n\n    case CG3_REG_FBC_CTRL:\n\n        s->regs[0] = val;\n\n        break;\n\n    case CG3_REG_FBC_STATUS:\n\n        if (s->regs[1] & CG3_SR_PENDING_INT) {\n\n            /* clear interrupt */\n\n            s->regs[1] &= ~CG3_SR_PENDING_INT;\n\n            qemu_irq_lower(s->irq);\n\n        }\n\n        break;\n\n    case CG3_REG_FBC_CURSTART ... CG3_REG_SIZE:\n\n        s->regs[addr - 0x10] = val;\n\n        break;\n\n    default:\n\n        qemu_log_mask(LOG_UNIMP,\n\n                  \"cg3: Unimplemented register write \"\n\n                  \"reg 0x%\" HWADDR_PRIx \" size 0x%x value 0x%\" PRIx64 \"\\n\",\n\n                  addr, size, val);\n\n        break;\n\n    }\n\n}\n", "idx": 6339, "_split": "valid", "_hash": "948fe727695b5c52732f23cc3815576f"}
{"project": "qemu", "commit_id": "c5825ac6c861bfe1a4adfa27517931b56079e298", "target": 1, "func": "static void qxl_dirty_surfaces(PCIQXLDevice *qxl)\n\n{\n\n    intptr_t vram_start;\n\n    int i;\n\n\n\n    if (qxl->mode != QXL_MODE_NATIVE && qxl->mode != QXL_MODE_COMPAT) {\n\n        return;\n\n    }\n\n\n\n    /* dirty the primary surface */\n\n    qxl_set_dirty(&qxl->vga.vram, qxl->shadow_rom.draw_area_offset,\n\n                  qxl->shadow_rom.surface0_area_size);\n\n\n\n    vram_start =  (intptr_t)memory_region_get_ram_ptr(&qxl->vram_bar);\n\n\n\n    /* dirty the off-screen surfaces */\n\n    for (i = 0; i < qxl->ssd.num_surfaces; i++) {\n\n        QXLSurfaceCmd *cmd;\n\n        intptr_t surface_offset;\n\n        int surface_size;\n\n\n\n        if (qxl->guest_surfaces.cmds[i] == 0) {\n\n            continue;\n\n        }\n\n\n\n        cmd = qxl_phys2virt(qxl, qxl->guest_surfaces.cmds[i],\n\n                            MEMSLOT_GROUP_GUEST);\n\n        assert(cmd);\n\n        assert(cmd->type == QXL_SURFACE_CMD_CREATE);\n\n        surface_offset = (intptr_t)qxl_phys2virt(qxl,\n\n                                                 cmd->u.surface_create.data,\n\n                                                 MEMSLOT_GROUP_GUEST);\n\n        assert(surface_offset);\n\n        surface_offset -= vram_start;\n\n        surface_size = cmd->u.surface_create.height *\n\n                       abs(cmd->u.surface_create.stride);\n\n        trace_qxl_surfaces_dirty(qxl->id, i, (int)surface_offset, surface_size);\n\n        qxl_set_dirty(&qxl->vram_bar, surface_offset, surface_size);\n\n    }\n\n}\n", "idx": 6352, "_split": "valid", "_hash": "f0bf7e7fb6d46e8609935b10489ce33d"}
{"project": "qemu", "commit_id": "69b302b2044a9a0f6d157d25b39a91ff7124c61f", "target": 1, "func": "VirtIODevice *virtio_blk_init(DeviceState *dev, VirtIOBlkConf *blk)\n\n{\n\n    VirtIOBlock *s;\n\n    static int virtio_blk_id;\n\n\n\n    if (!blk->conf.bs) {\n\n        error_report(\"drive property not set\");\n\n        return NULL;\n\n    }\n\n    if (!bdrv_is_inserted(blk->conf.bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return NULL;\n\n    }\n\n\n\n    blkconf_serial(&blk->conf, &blk->serial);\n\n    if (blkconf_geometry(&blk->conf, NULL, 65535, 255, 255) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.set_config = virtio_blk_set_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.set_status = virtio_blk_set_status;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = blk->conf.bs;\n\n    s->conf = &blk->conf;\n\n    s->blk = blk;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE\n\n    if (!virtio_blk_data_plane_create(&s->vdev, blk, &s->dataplane)) {\n\n        virtio_cleanup(&s->vdev);\n\n        return NULL;\n\n    }\n\n#endif\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    s->qdev = dev;\n\n    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n\n    bdrv_set_buffer_alignment(s->bs, s->conf->logical_block_size);\n\n\n\n    bdrv_iostatus_enable(s->bs);\n\n    add_boot_device_path(s->conf->bootindex, dev, \"/disk@0,0\");\n\n\n\n    return &s->vdev;\n\n}\n", "idx": 6361, "_split": "valid", "_hash": "6e1d702246b43bb1bc315b85e6ab4a78"}
{"project": "qemu", "commit_id": "fe25591e7b98386cce2c9ec8a8878947b50e3741", "target": 1, "func": "void _decode_opc(DisasContext * ctx)\n\n{\n\n#if 0\n\n    fprintf(stderr, \"Translating opcode 0x%04x\\n\", ctx->opcode);\n\n#endif\n\n    switch (ctx->opcode) {\n\n    case 0x0019:\t\t/* div0u */\n\n\ttcg_gen_andi_i32(cpu_sr, cpu_sr, ~(SR_M | SR_Q | SR_T));\n\n\treturn;\n\n    case 0x000b:\t\t/* rts */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, cpu_pr);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0028:\t\t/* clrmac */\n\n\ttcg_gen_movi_i32(cpu_mach, 0);\n\n\ttcg_gen_movi_i32(cpu_macl, 0);\n\n\treturn;\n\n    case 0x0048:\t\t/* clrs */\n\n\ttcg_gen_andi_i32(cpu_sr, cpu_sr, ~SR_S);\n\n\treturn;\n\n    case 0x0008:\t\t/* clrt */\n\n\tgen_clr_t();\n\n\treturn;\n\n    case 0x0038:\t\t/* ldtlb */\n\n#if defined(CONFIG_USER_ONLY)\n\n\tassert(0);\t\t/* XXXXX */\n\n#else\n\n\ttcg_gen_helper_0_0(helper_ldtlb);\n\n#endif\n\n\treturn;\n\n    case 0x002b:\t\t/* rte */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_sr, cpu_ssr);\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, cpu_spc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0058:\t\t/* sets */\n\n\ttcg_gen_ori_i32(cpu_sr, cpu_sr, SR_S);\n\n\treturn;\n\n    case 0x0018:\t\t/* sett */\n\n\tgen_set_t();\n\n\treturn;\n\n    case 0xfbfd:\t\t/* frchg */\n\n\ttcg_gen_xori_i32(cpu_fpscr, cpu_fpscr, FPSCR_FR);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0xf3fd:\t\t/* fschg */\n\n\ttcg_gen_xori_i32(cpu_fpscr, cpu_fpscr, FPSCR_SZ);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x0009:\t\t/* nop */\n\n\treturn;\n\n    case 0x001b:\t\t/* sleep */\n\n\tif (ctx->memidx) {\n\n\t\ttcg_gen_helper_0_1(helper_sleep, tcg_const_i32(ctx->pc + 2));\n\n\t} else {\n\n\t\ttcg_gen_helper_0_0(helper_raise_illegal_instruction);\n\n\t\tctx->bstate = BS_EXCP;\n\n\t}\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf000) {\n\n    case 0x1000:\t\t/* mov.l Rm,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_addi_i32(addr, REG(B11_8), B3_0 * 4);\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x5000:\t\t/* mov.l @(disp,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 4);\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xe000:\t\t/* mov #imm,Rn */\n\n\ttcg_gen_movi_i32(REG(B11_8), B7_0s);\n\n\treturn;\n\n    case 0x9000:\t\t/* mov.w @(disp,PC),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_const_i32(ctx->pc + 4 + B7_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xd000:\t\t/* mov.l @(disp,PC),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_const_i32((ctx->pc + 4 + B7_0 * 4) & ~3);\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x7000:\t\t/* add #imm,Rn */\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), B7_0s);\n\n\treturn;\n\n    case 0xa000:\t\t/* bra disp */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tctx->delayed_pc = ctx->pc + 4 + B11_0s * 2;\n\n\ttcg_gen_movi_i32(cpu_delayed_pc, ctx->delayed_pc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\treturn;\n\n    case 0xb000:\t\t/* bsr disp */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\tctx->delayed_pc = ctx->pc + 4 + B11_0s * 2;\n\n\ttcg_gen_movi_i32(cpu_delayed_pc, ctx->delayed_pc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf00f) {\n\n    case 0x6003:\t\t/* mov Rm,Rn */\n\n\ttcg_gen_mov_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x2000:\t\t/* mov.b Rm,@Rn */\n\n\ttcg_gen_qemu_st8(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x2001:\t\t/* mov.w Rm,@Rn */\n\n\ttcg_gen_qemu_st16(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x2002:\t\t/* mov.l Rm,@Rn */\n\n\ttcg_gen_qemu_st32(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x6000:\t\t/* mov.b @Rm,Rn */\n\n\ttcg_gen_qemu_ld8s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x6001:\t\t/* mov.w @Rm,Rn */\n\n\ttcg_gen_qemu_ld16s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x6002:\t\t/* mov.l @Rm,Rn */\n\n\ttcg_gen_qemu_ld32s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x2004:\t\t/* mov.b Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 1);\n\n\t    tcg_gen_qemu_st8(REG(B7_4), addr, ctx->memidx);\t/* might cause re-execution */\n\n\t    tcg_gen_subi_i32(REG(B11_8), REG(B11_8), 1);\t/* modify register status */\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x2005:\t\t/* mov.w Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 2);\n\n\t    tcg_gen_qemu_st16(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_gen_subi_i32(REG(B11_8), REG(B11_8), 2);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x2006:\t\t/* mov.l Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_gen_subi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t}\n\n\treturn;\n\n    case 0x6004:\t\t/* mov.b @Rm+,Rn */\n\n\ttcg_gen_qemu_ld8s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 1);\n\n\treturn;\n\n    case 0x6005:\t\t/* mov.w @Rm+,Rn */\n\n\ttcg_gen_qemu_ld16s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 2);\n\n\treturn;\n\n    case 0x6006:\t\t/* mov.l @Rm+,Rn */\n\n\ttcg_gen_qemu_ld32s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\treturn;\n\n    case 0x0004:\t\t/* mov.b Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st8(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x0005:\t\t/* mov.w Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st16(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x0006:\t\t/* mov.l Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000c:\t\t/* mov.b @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld8s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000d:\t\t/* mov.w @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld16s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000e:\t\t/* mov.l @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x6008:\t\t/* swap.b Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_ext8u_i32(high, REG(B7_4));\n\n\t    tcg_gen_shli_i32(high, high, 8);\n\n\t    low = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_shri_i32(low, REG(B7_4), 8);\n\n\t    tcg_gen_ext8u_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x6009:\t\t/* swap.w Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_ext16u_i32(high, REG(B7_4));\n\n\t    tcg_gen_shli_i32(high, high, 16);\n\n\t    low = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_shri_i32(low, REG(B7_4), 16);\n\n\t    tcg_gen_ext16u_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x200d:\t\t/* xtrct Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_ext16u_i32(high, REG(B7_4));\n\n\t    tcg_gen_shli_i32(high, high, 16);\n\n\t    low = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_shri_i32(low, REG(B11_8), 16);\n\n\t    tcg_gen_ext16u_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x300c:\t\t/* add Rm,Rn */\n\n\ttcg_gen_add_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x300e:\t\t/* addc Rm,Rn */\n\n\ttcg_gen_helper_1_2(helper_addc, REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300f:\t\t/* addv Rm,Rn */\n\n\ttcg_gen_helper_1_2(helper_addv, REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x2009:\t\t/* and Rm,Rn */\n\n\ttcg_gen_and_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x3000:\t\t/* cmp/eq Rm,Rn */\n\n\tgen_cmp(TCG_COND_EQ, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3003:\t\t/* cmp/ge Rm,Rn */\n\n\tgen_cmp(TCG_COND_GE, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3007:\t\t/* cmp/gt Rm,Rn */\n\n\tgen_cmp(TCG_COND_GT, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3006:\t\t/* cmp/hi Rm,Rn */\n\n\tgen_cmp(TCG_COND_GTU, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3002:\t\t/* cmp/hs Rm,Rn */\n\n\tgen_cmp(TCG_COND_GEU, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x200c:\t\t/* cmp/str Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    TCGv cmp1 = tcg_temp_local_new(TCG_TYPE_I32);\n\n\t    TCGv cmp2 = tcg_temp_local_new(TCG_TYPE_I32);\n\n\t    tcg_gen_xor_i32(cmp1, REG(B7_4), REG(B11_8));\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0xff000000);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x00ff0000);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x0000ff00);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x000000ff);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cpu_sr, cpu_sr, ~SR_T);\n\n\t    tcg_gen_br(label2);\n\n\t    gen_set_label(label1);\n\n\t    tcg_gen_ori_i32(cpu_sr, cpu_sr, SR_T);\n\n\t    gen_set_label(label2);\n\n\t    tcg_temp_free(cmp2);\n\n\t    tcg_temp_free(cmp1);\n\n\t}\n\n\treturn;\n\n    case 0x2007:\t\t/* div0s Rm,Rn */\n\n\t{\n\n\t    gen_copy_bit_i32(cpu_sr, 8, REG(B11_8), 31);\t/* SR_Q */\n\n\t    gen_copy_bit_i32(cpu_sr, 9, REG(B7_4), 31);\t\t/* SR_M */\n\n\t    TCGv val = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_xor_i32(val, REG(B7_4), REG(B11_8));\n\n\t    gen_copy_bit_i32(cpu_sr, 0, val, 31);\t\t/* SR_T */\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x3004:\t\t/* div1 Rm,Rn */\n\n\ttcg_gen_helper_1_2(helper_div1, REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300d:\t\t/* dmuls.l Rm,Rn */\n\n\t{\n\n\t    TCGv tmp1 = tcg_temp_new(TCG_TYPE_I64);\n\n\t    TCGv tmp2 = tcg_temp_new(TCG_TYPE_I64);\n\n\n\n\t    tcg_gen_ext_i32_i64(tmp1, REG(B7_4));\n\n\t    tcg_gen_ext_i32_i64(tmp2, REG(B11_8));\n\n\t    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n\n\t    tcg_gen_trunc_i64_i32(cpu_macl, tmp1);\n\n\t    tcg_gen_shri_i64(tmp1, tmp1, 32);\n\n\t    tcg_gen_trunc_i64_i32(cpu_mach, tmp1);\n\n\n\n\t    tcg_temp_free(tmp2);\n\n\t    tcg_temp_free(tmp1);\n\n\t}\n\n\treturn;\n\n    case 0x3005:\t\t/* dmulu.l Rm,Rn */\n\n\t{\n\n\t    TCGv tmp1 = tcg_temp_new(TCG_TYPE_I64);\n\n\t    TCGv tmp2 = tcg_temp_new(TCG_TYPE_I64);\n\n\n\n\t    tcg_gen_extu_i32_i64(tmp1, REG(B7_4));\n\n\t    tcg_gen_extu_i32_i64(tmp2, REG(B11_8));\n\n\t    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n\n\t    tcg_gen_trunc_i64_i32(cpu_macl, tmp1);\n\n\t    tcg_gen_shri_i64(tmp1, tmp1, 32);\n\n\t    tcg_gen_trunc_i64_i32(cpu_mach, tmp1);\n\n\n\n\t    tcg_temp_free(tmp2);\n\n\t    tcg_temp_free(tmp1);\n\n\t}\n\n\treturn;\n\n    case 0x600e:\t\t/* exts.b Rm,Rn */\n\n\ttcg_gen_ext8s_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600f:\t\t/* exts.w Rm,Rn */\n\n\ttcg_gen_ext16s_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600c:\t\t/* extu.b Rm,Rn */\n\n\ttcg_gen_ext8u_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600d:\t\t/* extu.w Rm,Rn */\n\n\ttcg_gen_ext16u_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x000f:\t\t/* mac.l @Rm+,@Rn+ */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_qemu_ld32s(arg0, REG(B7_4), ctx->memidx);\n\n\t    arg1 = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_qemu_ld32s(arg1, REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_helper_0_2(helper_macl, arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t}\n\n\treturn;\n\n    case 0x400f:\t\t/* mac.w @Rm+,@Rn+ */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_qemu_ld32s(arg0, REG(B7_4), ctx->memidx);\n\n\t    arg1 = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_qemu_ld32s(arg1, REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_helper_0_2(helper_macw, arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 2);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 2);\n\n\t}\n\n\treturn;\n\n    case 0x0007:\t\t/* mul.l Rm,Rn */\n\n\ttcg_gen_mul_i32(cpu_macl, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x200f:\t\t/* muls.w Rm,Rn */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_ext16s_i32(arg0, REG(B7_4));\n\n\t    arg1 = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_ext16s_i32(arg1, REG(B11_8));\n\n\t    tcg_gen_mul_i32(cpu_macl, arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t}\n\n\treturn;\n\n    case 0x200e:\t\t/* mulu.w Rm,Rn */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_ext16u_i32(arg0, REG(B7_4));\n\n\t    arg1 = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_ext16u_i32(arg1, REG(B11_8));\n\n\t    tcg_gen_mul_i32(cpu_macl, arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t}\n\n\treturn;\n\n    case 0x600b:\t\t/* neg Rm,Rn */\n\n\ttcg_gen_neg_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600a:\t\t/* negc Rm,Rn */\n\n\ttcg_gen_helper_1_1(helper_negc, REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x6007:\t\t/* not Rm,Rn */\n\n\ttcg_gen_not_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x200b:\t\t/* or Rm,Rn */\n\n\ttcg_gen_or_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x400c:\t\t/* shad Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    int label3 = gen_new_label();\n\n\t    int label4 = gen_new_label();\n\n\t    TCGv shift = tcg_temp_local_new(TCG_TYPE_I32);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B7_4), 0, label1);\n\n\t    /* Rm positive, shift to the left */\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_shl_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_gen_br(label4);\n\n\t    /* Rm negative, shift to the right */\n\n\t    gen_set_label(label1);\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, shift, 0, label2);\n\n\t    tcg_gen_not_i32(shift, REG(B7_4));\n\n\t    tcg_gen_andi_i32(shift, shift, 0x1f);\n\n\t    tcg_gen_addi_i32(shift, shift, 1);\n\n\t    tcg_gen_sar_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_gen_br(label4);\n\n\t    /* Rm = -32 */\n\n\t    gen_set_label(label2);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B11_8), 0, label3);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0);\n\n\t    tcg_gen_br(label4);\n\n\t    gen_set_label(label3);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0xffffffff);\n\n\t    gen_set_label(label4);\n\n\t    tcg_temp_free(shift);\n\n\t}\n\n\treturn;\n\n    case 0x400d:\t\t/* shld Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    int label3 = gen_new_label();\n\n\t    TCGv shift = tcg_temp_local_new(TCG_TYPE_I32);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B7_4), 0, label1);\n\n\t    /* Rm positive, shift to the left */\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_shl_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_gen_br(label3);\n\n\t    /* Rm negative, shift to the right */\n\n\t    gen_set_label(label1);\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, shift, 0, label2);\n\n\t    tcg_gen_not_i32(shift, REG(B7_4));\n\n\t    tcg_gen_andi_i32(shift, shift, 0x1f);\n\n\t    tcg_gen_addi_i32(shift, shift, 1);\n\n\t    tcg_gen_shr_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_gen_br(label3);\n\n\t    /* Rm = -32 */\n\n\t    gen_set_label(label2);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0);\n\n\t    gen_set_label(label3);\n\n\t    tcg_temp_free(shift);\n\n\t}\n\n\treturn;\n\n    case 0x3008:\t\t/* sub Rm,Rn */\n\n\ttcg_gen_sub_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x300a:\t\t/* subc Rm,Rn */\n\n\ttcg_gen_helper_1_2(helper_subc, REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300b:\t\t/* subv Rm,Rn */\n\n\ttcg_gen_helper_1_2(helper_subv, REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x2008:\t\t/* tst Rm,Rn */\n\n\t{\n\n\t    TCGv val = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_and_i32(val, REG(B7_4), REG(B11_8));\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x200a:\t\t/* xor Rm,Rn */\n\n\ttcg_gen_xor_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0xf00c: /* fmov {F,D,X}Rm,{F,D,X}Rn - FPSCR: Nothing */\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv fp = tcg_temp_new(TCG_TYPE_I64);\n\n\t    gen_load_fpr64(fp, XREG(B7_4));\n\n\t    gen_store_fpr64(fp, XREG(B11_8));\n\n\t    tcg_temp_free(fp);\n\n\t} else {\n\n\t    TCGv fp = tcg_temp_new(TCG_TYPE_I32);\n\n\t    gen_load_fpr32(fp, FREG(B7_4));\n\n\t    gen_store_fpr32(fp, FREG(B11_8));\n\n\t    tcg_temp_free(fp);\n\n\t}\n\n\treturn;\n\n    case 0xf00a: /* fmov {F,D,X}Rm,@Rn - FPSCR: Nothing */\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv fp = tcg_temp_new(TCG_TYPE_I64);\n\n\t    gen_load_fpr64(fp, XREG(B7_4));\n\n\t    tcg_gen_qemu_st64(fp, REG(B11_8), ctx->memidx);\n\n\t    tcg_temp_free(fp);\n\n\t} else {\n\n\t    TCGv fp = tcg_temp_new(TCG_TYPE_I32);\n\n\t    gen_load_fpr32(fp, FREG(B7_4));\n\n\t    tcg_gen_qemu_st32(fp, REG(B11_8), ctx->memidx);\n\n\t    tcg_temp_free(fp);\n\n\t}\n\n\treturn;\n\n    case 0xf008: /* fmov @Rm,{F,D,X}Rn - FPSCR: Nothing */\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv fp = tcg_temp_new(TCG_TYPE_I64);\n\n\t    tcg_gen_qemu_ld64(fp, REG(B7_4), ctx->memidx);\n\n\t    gen_store_fpr64(fp, XREG(B11_8));\n\n\t    tcg_temp_free(fp);\n\n\t} else {\n\n\t    TCGv fp = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_qemu_ld32u(fp, REG(B7_4), ctx->memidx);\n\n\t    gen_store_fpr32(fp, FREG(B11_8));\n\n\t    tcg_temp_free(fp);\n\n\t}\n\n\treturn;\n\n    case 0xf009: /* fmov @Rm+,{F,D,X}Rn - FPSCR: Nothing */\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv fp = tcg_temp_new(TCG_TYPE_I64);\n\n\t    tcg_gen_qemu_ld64(fp, REG(B7_4), ctx->memidx);\n\n\t    gen_store_fpr64(fp, XREG(B11_8));\n\n\t    tcg_temp_free(fp);\n\n\t    tcg_gen_addi_i32(REG(B7_4),REG(B7_4), 8);\n\n\t} else {\n\n\t    TCGv fp = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_qemu_ld32u(fp, REG(B7_4), ctx->memidx);\n\n\t    gen_store_fpr32(fp, FREG(B11_8));\n\n\t    tcg_temp_free(fp);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\t}\n\n\treturn;\n\n    case 0xf00b: /* fmov {F,D,X}Rm,@-Rn - FPSCR: Nothing */\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr, fp;\n\n\t    addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 8);\n\n\t    fp = tcg_temp_new(TCG_TYPE_I64);\n\n\t    gen_load_fpr64(fp, XREG(B7_4));\n\n\t    tcg_gen_qemu_st64(fp, addr, ctx->memidx);\n\n\t    tcg_temp_free(fp);\n\n\t    tcg_temp_free(addr);\n\n\t    tcg_gen_subi_i32(REG(B11_8), REG(B11_8), 8);\n\n\t} else {\n\n\t    TCGv addr, fp;\n\n\t    addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    fp = tcg_temp_new(TCG_TYPE_I32);\n\n\t    gen_load_fpr32(fp, FREG(B7_4));\n\n\t    tcg_gen_qemu_st32(fp, addr, ctx->memidx);\n\n\t    tcg_temp_free(fp);\n\n\t    tcg_temp_free(addr);\n\n\t    tcg_gen_subi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t}\n\n\treturn;\n\n    case 0xf006: /* fmov @(R0,Rm),{F,D,X}Rm - FPSCR: Nothing */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    if (ctx->fpscr & FPSCR_SZ) {\n\n\t\tTCGv fp = tcg_temp_new(TCG_TYPE_I64);\n\n\t\ttcg_gen_qemu_ld64(fp, addr, ctx->memidx);\n\n\t\tgen_store_fpr64(fp, XREG(B11_8));\n\n\t\ttcg_temp_free(fp);\n\n\t    } else {\n\n\t\tTCGv fp = tcg_temp_new(TCG_TYPE_I32);\n\n\t\ttcg_gen_qemu_ld32u(fp, addr, ctx->memidx);\n\n\t\tgen_store_fpr32(fp, FREG(B11_8));\n\n\t\ttcg_temp_free(fp);\n\n\t    }\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf007: /* fmov {F,D,X}Rn,@(R0,Rn) - FPSCR: Nothing */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    if (ctx->fpscr & FPSCR_SZ) {\n\n\t\tTCGv fp = tcg_temp_new(TCG_TYPE_I64);\n\n\t\tgen_load_fpr64(fp, XREG(B7_4));\n\n\t\ttcg_gen_qemu_st64(fp, addr, ctx->memidx);\n\n\t\ttcg_temp_free(fp);\n\n\t    } else {\n\n\t\tTCGv fp = tcg_temp_new(TCG_TYPE_I32);\n\n\t\tgen_load_fpr32(fp, FREG(B7_4));\n\n\t\ttcg_gen_qemu_st32(fp, addr, ctx->memidx);\n\n\t\ttcg_temp_free(fp);\n\n\t    }\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf000: /* fadd Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf001: /* fsub Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf002: /* fmul Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf003: /* fdiv Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf004: /* fcmp/eq Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n    case 0xf005: /* fcmp/gt Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n\t{\n\n\t    TCGv fp0, fp1;\n\n\n\n\t    if (ctx->fpscr & FPSCR_PR) {\n\n\t\tif (ctx->opcode & 0x0110)\n\n\t\t    break; /* illegal instruction */\n\n\t\tfp0 = tcg_temp_new(TCG_TYPE_I64);\n\n\t\tfp1 = tcg_temp_new(TCG_TYPE_I64);\n\n\t\tgen_load_fpr64(fp0, DREG(B11_8));\n\n\t\tgen_load_fpr64(fp1, DREG(B7_4));\n\n\t    }\n\n\t    else {\n\n\t\tfp0 = tcg_temp_new(TCG_TYPE_I32);\n\n\t\tfp1 = tcg_temp_new(TCG_TYPE_I32);\n\n\t\tgen_load_fpr32(fp0, FREG(B11_8));\n\n\t\tgen_load_fpr32(fp1, FREG(B7_4));\n\n\t    }\n\n\n\n\t    switch (ctx->opcode & 0xf00f) {\n\n\t    case 0xf000:\t\t/* fadd Rm,Rn */\n\n\t\tif (ctx->fpscr & FPSCR_PR)\n\n\t\t    tcg_gen_helper_1_2(helper_fadd_DT, fp0, fp0, fp1);\n\n\t\telse\n\n\t\t    tcg_gen_helper_1_2(helper_fadd_FT, fp0, fp0, fp1);\n\n\t\tbreak;\n\n\t    case 0xf001:\t\t/* fsub Rm,Rn */\n\n\t\tif (ctx->fpscr & FPSCR_PR)\n\n\t\t    tcg_gen_helper_1_2(helper_fsub_DT, fp0, fp0, fp1);\n\n\t\telse\n\n\t\t    tcg_gen_helper_1_2(helper_fsub_FT, fp0, fp0, fp1);\n\n\t\tbreak;\n\n\t    case 0xf002:\t\t/* fmul Rm,Rn */\n\n\t\tif (ctx->fpscr & FPSCR_PR)\n\n\t\t    tcg_gen_helper_1_2(helper_fmul_DT, fp0, fp0, fp1);\n\n\t\telse\n\n\t\t    tcg_gen_helper_1_2(helper_fmul_FT, fp0, fp0, fp1);\n\n\t\tbreak;\n\n\t    case 0xf003:\t\t/* fdiv Rm,Rn */\n\n\t\tif (ctx->fpscr & FPSCR_PR)\n\n\t\t    tcg_gen_helper_1_2(helper_fdiv_DT, fp0, fp0, fp1);\n\n\t\telse\n\n\t\t    tcg_gen_helper_1_2(helper_fdiv_FT, fp0, fp0, fp1);\n\n\t\tbreak;\n\n\t    case 0xf004:\t\t/* fcmp/eq Rm,Rn */\n\n\t\tif (ctx->fpscr & FPSCR_PR)\n\n\t\t    tcg_gen_helper_0_2(helper_fcmp_eq_DT, fp0, fp1);\n\n\t\telse\n\n\t\t    tcg_gen_helper_0_2(helper_fcmp_eq_FT, fp0, fp1);\n\n\t\treturn;\n\n\t    case 0xf005:\t\t/* fcmp/gt Rm,Rn */\n\n\t\tif (ctx->fpscr & FPSCR_PR)\n\n\t\t    tcg_gen_helper_0_2(helper_fcmp_gt_DT, fp0, fp1);\n\n\t\telse\n\n\t\t    tcg_gen_helper_0_2(helper_fcmp_gt_FT, fp0, fp1);\n\n\t\treturn;\n\n\t    }\n\n\n\n\t    if (ctx->fpscr & FPSCR_PR) {\n\n\t\tgen_store_fpr64(fp0, DREG(B11_8));\n\n\t    }\n\n\t    else {\n\n\t\tgen_store_fpr32(fp0, FREG(B11_8));\n\n\t    }\n\n\t    tcg_temp_free(fp1);\n\n\t    tcg_temp_free(fp0);\n\n\t}\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xff00) {\n\n    case 0xc900:\t\t/* and #imm,R0 */\n\n\ttcg_gen_andi_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xcd00:\t\t/* and.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_andi_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8b00:\t\t/* bf label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\t    gen_conditional_jump(ctx, ctx->pc + 2,\n\n\t\t\t\t ctx->pc + 4 + B7_0s * 2);\n\n\tctx->bstate = BS_BRANCH;\n\n\treturn;\n\n    case 0x8f00:\t\t/* bf/s label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tgen_branch_slot(ctx->delayed_pc = ctx->pc + 4 + B7_0s * 2, 0);\n\n\tctx->flags |= DELAY_SLOT_CONDITIONAL;\n\n\treturn;\n\n    case 0x8900:\t\t/* bt label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\t    gen_conditional_jump(ctx, ctx->pc + 4 + B7_0s * 2,\n\n\t\t\t\t ctx->pc + 2);\n\n\tctx->bstate = BS_BRANCH;\n\n\treturn;\n\n    case 0x8d00:\t\t/* bt/s label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tgen_branch_slot(ctx->delayed_pc = ctx->pc + 4 + B7_0s * 2, 1);\n\n\tctx->flags |= DELAY_SLOT_CONDITIONAL;\n\n\treturn;\n\n    case 0x8800:\t\t/* cmp/eq #imm,R0 */\n\n\tgen_cmp_imm(TCG_COND_EQ, REG(0), B7_0s);\n\n\treturn;\n\n    case 0xc400:\t\t/* mov.b @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0);\n\n\t    tcg_gen_qemu_ld8s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc500:\t\t/* mov.w @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc600:\t\t/* mov.l @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 4);\n\n\t    tcg_gen_qemu_ld32s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc000:\t\t/* mov.b R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0);\n\n\t    tcg_gen_qemu_st8(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc100:\t\t/* mov.w R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 2);\n\n\t    tcg_gen_qemu_st16(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc200:\t\t/* mov.l R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 4);\n\n\t    tcg_gen_qemu_st32(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8000:\t\t/* mov.b R0,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0);\n\n\t    tcg_gen_qemu_st8(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8100:\t\t/* mov.w R0,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 2);\n\n\t    tcg_gen_qemu_st16(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8400:\t\t/* mov.b @(disp,Rn),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0);\n\n\t    tcg_gen_qemu_ld8s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8500:\t\t/* mov.w @(disp,Rn),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc700:\t\t/* mova @(disp,PC),R0 */\n\n\ttcg_gen_movi_i32(REG(0), ((ctx->pc & 0xfffffffc) + 4 + B7_0 * 4) & ~3);\n\n\treturn;\n\n    case 0xcb00:\t\t/* or #imm,R0 */\n\n\ttcg_gen_ori_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xcf00:\t\t/* or.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_ori_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc300:\t\t/* trapa #imm */\n\n\t{\n\n\t    TCGv imm;\n\n\t    CHECK_NOT_DELAY_SLOT\n\n\t    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n\t    imm = tcg_const_i32(B7_0);\n\n\t    tcg_gen_helper_0_1(helper_trapa, imm);\n\n\t    tcg_temp_free(imm);\n\n\t    ctx->bstate = BS_BRANCH;\n\n\t}\n\n\treturn;\n\n    case 0xc800:\t\t/* tst #imm,R0 */\n\n\t{\n\n\t    TCGv val = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_andi_i32(val, REG(0), B7_0);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0xcc00:\t\t/* tst.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv val = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_add_i32(val, REG(0), cpu_gbr);\n\n\t    tcg_gen_qemu_ld8u(val, val, ctx->memidx);\n\n\t    tcg_gen_andi_i32(val, val, B7_0);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0xca00:\t\t/* xor #imm,R0 */\n\n\ttcg_gen_xori_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xce00:\t\t/* xor.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_xori_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf08f) {\n\n    case 0x408e:\t\t/* ldc Rm,Rn_BANK */\n\n\ttcg_gen_mov_i32(ALTREG(B6_4), REG(B11_8));\n\n\treturn;\n\n    case 0x4087:\t\t/* ldc.l @Rm+,Rn_BANK */\n\n\ttcg_gen_qemu_ld32s(ALTREG(B6_4), REG(B11_8), ctx->memidx);\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\treturn;\n\n    case 0x0082:\t\t/* stc Rm_BANK,Rn */\n\n\ttcg_gen_mov_i32(REG(B11_8), ALTREG(B6_4));\n\n\treturn;\n\n    case 0x4083:\t\t/* stc.l Rm_BANK,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(ALTREG(B6_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t    tcg_gen_subi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t}\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf0ff) {\n\n    case 0x0023:\t\t/* braf Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_addi_i32(cpu_delayed_pc, REG(B11_8), ctx->pc + 4);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0003:\t\t/* bsrf Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\ttcg_gen_add_i32(cpu_delayed_pc, REG(B11_8), cpu_pr);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x4015:\t\t/* cmp/pl Rn */\n\n\tgen_cmp_imm(TCG_COND_GT, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x4011:\t\t/* cmp/pz Rn */\n\n\tgen_cmp_imm(TCG_COND_GE, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x4010:\t\t/* dt Rn */\n\n\ttcg_gen_subi_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_cmp_imm(TCG_COND_EQ, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x402b:\t\t/* jmp @Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, REG(B11_8));\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x400b:\t\t/* jsr @Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, REG(B11_8));\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x400e:\t\t/* lds Rm,SR */\n\n\ttcg_gen_andi_i32(cpu_sr, REG(B11_8), 0x700083f3);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x4007:\t\t/* lds.l @Rm+,SR */\n\n\t{\n\n\t    TCGv val = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_qemu_ld32s(val, REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_andi_i32(cpu_sr, val, 0x700083f3);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t    ctx->bstate = BS_STOP;\n\n\t}\n\n\treturn;\n\n    case 0x0002:\t\t/* sts SR,Rn */\n\n\ttcg_gen_mov_i32(REG(B11_8), cpu_sr);\n\n\treturn;\n\n    case 0x4003:\t\t/* sts SR,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_sr, addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t    tcg_gen_subi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t}\n\n\treturn;\n\n#define LDST(reg,ldnum,ldpnum,stnum,stpnum)\t\t\t\\\n\n  case ldnum:\t\t\t\t\t\t\t\\\n\n    tcg_gen_mov_i32 (cpu_##reg, REG(B11_8));\t\t\t\\\n\n    return;\t\t\t\t\t\t\t\\\n\n  case ldpnum:\t\t\t\t\t\t\t\\\n\n    tcg_gen_qemu_ld32s (cpu_##reg, REG(B11_8), ctx->memidx);\t\\\n\n    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\t\t\\\n\n    return;\t\t\t\t\t\t\t\\\n\n  case stnum:\t\t\t\t\t\t\t\\\n\n    tcg_gen_mov_i32 (REG(B11_8), cpu_##reg);\t\t\t\\\n\n    return;\t\t\t\t\t\t\t\\\n\n  case stpnum:\t\t\t\t\t\t\t\\\n\n    {\t\t\t\t\t\t\t\t\\\n\n\tTCGv addr = tcg_temp_new(TCG_TYPE_I32);\t\t\t\\\n\n\ttcg_gen_subi_i32(addr, REG(B11_8), 4);\t\t\t\\\n\n\ttcg_gen_qemu_st32 (cpu_##reg, addr, ctx->memidx);\t\\\n\n\ttcg_temp_free(addr);\t\t\t\t\t\\\n\n\ttcg_gen_subi_i32(REG(B11_8), REG(B11_8), 4);\t\t\\\n\n    }\t\t\t\t\t\t\t\t\\\n\n    return;\n\n\tLDST(gbr,  0x401e, 0x4017, 0x0012, 0x4013)\n\n\tLDST(vbr,  0x402e, 0x4027, 0x0022, 0x4023)\n\n\tLDST(ssr,  0x403e, 0x4037, 0x0032, 0x4033)\n\n\tLDST(spc,  0x404e, 0x4047, 0x0042, 0x4043)\n\n\tLDST(dbr,  0x40fa, 0x40f6, 0x00fa, 0x40f2)\n\n\tLDST(mach, 0x400a, 0x4006, 0x000a, 0x4002)\n\n\tLDST(macl, 0x401a, 0x4016, 0x001a, 0x4012)\n\n\tLDST(pr,   0x402a, 0x4026, 0x002a, 0x4022)\n\n\tLDST(fpul, 0x405a, 0x4056, 0x005a, 0x4052)\n\n    case 0x406a:\t\t/* lds Rm,FPSCR */\n\n\ttcg_gen_helper_0_1(helper_ld_fpscr, REG(B11_8));\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x4066:\t\t/* lds.l @Rm+,FPSCR */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_qemu_ld32s(addr, REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t    tcg_gen_helper_0_1(helper_ld_fpscr, addr);\n\n\t    tcg_temp_free(addr);\n\n\t    ctx->bstate = BS_STOP;\n\n\t}\n\n\treturn;\n\n    case 0x006a:\t\t/* sts FPSCR,Rn */\n\n\ttcg_gen_andi_i32(REG(B11_8), cpu_fpscr, 0x003fffff);\n\n\treturn;\n\n    case 0x4062:\t\t/* sts FPSCR,@-Rn */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    val = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_andi_i32(val, cpu_fpscr, 0x003fffff);\n\n\t    addr = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_gen_subi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t}\n\n\treturn;\n\n    case 0x00c3:\t\t/* movca.l R0,@Rm */\n\n\ttcg_gen_qemu_st32(REG(0), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x0029:\t\t/* movt Rn */\n\n\ttcg_gen_andi_i32(REG(B11_8), cpu_sr, SR_T);\n\n\treturn;\n\n    case 0x0093:\t\t/* ocbi @Rn */\n\n\t{\n\n\t    TCGv dummy = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);\n\n\t    tcg_temp_free(dummy);\n\n\t}\n\n\treturn;\n\n    case 0x00a3:\t\t/* ocbp @Rn */\n\n\t{\n\n\t    TCGv dummy = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);\n\n\t    tcg_temp_free(dummy);\n\n\t}\n\n\treturn;\n\n    case 0x00b3:\t\t/* ocbwb @Rn */\n\n\t{\n\n\t    TCGv dummy = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);\n\n\t    tcg_temp_free(dummy);\n\n\t}\n\n\treturn;\n\n    case 0x0083:\t\t/* pref @Rn */\n\n\treturn;\n\n    case 0x4024:\t\t/* rotcl Rn */\n\n\t{\n\n\t    TCGv tmp = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_mov_i32(tmp, cpu_sr);\n\n\t    gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\t    tcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\t    gen_copy_bit_i32(REG(B11_8), 0, tmp, 0);\n\n\t    tcg_temp_free(tmp);\n\n\t}\n\n\treturn;\n\n    case 0x4025:\t\t/* rotcr Rn */\n\n\t{\n\n\t    TCGv tmp = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_mov_i32(tmp, cpu_sr);\n\n\t    gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\t    tcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\t    gen_copy_bit_i32(REG(B11_8), 31, tmp, 0);\n\n\t    tcg_temp_free(tmp);\n\n\t}\n\n\treturn;\n\n    case 0x4004:\t\t/* rotl Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_copy_bit_i32(REG(B11_8), 0, cpu_sr, 0);\n\n\treturn;\n\n    case 0x4005:\t\t/* rotr Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_copy_bit_i32(REG(B11_8), 31, cpu_sr, 0);\n\n\treturn;\n\n    case 0x4000:\t\t/* shll Rn */\n\n    case 0x4020:\t\t/* shal Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4021:\t\t/* shar Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_sari_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4001:\t\t/* shlr Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4008:\t\t/* shll2 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 2);\n\n\treturn;\n\n    case 0x4018:\t\t/* shll8 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 8);\n\n\treturn;\n\n    case 0x4028:\t\t/* shll16 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 16);\n\n\treturn;\n\n    case 0x4009:\t\t/* shlr2 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 2);\n\n\treturn;\n\n    case 0x4019:\t\t/* shlr8 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 8);\n\n\treturn;\n\n    case 0x4029:\t\t/* shlr16 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 16);\n\n\treturn;\n\n    case 0x401b:\t\t/* tas.b @Rn */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_local_new(TCG_TYPE_I32);\n\n\t    tcg_gen_mov_i32(addr, REG(B11_8));\n\n\t    val = tcg_temp_local_new(TCG_TYPE_I32);\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_gen_ori_i32(val, val, 0x80);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf00d: /* fsts FPUL,FRn - FPSCR: Nothing */\n\n\t{\n\n\t    TCGv fp = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_mov_i32(fp, cpu_fpul);\n\n\t    gen_store_fpr32(fp, FREG(B11_8));\n\n\t    tcg_temp_free(fp);\n\n\t}\n\n\treturn;\n\n    case 0xf01d: /* flds FRm,FPUL - FPSCR: Nothing */\n\n\t{\n\n\t    TCGv fp = tcg_temp_new(TCG_TYPE_I32);\n\n\t    gen_load_fpr32(fp, FREG(B11_8));\n\n\t    tcg_gen_mov_i32(cpu_fpul, fp);\n\n\t    tcg_temp_free(fp);\n\n\t}\n\n\treturn;\n\n    case 0xf02d: /* float FPUL,FRn/DRn - FPSCR: R[PR,Enable.I]/W[Cause,Flag] */\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    TCGv fp;\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    fp = tcg_temp_new(TCG_TYPE_I64);\n\n\t    tcg_gen_helper_1_1(helper_float_DT, fp, cpu_fpul);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free(fp);\n\n\t}\n\n\telse {\n\n\t    TCGv fp = tcg_temp_new(TCG_TYPE_I32);\n\n\t    tcg_gen_helper_1_1(helper_float_FT, fp, cpu_fpul);\n\n\t    gen_store_fpr32(fp, FREG(B11_8));\n\n\t    tcg_temp_free(fp);\n\n\t}\n\n\treturn;\n\n    case 0xf03d: /* ftrc FRm/DRm,FPUL - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    TCGv fp;\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    fp = tcg_temp_new(TCG_TYPE_I64);\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    tcg_gen_helper_1_1(helper_ftrc_DT, cpu_fpul, fp);\n\n\t    tcg_temp_free(fp);\n\n\t}\n\n\telse {\n\n\t    TCGv fp = tcg_temp_new(TCG_TYPE_I32);\n\n\t    gen_load_fpr32(fp, FREG(B11_8));\n\n\t    tcg_gen_helper_1_1(helper_ftrc_FT, cpu_fpul, fp);\n\n\t    tcg_temp_free(fp);\n\n\t}\n\n\treturn;\n\n    case 0xf04d: /* fneg FRn/DRn - FPSCR: Nothing */\n\n\t{\n\n\t    TCGv fp = tcg_temp_new(TCG_TYPE_I32);\n\n\t    gen_load_fpr32(fp, FREG(B11_8));\n\n\t    tcg_gen_helper_1_1(helper_fneg_T, fp, fp);\n\n\t    gen_store_fpr32(fp, FREG(B11_8));\n\n\t    tcg_temp_free(fp);\n\n\t}\n\n\treturn;\n\n    case 0xf05d: /* fabs FRn/DRn */\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    TCGv fp = tcg_temp_new(TCG_TYPE_I64);\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    tcg_gen_helper_1_1(helper_fabs_DT, fp, fp);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free(fp);\n\n\t} else {\n\n\t    TCGv fp = tcg_temp_new(TCG_TYPE_I32);\n\n\t    gen_load_fpr32(fp, FREG(B11_8));\n\n\t    tcg_gen_helper_1_1(helper_fabs_FT, fp, fp);\n\n\t    gen_store_fpr32(fp, FREG(B11_8));\n\n\t    tcg_temp_free(fp);\n\n\t}\n\n\treturn;\n\n    case 0xf06d: /* fsqrt FRn */\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    TCGv fp = tcg_temp_new(TCG_TYPE_I64);\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    tcg_gen_helper_1_1(helper_fsqrt_DT, fp, fp);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free(fp);\n\n\t} else {\n\n\t    TCGv fp = tcg_temp_new(TCG_TYPE_I32);\n\n\t    gen_load_fpr32(fp, FREG(B11_8));\n\n\t    tcg_gen_helper_1_1(helper_fsqrt_FT, fp, fp);\n\n\t    gen_store_fpr32(fp, FREG(B11_8));\n\n\t    tcg_temp_free(fp);\n\n\t}\n\n\treturn;\n\n    case 0xf07d: /* fsrra FRn */\n\n\tbreak;\n\n    case 0xf08d: /* fldi0 FRn - FPSCR: R[PR] */\n\n\tif (!(ctx->fpscr & FPSCR_PR)) {\n\n\t    TCGv val = tcg_const_i32(0);\n\n\t    gen_load_fpr32(val, FREG(B11_8));\n\n\t    tcg_temp_free(val);\n\n\t    return;\n\n\t}\n\n\tbreak;\n\n    case 0xf09d: /* fldi1 FRn - FPSCR: R[PR] */\n\n\tif (!(ctx->fpscr & FPSCR_PR)) {\n\n\t    TCGv val = tcg_const_i32(0x3f800000);\n\n\t    gen_load_fpr32(val, FREG(B11_8));\n\n\t    tcg_temp_free(val);\n\n\t    return;\n\n\t}\n\n\tbreak;\n\n    case 0xf0ad: /* fcnvsd FPUL,DRn */\n\n\t{\n\n\t    TCGv fp = tcg_temp_new(TCG_TYPE_I64);\n\n\t    tcg_gen_helper_1_1(helper_fcnvsd_FT_DT, fp, cpu_fpul);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free(fp);\n\n\t}\n\n\treturn;\n\n    case 0xf0bd: /* fcnvds DRn,FPUL */\n\n\t{\n\n\t    TCGv fp = tcg_temp_new(TCG_TYPE_I64);\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    tcg_gen_helper_1_1(helper_fcnvds_DT_FT, cpu_fpul, fp);\n\n\t    tcg_temp_free(fp);\n\n\t}\n\n\treturn;\n\n    }\n\n\n\n    fprintf(stderr, \"unknown instruction 0x%04x at pc 0x%08x\\n\",\n\n\t    ctx->opcode, ctx->pc);\n\n    tcg_gen_helper_0_0(helper_raise_illegal_instruction);\n\n    ctx->bstate = BS_EXCP;\n\n}\n", "idx": 6377, "_split": "valid", "_hash": "d93b01ee3b4deb26ed8c173cf2db4e02"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void a9_scu_write(void *opaque, target_phys_addr_t offset,\n\n                         uint64_t value, unsigned size)\n\n{\n\n    a9mp_priv_state *s = (a9mp_priv_state *)opaque;\n\n    uint32_t mask;\n\n    uint32_t shift;\n\n    switch (size) {\n\n    case 1:\n\n        mask = 0xff;\n\n        break;\n\n    case 2:\n\n        mask = 0xffff;\n\n        break;\n\n    case 4:\n\n        mask = 0xffffffff;\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"Invalid size %u in write to a9 scu register %x\\n\",\n\n                size, (unsigned)offset);\n\n        return;\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00: /* Control */\n\n        s->scu_control = value & 1;\n\n        break;\n\n    case 0x4: /* Configuration: RO */\n\n        break;\n\n    case 0x08: case 0x09: case 0x0A: case 0x0B: /* Power Control */\n\n        shift = (offset - 0x8) * 8;\n\n        s->scu_status &= ~(mask << shift);\n\n        s->scu_status |= ((value & mask) << shift);\n\n        break;\n\n    case 0x0c: /* Invalidate All Registers In Secure State */\n\n        /* no-op as we do not implement caches */\n\n        break;\n\n    case 0x40: /* Filtering Start Address Register */\n\n    case 0x44: /* Filtering End Address Register */\n\n        /* RAZ/WI, like an implementation with only one AXI master */\n\n        break;\n\n    case 0x50: /* SCU Access Control Register */\n\n    case 0x54: /* SCU Non-secure Access Control Register */\n\n        /* unimplemented, fall through */\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 6401, "_split": "valid", "_hash": "f882e5f556b7ba74f0dc0f9f829a4467"}
{"project": "qemu", "commit_id": "6acbe4c6f18e7de00481ff30574262b58526de45", "target": 0, "func": "static void s390_virtio_net_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtIOS390DeviceClass *k = VIRTIO_S390_DEVICE_CLASS(klass);\n\n\n\n    k->init = s390_virtio_net_init;\n\n    dc->props = s390_virtio_net_properties;\n\n    dc->alias = \"virtio-net\";\n\n}\n", "idx": 6404, "_split": "valid", "_hash": "089bfd1a10db31045e3a75ab6b71876b"}
{"project": "qemu", "commit_id": "24f3902b088cd4f2dbebfd90527b5d81d6a050e9", "target": 1, "func": "static int qemu_savevm_state(QEMUFile *f, Error **errp)\n\n{\n\n    int ret;\n\n    MigrationParams params = {\n\n        .blk = 0,\n\n        .shared = 0\n\n    };\n\n    MigrationState *ms = migrate_init(&params);\n\n    ms->to_dst_file = f;\n\n\n\n    if (qemu_savevm_state_blocked(errp)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    qemu_mutex_unlock_iothread();\n\n    qemu_savevm_state_header(f);\n\n    qemu_savevm_state_begin(f, &params);\n\n    qemu_mutex_lock_iothread();\n\n\n\n    while (qemu_file_get_error(f) == 0) {\n\n        if (qemu_savevm_state_iterate(f, false) > 0) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    ret = qemu_file_get_error(f);\n\n    if (ret == 0) {\n\n        qemu_savevm_state_complete_precopy(f, false);\n\n        ret = qemu_file_get_error(f);\n\n    }\n\n    qemu_savevm_state_cleanup();\n\n    if (ret != 0) {\n\n        error_setg_errno(errp, -ret, \"Error while writing VM state\");\n\n    }\n\n    return ret;\n\n}\n", "idx": 6425, "_split": "valid", "_hash": "6d6dfa57c4c37826f78d21c87d7bfc6c"}
{"project": "qemu", "commit_id": "44696296d5c2ffccef9d43d37d4f525bba7d9f5c", "target": 1, "func": "static void t_gen_lsl(TCGv d, TCGv a, TCGv b)\n\n{\n\n\tTCGv t0, t_31;\n\n\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\tt_31 = tcg_temp_new(TCG_TYPE_TL);\n\n\ttcg_gen_shl_tl(d, a, b);\n\n\n\n\ttcg_gen_movi_tl(t_31, 31);\n\n\ttcg_gen_sub_tl(t0, t_31, b);\n\n\ttcg_gen_sar_tl(t0, t0, t_31);\n\n\ttcg_gen_and_tl(t0, t0, d);\n\n\ttcg_gen_xor_tl(d, d, t0);\n\n\ttcg_temp_free(t0);\n\n\ttcg_temp_free(t_31);\n\n}\n", "idx": 6440, "_split": "valid", "_hash": "21265a2982c05bf2c70ec4fd5521d453"}
{"project": "qemu", "commit_id": "71407786054cad26de7ef66718b2a57a4bcb49b5", "target": 1, "func": "bool virtio_scsi_handle_ctrl_vq(VirtIOSCSI *s, VirtQueue *vq)\n\n{\n\n    VirtIOSCSIReq *req;\n\n    bool progress = false;\n\n\n\n    virtio_scsi_acquire(s);\n\n    while ((req = virtio_scsi_pop_req(s, vq))) {\n\n        progress = true;\n\n        virtio_scsi_handle_ctrl_req(s, req);\n\n    }\n\n    virtio_scsi_release(s);\n\n    return progress;\n\n}\n", "idx": 6445, "_split": "valid", "_hash": "61585029e62d4a5ac7b48bf0cbbf66a5"}
{"project": "qemu", "commit_id": "e305a16510afa74eec20390479e349402e55ef4c", "target": 1, "func": "static void gus_realizefn (DeviceState *dev, Error **errp)\n\n{\n\n    ISADevice *d = ISA_DEVICE(dev);\n\n    GUSState *s = GUS (dev);\n\n    IsaDmaClass *k;\n\n    struct audsettings as;\n\n\n\n    AUD_register_card (\"gus\", &s->card);\n\n\n\n    as.freq = s->freq;\n\n    as.nchannels = 2;\n\n    as.fmt = AUD_FMT_S16;\n\n    as.endianness = GUS_ENDIANNESS;\n\n\n\n    s->voice = AUD_open_out (\n\n        &s->card,\n\n        NULL,\n\n        \"gus\",\n\n        s,\n\n        GUS_callback,\n\n        &as\n\n        );\n\n\n\n    if (!s->voice) {\n\n        AUD_remove_card (&s->card);\n\n        error_setg(errp, \"No voice\");\n\n        return;\n\n    }\n\n\n\n    s->shift = 2;\n\n    s->samples = AUD_get_buffer_size_out (s->voice) >> s->shift;\n\n    s->mixbuf = g_malloc0 (s->samples << s->shift);\n\n\n\n    isa_register_portio_list (d, s->port, gus_portio_list1, s, \"gus\");\n\n    isa_register_portio_list (d, (s->port + 0x100) & 0xf00,\n\n                              gus_portio_list2, s, \"gus\");\n\n\n\n    s->isa_dma = isa_get_dma(isa_bus_from_device(d), s->emu.gusdma);\n\n    k = ISADMA_GET_CLASS(s->isa_dma);\n\n    k->register_channel(s->isa_dma, s->emu.gusdma, GUS_read_DMA, s);\n\n    s->emu.himemaddr = s->himem;\n\n    s->emu.gusdatapos = s->emu.himemaddr + 1024 * 1024 + 32;\n\n    s->emu.opaque = s;\n\n    isa_init_irq (d, &s->pic, s->emu.gusirq);\n\n\n\n    AUD_set_active_out (s->voice, 1);\n\n}\n", "idx": 6461, "_split": "valid", "_hash": "b05bbe555c8941c8f714620bf11498e2"}
{"project": "qemu", "commit_id": "06b106889a09277617fc8c542397a9f595ee605a", "target": 1, "func": "static inline bool migration_bitmap_clear_dirty(RAMState *rs, ram_addr_t addr)\n\n{\n\n    bool ret;\n\n    int nr = addr >> TARGET_PAGE_BITS;\n\n    unsigned long *bitmap = atomic_rcu_read(&rs->ram_bitmap)->bmap;\n\n\n\n    ret = test_and_clear_bit(nr, bitmap);\n\n\n\n    if (ret) {\n\n        rs->migration_dirty_pages--;\n\n    }\n\n    return ret;\n\n}\n", "idx": 6467, "_split": "valid", "_hash": "bb28e65c9c117ba4c681d640fc701010"}
{"project": "qemu", "commit_id": "e537112b418306229eb74c53de93751dd7b484d0", "target": 1, "func": "static void unassign_storage(SCLPDevice *sclp, SCCB *sccb)\n\n{\n\n    MemoryRegion *mr = NULL;\n\n    AssignStorage *assign_info = (AssignStorage *) sccb;\n\n    sclpMemoryHotplugDev *mhd = get_sclp_memory_hotplug_dev();\n\n    ram_addr_t unassign_addr;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n\n\n    if (!mhd) {\n\n        sccb->h.response_code = cpu_to_be16(SCLP_RC_INVALID_SCLP_COMMAND);\n\n        return;\n\n    }\n\n    unassign_addr = (assign_info->rn - 1) * mhd->rzm;\n\n\n\n    /* if the addr is a multiple of 256 MB */\n\n    if ((unassign_addr % MEM_SECTION_SIZE == 0) &&\n\n        (unassign_addr >= mhd->padded_ram_size)) {\n\n        mhd->standby_state_map[(unassign_addr -\n\n                           mhd->padded_ram_size) / MEM_SECTION_SIZE] = 0;\n\n\n\n        /* find the specified memory region and destroy it */\n\n        mr = memory_region_find(sysmem, unassign_addr, 1).mr;\n\n        memory_region_unref(mr);\n\n        if (mr) {\n\n            int i;\n\n            int is_removable = 1;\n\n            ram_addr_t map_offset = (unassign_addr - mhd->padded_ram_size -\n\n                                     (unassign_addr - mhd->padded_ram_size)\n\n                                     % mhd->standby_subregion_size);\n\n            /* Mark all affected subregions as 'standby' once again */\n\n            for (i = 0;\n\n                 i < (mhd->standby_subregion_size / MEM_SECTION_SIZE);\n\n                 i++) {\n\n\n\n                if (mhd->standby_state_map[i + map_offset / MEM_SECTION_SIZE]) {\n\n                    is_removable = 0;\n\n                    break;\n\n                }\n\n            }\n\n            if (is_removable) {\n\n                memory_region_del_subregion(sysmem, mr);\n\n                object_unref(OBJECT(mr));\n\n            }\n\n        }\n\n    }\n\n    sccb->h.response_code = cpu_to_be16(SCLP_RC_NORMAL_COMPLETION);\n\n}\n", "idx": 6495, "_split": "valid", "_hash": "7b3c30d3883d804f74cb083eba92f744"}
{"project": "qemu", "commit_id": "46764fe09ca2e0f15c0981a672c166ed8cf57e72", "target": 1, "func": "static void do_flush_queued_data(VirtIOSerialPort *port, VirtQueue *vq,\n\n                                 VirtIODevice *vdev)\n\n{\n\n    VirtIOSerialPortClass *vsc;\n\n\n\n    assert(port);\n\n    assert(virtio_queue_ready(vq));\n\n\n\n    vsc = VIRTIO_SERIAL_PORT_GET_CLASS(port);\n\n\n\n    while (!port->throttled) {\n\n        unsigned int i;\n\n\n\n        /* Pop an elem only if we haven't left off a previous one mid-way */\n\n        if (!port->elem) {\n\n            port->elem = virtqueue_pop(vq, sizeof(VirtQueueElement));\n\n            if (!port->elem) {\n\n                break;\n\n\n            port->iov_idx = 0;\n\n            port->iov_offset = 0;\n\n\n\n\n        for (i = port->iov_idx; i < port->elem->out_num; i++) {\n\n            size_t buf_size;\n\n            ssize_t ret;\n\n\n\n            buf_size = port->elem->out_sg[i].iov_len - port->iov_offset;\n\n            ret = vsc->have_data(port,\n\n                                  port->elem->out_sg[i].iov_base\n\n                                  + port->iov_offset,\n\n                                  buf_size);\n\n\n\n\n            if (port->throttled) {\n\n                port->iov_idx = i;\n\n                if (ret > 0) {\n\n                    port->iov_offset += ret;\n\n\n                break;\n\n\n            port->iov_offset = 0;\n\n\n        if (port->throttled) {\n\n            break;\n\n\n        virtqueue_push(vq, port->elem, 0);\n\n        g_free(port->elem);\n\n        port->elem = NULL;\n\n\n    virtio_notify(vdev, vq);\n", "idx": 6508, "_split": "valid", "_hash": "498423ecb4e6418fefc00827d0bf7730"}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int v9fs_receive_response(V9fsProxy *proxy, int type,\n\n                                 int *status, void *response)\n\n{\n\n    int retval;\n\n    ProxyHeader header;\n\n    struct iovec *reply = &proxy->in_iovec;\n\n\n\n    *status = 0;\n\n    reply->iov_len = 0;\n\n    retval = socket_read(proxy->sockfd, reply->iov_base, PROXY_HDR_SZ);\n\n    if (retval < 0) {\n\n        return retval;\n\n    }\n\n    reply->iov_len = PROXY_HDR_SZ;\n\n    proxy_unmarshal(reply, 0, \"dd\", &header.type, &header.size);\n\n    /*\n\n     * if response size > PROXY_MAX_IO_SZ, read the response but ignore it and\n\n     * return -ENOBUFS\n\n     */\n\n    if (header.size > PROXY_MAX_IO_SZ) {\n\n        int count;\n\n        while (header.size > 0) {\n\n            count = MIN(PROXY_MAX_IO_SZ, header.size);\n\n            count = socket_read(proxy->sockfd, reply->iov_base, count);\n\n            if (count < 0) {\n\n                return count;\n\n            }\n\n            header.size -= count;\n\n        }\n\n        *status = -ENOBUFS;\n\n        return 0;\n\n    }\n\n\n\n    retval = socket_read(proxy->sockfd,\n\n                         reply->iov_base + PROXY_HDR_SZ, header.size);\n\n    if (retval < 0) {\n\n        return retval;\n\n    }\n\n    reply->iov_len += header.size;\n\n    /* there was an error during processing request */\n\n    if (header.type == T_ERROR) {\n\n        int ret;\n\n        ret = proxy_unmarshal(reply, PROXY_HDR_SZ, \"d\", status);\n\n        if (ret < 0) {\n\n            *status = ret;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    switch (type) {\n\n    case T_LSTAT: {\n\n        ProxyStat prstat;\n\n        retval = proxy_unmarshal(reply, PROXY_HDR_SZ,\n\n                                 \"qqqdddqqqqqqqqqq\", &prstat.st_dev,\n\n                                 &prstat.st_ino, &prstat.st_nlink,\n\n                                 &prstat.st_mode, &prstat.st_uid,\n\n                                 &prstat.st_gid, &prstat.st_rdev,\n\n                                 &prstat.st_size, &prstat.st_blksize,\n\n                                 &prstat.st_blocks,\n\n                                 &prstat.st_atim_sec, &prstat.st_atim_nsec,\n\n                                 &prstat.st_mtim_sec, &prstat.st_mtim_nsec,\n\n                                 &prstat.st_ctim_sec, &prstat.st_ctim_nsec);\n\n        prstat_to_stat(response, &prstat);\n\n        break;\n\n    }\n\n    case T_STATFS: {\n\n        ProxyStatFS prstfs;\n\n        retval = proxy_unmarshal(reply, PROXY_HDR_SZ,\n\n                                 \"qqqqqqqqqqq\", &prstfs.f_type,\n\n                                 &prstfs.f_bsize, &prstfs.f_blocks,\n\n                                 &prstfs.f_bfree, &prstfs.f_bavail,\n\n                                 &prstfs.f_files, &prstfs.f_ffree,\n\n                                 &prstfs.f_fsid[0], &prstfs.f_fsid[1],\n\n                                 &prstfs.f_namelen, &prstfs.f_frsize);\n\n        prstatfs_to_statfs(response, &prstfs);\n\n        break;\n\n    }\n\n    case T_READLINK: {\n\n        V9fsString target;\n\n        v9fs_string_init(&target);\n\n        retval = proxy_unmarshal(reply, PROXY_HDR_SZ, \"s\", &target);\n\n        strcpy(response, target.data);\n\n        v9fs_string_free(&target);\n\n        break;\n\n    }\n\n    case T_LGETXATTR:\n\n    case T_LLISTXATTR: {\n\n        V9fsString xattr;\n\n        v9fs_string_init(&xattr);\n\n        retval = proxy_unmarshal(reply, PROXY_HDR_SZ, \"s\", &xattr);\n\n        memcpy(response, xattr.data, xattr.size);\n\n        v9fs_string_free(&xattr);\n\n        break;\n\n    }\n\n    case T_GETVERSION:\n\n        proxy_unmarshal(reply, PROXY_HDR_SZ, \"q\", response);\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    if (retval < 0) {\n\n        *status  = retval;\n\n    }\n\n    return 0;\n\n}\n", "idx": 6541, "_split": "valid", "_hash": "a695adc7a2f719910c839850dbd32f4e"}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int usbredir_handle_interrupt_data(USBRedirDevice *dev,\n\n                                           USBPacket *p, uint8_t ep)\n\n{\n\n    if (ep & USB_DIR_IN) {\n\n        /* Input interrupt endpoint, buffered packet input */\n\n        struct buf_packet *intp;\n\n        int status, len;\n\n\n\n        if (!dev->endpoint[EP2I(ep)].interrupt_started &&\n\n                !dev->endpoint[EP2I(ep)].interrupt_error) {\n\n            struct usb_redir_start_interrupt_receiving_header start_int = {\n\n                .endpoint = ep,\n\n            };\n\n            /* No id, we look at the ep when receiving a status back */\n\n            usbredirparser_send_start_interrupt_receiving(dev->parser, 0,\n\n                                                          &start_int);\n\n            usbredirparser_do_write(dev->parser);\n\n            DPRINTF(\"interrupt recv started ep %02X\\n\", ep);\n\n            dev->endpoint[EP2I(ep)].interrupt_started = 1;\n\n        }\n\n\n\n        intp = QTAILQ_FIRST(&dev->endpoint[EP2I(ep)].bufpq);\n\n        if (intp == NULL) {\n\n            DPRINTF2(\"interrupt-token-in ep %02X, no intp\\n\", ep);\n\n            /* Check interrupt_error for stream errors */\n\n            status = dev->endpoint[EP2I(ep)].interrupt_error;\n\n            dev->endpoint[EP2I(ep)].interrupt_error = 0;\n\n            return usbredir_handle_status(dev, status, 0);\n\n        }\n\n        DPRINTF(\"interrupt-token-in ep %02X status %d len %d\\n\", ep,\n\n                intp->status, intp->len);\n\n\n\n        status = intp->status;\n\n        if (status != usb_redir_success) {\n\n            bufp_free(dev, intp, ep);\n\n            return usbredir_handle_status(dev, status, 0);\n\n        }\n\n\n\n        len = intp->len;\n\n        if (len > p->len) {\n\n            ERROR(\"received int data is larger then packet ep %02X\\n\", ep);\n\n            bufp_free(dev, intp, ep);\n\n            return USB_RET_NAK;\n\n        }\n\n        memcpy(p->data, intp->data, len);\n\n        bufp_free(dev, intp, ep);\n\n        return len;\n\n    } else {\n\n        /* Output interrupt endpoint, normal async operation */\n\n        AsyncURB *aurb = async_alloc(dev, p);\n\n        struct usb_redir_interrupt_packet_header interrupt_packet;\n\n\n\n        DPRINTF(\"interrupt-out ep %02X len %d id %u\\n\", ep, p->len,\n\n                aurb->packet_id);\n\n\n\n        interrupt_packet.endpoint  = ep;\n\n        interrupt_packet.length    = p->len;\n\n        aurb->interrupt_packet     = interrupt_packet;\n\n\n\n        usbredir_log_data(dev, \"interrupt data out:\", p->data, p->len);\n\n        usbredirparser_send_interrupt_packet(dev->parser, aurb->packet_id,\n\n                                        &interrupt_packet, p->data, p->len);\n\n        usbredirparser_do_write(dev->parser);\n\n        return USB_RET_ASYNC;\n\n    }\n\n}\n", "idx": 6563, "_split": "valid", "_hash": "45ceee99b43e3a1c7724aa884fc1c346"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void nvme_clear_ctrl(NvmeCtrl *n)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < n->num_queues; i++) {\n\n        if (n->sq[i] != NULL) {\n\n            nvme_free_sq(n->sq[i], n);\n\n        }\n\n    }\n\n    for (i = 0; i < n->num_queues; i++) {\n\n        if (n->cq[i] != NULL) {\n\n            nvme_free_cq(n->cq[i], n);\n\n        }\n\n    }\n\n\n\n    bdrv_flush(n->conf.bs);\n\n    n->bar.cc = 0;\n\n}\n", "idx": 6595, "_split": "valid", "_hash": "d2977cd31891283739caf6bc9a635c28"}
{"project": "qemu", "commit_id": "eff6ff9431aa9776062a5f4a08d1f6503ca9995a", "target": 0, "func": "void r4k_helper_tlbwi(CPUMIPSState *env)\n\n{\n\n    r4k_tlb_t *tlb;\n\n    int idx;\n\n    target_ulong VPN;\n\n    uint16_t ASID;\n\n    bool G, V0, D0, V1, D1;\n\n\n\n    idx = (env->CP0_Index & ~0x80000000) % env->tlb->nb_tlb;\n\n    tlb = &env->tlb->mmu.r4k.tlb[idx];\n\n    VPN = env->CP0_EntryHi & (TARGET_PAGE_MASK << 1);\n\n#if defined(TARGET_MIPS64)\n\n    VPN &= env->SEGMask;\n\n#endif\n\n    ASID = env->CP0_EntryHi & env->CP0_EntryHi_ASID_mask;\n\n    G = env->CP0_EntryLo0 & env->CP0_EntryLo1 & 1;\n\n    V0 = (env->CP0_EntryLo0 & 2) != 0;\n\n    D0 = (env->CP0_EntryLo0 & 4) != 0;\n\n    V1 = (env->CP0_EntryLo1 & 2) != 0;\n\n    D1 = (env->CP0_EntryLo1 & 4) != 0;\n\n\n\n    /* Discard cached TLB entries, unless tlbwi is just upgrading access\n\n       permissions on the current entry. */\n\n    if (tlb->VPN != VPN || tlb->ASID != ASID || tlb->G != G ||\n\n        (tlb->V0 && !V0) || (tlb->D0 && !D0) ||\n\n        (tlb->V1 && !V1) || (tlb->D1 && !D1)) {\n\n        r4k_mips_tlb_flush_extra(env, env->tlb->nb_tlb);\n\n    }\n\n\n\n    r4k_invalidate_tlb(env, idx, 0);\n\n    r4k_fill_tlb(env, idx);\n\n}\n", "idx": 6609, "_split": "valid", "_hash": "bfcbd3ac1fcededcbd76d2bfa74c7de2"}
{"project": "qemu", "commit_id": "45876e913e169bf156a3fc36f21eb0adf6ec3671", "target": 0, "func": "static void an5206_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    M68kCPU *cpu;\n\n    CPUM68KState *env;\n\n    int kernel_size;\n\n    uint64_t elf_entry;\n\n    hwaddr entry;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"m5206\";\n\n    }\n\n    cpu = M68K_CPU(cpu_generic_init(TYPE_M68K_CPU, cpu_model));\n\n    env = &cpu->env;\n\n\n\n    /* Initialize CPU registers.  */\n\n    env->vbr = 0;\n\n    /* TODO: allow changing MBAR and RAMBAR.  */\n\n    env->mbar = AN5206_MBAR_ADDR | 1;\n\n    env->rambar0 = AN5206_RAMBAR_ADDR | 1;\n\n\n\n    /* DRAM at address zero */\n\n    memory_region_allocate_system_memory(ram, NULL, \"an5206.ram\", ram_size);\n\n    memory_region_add_subregion(address_space_mem, 0, ram);\n\n\n\n    /* Internal SRAM.  */\n\n    memory_region_init_ram(sram, NULL, \"an5206.sram\", 512, &error_fatal);\n\n    memory_region_add_subregion(address_space_mem, AN5206_RAMBAR_ADDR, sram);\n\n\n\n    mcf5206_init(address_space_mem, AN5206_MBAR_ADDR, cpu);\n\n\n\n    /* Load kernel.  */\n\n    if (!kernel_filename) {\n\n        if (qtest_enabled()) {\n\n            return;\n\n        }\n\n        fprintf(stderr, \"Kernel image must be specified\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                           NULL, NULL, 1, EM_68K, 0, 0);\n\n    entry = elf_entry;\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL,\n\n                                  NULL, NULL);\n\n    }\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR,\n\n                                          ram_size - KERNEL_LOAD_ADDR);\n\n        entry = KERNEL_LOAD_ADDR;\n\n    }\n\n    if (kernel_size < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    env->pc = entry;\n\n}\n", "idx": 6612, "_split": "valid", "_hash": "a95f53b6a0e167951c113e2fafd22010"}
{"project": "qemu", "commit_id": "f5aa4bdc766190b95d18be27d5cdf4d80c35b33c", "target": 1, "func": "static uint8_t ide_wait_clear(uint8_t flag)\n\n{\n\n    QPCIDevice *dev;\n\n    QPCIBar bmdma_bar, ide_bar;\n\n    uint8_t data;\n\n    time_t st;\n\n\n\n    dev = get_pci_device(&bmdma_bar, &ide_bar);\n\n\n\n    /* Wait with a 5 second timeout */\n\n    time(&st);\n\n    while (true) {\n\n        data = qpci_io_readb(dev, ide_bar, reg_status);\n\n        if (!(data & flag)) {\n\n\n            return data;\n\n        }\n\n        if (difftime(time(NULL), st) > 5.0) {\n\n            break;\n\n        }\n\n        nsleep(400);\n\n    }\n\n    g_assert_not_reached();\n\n}", "idx": 6627, "_split": "valid", "_hash": "9c1b83fbcc96d95f92e3fb7bf82f7c5d"}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void perf_lifecycle(void)\n\n{\n\n    Coroutine *coroutine;\n\n    unsigned int i, max;\n\n    double duration;\n\n\n\n    max = 1000000;\n\n\n\n    g_test_timer_start();\n\n    for (i = 0; i < max; i++) {\n\n        coroutine = qemu_coroutine_create(empty_coroutine);\n\n        qemu_coroutine_enter(coroutine, NULL);\n\n    }\n\n    duration = g_test_timer_elapsed();\n\n\n\n    g_test_message(\"Lifecycle %u iterations: %f s\\n\", max, duration);\n\n}\n", "idx": 6630, "_split": "valid", "_hash": "566af8ddae5829d4491ca73d47bb688b"}
{"project": "qemu", "commit_id": "966439a67830239a6c520c5df6c55627b8153c8b", "target": 1, "func": "void do_4xx_tlbsx_ (void)\n\n{\n\n    int tmp = xer_ov;\n\n\n\n    T0 = ppcemb_tlb_search(env, T0, env->spr[SPR_40x_PID]);\n\n    if (T0 != -1)\n\n        tmp |= 0x02;\n\n    env->crf[0] = tmp;\n\n}\n", "idx": 6644, "_split": "valid", "_hash": "02489061dbed7f4bf0b3f2b17bb0c859"}
{"project": "qemu", "commit_id": "f678f671ba654d4610f0e43d175c8c1b2fad10df", "target": 1, "func": "static void decode_bol_opc(CPUTriCoreState *env, DisasContext *ctx, int32_t op1)\n\n{\n\n    int r1, r2;\n\n    int32_t address;\n\n    TCGv temp;\n\n\n\n    r1 = MASK_OP_BOL_S1D(ctx->opcode);\n\n    r2 = MASK_OP_BOL_S2(ctx->opcode);\n\n    address = MASK_OP_BOL_OFF16_SEXT(ctx->opcode);\n\n\n\n    switch (op1) {\n\n    case OPC1_32_BOL_LD_A_LONGOFF:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_addi_tl(temp, cpu_gpr_a[r2], address);\n\n        tcg_gen_qemu_ld_tl(cpu_gpr_a[r1], temp, ctx->mem_idx, MO_LEUL);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC1_32_BOL_LD_W_LONGOFF:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_addi_tl(temp, cpu_gpr_a[r2], address);\n\n        tcg_gen_qemu_ld_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LEUL);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC1_32_BOL_LEA_LONGOFF:\n\n        tcg_gen_addi_tl(cpu_gpr_a[r1], cpu_gpr_a[r2], address);\n\n        break;\n\n    case OPC1_32_BOL_ST_A_LONGOFF:\n\n        if (tricore_feature(env, TRICORE_FEATURE_16)) {\n\n            gen_offset_st(ctx, cpu_gpr_a[r1], cpu_gpr_a[r2], address, MO_LEUL);\n\n        } else {\n\n            /* raise illegal opcode trap */\n\n        }\n\n        break;\n\n    case OPC1_32_BOL_ST_W_LONGOFF:\n\n        gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], address, MO_LEUL);\n\n        break;\n\n    case OPC1_32_BOL_LD_B_LONGOFF:\n\n        if (tricore_feature(env, TRICORE_FEATURE_16)) {\n\n            gen_offset_ld(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], address, MO_SB);\n\n        } else {\n\n            /* raise illegal opcode trap */\n\n        }\n\n        break;\n\n    case OPC1_32_BOL_LD_BU_LONGOFF:\n\n        if (tricore_feature(env, TRICORE_FEATURE_16)) {\n\n            gen_offset_ld(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], address, MO_UB);\n\n        } else {\n\n            /* raise illegal opcode trap */\n\n        }\n\n        break;\n\n    case OPC1_32_BOL_LD_H_LONGOFF:\n\n        if (tricore_feature(env, TRICORE_FEATURE_16)) {\n\n            gen_offset_ld(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], address, MO_LESW);\n\n        } else {\n\n            /* raise illegal opcode trap */\n\n        }\n\n        break;\n\n    case OPC1_32_BOL_LD_HU_LONGOFF:\n\n        if (tricore_feature(env, TRICORE_FEATURE_16)) {\n\n            gen_offset_ld(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], address, MO_LEUW);\n\n        } else {\n\n            /* raise illegal opcode trap */\n\n        }\n\n        break;\n\n    case OPC1_32_BOL_ST_B_LONGOFF:\n\n        if (tricore_feature(env, TRICORE_FEATURE_16)) {\n\n            gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], address, MO_SB);\n\n        } else {\n\n            /* raise illegal opcode trap */\n\n        }\n\n        break;\n\n    case OPC1_32_BOL_ST_H_LONGOFF:\n\n        if (tricore_feature(env, TRICORE_FEATURE_16)) {\n\n            gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], address, MO_LESW);\n\n        } else {\n\n            /* raise illegal opcode trap */\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 6654, "_split": "valid", "_hash": "cc14d0f023c32d88f1e2165a9a12d264"}
{"project": "qemu", "commit_id": "bce6261eb2d879625126485d4ddd28cacb93152e", "target": 1, "func": "static void virtconsole_realize(DeviceState *dev, Error **errp)\n\n{\n\n    VirtIOSerialPort *port = VIRTIO_SERIAL_PORT(dev);\n\n    VirtConsole *vcon = VIRTIO_CONSOLE(dev);\n\n    VirtIOSerialPortClass *k = VIRTIO_SERIAL_PORT_GET_CLASS(dev);\n\n\n\n    if (port->id == 0 && !k->is_console) {\n\n        error_setg(errp, \"Port number 0 on virtio-serial devices reserved \"\n\n                   \"for virtconsole devices for backward compatibility.\");\n\n        return;\n\n    }\n\n\n\n    if (vcon->chr) {\n\n        vcon->chr->explicit_fe_open = 1;\n\n        qemu_chr_add_handlers(vcon->chr, chr_can_read, chr_read, chr_event,\n\n                              vcon);\n\n    }\n\n}\n", "idx": 6661, "_split": "valid", "_hash": "08bc6e5819c793bd9bc5644223a5da66"}
{"project": "qemu", "commit_id": "07fb61760cdea7c3f1b9c897513986945bca8e89", "target": 1, "func": "static void pc_q35_init(MachineState *machine)\n{\n    PCMachineState *pc_machine = PC_MACHINE(machine);\n    ram_addr_t below_4g_mem_size, above_4g_mem_size;\n    Q35PCIHost *q35_host;\n    PCIHostState *phb;\n    PCIBus *host_bus;\n    PCIDevice *lpc;\n    BusState *idebus[MAX_SATA_PORTS];\n    ISADevice *rtc_state;\n    ISADevice *floppy;\n    MemoryRegion *pci_memory;\n    MemoryRegion *rom_memory;\n    MemoryRegion *ram_memory;\n    GSIState *gsi_state;\n    ISABus *isa_bus;\n    int pci_enabled = 1;\n    qemu_irq *cpu_irq;\n    qemu_irq *gsi;\n    qemu_irq *i8259;\n    int i;\n    ICH9LPCState *ich9_lpc;\n    PCIDevice *ahci;\n    DeviceState *icc_bridge;\n    PcGuestInfo *guest_info;\n    ram_addr_t lowmem;\n    /* Check whether RAM fits below 4G (leaving 1/2 GByte for IO memory\n     * and 256 Mbytes for PCI Express Enhanced Configuration Access Mapping\n     * also known as MMCFG).\n     * If it doesn't, we need to split it in chunks below and above 4G.\n     * In any case, try to make sure that guest addresses aligned at\n     * 1G boundaries get mapped to host addresses aligned at 1G boundaries.\n     * For old machine types, use whatever split we used historically to avoid\n     * breaking migration.\n    if (machine->ram_size >= 0xb0000000) {\n        lowmem = gigabyte_align ? 0x80000000 : 0xb0000000;\n    } else {\n        lowmem = 0xb0000000;\n    }\n    /* Handle the machine opt max-ram-below-4g.  It is basically doing\n     * min(qemu limit, user limit).\n    if (lowmem > pc_machine->max_ram_below_4g) {\n        lowmem = pc_machine->max_ram_below_4g;\n        if (machine->ram_size - lowmem > lowmem &&\n            lowmem & ((1ULL << 30) - 1)) {\n            error_report(\"Warning: Large machine and max_ram_below_4g(%\"PRIu64\n                         \") not a multiple of 1G; possible bad performance.\",\n                         pc_machine->max_ram_below_4g);\n        }\n    }\n    if (machine->ram_size >= lowmem) {\n        above_4g_mem_size = machine->ram_size - lowmem;\n        below_4g_mem_size = lowmem;\n    } else {\n        above_4g_mem_size = 0;\n        below_4g_mem_size = machine->ram_size;\n    }\n    if (xen_enabled() && xen_hvm_init(&below_4g_mem_size, &above_4g_mem_size,\n                                      &ram_memory) != 0) {\n        fprintf(stderr, \"xen hardware virtual machine initialisation failed\\n\");\n        exit(1);\n    }\n    icc_bridge = qdev_create(NULL, TYPE_ICC_BRIDGE);\n    object_property_add_child(qdev_get_machine(), \"icc-bridge\",\n                              OBJECT(icc_bridge), NULL);\n    pc_cpus_init(machine->cpu_model, icc_bridge);\n    pc_acpi_init(\"q35-acpi-dsdt.aml\");\n    kvmclock_create();\n    /* pci enabled */\n    if (pci_enabled) {\n        pci_memory = g_new(MemoryRegion, 1);\n        memory_region_init(pci_memory, NULL, \"pci\", UINT64_MAX);\n        rom_memory = pci_memory;\n    } else {\n        pci_memory = NULL;\n        rom_memory = get_system_memory();\n    }\n    guest_info = pc_guest_info_init(below_4g_mem_size, above_4g_mem_size);\n    guest_info->has_pci_info = has_pci_info;\n    guest_info->isapc_ram_fw = false;\n    guest_info->has_acpi_build = has_acpi_build;\n    guest_info->has_reserved_memory = has_reserved_memory;\n    if (smbios_defaults) {\n        MachineClass *mc = MACHINE_GET_CLASS(machine);\n        /* These values are guest ABI, do not change */\n        smbios_set_defaults(\"QEMU\", \"Standard PC (Q35 + ICH9, 2009)\",\n                            mc->name, smbios_legacy_mode);\n    }\n    /* allocate ram and load rom/bios */\n    if (!xen_enabled()) {\n        pc_memory_init(machine, get_system_memory(),\n                       below_4g_mem_size, above_4g_mem_size,\n                       rom_memory, &ram_memory, guest_info);\n    }\n    /* irq lines */\n    gsi_state = g_malloc0(sizeof(*gsi_state));\n    if (kvm_irqchip_in_kernel()) {\n        kvm_pc_setup_irq_routing(pci_enabled);\n        gsi = qemu_allocate_irqs(kvm_pc_gsi_handler, gsi_state,\n                                 GSI_NUM_PINS);\n    } else {\n        gsi = qemu_allocate_irqs(gsi_handler, gsi_state, GSI_NUM_PINS);\n    }\n    /* create pci host bus */\n    q35_host = Q35_HOST_DEVICE(qdev_create(NULL, TYPE_Q35_HOST_DEVICE));\n    object_property_add_child(qdev_get_machine(), \"q35\", OBJECT(q35_host), NULL);\n    q35_host->mch.ram_memory = ram_memory;\n    q35_host->mch.pci_address_space = pci_memory;\n    q35_host->mch.system_memory = get_system_memory();\n    q35_host->mch.address_space_io = get_system_io();\n    q35_host->mch.below_4g_mem_size = below_4g_mem_size;\n    q35_host->mch.above_4g_mem_size = above_4g_mem_size;\n    q35_host->mch.guest_info = guest_info;\n    /* pci */\n    qdev_init_nofail(DEVICE(q35_host));\n    phb = PCI_HOST_BRIDGE(q35_host);\n    host_bus = phb->bus;\n    /* create ISA bus */\n    lpc = pci_create_simple_multifunction(host_bus, PCI_DEVFN(ICH9_LPC_DEV,\n                                          ICH9_LPC_FUNC), true,\n                                          TYPE_ICH9_LPC_DEVICE);\n    object_property_add_link(OBJECT(machine), PC_MACHINE_ACPI_DEVICE_PROP,\n                             TYPE_HOTPLUG_HANDLER,\n                             (Object **)&pc_machine->acpi_dev,\n                             object_property_allow_set_link,\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE, &error_abort);\n    object_property_set_link(OBJECT(machine), OBJECT(lpc),\n                             PC_MACHINE_ACPI_DEVICE_PROP, &error_abort);\n    ich9_lpc = ICH9_LPC_DEVICE(lpc);\n    ich9_lpc->pic = gsi;\n    ich9_lpc->ioapic = gsi_state->ioapic_irq;\n    pci_bus_irqs(host_bus, ich9_lpc_set_irq, ich9_lpc_map_irq, ich9_lpc,\n                 ICH9_LPC_NB_PIRQS);\n    pci_bus_set_route_irq_fn(host_bus, ich9_route_intx_pin_to_irq);\n    isa_bus = ich9_lpc->isa_bus;\n    /*end early*/\n    isa_bus_irqs(isa_bus, gsi);\n    if (kvm_irqchip_in_kernel()) {\n        i8259 = kvm_i8259_init(isa_bus);\n    } else if (xen_enabled()) {\n        i8259 = xen_interrupt_controller_init();\n    } else {\n        cpu_irq = pc_allocate_cpu_irq();\n        i8259 = i8259_init(isa_bus, cpu_irq[0]);\n    }\n    for (i = 0; i < ISA_NUM_IRQS; i++) {\n        gsi_state->i8259_irq[i] = i8259[i];\n    }\n    if (pci_enabled) {\n        ioapic_init_gsi(gsi_state, NULL);\n    }\n    qdev_init_nofail(icc_bridge);\n    pc_register_ferr_irq(gsi[13]);\n    /* init basic PC hardware */\n    pc_basic_device_init(isa_bus, gsi, &rtc_state, &floppy, false, 0xff0104);\n    /* connect pm stuff to lpc */\n    ich9_lpc_pm_init(lpc);\n    /* ahci and SATA device, for q35 1 ahci controller is built-in */\n    ahci = pci_create_simple_multifunction(host_bus,\n                                           PCI_DEVFN(ICH9_SATA1_DEV,\n                                                     ICH9_SATA1_FUNC),\n                                           true, \"ich9-ahci\");\n    idebus[0] = qdev_get_child_bus(&ahci->qdev, \"ide.0\");\n    idebus[1] = qdev_get_child_bus(&ahci->qdev, \"ide.1\");\n    if (usb_enabled(false)) {\n        /* Should we create 6 UHCI according to ich9 spec? */\n        ehci_create_ich9_with_companions(host_bus, 0x1d);\n    }\n    /* TODO: Populate SPD eeprom data.  */\n    smbus_eeprom_init(ich9_smb_init(host_bus,\n                                    PCI_DEVFN(ICH9_SMB_DEV, ICH9_SMB_FUNC),\n                                    0xb100),\n                      8, NULL, 0);\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, machine->boot_order,\n                 floppy, idebus[0], idebus[1], rtc_state);\n    /* the rest devices to which pci devfn is automatically assigned */\n    pc_vga_init(isa_bus, host_bus);\n    pc_nic_init(isa_bus, host_bus);\n    if (pci_enabled) {\n        pc_pci_device_init(host_bus);\n    }\n}", "idx": 6673, "_split": "valid", "_hash": "b98ed2c22be903db26a25b544cbd787e"}
{"project": "qemu", "commit_id": "97f1c45c6f456572e5b504b8614e4a69e23b8e3a", "target": 1, "func": "static int vpc_open(BlockDriverState *bs, QDict *options, int flags,\n\n                    Error **errp)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    int i;\n\n    VHDFooter *footer;\n\n    VHDDynDiskHeader *dyndisk_header;\n\n    uint8_t buf[HEADER_SIZE];\n\n    uint32_t checksum;\n\n    int disk_type = VHD_DYNAMIC;\n\n    int ret;\n\n\n\n    ret = bdrv_pread(bs->file, 0, s->footer_buf, HEADER_SIZE);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    footer = (VHDFooter *) s->footer_buf;\n\n    if (strncmp(footer->creator, \"conectix\", 8)) {\n\n        int64_t offset = bdrv_getlength(bs->file);\n\n        if (offset < 0) {\n\n            ret = offset;\n\n            goto fail;\n\n        } else if (offset < HEADER_SIZE) {\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n\n\n        /* If a fixed disk, the footer is found only at the end of the file */\n\n        ret = bdrv_pread(bs->file, offset-HEADER_SIZE, s->footer_buf,\n\n                         HEADER_SIZE);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        if (strncmp(footer->creator, \"conectix\", 8)) {\n\n            error_setg(errp, \"invalid VPC image\");\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n        disk_type = VHD_FIXED;\n\n    }\n\n\n\n    checksum = be32_to_cpu(footer->checksum);\n\n    footer->checksum = 0;\n\n    if (vpc_checksum(s->footer_buf, HEADER_SIZE) != checksum)\n\n        fprintf(stderr, \"block-vpc: The header checksum of '%s' is \"\n\n            \"incorrect.\\n\", bs->filename);\n\n\n\n    /* Write 'checksum' back to footer, or else will leave it with zero. */\n\n    footer->checksum = be32_to_cpu(checksum);\n\n\n\n    // The visible size of a image in Virtual PC depends on the geometry\n\n    // rather than on the size stored in the footer (the size in the footer\n\n    // is too large usually)\n\n    bs->total_sectors = (int64_t)\n\n        be16_to_cpu(footer->cyls) * footer->heads * footer->secs_per_cyl;\n\n\n\n    /* images created with disk2vhd report a far higher virtual size\n\n     * than expected with the cyls * heads * sectors_per_cyl formula.\n\n     * use the footer->size instead if the image was created with\n\n     * disk2vhd.\n\n     */\n\n    if (!strncmp(footer->creator_app, \"d2v\", 4)) {\n\n        bs->total_sectors = be64_to_cpu(footer->size) / BDRV_SECTOR_SIZE;\n\n    }\n\n\n\n    /* Allow a maximum disk size of approximately 2 TB */\n\n    if (bs->total_sectors >= 65535LL * 255 * 255) {\n\n        ret = -EFBIG;\n\n        goto fail;\n\n    }\n\n\n\n    if (disk_type == VHD_DYNAMIC) {\n\n        ret = bdrv_pread(bs->file, be64_to_cpu(footer->data_offset), buf,\n\n                         HEADER_SIZE);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        dyndisk_header = (VHDDynDiskHeader *) buf;\n\n\n\n        if (strncmp(dyndisk_header->magic, \"cxsparse\", 8)) {\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n\n\n        s->block_size = be32_to_cpu(dyndisk_header->block_size);\n\n        s->bitmap_size = ((s->block_size / (8 * 512)) + 511) & ~511;\n\n\n\n        s->max_table_entries = be32_to_cpu(dyndisk_header->max_table_entries);\n\n        s->pagetable = g_malloc(s->max_table_entries * 4);\n\n\n\n        s->bat_offset = be64_to_cpu(dyndisk_header->table_offset);\n\n\n\n        ret = bdrv_pread(bs->file, s->bat_offset, s->pagetable,\n\n                         s->max_table_entries * 4);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        s->free_data_block_offset =\n\n            (s->bat_offset + (s->max_table_entries * 4) + 511) & ~511;\n\n\n\n        for (i = 0; i < s->max_table_entries; i++) {\n\n            be32_to_cpus(&s->pagetable[i]);\n\n            if (s->pagetable[i] != 0xFFFFFFFF) {\n\n                int64_t next = (512 * (int64_t) s->pagetable[i]) +\n\n                    s->bitmap_size + s->block_size;\n\n\n\n                if (next > s->free_data_block_offset) {\n\n                    s->free_data_block_offset = next;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (s->free_data_block_offset > bdrv_getlength(bs->file)) {\n\n            error_setg(errp, \"block-vpc: free_data_block_offset points after \"\n\n                             \"the end of file. The image has been truncated.\");\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n\n\n        s->last_bitmap_offset = (int64_t) -1;\n\n\n\n#ifdef CACHE\n\n        s->pageentry_u8 = g_malloc(512);\n\n        s->pageentry_u32 = s->pageentry_u8;\n\n        s->pageentry_u16 = s->pageentry_u8;\n\n        s->last_pagetable = -1;\n\n#endif\n\n    }\n\n\n\n    qemu_co_mutex_init(&s->lock);\n\n\n\n    /* Disable migration when VHD images are used */\n\n    error_set(&s->migration_blocker,\n\n              QERR_BLOCK_FORMAT_FEATURE_NOT_SUPPORTED,\n\n              \"vpc\", bs->device_name, \"live migration\");\n\n    migrate_add_blocker(s->migration_blocker);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    g_free(s->pagetable);\n\n#ifdef CACHE\n\n    g_free(s->pageentry_u8);\n\n#endif\n\n    return ret;\n\n}\n", "idx": 6679, "_split": "valid", "_hash": "fa31a10377fede4e547c89dc4e12f625"}
{"project": "qemu", "commit_id": "5ee5993001cf32addb86a92e2ae8cb090fbc1462", "target": 1, "func": "void helper_done(CPUSPARCState *env)\n\n{\n\n    trap_state *tsptr = cpu_tsptr(env);\n\n\n\n    env->pc = tsptr->tnpc;\n\n    env->npc = tsptr->tnpc + 4;\n\n    cpu_put_ccr(env, tsptr->tstate >> 32);\n\n    env->asi = (tsptr->tstate >> 24) & 0xff;\n\n    cpu_change_pstate(env, (tsptr->tstate >> 8) & 0xf3f);\n\n    cpu_put_cwp64(env, tsptr->tstate & 0xff);\n\n    if (cpu_has_hypervisor(env)) {\n\n        uint32_t new_gl = (tsptr->tstate >> 40) & 7;\n\n        env->hpstate = env->htstate[env->tl];\n\n        cpu_gl_switch_gregs(env, new_gl);\n\n        env->gl = new_gl;\n\n    }\n\n    env->tl--;\n\n\n\n    trace_win_helper_done(env->tl);\n\n\n\n#if !defined(CONFIG_USER_ONLY)\n\n    if (cpu_interrupts_enabled(env)) {\n\n\n        cpu_check_irqs(env);\n\n\n    }\n\n#endif\n\n}", "idx": 6682, "_split": "valid", "_hash": "c9d138b33d17931bafbe2744bc0f29e5"}
{"project": "qemu", "commit_id": "4f8eb8daebd72bdc214c63a3b2577f95bbadb27d", "target": 1, "func": "void CALLBACK host_alarm_handler(UINT uTimerID, UINT uMsg,\n\n                                 DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2)\n\n#else\n\nstatic void host_alarm_handler(int host_signum)\n\n#endif\n\n{\n\n#if 0\n\n#define DISP_FREQ 1000\n\n    {\n\n        static int64_t delta_min = INT64_MAX;\n\n        static int64_t delta_max, delta_cum, last_clock, delta, ti;\n\n        static int count;\n\n        ti = qemu_get_clock(vm_clock);\n\n        if (last_clock != 0) {\n\n            delta = ti - last_clock;\n\n            if (delta < delta_min)\n\n                delta_min = delta;\n\n            if (delta > delta_max)\n\n                delta_max = delta;\n\n            delta_cum += delta;\n\n            if (++count == DISP_FREQ) {\n\n                printf(\"timer: min=%\" PRId64 \" us max=%\" PRId64 \" us avg=%\" PRId64 \" us avg_freq=%0.3f Hz\\n\",\n\n                       muldiv64(delta_min, 1000000, ticks_per_sec),\n\n                       muldiv64(delta_max, 1000000, ticks_per_sec),\n\n                       muldiv64(delta_cum, 1000000 / DISP_FREQ, ticks_per_sec),\n\n                       (double)ticks_per_sec / ((double)delta_cum / DISP_FREQ));\n\n                count = 0;\n\n                delta_min = INT64_MAX;\n\n                delta_max = 0;\n\n                delta_cum = 0;\n\n            }\n\n        }\n\n        last_clock = ti;\n\n    }\n\n#endif\n\n    if (alarm_has_dynticks(alarm_timer) ||\n\n        qemu_timer_expired(active_timers[QEMU_TIMER_VIRTUAL],\n\n                           qemu_get_clock(vm_clock)) ||\n\n        qemu_timer_expired(active_timers[QEMU_TIMER_REALTIME],\n\n                           qemu_get_clock(rt_clock))) {\n\n#ifdef _WIN32\n\n        struct qemu_alarm_win32 *data = ((struct qemu_alarm_timer*)dwUser)->priv;\n\n        SetEvent(data->host_alarm);\n\n#endif\n\n        CPUState *env = next_cpu;\n\n\n\n        /* stop the currently executing cpu because a timer occured */\n\n        cpu_interrupt(env, CPU_INTERRUPT_EXIT);\n\n#ifdef USE_KQEMU\n\n        if (env->kqemu_enabled) {\n\n            kqemu_cpu_interrupt(env);\n\n        }\n\n#endif\n\n        event_pending = 1;\n\n    }\n\n}\n", "idx": 6686, "_split": "valid", "_hash": "7d2c9ee1dddce8d80c9584b17b10aed9"}
{"project": "qemu", "commit_id": "5b498459b441f4639fd4c39c35345637bfc6c16c", "target": 1, "func": "static void tcp_chr_disconnect(CharDriverState *chr)\n\n{\n\n    TCPCharDriver *s = chr->opaque;\n\n\n\n    if (!s->connected) {\n\n        return;\n\n    }\n\n\n\n    s->connected = 0;\n\n    if (s->listen_ioc) {\n\n        s->listen_tag = qio_channel_add_watch(\n\n            QIO_CHANNEL(s->listen_ioc), G_IO_IN, tcp_chr_accept, chr, NULL);\n\n    }\n\n    tcp_set_msgfds(chr, NULL, 0);\n\n    remove_fd_in_watch(chr);\n\n    object_unref(OBJECT(s->sioc));\n\n    s->sioc = NULL;\n\n    object_unref(OBJECT(s->ioc));\n\n    s->ioc = NULL;\n\n    g_free(chr->filename);\n\n    chr->filename = SocketAddress_to_str(\"disconnected:\", s->addr,\n\n                                         s->is_listen, s->is_telnet);\n\n    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);\n\n    if (s->reconnect_time) {\n\n        qemu_chr_socket_restart_timer(chr);\n\n    }\n\n}\n", "idx": 6710, "_split": "valid", "_hash": "1fd05fd412fdc95ac91cc32fc3a0be8f"}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static inline void menelaus_rtc_stop(MenelausState *s)\n\n{\n\n    qemu_del_timer(s->rtc.hz_tm);\n\n    s->rtc.next -= qemu_get_clock(rt_clock);\n\n    if (s->rtc.next < 1)\n\n        s->rtc.next = 1;\n\n}\n", "idx": 6740, "_split": "valid", "_hash": "890b5db3ceb9358c1215ef623651cf5a"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "int ide_get_geometry(BusState *bus, int unit,\n\n                     int16_t *cyls, int8_t *heads, int8_t *secs)\n\n{\n\n    IDEState *s = &DO_UPCAST(IDEBus, qbus, bus)->ifs[unit];\n\n\n\n    if (s->drive_kind != IDE_HD || !s->bs) {\n\n        return -1;\n\n    }\n\n\n\n    *cyls = s->cylinders;\n\n    *heads = s->heads;\n\n    *secs = s->sectors;\n\n    return 0;\n\n}\n", "idx": 6748, "_split": "valid", "_hash": "cf3a641d224c2bde0f84397615a7d1ae"}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_dcread(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    TCGv EA, val;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_set_access_type(ctx, ACCESS_CACHE);\n\n    EA = tcg_temp_new();\n\n    gen_addr_reg_index(ctx, EA);\n\n    val = tcg_temp_new();\n\n    gen_qemu_ld32u(ctx, val, EA);\n\n    tcg_temp_free(val);\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], EA);\n\n    tcg_temp_free(EA);\n\n#endif\n\n}\n", "idx": 6809, "_split": "valid", "_hash": "9d3491f2d32d9fde74b19bdf04b63411"}
{"project": "qemu", "commit_id": "b0b6862e5e1a1394e0ab3d5da94ba8b0da8664e2", "target": 1, "func": "uint64_t qcow2_alloc_compressed_cluster_offset(BlockDriverState *bs,\n\n                                               uint64_t offset,\n\n                                               int compressed_size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l2_index, ret;\n\n    uint64_t *l2_table;\n\n    int64_t cluster_offset;\n\n    int nb_csectors;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return 0;\n\n    }\n\n\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n    if (cluster_offset & QCOW_OFLAG_COPIED) {\n\n        qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n        return 0;\n\n    }\n\n\n\n    if (cluster_offset)\n\n        qcow2_free_any_clusters(bs, cluster_offset, 1);\n\n\n\n    cluster_offset = qcow2_alloc_bytes(bs, compressed_size);\n\n    if (cluster_offset < 0) {\n\n        qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n        return 0;\n\n    }\n\n\n\n    nb_csectors = ((cluster_offset + compressed_size - 1) >> 9) -\n\n                  (cluster_offset >> 9);\n\n\n\n    cluster_offset |= QCOW_OFLAG_COMPRESSED |\n\n                      ((uint64_t)nb_csectors << s->csize_shift);\n\n\n\n    /* update L2 table */\n\n\n\n    /* compressed clusters never have the copied flag */\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L2_UPDATE_COMPRESSED);\n\n    qcow2_cache_entry_mark_dirty(s->l2_table_cache, l2_table);\n\n    l2_table[l2_index] = cpu_to_be64(cluster_offset);\n\n    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n    if (ret < 0) {\n\n        return 0;\n\n    }\n\n\n\n    return cluster_offset;\n\n}\n", "idx": 6810, "_split": "valid", "_hash": "a6b177ebf488830093bbae5fff4b0c14"}
{"project": "qemu", "commit_id": "4cad3867b6df2c0826ae508a9fe15dd0b9d8936a", "target": 1, "func": "int fw_cfg_add_i64(FWCfgState *s, uint16_t key, uint64_t value)\n\n{\n\n    uint64_t *copy;\n\n\n\n    copy = g_malloc(sizeof(value));\n\n    *copy = cpu_to_le64(value);\n\n    return fw_cfg_add_bytes(s, key, (uint8_t *)copy, sizeof(value));\n\n}\n", "idx": 6815, "_split": "valid", "_hash": "323e5a52155144e9b10a43c1c5afc4ea"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static uint16_t nvme_del_sq(NvmeCtrl *n, NvmeCmd *cmd)\n\n{\n\n    NvmeDeleteQ *c = (NvmeDeleteQ *)cmd;\n\n    NvmeRequest *req, *next;\n\n    NvmeSQueue *sq;\n\n    NvmeCQueue *cq;\n\n    uint16_t qid = le16_to_cpu(c->qid);\n\n\n\n    if (!qid || nvme_check_sqid(n, qid)) {\n\n        return NVME_INVALID_QID | NVME_DNR;\n\n    }\n\n\n\n    sq = n->sq[qid];\n\n    while (!QTAILQ_EMPTY(&sq->out_req_list)) {\n\n        req = QTAILQ_FIRST(&sq->out_req_list);\n\n        assert(req->aiocb);\n\n        bdrv_aio_cancel(req->aiocb);\n\n    }\n\n    if (!nvme_check_cqid(n, sq->cqid)) {\n\n        cq = n->cq[sq->cqid];\n\n        QTAILQ_REMOVE(&cq->sq_list, sq, entry);\n\n\n\n        nvme_post_cqes(cq);\n\n        QTAILQ_FOREACH_SAFE(req, &cq->req_list, entry, next) {\n\n            if (req->sq == sq) {\n\n                QTAILQ_REMOVE(&cq->req_list, req, entry);\n\n                QTAILQ_INSERT_TAIL(&sq->req_list, req, entry);\n\n            }\n\n        }\n\n    }\n\n\n\n    nvme_free_sq(sq, n);\n\n    return NVME_SUCCESS;\n\n}\n", "idx": 6826, "_split": "valid", "_hash": "f63fc73a31047a214b57579bcaae8bb1"}
{"project": "qemu", "commit_id": "2a7e6857cd3178d705a49c4adde2f3af26ed3ae1", "target": 0, "func": "static void qmp_query_auth(VncDisplay *vd, VncInfo2 *info)\n\n{\n\n    switch (vd->auth) {\n\n    case VNC_AUTH_VNC:\n\n        info->auth = VNC_PRIMARY_AUTH_VNC;\n\n        break;\n\n    case VNC_AUTH_RA2:\n\n        info->auth = VNC_PRIMARY_AUTH_RA2;\n\n        break;\n\n    case VNC_AUTH_RA2NE:\n\n        info->auth = VNC_PRIMARY_AUTH_RA2NE;\n\n        break;\n\n    case VNC_AUTH_TIGHT:\n\n        info->auth = VNC_PRIMARY_AUTH_TIGHT;\n\n        break;\n\n    case VNC_AUTH_ULTRA:\n\n        info->auth = VNC_PRIMARY_AUTH_ULTRA;\n\n        break;\n\n    case VNC_AUTH_TLS:\n\n        info->auth = VNC_PRIMARY_AUTH_TLS;\n\n        break;\n\n    case VNC_AUTH_VENCRYPT:\n\n        info->auth = VNC_PRIMARY_AUTH_VENCRYPT;\n\n        info->has_vencrypt = true;\n\n        switch (vd->subauth) {\n\n        case VNC_AUTH_VENCRYPT_PLAIN:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_PLAIN;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_TLSNONE:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_TLS_NONE;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_TLSVNC:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_TLS_VNC;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_TLSPLAIN:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_TLS_PLAIN;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_X509NONE:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_X509_NONE;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_X509VNC:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_X509_VNC;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_X509PLAIN:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_X509_PLAIN;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_TLSSASL:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_TLS_SASL;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_X509SASL:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_X509_SASL;\n\n            break;\n\n        default:\n\n            info->has_vencrypt = false;\n\n            break;\n\n        }\n\n        break;\n\n    case VNC_AUTH_SASL:\n\n        info->auth = VNC_PRIMARY_AUTH_SASL;\n\n        break;\n\n    case VNC_AUTH_NONE:\n\n    default:\n\n        info->auth = VNC_PRIMARY_AUTH_NONE;\n\n        break;\n\n    }\n\n}\n", "idx": 6833, "_split": "valid", "_hash": "b4af640158d801d3bcf32c325edc9f4c"}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_multiply(TCGv dst, TCGv src1, TCGv src2, int sign_ext)\n\n{\n\n    TCGv_i32 r_src1, r_src2;\n\n    TCGv_i64 r_temp, r_temp2;\n\n\n\n    r_src1 = tcg_temp_new_i32();\n\n    r_src2 = tcg_temp_new_i32();\n\n\n\n    tcg_gen_trunc_tl_i32(r_src1, src1);\n\n    tcg_gen_trunc_tl_i32(r_src2, src2);\n\n\n\n    r_temp = tcg_temp_new_i64();\n\n    r_temp2 = tcg_temp_new_i64();\n\n\n\n    if (sign_ext) {\n\n        tcg_gen_ext_i32_i64(r_temp, r_src2);\n\n        tcg_gen_ext_i32_i64(r_temp2, r_src1);\n\n    } else {\n\n        tcg_gen_extu_i32_i64(r_temp, r_src2);\n\n        tcg_gen_extu_i32_i64(r_temp2, r_src1);\n\n    }\n\n\n\n    tcg_gen_mul_i64(r_temp2, r_temp, r_temp2);\n\n\n\n    tcg_gen_shri_i64(r_temp, r_temp2, 32);\n\n    tcg_gen_trunc_i64_tl(cpu_tmp0, r_temp);\n\n    tcg_temp_free_i64(r_temp);\n\n    tcg_gen_andi_tl(cpu_y, cpu_tmp0, 0xffffffff);\n\n\n\n    tcg_gen_trunc_i64_tl(dst, r_temp2);\n\n\n\n    tcg_temp_free_i64(r_temp2);\n\n\n\n    tcg_temp_free_i32(r_src1);\n\n    tcg_temp_free_i32(r_src2);\n\n}\n", "idx": 6835, "_split": "valid", "_hash": "fc3b3c07ee172976daa38df77ecee179"}
{"project": "qemu", "commit_id": "2f4dc3c1b2a453a8255d9b97c7cb87860123e495", "target": 0, "func": "AioContext *aio_context_new(void)\n\n{\n\n    return (AioContext *) g_source_new(&aio_source_funcs, sizeof(AioContext));\n\n}\n", "idx": 6839, "_split": "valid", "_hash": "03c35a4082401603638ac5ec50bf7da8"}
{"project": "qemu", "commit_id": "713d9675e0e31c627d08b6a33d3a92e4b8505b40", "target": 0, "func": "static int check_refcounts_l1(BlockDriverState *bs,\n\n                              BdrvCheckResult *res,\n\n                              uint16_t *refcount_table,\n\n                              int refcount_table_size,\n\n                              int64_t l1_table_offset, int l1_size,\n\n                              int flags)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l1_table, l2_offset, l1_size2;\n\n    int i, ret;\n\n\n\n    l1_size2 = l1_size * sizeof(uint64_t);\n\n\n\n    /* Mark L1 table as used */\n\n    inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n        l1_table_offset, l1_size2);\n\n\n\n    /* Read L1 table entries from disk */\n\n    if (l1_size2 == 0) {\n\n        l1_table = NULL;\n\n    } else {\n\n        l1_table = g_try_malloc(l1_size2);\n\n        if (l1_table == NULL) {\n\n            ret = -ENOMEM;\n\n            goto fail;\n\n        }\n\n        if (bdrv_pread(bs->file, l1_table_offset,\n\n                       l1_table, l1_size2) != l1_size2)\n\n            goto fail;\n\n        for(i = 0;i < l1_size; i++)\n\n            be64_to_cpus(&l1_table[i]);\n\n    }\n\n\n\n    /* Do the actual checks */\n\n    for(i = 0; i < l1_size; i++) {\n\n        l2_offset = l1_table[i];\n\n        if (l2_offset) {\n\n            /* Mark L2 table as used */\n\n            l2_offset &= L1E_OFFSET_MASK;\n\n            inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                l2_offset, s->cluster_size);\n\n\n\n            /* L2 tables are cluster aligned */\n\n            if (offset_into_cluster(s, l2_offset)) {\n\n                fprintf(stderr, \"ERROR l2_offset=%\" PRIx64 \": Table is not \"\n\n                    \"cluster aligned; L1 entry corrupted\\n\", l2_offset);\n\n                res->corruptions++;\n\n            }\n\n\n\n            /* Process and check L2 entries */\n\n            ret = check_refcounts_l2(bs, res, refcount_table,\n\n                                     refcount_table_size, l2_offset, flags);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n    g_free(l1_table);\n\n    return 0;\n\n\n\nfail:\n\n    fprintf(stderr, \"ERROR: I/O error in check_refcounts_l1\\n\");\n\n    res->check_errors++;\n\n    g_free(l1_table);\n\n    return -EIO;\n\n}\n", "idx": 6856, "_split": "valid", "_hash": "67d0404b1f7fd52013ef8e8f5c864def"}
{"project": "qemu", "commit_id": "28290f37e20cda27574f15be9e9499493e3d0fe8", "target": 0, "func": "void ppce500_init(QEMUMachineInitArgs *args, PPCE500Params *params)\n\n{\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    PCIBus *pci_bus;\n\n    CPUPPCState *env = NULL;\n\n    uint64_t elf_entry;\n\n    uint64_t elf_lowaddr;\n\n    hwaddr entry=0;\n\n    hwaddr loadaddr=UIMAGE_LOAD_BASE;\n\n    target_long kernel_size=0;\n\n    target_ulong dt_base = 0;\n\n    target_ulong initrd_base = 0;\n\n    target_long initrd_size = 0;\n\n    target_ulong cur_base = 0;\n\n    int i;\n\n    unsigned int pci_irq_nrs[4] = {1, 2, 3, 4};\n\n    qemu_irq **irqs, *mpic;\n\n    DeviceState *dev;\n\n    CPUPPCState *firstenv = NULL;\n\n    MemoryRegion *ccsr_addr_space;\n\n    SysBusDevice *s;\n\n    PPCE500CCSRState *ccsr;\n\n\n\n    /* Setup CPUs */\n\n    if (args->cpu_model == NULL) {\n\n        args->cpu_model = \"e500v2_v30\";\n\n    }\n\n\n\n    irqs = g_malloc0(smp_cpus * sizeof(qemu_irq *));\n\n    irqs[0] = g_malloc0(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        PowerPCCPU *cpu;\n\n        CPUState *cs;\n\n        qemu_irq *input;\n\n\n\n        cpu = cpu_ppc_init(args->cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n        cs = CPU(cpu);\n\n\n\n        if (!firstenv) {\n\n            firstenv = env;\n\n        }\n\n\n\n        irqs[i] = irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n        input = (qemu_irq *)env->irq_inputs;\n\n        irqs[i][OPENPIC_OUTPUT_INT] = input[PPCE500_INPUT_INT];\n\n        irqs[i][OPENPIC_OUTPUT_CINT] = input[PPCE500_INPUT_CINT];\n\n        env->spr[SPR_BOOKE_PIR] = cs->cpu_index = i;\n\n        env->mpic_iack = MPC8544_CCSRBAR_BASE +\n\n                         MPC8544_MPIC_REGS_OFFSET + 0xa0;\n\n\n\n        ppc_booke_timers_init(cpu, 400000000, PPC_TIMER_E500);\n\n\n\n        /* Register reset handler */\n\n        if (!i) {\n\n            /* Primary CPU */\n\n            struct boot_info *boot_info;\n\n            boot_info = g_malloc0(sizeof(struct boot_info));\n\n            qemu_register_reset(ppce500_cpu_reset, cpu);\n\n            env->load_info = boot_info;\n\n        } else {\n\n            /* Secondary CPUs */\n\n            qemu_register_reset(ppce500_cpu_reset_sec, cpu);\n\n        }\n\n    }\n\n\n\n    env = firstenv;\n\n\n\n    /* Fixup Memory size on a alignment boundary */\n\n    ram_size &= ~(RAM_SIZES_ALIGN - 1);\n\n    args->ram_size = ram_size;\n\n\n\n    /* Register Memory */\n\n    memory_region_init_ram(ram, NULL, \"mpc8544ds.ram\", ram_size);\n\n    vmstate_register_ram_global(ram);\n\n    memory_region_add_subregion(address_space_mem, 0, ram);\n\n\n\n    dev = qdev_create(NULL, \"e500-ccsr\");\n\n    object_property_add_child(qdev_get_machine(), \"e500-ccsr\",\n\n                              OBJECT(dev), NULL);\n\n    qdev_init_nofail(dev);\n\n    ccsr = CCSR(dev);\n\n    ccsr_addr_space = &ccsr->ccsr_space;\n\n    memory_region_add_subregion(address_space_mem, MPC8544_CCSRBAR_BASE,\n\n                                ccsr_addr_space);\n\n\n\n    mpic = ppce500_init_mpic(params, ccsr_addr_space, irqs);\n\n\n\n    /* Serial */\n\n    if (serial_hds[0]) {\n\n        serial_mm_init(ccsr_addr_space, MPC8544_SERIAL0_REGS_OFFSET,\n\n                       0, mpic[42], 399193,\n\n                       serial_hds[0], DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    if (serial_hds[1]) {\n\n        serial_mm_init(ccsr_addr_space, MPC8544_SERIAL1_REGS_OFFSET,\n\n                       0, mpic[42], 399193,\n\n                       serial_hds[1], DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    /* General Utility device */\n\n    dev = qdev_create(NULL, \"mpc8544-guts\");\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n    memory_region_add_subregion(ccsr_addr_space, MPC8544_UTIL_OFFSET,\n\n                                sysbus_mmio_get_region(s, 0));\n\n\n\n    /* PCI */\n\n    dev = qdev_create(NULL, \"e500-pcihost\");\n\n    qdev_prop_set_uint32(dev, \"first_slot\", params->pci_first_slot);\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n    sysbus_connect_irq(s, 0, mpic[pci_irq_nrs[0]]);\n\n    sysbus_connect_irq(s, 1, mpic[pci_irq_nrs[1]]);\n\n    sysbus_connect_irq(s, 2, mpic[pci_irq_nrs[2]]);\n\n    sysbus_connect_irq(s, 3, mpic[pci_irq_nrs[3]]);\n\n    memory_region_add_subregion(ccsr_addr_space, MPC8544_PCI_REGS_OFFSET,\n\n                                sysbus_mmio_get_region(s, 0));\n\n\n\n    pci_bus = (PCIBus *)qdev_get_child_bus(dev, \"pci.0\");\n\n    if (!pci_bus)\n\n        printf(\"couldn't create PCI controller!\\n\");\n\n\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 1, MPC8544_PCI_IO);\n\n\n\n    if (pci_bus) {\n\n        /* Register network interfaces. */\n\n        for (i = 0; i < nb_nics; i++) {\n\n            pci_nic_init_nofail(&nd_table[i], pci_bus, \"virtio\", NULL);\n\n        }\n\n    }\n\n\n\n    /* Register spinning region */\n\n    sysbus_create_simple(\"e500-spin\", MPC8544_SPIN_BASE, NULL);\n\n\n\n    /* Load kernel. */\n\n    if (args->kernel_filename) {\n\n        kernel_size = load_uimage(args->kernel_filename, &entry,\n\n                                  &loadaddr, NULL);\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_elf(args->kernel_filename, NULL, NULL,\n\n                                   &elf_entry, &elf_lowaddr, NULL, 1,\n\n                                   ELF_MACHINE, 0);\n\n            entry = elf_entry;\n\n            loadaddr = elf_lowaddr;\n\n        }\n\n        /* XXX try again as binary */\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    args->kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        cur_base = loadaddr + kernel_size;\n\n\n\n        /* Reserve space for dtb */\n\n        dt_base = (cur_base + DTC_LOAD_PAD) & ~DTC_PAD_MASK;\n\n        cur_base += DTB_MAX_SIZE;\n\n    }\n\n\n\n    /* Load initrd. */\n\n    if (args->initrd_filename) {\n\n        initrd_base = (cur_base + INITRD_LOAD_PAD) & ~INITRD_PAD_MASK;\n\n        initrd_size = load_image_targphys(args->initrd_filename, initrd_base,\n\n                                          ram_size - initrd_base);\n\n\n\n        if (initrd_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    args->initrd_filename);\n\n            exit(1);\n\n        }\n\n\n\n        cur_base = initrd_base + initrd_size;\n\n    }\n\n\n\n    /* If we're loading a kernel directly, we must load the device tree too. */\n\n    if (args->kernel_filename) {\n\n        struct boot_info *boot_info;\n\n        int dt_size;\n\n\n\n        dt_size = ppce500_load_device_tree(env, args, params, dt_base,\n\n                                           initrd_base, initrd_size);\n\n        if (dt_size < 0) {\n\n            fprintf(stderr, \"couldn't load device tree\\n\");\n\n            exit(1);\n\n        }\n\n        assert(dt_size < DTB_MAX_SIZE);\n\n\n\n        boot_info = env->load_info;\n\n        boot_info->entry = entry;\n\n        boot_info->dt_base = dt_base;\n\n        boot_info->dt_size = dt_size;\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        kvmppc_init();\n\n    }\n\n}\n", "idx": 6864, "_split": "valid", "_hash": "42af8209f1fa41765900e0ec2d7ca6f4"}
{"project": "qemu", "commit_id": "b062ad86dcd33ab39be5060b0655d8e13834b167", "target": 0, "func": "static int write_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0, Pflag = 0, zflag = 0;\n\n    int cflag = 0;\n\n    int c, cnt;\n\n    char *buf = NULL;\n\n    int64_t offset;\n\n    int count;\n\n    /* Some compilers get confused and warn if this is not initialized.  */\n\n    int total = 0;\n\n    int pattern = 0xcd;\n\n\n\n    while ((c = getopt(argc, argv, \"bcCpP:qz\")) != EOF) {\n\n        switch (c) {\n\n        case 'b':\n\n            bflag = 1;\n\n            break;\n\n        case 'c':\n\n            cflag = 1;\n\n            break;\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'p':\n\n            pflag = 1;\n\n            break;\n\n        case 'P':\n\n            Pflag = 1;\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        case 'z':\n\n            zflag = 1;\n\n            break;\n\n        default:\n\n            return qemuio_command_usage(&write_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind != argc - 2) {\n\n        return qemuio_command_usage(&write_cmd);\n\n    }\n\n\n\n    if (bflag + pflag + zflag > 1) {\n\n        printf(\"-b, -p, or -z cannot be specified at the same time\\n\");\n\n        return 0;\n\n    }\n\n\n\n    if (zflag && Pflag) {\n\n        printf(\"-z and -P cannot be specified at the same time\\n\");\n\n        return 0;\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    optind++;\n\n    count = cvtnum(argv[optind]);\n\n    if (count < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    if (!pflag) {\n\n        if (offset & 0x1ff) {\n\n            printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n                   offset);\n\n            return 0;\n\n        }\n\n\n\n        if (count & 0x1ff) {\n\n            printf(\"count %d is not sector aligned\\n\",\n\n                   count);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    if (!zflag) {\n\n        buf = qemu_io_alloc(blk, count, pattern);\n\n    }\n\n\n\n    gettimeofday(&t1, NULL);\n\n    if (pflag) {\n\n        cnt = do_pwrite(blk, buf, offset, count, &total);\n\n    } else if (bflag) {\n\n        cnt = do_save_vmstate(blk, buf, offset, count, &total);\n\n    } else if (zflag) {\n\n        cnt = do_co_write_zeroes(blk, offset, count, &total);\n\n    } else if (cflag) {\n\n        cnt = do_write_compressed(blk, buf, offset, count, &total);\n\n    } else {\n\n        cnt = do_write(blk, buf, offset, count, &total);\n\n    }\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"write failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"wrote\", &t2, offset, count, total, cnt, Cflag);\n\n\n\nout:\n\n    if (!zflag) {\n\n        qemu_io_free(buf);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6866, "_split": "valid", "_hash": "c3da606b62a99574068625051c2e44e8"}
{"project": "qemu", "commit_id": "032a7c4e425f1f0b71942768696f53f93947f8fa", "target": 1, "func": "static int lance_init(SysBusDevice *dev)\n\n{\n\n    SysBusPCNetState *d = FROM_SYSBUS(SysBusPCNetState, dev);\n\n    PCNetState *s = &d->state;\n\n\n\n    memory_region_init_io(&s->mmio, &lance_mem_ops, s, \"lance-mmio\", 4);\n\n\n\n    qdev_init_gpio_in(&dev->qdev, parent_lance_reset, 1);\n\n\n\n    sysbus_init_mmio_region(dev, &s->mmio);\n\n\n\n    sysbus_init_irq(dev, &s->irq);\n\n\n\n    s->phys_mem_read = ledma_memory_read;\n\n    s->phys_mem_write = ledma_memory_write;\n\n    return pcnet_common_init(&dev->qdev, s, &net_lance_info);\n\n}\n", "idx": 6886, "_split": "valid", "_hash": "ef6ba5f859e471df860c929968a29c9f"}
{"project": "qemu", "commit_id": "d42cf28837801cd1f835089fe9db2a42a1af55cd", "target": 0, "func": "void bdrv_drained_begin(BlockDriverState *bs)\n\n{\n\n    if (!bs->quiesce_counter++) {\n\n        aio_disable_external(bdrv_get_aio_context(bs));\n\n        bdrv_parent_drained_begin(bs);\n\n    }\n\n\n\n    bdrv_io_unplugged_begin(bs);\n\n    bdrv_drain_recurse(bs);\n\n    if (qemu_in_coroutine()) {\n\n        bdrv_co_yield_to_drain(bs);\n\n    } else {\n\n        bdrv_drain_poll(bs);\n\n    }\n\n    bdrv_io_unplugged_end(bs);\n\n}\n", "idx": 6921, "_split": "valid", "_hash": "c34eb2b8ede1c2ace3812a9de3ed0361"}
{"project": "qemu", "commit_id": "e4a3507e86a1ef1453d603031bca27d5ac4cff3c", "target": 0, "func": "static ssize_t block_crypto_init_func(QCryptoBlock *block,\n\n                                      void *opaque,\n\n                                      size_t headerlen,\n\n                                      Error **errp)\n\n{\n\n    struct BlockCryptoCreateData *data = opaque;\n\n    int ret;\n\n\n\n    /* User provided size should reflect amount of space made\n\n     * available to the guest, so we must take account of that\n\n     * which will be used by the crypto header\n\n     */\n\n    data->size += headerlen;\n\n\n\n    qemu_opt_set_number(data->opts, BLOCK_OPT_SIZE, data->size, &error_abort);\n\n    ret = bdrv_create_file(data->filename, data->opts, errp);\n\n    if (ret < 0) {\n\n        return -1;\n\n    }\n\n\n\n    data->blk = blk_new_open(data->filename, NULL, NULL,\n\n                             BDRV_O_RDWR | BDRV_O_PROTOCOL, errp);\n\n    if (!data->blk) {\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6931, "_split": "valid", "_hash": "ab8dae541af54745b3851108ec170279"}
{"project": "qemu", "commit_id": "6977dfe6af975d72a8140dbc91effe8b8f2a58f8", "target": 0, "func": "ram_addr_t qemu_ram_alloc(DeviceState *dev, const char *name, ram_addr_t size)\n\n{\n\n    RAMBlock *new_block, *block;\n\n\n\n    size = TARGET_PAGE_ALIGN(size);\n\n    new_block = qemu_mallocz(sizeof(*new_block));\n\n\n\n    if (dev && dev->parent_bus && dev->parent_bus->info->get_dev_path) {\n\n        char *id = dev->parent_bus->info->get_dev_path(dev);\n\n        if (id) {\n\n            snprintf(new_block->idstr, sizeof(new_block->idstr), \"%s/\", id);\n\n            qemu_free(id);\n\n        }\n\n    }\n\n    pstrcat(new_block->idstr, sizeof(new_block->idstr), name);\n\n\n\n    QLIST_FOREACH(block, &ram_list.blocks, next) {\n\n        if (!strcmp(block->idstr, new_block->idstr)) {\n\n            fprintf(stderr, \"RAMBlock \\\"%s\\\" already registered, abort!\\n\",\n\n                    new_block->idstr);\n\n            abort();\n\n        }\n\n    }\n\n\n\n    if (mem_path) {\n\n#if defined (__linux__) && !defined(TARGET_S390X)\n\n        new_block->host = file_ram_alloc(new_block, size, mem_path);\n\n        if (!new_block->host) {\n\n            new_block->host = qemu_vmalloc(size);\n\n#ifdef MADV_MERGEABLE\n\n            madvise(new_block->host, size, MADV_MERGEABLE);\n\n#endif\n\n        }\n\n#else\n\n        fprintf(stderr, \"-mem-path option unsupported\\n\");\n\n        exit(1);\n\n#endif\n\n    } else {\n\n#if defined(TARGET_S390X) && defined(CONFIG_KVM)\n\n        /* XXX S390 KVM requires the topmost vma of the RAM to be < 256GB */\n\n        new_block->host = mmap((void*)0x1000000, size,\n\n                                PROT_EXEC|PROT_READ|PROT_WRITE,\n\n                                MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n\n#else\n\n        new_block->host = qemu_vmalloc(size);\n\n#endif\n\n#ifdef MADV_MERGEABLE\n\n        madvise(new_block->host, size, MADV_MERGEABLE);\n\n#endif\n\n    }\n\n    new_block->offset = find_ram_offset(size);\n\n    new_block->length = size;\n\n\n\n    QLIST_INSERT_HEAD(&ram_list.blocks, new_block, next);\n\n\n\n    ram_list.phys_dirty = qemu_realloc(ram_list.phys_dirty,\n\n                                       last_ram_offset() >> TARGET_PAGE_BITS);\n\n    memset(ram_list.phys_dirty + (new_block->offset >> TARGET_PAGE_BITS),\n\n           0xff, size >> TARGET_PAGE_BITS);\n\n\n\n    if (kvm_enabled())\n\n        kvm_setup_guest_memory(new_block->host, size);\n\n\n\n    return new_block->offset;\n\n}\n", "idx": 6933, "_split": "valid", "_hash": "6ec500703d2d6b4d9d488352c3abd6c5"}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "void HELPER(ucf64_set_fpscr)(CPUUniCore32State *env, uint32_t val)\n\n{\n\n    int i;\n\n    uint32_t changed;\n\n\n\n    changed = env->ucf64.xregs[UC32_UCF64_FPSCR];\n\n    env->ucf64.xregs[UC32_UCF64_FPSCR] = (val & UCF64_FPSCR_MASK);\n\n\n\n    changed ^= val;\n\n    if (changed & (UCF64_FPSCR_RND_MASK)) {\n\n        i = UCF64_FPSCR_RND(val);\n\n        switch (i) {\n\n        case 0:\n\n            i = float_round_nearest_even;\n\n            break;\n\n        case 1:\n\n            i = float_round_to_zero;\n\n            break;\n\n        case 2:\n\n            i = float_round_up;\n\n            break;\n\n        case 3:\n\n            i = float_round_down;\n\n            break;\n\n        default: /* 100 and 101 not implement */\n\n            cpu_abort(env, \"Unsupported UniCore-F64 round mode\");\n\n        }\n\n        set_float_rounding_mode(i, &env->ucf64.fp_status);\n\n    }\n\n\n\n    i = ucf64_exceptbits_to_host(UCF64_FPSCR_TRAPEN(val));\n\n    set_float_exception_flags(i, &env->ucf64.fp_status);\n\n}\n", "idx": 6941, "_split": "valid", "_hash": "ca26d8c9de50a653bd19bc82465f4cc3"}
{"project": "qemu", "commit_id": "e04fb07fd1676e9facd7f3f878c1bbe03bccd26b", "target": 1, "func": "static void qemu_rbd_close(BlockDriverState *bs)\n\n{\n\n    BDRVRBDState *s = bs->opaque;\n\n\n\n    close(s->fds[0]);\n\n    close(s->fds[1]);\n\n    qemu_aio_set_fd_handler(s->fds[RBD_FD_READ], NULL, NULL, NULL);\n\n\n\n    rbd_close(s->image);\n\n    rados_ioctx_destroy(s->io_ctx);\n\n    g_free(s->snap);\n\n    rados_shutdown(s->cluster);\n\n}\n", "idx": 6960, "_split": "valid", "_hash": "7992cfe170be93fc524f77d1c1186f3b"}
{"project": "qemu", "commit_id": "d6cf84e1de0a167963f0803d6e39f6ca03e27eaa", "target": 0, "func": "void slirp_output(const uint8_t *pkt, int pkt_len)\n\n{\n\n#ifdef DEBUG_SLIRP\n\n    printf(\"slirp output:\\n\");\n\n    hex_dump(stdout, pkt, pkt_len);\n\n#endif\n\n    if (!slirp_vc)\n\n        return;\n\n    qemu_send_packet(slirp_vc, pkt, pkt_len);\n\n}\n", "idx": 7021, "_split": "valid", "_hash": "37cf729d173f6214efec8a2087eb42d8"}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "static void vnc_connect(VncDisplay *vd, int csock, int skipauth, bool websocket)\n\n{\n\n    VncState *vs = g_malloc0(sizeof(VncState));\n\n    int i;\n\n\n\n    vs->csock = csock;\n\n\n\n    if (skipauth) {\n\n\tvs->auth = VNC_AUTH_NONE;\n\n#ifdef CONFIG_VNC_TLS\n\n\tvs->subauth = VNC_AUTH_INVALID;\n\n#endif\n\n    } else {\n\n\tvs->auth = vd->auth;\n\n#ifdef CONFIG_VNC_TLS\n\n\tvs->subauth = vd->subauth;\n\n#endif\n\n    }\n\n\n\n    vs->lossy_rect = g_malloc0(VNC_STAT_ROWS * sizeof (*vs->lossy_rect));\n\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n\n        vs->lossy_rect[i] = g_malloc0(VNC_STAT_COLS * sizeof (uint8_t));\n\n    }\n\n\n\n    VNC_DEBUG(\"New client on socket %d\\n\", csock);\n\n    dcl->idle = 0;\n\n    socket_set_nonblock(vs->csock);\n\n#ifdef CONFIG_VNC_WS\n\n    if (websocket) {\n\n        vs->websocket = 1;\n\n        qemu_set_fd_handler2(vs->csock, NULL, vncws_handshake_read, NULL, vs);\n\n    } else\n\n#endif /* CONFIG_VNC_WS */\n\n    {\n\n        qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, NULL, vs);\n\n    }\n\n\n\n    vnc_client_cache_addr(vs);\n\n    vnc_qmp_event(vs, QEVENT_VNC_CONNECTED);\n\n    vnc_set_share_mode(vs, VNC_SHARE_MODE_CONNECTING);\n\n\n\n    vs->vd = vd;\n\n\n\n#ifdef CONFIG_VNC_WS\n\n    if (!vs->websocket)\n\n#endif\n\n    {\n\n        vnc_init_state(vs);\n\n    }\n\n}\n", "idx": 7056, "_split": "valid", "_hash": "f1a9e758a37f46d07ba9c6e94b863a9d"}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "func": "static void v9fs_open(void *opaque)\n\n{\n\n    int flags;\n\n    int iounit;\n\n    int32_t fid;\n\n    int32_t mode;\n\n    V9fsQID qid;\n\n    ssize_t err = 0;\n\n    size_t offset = 7;\n\n    struct stat stbuf;\n\n    V9fsFidState *fidp;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    if (s->proto_version == V9FS_PROTO_2000L) {\n\n        pdu_unmarshal(pdu, offset, \"dd\", &fid, &mode);\n\n    } else {\n\n        pdu_unmarshal(pdu, offset, \"db\", &fid, &mode);\n\n    }\n\n    trace_v9fs_open(pdu->tag, pdu->id, fid, mode);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n    BUG_ON(fidp->fid_type != P9_FID_NONE);\n\n\n\n    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    stat_to_qid(&stbuf, &qid);\n\n    if (S_ISDIR(stbuf.st_mode)) {\n\n        err = v9fs_co_opendir(pdu, fidp);\n\n        if (err < 0) {\n\n            goto out;\n\n        }\n\n        fidp->fid_type = P9_FID_DIR;\n\n        offset += pdu_marshal(pdu, offset, \"Qd\", &qid, 0);\n\n        err = offset;\n\n    } else {\n\n        if (s->proto_version == V9FS_PROTO_2000L) {\n\n            flags = get_dotl_openflags(s, mode);\n\n        } else {\n\n            flags = omode_to_uflags(mode);\n\n        }\n\n        err = v9fs_co_open(pdu, fidp, flags);\n\n        if (err < 0) {\n\n            goto out;\n\n        }\n\n        fidp->fid_type = P9_FID_FILE;\n\n        fidp->open_flags = flags;\n\n        if (flags & O_EXCL) {\n\n            /*\n\n             * We let the host file system do O_EXCL check\n\n             * We should not reclaim such fd\n\n             */\n\n            fidp->flags |= FID_NON_RECLAIMABLE;\n\n        }\n\n        iounit = get_iounit(pdu, &fidp->path);\n\n        offset += pdu_marshal(pdu, offset, \"Qd\", &qid, iounit);\n\n        err = offset;\n\n    }\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n\n\n    complete_pdu(s, pdu, err);\n\n}", "idx": 7059, "_split": "valid", "_hash": "23beb775de49cd2428ce747387a548b8"}
{"project": "qemu", "commit_id": "0ff0fad23d3693ecf7a0c462cdb48f0e60f93808", "target": 0, "func": "static void tcp_chr_disconnect(CharDriverState *chr)\n\n{\n\n    TCPCharDriver *s = chr->opaque;\n\n\n\n    s->connected = 0;\n\n    if (s->listen_chan) {\n\n        s->listen_tag = g_io_add_watch(s->listen_chan, G_IO_IN,\n\n                                       tcp_chr_accept, chr);\n\n    }\n\n    remove_fd_in_watch(chr);\n\n    g_io_channel_unref(s->chan);\n\n    s->chan = NULL;\n\n    closesocket(s->fd);\n\n    s->fd = -1;\n\n    SocketAddress_to_str(chr->filename, CHR_MAX_FILENAME_SIZE,\n\n                         \"disconnected:\", s->addr, s->is_listen, s->is_telnet);\n\n    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);\n\n    if (s->reconnect_time) {\n\n        qemu_chr_socket_restart_timer(chr);\n\n    }\n\n}\n", "idx": 7070, "_split": "valid", "_hash": "25d6fe016155e4754fcbf67c8e6355b2"}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float64 HELPER(ucf64_si2df)(float32 x, CPUUniCore32State *env)\n\n{\n\n    return int32_to_float64(ucf64_stoi(x), &env->ucf64.fp_status);\n\n}\n", "idx": 7073, "_split": "valid", "_hash": "9372809440e7f3a3446eef06fd8931a1"}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static QObject *parse_literal(JSONParserContext *ctxt)\n\n{\n\n    QObject *token;\n\n\n\n    token = parser_context_pop_token(ctxt);\n\n    assert(token);\n\n\n\n    switch (token_get_type(token)) {\n\n    case JSON_STRING:\n\n        return QOBJECT(qstring_from_escaped_str(ctxt, token));\n\n    case JSON_INTEGER: {\n\n        /* A possibility exists that this is a whole-valued float where the\n\n         * fractional part was left out due to being 0 (.0). It's not a big\n\n         * deal to treat these as ints in the parser, so long as users of the\n\n         * resulting QObject know to expect a QInt in place of a QFloat in\n\n         * cases like these.\n\n         *\n\n         * However, in some cases these values will overflow/underflow a\n\n         * QInt/int64 container, thus we should assume these are to be handled\n\n         * as QFloats/doubles rather than silently changing their values.\n\n         *\n\n         * strtoll() indicates these instances by setting errno to ERANGE\n\n         */\n\n        int64_t value;\n\n\n\n        errno = 0; /* strtoll doesn't set errno on success */\n\n        value = strtoll(token_get_value(token), NULL, 10);\n\n        if (errno != ERANGE) {\n\n            return QOBJECT(qint_from_int(value));\n\n        }\n\n        /* fall through to JSON_FLOAT */\n\n    }\n\n    case JSON_FLOAT:\n\n        /* FIXME dependent on locale */\n\n        return QOBJECT(qfloat_from_double(strtod(token_get_value(token),\n\n                                                 NULL)));\n\n    default:\n\n        abort();\n\n    }\n\n}\n", "idx": 7076, "_split": "valid", "_hash": "4949aa834b6cc7531a6cf6c143b6cdf8"}
{"project": "qemu", "commit_id": "ff589551c8e8e9e95e211b9d8daafb4ed39f1aec", "target": 0, "func": "uint64_t esp_reg_read(ESPState *s, uint32_t saddr)\n\n{\n\n    uint32_t old_val;\n\n\n\n    trace_esp_mem_readb(saddr, s->rregs[saddr]);\n\n    switch (saddr) {\n\n    case ESP_FIFO:\n\n        if (s->ti_size > 0) {\n\n            s->ti_size--;\n\n            if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n\n                /* Data out.  */\n\n                qemu_log_mask(LOG_UNIMP,\n\n                              \"esp: PIO data read not implemented\\n\");\n\n                s->rregs[ESP_FIFO] = 0;\n\n            } else {\n\n                s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];\n\n            }\n\n            esp_raise_irq(s);\n\n        }\n\n        if (s->ti_size == 0) {\n\n            s->ti_rptr = 0;\n\n            s->ti_wptr = 0;\n\n        }\n\n        break;\n\n    case ESP_RINTR:\n\n        /* Clear sequence step, interrupt register and all status bits\n\n           except TC */\n\n        old_val = s->rregs[ESP_RINTR];\n\n        s->rregs[ESP_RINTR] = 0;\n\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n\n        esp_lower_irq(s);\n\n\n\n        return old_val;\n\n    case ESP_TCHI:\n\n        /* Return the unique id if the value has never been written */\n\n        if (!s->tchi_written) {\n\n            return s->chip_id;\n\n        }\n\n    default:\n\n        break;\n\n    }\n\n    return s->rregs[saddr];\n\n}\n", "idx": 7078, "_split": "valid", "_hash": "6b0160d13cb0b2d741f2957c3b733d90"}
{"project": "qemu", "commit_id": "c4d9d19645a484298a67e9021060bc7c2b081d0f", "target": 0, "func": "static void co_test_cb(void *opaque)\n\n{\n\n    WorkerTestData *data = opaque;\n\n\n\n    active = 1;\n\n    data->n = 0;\n\n    data->ret = -EINPROGRESS;\n\n    thread_pool_submit_co(worker_cb, data);\n\n\n\n    /* The test continues in test_submit_co, after qemu_coroutine_enter... */\n\n\n\n    g_assert_cmpint(data->n, ==, 1);\n\n    data->ret = 0;\n\n    active--;\n\n\n\n    /* The test continues in test_submit_co, after qemu_aio_wait_all... */\n\n}\n", "idx": 7083, "_split": "valid", "_hash": "9f58ca576d8c477f01e9d1439a858245"}
{"project": "qemu", "commit_id": "aacf4563878cac2afbbdc9818d810d2a3b075c6a", "target": 0, "func": "print_insn_microblaze (bfd_vma memaddr, struct disassemble_info * info)\n\n{\n\n  fprintf_ftype       fprintf = info->fprintf_func;\n\n  void *              stream = info->stream;\n\n  unsigned long       inst, prev_inst;\n\n  struct op_code_struct * op, *pop;\n\n  int                 immval = 0;\n\n  bfd_boolean         immfound = FALSE;\n\n  static bfd_vma prev_insn_addr = -1; /*init the prev insn addr */\n\n  static int     prev_insn_vma = -1;  /*init the prev insn vma */\n\n  int            curr_insn_vma = info->buffer_vma;\n\n\n\n  info->bytes_per_chunk = 4;\n\n\n\n  inst = read_insn_microblaze (memaddr, info, &op);\n\n  if (inst == 0) {\n\n    return -1;\n\n  }\n\n  \n\n  if (prev_insn_vma == curr_insn_vma) {\n\n  if (memaddr-(info->bytes_per_chunk) == prev_insn_addr) {\n\n    prev_inst = read_insn_microblaze (prev_insn_addr, info, &pop);\n\n    if (prev_inst == 0)\n\n      return -1;\n\n    if (pop->instr == imm) {\n\n      immval = (get_int_field_imm(prev_inst) << 16) & 0xffff0000;\n\n      immfound = TRUE;\n\n    }\n\n    else {\n\n      immval = 0;\n\n      immfound = FALSE;\n\n    }\n\n  }\n\n  }\n\n  /* make curr insn as prev insn */\n\n  prev_insn_addr = memaddr;\n\n  prev_insn_vma = curr_insn_vma;\n\n\n\n  if (op->name == 0) {\n\n    fprintf (stream, \".short 0x%04lx\", inst);\n\n  }\n\n  else\n\n    {\n\n      fprintf (stream, \"%s\", op->name);\n\n      \n\n      switch (op->inst_type)\n\n\t{\n\n  case INST_TYPE_RD_R1_R2:\n\n     fprintf(stream, \"\\t%s, %s, %s\", get_field_rd(inst), get_field_r1(inst), get_field_r2(inst));\n\n     break;\n\n        case INST_TYPE_RD_R1_IMM:\n\n\t  fprintf(stream, \"\\t%s, %s, %s\", get_field_rd(inst), get_field_r1(inst), get_field_imm(inst));\n\n\t  if (info->print_address_func && get_int_field_r1(inst) == 0 && info->symbol_at_address_func) {\n\n\t    if (immfound)\n\n\t      immval |= (get_int_field_imm(inst) & 0x0000ffff);\n\n\t    else {\n\n\t      immval = get_int_field_imm(inst);\n\n\t      if (immval & 0x8000)\n\n\t\timmval |= 0xFFFF0000;\n\n\t    }\n\n\t    if (immval > 0 && info->symbol_at_address_func(immval, info)) {\n\n\t      fprintf (stream, \"\\t// \");\n\n\t      info->print_address_func (immval, info);\n\n\t    }\n\n\t  }\n\n\t  break;\n\n\tcase INST_TYPE_RD_R1_IMM5:\n\n\t  fprintf(stream, \"\\t%s, %s, %s\", get_field_rd(inst), get_field_r1(inst), get_field_imm5(inst));\n\n\t  break;\n\n\tcase INST_TYPE_RD_RFSL:\n\n\t  fprintf(stream, \"\\t%s, %s\", get_field_rd(inst), get_field_rfsl(inst));\n\n\t  break;\n\n\tcase INST_TYPE_R1_RFSL:\n\n\t  fprintf(stream, \"\\t%s, %s\", get_field_r1(inst), get_field_rfsl(inst));\n\n\t  break;\n\n\tcase INST_TYPE_RD_SPECIAL:\n\n\t  fprintf(stream, \"\\t%s, %s\", get_field_rd(inst), get_field_special(inst, op));\n\n\t  break;\n\n\tcase INST_TYPE_SPECIAL_R1:\n\n\t  fprintf(stream, \"\\t%s, %s\", get_field_special(inst, op), get_field_r1(inst));\n\n\t  break;\n\n\tcase INST_TYPE_RD_R1:\n\n\t  fprintf(stream, \"\\t%s, %s\", get_field_rd(inst), get_field_r1(inst));\n\n\t  break;\n\n\tcase INST_TYPE_R1_R2:\n\n\t  fprintf(stream, \"\\t%s, %s\", get_field_r1(inst), get_field_r2(inst));\n\n\t  break;\n\n\tcase INST_TYPE_R1_IMM:\n\n\t  fprintf(stream, \"\\t%s, %s\", get_field_r1(inst), get_field_imm(inst));\n\n\t  /* The non-pc relative instructions are returns, which shouldn't \n\n\t     have a label printed */\n\n\t  if (info->print_address_func && op->inst_offset_type == INST_PC_OFFSET && info->symbol_at_address_func) {\n\n\t    if (immfound)\n\n\t      immval |= (get_int_field_imm(inst) & 0x0000ffff);\n\n\t    else {\n\n\t      immval = get_int_field_imm(inst);\n\n\t      if (immval & 0x8000)\n\n\t\timmval |= 0xFFFF0000;\n\n\t    }\n\n\t    immval += memaddr;\n\n\t    if (immval > 0 && info->symbol_at_address_func(immval, info)) {\n\n\t      fprintf (stream, \"\\t// \");\n\n\t      info->print_address_func (immval, info);\n\n\t    } else {\n\n\t      fprintf (stream, \"\\t\\t// \");\n\n\t      fprintf (stream, \"%x\", immval);\n\n\t    }\n\n\t  }\n\n\t  break;\n\n        case INST_TYPE_RD_IMM:\n\n\t  fprintf(stream, \"\\t%s, %s\", get_field_rd(inst), get_field_imm(inst));\n\n\t  if (info->print_address_func && info->symbol_at_address_func) {\n\n\t    if (immfound)\n\n\t      immval |= (get_int_field_imm(inst) & 0x0000ffff);\n\n\t    else {\n\n\t      immval = get_int_field_imm(inst);\n\n\t      if (immval & 0x8000)\n\n\t\timmval |= 0xFFFF0000;\n\n\t    }\n\n\t    if (op->inst_offset_type == INST_PC_OFFSET)\n\n\t      immval += (int) memaddr;\n\n\t    if (info->symbol_at_address_func(immval, info)) {\n\n\t      fprintf (stream, \"\\t// \");\n\n\t      info->print_address_func (immval, info);\n\n\t    } \n\n\t  }\n\n\t  break;\n\n        case INST_TYPE_IMM:\n\n\t  fprintf(stream, \"\\t%s\", get_field_imm(inst));\n\n\t  if (info->print_address_func && info->symbol_at_address_func && op->instr != imm) {\n\n\t    if (immfound)\n\n\t      immval |= (get_int_field_imm(inst) & 0x0000ffff);\n\n\t    else {\n\n\t      immval = get_int_field_imm(inst);\n\n\t      if (immval & 0x8000)\n\n\t\timmval |= 0xFFFF0000;\n\n\t    }\n\n\t    if (op->inst_offset_type == INST_PC_OFFSET)\n\n\t      immval += (int) memaddr;\n\n\t    if (immval > 0 && info->symbol_at_address_func(immval, info)) {\n\n\t      fprintf (stream, \"\\t// \");\n\n\t      info->print_address_func (immval, info);\n\n\t    } else if (op->inst_offset_type == INST_PC_OFFSET) {\n\n\t      fprintf (stream, \"\\t\\t// \");\n\n\t      fprintf (stream, \"%x\", immval);\n\n\t    }\n\n\t  }\n\n\t  break;\n\n        case INST_TYPE_RD_R2:\n\n\t  fprintf(stream, \"\\t%s, %s\", get_field_rd(inst), get_field_r2(inst));\n\n\t  break;\n\n  case INST_TYPE_R2:\n\n     fprintf(stream, \"\\t%s\", get_field_r2(inst));\n\n     break;\n\n  case INST_TYPE_R1:\n\n     fprintf(stream, \"\\t%s\", get_field_r1(inst));\n\n     break;\n\n  case INST_TYPE_RD_R1_SPECIAL:\n\n     fprintf(stream, \"\\t%s, %s\", get_field_rd(inst), get_field_r2(inst));\n\n     break;\n\n  case INST_TYPE_RD_IMM15:\n\n     fprintf(stream, \"\\t%s, %s\", get_field_rd(inst), get_field_imm15(inst));\n\n     break;\n\n     /* For tuqula instruction */\n\n  case INST_TYPE_RD:\n\n     fprintf(stream, \"\\t%s\", get_field_rd(inst));\n\n     break;\n\n  case INST_TYPE_RFSL:\n\n     fprintf(stream, \"\\t%s\", get_field_rfsl(inst));\n\n     break;\n\n  default:\n\n\t  /* if the disassembler lags the instruction set */\n\n\t  fprintf (stream, \"\\tundecoded operands, inst is 0x%04lx\", inst);\n\n\t  break;\n\n\t}\n\n    }\n\n  \n\n  /* Say how many bytes we consumed? */\n\n  return 4;\n\n}\n", "idx": 7089, "_split": "valid", "_hash": "feda0e8ffb062c295667c154129e6c6c"}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "int nbd_client_session_co_flush(NbdClientSession *client)\n\n{\n\n    struct nbd_request request = { .type = NBD_CMD_FLUSH };\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n\n\n    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {\n\n        return 0;\n\n    }\n\n\n\n    if (client->nbdflags & NBD_FLAG_SEND_FUA) {\n\n        request.type |= NBD_CMD_FLAG_FUA;\n\n    }\n\n\n\n    request.from = 0;\n\n    request.len = 0;\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(client, &request, NULL, 0);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, NULL, 0);\n\n    }\n\n    nbd_coroutine_end(client, &request);\n\n    return -reply.error;\n\n}\n", "idx": 7090, "_split": "valid", "_hash": "7effe1dab783305e87b28997c2dee1d5"}
{"project": "qemu", "commit_id": "97a83ec3a9d83f2e86b8b93178d8e8b64ccc7486", "target": 0, "func": "static void i440fx_pcihost_initfn(Object *obj)\n\n{\n\n    PCIHostState *s = PCI_HOST_BRIDGE(obj);\n\n    I440FXState *d = I440FX_PCI_HOST_BRIDGE(obj);\n\n\n\n    memory_region_init_io(&s->conf_mem, obj, &pci_host_conf_le_ops, s,\n\n                          \"pci-conf-idx\", 4);\n\n    memory_region_init_io(&s->data_mem, obj, &pci_host_data_le_ops, s,\n\n                          \"pci-conf-data\", 4);\n\n\n\n    object_property_add(obj, PCI_HOST_PROP_PCI_HOLE_START, \"int\",\n\n                        i440fx_pcihost_get_pci_hole_start,\n\n                        NULL, NULL, NULL, NULL);\n\n\n\n    object_property_add(obj, PCI_HOST_PROP_PCI_HOLE_END, \"int\",\n\n                        i440fx_pcihost_get_pci_hole_end,\n\n                        NULL, NULL, NULL, NULL);\n\n\n\n    object_property_add(obj, PCI_HOST_PROP_PCI_HOLE64_START, \"int\",\n\n                        i440fx_pcihost_get_pci_hole64_start,\n\n                        NULL, NULL, NULL, NULL);\n\n\n\n    object_property_add(obj, PCI_HOST_PROP_PCI_HOLE64_END, \"int\",\n\n                        i440fx_pcihost_get_pci_hole64_end,\n\n                        NULL, NULL, NULL, NULL);\n\n\n\n    d->pci_info.w32.end = IO_APIC_DEFAULT_ADDRESS;\n\n}\n", "idx": 7115, "_split": "valid", "_hash": "aab0bab79b72186ee02fb4bc261cdbff"}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "void qemu_mutex_unlock_iothread(void) {}\n", "idx": 7152, "_split": "valid", "_hash": "1444acdf6bdf77b23f7237d7b2c45dcd"}
{"project": "qemu", "commit_id": "e305a16510afa74eec20390479e349402e55ef4c", "target": 1, "func": "static void parallel_isa_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    static int index;\n\n    ISADevice *isadev = ISA_DEVICE(dev);\n\n    ISAParallelState *isa = ISA_PARALLEL(dev);\n\n    ParallelState *s = &isa->state;\n\n    int base;\n\n    uint8_t dummy;\n\n\n\n    if (!s->chr) {\n\n        error_setg(errp, \"Can't create parallel device, empty char device\");\n\n        return;\n\n    }\n\n\n\n    if (isa->index == -1) {\n\n        isa->index = index;\n\n    }\n\n    if (isa->index >= MAX_PARALLEL_PORTS) {\n\n        error_setg(errp, \"Max. supported number of parallel ports is %d.\",\n\n                   MAX_PARALLEL_PORTS);\n\n        return;\n\n    }\n\n    if (isa->iobase == -1) {\n\n        isa->iobase = isa_parallel_io[isa->index];\n\n    }\n\n    index++;\n\n\n\n    base = isa->iobase;\n\n    isa_init_irq(isadev, &s->irq, isa->isairq);\n\n    qemu_register_reset(parallel_reset, s);\n\n\n\n    if (qemu_chr_fe_ioctl(s->chr, CHR_IOCTL_PP_READ_STATUS, &dummy) == 0) {\n\n        s->hw_driver = 1;\n\n        s->status = dummy;\n\n    }\n\n\n\n    isa_register_portio_list(isadev, base,\n\n                             (s->hw_driver\n\n                              ? &isa_parallel_portio_hw_list[0]\n\n                              : &isa_parallel_portio_sw_list[0]),\n\n                             s, \"parallel\");\n\n}\n", "idx": 7157, "_split": "valid", "_hash": "afeac12594be6779e654c7f71b5a914e"}
{"project": "qemu", "commit_id": "f5aa4bdc766190b95d18be27d5cdf4d80c35b33c", "target": 1, "func": "static void test_bmdma_long_prdt(void)\n\n{\n\n    QPCIDevice *dev;\n\n    QPCIBar bmdma_bar, ide_bar;\n\n    uint8_t status;\n\n\n\n    PrdtEntry prdt[] = {\n\n        {\n\n            .addr = 0,\n\n            .size = cpu_to_le32(0x1000 | PRDT_EOT),\n\n        },\n\n    };\n\n\n\n    dev = get_pci_device(&bmdma_bar, &ide_bar);\n\n\n\n    /* Normal request */\n\n    status = send_dma_request(CMD_READ_DMA, 0, 1,\n\n                              prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_ACTIVE | BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_bar, reg_status), DF | ERR);\n\n\n\n    /* Abort the request before it completes */\n\n    status = send_dma_request(CMD_READ_DMA | CMDF_ABORT, 0, 1,\n\n                              prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_bar, reg_status), DF | ERR);\n\n\n}", "idx": 7164, "_split": "valid", "_hash": "f24a6bad0cf89b23b05f9728d74119ca"}
{"project": "qemu", "commit_id": "8786db7cb96f8ce5c75c6e1e074319c9dca8d356", "target": 1, "func": "static void memory_region_update_coalesced_range(MemoryRegion *mr)\n\n{\n\n    FlatRange *fr;\n\n    CoalescedMemoryRange *cmr;\n\n    AddrRange tmp;\n\n\n\n    FOR_EACH_FLAT_RANGE(fr, &address_space_memory.current_map) {\n\n        if (fr->mr == mr) {\n\n            qemu_unregister_coalesced_mmio(int128_get64(fr->addr.start),\n\n                                           int128_get64(fr->addr.size));\n\n            QTAILQ_FOREACH(cmr, &mr->coalesced, link) {\n\n                tmp = addrrange_shift(cmr->addr,\n\n                                      int128_sub(fr->addr.start,\n\n                                                 int128_make64(fr->offset_in_region)));\n\n                if (!addrrange_intersects(tmp, fr->addr)) {\n\n                    continue;\n\n                }\n\n                tmp = addrrange_intersection(tmp, fr->addr);\n\n                qemu_register_coalesced_mmio(int128_get64(tmp.start),\n\n                                             int128_get64(tmp.size));\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 7169, "_split": "valid", "_hash": "bfdd204b01740835ed64c74790246e55"}
{"project": "qemu", "commit_id": "13d1fd44c46629aad672f192abbf02238c6cbf36", "target": 1, "func": "static int qxl_init_secondary(PCIDevice *dev)\n\n{\n\n    static int device_id = 1;\n\n    PCIQXLDevice *qxl = DO_UPCAST(PCIQXLDevice, pci, dev);\n\n\n\n    qxl->id = device_id++;\n\n    qxl_init_ramsize(qxl, 16);\n\n    memory_region_init_ram(&qxl->vga.vram, \"qxl.vgavram\", qxl->vga.vram_size);\n\n    vmstate_register_ram(&qxl->vga.vram, &qxl->pci.qdev);\n\n    qxl->vga.vram_ptr = memory_region_get_ram_ptr(&qxl->vga.vram);\n\n\n\n    return qxl_init_common(qxl);\n\n}\n", "idx": 7171, "_split": "valid", "_hash": "f3df8ce6f5e99ed413b2baece10becae"}
{"project": "qemu", "commit_id": "5c53bb812152c3d7919cadfd47c210b181bf89ac", "target": 1, "func": "static void tcg_out_qemu_st_slow_path(TCGContext *s, TCGLabelQemuLdst *l)\n\n{\n\n    TCGMemOp opc = l->opc;\n\n    TCGMemOp s_bits = opc & MO_SIZE;\n\n    uint8_t **label_ptr = &l->label_ptr[0];\n\n    TCGReg retaddr;\n\n\n\n    /* resolve label address */\n\n    *(uint32_t *)label_ptr[0] = (uint32_t)(s->code_ptr - label_ptr[0] - 4);\n\n    if (TARGET_LONG_BITS > TCG_TARGET_REG_BITS) {\n\n        *(uint32_t *)label_ptr[1] = (uint32_t)(s->code_ptr - label_ptr[1] - 4);\n\n    }\n\n\n\n    if (TCG_TARGET_REG_BITS == 32) {\n\n        int ofs = 0;\n\n\n\n        tcg_out_st(s, TCG_TYPE_PTR, TCG_AREG0, TCG_REG_ESP, ofs);\n\n        ofs += 4;\n\n\n\n        tcg_out_st(s, TCG_TYPE_I32, l->addrlo_reg, TCG_REG_ESP, ofs);\n\n        ofs += 4;\n\n\n\n        if (TARGET_LONG_BITS == 64) {\n\n            tcg_out_st(s, TCG_TYPE_I32, l->addrhi_reg, TCG_REG_ESP, ofs);\n\n            ofs += 4;\n\n        }\n\n\n\n        tcg_out_st(s, TCG_TYPE_I32, l->datalo_reg, TCG_REG_ESP, ofs);\n\n        ofs += 4;\n\n\n\n        if (s_bits == MO_64) {\n\n            tcg_out_st(s, TCG_TYPE_I32, l->datahi_reg, TCG_REG_ESP, ofs);\n\n            ofs += 4;\n\n        }\n\n\n\n        tcg_out_sti(s, TCG_TYPE_I32, TCG_REG_ESP, ofs, l->mem_index);\n\n        ofs += 4;\n\n\n\n        retaddr = TCG_REG_EAX;\n\n        tcg_out_movi(s, TCG_TYPE_I32, retaddr, (uintptr_t)l->raddr);\n\n        tcg_out_st(s, TCG_TYPE_I32, retaddr, TCG_REG_ESP, ofs);\n\n    } else {\n\n        tcg_out_mov(s, TCG_TYPE_PTR, tcg_target_call_iarg_regs[0], TCG_AREG0);\n\n        /* The second argument is already loaded with addrlo.  */\n\n        tcg_out_mov(s, (s_bits == MO_64 ? TCG_TYPE_I64 : TCG_TYPE_I32),\n\n                    tcg_target_call_iarg_regs[2], l->datalo_reg);\n\n        tcg_out_movi(s, TCG_TYPE_I32, tcg_target_call_iarg_regs[3],\n\n                     l->mem_index);\n\n\n\n        if (ARRAY_SIZE(tcg_target_call_iarg_regs) > 4) {\n\n            retaddr = tcg_target_call_iarg_regs[4];\n\n            tcg_out_movi(s, TCG_TYPE_PTR, retaddr, (uintptr_t)l->raddr);\n\n        } else {\n\n            retaddr = TCG_REG_RAX;\n\n            tcg_out_movi(s, TCG_TYPE_PTR, retaddr, (uintptr_t)l->raddr);\n\n            tcg_out_st(s, TCG_TYPE_PTR, retaddr, TCG_REG_ESP, 0);\n\n        }\n\n    }\n\n\n\n    /* \"Tail call\" to the helper, with the return address back inline.  */\n\n    tcg_out_push(s, retaddr);\n\n    tcg_out_jmp(s, (uintptr_t)qemu_st_helpers[opc]);\n\n}\n", "idx": 7180, "_split": "valid", "_hash": "45f1525811cda5fe9064417fe2a73e00"}
{"project": "qemu", "commit_id": "84961407a50bb02d34ab9cca7a21cdb4ff7c25fe", "target": 1, "func": "static void gd_set_keycode_type(GtkDisplayState *s)\n{\n#ifdef GDK_WINDOWING_X11\n    GdkDisplay *display = gtk_widget_get_display(s->window);\n    if (GDK_IS_X11_DISPLAY(display)) {\n        Display *x11_display = gdk_x11_display_get_xdisplay(display);\n        XkbDescPtr desc = XkbGetKeyboard(x11_display, XkbGBN_AllComponentsMask,\n                                         XkbUseCoreKbd);\n        char *keycodes = NULL;\n        if (desc && desc->names) {\n            keycodes = XGetAtomName(x11_display, desc->names->keycodes);\n        if (keycodes == NULL) {\n            fprintf(stderr, \"could not lookup keycode name\\n\");\n        } else if (strstart(keycodes, \"evdev\", NULL)) {\n            s->has_evdev = true;\n        } else if (!strstart(keycodes, \"xfree86\", NULL)) {\n            fprintf(stderr, \"unknown keycodes `%s', please report to \"\n                    \"qemu-devel@nongnu.org\\n\", keycodes);\n#endif", "idx": 7206, "_split": "valid", "_hash": "928cb9746c58c2b1ba5e7dc220808631"}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "static void kvm_client_set_memory(struct CPUPhysMemoryClient *client,\n\n\t\t\t\t  target_phys_addr_t start_addr,\n\n\t\t\t\t  ram_addr_t size,\n\n\t\t\t\t  ram_addr_t phys_offset)\n\n{\n\n\tkvm_set_phys_mem(start_addr, size, phys_offset);\n\n}\n", "idx": 7211, "_split": "valid", "_hash": "9346603357450395d61541f16d0f3603"}
{"project": "qemu", "commit_id": "3482b9bc411a9a12b2efde1018e1ddc906cd817e", "target": 0, "func": "int coroutine_fn bdrv_co_pdiscard(BlockDriverState *bs, int64_t offset,\n\n                                  int count)\n\n{\n\n    BdrvTrackedRequest req;\n\n    int max_pdiscard, ret;\n\n    int head, align;\n\n\n\n    if (!bs->drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n\n\n    ret = bdrv_check_byte_request(bs, offset, count);\n\n    if (ret < 0) {\n\n        return ret;\n\n    } else if (bs->read_only) {\n\n        return -EPERM;\n\n    }\n\n    assert(!(bs->open_flags & BDRV_O_INACTIVE));\n\n\n\n    /* Do nothing if disabled.  */\n\n    if (!(bs->open_flags & BDRV_O_UNMAP)) {\n\n        return 0;\n\n    }\n\n\n\n    if (!bs->drv->bdrv_co_pdiscard && !bs->drv->bdrv_aio_pdiscard) {\n\n        return 0;\n\n    }\n\n\n\n    /* Discard is advisory, so ignore any unaligned head or tail */\n\n    align = MAX(bs->bl.pdiscard_alignment, bs->bl.request_alignment);\n\n    assert(align % bs->bl.request_alignment == 0);\n\n    head = offset % align;\n\n    if (head) {\n\n        head = MIN(count, align - head);\n\n        count -= head;\n\n        offset += head;\n\n    }\n\n    count = QEMU_ALIGN_DOWN(count, align);\n\n    if (!count) {\n\n        return 0;\n\n    }\n\n\n\n    bdrv_inc_in_flight(bs);\n\n    tracked_request_begin(&req, bs, offset, count, BDRV_TRACKED_DISCARD);\n\n\n\n    ret = notifier_with_return_list_notify(&bs->before_write_notifiers, &req);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    max_pdiscard = QEMU_ALIGN_DOWN(MIN_NON_ZERO(bs->bl.max_pdiscard, INT_MAX),\n\n                                   align);\n\n    assert(max_pdiscard);\n\n\n\n    while (count > 0) {\n\n        int ret;\n\n        int num = MIN(count, max_pdiscard);\n\n\n\n        if (bs->drv->bdrv_co_pdiscard) {\n\n            ret = bs->drv->bdrv_co_pdiscard(bs, offset, num);\n\n        } else {\n\n            BlockAIOCB *acb;\n\n            CoroutineIOCompletion co = {\n\n                .coroutine = qemu_coroutine_self(),\n\n            };\n\n\n\n            acb = bs->drv->bdrv_aio_pdiscard(bs, offset, num,\n\n                                             bdrv_co_io_em_complete, &co);\n\n            if (acb == NULL) {\n\n                ret = -EIO;\n\n                goto out;\n\n            } else {\n\n                qemu_coroutine_yield();\n\n                ret = co.ret;\n\n            }\n\n        }\n\n        if (ret && ret != -ENOTSUP) {\n\n            goto out;\n\n        }\n\n\n\n        offset += num;\n\n        count -= num;\n\n    }\n\n    ret = 0;\n\nout:\n\n    ++bs->write_gen;\n\n    bdrv_set_dirty(bs, req.offset >> BDRV_SECTOR_BITS,\n\n                   req.bytes >> BDRV_SECTOR_BITS);\n\n    tracked_request_end(&req);\n\n    bdrv_dec_in_flight(bs);\n\n    return ret;\n\n}\n", "idx": 7218, "_split": "valid", "_hash": "3de55c67ec72c75aad67787b33ec75d0"}
{"project": "qemu", "commit_id": "90e496386fe7fd32c189561f846b7913f95b8cf4", "target": 0, "func": "static inline int fp_reg_offset(int regno, TCGMemOp size)\n\n{\n\n    int offs = offsetof(CPUARMState, vfp.regs[regno * 2]);\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n    offs += (8 - (1 << size));\n\n#endif\n\n    return offs;\n\n}\n", "idx": 7231, "_split": "valid", "_hash": "d55ac08e516cf3014baf7038516e42f5"}
{"project": "qemu", "commit_id": "6e13610aa454beba52944e8df6d93158d68ab911", "target": 1, "func": "static int qcow2_save_vmstate(BlockDriverState *bs, QEMUIOVector *qiov,\n\n                              int64_t pos)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t total_sectors = bs->total_sectors;\n\n    int growable = bs->growable;\n\n\n    int ret;\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_VMSTATE_SAVE);\n\n    bs->growable = 1;\n\n\n    ret = bdrv_pwritev(bs, qcow2_vm_state_offset(s) + pos, qiov);\n\n    bs->growable = growable;\n\n\n\n\n    /* bdrv_co_do_writev will have increased the total_sectors value to include\n\n     * the VM state - the VM state is however not an actual part of the block\n\n     * device, therefore, we need to restore the old value. */\n\n    bs->total_sectors = total_sectors;\n\n\n\n    return ret;\n\n}", "idx": 7263, "_split": "valid", "_hash": "15dcebef3f05f302759c496512ebbad4"}
{"project": "qemu", "commit_id": "99f2cf4b2dad7b37c69759deb0d0b19d3ec1a24a", "target": 1, "func": "static void local_mapped_file_attr(int dirfd, const char *name,\n\n                                   struct stat *stbuf)\n\n{\n\n    FILE *fp;\n\n    char buf[ATTR_MAX];\n\n    int map_dirfd;\n\n\n\n    map_dirfd = openat(dirfd, VIRTFS_META_DIR,\n\n                       O_RDONLY | O_DIRECTORY | O_NOFOLLOW);\n\n    if (map_dirfd == -1) {\n\n        return;\n\n    }\n\n\n\n    fp = local_fopenat(map_dirfd, name, \"r\");\n\n    close_preserve_errno(map_dirfd);\n\n    if (!fp) {\n\n        return;\n\n    }\n\n    memset(buf, 0, ATTR_MAX);\n\n    while (fgets(buf, ATTR_MAX, fp)) {\n\n        if (!strncmp(buf, \"virtfs.uid\", 10)) {\n\n            stbuf->st_uid = atoi(buf+11);\n\n        } else if (!strncmp(buf, \"virtfs.gid\", 10)) {\n\n            stbuf->st_gid = atoi(buf+11);\n\n        } else if (!strncmp(buf, \"virtfs.mode\", 11)) {\n\n            stbuf->st_mode = atoi(buf+12);\n\n        } else if (!strncmp(buf, \"virtfs.rdev\", 11)) {\n\n            stbuf->st_rdev = atoi(buf+12);\n\n        }\n\n        memset(buf, 0, ATTR_MAX);\n\n    }\n\n    fclose(fp);\n\n}\n", "idx": 7308, "_split": "valid", "_hash": "8211381395615e242dd9256602a11326"}
{"project": "qemu", "commit_id": "b946a1533209f61a93e34898aebb5b43154b99c3", "target": 1, "func": "pci_e1000_init(PCIBus *bus, NICInfo *nd, int devfn)\n\n{\n\n    E1000State *d;\n\n    uint8_t *pci_conf;\n\n    uint16_t checksum = 0;\n\n    static const char info_str[] = \"e1000\";\n\n    int i;\n\n\n\n    d = (E1000State *)pci_register_device(bus, \"e1000\",\n\n                sizeof(E1000State), devfn, NULL, NULL);\n\n\n\n    pci_conf = d->dev.config;\n\n    memset(pci_conf, 0, 256);\n\n\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(pci_conf, E1000_DEVID);\n\n    *(uint16_t *)(pci_conf+0x04) = cpu_to_le16(0x0407);\n\n    *(uint16_t *)(pci_conf+0x06) = cpu_to_le16(0x0010);\n\n    pci_conf[0x08] = 0x03;\n\n    pci_config_set_class(pci_conf, PCI_CLASS_NETWORK_ETHERNET);\n\n    pci_conf[0x0c] = 0x10;\n\n\n\n    pci_conf[0x3d] = 1; // interrupt pin 0\n\n\n\n    d->mmio_index = cpu_register_io_memory(0, e1000_mmio_read,\n\n            e1000_mmio_write, d);\n\n\n\n    pci_register_io_region((PCIDevice *)d, 0, PNPMMIO_SIZE,\n\n                           PCI_ADDRESS_SPACE_MEM, e1000_mmio_map);\n\n\n\n    pci_register_io_region((PCIDevice *)d, 1, IOPORT_SIZE,\n\n                           PCI_ADDRESS_SPACE_IO, ioport_map);\n\n\n\n    memmove(d->eeprom_data, e1000_eeprom_template,\n\n        sizeof e1000_eeprom_template);\n\n    for (i = 0; i < 3; i++)\n\n        d->eeprom_data[i] = (nd->macaddr[2*i+1]<<8) | nd->macaddr[2*i];\n\n    for (i = 0; i < EEPROM_CHECKSUM_REG; i++)\n\n        checksum += d->eeprom_data[i];\n\n    checksum = (uint16_t) EEPROM_SUM - checksum;\n\n    d->eeprom_data[EEPROM_CHECKSUM_REG] = checksum;\n\n\n\n    memset(d->phy_reg, 0, sizeof d->phy_reg);\n\n    memmove(d->phy_reg, phy_reg_init, sizeof phy_reg_init);\n\n    memset(d->mac_reg, 0, sizeof d->mac_reg);\n\n    memmove(d->mac_reg, mac_reg_init, sizeof mac_reg_init);\n\n    d->rxbuf_min_shift = 1;\n\n    memset(&d->tx, 0, sizeof d->tx);\n\n\n\n    d->vc = qemu_new_vlan_client(nd->vlan, nd->model, nd->name,\n\n                                 e1000_receive, e1000_can_receive, d);\n\n    d->vc->link_status_changed = e1000_set_link_status;\n\n\n\n    qemu_format_nic_info_str(d->vc, nd->macaddr);\n\n\n\n    register_savevm(info_str, -1, 2, nic_save, nic_load, d);\n\n    d->dev.unregister = pci_e1000_uninit;\n\n\n\n    return (PCIDevice *)d;\n\n}\n", "idx": 7309, "_split": "valid", "_hash": "0be81caf78400ac7ea7650af373ea58d"}
{"project": "qemu", "commit_id": "568c73a4783cd981e9aa6de4f15dcda7829643ad", "target": 0, "func": "static void legacy_kbd_event(DeviceState *dev, QemuConsole *src,\n\n                             InputEvent *evt)\n\n{\n\n    QEMUPutKbdEntry *entry = (QEMUPutKbdEntry *)dev;\n\n    int scancodes[3], i, count;\n\n\n\n    if (!entry || !entry->put_kbd) {\n\n        return;\n\n    }\n\n    count = qemu_input_key_value_to_scancode(evt->key->key,\n\n                                             evt->key->down,\n\n                                             scancodes);\n\n    for (i = 0; i < count; i++) {\n\n        entry->put_kbd(entry->opaque, scancodes[i]);\n\n    }\n\n}\n", "idx": 7316, "_split": "valid", "_hash": "c3fa11784bdb2e3df4f85ba1202a9358"}
{"project": "qemu", "commit_id": "c169998802505c244b8bcad562633f29de7d74a4", "target": 0, "func": "PITState *pit_init(int base, qemu_irq irq)\n\n{\n\n    PITState *pit = &pit_state;\n\n    PITChannelState *s;\n\n\n\n    s = &pit->channels[0];\n\n    /* the timer 0 is connected to an IRQ */\n\n    s->irq_timer = qemu_new_timer(vm_clock, pit_irq_timer, s);\n\n    s->irq = irq;\n\n\n\n    vmstate_register(base, &vmstate_pit, pit);\n\n    qemu_register_reset(pit_reset, pit);\n\n    register_ioport_write(base, 4, 1, pit_ioport_write, pit);\n\n    register_ioport_read(base, 3, 1, pit_ioport_read, pit);\n\n\n\n    pit_reset(pit);\n\n\n\n    return pit;\n\n}\n", "idx": 7322, "_split": "valid", "_hash": "e17c30d598f37d4a5e5e080d7a605fae"}
{"project": "qemu", "commit_id": "96c05abc904c6f74b60981d956cee531920e4cdf", "target": 0, "func": "static int qxl_init_common(PCIQXLDevice *qxl)\n\n{\n\n    uint8_t* config = qxl->pci.config;\n\n    uint32_t pci_device_id;\n\n    uint32_t pci_device_rev;\n\n    uint32_t io_size;\n\n\n\n    qxl->mode = QXL_MODE_UNDEFINED;\n\n    qxl->generation = 1;\n\n    qxl->num_memslots = NUM_MEMSLOTS;\n\n    qxl->num_surfaces = NUM_SURFACES;\n\n\n\n    switch (qxl->revision) {\n\n    case 1: /* spice 0.4 -- qxl-1 */\n\n        pci_device_id  = QXL_DEVICE_ID_STABLE;\n\n        pci_device_rev = QXL_REVISION_STABLE_V04;\n\n        break;\n\n    case 2: /* spice 0.6 -- qxl-2 */\n\n        pci_device_id  = QXL_DEVICE_ID_STABLE;\n\n        pci_device_rev = QXL_REVISION_STABLE_V06;\n\n        break;\n\n    default: /* experimental */\n\n        pci_device_id  = QXL_DEVICE_ID_DEVEL;\n\n        pci_device_rev = 1;\n\n        break;\n\n    }\n\n\n\n    pci_config_set_vendor_id(config, REDHAT_PCI_VENDOR_ID);\n\n    pci_config_set_device_id(config, pci_device_id);\n\n    pci_set_byte(&config[PCI_REVISION_ID], pci_device_rev);\n\n    pci_set_byte(&config[PCI_INTERRUPT_PIN], 1);\n\n\n\n    qxl->rom_size = qxl_rom_size();\n\n    qxl->rom_offset = qemu_ram_alloc(&qxl->pci.qdev, \"qxl.vrom\", qxl->rom_size);\n\n    init_qxl_rom(qxl);\n\n    init_qxl_ram(qxl);\n\n\n\n    if (qxl->vram_size < 16 * 1024 * 1024) {\n\n        qxl->vram_size = 16 * 1024 * 1024;\n\n    }\n\n    if (qxl->revision == 1) {\n\n        qxl->vram_size = 4096;\n\n    }\n\n    qxl->vram_size = msb_mask(qxl->vram_size * 2 - 1);\n\n    qxl->vram_offset = qemu_ram_alloc(&qxl->pci.qdev, \"qxl.vram\", qxl->vram_size);\n\n\n\n    io_size = msb_mask(QXL_IO_RANGE_SIZE * 2 - 1);\n\n    if (qxl->revision == 1) {\n\n        io_size = 8;\n\n    }\n\n\n\n    pci_register_bar(&qxl->pci, QXL_IO_RANGE_INDEX,\n\n                     io_size, PCI_BASE_ADDRESS_SPACE_IO, qxl_map);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_ROM_RANGE_INDEX,\n\n                     qxl->rom_size, PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                     qxl_map);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_RAM_RANGE_INDEX,\n\n                     qxl->vga.vram_size, PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                     qxl_map);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_VRAM_RANGE_INDEX, qxl->vram_size,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, qxl_map);\n\n\n\n    qxl->ssd.qxl.base.sif = &qxl_interface.base;\n\n    qxl->ssd.qxl.id = qxl->id;\n\n    qemu_spice_add_interface(&qxl->ssd.qxl.base);\n\n    qemu_add_vm_change_state_handler(qxl_vm_change_state_handler, qxl);\n\n\n\n    init_pipe_signaling(qxl);\n\n    qxl_reset_state(qxl);\n\n\n\n    return 0;\n\n}\n", "idx": 7325, "_split": "valid", "_hash": "9f109da439207e24fd0f51a11b1e306d"}
{"project": "qemu", "commit_id": "1f00b27f17518a1bcb4cedca49eaec96a4d560bd", "target": 0, "func": "static TCGReg tcg_out_tlb_read(TCGContext* s, TCGReg addr_reg, TCGMemOp opc,\n\n                               int mem_index, bool is_ld)\n\n{\n\n    int s_mask = (1 << (opc & MO_SIZE)) - 1;\n\n    int ofs, a_off;\n\n    uint64_t tlb_mask;\n\n\n\n    /* For aligned accesses, we check the first byte and include the alignment\n\n       bits within the address.  For unaligned access, we check that we don't\n\n       cross pages using the address of the last byte of the access.  */\n\n    if ((opc & MO_AMASK) == MO_ALIGN || s_mask == 0) {\n\n        a_off = 0;\n\n        tlb_mask = TARGET_PAGE_MASK | s_mask;\n\n    } else {\n\n        a_off = s_mask;\n\n        tlb_mask = TARGET_PAGE_MASK;\n\n    }\n\n\n\n    if (facilities & FACILITY_GEN_INST_EXT) {\n\n        tcg_out_risbg(s, TCG_REG_R2, addr_reg,\n\n                      64 - CPU_TLB_BITS - CPU_TLB_ENTRY_BITS,\n\n                      63 - CPU_TLB_ENTRY_BITS,\n\n                      64 + CPU_TLB_ENTRY_BITS - TARGET_PAGE_BITS, 1);\n\n        if (a_off) {\n\n            tcg_out_insn(s, RX, LA, TCG_REG_R3, addr_reg, TCG_REG_NONE, a_off);\n\n            tgen_andi(s, TCG_TYPE_TL, TCG_REG_R3, tlb_mask);\n\n        } else {\n\n            tgen_andi_risbg(s, TCG_REG_R3, addr_reg, tlb_mask);\n\n        }\n\n    } else {\n\n        tcg_out_sh64(s, RSY_SRLG, TCG_REG_R2, addr_reg, TCG_REG_NONE,\n\n                     TARGET_PAGE_BITS - CPU_TLB_ENTRY_BITS);\n\n        tcg_out_insn(s, RX, LA, TCG_REG_R3, addr_reg, TCG_REG_NONE, a_off);\n\n        tgen_andi(s, TCG_TYPE_I64, TCG_REG_R2,\n\n                  (CPU_TLB_SIZE - 1) << CPU_TLB_ENTRY_BITS);\n\n        tgen_andi(s, TCG_TYPE_TL, TCG_REG_R3, tlb_mask);\n\n    }\n\n\n\n    if (is_ld) {\n\n        ofs = offsetof(CPUArchState, tlb_table[mem_index][0].addr_read);\n\n    } else {\n\n        ofs = offsetof(CPUArchState, tlb_table[mem_index][0].addr_write);\n\n    }\n\n    if (TARGET_LONG_BITS == 32) {\n\n        tcg_out_mem(s, RX_C, RXY_CY, TCG_REG_R3, TCG_REG_R2, TCG_AREG0, ofs);\n\n    } else {\n\n        tcg_out_mem(s, 0, RXY_CG, TCG_REG_R3, TCG_REG_R2, TCG_AREG0, ofs);\n\n    }\n\n\n\n    ofs = offsetof(CPUArchState, tlb_table[mem_index][0].addend);\n\n    tcg_out_mem(s, 0, RXY_LG, TCG_REG_R2, TCG_REG_R2, TCG_AREG0, ofs);\n\n\n\n    if (TARGET_LONG_BITS == 32) {\n\n        tgen_ext32u(s, TCG_REG_R3, addr_reg);\n\n        return TCG_REG_R3;\n\n    }\n\n    return addr_reg;\n\n}\n", "idx": 7331, "_split": "valid", "_hash": "aa128790e85f729d0243bfa025f2f4c0"}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void unterminated_literal(void)\n\n{\n\n    QObject *obj = qobject_from_json(\"nul\", NULL);\n\n    g_assert(obj == NULL);\n\n}\n", "idx": 7349, "_split": "valid", "_hash": "f84c9c2c30f85dad3a2ba17c9576596c"}
{"project": "qemu", "commit_id": "441692ddd8321d5e0f09b163e86410e578d87236", "target": 1, "func": "static inline int onenand_load_main(OneNANDState *s, int sec, int secn,\n\n                void *dest)\n\n{\n\n    if (s->blk_cur) {\n\n        return blk_read(s->blk_cur, sec, dest, secn) < 0;\n\n    } else if (sec + secn > s->secs_cur) {\n\n        return 1;\n\n    }\n\n\n\n    memcpy(dest, s->current + (sec << 9), secn << 9);\n\n\n\n    return 0;\n\n}\n", "idx": 7353, "_split": "valid", "_hash": "f15099e50957fda953dd37c59712cdda"}
{"project": "qemu", "commit_id": "0b5538c300a56c3cfb33022840fe0b4968147e7a", "target": 1, "func": "static void flush_trace_file(void)\n\n{\n\n    /* If the trace file is not open yet, open it now */\n\n    if (!trace_fp) {\n\n        trace_fp = fopen(trace_file_name, \"w\");\n\n        if (!trace_fp) {\n\n            /* Avoid repeatedly trying to open file on failure */\n\n            trace_file_enabled = false;\n\n            return;\n\n        }\n\n        write_header(trace_fp);\n\n    }\n\n\n\n    if (trace_fp) {\n\n        size_t unused; /* for when fwrite(3) is declared warn_unused_result */\n\n        unused = fwrite(trace_buf, trace_idx * sizeof(trace_buf[0]), 1, trace_fp);\n\n    }\n\n}\n", "idx": 7355, "_split": "valid", "_hash": "d991e2c5a2139eaa3b15911bd39acb31"}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "void helper_fxtoq(CPUSPARCState *env, int64_t src)\n\n{\n\n    /* No possible exceptions converting long long to long double.  */\n\n    QT0 = int64_to_float128(src, &env->fp_status);\n\n}\n", "idx": 7359, "_split": "valid", "_hash": "ee2616ea7f362af584b2929aea011d69"}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_open(void *opaque)\n\n{\n\n    int flags;\n\n    int32_t fid;\n\n    int32_t mode;\n\n    V9fsQID qid;\n\n    int iounit = 0;\n\n    ssize_t err = 0;\n\n    size_t offset = 7;\n\n    struct stat stbuf;\n\n    V9fsFidState *fidp;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    if (s->proto_version == V9FS_PROTO_2000L) {\n\n        pdu_unmarshal(pdu, offset, \"dd\", &fid, &mode);\n\n    } else {\n\n        pdu_unmarshal(pdu, offset, \"db\", &fid, &mode);\n\n    }\n\n    trace_v9fs_open(pdu->tag, pdu->id, fid, mode);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n    BUG_ON(fidp->fid_type != P9_FID_NONE);\n\n\n\n    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    stat_to_qid(&stbuf, &qid);\n\n    if (S_ISDIR(stbuf.st_mode)) {\n\n        err = v9fs_co_opendir(pdu, fidp);\n\n        if (err < 0) {\n\n            goto out;\n\n        }\n\n        fidp->fid_type = P9_FID_DIR;\n\n        offset += pdu_marshal(pdu, offset, \"Qd\", &qid, 0);\n\n        err = offset;\n\n    } else {\n\n        if (s->proto_version == V9FS_PROTO_2000L) {\n\n            flags = get_dotl_openflags(s, mode);\n\n        } else {\n\n            flags = omode_to_uflags(mode);\n\n        }\n\n        if (is_ro_export(&s->ctx)) {\n\n            if (mode & O_WRONLY || mode & O_RDWR ||\n\n                mode & O_APPEND || mode & O_TRUNC) {\n\n                err = -EROFS;\n\n                goto out;\n\n            }\n\n            flags |= O_NOATIME;\n\n        }\n\n        err = v9fs_co_open(pdu, fidp, flags);\n\n        if (err < 0) {\n\n            goto out;\n\n        }\n\n        fidp->fid_type = P9_FID_FILE;\n\n        fidp->open_flags = flags;\n\n        if (flags & O_EXCL) {\n\n            /*\n\n             * We let the host file system do O_EXCL check\n\n             * We should not reclaim such fd\n\n             */\n\n            fidp->flags |= FID_NON_RECLAIMABLE;\n\n        }\n\n        iounit = get_iounit(pdu, &fidp->path);\n\n        offset += pdu_marshal(pdu, offset, \"Qd\", &qid, iounit);\n\n        err = offset;\n\n    }\n\n    trace_v9fs_open_return(pdu->tag, pdu->id,\n\n                           qid.type, qid.version, qid.path, iounit);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(s, pdu, err);\n\n}\n", "idx": 7371, "_split": "valid", "_hash": "a5729a2b2c85837eacf2bb4e96412c56"}
{"project": "qemu", "commit_id": "25f8e2f512d87f0a77fc5c0b367dd200a7834d21", "target": 0, "func": "static int pci_piix3_ide_initfn(PCIDevice *dev)\n\n{\n\n    PCIIDEState *d = DO_UPCAST(PCIIDEState, dev, dev);\n\n\n\n    pci_config_set_vendor_id(d->dev.config, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(d->dev.config, PCI_DEVICE_ID_INTEL_82371SB_1);\n\n    return pci_piix_ide_initfn(d);\n\n}\n", "idx": 7377, "_split": "valid", "_hash": "e7f6d15fd55bfd8a193443af634a6513"}
{"project": "qemu", "commit_id": "be09ac4194bd0a61c0d9412c32431fbe2273cba1", "target": 0, "func": "static abi_long do_getpeername(int fd, abi_ulong target_addr,\n\n                               abi_ulong target_addrlen_addr)\n\n{\n\n    socklen_t addrlen;\n\n    void *addr;\n\n    abi_long ret;\n\n\n\n    if (get_user_u32(addrlen, target_addrlen_addr))\n\n        return -TARGET_EFAULT;\n\n\n\n    if (addrlen < 0 || addrlen > MAX_SOCK_ADDR)\n\n        return -TARGET_EINVAL;\n\n\n\n    addr = alloca(addrlen);\n\n\n\n    ret = get_errno(getpeername(fd, addr, &addrlen));\n\n    if (!is_error(ret)) {\n\n        host_to_target_sockaddr(target_addr, addr, addrlen);\n\n        if (put_user_u32(addrlen, target_addrlen_addr))\n\n            ret = -TARGET_EFAULT;\n\n    }\n\n    return ret;\n\n}\n", "idx": 7378, "_split": "valid", "_hash": "9b1a1d9776e0ca152fdc068feacb6c9c"}
{"project": "qemu", "commit_id": "c18ad9a54b75495ce61e8b28d353f8eec51768fc", "target": 0, "func": "void ppc_hash64_set_external_hpt(PowerPCCPU *cpu, void *hpt, int shift,\n\n                                 Error **errp)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    Error *local_err = NULL;\n\n\n\n    cpu_synchronize_state(CPU(cpu));\n\n\n\n    env->external_htab = hpt;\n\n    ppc_hash64_set_sdr1(cpu, (target_ulong)(uintptr_t)hpt | (shift - 18),\n\n                        &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    /* Not strictly necessary, but makes it clearer that an external\n\n     * htab is in use when debugging */\n\n    env->htab_base = -1;\n\n\n\n    if (kvm_enabled()) {\n\n        if (kvmppc_put_books_sregs(cpu) < 0) {\n\n            error_setg(errp, \"Unable to update SDR1 in KVM\");\n\n        }\n\n    }\n\n}\n", "idx": 7383, "_split": "valid", "_hash": "9a47fcfbe072c922bbc8ff193ce40d47"}
{"project": "qemu", "commit_id": "672558d2ea8dd782d1d2adc6e16af3bc34029a36", "target": 1, "func": "void numa_set_mem_node_id(ram_addr_t addr, uint64_t size, uint32_t node)\n\n{\n\n    struct numa_addr_range *range = g_malloc0(sizeof(*range));\n\n\n\n    /*\n\n     * Memory-less nodes can come here with 0 size in which case,\n\n     * there is nothing to do.\n\n     */\n\n    if (!size) {\n\n        return;\n\n    }\n\n\n\n    range->mem_start = addr;\n\n    range->mem_end = addr + size - 1;\n\n    QLIST_INSERT_HEAD(&numa_info[node].addr, range, entry);\n\n}\n", "idx": 7394, "_split": "valid", "_hash": "7d762c77a565a33206083c6f4601df74"}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int cris_bound_d(int v, int b)\n\n{\n\n\tint r = v;\n\n\tasm (\"bound.d\\t%1, %0\\n\" : \"+r\" (r) : \"ri\" (b));\n\n\treturn r;\n\n}\n", "idx": 7400, "_split": "valid", "_hash": "1825c70663e6d1a457a9d1c7b08a5490"}
{"project": "qemu", "commit_id": "02b07434bed8360715198b4cbfdfebd17f7cac32", "target": 0, "func": "static const char *pxb_host_root_bus_path(PCIHostState *host_bridge,\n\n                                          PCIBus *rootbus)\n\n{\n\n    PXBBus *bus = PXB_BUS(rootbus);\n\n\n\n    snprintf(bus->bus_path, 8, \"0000:%02x\", pxb_bus_num(rootbus));\n\n    return bus->bus_path;\n\n}\n", "idx": 7446, "_split": "valid", "_hash": "54cea1bf0e9c413c22fc100eb4bf4dc8"}
{"project": "qemu", "commit_id": "717adf960933da0650d995f050d457063d591914", "target": 0, "func": "int qemu_strtou64(const char *nptr, const char **endptr, int base,\n\n                  uint64_t *result)\n\n{\n\n    char *p;\n\n    int err = 0;\n\n    if (!nptr) {\n\n        if (endptr) {\n\n            *endptr = nptr;\n\n        }\n\n        err = -EINVAL;\n\n    } else {\n\n        errno = 0;\n\n        /* FIXME This assumes uint64_t is unsigned long long */\n\n        *result = strtoull(nptr, &p, base);\n\n        /* Windows returns 1 for negative out-of-range values.  */\n\n        if (errno == ERANGE) {\n\n            *result = -1;\n\n        }\n\n        err = check_strtox_error(nptr, p, endptr, errno);\n\n    }\n\n    return err;\n\n}\n", "idx": 7450, "_split": "valid", "_hash": "4ee52ecc3850ac5feec2441785b55e2b"}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "void v9fs_string_init(V9fsString *str)\n\n{\n\n    str->data = NULL;\n\n    str->size = 0;\n\n}\n", "idx": 7484, "_split": "valid", "_hash": "eb9ed80744d3369f770302f9f38ab575"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void do_spawn_thread(ThreadPool *pool)\n\n{\n\n    QemuThread t;\n\n\n\n    /* Runs with lock taken.  */\n\n    if (!pool->new_threads) {\n\n        return;\n\n    }\n\n\n\n    pool->new_threads--;\n\n    pool->pending_threads++;\n\n\n\n    qemu_thread_create(&t, \"worker\", worker_thread, pool, QEMU_THREAD_DETACHED);\n\n}\n", "idx": 7487, "_split": "valid", "_hash": "fbe64118b4228102b5fcefabb7dcc2ef"}
{"project": "qemu", "commit_id": "5379229a2708df3a1506113315214c3ce5325859", "target": 0, "func": "icmp_input(struct mbuf *m, int hlen)\n\n{\n\n  register struct icmp *icp;\n\n  register struct ip *ip=mtod(m, struct ip *);\n\n  int icmplen=ip->ip_len;\n\n  Slirp *slirp = m->slirp;\n\n\n\n  DEBUG_CALL(\"icmp_input\");\n\n  DEBUG_ARG(\"m = %p\", m);\n\n  DEBUG_ARG(\"m_len = %d\", m->m_len);\n\n\n\n  /*\n\n   * Locate icmp structure in mbuf, and check\n\n   * that its not corrupted and of at least minimum length.\n\n   */\n\n  if (icmplen < ICMP_MINLEN) {          /* min 8 bytes payload */\n\n  freeit:\n\n    m_free(m);\n\n    goto end_error;\n\n  }\n\n\n\n  m->m_len -= hlen;\n\n  m->m_data += hlen;\n\n  icp = mtod(m, struct icmp *);\n\n  if (cksum(m, icmplen)) {\n\n    goto freeit;\n\n  }\n\n  m->m_len += hlen;\n\n  m->m_data -= hlen;\n\n\n\n  DEBUG_ARG(\"icmp_type = %d\", icp->icmp_type);\n\n  switch (icp->icmp_type) {\n\n  case ICMP_ECHO:\n\n    ip->ip_len += hlen;\t             /* since ip_input subtracts this */\n\n    if (ip->ip_dst.s_addr == slirp->vhost_addr.s_addr) {\n\n      icmp_reflect(m);\n\n    } else if (slirp->restricted) {\n\n        goto freeit;\n\n    } else {\n\n      struct socket *so;\n\n      struct sockaddr_in addr;\n\n      if ((so = socreate(slirp)) == NULL) goto freeit;\n\n      if (icmp_send(so, m, hlen) == 0) {\n\n        return;\n\n      }\n\n      if(udp_attach(so) == -1) {\n\n\tDEBUG_MISC((dfd,\"icmp_input udp_attach errno = %d-%s\\n\",\n\n\t\t    errno,strerror(errno)));\n\n\tsofree(so);\n\n\tm_free(m);\n\n\tgoto end_error;\n\n      }\n\n      so->so_m = m;\n\n      so->so_ffamily = AF_INET;\n\n      so->so_faddr = ip->ip_dst;\n\n      so->so_fport = htons(7);\n\n      so->so_lfamily = AF_INET;\n\n      so->so_laddr = ip->ip_src;\n\n      so->so_lport = htons(9);\n\n      so->so_iptos = ip->ip_tos;\n\n      so->so_type = IPPROTO_ICMP;\n\n      so->so_state = SS_ISFCONNECTED;\n\n\n\n      /* Send the packet */\n\n      addr.sin_family = AF_INET;\n\n      if ((so->so_faddr.s_addr & slirp->vnetwork_mask.s_addr) ==\n\n          slirp->vnetwork_addr.s_addr) {\n\n\t/* It's an alias */\n\n\tif (so->so_faddr.s_addr == slirp->vnameserver_addr.s_addr) {\n\n\t  if (get_dns_addr(&addr.sin_addr) < 0)\n\n\t    addr.sin_addr = loopback_addr;\n\n\t} else {\n\n\t  addr.sin_addr = loopback_addr;\n\n\t}\n\n      } else {\n\n\taddr.sin_addr = so->so_faddr;\n\n      }\n\n      addr.sin_port = so->so_fport;\n\n      if(sendto(so->s, icmp_ping_msg, strlen(icmp_ping_msg), 0,\n\n\t\t(struct sockaddr *)&addr, sizeof(addr)) == -1) {\n\n\tDEBUG_MISC((dfd,\"icmp_input udp sendto tx errno = %d-%s\\n\",\n\n\t\t    errno,strerror(errno)));\n\n\ticmp_error(m, ICMP_UNREACH,ICMP_UNREACH_NET, 0,strerror(errno));\n\n\tudp_detach(so);\n\n      }\n\n    } /* if ip->ip_dst.s_addr == alias_addr.s_addr */\n\n    break;\n\n  case ICMP_UNREACH:\n\n    /* XXX? report error? close socket? */\n\n  case ICMP_TIMXCEED:\n\n  case ICMP_PARAMPROB:\n\n  case ICMP_SOURCEQUENCH:\n\n  case ICMP_TSTAMP:\n\n  case ICMP_MASKREQ:\n\n  case ICMP_REDIRECT:\n\n    m_free(m);\n\n    break;\n\n\n\n  default:\n\n    m_free(m);\n\n  } /* swith */\n\n\n\nend_error:\n\n  /* m is m_free()'d xor put in a socket xor or given to ip_send */\n\n  return;\n\n}\n", "idx": 7496, "_split": "valid", "_hash": "4d43a5353795385d8f154ed76683023e"}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static void virtio_net_tx_complete(NetClientState *nc, ssize_t len)\n\n{\n\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n\n    VirtIONetQueue *q = virtio_net_get_subqueue(nc);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n\n\n    virtqueue_push(q->tx_vq, &q->async_tx.elem, 0);\n\n    virtio_notify(vdev, q->tx_vq);\n\n\n\n    q->async_tx.elem.out_num = 0;\n\n\n\n    virtio_queue_set_notification(q->tx_vq, 1);\n\n    virtio_net_flush_tx(q);\n\n}\n", "idx": 7502, "_split": "valid", "_hash": "9341157befefb7aceba484e38c289646"}
{"project": "qemu", "commit_id": "0f8c289ad539feb5135c545bea947b310a893f4b", "target": 1, "func": "static int net_socket_mcast_init(NetClientState *peer,\n\n                                 const char *model,\n\n                                 const char *name,\n\n                                 const char *host_str,\n\n                                 const char *localaddr_str)\n\n{\n\n    NetSocketState *s;\n\n    int fd;\n\n    struct sockaddr_in saddr;\n\n    struct in_addr localaddr, *param_localaddr;\n\n\n\n    if (parse_host_port(&saddr, host_str) < 0)\n\n        return -1;\n\n\n\n    if (localaddr_str != NULL) {\n\n        if (inet_aton(localaddr_str, &localaddr) == 0)\n\n            return -1;\n\n        param_localaddr = &localaddr;\n\n    } else {\n\n        param_localaddr = NULL;\n\n    }\n\n\n\n    fd = net_socket_mcast_create(&saddr, param_localaddr);\n\n    if (fd < 0)\n\n        return -1;\n\n\n\n    s = net_socket_fd_init(peer, model, name, fd, 0);\n\n    if (!s)\n\n        return -1;\n\n\n\n    s->dgram_dst = saddr;\n\n\n\n    snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n             \"socket: mcast=%s:%d\",\n\n             inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));\n\n    return 0;\n\n\n\n}\n", "idx": 7522, "_split": "valid", "_hash": "d99972c99ccd9ec69aed565af851aa82"}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void pl041_device_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    k->init = pl041_init;\n\n    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);\n\n    dc->no_user = 1;\n\n    dc->reset = pl041_device_reset;\n\n    dc->vmsd = &vmstate_pl041;\n\n    dc->props = pl041_device_properties;\n\n}\n", "idx": 7528, "_split": "valid", "_hash": "098d07a32bd6e64893bb8725affe664a"}
{"project": "qemu", "commit_id": "a41642708a5d1cbe8ad966227bbee1ed5eb421ad", "target": 1, "func": "static SpiceChannelList *qmp_query_spice_channels(void)\n\n{\n\n    SpiceChannelList *cur_item = NULL, *head = NULL;\n\n    ChannelList *item;\n\n\n\n    QTAILQ_FOREACH(item, &channel_list, link) {\n\n        SpiceChannelList *chan;\n\n        char host[NI_MAXHOST], port[NI_MAXSERV];\n\n        struct sockaddr *paddr;\n\n        socklen_t plen;\n\n\n\n        if (!(item->info->flags & SPICE_CHANNEL_EVENT_FLAG_ADDR_EXT)) {\n\n            error_report(\"invalid channel event\");\n\n            return NULL;\n\n        }\n\n\n\n        chan = g_malloc0(sizeof(*chan));\n\n        chan->value = g_malloc0(sizeof(*chan->value));\n\n        chan->value->base = g_malloc0(sizeof(*chan->value->base));\n\n\n\n        paddr = (struct sockaddr *)&item->info->paddr_ext;\n\n        plen = item->info->plen_ext;\n\n        getnameinfo(paddr, plen,\n\n                    host, sizeof(host), port, sizeof(port),\n\n                    NI_NUMERICHOST | NI_NUMERICSERV);\n\n        chan->value->base->host = g_strdup(host);\n\n        chan->value->base->port = g_strdup(port);\n\n        chan->value->base->family = inet_netfamily(paddr->sa_family);\n\n\n\n        chan->value->connection_id = item->info->connection_id;\n\n        chan->value->channel_type = item->info->type;\n\n        chan->value->channel_id = item->info->id;\n\n        chan->value->tls = item->info->flags & SPICE_CHANNEL_EVENT_FLAG_TLS;\n\n\n\n       /* XXX: waiting for the qapi to support GSList */\n\n        if (!cur_item) {\n\n            head = cur_item = chan;\n\n        } else {\n\n            cur_item->next = chan;\n\n            cur_item = chan;\n\n        }\n\n    }\n\n\n\n    return head;\n\n}\n", "idx": 7531, "_split": "valid", "_hash": "1311d3d381e0829ca06da642ad043c88"}
{"project": "qemu", "commit_id": "ece2d05ed4adb9a9aa3ca9da0496be769dfb3a25", "target": 1, "func": "static int cd_read_sector(IDEState *s, int lba, uint8_t *buf, int sector_size)\n\n{\n\n    int ret;\n\n\n\n    switch(sector_size) {\n\n    case 2048:\n\n        block_acct_start(blk_get_stats(s->blk), &s->acct,\n\n                         4 * BDRV_SECTOR_SIZE, BLOCK_ACCT_READ);\n\n        ret = blk_read(s->blk, (int64_t)lba << 2, buf, 4);\n\n        block_acct_done(blk_get_stats(s->blk), &s->acct);\n\n        break;\n\n    case 2352:\n\n        block_acct_start(blk_get_stats(s->blk), &s->acct,\n\n                         4 * BDRV_SECTOR_SIZE, BLOCK_ACCT_READ);\n\n        ret = blk_read(s->blk, (int64_t)lba << 2, buf + 16, 4);\n\n        block_acct_done(blk_get_stats(s->blk), &s->acct);\n\n        if (ret < 0)\n\n            return ret;\n\n        cd_data_to_raw(buf, lba);\n\n        break;\n\n    default:\n\n        ret = -EIO;\n\n        break;\n\n    }\n\n    return ret;\n\n}\n", "idx": 7538, "_split": "valid", "_hash": "0bd8d9d52093bf563038eebecdcf64e7"}
{"project": "qemu", "commit_id": "81145834d39897c6f153ac26a4077f90f269c5fc", "target": 1, "func": "static int cow_read(BlockDriverState *bs, int64_t sector_num,\n\n                    uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVCowState *s = bs->opaque;\n\n    int ret, n;\n\n\n\n    while (nb_sectors > 0) {\n\n        if (cow_is_allocated(bs, sector_num, nb_sectors, &n)) {\n\n            ret = bdrv_pread(bs->file,\n\n                        s->cow_sectors_offset + sector_num * 512,\n\n                        buf, n * 512);\n\n            if (ret != n * 512)\n\n                return -1;\n\n        } else {\n\n            if (bs->backing_hd) {\n\n                /* read from the base image */\n\n                ret = bdrv_read(bs->backing_hd, sector_num, buf, n);\n\n                if (ret < 0)\n\n                    return -1;\n\n            } else {\n\n            memset(buf, 0, n * 512);\n\n        }\n\n        }\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n    }\n\n    return 0;\n\n}\n", "idx": 7540, "_split": "valid", "_hash": "2034aa8abd4329664a84cbec6f8985f2"}
{"project": "qemu", "commit_id": "7ebaf7955603cc50988e0eafd5e6074320fefc70", "target": 0, "func": "static HotplugHandler *spapr_get_hotpug_handler(MachineState *machine,\n\n                                             DeviceState *dev)\n\n{\n\n    if (object_dynamic_cast(OBJECT(dev), TYPE_PC_DIMM) ||\n\n        object_dynamic_cast(OBJECT(dev), TYPE_SPAPR_CPU_CORE)) {\n\n        return HOTPLUG_HANDLER(machine);\n\n    }\n\n    return NULL;\n\n}\n", "idx": 7580, "_split": "valid", "_hash": "c89f80d32a6fc5113a32c300c790544a"}
{"project": "qemu", "commit_id": "cf0f7cf903073f9dd9979dd33d52618b384ac2cb", "target": 1, "func": "void kvm_init_cpu_signals(CPUState *cpu)\n\n{\n\n    int r;\n\n    sigset_t set;\n\n    struct sigaction sigact;\n\n\n\n    memset(&sigact, 0, sizeof(sigact));\n\n    sigact.sa_handler = dummy_signal;\n\n    sigaction(SIG_IPI, &sigact, NULL);\n\n\n\n    pthread_sigmask(SIG_BLOCK, NULL, &set);\n\n#if defined KVM_HAVE_MCE_INJECTION\n\n    sigdelset(&set, SIGBUS);\n\n    pthread_sigmask(SIG_SETMASK, &set, NULL);\n\n#endif\n\n    sigdelset(&set, SIG_IPI);\n\n    r = kvm_set_signal_mask(cpu, &set);\n\n    if (r) {\n\n        fprintf(stderr, \"kvm_set_signal_mask: %s\\n\", strerror(-r));\n\n        exit(1);\n\n    }\n\n}\n", "idx": 7665, "_split": "valid", "_hash": "2ffd623ffc2bc21ddfb3ba489141be16"}
{"project": "qemu", "commit_id": "3e40ba0faf0822fa78336fe6cd9d677ea9b14f1b", "target": 1, "func": "static void vfio_disable_msix(VFIODevice *vdev)\n{\n    msix_unset_vector_notifiers(&vdev->pdev);\n    if (vdev->nr_vectors) {\n        vfio_disable_irqindex(vdev, VFIO_PCI_MSIX_IRQ_INDEX);\n    vfio_disable_msi_common(vdev);\n    DPRINTF(\"%s(%04x:%02x:%02x.%x)\\n\", __func__, vdev->host.domain,\n            vdev->host.bus, vdev->host.slot, vdev->host.function);", "idx": 7678, "_split": "valid", "_hash": "3429c1ec3f27987bd34ef87d8c9add36"}
{"project": "qemu", "commit_id": "36cf2a37132c7f01fa9adb5f95f5312b27742fd4", "target": 1, "func": "void virtqueue_map_sg(struct iovec *sg, hwaddr *addr,\n    size_t num_sg, int is_write)\n{\n    unsigned int i;\n    hwaddr len;\n    for (i = 0; i < num_sg; i++) {\n        len = sg[i].iov_len;\n        sg[i].iov_base = cpu_physical_memory_map(addr[i], &len, is_write);\n        if (sg[i].iov_base == NULL || len != sg[i].iov_len) {\n            error_report(\"virtio: trying to map MMIO memory\");", "idx": 7690, "_split": "valid", "_hash": "e957da311adde6a30e5b162b213b5533"}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void ehci_async_complete_packet(USBPort *port, USBPacket *packet)\n\n{\n\n    EHCIQueue *q;\n\n    EHCIState *s = port->opaque;\n\n    uint32_t portsc = s->portsc[port->index];\n\n\n\n    if (portsc & PORTSC_POWNER) {\n\n        USBPort *companion = s->companion_ports[port->index];\n\n        companion->ops->complete(companion, packet);\n\n        return;\n\n    }\n\n\n\n    q = container_of(packet, EHCIQueue, packet);\n\n    trace_usb_ehci_queue_action(q, \"wakeup\");\n\n    assert(q->async == EHCI_ASYNC_INFLIGHT);\n\n    q->async = EHCI_ASYNC_FINISHED;\n\n    q->usb_status = packet->len;\n\n}\n", "idx": 7706, "_split": "valid", "_hash": "70fd1bea63c2fcb0b2fec444782136b5"}
{"project": "qemu", "commit_id": "9883975050deffc147a3903d07ff995ecdc8a100", "target": 1, "func": "static int l2_allocate(BlockDriverState *bs, int l1_index, uint64_t **table)\n{\n    BDRVQcow2State *s = bs->opaque;\n    uint64_t old_l2_offset;\n    uint64_t *l2_table = NULL;\n    int64_t l2_offset;\n    int ret;\n    old_l2_offset = s->l1_table[l1_index];\n    trace_qcow2_l2_allocate(bs, l1_index);\n    /* allocate a new l2 entry */\n    l2_offset = qcow2_alloc_clusters(bs, s->l2_size * sizeof(uint64_t));\n    if (l2_offset < 0) {\n        ret = l2_offset;\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n    if (ret < 0) {\n    /* allocate a new entry in the l2 cache */\n    trace_qcow2_l2_allocate_get_empty(bs, l1_index);\n    ret = qcow2_cache_get_empty(bs, s->l2_table_cache, l2_offset, (void**) table);\n    if (ret < 0) {\n    l2_table = *table;\n    if ((old_l2_offset & L1E_OFFSET_MASK) == 0) {\n        /* if there was no old l2 table, clear the new table */\n        memset(l2_table, 0, s->l2_size * sizeof(uint64_t));\n    } else {\n        uint64_t* old_table;\n        /* if there was an old l2 table, read it from the disk */\n        BLKDBG_EVENT(bs->file, BLKDBG_L2_ALLOC_COW_READ);\n        ret = qcow2_cache_get(bs, s->l2_table_cache,\n            old_l2_offset & L1E_OFFSET_MASK,\n            (void**) &old_table);\n        if (ret < 0) {\n        memcpy(l2_table, old_table, s->cluster_size);\n        qcow2_cache_put(bs, s->l2_table_cache, (void **) &old_table);\n    /* write the l2 table to the file */\n    BLKDBG_EVENT(bs->file, BLKDBG_L2_ALLOC_WRITE);\n    trace_qcow2_l2_allocate_write_l2(bs, l1_index);\n    qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n    if (ret < 0) {\n    /* update the L1 entry */\n    trace_qcow2_l2_allocate_write_l1(bs, l1_index);\n    s->l1_table[l1_index] = l2_offset | QCOW_OFLAG_COPIED;\n    ret = qcow2_write_l1_entry(bs, l1_index);\n    if (ret < 0) {\n    *table = l2_table;\n    trace_qcow2_l2_allocate_done(bs, l1_index, 0);\n    return 0;\nfail:\n    trace_qcow2_l2_allocate_done(bs, l1_index, ret);\n    if (l2_table != NULL) {\n        qcow2_cache_put(bs, s->l2_table_cache, (void**) table);\n    s->l1_table[l1_index] = old_l2_offset;\n    if (l2_offset > 0) {\n        qcow2_free_clusters(bs, l2_offset, s->l2_size * sizeof(uint64_t),\n                            QCOW2_DISCARD_ALWAYS);\n    return ret;", "idx": 7745, "_split": "valid", "_hash": "9af712efd6912e5e827129a22f9a686e"}
{"project": "qemu", "commit_id": "c2d76497b6eafcaedc806e07804e7bed55a98a0b", "target": 1, "func": "void get_tmp_filename(char *filename, int size)\n\n{\n\n    char temp_dir[MAX_PATH];\n\n\n\n    GetTempPath(MAX_PATH, temp_dir);\n\n    GetTempFileName(temp_dir, \"qem\", 0, filename);\n\n}\n", "idx": 7770, "_split": "valid", "_hash": "fa072ea95a01c2333812ff30efd5cb63"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void microblaze_load_kernel(MicroBlazeCPU *cpu, target_phys_addr_t ddr_base,\n\n                            uint32_t ramsize, const char *dtb_filename,\n\n                            void (*machine_cpu_reset)(MicroBlazeCPU *))\n\n{\n\n    QemuOpts *machine_opts;\n\n    const char *kernel_filename = NULL;\n\n    const char *kernel_cmdline = NULL;\n\n\n\n    machine_opts = qemu_opts_find(qemu_find_opts(\"machine\"), 0);\n\n    if (machine_opts) {\n\n        const char *dtb_arg;\n\n        kernel_filename = qemu_opt_get(machine_opts, \"kernel\");\n\n        kernel_cmdline = qemu_opt_get(machine_opts, \"append\");\n\n        dtb_arg = qemu_opt_get(machine_opts, \"dtb\");\n\n        if (dtb_arg) { /* Preference a -dtb argument */\n\n            dtb_filename = dtb_arg;\n\n        } else { /* default to pcbios dtb as passed by machine_init */\n\n            dtb_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, dtb_filename);\n\n        }\n\n    }\n\n\n\n    boot_info.machine_cpu_reset = machine_cpu_reset;\n\n    qemu_register_reset(main_cpu_reset, cpu);\n\n\n\n    if (kernel_filename) {\n\n        int kernel_size;\n\n        uint64_t entry, low, high;\n\n        uint32_t base32;\n\n        int big_endian = 0;\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n        big_endian = 1;\n\n#endif\n\n\n\n        /* Boots a kernel elf binary.  */\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL,\n\n                               &entry, &low, &high,\n\n                               big_endian, ELF_MACHINE, 0);\n\n        base32 = entry;\n\n        if (base32 == 0xc0000000) {\n\n            kernel_size = load_elf(kernel_filename, translate_kernel_address,\n\n                                   NULL, &entry, NULL, NULL,\n\n                                   big_endian, ELF_MACHINE, 0);\n\n        }\n\n        /* Always boot into physical ram.  */\n\n        boot_info.bootstrap_pc = ddr_base + (entry & 0x0fffffff);\n\n\n\n        /* If it wasn't an ELF image, try an u-boot image.  */\n\n        if (kernel_size < 0) {\n\n            target_phys_addr_t uentry, loadaddr;\n\n\n\n            kernel_size = load_uimage(kernel_filename, &uentry, &loadaddr, 0);\n\n            boot_info.bootstrap_pc = uentry;\n\n            high = (loadaddr + kernel_size + 3) & ~3;\n\n        }\n\n\n\n        /* Not an ELF image nor an u-boot image, try a RAW image.  */\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename, ddr_base,\n\n                                              ram_size);\n\n            boot_info.bootstrap_pc = ddr_base;\n\n            high = (ddr_base + kernel_size + 3) & ~3;\n\n        }\n\n\n\n        boot_info.cmdline = high + 4096;\n\n        if (kernel_cmdline && strlen(kernel_cmdline)) {\n\n            pstrcpy_targphys(\"cmdline\", boot_info.cmdline, 256, kernel_cmdline);\n\n        }\n\n        /* Provide a device-tree.  */\n\n        boot_info.fdt = boot_info.cmdline + 4096;\n\n        microblaze_load_dtb(boot_info.fdt, ram_size, kernel_cmdline,\n\n                                                     dtb_filename);\n\n    }\n\n\n\n}\n", "idx": 7786, "_split": "valid", "_hash": "2dd81d422b447992efb258eddef3ce98"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void qemu_clock_enable(QEMUClockType type, bool enabled)\n\n{\n\n    QEMUClock *clock = qemu_clock_ptr(type);\n\n    QEMUTimerList *tl;\n\n    bool old = clock->enabled;\n\n    clock->enabled = enabled;\n\n    if (enabled && !old) {\n\n        qemu_clock_notify(type);\n\n    } else if (!enabled && old) {\n\n        QLIST_FOREACH(tl, &clock->timerlists, list) {\n\n            qemu_event_wait(&tl->timers_done_ev);\n\n        }\n\n    }\n\n}\n", "idx": 7791, "_split": "valid", "_hash": "aff51e4e9ea482a9e251c80fae488c75"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t grlib_gptimer_read(void *opaque, target_phys_addr_t addr,\n\n                                   unsigned size)\n\n{\n\n    GPTimerUnit        *unit  = opaque;\n\n    target_phys_addr_t  timer_addr;\n\n    int                 id;\n\n    uint32_t            value = 0;\n\n\n\n    addr &= 0xff;\n\n\n\n    /* Unit registers */\n\n    switch (addr) {\n\n    case SCALER_OFFSET:\n\n        trace_grlib_gptimer_readl(-1, addr, unit->scaler);\n\n        return unit->scaler;\n\n\n\n    case SCALER_RELOAD_OFFSET:\n\n        trace_grlib_gptimer_readl(-1, addr, unit->reload);\n\n        return unit->reload;\n\n\n\n    case CONFIG_OFFSET:\n\n        trace_grlib_gptimer_readl(-1, addr, unit->config);\n\n        return unit->config;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    timer_addr = (addr % TIMER_BASE);\n\n    id         = (addr - TIMER_BASE) / TIMER_BASE;\n\n\n\n    if (id >= 0 && id < unit->nr_timers) {\n\n\n\n        /* GPTimer registers */\n\n        switch (timer_addr) {\n\n        case COUNTER_OFFSET:\n\n            value = ptimer_get_count(unit->timers[id].ptimer);\n\n            trace_grlib_gptimer_readl(id, addr, value);\n\n            return value;\n\n\n\n        case COUNTER_RELOAD_OFFSET:\n\n            value = unit->timers[id].reload;\n\n            trace_grlib_gptimer_readl(id, addr, value);\n\n            return value;\n\n\n\n        case CONFIG_OFFSET:\n\n            trace_grlib_gptimer_readl(id, addr, unit->timers[id].config);\n\n            return unit->timers[id].config;\n\n\n\n        default:\n\n            break;\n\n        }\n\n\n\n    }\n\n\n\n    trace_grlib_gptimer_readl(-1, addr, 0);\n\n    return 0;\n\n}\n", "idx": 7792, "_split": "valid", "_hash": "f8ef3c494b8f156398a7f757f676017f"}
{"project": "qemu", "commit_id": "6d8048341995b31a77dc2e0dcaaf4e3df0e3121a", "target": 0, "func": "static int get_cpsr(QEMUFile *f, void *opaque, size_t size,\n\n                    VMStateField *field)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    CPUARMState *env = &cpu->env;\n\n    uint32_t val = qemu_get_be32(f);\n\n\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        if (val & XPSR_EXCP) {\n\n            /* This is a CPSR format value from an older QEMU. (We can tell\n\n             * because values transferred in XPSR format always have zero\n\n             * for the EXCP field, and CPSR format will always have bit 4\n\n             * set in CPSR_M.) Rearrange it into XPSR format. The significant\n\n             * differences are that the T bit is not in the same place, the\n\n             * primask/faultmask info may be in the CPSR I and F bits, and\n\n             * we do not want the mode bits.\n\n             */\n\n            uint32_t newval = val;\n\n\n\n            newval &= (CPSR_NZCV | CPSR_Q | CPSR_IT | CPSR_GE);\n\n            if (val & CPSR_T) {\n\n                newval |= XPSR_T;\n\n            }\n\n            /* If the I or F bits are set then this is a migration from\n\n             * an old QEMU which still stored the M profile FAULTMASK\n\n             * and PRIMASK in env->daif. For a new QEMU, the data is\n\n             * transferred using the vmstate_m_faultmask_primask subsection.\n\n             */\n\n            if (val & CPSR_F) {\n\n                env->v7m.faultmask = 1;\n\n            }\n\n            if (val & CPSR_I) {\n\n                env->v7m.primask = 1;\n\n            }\n\n            val = newval;\n\n        }\n\n        /* Ignore the low bits, they are handled by vmstate_m. */\n\n        xpsr_write(env, val, ~XPSR_EXCP);\n\n        return 0;\n\n    }\n\n\n\n    env->aarch64 = ((val & PSTATE_nRW) == 0);\n\n\n\n    if (is_a64(env)) {\n\n        pstate_write(env, val);\n\n        return 0;\n\n    }\n\n\n\n    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);\n\n    return 0;\n\n}\n", "idx": 7797, "_split": "valid", "_hash": "e73d755fbec8cda22d6300685884cd62"}
{"project": "qemu", "commit_id": "89b190a2bb82b1226b5cc05846e9a063c0d0efa3", "target": 0, "func": "static void pcnet_receive(void *opaque, const uint8_t *buf, int size)\n\n{\n\n    PCNetState *s = opaque;\n\n    int is_padr = 0, is_bcast = 0, is_ladr = 0;\n\n    uint8_t buf1[60];\n\n\n\n    if (CSR_DRX(s) || CSR_STOP(s) || CSR_SPND(s) || !size)\n\n        return;\n\n\n\n#ifdef PCNET_DEBUG\n\n    printf(\"pcnet_receive size=%d\\n\", size);\n\n#endif\n\n\n\n    /* if too small buffer, then expand it */\n\n    if (size < MIN_BUF_SIZE) {\n\n        memcpy(buf1, buf, size);\n\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n\n        buf = buf1;\n\n        size = MIN_BUF_SIZE;\n\n    }\n\n\n\n    if (CSR_PROM(s)\n\n        || (is_padr=padr_match(s, buf, size))\n\n        || (is_bcast=padr_bcast(s, buf, size))\n\n        || (is_ladr=ladr_match(s, buf, size))) {\n\n\n\n        pcnet_rdte_poll(s);\n\n\n\n        if (!(CSR_CRST(s) & 0x8000) && s->rdra) {\n\n            struct pcnet_RMD rmd;\n\n            int rcvrc = CSR_RCVRC(s)-1,i;\n\n            target_phys_addr_t nrda;\n\n            for (i = CSR_RCVRL(s)-1; i > 0; i--, rcvrc--) {\n\n                if (rcvrc <= 1)\n\n                    rcvrc = CSR_RCVRL(s);\n\n                nrda = s->rdra +\n\n                    (CSR_RCVRL(s) - rcvrc) *\n\n                    (BCR_SWSTYLE(s) ? 16 : 8 );\n\n                RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n#ifdef PCNET_DEBUG_RMD\n\n                    printf(\"pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d\\n\",\n\n                                rcvrc, CSR_RCVRC(s));\n\n#endif\n\n                    CSR_RCVRC(s) = rcvrc;\n\n                    pcnet_rdte_poll(s);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (!(CSR_CRST(s) & 0x8000)) {\n\n#ifdef PCNET_DEBUG_RMD\n\n            printf(\"pcnet - no buffer: RCVRC=%d\\n\", CSR_RCVRC(s));\n\n#endif\n\n            s->csr[0] |= 0x1000; /* Set MISS flag */\n\n            CSR_MISSC(s)++;\n\n        } else {\n\n            uint8_t *src = &s->buffer[8];\n\n            target_phys_addr_t crda = CSR_CRDA(s);\n\n            struct pcnet_RMD rmd;\n\n            int pktcount = 0;\n\n\n\n            memcpy(src, buf, size);\n\n\n\n#if 1\n\n            /* no need to compute the CRC */\n\n            src[size] = 0;\n\n            src[size + 1] = 0;\n\n            src[size + 2] = 0;\n\n            src[size + 3] = 0;\n\n            size += 4;\n\n#else\n\n            /* XXX: avoid CRC generation */\n\n            if (!CSR_ASTRP_RCV(s)) {\n\n                uint32_t fcs = ~0;\n\n                uint8_t *p = src;\n\n\n\n                while (size < 46) {\n\n                    src[size++] = 0;\n\n                }\n\n\n\n                while (p != &src[size]) {\n\n                    CRC(fcs, *p++);\n\n                }\n\n                ((uint32_t *)&src[size])[0] = htonl(fcs);\n\n                size += 4; /* FCS at end of packet */\n\n            } else size += 4;\n\n#endif\n\n\n\n#ifdef PCNET_DEBUG_MATCH\n\n            PRINT_PKTHDR(buf);\n\n#endif\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            /*if (!CSR_LAPPEN(s))*/\n\n                SET_FIELD(&rmd.status, RMDS, STP, 1);\n\n\n\n#define PCNET_RECV_STORE() do {                                 \\\n\n    int count = MIN(4096 - GET_FIELD(rmd.buf_length, RMDL, BCNT),size); \\\n\n    target_phys_addr_t rbadr = PHYSADDR(s, rmd.rbadr);          \\\n\n    s->phys_mem_write(s->dma_opaque, rbadr, src, count, CSR_BSWP(s)); \\\n\n    src += count; size -= count;                                \\\n\n    SET_FIELD(&rmd.msg_length, RMDM, MCNT, count);              \\\n\n    SET_FIELD(&rmd.status, RMDS, OWN, 0);                       \\\n\n    RMDSTORE(&rmd, PHYSADDR(s,crda));                           \\\n\n    pktcount++;                                                 \\\n\n} while (0)\n\n\n\n            PCNET_RECV_STORE();\n\n            if ((size > 0) && CSR_NRDA(s)) {\n\n                target_phys_addr_t nrda = CSR_NRDA(s);\n\n                RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n                    crda = nrda;\n\n                    PCNET_RECV_STORE();\n\n                    if ((size > 0) && (nrda=CSR_NNRD(s))) {\n\n                        RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                        if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n                            crda = nrda;\n\n                            PCNET_RECV_STORE();\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n\n\n#undef PCNET_RECV_STORE\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            if (size == 0) {\n\n                SET_FIELD(&rmd.status, RMDS, ENP, 1);\n\n                SET_FIELD(&rmd.status, RMDS, PAM, !CSR_PROM(s) && is_padr);\n\n                SET_FIELD(&rmd.status, RMDS, LFAM, !CSR_PROM(s) && is_ladr);\n\n                SET_FIELD(&rmd.status, RMDS, BAM, !CSR_PROM(s) && is_bcast);\n\n            } else {\n\n                SET_FIELD(&rmd.status, RMDS, OFLO, 1);\n\n                SET_FIELD(&rmd.status, RMDS, BUFF, 1);\n\n                SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n            }\n\n            RMDSTORE(&rmd, PHYSADDR(s,crda));\n\n            s->csr[0] |= 0x0400;\n\n\n\n#ifdef PCNET_DEBUG\n\n            printf(\"RCVRC=%d CRDA=0x%08x BLKS=%d\\n\",\n\n                CSR_RCVRC(s), PHYSADDR(s,CSR_CRDA(s)), pktcount);\n\n#endif\n\n#ifdef PCNET_DEBUG_RMD\n\n            PRINT_RMD(&rmd);\n\n#endif\n\n\n\n            while (pktcount--) {\n\n                if (CSR_RCVRC(s) <= 1)\n\n                    CSR_RCVRC(s) = CSR_RCVRL(s);\n\n                else\n\n                    CSR_RCVRC(s)--;\n\n            }\n\n\n\n            pcnet_rdte_poll(s);\n\n\n\n        }\n\n    }\n\n\n\n    pcnet_poll(s);\n\n    pcnet_update_irq(s);\n\n}\n", "idx": 7817, "_split": "valid", "_hash": "c68bf3dcaa9fc56c4dfb9d9ef3499d2d"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t m5206_mbar_readl(void *opaque, target_phys_addr_t offset)\n\n{\n\n    m5206_mbar_state *s = (m5206_mbar_state *)opaque;\n\n    int width;\n\n    offset &= 0x3ff;\n\n    if (offset >= 0x200) {\n\n        hw_error(\"Bad MBAR read offset 0x%x\", (int)offset);\n\n    }\n\n    width = m5206_mbar_width[offset >> 2];\n\n    if (width < 4) {\n\n        uint32_t val;\n\n        val = m5206_mbar_readw(opaque, offset) << 16;\n\n        val |= m5206_mbar_readw(opaque, offset + 2);\n\n        return val;\n\n    }\n\n    return m5206_mbar_read(s, offset, 4);\n\n}\n", "idx": 7819, "_split": "valid", "_hash": "fad8ea712eeadf652fd6c98c82cfc8f2"}
{"project": "qemu", "commit_id": "a3f1afb43a09e4577571c044c48f2ba9e6e4ad06", "target": 0, "func": "uint64_t qcow2_alloc_compressed_cluster_offset(BlockDriverState *bs,\n\n                                               uint64_t offset,\n\n                                               int compressed_size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l2_index, ret;\n\n    uint64_t *l2_table;\n\n    int64_t cluster_offset;\n\n    int nb_csectors;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return 0;\n\n    }\n\n\n\n    /* Compression can't overwrite anything. Fail if the cluster was already\n\n     * allocated. */\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n    if (cluster_offset & L2E_OFFSET_MASK) {\n\n        qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n        return 0;\n\n    }\n\n\n\n    cluster_offset = qcow2_alloc_bytes(bs, compressed_size);\n\n    if (cluster_offset < 0) {\n\n        qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n        return 0;\n\n    }\n\n\n\n    nb_csectors = ((cluster_offset + compressed_size - 1) >> 9) -\n\n                  (cluster_offset >> 9);\n\n\n\n    cluster_offset |= QCOW_OFLAG_COMPRESSED |\n\n                      ((uint64_t)nb_csectors << s->csize_shift);\n\n\n\n    /* update L2 table */\n\n\n\n    /* compressed clusters never have the copied flag */\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L2_UPDATE_COMPRESSED);\n\n    qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n\n    l2_table[l2_index] = cpu_to_be64(cluster_offset);\n\n    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n    if (ret < 0) {\n\n        return 0;\n\n    }\n\n\n\n    return cluster_offset;\n\n}\n", "idx": 7826, "_split": "valid", "_hash": "2d6b63bea133185d0af4d97317344c91"}
{"project": "qemu", "commit_id": "318347234d7069b62d38391dd27e269a3107d668", "target": 0, "func": "void spapr_core_unplug_request(HotplugHandler *hotplug_dev, DeviceState *dev,\n\n                               Error **errp)\n\n{\n\n    int index;\n\n    sPAPRDRConnector *drc;\n\n    sPAPRDRConnectorClass *drck;\n\n    Error *local_err = NULL;\n\n    CPUCore *cc = CPU_CORE(dev);\n\n    int smt = kvmppc_smt_threads();\n\n\n\n    if (!spapr_find_cpu_slot(MACHINE(hotplug_dev), cc->core_id, &index)) {\n\n        error_setg(errp, \"Unable to find CPU core with core-id: %d\",\n\n                   cc->core_id);\n\n        return;\n\n    }\n\n    if (index == 0) {\n\n        error_setg(errp, \"Boot CPU core may not be unplugged\");\n\n        return;\n\n    }\n\n\n\n    drc = spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_CPU, index * smt);\n\n    g_assert(drc);\n\n\n\n    drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n    drck->detach(drc, dev, spapr_core_release, NULL, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    spapr_hotplug_req_remove_by_index(drc);\n\n}\n", "idx": 7837, "_split": "valid", "_hash": "19a89bbb8d12015f161b40f72197ed27"}
{"project": "qemu", "commit_id": "0fb6395c0cb5046432a80d608ddde7a3b2f8a9ae", "target": 0, "func": "void commit_active_start(BlockDriverState *bs, BlockDriverState *base,\n\n                         int64_t speed,\n\n                         BlockdevOnError on_error,\n\n                         BlockDriverCompletionFunc *cb,\n\n                         void *opaque, Error **errp)\n\n{\n\n    int64_t length, base_length;\n\n    int orig_base_flags;\n\n    int ret;\n\n    Error *local_err = NULL;\n\n\n\n    orig_base_flags = bdrv_get_flags(base);\n\n\n\n    if (bdrv_reopen(base, bs->open_flags, errp)) {\n\n        return;\n\n    }\n\n\n\n    length = bdrv_getlength(bs);\n\n    if (length < 0) {\n\n        error_setg_errno(errp, -length,\n\n                         \"Unable to determine length of %s\", bs->filename);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    base_length = bdrv_getlength(base);\n\n    if (base_length < 0) {\n\n        error_setg_errno(errp, -base_length,\n\n                         \"Unable to determine length of %s\", base->filename);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    if (length > base_length) {\n\n        ret = bdrv_truncate(base, length);\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret,\n\n                            \"Top image %s is larger than base image %s, and \"\n\n                             \"resize of base image failed\",\n\n                             bs->filename, base->filename);\n\n            goto error_restore_flags;\n\n        }\n\n    }\n\n\n\n    bdrv_ref(base);\n\n    mirror_start_job(bs, base, speed, 0, 0,\n\n                     on_error, on_error, cb, opaque, &local_err,\n\n                     &commit_active_job_driver, false, base);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    return;\n\n\n\nerror_restore_flags:\n\n    /* ignore error and errp for bdrv_reopen, because we want to propagate\n\n     * the original error */\n\n    bdrv_reopen(base, orig_base_flags, NULL);\n\n    return;\n\n}\n", "idx": 7858, "_split": "valid", "_hash": "c68c598dc6a9f93acff4d3d4595c963f"}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_up_char(void)\n\n{\n\n    int idx;\n\n\n\n    if (term_hist_entry == 0)\n\n\treturn;\n\n    if (term_hist_entry == -1) {\n\n\t/* Find latest entry */\n\n\tfor (idx = 0; idx < TERM_MAX_CMDS; idx++) {\n\n\t    if (term_history[idx] == NULL)\n\n\t\tbreak;\n\n\t}\n\n\tterm_hist_entry = idx;\n\n    }\n\n    term_hist_entry--;\n\n    if (term_hist_entry >= 0) {\n\n\tpstrcpy(term_cmd_buf, sizeof(term_cmd_buf), \n\n                term_history[term_hist_entry]);\n\n\tterm_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);\n\n    }\n\n}\n", "idx": 7877, "_split": "valid", "_hash": "ea7f10ef26ab75fafdee3a981790aaf9"}
{"project": "qemu", "commit_id": "3849902cd852d7de0783abc41cb0c57949d567fd", "target": 1, "func": "static inline void gen_intermediate_code_internal(CPUState *env,\n                                                  TranslationBlock *tb,\n                                                  int search_pc)\n{\n    DisasContext dc1, *dc = &dc1;\n    CPUBreakpoint *bp;\n    uint16_t *gen_opc_end;\n    int j, lj;\n    target_ulong pc_start;\n    uint32_t next_page_start;\n    int num_insns;\n    int max_insns;\n    /* generate intermediate code */\n    pc_start = tb->pc;\n    dc->tb = tb;\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n    dc->is_jmp = DISAS_NEXT;\n    dc->pc = pc_start;\n    dc->singlestep_enabled = env->singlestep_enabled;\n    dc->condjmp = 0;\n    dc->thumb = ARM_TBFLAG_THUMB(tb->flags);\n    dc->condexec_mask = (ARM_TBFLAG_CONDEXEC(tb->flags) & 0xf) << 1;\n    dc->condexec_cond = ARM_TBFLAG_CONDEXEC(tb->flags) >> 4;\n#if !defined(CONFIG_USER_ONLY)\n    dc->user = (ARM_TBFLAG_PRIV(tb->flags) == 0);\n#endif\n    dc->vfp_enabled = ARM_TBFLAG_VFPEN(tb->flags);\n    dc->vec_len = ARM_TBFLAG_VECLEN(tb->flags);\n    dc->vec_stride = ARM_TBFLAG_VECSTRIDE(tb->flags);\n    cpu_F0s = tcg_temp_new_i32();\n    cpu_F1s = tcg_temp_new_i32();\n    cpu_F0d = tcg_temp_new_i64();\n    cpu_F1d = tcg_temp_new_i64();\n    cpu_V0 = cpu_F0d;\n    cpu_V1 = cpu_F1d;\n    /* FIXME: cpu_M0 can probably be the same as cpu_V0.  */\n    cpu_M0 = tcg_temp_new_i64();\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n    lj = -1;\n    num_insns = 0;\n    max_insns = tb->cflags & CF_COUNT_MASK;\n    if (max_insns == 0)\n        max_insns = CF_COUNT_MASK;\n    gen_icount_start();\n    tcg_clear_temp_count();\n    /* A note on handling of the condexec (IT) bits:\n     *\n     * We want to avoid the overhead of having to write the updated condexec\n     * bits back to the CPUState for every instruction in an IT block. So:\n     * (1) if the condexec bits are not already zero then we write\n     * zero back into the CPUState now. This avoids complications trying\n     * to do it at the end of the block. (For example if we don't do this\n     * it's hard to identify whether we can safely skip writing condexec\n     * at the end of the TB, which we definitely want to do for the case\n     * where a TB doesn't do anything with the IT state at all.)\n     * (2) if we are going to leave the TB then we call gen_set_condexec()\n     * which will write the correct value into CPUState if zero is wrong.\n     * This is done both for leaving the TB at the end, and for leaving\n     * it because of an exception we know will happen, which is done in\n     * gen_exception_insn(). The latter is necessary because we need to\n     * leave the TB with the PC/IT state just prior to execution of the\n     * instruction which caused the exception.\n     * (3) if we leave the TB unexpectedly (eg a data abort on a load)\n     * then the CPUState will be wrong and we need to reset it.\n     * This is handled in the same way as restoration of the\n     * PC in these situations: we will be called again with search_pc=1\n     * and generate a mapping of the condexec bits for each PC in\n     * gen_opc_condexec_bits[]. gen_pc_load[] then uses this to restore\n     * the condexec bits.\n     *\n     * Note that there are no instructions which can read the condexec\n     * bits, and none which can write non-static values to them, so\n     * we don't need to care about whether CPUState is correct in the\n     * middle of a TB.\n     */\n    /* Reset the conditional execution bits immediately. This avoids\n       complications trying to do it at the end of the block.  */\n    if (dc->condexec_mask || dc->condexec_cond)\n      {\n        TCGv tmp = tcg_temp_new_i32();\n        tcg_gen_movi_i32(tmp, 0);\n        store_cpu_field(tmp, condexec_bits);\n    do {\n#ifdef CONFIG_USER_ONLY\n        /* Intercept jump to the magic kernel page.  */\n        if (dc->pc >= 0xffff0000) {\n            /* We always get here via a jump, so know we are not in a\n               conditional execution block.  */\n            gen_exception(EXCP_KERNEL_TRAP);\n            dc->is_jmp = DISAS_UPDATE;\n            break;\n#else\n        if (dc->pc >= 0xfffffff0 && IS_M(env)) {\n            /* We always get here via a jump, so know we are not in a\n               conditional execution block.  */\n            gen_exception(EXCP_EXCEPTION_EXIT);\n            dc->is_jmp = DISAS_UPDATE;\n            break;\n#endif\n        if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {\n            QTAILQ_FOREACH(bp, &env->breakpoints, entry) {\n                if (bp->pc == dc->pc) {\n                    gen_exception_insn(dc, 0, EXCP_DEBUG);\n                    /* Advance PC so that clearing the breakpoint will\n                       invalidate this TB.  */\n                    dc->pc += 2;\n                    goto done_generating;\n                    break;\n        if (search_pc) {\n            j = gen_opc_ptr - gen_opc_buf;\n            if (lj < j) {\n                lj++;\n                while (lj < j)\n                    gen_opc_instr_start[lj++] = 0;\n            gen_opc_pc[lj] = dc->pc;\n            gen_opc_condexec_bits[lj] = (dc->condexec_cond << 4) | (dc->condexec_mask >> 1);\n            gen_opc_instr_start[lj] = 1;\n            gen_opc_icount[lj] = num_insns;\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n            gen_io_start();\n        if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP))) {\n            tcg_gen_debug_insn_start(dc->pc);\n        if (dc->thumb) {\n            disas_thumb_insn(env, dc);\n            if (dc->condexec_mask) {\n                dc->condexec_cond = (dc->condexec_cond & 0xe)\n                                   | ((dc->condexec_mask >> 4) & 1);\n                dc->condexec_mask = (dc->condexec_mask << 1) & 0x1f;\n                if (dc->condexec_mask == 0) {\n                    dc->condexec_cond = 0;\n        } else {\n            disas_arm_insn(env, dc);\n        if (dc->condjmp && !dc->is_jmp) {\n            gen_set_label(dc->condlabel);\n            dc->condjmp = 0;\n        /* Translation stops when a conditional branch is encountered.\n         * Otherwise the subsequent code could get translated several times.\n         * Also stop translation when a page boundary is reached.  This\n         * ensures prefetch aborts occur at the right place.  */\n        num_insns ++;\n    } while (!dc->is_jmp && gen_opc_ptr < gen_opc_end &&\n             !env->singlestep_enabled &&\n             !singlestep &&\n             dc->pc < next_page_start &&\n             num_insns < max_insns);\n    if (tb->cflags & CF_LAST_IO) {\n        if (dc->condjmp) {\n            /* FIXME:  This can theoretically happen with self-modifying\n               code.  */\n            cpu_abort(env, \"IO on conditional branch instruction\");\n        gen_io_end();\n    /* At this stage dc->condjmp will only be set when the skipped\n       instruction was a conditional branch or trap, and the PC has\n       already been written.  */\n    if (unlikely(env->singlestep_enabled)) {\n        /* Make sure the pc is updated, and raise a debug exception.  */\n        if (dc->condjmp) {\n            gen_set_condexec(dc);\n            if (dc->is_jmp == DISAS_SWI) {\n                gen_exception(EXCP_SWI);\n            } else {\n                gen_exception(EXCP_DEBUG);\n            gen_set_label(dc->condlabel);\n        if (dc->condjmp || !dc->is_jmp) {\n            gen_set_pc_im(dc->pc);\n            dc->condjmp = 0;\n        gen_set_condexec(dc);\n        if (dc->is_jmp == DISAS_SWI && !dc->condjmp) {\n            gen_exception(EXCP_SWI);\n        } else {\n            /* FIXME: Single stepping a WFI insn will not halt\n               the CPU.  */\n            gen_exception(EXCP_DEBUG);\n    } else {\n        /* While branches must always occur at the end of an IT block,\n           there are a few other things that can cause us to terminate\n           the TB in the middel of an IT block:\n            - Exception generating instructions (bkpt, swi, undefined).\n            - Page boundaries.\n            - Hardware watchpoints.\n           Hardware breakpoints have already been handled and skip this code.\n         */\n        gen_set_condexec(dc);\n        switch(dc->is_jmp) {\n        case DISAS_NEXT:\n            gen_goto_tb(dc, 1, dc->pc);\n            break;\n        default:\n        case DISAS_JUMP:\n        case DISAS_UPDATE:\n            /* indicate that the hash table must be used to find the next TB */\n            tcg_gen_exit_tb(0);\n            break;\n        case DISAS_TB_JUMP:\n            /* nothing more to generate */\n            break;\n        case DISAS_WFI:\n            gen_helper_wfi();\n            break;\n        case DISAS_SWI:\n            gen_exception(EXCP_SWI);\n            break;\n        if (dc->condjmp) {\n            gen_set_label(dc->condlabel);\n            gen_set_condexec(dc);\n            gen_goto_tb(dc, 1, dc->pc);\n            dc->condjmp = 0;\ndone_generating:\n    gen_icount_end(tb, num_insns);\n    *gen_opc_ptr = INDEX_op_end;\n#ifdef DEBUG_DISAS\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n        qemu_log(\"----------------\\n\");\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n        log_target_disas(pc_start, dc->pc - pc_start, dc->thumb);\n        qemu_log(\"\\n\");\n#endif\n    if (search_pc) {\n        j = gen_opc_ptr - gen_opc_buf;\n        lj++;\n        while (lj <= j)\n            gen_opc_instr_start[lj++] = 0;\n    } else {\n        tb->size = dc->pc - pc_start;\n        tb->icount = num_insns;", "idx": 7903, "_split": "valid", "_hash": "dabbe08f5d92f02c42d87420a83152d8"}
{"project": "qemu", "commit_id": "e6ae5981ea4b0f6feb223009a5108582e7644f8f", "target": 0, "func": "static inline int nvic_exec_prio(NVICState *s)\n\n{\n\n    CPUARMState *env = &s->cpu->env;\n\n    int running;\n\n\n\n    if (env->daif & PSTATE_F) { /* FAULTMASK */\n\n        running = -1;\n\n    } else if (env->daif & PSTATE_I) { /* PRIMASK */\n\n        running = 0;\n\n    } else if (env->v7m.basepri > 0) {\n\n        running = env->v7m.basepri & nvic_gprio_mask(s);\n\n    } else {\n\n        running = NVIC_NOEXC_PRIO; /* lower than any possible priority */\n\n    }\n\n    /* consider priority of active handler */\n\n    return MIN(running, s->exception_prio);\n\n}\n", "idx": 7929, "_split": "valid", "_hash": "d5d546fff705121f0180b8b4ed250daf"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint16(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint16_t *v = pv;\n\n    qemu_get_be16s(f, v);\n\n    return 0;\n\n}\n", "idx": 7949, "_split": "valid", "_hash": "76628164eb1498d1e2024e4c43154872"}
{"project": "qemu", "commit_id": "cd245a19329edfcd968b00d05ad92de7a0e2daa1", "target": 1, "func": "void *qemu_malloc(size_t size)\n\n{\n\n    if (!size && !allow_zero_malloc()) {\n\n        abort();\n\n    }\n\n    return oom_check(malloc(size ? size : 1));\n\n}\n", "idx": 7955, "_split": "valid", "_hash": "89e08616aca7f0f5695a95c87a4c0cf5"}
{"project": "qemu", "commit_id": "185b43386ad999c80bdc58e41b87f05e5b3e8463", "target": 0, "func": "int nbd_receive_negotiate(int csock, const char *name, uint32_t *flags,\n\n                          off_t *size, size_t *blocksize)\n\n{\n\n    char buf[256];\n\n    uint64_t magic, s;\n\n    uint16_t tmp;\n\n\n\n    TRACE(\"Receiving negotiation.\");\n\n\n\n    if (read_sync(csock, buf, 8) != 8) {\n\n        LOG(\"read failed\");\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    buf[8] = '\\0';\n\n    if (strlen(buf) == 0) {\n\n        LOG(\"server connection closed\");\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    TRACE(\"Magic is %c%c%c%c%c%c%c%c\",\n\n          qemu_isprint(buf[0]) ? buf[0] : '.',\n\n          qemu_isprint(buf[1]) ? buf[1] : '.',\n\n          qemu_isprint(buf[2]) ? buf[2] : '.',\n\n          qemu_isprint(buf[3]) ? buf[3] : '.',\n\n          qemu_isprint(buf[4]) ? buf[4] : '.',\n\n          qemu_isprint(buf[5]) ? buf[5] : '.',\n\n          qemu_isprint(buf[6]) ? buf[6] : '.',\n\n          qemu_isprint(buf[7]) ? buf[7] : '.');\n\n\n\n    if (memcmp(buf, \"NBDMAGIC\", 8) != 0) {\n\n        LOG(\"Invalid magic received\");\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    if (read_sync(csock, &magic, sizeof(magic)) != sizeof(magic)) {\n\n        LOG(\"read failed\");\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n    magic = be64_to_cpu(magic);\n\n    TRACE(\"Magic is 0x%\" PRIx64, magic);\n\n\n\n    if (name) {\n\n        uint32_t reserved = 0;\n\n        uint32_t opt;\n\n        uint32_t namesize;\n\n\n\n        TRACE(\"Checking magic (opts_magic)\");\n\n        if (magic != 0x49484156454F5054LL) {\n\n            LOG(\"Bad magic received\");\n\n            errno = EINVAL;\n\n            return -1;\n\n        }\n\n        if (read_sync(csock, &tmp, sizeof(tmp)) != sizeof(tmp)) {\n\n            LOG(\"flags read failed\");\n\n            errno = EINVAL;\n\n            return -1;\n\n        }\n\n        *flags = be16_to_cpu(tmp) << 16;\n\n        /* reserved for future use */\n\n        if (write_sync(csock, &reserved, sizeof(reserved)) !=\n\n            sizeof(reserved)) {\n\n            LOG(\"write failed (reserved)\");\n\n            errno = EINVAL;\n\n            return -1;\n\n        }\n\n        /* write the export name */\n\n        magic = cpu_to_be64(magic);\n\n        if (write_sync(csock, &magic, sizeof(magic)) != sizeof(magic)) {\n\n            LOG(\"write failed (magic)\");\n\n            errno = EINVAL;\n\n            return -1;\n\n        }\n\n        opt = cpu_to_be32(NBD_OPT_EXPORT_NAME);\n\n        if (write_sync(csock, &opt, sizeof(opt)) != sizeof(opt)) {\n\n            LOG(\"write failed (opt)\");\n\n            errno = EINVAL;\n\n            return -1;\n\n        }\n\n        namesize = cpu_to_be32(strlen(name));\n\n        if (write_sync(csock, &namesize, sizeof(namesize)) !=\n\n            sizeof(namesize)) {\n\n            LOG(\"write failed (namesize)\");\n\n            errno = EINVAL;\n\n            return -1;\n\n        }\n\n        if (write_sync(csock, (char*)name, strlen(name)) != strlen(name)) {\n\n            LOG(\"write failed (name)\");\n\n            errno = EINVAL;\n\n            return -1;\n\n        }\n\n    } else {\n\n        TRACE(\"Checking magic (cli_magic)\");\n\n\n\n        if (magic != 0x00420281861253LL) {\n\n            LOG(\"Bad magic received\");\n\n            errno = EINVAL;\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (read_sync(csock, &s, sizeof(s)) != sizeof(s)) {\n\n        LOG(\"read failed\");\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n    *size = be64_to_cpu(s);\n\n    *blocksize = 1024;\n\n    TRACE(\"Size is %\" PRIu64, *size);\n\n\n\n    if (!name) {\n\n        if (read_sync(csock, flags, sizeof(*flags)) != sizeof(*flags)) {\n\n            LOG(\"read failed (flags)\");\n\n            errno = EINVAL;\n\n            return -1;\n\n        }\n\n        *flags = be32_to_cpup(flags);\n\n    } else {\n\n        if (read_sync(csock, &tmp, sizeof(tmp)) != sizeof(tmp)) {\n\n            LOG(\"read failed (tmp)\");\n\n            errno = EINVAL;\n\n            return -1;\n\n        }\n\n        *flags |= be32_to_cpu(tmp);\n\n    }\n\n    if (read_sync(csock, &buf, 124) != 124) {\n\n        LOG(\"read failed (buf)\");\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n        return 0;\n\n}\n", "idx": 7960, "_split": "valid", "_hash": "8f7f87ba6491f23965f5d007ceef6106"}
{"project": "qemu", "commit_id": "8caa05d8891d0a09dc4c00908c24c6ddfd872bbe", "target": 0, "func": "static bool timer_mod_ns_locked(QEMUTimerList *timer_list,\n\n                                QEMUTimer *ts, int64_t expire_time)\n\n{\n\n    QEMUTimer **pt, *t;\n\n\n\n    /* add the timer in the sorted list */\n\n    pt = &timer_list->active_timers;\n\n    for (;;) {\n\n        t = *pt;\n\n        if (!timer_expired_ns(t, expire_time)) {\n\n            break;\n\n        }\n\n        pt = &t->next;\n\n    }\n\n    ts->expire_time = MAX(expire_time, 0);\n\n    ts->next = *pt;\n\n    *pt = ts;\n\n\n\n    return pt == &timer_list->active_timers;\n\n}\n", "idx": 7963, "_split": "valid", "_hash": "f3aaeadfd2f6b6adda0df526bf7a147f"}
{"project": "qemu", "commit_id": "a980f7f2c2f4d7e9a1eba4f804cd66dbd458b6d4", "target": 0, "func": "static void qvirtio_9p_start(void)\n\n{\n\n    char *args;\n\n\n\n    test_share = g_strdup(\"/tmp/qtest.XXXXXX\");\n\n    g_assert_nonnull(mkdtemp(test_share));\n\n\n\n    args = g_strdup_printf(\"-fsdev local,id=fsdev0,security_model=none,path=%s \"\n\n                           \"-device virtio-9p-pci,fsdev=fsdev0,mount_tag=%s\",\n\n                           test_share, mount_tag);\n\n\n\n    qtest_start(args);\n\n    g_free(args);\n\n}\n", "idx": 7969, "_split": "valid", "_hash": "434ed87c44e052212ebf88988c443992"}
{"project": "qemu", "commit_id": "f3a06403b82c7f036564e4caf18b52ce6885fcfb", "target": 1, "func": "static void build_fs_mount_list(FsMountList *mounts, Error **errp)\n\n{\n\n    FsMount *mount;\n\n    char const *mountinfo = \"/proc/self/mountinfo\";\n\n    FILE *fp;\n\n    char *line = NULL, *dash;\n\n    size_t n;\n\n    char check;\n\n    unsigned int devmajor, devminor;\n\n    int ret, dir_s, dir_e, type_s, type_e, dev_s, dev_e;\n\n\n\n    fp = fopen(mountinfo, \"r\");\n\n    if (!fp) {\n\n        build_fs_mount_list_from_mtab(mounts, errp);\n\n        return;\n\n    }\n\n\n\n    while (getline(&line, &n, fp) != -1) {\n\n        ret = sscanf(line, \"%*u %*u %u:%u %*s %n%*s%n%c\",\n\n                     &devmajor, &devminor, &dir_s, &dir_e, &check);\n\n        if (ret < 3) {\n\n            continue;\n\n        }\n\n        dash = strstr(line + dir_e, \" - \");\n\n        if (!dash) {\n\n            continue;\n\n        }\n\n        ret = sscanf(dash, \" - %n%*s%n %n%*s%n%c\",\n\n                     &type_s, &type_e, &dev_s, &dev_e, &check);\n\n        if (ret < 1) {\n\n            continue;\n\n        }\n\n        line[dir_e] = 0;\n\n        dash[type_e] = 0;\n\n        dash[dev_e] = 0;\n\n        decode_mntname(line + dir_s, dir_e - dir_s);\n\n        decode_mntname(dash + dev_s, dev_e - dev_s);\n\n        if (devmajor == 0) {\n\n            /* btrfs reports major number = 0 */\n\n            if (strcmp(\"btrfs\", dash + type_s) != 0 ||\n\n                dev_major_minor(dash + dev_s, &devmajor, &devminor) < 0) {\n\n                continue;\n\n            }\n\n        }\n\n\n\n        mount = g_malloc0(sizeof(FsMount));\n\n        mount->dirname = g_strdup(line + dir_s);\n\n        mount->devtype = g_strdup(dash + type_s);\n\n        mount->devmajor = devmajor;\n\n        mount->devminor = devminor;\n\n\n\n        QTAILQ_INSERT_TAIL(mounts, mount, next);\n\n    }\n\n    free(line);\n\n\n\n    fclose(fp);\n\n}\n", "idx": 7989, "_split": "valid", "_hash": "a21854c8b4d102b60477e768c8caa6b9"}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "float64 int32_to_float64( int32 a STATUS_PARAM )\n\n{\n\n    flag zSign;\n\n    uint32 absA;\n\n    int8 shiftCount;\n\n    bits64 zSig;\n\n\n\n    if ( a == 0 ) return 0;\n\n    zSign = ( a < 0 );\n\n    absA = zSign ? - a : a;\n\n    shiftCount = countLeadingZeros32( absA ) + 21;\n\n    zSig = absA;\n\n    return packFloat64( zSign, 0x432 - shiftCount, zSig<<shiftCount );\n\n\n\n}\n", "idx": 7995, "_split": "valid", "_hash": "6b5d0e2835166b081d2d055f1801a97d"}
{"project": "qemu", "commit_id": "577d0a38070d1d6c4c7fab5c2054380770b1ec6b", "target": 0, "func": "void blkconf_serial(BlockConf *conf, char **serial)\n\n{\n\n    DriveInfo *dinfo;\n\n\n\n    if (!*serial) {\n\n        /* try to fall back to value set with legacy -drive serial=... */\n\n        dinfo = drive_get_by_blockdev(conf->bs);\n\n        if (*dinfo->serial) {\n\n            *serial = g_strdup(dinfo->serial);\n\n        }\n\n    }\n\n}\n", "idx": 7998, "_split": "valid", "_hash": "a3467a48399ae013e916605cbb583fd9"}
{"project": "qemu", "commit_id": "9706e0162d2405218fd7376ffdf13baed8569a4b", "target": 0, "func": "int bitbang_i2c_set(bitbang_i2c_interface *i2c, int line, int level)\n\n{\n\n    int data;\n\n\n\n    if (level != 0 && level != 1) {\n\n        abort();\n\n    }\n\n\n\n    if (line == BITBANG_I2C_SDA) {\n\n        if (level == i2c->last_data) {\n\n            return bitbang_i2c_nop(i2c);\n\n        }\n\n        i2c->last_data = level;\n\n        if (i2c->last_clock == 0) {\n\n            return bitbang_i2c_nop(i2c);\n\n        }\n\n        if (level == 0) {\n\n            DPRINTF(\"START\\n\");\n\n            /* START condition.  */\n\n            i2c->state = SENDING_BIT7;\n\n            i2c->current_addr = -1;\n\n        } else {\n\n            /* STOP condition.  */\n\n            bitbang_i2c_enter_stop(i2c);\n\n        }\n\n        return bitbang_i2c_ret(i2c, 1);\n\n    }\n\n\n\n    data = i2c->last_data;\n\n    if (i2c->last_clock == level) {\n\n        return bitbang_i2c_nop(i2c);\n\n    }\n\n    i2c->last_clock = level;\n\n    if (level == 0) {\n\n        /* State is set/read at the start of the clock pulse.\n\n           release the data line at the end.  */\n\n        return bitbang_i2c_ret(i2c, 1);\n\n    }\n\n    switch (i2c->state) {\n\n    case STOPPED:\n\n    case SENT_NACK:\n\n        return bitbang_i2c_ret(i2c, 1);\n\n\n\n    case SENDING_BIT7 ... SENDING_BIT0:\n\n        i2c->buffer = (i2c->buffer << 1) | data;\n\n        /* will end up in WAITING_FOR_ACK */\n\n        i2c->state++; \n\n        return bitbang_i2c_ret(i2c, 1);\n\n\n\n    case WAITING_FOR_ACK:\n\n        if (i2c->current_addr < 0) {\n\n            i2c->current_addr = i2c->buffer;\n\n            DPRINTF(\"Address 0x%02x\\n\", i2c->current_addr);\n\n            i2c_start_transfer(i2c->bus, i2c->current_addr >> 1,\n\n                               i2c->current_addr & 1);\n\n        } else {\n\n            DPRINTF(\"Sent 0x%02x\\n\", i2c->buffer);\n\n            i2c_send(i2c->bus, i2c->buffer);\n\n        }\n\n        if (i2c->current_addr & 1) {\n\n            i2c->state = RECEIVING_BIT7;\n\n        } else {\n\n            i2c->state = SENDING_BIT7;\n\n        }\n\n        return bitbang_i2c_ret(i2c, 0);\n\n\n\n    case RECEIVING_BIT7:\n\n        i2c->buffer = i2c_recv(i2c->bus);\n\n        DPRINTF(\"RX byte 0x%02x\\n\", i2c->buffer);\n\n        /* Fall through... */\n\n    case RECEIVING_BIT6 ... RECEIVING_BIT0:\n\n        data = i2c->buffer >> 7;\n\n        /* will end up in SENDING_ACK */\n\n        i2c->state++;\n\n        i2c->buffer <<= 1;\n\n        return bitbang_i2c_ret(i2c, data);\n\n\n\n    case SENDING_ACK:\n\n        i2c->state = RECEIVING_BIT7;\n\n        if (data != 0) {\n\n            DPRINTF(\"NACKED\\n\");\n\n            i2c->state = SENT_NACK;\n\n            i2c_nack(i2c->bus);\n\n        } else {\n\n            DPRINTF(\"ACKED\\n\");\n\n        }\n\n        return bitbang_i2c_ret(i2c, 1);\n\n    }\n\n    abort();\n\n}\n", "idx": 8006, "_split": "valid", "_hash": "0d1fd86e33816d5165848c4f5e8664b4"}
{"project": "qemu", "commit_id": "4cae4d5acaea23f3def84c8dc67ef5106323e5cb", "target": 1, "func": "static void peripheral_device_del_completion(ReadLineState *rs,\n\n                                             const char *str, size_t len)\n\n{\n\n    Object *peripheral;\n\n    GSList *list = NULL, *item;\n\n\n\n    peripheral = object_resolve_path(\"/machine/peripheral/\", NULL);\n\n    if (peripheral == NULL) {\n\n        return;\n\n    }\n\n\n\n    object_child_foreach(peripheral, qdev_build_hotpluggable_device_list,\n\n                         &list);\n\n\n\n    for (item = list; item; item = g_slist_next(item)) {\n\n        DeviceState *dev = item->data;\n\n\n\n        if (dev->id && !strncmp(str, dev->id, len)) {\n\n            readline_add_completion(rs, dev->id);\n\n        }\n\n    }\n\n\n\n    g_slist_free(list);\n\n}\n", "idx": 8024, "_split": "valid", "_hash": "3845854389aea176e65794ce1d2b97a8"}
{"project": "qemu", "commit_id": "cfaf6d36ae761da1033159d85d670706ffb24fb9", "target": 0, "func": "static void tcp_accept_incoming_migration(void *opaque)\n\n{\n\n    struct sockaddr_in addr;\n\n    socklen_t addrlen = sizeof(addr);\n\n    int s = (unsigned long)opaque;\n\n    QEMUFile *f;\n\n    int c, ret;\n\n\n\n    do {\n\n        c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);\n\n    } while (c == -1 && socket_error() == EINTR);\n\n\n\n    DPRINTF(\"accepted migration\\n\");\n\n\n\n    if (c == -1) {\n\n        fprintf(stderr, \"could not accept migration connection\\n\");\n\n        return;\n\n    }\n\n\n\n    f = qemu_fopen_socket(c);\n\n    if (f == NULL) {\n\n        fprintf(stderr, \"could not qemu_fopen socket\\n\");\n\n        goto out;\n\n    }\n\n\n\n    ret = qemu_loadvm_state(f);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"load of migration failed\\n\");\n\n        goto out_fopen;\n\n    }\n\n    qemu_announce_self();\n\n    DPRINTF(\"successfully loaded vm state\\n\");\n\n\n\n    /* we've successfully migrated, close the server socket */\n\n    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);\n\n    close(s);\n\n    if (autostart)\n\n        vm_start();\n\n\n\nout_fopen:\n\n    qemu_fclose(f);\n\nout:\n\n    close(c);\n\n}\n", "idx": 8044, "_split": "valid", "_hash": "d841c814f8181a739d4c50475d7cae71"}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_info_network(int argc, const char **argv)\n\n{\n\n    int i, j;\n\n    NetDriverState *nd;\n\n    \n\n    for(i = 0; i < nb_nics; i++) {\n\n        nd = &nd_table[i];\n\n        term_printf(\"%d: ifname=%s macaddr=\", i, nd->ifname);\n\n        for(j = 0; j < 6; j++) {\n\n            if (j > 0)\n\n                term_printf(\":\");\n\n            term_printf(\"%02x\", nd->macaddr[j]);\n\n        }\n\n        term_printf(\"\\n\");\n\n    }\n\n}\n", "idx": 8073, "_split": "valid", "_hash": "048ac88a0290ae49267e030adf36d0a0"}
{"project": "qemu", "commit_id": "482a33c53cbc9d2b0c47d4df03b659bf50258c21", "target": 0, "func": "static int qemu_rdma_registration_handle(QEMUFile *f, void *opaque)\n\n{\n\n    RDMAControlHeader reg_resp = { .len = sizeof(RDMARegisterResult),\n\n                               .type = RDMA_CONTROL_REGISTER_RESULT,\n\n                               .repeat = 0,\n\n                             };\n\n    RDMAControlHeader unreg_resp = { .len = 0,\n\n                               .type = RDMA_CONTROL_UNREGISTER_FINISHED,\n\n                               .repeat = 0,\n\n                             };\n\n    RDMAControlHeader blocks = { .type = RDMA_CONTROL_RAM_BLOCKS_RESULT,\n\n                                 .repeat = 1 };\n\n    QIOChannelRDMA *rioc = QIO_CHANNEL_RDMA(opaque);\n\n    RDMAContext *rdma = rioc->rdma;\n\n    RDMALocalBlocks *local = &rdma->local_ram_blocks;\n\n    RDMAControlHeader head;\n\n    RDMARegister *reg, *registers;\n\n    RDMACompress *comp;\n\n    RDMARegisterResult *reg_result;\n\n    static RDMARegisterResult results[RDMA_CONTROL_MAX_COMMANDS_PER_MESSAGE];\n\n    RDMALocalBlock *block;\n\n    void *host_addr;\n\n    int ret = 0;\n\n    int idx = 0;\n\n    int count = 0;\n\n    int i = 0;\n\n\n\n    CHECK_ERROR_STATE();\n\n\n\n    do {\n\n        trace_qemu_rdma_registration_handle_wait();\n\n\n\n        ret = qemu_rdma_exchange_recv(rdma, &head, RDMA_CONTROL_NONE);\n\n\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n\n\n        if (head.repeat > RDMA_CONTROL_MAX_COMMANDS_PER_MESSAGE) {\n\n            error_report(\"rdma: Too many requests in this message (%d).\"\n\n                            \"Bailing.\", head.repeat);\n\n            ret = -EIO;\n\n            break;\n\n        }\n\n\n\n        switch (head.type) {\n\n        case RDMA_CONTROL_COMPRESS:\n\n            comp = (RDMACompress *) rdma->wr_data[idx].control_curr;\n\n            network_to_compress(comp);\n\n\n\n            trace_qemu_rdma_registration_handle_compress(comp->length,\n\n                                                         comp->block_idx,\n\n                                                         comp->offset);\n\n            if (comp->block_idx >= rdma->local_ram_blocks.nb_blocks) {\n\n                error_report(\"rdma: 'compress' bad block index %u (vs %d)\",\n\n                             (unsigned int)comp->block_idx,\n\n                             rdma->local_ram_blocks.nb_blocks);\n\n                ret = -EIO;\n\n                goto out;\n\n            }\n\n            block = &(rdma->local_ram_blocks.block[comp->block_idx]);\n\n\n\n            host_addr = block->local_host_addr +\n\n                            (comp->offset - block->offset);\n\n\n\n            ram_handle_compressed(host_addr, comp->value, comp->length);\n\n            break;\n\n\n\n        case RDMA_CONTROL_REGISTER_FINISHED:\n\n            trace_qemu_rdma_registration_handle_finished();\n\n            goto out;\n\n\n\n        case RDMA_CONTROL_RAM_BLOCKS_REQUEST:\n\n            trace_qemu_rdma_registration_handle_ram_blocks();\n\n\n\n            /* Sort our local RAM Block list so it's the same as the source,\n\n             * we can do this since we've filled in a src_index in the list\n\n             * as we received the RAMBlock list earlier.\n\n             */\n\n            qsort(rdma->local_ram_blocks.block,\n\n                  rdma->local_ram_blocks.nb_blocks,\n\n                  sizeof(RDMALocalBlock), dest_ram_sort_func);\n\n            if (rdma->pin_all) {\n\n                ret = qemu_rdma_reg_whole_ram_blocks(rdma);\n\n                if (ret) {\n\n                    error_report(\"rdma migration: error dest \"\n\n                                    \"registering ram blocks\");\n\n                    goto out;\n\n                }\n\n            }\n\n\n\n            /*\n\n             * Dest uses this to prepare to transmit the RAMBlock descriptions\n\n             * to the source VM after connection setup.\n\n             * Both sides use the \"remote\" structure to communicate and update\n\n             * their \"local\" descriptions with what was sent.\n\n             */\n\n            for (i = 0; i < local->nb_blocks; i++) {\n\n                rdma->dest_blocks[i].remote_host_addr =\n\n                    (uintptr_t)(local->block[i].local_host_addr);\n\n\n\n                if (rdma->pin_all) {\n\n                    rdma->dest_blocks[i].remote_rkey = local->block[i].mr->rkey;\n\n                }\n\n\n\n                rdma->dest_blocks[i].offset = local->block[i].offset;\n\n                rdma->dest_blocks[i].length = local->block[i].length;\n\n\n\n                dest_block_to_network(&rdma->dest_blocks[i]);\n\n                trace_qemu_rdma_registration_handle_ram_blocks_loop(\n\n                    local->block[i].block_name,\n\n                    local->block[i].offset,\n\n                    local->block[i].length,\n\n                    local->block[i].local_host_addr,\n\n                    local->block[i].src_index);\n\n            }\n\n\n\n            blocks.len = rdma->local_ram_blocks.nb_blocks\n\n                                                * sizeof(RDMADestBlock);\n\n\n\n\n\n            ret = qemu_rdma_post_send_control(rdma,\n\n                                        (uint8_t *) rdma->dest_blocks, &blocks);\n\n\n\n            if (ret < 0) {\n\n                error_report(\"rdma migration: error sending remote info\");\n\n                goto out;\n\n            }\n\n\n\n            break;\n\n        case RDMA_CONTROL_REGISTER_REQUEST:\n\n            trace_qemu_rdma_registration_handle_register(head.repeat);\n\n\n\n            reg_resp.repeat = head.repeat;\n\n            registers = (RDMARegister *) rdma->wr_data[idx].control_curr;\n\n\n\n            for (count = 0; count < head.repeat; count++) {\n\n                uint64_t chunk;\n\n                uint8_t *chunk_start, *chunk_end;\n\n\n\n                reg = &registers[count];\n\n                network_to_register(reg);\n\n\n\n                reg_result = &results[count];\n\n\n\n                trace_qemu_rdma_registration_handle_register_loop(count,\n\n                         reg->current_index, reg->key.current_addr, reg->chunks);\n\n\n\n                if (reg->current_index >= rdma->local_ram_blocks.nb_blocks) {\n\n                    error_report(\"rdma: 'register' bad block index %u (vs %d)\",\n\n                                 (unsigned int)reg->current_index,\n\n                                 rdma->local_ram_blocks.nb_blocks);\n\n                    ret = -ENOENT;\n\n                    goto out;\n\n                }\n\n                block = &(rdma->local_ram_blocks.block[reg->current_index]);\n\n                if (block->is_ram_block) {\n\n                    if (block->offset > reg->key.current_addr) {\n\n                        error_report(\"rdma: bad register address for block %s\"\n\n                            \" offset: %\" PRIx64 \" current_addr: %\" PRIx64,\n\n                            block->block_name, block->offset,\n\n                            reg->key.current_addr);\n\n                        ret = -ERANGE;\n\n                        goto out;\n\n                    }\n\n                    host_addr = (block->local_host_addr +\n\n                                (reg->key.current_addr - block->offset));\n\n                    chunk = ram_chunk_index(block->local_host_addr,\n\n                                            (uint8_t *) host_addr);\n\n                } else {\n\n                    chunk = reg->key.chunk;\n\n                    host_addr = block->local_host_addr +\n\n                        (reg->key.chunk * (1UL << RDMA_REG_CHUNK_SHIFT));\n\n                    /* Check for particularly bad chunk value */\n\n                    if (host_addr < (void *)block->local_host_addr) {\n\n                        error_report(\"rdma: bad chunk for block %s\"\n\n                            \" chunk: %\" PRIx64,\n\n                            block->block_name, reg->key.chunk);\n\n                        ret = -ERANGE;\n\n                        goto out;\n\n                    }\n\n                }\n\n                chunk_start = ram_chunk_start(block, chunk);\n\n                chunk_end = ram_chunk_end(block, chunk + reg->chunks);\n\n                if (qemu_rdma_register_and_get_keys(rdma, block,\n\n                            (uintptr_t)host_addr, NULL, &reg_result->rkey,\n\n                            chunk, chunk_start, chunk_end)) {\n\n                    error_report(\"cannot get rkey\");\n\n                    ret = -EINVAL;\n\n                    goto out;\n\n                }\n\n\n\n                reg_result->host_addr = (uintptr_t)block->local_host_addr;\n\n\n\n                trace_qemu_rdma_registration_handle_register_rkey(\n\n                                                           reg_result->rkey);\n\n\n\n                result_to_network(reg_result);\n\n            }\n\n\n\n            ret = qemu_rdma_post_send_control(rdma,\n\n                            (uint8_t *) results, &reg_resp);\n\n\n\n            if (ret < 0) {\n\n                error_report(\"Failed to send control buffer\");\n\n                goto out;\n\n            }\n\n            break;\n\n        case RDMA_CONTROL_UNREGISTER_REQUEST:\n\n            trace_qemu_rdma_registration_handle_unregister(head.repeat);\n\n            unreg_resp.repeat = head.repeat;\n\n            registers = (RDMARegister *) rdma->wr_data[idx].control_curr;\n\n\n\n            for (count = 0; count < head.repeat; count++) {\n\n                reg = &registers[count];\n\n                network_to_register(reg);\n\n\n\n                trace_qemu_rdma_registration_handle_unregister_loop(count,\n\n                           reg->current_index, reg->key.chunk);\n\n\n\n                block = &(rdma->local_ram_blocks.block[reg->current_index]);\n\n\n\n                ret = ibv_dereg_mr(block->pmr[reg->key.chunk]);\n\n                block->pmr[reg->key.chunk] = NULL;\n\n\n\n                if (ret != 0) {\n\n                    perror(\"rdma unregistration chunk failed\");\n\n                    ret = -ret;\n\n                    goto out;\n\n                }\n\n\n\n                rdma->total_registrations--;\n\n\n\n                trace_qemu_rdma_registration_handle_unregister_success(\n\n                                                       reg->key.chunk);\n\n            }\n\n\n\n            ret = qemu_rdma_post_send_control(rdma, NULL, &unreg_resp);\n\n\n\n            if (ret < 0) {\n\n                error_report(\"Failed to send control buffer\");\n\n                goto out;\n\n            }\n\n            break;\n\n        case RDMA_CONTROL_REGISTER_RESULT:\n\n            error_report(\"Invalid RESULT message at dest.\");\n\n            ret = -EIO;\n\n            goto out;\n\n        default:\n\n            error_report(\"Unknown control message %s\", control_desc[head.type]);\n\n            ret = -EIO;\n\n            goto out;\n\n        }\n\n    } while (1);\n\nout:\n\n    if (ret < 0) {\n\n        rdma->error_state = ret;\n\n    }\n\n    return ret;\n\n}\n", "idx": 8078, "_split": "valid", "_hash": "0c649bbcc4333ed9ef27f8244ba42528"}
{"project": "qemu", "commit_id": "86a6a9bf551ffa183880480b37c5836d3916687a", "target": 0, "func": "void xen_invalidate_map_cache(void)\n\n{\n\n    unsigned long i;\n\n    MapCacheRev *reventry;\n\n\n\n    /* Flush pending AIO before destroying the mapcache */\n\n    bdrv_drain_all();\n\n\n\n    QTAILQ_FOREACH(reventry, &mapcache->locked_entries, next) {\n\n        DPRINTF(\"There should be no locked mappings at this time, \"\n\n                \"but \"TARGET_FMT_plx\" -> %p is present\\n\",\n\n                reventry->paddr_index, reventry->vaddr_req);\n\n    }\n\n\n\n    mapcache_lock();\n\n\n\n    for (i = 0; i < mapcache->nr_buckets; i++) {\n\n        MapCacheEntry *entry = &mapcache->entry[i];\n\n\n\n        if (entry->vaddr_base == NULL) {\n\n            continue;\n\n        }\n\n        if (entry->lock > 0) {\n\n            continue;\n\n        }\n\n\n\n        if (munmap(entry->vaddr_base, entry->size) != 0) {\n\n            perror(\"unmap fails\");\n\n            exit(-1);\n\n        }\n\n\n\n        entry->paddr_index = 0;\n\n        entry->vaddr_base = NULL;\n\n        entry->size = 0;\n\n        g_free(entry->valid_mapping);\n\n        entry->valid_mapping = NULL;\n\n    }\n\n\n\n    mapcache->last_entry = NULL;\n\n\n\n    mapcache_unlock();\n\n}\n", "idx": 8081, "_split": "valid", "_hash": "b84968c2a50c0af394d65af94d9820c0"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_clkdsp_read(void *opaque, target_phys_addr_t addr,\n\n                                 unsigned size)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque;\n\n\n\n    if (size != 2) {\n\n        return omap_badwidth_read16(opaque, addr);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x04:\t/* DSP_IDLECT1 */\n\n        return s->clkm.dsp_idlect1;\n\n\n\n    case 0x08:\t/* DSP_IDLECT2 */\n\n        return s->clkm.dsp_idlect2;\n\n\n\n    case 0x14:\t/* DSP_RSTCT2 */\n\n        return s->clkm.dsp_rstct2;\n\n\n\n    case 0x18:\t/* DSP_SYSST */\n\n        return (s->clkm.clocking_scheme << 11) | s->clkm.cold_start |\n\n                (s->cpu->env.halted << 6);      /* Quite useless... */\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 8086, "_split": "valid", "_hash": "d7f81540c08ee9ee194c028b633e85a3"}
{"project": "qemu", "commit_id": "aab2293687ee54a409f3fb53a1ab3595b595e0fb", "target": 1, "func": "static int fd_close(MigrationState *s)\n\n{\n\n    DPRINTF(\"fd_close\\n\");\n\n    if (s->fd != -1) {\n\n        close(s->fd);\n\n        s->fd = -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 8088, "_split": "valid", "_hash": "4eaec943a3da4bba47e66046af58c549"}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "struct USBEndpoint *usb_ep_get(USBDevice *dev, int pid, int ep)\n\n{\n\n    struct USBEndpoint *eps = pid == USB_TOKEN_IN ? dev->ep_in : dev->ep_out;\n\n    if (ep == 0) {\n\n        return &dev->ep_ctl;\n\n    }\n\n    assert(pid == USB_TOKEN_IN || pid == USB_TOKEN_OUT);\n\n    assert(ep > 0 && ep <= USB_MAX_ENDPOINTS);\n\n    return eps + ep - 1;\n\n}\n", "idx": 8149, "_split": "valid", "_hash": "5862f33ba8f29eb4634395291c2b0eeb"}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static void pointer_event(VncState *vs, int button_mask, int x, int y)\n\n{\n\n    static uint32_t bmap[INPUT_BUTTON_MAX] = {\n\n        [INPUT_BUTTON_LEFT]       = 0x01,\n\n        [INPUT_BUTTON_MIDDLE]     = 0x02,\n\n        [INPUT_BUTTON_RIGHT]      = 0x04,\n\n        [INPUT_BUTTON_WHEEL_UP]   = 0x08,\n\n        [INPUT_BUTTON_WHEEL_DOWN] = 0x10,\n\n    };\n\n    QemuConsole *con = vs->vd->dcl.con;\n\n    int width = surface_width(vs->vd->ds);\n\n    int height = surface_height(vs->vd->ds);\n\n\n\n    if (vs->last_bmask != button_mask) {\n\n        qemu_input_update_buttons(con, bmap, vs->last_bmask, button_mask);\n\n        vs->last_bmask = button_mask;\n\n    }\n\n\n\n    if (vs->absolute) {\n\n        qemu_input_queue_abs(con, INPUT_AXIS_X, x, width);\n\n        qemu_input_queue_abs(con, INPUT_AXIS_Y, y, height);\n\n    } else if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE)) {\n\n        qemu_input_queue_rel(con, INPUT_AXIS_X, x - 0x7FFF);\n\n        qemu_input_queue_rel(con, INPUT_AXIS_Y, y - 0x7FFF);\n\n    } else {\n\n        if (vs->last_x != -1) {\n\n            qemu_input_queue_rel(con, INPUT_AXIS_X, x - vs->last_x);\n\n            qemu_input_queue_rel(con, INPUT_AXIS_Y, y - vs->last_y);\n\n        }\n\n        vs->last_x = x;\n\n        vs->last_y = y;\n\n    }\n\n    qemu_input_event_sync();\n\n}\n", "idx": 8173, "_split": "valid", "_hash": "7c751606cc06e03b178fb2a2b1cbe409"}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_uint16(Visitor *v, uint16_t *obj, const char *name, Error **errp)\n\n{\n\n    int64_t value;\n\n    if (!error_is_set(errp)) {\n\n        if (v->type_uint16) {\n\n            v->type_uint16(v, obj, name, errp);\n\n        } else {\n\n            value = *obj;\n\n            v->type_int(v, &value, name, errp);\n\n            if (value < 0 || value > UINT16_MAX) {\n\n                error_set(errp, QERR_INVALID_PARAMETER_VALUE, name ? name : \"null\",\n\n                          \"uint16_t\");\n\n                return;\n\n            }\n\n            *obj = value;\n\n        }\n\n    }\n\n}\n", "idx": 8177, "_split": "valid", "_hash": "90868f7038c5377a72396b5b5ca12690"}
{"project": "qemu", "commit_id": "bd83b3620517ef9f2079cfda465953e60263f623", "target": 1, "func": "void qemu_iovec_destroy(QEMUIOVector *qiov)\n\n{\n\n    assert(qiov->nalloc != -1);\n\n\n\n\n    g_free(qiov->iov);\n\n\n\n}", "idx": 8226, "_split": "valid", "_hash": "a8844444f377a4d62944ae6b13978f28"}
{"project": "qemu", "commit_id": "b0f2027cde31c645524256763672e09eeb204a9a", "target": 1, "func": "bool virtio_blk_data_plane_create(VirtIODevice *vdev, VirtIOBlkConf *blk,\n                                  VirtIOBlockDataPlane **dataplane)\n{\n    VirtIOBlockDataPlane *s;\n    int fd;\n    *dataplane = NULL;\n    if (!blk->data_plane) {\n        return true;\n    if (blk->scsi) {\n        error_report(\"device is incompatible with x-data-plane, use scsi=off\");\n    if (blk->config_wce) {\n        error_report(\"device is incompatible with x-data-plane, \"\n                     \"use config-wce=off\");\n    fd = raw_get_aio_fd(blk->conf.bs);\n    if (fd < 0) {\n        error_report(\"drive is incompatible with x-data-plane, \"\n                     \"use format=raw,cache=none,aio=native\");\n    s = g_new0(VirtIOBlockDataPlane, 1);\n    s->vdev = vdev;\n    s->fd = fd;\n    s->blk = blk;\n    /* Prevent block operations that conflict with data plane thread */\n    bdrv_set_in_use(blk->conf.bs, 1);\n    *dataplane = s;\n    return true;", "idx": 8233, "_split": "valid", "_hash": "5547af81b3f9bf5f096005411aad2423"}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void helper_sysexit(int dflag)\n\n{\n\n    int cpl;\n\n\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    if (env->sysenter_cs == 0 || cpl != 0) {\n\n        raise_exception_err(EXCP0D_GPF, 0);\n\n    }\n\n    cpu_x86_set_cpl(env, 3);\n\n#ifdef TARGET_X86_64\n\n    if (dflag == 2) {\n\n        cpu_x86_load_seg_cache(env, R_CS, ((env->sysenter_cs + 32) & 0xfffc) | 3,\n\n                               0, 0xffffffff,\n\n                               DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                               DESC_S_MASK | (3 << DESC_DPL_SHIFT) |\n\n                               DESC_CS_MASK | DESC_R_MASK | DESC_A_MASK | DESC_L_MASK);\n\n        cpu_x86_load_seg_cache(env, R_SS, ((env->sysenter_cs + 40) & 0xfffc) | 3,\n\n                               0, 0xffffffff,\n\n                               DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                               DESC_S_MASK | (3 << DESC_DPL_SHIFT) |\n\n                               DESC_W_MASK | DESC_A_MASK);\n\n    } else\n\n#endif\n\n    {\n\n        cpu_x86_load_seg_cache(env, R_CS, ((env->sysenter_cs + 16) & 0xfffc) | 3,\n\n                               0, 0xffffffff,\n\n                               DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                               DESC_S_MASK | (3 << DESC_DPL_SHIFT) |\n\n                               DESC_CS_MASK | DESC_R_MASK | DESC_A_MASK);\n\n        cpu_x86_load_seg_cache(env, R_SS, ((env->sysenter_cs + 24) & 0xfffc) | 3,\n\n                               0, 0xffffffff,\n\n                               DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                               DESC_S_MASK | (3 << DESC_DPL_SHIFT) |\n\n                               DESC_W_MASK | DESC_A_MASK);\n\n    }\n\n    ESP = ECX;\n\n    EIP = EDX;\n\n#ifdef CONFIG_KQEMU\n\n    if (kqemu_is_ok(env)) {\n\n        env->exception_index = -1;\n\n        cpu_loop_exit();\n\n    }\n\n#endif\n\n}\n", "idx": 8249, "_split": "valid", "_hash": "3a33ce32dddbea6770bf80340ae02a9b"}
{"project": "qemu", "commit_id": "7c560456707bfe53eb1728fcde759be7d9418b62", "target": 0, "func": "static void ecc_mem_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    printf(\"ECC: Unsupported write 0x\" TARGET_FMT_plx \" %02x\\n\",\n\n           addr, val & 0xff);\n\n}\n", "idx": 8250, "_split": "valid", "_hash": "6dd975bbf43dcf77d0a010f13e7fbb7c"}
{"project": "qemu", "commit_id": "f8c35c1d59c9fecf79f6d5a02cd09f472a6f411d", "target": 0, "func": "static int bdrv_write_em(BlockDriverState *bs, int64_t sector_num,\n\n                         const uint8_t *buf, int nb_sectors)\n\n{\n\n    int async_ret;\n\n    BlockDriverAIOCB *acb;\n\n    struct iovec iov;\n\n    QEMUIOVector qiov;\n\n\n\n    async_ret = NOT_DONE;\n\n    iov.iov_base = (void *)buf;\n\n    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n    acb = bs->drv->bdrv_aio_writev(bs, sector_num, &qiov, nb_sectors,\n\n                                   bdrv_rw_em_cb, &async_ret);\n\n    if (acb == NULL) {\n\n        async_ret = -1;\n\n        goto fail;\n\n    }\n\n    while (async_ret == NOT_DONE) {\n\n        qemu_aio_wait();\n\n    }\n\n\n\nfail:\n\n    return async_ret;\n\n}\n", "idx": 8255, "_split": "valid", "_hash": "b0121b0073a384b83a7d6d5aad503f76"}
{"project": "qemu", "commit_id": "0cd09c3a6cc2230ba38c462fc410b4acce59eb6f", "target": 0, "func": "static uint32_t virtio_9p_get_features(VirtIODevice *vdev, uint32_t features)\n\n{\n\n    features |= 1 << VIRTIO_9P_MOUNT_TAG;\n\n    return features;\n\n}\n", "idx": 8262, "_split": "valid", "_hash": "5b91f674cda3099562e9d7638b4e4312"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t error_mem_read(void *opaque, target_phys_addr_t addr,\n\n                               unsigned size)\n\n{\n\n    abort();\n\n}\n", "idx": 8284, "_split": "valid", "_hash": "e1a682e6419afe9cab34f23269bc4921"}
{"project": "qemu", "commit_id": "9f1d4b1d6939d39fe570d886f6a651f4764bcbcb", "target": 0, "func": "static void openpic_set_irq(void *opaque, int n_IRQ, int level)\n\n{\n\n    OpenPICState *opp = opaque;\n\n    IRQSource *src;\n\n\n\n    if (n_IRQ >= MAX_IRQ) {\n\n        fprintf(stderr, \"%s: IRQ %d out of range\\n\", __func__, n_IRQ);\n\n        abort();\n\n    }\n\n\n\n    src = &opp->src[n_IRQ];\n\n    DPRINTF(\"openpic: set irq %d = %d ivpr=0x%08x\\n\",\n\n            n_IRQ, level, src->ivpr);\n\n    if (src->level) {\n\n        /* level-sensitive irq */\n\n        src->pending = level;\n\n        if (!level) {\n\n            src->ivpr &= ~IVPR_ACTIVITY_MASK;\n\n        }\n\n    } else {\n\n        /* edge-sensitive irq */\n\n        if (level) {\n\n            src->pending = 1;\n\n        }\n\n    }\n\n    openpic_update_irq(opp, n_IRQ);\n\n}\n", "idx": 8297, "_split": "valid", "_hash": "ab3ab27fa28d6ad9e2aa4bbb7baa6403"}
{"project": "qemu", "commit_id": "9f14b0add1dcdbfa2ee61051d068211fb0a1fcc9", "target": 0, "func": "static void rng_egd_finalize(Object *obj)\n\n{\n\n    RngEgd *s = RNG_EGD(obj);\n\n\n\n    if (s->chr) {\n\n        qemu_chr_add_handlers(s->chr, NULL, NULL, NULL, NULL);\n\n        qemu_chr_fe_release(s->chr);\n\n    }\n\n\n\n    g_free(s->chr_name);\n\n\n\n    rng_egd_free_requests(s);\n\n}\n", "idx": 8374, "_split": "valid", "_hash": "8af7296406e59f196f7ee6098a8e23d0"}
{"project": "qemu", "commit_id": "f278d4947fff814dcde2ef2acad36d172ff8be35", "target": 1, "func": "int pic_read_irq(DeviceState *d)\n\n{\n\n    PICCommonState *s = DO_UPCAST(PICCommonState, dev.qdev, d);\n\n    int irq, irq2, intno;\n\n\n\n    irq = pic_get_irq(s);\n\n    if (irq >= 0) {\n\n        if (irq == 2) {\n\n            irq2 = pic_get_irq(slave_pic);\n\n            if (irq2 >= 0) {\n\n                pic_intack(slave_pic, irq2);\n\n            } else {\n\n                /* spurious IRQ on slave controller */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                irq2 = 7;\n\n\n            intno = slave_pic->irq_base + irq2;\n\n        } else {\n\n            intno = s->irq_base + irq;\n\n\n        pic_intack(s, irq);\n\n    } else {\n\n        /* spurious IRQ on host controller */\n\n\n\n\n        irq = 7;\n\n        intno = s->irq_base + irq;\n\n\n\n\n#if defined(DEBUG_PIC) || defined(DEBUG_IRQ_LATENCY)\n\n    if (irq == 2) {\n\n        irq = irq2 + 8;\n\n\n#endif\n\n#ifdef DEBUG_IRQ_LATENCY\n\n    printf(\"IRQ%d latency=%0.3fus\\n\",\n\n           irq,\n\n           (double)(qemu_get_clock_ns(vm_clock) -\n\n                    irq_time[irq]) * 1000000.0 / get_ticks_per_sec());\n\n#endif\n\n    DPRINTF(\"pic_interrupt: irq=%d\\n\", irq);\n\n    return intno;\n", "idx": 8440, "_split": "valid", "_hash": "0169b908c245dbc216b6d603e1aaa1ac"}
{"project": "qemu", "commit_id": "b021d1c04452276f4926eed2d104ccbd1037a6e1", "target": 1, "func": "void memory_region_notify_one(IOMMUNotifier *notifier,\n\n                              IOMMUTLBEntry *entry)\n\n{\n\n    IOMMUNotifierFlag request_flags;\n\n\n\n    /*\n\n     * Skip the notification if the notification does not overlap\n\n     * with registered range.\n\n     */\n\n    if (notifier->start > entry->iova + entry->addr_mask + 1 ||\n\n        notifier->end < entry->iova) {\n\n        return;\n\n    }\n\n\n\n    if (entry->perm & IOMMU_RW) {\n\n        request_flags = IOMMU_NOTIFIER_MAP;\n\n    } else {\n\n        request_flags = IOMMU_NOTIFIER_UNMAP;\n\n    }\n\n\n\n    if (notifier->notifier_flags & request_flags) {\n\n        notifier->notify(notifier, entry);\n\n    }\n\n}\n", "idx": 8449, "_split": "valid", "_hash": "fa63239344cb9ce1962556e029f598e0"}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void udp_chr_close(CharDriverState *chr)\n\n{\n\n    NetCharDriver *s = chr->opaque;\n\n    if (s->tag) {\n\n        g_source_remove(s->tag);\n\n        s->tag = 0;\n\n    }\n\n    if (s->chan) {\n\n        g_io_channel_unref(s->chan);\n\n        closesocket(s->fd);\n\n    }\n\n    g_free(s);\n\n    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);\n\n}\n", "idx": 8451, "_split": "valid", "_hash": "e4213b7e69c1c8d65be52d4a26295c42"}
{"project": "qemu", "commit_id": "24355b79bdaf6ab12f7c610b032fc35ec045cd55", "target": 1, "func": "static void scsi_write_same_complete(void *opaque, int ret)\n\n{\n\n    WriteSameCBData *data = opaque;\n\n    SCSIDiskReq *r = data->r;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n\n\n    assert(r->req.aiocb != NULL);\n\n    r->req.aiocb = NULL;\n\n    aio_context_acquire(blk_get_aio_context(s->qdev.conf.blk));\n\n    if (scsi_disk_req_check_error(r, ret, true)) {\n\n        goto done;\n\n    }\n\n\n\n    block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);\n\n\n\n    data->nb_sectors -= data->iov.iov_len / 512;\n\n    data->sector += data->iov.iov_len / 512;\n\n    data->iov.iov_len = MIN(data->nb_sectors * 512, data->iov.iov_len);\n\n    if (data->iov.iov_len) {\n\n        block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,\n\n                         data->iov.iov_len, BLOCK_ACCT_WRITE);\n\n        /* Reinitialize qiov, to handle unaligned WRITE SAME request\n\n         * where final qiov may need smaller size */\n\n        qemu_iovec_init_external(&data->qiov, &data->iov, 1);\n\n        r->req.aiocb = blk_aio_pwritev(s->qdev.conf.blk,\n\n                                       data->sector << BDRV_SECTOR_BITS,\n\n                                       &data->qiov, 0,\n\n                                       scsi_write_same_complete, data);\n\n\n        return;\n\n    }\n\n\n\n    scsi_req_complete(&r->req, GOOD);\n\n\n\ndone:\n\n    scsi_req_unref(&r->req);\n\n    qemu_vfree(data->iov.iov_base);\n\n    g_free(data);\n\n\n}", "idx": 8469, "_split": "valid", "_hash": "47592595ea53ec27db8322f0ab19ea16"}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "PXA2xxState *pxa255_init(MemoryRegion *address_space, unsigned int sdram_size)\n\n{\n\n    PXA2xxState *s;\n\n    int i;\n\n    DriveInfo *dinfo;\n\n\n\n    s = (PXA2xxState *) g_malloc0(sizeof(PXA2xxState));\n\n\n\n    s->cpu = cpu_arm_init(\"pxa255\");\n\n    if (s->cpu == NULL) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    s->reset = qemu_allocate_irq(pxa2xx_reset, s, 0);\n\n\n\n    /* SDRAM & Internal Memory Storage */\n\n    memory_region_init_ram(&s->sdram, NULL, \"pxa255.sdram\", sdram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->sdram);\n\n    memory_region_add_subregion(address_space, PXA2XX_SDRAM_BASE, &s->sdram);\n\n    memory_region_init_ram(&s->internal, NULL, \"pxa255.internal\",\n\n                           PXA2XX_INTERNAL_SIZE, &error_abort);\n\n    vmstate_register_ram_global(&s->internal);\n\n    memory_region_add_subregion(address_space, PXA2XX_INTERNAL_BASE,\n\n                                &s->internal);\n\n\n\n    s->pic = pxa2xx_pic_init(0x40d00000, s->cpu);\n\n\n\n    s->dma = pxa255_dma_init(0x40000000,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_DMA));\n\n\n\n    sysbus_create_varargs(\"pxa25x-timer\", 0x40a00000,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_OST_0 + 0),\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_OST_0 + 1),\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_OST_0 + 2),\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_OST_0 + 3),\n\n                    NULL);\n\n\n\n    s->gpio = pxa2xx_gpio_init(0x40e00000, s->cpu, s->pic, 85);\n\n\n\n    dinfo = drive_get(IF_SD, 0, 0);\n\n    if (!dinfo) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n\n        exit(1);\n\n    }\n\n    s->mmc = pxa2xx_mmci_init(address_space, 0x41100000,\n\n                    blk_by_legacy_dinfo(dinfo),\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_MMC),\n\n                    qdev_get_gpio_in(s->dma, PXA2XX_RX_RQ_MMCI),\n\n                    qdev_get_gpio_in(s->dma, PXA2XX_TX_RQ_MMCI));\n\n\n\n    for (i = 0; pxa255_serial[i].io_base; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_mm_init(address_space, pxa255_serial[i].io_base, 2,\n\n                           qdev_get_gpio_in(s->pic, pxa255_serial[i].irqn),\n\n                           14745600 / 16, serial_hds[i],\n\n                           DEVICE_NATIVE_ENDIAN);\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n    if (serial_hds[i])\n\n        s->fir = pxa2xx_fir_init(address_space, 0x40800000,\n\n                        qdev_get_gpio_in(s->pic, PXA2XX_PIC_ICP),\n\n                        qdev_get_gpio_in(s->dma, PXA2XX_RX_RQ_ICP),\n\n                        qdev_get_gpio_in(s->dma, PXA2XX_TX_RQ_ICP),\n\n                        serial_hds[i]);\n\n\n\n    s->lcd = pxa2xx_lcdc_init(address_space, 0x44000000,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_LCD));\n\n\n\n    s->cm_base = 0x41300000;\n\n    s->cm_regs[CCCR >> 2] = 0x02000210;\t/* 416.0 MHz */\n\n    s->clkcfg = 0x00000009;\t\t/* Turbo mode active */\n\n    memory_region_init_io(&s->cm_iomem, NULL, &pxa2xx_cm_ops, s, \"pxa2xx-cm\", 0x1000);\n\n    memory_region_add_subregion(address_space, s->cm_base, &s->cm_iomem);\n\n    vmstate_register(NULL, 0, &vmstate_pxa2xx_cm, s);\n\n\n\n    pxa2xx_setup_cp14(s);\n\n\n\n    s->mm_base = 0x48000000;\n\n    s->mm_regs[MDMRS >> 2] = 0x00020002;\n\n    s->mm_regs[MDREFR >> 2] = 0x03ca4000;\n\n    s->mm_regs[MECR >> 2] = 0x00000001;\t/* Two PC Card sockets */\n\n    memory_region_init_io(&s->mm_iomem, NULL, &pxa2xx_mm_ops, s, \"pxa2xx-mm\", 0x1000);\n\n    memory_region_add_subregion(address_space, s->mm_base, &s->mm_iomem);\n\n    vmstate_register(NULL, 0, &vmstate_pxa2xx_mm, s);\n\n\n\n    s->pm_base = 0x40f00000;\n\n    memory_region_init_io(&s->pm_iomem, NULL, &pxa2xx_pm_ops, s, \"pxa2xx-pm\", 0x100);\n\n    memory_region_add_subregion(address_space, s->pm_base, &s->pm_iomem);\n\n    vmstate_register(NULL, 0, &vmstate_pxa2xx_pm, s);\n\n\n\n    for (i = 0; pxa255_ssp[i].io_base; i ++);\n\n    s->ssp = (SSIBus **)g_malloc0(sizeof(SSIBus *) * i);\n\n    for (i = 0; pxa255_ssp[i].io_base; i ++) {\n\n        DeviceState *dev;\n\n        dev = sysbus_create_simple(TYPE_PXA2XX_SSP, pxa255_ssp[i].io_base,\n\n                        qdev_get_gpio_in(s->pic, pxa255_ssp[i].irqn));\n\n        s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, \"ssi\");\n\n    }\n\n\n\n    if (usb_enabled()) {\n\n        sysbus_create_simple(\"sysbus-ohci\", 0x4c000000,\n\n                        qdev_get_gpio_in(s->pic, PXA2XX_PIC_USBH1));\n\n    }\n\n\n\n    s->pcmcia[0] = pxa2xx_pcmcia_init(address_space, 0x20000000);\n\n    s->pcmcia[1] = pxa2xx_pcmcia_init(address_space, 0x30000000);\n\n\n\n    sysbus_create_simple(TYPE_PXA2XX_RTC, 0x40900000,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_RTCALARM));\n\n\n\n    s->i2c[0] = pxa2xx_i2c_init(0x40301600,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_I2C), 0xffff);\n\n    s->i2c[1] = pxa2xx_i2c_init(0x40f00100,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_PWRI2C), 0xff);\n\n\n\n    s->i2s = pxa2xx_i2s_init(address_space, 0x40400000,\n\n                    qdev_get_gpio_in(s->pic, PXA2XX_PIC_I2S),\n\n                    qdev_get_gpio_in(s->dma, PXA2XX_RX_RQ_I2S),\n\n                    qdev_get_gpio_in(s->dma, PXA2XX_TX_RQ_I2S));\n\n\n\n    /* GPIO1 resets the processor */\n\n    /* The handler can be overridden by board-specific code */\n\n    qdev_connect_gpio_out(s->gpio, 1, s->reset);\n\n    return s;\n\n}\n", "idx": 8527, "_split": "valid", "_hash": "366a1c2c9dfe07d0f4d9d14d0fc9faeb"}
{"project": "qemu", "commit_id": "a2db2a1edd06a50b8a862c654cf993368cf9f1d9", "target": 0, "func": "void xen_be_unbind_evtchn(struct XenDevice *xendev)\n\n{\n\n    if (xendev->local_port == -1) {\n\n        return;\n\n    }\n\n    qemu_set_fd_handler(xc_evtchn_fd(xendev->evtchndev), NULL, NULL, NULL);\n\n    xc_evtchn_unbind(xendev->evtchndev, xendev->local_port);\n\n    xen_be_printf(xendev, 2, \"unbind evtchn port %d\\n\", xendev->local_port);\n\n    xendev->local_port = -1;\n\n}\n", "idx": 8566, "_split": "valid", "_hash": "f75b18cc8380ca5e8ac896f6ec114799"}
{"project": "qemu", "commit_id": "91cda45b69e45a089f9989979a65db3f710c9925", "target": 0, "func": "static int ppc_hash64_check_prot(int prot, int rw, int access_type)\n\n{\n\n    int ret;\n\n\n\n    if (access_type == ACCESS_CODE) {\n\n        if (prot & PAGE_EXEC) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else if (rw) {\n\n        if (prot & PAGE_WRITE) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else {\n\n        if (prot & PAGE_READ) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 8574, "_split": "valid", "_hash": "7c4a8c062f5c5af09856841902583478"}
{"project": "qemu", "commit_id": "c8dcb531bcd37a4a81d2cc08a89fcd19c34348f9", "target": 1, "func": "static int scsi_disk_emulate_inquiry(SCSIRequest *req, uint8_t *outbuf)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    int buflen = 0;\n\n    int start;\n\n\n\n    if (req->cmd.buf[1] & 0x1) {\n\n        /* Vital product data */\n\n        uint8_t page_code = req->cmd.buf[2];\n\n\n\n        outbuf[buflen++] = s->qdev.type & 0x1f;\n\n        outbuf[buflen++] = page_code ; // this page\n\n        outbuf[buflen++] = 0x00;\n\n        outbuf[buflen++] = 0x00;\n\n        start = buflen;\n\n\n\n        switch (page_code) {\n\n        case 0x00: /* Supported page codes, mandatory */\n\n        {\n\n            DPRINTF(\"Inquiry EVPD[Supported pages] \"\n\n                    \"buffer size %zd\\n\", req->cmd.xfer);\n\n            outbuf[buflen++] = 0x00; // list of supported pages (this page)\n\n            if (s->serial) {\n\n                outbuf[buflen++] = 0x80; // unit serial number\n\n            }\n\n            outbuf[buflen++] = 0x83; // device identification\n\n            if (s->qdev.type == TYPE_DISK) {\n\n                outbuf[buflen++] = 0xb0; // block limits\n\n                outbuf[buflen++] = 0xb2; // thin provisioning\n\n            }\n\n            break;\n\n        }\n\n        case 0x80: /* Device serial number, optional */\n\n        {\n\n            int l;\n\n\n\n            if (!s->serial) {\n\n                DPRINTF(\"Inquiry (EVPD[Serial number] not supported\\n\");\n\n                return -1;\n\n            }\n\n\n\n            l = strlen(s->serial);\n\n            if (l > 20) {\n\n                l = 20;\n\n            }\n\n\n\n            DPRINTF(\"Inquiry EVPD[Serial number] \"\n\n                    \"buffer size %zd\\n\", req->cmd.xfer);\n\n            memcpy(outbuf+buflen, s->serial, l);\n\n            buflen += l;\n\n            break;\n\n        }\n\n\n\n        case 0x83: /* Device identification page, mandatory */\n\n        {\n\n            const char *str = s->serial ?: bdrv_get_device_name(s->qdev.conf.bs);\n\n            int max_len = s->serial ? 20 : 255 - 8;\n\n            int id_len = strlen(str);\n\n\n\n            if (id_len > max_len) {\n\n                id_len = max_len;\n\n            }\n\n            DPRINTF(\"Inquiry EVPD[Device identification] \"\n\n                    \"buffer size %zd\\n\", req->cmd.xfer);\n\n\n\n            outbuf[buflen++] = 0x2; // ASCII\n\n            outbuf[buflen++] = 0;   // not officially assigned\n\n            outbuf[buflen++] = 0;   // reserved\n\n            outbuf[buflen++] = id_len; // length of data following\n\n            memcpy(outbuf+buflen, str, id_len);\n\n            buflen += id_len;\n\n\n\n            if (s->wwn) {\n\n                outbuf[buflen++] = 0x1; // Binary\n\n                outbuf[buflen++] = 0x3; // NAA\n\n                outbuf[buflen++] = 0;   // reserved\n\n                outbuf[buflen++] = 8;\n\n                stq_be_p(&outbuf[buflen], s->wwn);\n\n                buflen += 8;\n\n            }\n\n            break;\n\n        }\n\n        case 0xb0: /* block limits */\n\n        {\n\n            unsigned int unmap_sectors =\n\n                    s->qdev.conf.discard_granularity / s->qdev.blocksize;\n\n            unsigned int min_io_size =\n\n                    s->qdev.conf.min_io_size / s->qdev.blocksize;\n\n            unsigned int opt_io_size =\n\n                    s->qdev.conf.opt_io_size / s->qdev.blocksize;\n\n\n\n            if (s->qdev.type == TYPE_ROM) {\n\n                DPRINTF(\"Inquiry (EVPD[%02X] not supported for CDROM\\n\",\n\n                        page_code);\n\n                return -1;\n\n            }\n\n            /* required VPD size with unmap support */\n\n            buflen = 0x40;\n\n            memset(outbuf + 4, 0, buflen - 4);\n\n\n\n            /* optimal transfer length granularity */\n\n            outbuf[6] = (min_io_size >> 8) & 0xff;\n\n            outbuf[7] = min_io_size & 0xff;\n\n\n\n            /* optimal transfer length */\n\n            outbuf[12] = (opt_io_size >> 24) & 0xff;\n\n            outbuf[13] = (opt_io_size >> 16) & 0xff;\n\n            outbuf[14] = (opt_io_size >> 8) & 0xff;\n\n            outbuf[15] = opt_io_size & 0xff;\n\n\n\n            /* optimal unmap granularity */\n\n            outbuf[28] = (unmap_sectors >> 24) & 0xff;\n\n            outbuf[29] = (unmap_sectors >> 16) & 0xff;\n\n            outbuf[30] = (unmap_sectors >> 8) & 0xff;\n\n            outbuf[31] = unmap_sectors & 0xff;\n\n            break;\n\n        }\n\n        case 0xb2: /* thin provisioning */\n\n        {\n\n            buflen = 8;\n\n            outbuf[4] = 0;\n\n            outbuf[5] = 0xe0; /* unmap & write_same 10/16 all supported */\n\n            outbuf[6] = s->qdev.conf.discard_granularity ? 2 : 1;\n\n            outbuf[7] = 0;\n\n            break;\n\n        }\n\n        default:\n\n            return -1;\n\n        }\n\n        /* done with EVPD */\n\n        assert(buflen - start <= 255);\n\n        outbuf[start - 1] = buflen - start;\n\n        return buflen;\n\n    }\n\n\n\n    /* Standard INQUIRY data */\n\n    if (req->cmd.buf[2] != 0) {\n\n        return -1;\n\n    }\n\n\n\n    /* PAGE CODE == 0 */\n\n    buflen = req->cmd.xfer;\n\n    if (buflen > SCSI_MAX_INQUIRY_LEN) {\n\n        buflen = SCSI_MAX_INQUIRY_LEN;\n\n    }\n\n    memset(outbuf, 0, buflen);\n\n\n\n    outbuf[0] = s->qdev.type & 0x1f;\n\n    outbuf[1] = (s->features & (1 << SCSI_DISK_F_REMOVABLE)) ? 0x80 : 0;\n\n\n\n    strpadcpy((char *) &outbuf[16], 16, s->product, ' ');\n\n    strpadcpy((char *) &outbuf[8], 8, s->vendor, ' ');\n\n\n\n    memset(&outbuf[32], 0, 4);\n\n    memcpy(&outbuf[32], s->version, MIN(4, strlen(s->version)));\n\n    /*\n\n     * We claim conformance to SPC-3, which is required for guests\n\n     * to ask for modern features like READ CAPACITY(16) or the\n\n     * block characteristics VPD page by default.  Not all of SPC-3\n\n     * is actually implemented, but we're good enough.\n\n     */\n\n    outbuf[2] = 5;\n\n    outbuf[3] = 2 | 0x10; /* Format 2, HiSup */\n\n\n\n    if (buflen > 36) {\n\n        outbuf[4] = buflen - 5; /* Additional Length = (Len - 1) - 4 */\n\n    } else {\n\n        /* If the allocation length of CDB is too small,\n\n               the additional length is not adjusted */\n\n        outbuf[4] = 36 - 5;\n\n    }\n\n\n\n    /* Sync data transfer and TCQ.  */\n\n    outbuf[7] = 0x10 | (req->bus->info->tcq ? 0x02 : 0);\n\n    return buflen;\n\n}\n", "idx": 8581, "_split": "valid", "_hash": "a9e17d096125c73c1c47bd9053d8f68b"}
{"project": "qemu", "commit_id": "d7b61ecc61f84d23f98f1ee270fb48b41834ca00", "target": 0, "func": "static int unin_agp_pci_host_init(PCIDevice *d)\n\n{\n\n    pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_APPLE);\n\n    pci_config_set_device_id(d->config, PCI_DEVICE_ID_APPLE_UNI_N_AGP);\n\n    d->config[0x08] = 0x00; // revision\n\n    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_HOST);\n\n    d->config[0x0C] = 0x08; // cache_line_size\n\n    d->config[0x0D] = 0x10; // latency_timer\n\n    //    d->config[0x34] = 0x80; // capabilities_pointer\n\n    return 0;\n\n}\n", "idx": 8624, "_split": "valid", "_hash": "45f90a1c73b70bf7ccd4591ef1ceb873"}
{"project": "qemu", "commit_id": "8978b34af3250354e0b67340a7e920f909beda13", "target": 0, "func": "static void float_number(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        double decoded;\n\n        int skip;\n\n    } test_cases[] = {\n\n        { \"32.43\", 32.43 },\n\n        { \"0.222\", 0.222 },\n\n        { \"-32.12313\", -32.12313 },\n\n        { \"-32.20e-10\", -32.20e-10, .skip = 1 },\n\n        { },\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QFloat *qfloat;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded);\n\n        g_assert(obj != NULL);\n\n        g_assert(qobject_type(obj) == QTYPE_QFLOAT);\n\n\n\n        qfloat = qobject_to_qfloat(obj);\n\n        g_assert(qfloat_get_double(qfloat) == test_cases[i].decoded);\n\n\n\n        if (test_cases[i].skip == 0) {\n\n            QString *str;\n\n\n\n            str = qobject_to_json(obj);\n\n            g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);\n\n            QDECREF(str);\n\n        }\n\n\n\n        QDECREF(qfloat);\n\n    }\n\n}\n", "idx": 8625, "_split": "valid", "_hash": "de4ff79ffd598168c43d3c8aa15da487"}
{"project": "qemu", "commit_id": "479125d53eb8509d69a0548f131028a65fcbd65a", "target": 0, "func": "static void colo_process_checkpoint(MigrationState *s)\n\n{\n\n    QIOChannelBuffer *bioc;\n\n    QEMUFile *fb = NULL;\n\n    int64_t current_time, checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    failover_init_state();\n\n\n\n    s->rp_state.from_dst_file = qemu_file_get_return_path(s->to_dst_file);\n\n    if (!s->rp_state.from_dst_file) {\n\n        error_report(\"Open QEMUFile from_dst_file failed\");\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * Wait for Secondary finish loading VM states and enter COLO\n\n     * restore.\n\n     */\n\n    colo_receive_check_message(s->rp_state.from_dst_file,\n\n                       COLO_MESSAGE_CHECKPOINT_READY, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n    bioc = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE);\n\n    fb = qemu_fopen_channel_output(QIO_CHANNEL(bioc));\n\n    object_unref(OBJECT(bioc));\n\n\n\n    qemu_mutex_lock_iothread();\n\n    vm_start();\n\n    qemu_mutex_unlock_iothread();\n\n    trace_colo_vm_state_change(\"stop\", \"run\");\n\n\n\n    while (s->state == MIGRATION_STATUS_COLO) {\n\n        if (failover_get_state() != FAILOVER_STATUS_NONE) {\n\n            error_report(\"failover request\");\n\n            goto out;\n\n        }\n\n\n\n        current_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n\n        if (current_time - checkpoint_time <\n\n            s->parameters.x_checkpoint_delay) {\n\n            int64_t delay_ms;\n\n\n\n            delay_ms = s->parameters.x_checkpoint_delay -\n\n                       (current_time - checkpoint_time);\n\n            g_usleep(delay_ms * 1000);\n\n        }\n\n        ret = colo_do_checkpoint_transaction(s, bioc, fb);\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n        checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n\n    }\n\n\n\nout:\n\n    /* Throw the unreported error message after exited from loop */\n\n    if (local_err) {\n\n        error_report_err(local_err);\n\n    }\n\n\n\n    if (fb) {\n\n        qemu_fclose(fb);\n\n    }\n\n\n\n    if (s->rp_state.from_dst_file) {\n\n        qemu_fclose(s->rp_state.from_dst_file);\n\n    }\n\n}\n", "idx": 8626, "_split": "valid", "_hash": "ee60e9c686865fcdfcc4f0224c3fec4b"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void ecc_mem_write(void *opaque, target_phys_addr_t addr, uint64_t val,\n\n                          unsigned size)\n\n{\n\n    ECCState *s = opaque;\n\n\n\n    switch (addr >> 2) {\n\n    case ECC_MER:\n\n        if (s->version == ECC_MCC)\n\n            s->regs[ECC_MER] = (val & ECC_MER_MASK_0);\n\n        else if (s->version == ECC_EMC)\n\n            s->regs[ECC_MER] = s->version | (val & ECC_MER_MASK_1);\n\n        else if (s->version == ECC_SMC)\n\n            s->regs[ECC_MER] = s->version | (val & ECC_MER_MASK_2);\n\n        trace_ecc_mem_writel_mer(val);\n\n        break;\n\n    case ECC_MDR:\n\n        s->regs[ECC_MDR] =  val & ECC_MDR_MASK;\n\n        trace_ecc_mem_writel_mdr(val);\n\n        break;\n\n    case ECC_MFSR:\n\n        s->regs[ECC_MFSR] =  val;\n\n        qemu_irq_lower(s->irq);\n\n        trace_ecc_mem_writel_mfsr(val);\n\n        break;\n\n    case ECC_VCR:\n\n        s->regs[ECC_VCR] =  val;\n\n        trace_ecc_mem_writel_vcr(val);\n\n        break;\n\n    case ECC_DR:\n\n        s->regs[ECC_DR] =  val;\n\n        trace_ecc_mem_writel_dr(val);\n\n        break;\n\n    case ECC_ECR0:\n\n        s->regs[ECC_ECR0] =  val;\n\n        trace_ecc_mem_writel_ecr0(val);\n\n        break;\n\n    case ECC_ECR1:\n\n        s->regs[ECC_ECR0] =  val;\n\n        trace_ecc_mem_writel_ecr1(val);\n\n        break;\n\n    }\n\n}\n", "idx": 8647, "_split": "valid", "_hash": "5b3072ecb50ee79d39c3cf980f305b40"}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_op_mull_T0_T1(void)\n\n{\n\n    TCGv tmp1 = tcg_temp_new(TCG_TYPE_I64);\n\n    TCGv tmp2 = tcg_temp_new(TCG_TYPE_I64);\n\n\n\n    tcg_gen_extu_i32_i64(tmp1, cpu_T[0]);\n\n    tcg_gen_extu_i32_i64(tmp2, cpu_T[1]);\n\n    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n\n    tcg_gen_trunc_i64_i32(cpu_T[0], tmp1);\n\n    tcg_gen_shri_i64(tmp1, tmp1, 32);\n\n    tcg_gen_trunc_i64_i32(cpu_T[1], tmp1);\n\n}\n", "idx": 8666, "_split": "valid", "_hash": "1655d19595a77a8e6b9cd2debee61638"}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_subfco (void)\n\n{\n\n    T2 = T0;\n\n    T0 = T1 - T0;\n\n    if (likely(T0 > T1)) {\n\n        xer_ca = 0;\n\n    } else {\n\n        xer_ca = 1;\n\n    }\n\n    if (likely(!(((~T2) ^ T1 ^ (-1)) & ((~T2) ^ T0) & (1 << 31)))) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n    }\n\n}\n", "idx": 8719, "_split": "valid", "_hash": "35e8a66e4f0ed9d4142174f1c970a021"}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_del_sq(NvmeCtrl *n, NvmeCmd *cmd)\n\n{\n\n    NvmeDeleteQ *c = (NvmeDeleteQ *)cmd;\n\n    NvmeRequest *req, *next;\n\n    NvmeSQueue *sq;\n\n    NvmeCQueue *cq;\n\n    uint16_t qid = le16_to_cpu(c->qid);\n\n\n\n    if (!qid || nvme_check_sqid(n, qid)) {\n\n        return NVME_INVALID_QID | NVME_DNR;\n\n    }\n\n\n\n    sq = n->sq[qid];\n\n    while (!QTAILQ_EMPTY(&sq->out_req_list)) {\n\n        req = QTAILQ_FIRST(&sq->out_req_list);\n\n        assert(req->aiocb);\n\n        blk_aio_cancel(req->aiocb);\n\n    }\n\n    if (!nvme_check_cqid(n, sq->cqid)) {\n\n        cq = n->cq[sq->cqid];\n\n        QTAILQ_REMOVE(&cq->sq_list, sq, entry);\n\n\n\n        nvme_post_cqes(cq);\n\n        QTAILQ_FOREACH_SAFE(req, &cq->req_list, entry, next) {\n\n            if (req->sq == sq) {\n\n                QTAILQ_REMOVE(&cq->req_list, req, entry);\n\n                QTAILQ_INSERT_TAIL(&sq->req_list, req, entry);\n\n            }\n\n        }\n\n    }\n\n\n\n    nvme_free_sq(sq, n);\n\n    return NVME_SUCCESS;\n\n}\n", "idx": 8724, "_split": "valid", "_hash": "2420c9a37dda5494395fe6a7f62acd0e"}
{"project": "qemu", "commit_id": "8775d91a0f42d016833330881bb587982db88a3c", "target": 1, "func": "static void virtio_scsi_locate_device(VDev *vdev)\n\n{\n\n    const uint16_t channel = 0; /* again, it's what QEMU does */\n\n    uint16_t target;\n\n    static uint8_t data[16 + 8 * 63];\n\n    ScsiLunReport *r = (void *) data;\n\n    ScsiDevice *sdev = vdev->scsi_device;\n\n    int i, luns;\n\n\n\n    /* QEMU has hardcoded channel #0 in many places.\n\n     * If this hardcoded value is ever changed, we'll need to add code for\n\n     * vdev->config.scsi.max_channel != 0 here.\n\n     */\n\n    debug_print_int(\"config.scsi.max_channel\", vdev->config.scsi.max_channel);\n\n    debug_print_int(\"config.scsi.max_target \", vdev->config.scsi.max_target);\n\n    debug_print_int(\"config.scsi.max_lun    \", vdev->config.scsi.max_lun);\n\n    debug_print_int(\"config.scsi.max_sectors\", vdev->config.scsi.max_sectors);\n\n\n\n    if (vdev->scsi_device_selected) {\n\n        sdev->channel = vdev->selected_scsi_device.channel;\n\n        sdev->target = vdev->selected_scsi_device.target;\n\n        sdev->lun = vdev->selected_scsi_device.lun;\n\n\n\n        IPL_check(sdev->channel == 0, \"non-zero channel requested\");\n\n        IPL_check(sdev->target <= vdev->config.scsi.max_target, \"target# high\");\n\n        IPL_check(sdev->lun <= vdev->config.scsi.max_lun, \"LUN# high\");\n\n        return;\n\n    }\n\n\n\n    for (target = 0; target <= vdev->config.scsi.max_target; target++) {\n\n        sdev->channel = channel;\n\n        sdev->target = target; /* sdev->lun will be 0 here */\n\n        if (!scsi_report_luns(vdev, data, sizeof(data))) {\n\n            if (resp.response == VIRTIO_SCSI_S_BAD_TARGET) {\n\n                continue;\n\n            }\n\n            print_int(\"target\", target);\n\n            virtio_scsi_verify_response(&resp, \"SCSI cannot report LUNs\");\n\n        }\n\n        if (r->lun_list_len == 0) {\n\n            print_int(\"no LUNs for target\", target);\n\n            continue;\n\n        }\n\n        luns = r->lun_list_len / 8;\n\n        debug_print_int(\"LUNs reported\", luns);\n\n        if (luns == 1) {\n\n            /* There is no \",lun=#\" arg for -device or \",lun=0\" given.\n\n             * Hence, the only LUN reported.\n\n             * Usually, it's 0.\n\n             */\n\n            sdev->lun = r->lun[0].v16[0]; /* it's returned this way */\n\n            debug_print_int(\"Have to use LUN\", sdev->lun);\n\n            return; /* we have to use this device */\n\n        }\n\n        for (i = 0; i < luns; i++) {\n\n            if (r->lun[i].v64) {\n\n                /* Look for non-zero LUN - we have where to choose from */\n\n                sdev->lun = r->lun[i].v16[0];\n\n                debug_print_int(\"Will use LUN\", sdev->lun);\n\n                return; /* we have found a device */\n\n            }\n\n        }\n\n    }\n\n    panic(\"\\n! Cannot locate virtio-scsi device !\\n\");\n\n}\n", "idx": 8726, "_split": "valid", "_hash": "546e0f96fac9a993a74a387b88ede10f"}
{"project": "qemu", "commit_id": "e0d9c6f93729c9bfc98fcafcd73098bb8e131aeb", "target": 1, "func": "static void qcow2_aio_read_cb(void *opaque, int ret)\n\n{\n\n    QCowAIOCB *acb = opaque;\n\n    BlockDriverState *bs = acb->common.bs;\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster, n1;\n\n\n\n    acb->hd_aiocb = NULL;\n\n    if (ret < 0)\n\n        goto done;\n\n\n\n    /* post process the read buffer */\n\n    if (!acb->cluster_offset) {\n\n        /* nothing to do */\n\n    } else if (acb->cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n        /* nothing to do */\n\n    } else {\n\n        if (s->crypt_method) {\n\n            qcow2_encrypt_sectors(s, acb->sector_num,  acb->cluster_data,\n\n                acb->cluster_data, acb->cur_nr_sectors, 0, &s->aes_decrypt_key);\n\n            qemu_iovec_reset(&acb->hd_qiov);\n\n            qemu_iovec_copy(&acb->hd_qiov, acb->qiov, acb->bytes_done,\n\n                acb->cur_nr_sectors * 512);\n\n            qemu_iovec_from_buffer(&acb->hd_qiov, acb->cluster_data,\n\n                512 * acb->cur_nr_sectors);\n\n        }\n\n    }\n\n\n\n    acb->remaining_sectors -= acb->cur_nr_sectors;\n\n    acb->sector_num += acb->cur_nr_sectors;\n\n    acb->bytes_done += acb->cur_nr_sectors * 512;\n\n\n\n    if (acb->remaining_sectors == 0) {\n\n        /* request completed */\n\n        ret = 0;\n\n        goto done;\n\n    }\n\n\n\n    /* prepare next AIO request */\n\n    acb->cur_nr_sectors = acb->remaining_sectors;\n\n    if (s->crypt_method) {\n\n        acb->cur_nr_sectors = MIN(acb->cur_nr_sectors,\n\n            QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n    }\n\n\n\n    ret = qcow2_get_cluster_offset(bs, acb->sector_num << 9,\n\n        &acb->cur_nr_sectors, &acb->cluster_offset);\n\n    if (ret < 0) {\n\n        goto done;\n\n    }\n\n\n\n    index_in_cluster = acb->sector_num & (s->cluster_sectors - 1);\n\n\n\n    qemu_iovec_reset(&acb->hd_qiov);\n\n    qemu_iovec_copy(&acb->hd_qiov, acb->qiov, acb->bytes_done,\n\n        acb->cur_nr_sectors * 512);\n\n\n\n    if (!acb->cluster_offset) {\n\n\n\n        if (bs->backing_hd) {\n\n            /* read from the base image */\n\n            n1 = qcow2_backing_read1(bs->backing_hd, &acb->hd_qiov,\n\n                acb->sector_num, acb->cur_nr_sectors);\n\n            if (n1 > 0) {\n\n                BLKDBG_EVENT(bs->file, BLKDBG_READ_BACKING_AIO);\n\n                acb->hd_aiocb = bdrv_aio_readv(bs->backing_hd, acb->sector_num,\n\n                                    &acb->hd_qiov, acb->cur_nr_sectors,\n\n\t\t\t\t    qcow2_aio_read_cb, acb);\n\n                if (acb->hd_aiocb == NULL)\n\n                    goto done;\n\n            } else {\n\n                ret = qcow2_schedule_bh(qcow2_aio_read_bh, acb);\n\n                if (ret < 0)\n\n                    goto done;\n\n            }\n\n        } else {\n\n            /* Note: in this case, no need to wait */\n\n            qemu_iovec_memset(&acb->hd_qiov, 0, 512 * acb->cur_nr_sectors);\n\n            ret = qcow2_schedule_bh(qcow2_aio_read_bh, acb);\n\n            if (ret < 0)\n\n                goto done;\n\n        }\n\n    } else if (acb->cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n        /* add AIO support for compressed blocks ? */\n\n        if (qcow2_decompress_cluster(bs, acb->cluster_offset) < 0)\n\n            goto done;\n\n\n\n        qemu_iovec_from_buffer(&acb->hd_qiov,\n\n            s->cluster_cache + index_in_cluster * 512,\n\n            512 * acb->cur_nr_sectors);\n\n\n\n        ret = qcow2_schedule_bh(qcow2_aio_read_bh, acb);\n\n        if (ret < 0)\n\n            goto done;\n\n    } else {\n\n        if ((acb->cluster_offset & 511) != 0) {\n\n            ret = -EIO;\n\n            goto done;\n\n        }\n\n\n\n        if (s->crypt_method) {\n\n            /*\n\n             * For encrypted images, read everything into a temporary\n\n             * contiguous buffer on which the AES functions can work.\n\n             */\n\n            if (!acb->cluster_data) {\n\n                acb->cluster_data =\n\n                    qemu_mallocz(QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n            }\n\n\n\n            assert(acb->cur_nr_sectors <=\n\n                QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n            qemu_iovec_reset(&acb->hd_qiov);\n\n            qemu_iovec_add(&acb->hd_qiov, acb->cluster_data,\n\n                512 * acb->cur_nr_sectors);\n\n        }\n\n\n\n        BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n        acb->hd_aiocb = bdrv_aio_readv(bs->file,\n\n                            (acb->cluster_offset >> 9) + index_in_cluster,\n\n                            &acb->hd_qiov, acb->cur_nr_sectors,\n\n                            qcow2_aio_read_cb, acb);\n\n        if (acb->hd_aiocb == NULL) {\n\n            ret = -EIO;\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    return;\n\ndone:\n\n    acb->common.cb(acb->common.opaque, ret);\n\n    qemu_iovec_destroy(&acb->hd_qiov);\n\n    qemu_aio_release(acb);\n\n}\n", "idx": 8727, "_split": "valid", "_hash": "5cf57db326a79981cc952f3291082ef5"}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void t_gen_btst(TCGv d, TCGv a, TCGv b)\n\n{\n\n        TCGv sbit;\n\n        TCGv bset;\n\n        TCGv t0;\n\n\tint l1;\n\n\n\n        /* des ref:\n\n           The N flag is set according to the selected bit in the dest reg.\n\n           The Z flag is set if the selected bit and all bits to the right are\n\n           zero.\n\n           The X flag is cleared.\n\n           Other flags are left untouched.\n\n           The destination reg is not affected.\n\n\n\n        unsigned int fz, sbit, bset, mask, masked_t0;\n\n\n\n        sbit = T1 & 31;\n\n        bset = !!(T0 & (1 << sbit));\n\n        mask = sbit == 31 ? -1 : (1 << (sbit + 1)) - 1;\n\n        masked_t0 = T0 & mask;\n\n        fz = !(masked_t0 | bset);\n\n\n\n        // Clear the X, N and Z flags.\n\n        T0 = env->pregs[PR_CCS] & ~(X_FLAG | N_FLAG | Z_FLAG);\n\n        // Set the N and Z flags accordingly.\n\n        T0 |= (bset << 3) | (fz << 2);\n\n        */\n\n\n\n\tl1 = gen_new_label();\n\n        sbit = tcg_temp_new(TCG_TYPE_TL);\n\n        bset = tcg_temp_new(TCG_TYPE_TL);\n\n        t0 = tcg_temp_new(TCG_TYPE_TL);\n\n\n\n        /* Compute bset and sbit.  */\n\n        tcg_gen_andi_tl(sbit, b, 31);\n\n        tcg_gen_shl_tl(t0, tcg_const_tl(1), sbit);\n\n        tcg_gen_and_tl(bset, a, t0);\n\n        tcg_gen_shr_tl(bset, bset, sbit);\n\n\t/* Displace to N_FLAG.  */\n\n        tcg_gen_shli_tl(bset, bset, 3);\n\n\n\n        tcg_gen_shl_tl(sbit, tcg_const_tl(2), sbit);\n\n        tcg_gen_subi_tl(sbit, sbit, 1);\n\n        tcg_gen_and_tl(sbit, a, sbit);\n\n\n\n        tcg_gen_andi_tl(d, cpu_PR[PR_CCS], ~(X_FLAG | N_FLAG | Z_FLAG));\n\n\t/* or in the N_FLAG.  */\n\n        tcg_gen_or_tl(d, d, bset);\n\n\ttcg_gen_brcondi_tl(TCG_COND_NE, sbit, 0, l1);\n\n\t/* or in the Z_FLAG.  */\n\n\ttcg_gen_ori_tl(d, d, Z_FLAG);\n\n\tgen_set_label(l1);\n\n\n\n        tcg_temp_free(sbit);\n\n        tcg_temp_free(bset);\n\n}\n", "idx": 8750, "_split": "valid", "_hash": "4b07e080baeec225db06da85214df0c3"}
{"project": "qemu", "commit_id": "cf070d7ec0b8fb21faa9a630ed5cc66f90844a08", "target": 0, "func": "read_f(int argc, char **argv)\n\n{\n\n\tstruct timeval t1, t2;\n\n\tint Cflag = 0, pflag = 0, qflag = 0, vflag = 0;\n\n\tint Pflag = 0, sflag = 0, lflag = 0, bflag = 0;\n\n\tint c, cnt;\n\n\tchar *buf;\n\n\tint64_t offset;\n\n\tint count;\n\n        /* Some compilers get confused and warn if this is not initialized.  */\n\n        int total = 0;\n\n\tint pattern = 0, pattern_offset = 0, pattern_count = 0;\n\n\n\n\twhile ((c = getopt(argc, argv, \"bCl:pP:qs:v\")) != EOF) {\n\n\t\tswitch (c) {\n\n\t\tcase 'b':\n\n\t\t\tbflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'C':\n\n\t\t\tCflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'l':\n\n\t\t\tlflag = 1;\n\n\t\t\tpattern_count = cvtnum(optarg);\n\n\t\t\tif (pattern_count < 0) {\n\n\t\t\t\tprintf(\"non-numeric length argument -- %s\\n\", optarg);\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'p':\n\n\t\t\tpflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'P':\n\n\t\t\tPflag = 1;\n\n\t\t\tpattern = atoi(optarg);\n\n\t\t\tbreak;\n\n\t\tcase 'q':\n\n\t\t\tqflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 's':\n\n\t\t\tsflag = 1;\n\n\t\t\tpattern_offset = cvtnum(optarg);\n\n\t\t\tif (pattern_offset < 0) {\n\n\t\t\t\tprintf(\"non-numeric length argument -- %s\\n\", optarg);\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'v':\n\n\t\t\tvflag = 1;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\treturn command_usage(&read_cmd);\n\n\t\t}\n\n\t}\n\n\n\n\tif (optind != argc - 2)\n\n\t\treturn command_usage(&read_cmd);\n\n\n\n\tif (bflag && pflag) {\n\n\t\tprintf(\"-b and -p cannot be specified at the same time\\n\");\n\n\t\treturn 0;\n\n\t}\n\n\n\n\toffset = cvtnum(argv[optind]);\n\n\tif (offset < 0) {\n\n\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\toptind++;\n\n\tcount = cvtnum(argv[optind]);\n\n\tif (count < 0) {\n\n\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n\t\treturn 0;\n\n\t}\n\n\n\n    if (!Pflag && (lflag || sflag)) {\n\n        return command_usage(&read_cmd);\n\n    }\n\n\n\n    if (!lflag) {\n\n        pattern_count = count - pattern_offset;\n\n    }\n\n\n\n    if ((pattern_count < 0) || (pattern_count + pattern_offset > count))  {\n\n        printf(\"pattern verfication range exceeds end of read data\\n\");\n\n        return 0;\n\n    }\n\n\n\n\tif (!pflag)\n\n\t\tif (offset & 0x1ff) {\n\n\t\t\tprintf(\"offset %lld is not sector aligned\\n\",\n\n\t\t\t\t(long long)offset);\n\n\t\t\treturn 0;\n\n\n\n\t\tif (count & 0x1ff) {\n\n\t\t\tprintf(\"count %d is not sector aligned\\n\",\n\n\t\t\t\tcount);\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\n\n\tbuf = qemu_io_alloc(count, 0xab);\n\n\n\n\tgettimeofday(&t1, NULL);\n\n\tif (pflag)\n\n\t\tcnt = do_pread(buf, offset, count, &total);\n\n\telse if (bflag)\n\n\t\tcnt = do_load_vmstate(buf, offset, count, &total);\n\n\telse\n\n\t\tcnt = do_read(buf, offset, count, &total);\n\n\tgettimeofday(&t2, NULL);\n\n\n\n\tif (cnt < 0) {\n\n\t\tprintf(\"read failed: %s\\n\", strerror(-cnt));\n\n\t\tgoto out;\n\n\t}\n\n\n\n\tif (Pflag) {\n\n\t\tvoid* cmp_buf = malloc(pattern_count);\n\n\t\tmemset(cmp_buf, pattern, pattern_count);\n\n\t\tif (memcmp(buf + pattern_offset, cmp_buf, pattern_count)) {\n\n\t\t\tprintf(\"Pattern verification failed at offset %lld, \"\n\n\t\t\t\t\"%d bytes\\n\",\n\n\t\t\t\t(long long) offset + pattern_offset, pattern_count);\n\n\t\t}\n\n\t\tfree(cmp_buf);\n\n\t}\n\n\n\n\tif (qflag)\n\n\t\tgoto out;\n\n\n\n        if (vflag)\n\n\t\tdump_buffer(buf, offset, count);\n\n\n\n\t/* Finally, report back -- -C gives a parsable format */\n\n\tt2 = tsub(t2, t1);\n\n\tprint_report(\"read\", &t2, offset, count, total, cnt, Cflag);\n\n\n\nout:\n\n\tqemu_io_free(buf);\n\n\n\n\treturn 0;\n\n}\n", "idx": 8758, "_split": "valid", "_hash": "3808f495ccb47ef286d06cd552a50ae5"}
{"project": "qemu", "commit_id": "daa76aa416b1e18ab1fac650ff53d966d8f21f68", "target": 1, "func": "static void test_parse_path(void)\n\n{\n\n    g_test_trap_subprocess (\"/logging/parse_path/subprocess\", 0, 0);\n\n    g_test_trap_assert_passed();\n\n    g_test_trap_assert_stdout(\"\");\n\n    g_test_trap_assert_stderr(\"\");\n\n}\n", "idx": 8827, "_split": "valid", "_hash": "4e29796fce0424bb7de7894b339a4f3b"}
{"project": "qemu", "commit_id": "d1eb8f2acba579830cf3798c3c15ce51be852c56", "target": 0, "func": "int floatx80_unordered(floatx80 a, floatx80 b, float_status *status)\n\n{\n\n    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )\n\n         || (    ( extractFloatx80Exp( b ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )\n\n       ) {\n\n        float_raise(float_flag_invalid, status);\n\n        return 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 8837, "_split": "valid", "_hash": "683b04ed5a268036df12ffed6efa53f3"}
{"project": "qemu", "commit_id": "7d553f27fce284805d7f94603932045ee3bbb979", "target": 0, "func": "static void usbredir_do_attach(void *opaque)\n\n{\n\n    USBRedirDevice *dev = opaque;\n\n\n\n    /* In order to work properly with XHCI controllers we need these caps */\n\n    if ((dev->dev.port->speedmask & USB_SPEED_MASK_SUPER) && !(\n\n        usbredirparser_peer_has_cap(dev->parser,\n\n                                    usb_redir_cap_ep_info_max_packet_size) &&\n\n        usbredirparser_peer_has_cap(dev->parser,\n\n                                    usb_redir_cap_32bits_bulk_length) &&\n\n        usbredirparser_peer_has_cap(dev->parser,\n\n                                    usb_redir_cap_64bits_ids))) {\n\n        ERROR(\"usb-redir-host lacks capabilities needed for use with XHCI\\n\");\n\n        usbredir_reject_device(dev);\n\n        return;\n\n    }\n\n\n\n    if (usb_device_attach(&dev->dev) != 0) {\n\n        WARNING(\"rejecting device due to speed mismatch\\n\");\n\n        usbredir_reject_device(dev);\n\n    }\n\n}\n", "idx": 8838, "_split": "valid", "_hash": "8154c1cec81d28ae50d27ec01dfb3777"}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_fctidz (uint64_t arg)\n\n{\n\n    CPU_DoubleU farg;\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN conversion */\n\n        farg.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN | POWERPC_EXCP_FP_VXCVI);\n\n    } else if (unlikely(float64_is_nan(farg.d) || float64_is_infinity(farg.d))) {\n\n        /* qNan / infinity conversion */\n\n        farg.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXCVI);\n\n    } else {\n\n        farg.ll = float64_to_int64_round_to_zero(farg.d, &env->fp_status);\n\n    }\n\n    return farg.ll;\n\n}\n", "idx": 8853, "_split": "valid", "_hash": "b580dbbe005a6eb17519b7f85a5248f9"}
{"project": "qemu", "commit_id": "dd4d607e40dcd2cb7646b510504880a70939d91b", "target": 0, "func": "static void vtd_iommu_notify_flag_changed(MemoryRegion *iommu,\n\n                                          IOMMUNotifierFlag old,\n\n                                          IOMMUNotifierFlag new)\n\n{\n\n    VTDAddressSpace *vtd_as = container_of(iommu, VTDAddressSpace, iommu);\n\n\n\n    if (new & IOMMU_NOTIFIER_MAP) {\n\n        error_report(\"Device at bus %s addr %02x.%d requires iommu \"\n\n                     \"notifier which is currently not supported by \"\n\n                     \"intel-iommu emulation\",\n\n                     vtd_as->bus->qbus.name, PCI_SLOT(vtd_as->devfn),\n\n                     PCI_FUNC(vtd_as->devfn));\n\n        exit(1);\n\n    }\n\n}\n", "idx": 8862, "_split": "valid", "_hash": "e1587e748be1296d9235d5e4286a0a7d"}
{"project": "qemu", "commit_id": "e2779de053b64f023de382fd87b3596613d47d1e", "target": 0, "func": "static int xen_pt_long_reg_write(XenPCIPassthroughState *s, XenPTReg *cfg_entry,\n\n                                 uint32_t *val, uint32_t dev_value,\n\n                                 uint32_t valid_mask)\n\n{\n\n    XenPTRegInfo *reg = cfg_entry->reg;\n\n    uint32_t writable_mask = 0;\n\n    uint32_t throughable_mask = get_throughable_mask(s, reg, valid_mask);\n\n\n\n    /* modify emulate register */\n\n    writable_mask = reg->emu_mask & ~reg->ro_mask & valid_mask;\n\n    cfg_entry->data = XEN_PT_MERGE_VALUE(*val, cfg_entry->data, writable_mask);\n\n\n\n    /* create value for writing to I/O device register */\n\n    *val = XEN_PT_MERGE_VALUE(*val, dev_value, throughable_mask);\n\n\n\n    return 0;\n\n}\n", "idx": 8864, "_split": "valid", "_hash": "a0d78a4f82b5b4ae365a406c3b0b76ec"}
{"project": "qemu", "commit_id": "fa6252b0565526ec2347e248172f91771e0d9f47", "target": 1, "func": "coroutine_fn iscsi_co_write_zeroes(BlockDriverState *bs, int64_t sector_num,\n\n                                   int nb_sectors, BdrvRequestFlags flags)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct IscsiTask iTask;\n\n    uint64_t lba;\n\n    uint32_t nb_blocks;\n\n\n\n    if (!is_request_lun_aligned(sector_num, nb_sectors, iscsilun)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (!iscsilun->lbp.lbpws) {\n\n        /* WRITE SAME is not supported by the target */\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    lba = sector_qemu2lun(sector_num, iscsilun);\n\n    nb_blocks = sector_qemu2lun(nb_sectors, iscsilun);\n\n\n\n    if (iscsilun->zeroblock == NULL) {\n\n        iscsilun->zeroblock = g_malloc0(iscsilun->block_size);\n\n    }\n\n\n\n    iscsi_co_init_iscsitask(iscsilun, &iTask);\n\nretry:\n\n    if (iscsi_writesame16_task(iscsilun->iscsi, iscsilun->lun, lba,\n\n                               iscsilun->zeroblock, iscsilun->block_size,\n\n                               nb_blocks, 0, !!(flags & BDRV_REQ_MAY_UNMAP),\n\n                               0, 0, iscsi_co_generic_cb, &iTask) == NULL) {\n\n        return -EIO;\n\n    }\n\n\n\n    while (!iTask.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_coroutine_yield();\n\n    }\n\n\n\n    if (iTask.task != NULL) {\n\n        scsi_free_scsi_task(iTask.task);\n\n        iTask.task = NULL;\n\n    }\n\n\n\n    if (iTask.do_retry) {\n\n        goto retry;\n\n    }\n\n\n\n    if (iTask.status != SCSI_STATUS_GOOD) {\n\n        return -EIO;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 8873, "_split": "valid", "_hash": "ce560eee0ffb34bdae7e45e7363d0014"}
{"project": "qemu", "commit_id": "44b6789299a8acca3f25331bc411055cafc7bb06", "target": 1, "func": "static BlkverifyAIOCB *blkverify_aio_get(BlockDriverState *bs, bool is_write,\n\n                                         int64_t sector_num, QEMUIOVector *qiov,\n\n                                         int nb_sectors,\n\n                                         BlockCompletionFunc *cb,\n\n                                         void *opaque)\n\n{\n\n    BlkverifyAIOCB *acb = qemu_aio_get(&blkverify_aiocb_info, bs, cb, opaque);\n\n\n\n    acb->is_write = is_write;\n\n    acb->sector_num = sector_num;\n\n    acb->nb_sectors = nb_sectors;\n\n    acb->ret = -EINPROGRESS;\n\n    acb->done = 0;\n\n    acb->qiov = qiov;\n\n    acb->buf = NULL;\n\n    acb->verify = NULL;\n\n    return acb;\n\n}\n", "idx": 8874, "_split": "valid", "_hash": "ff62b375fa4bb0394978f3f1846519cb"}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_validate_list(TestInputVisitorData *data,\n\n                                const void *unused)\n\n{\n\n    UserDefOneList *head = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"[ { 'string': 'string0', 'integer': 42 }, { 'string': 'string1', 'integer': 43 }, { 'string': 'string2', 'integer': 44 } ]\");\n\n\n\n    visit_type_UserDefOneList(v, NULL, &head, &error_abort);\n\n    qapi_free_UserDefOneList(head);\n\n}\n", "idx": 8915, "_split": "valid", "_hash": "c83b3718f8567048d65b1fde5879dc38"}
{"project": "qemu", "commit_id": "4efe27556dea874030f1cd53a6d70452ee064fba", "target": 0, "func": "void vga_common_init(VGAState *s, DisplayState *ds, uint8_t *vga_ram_base,\n\n                     unsigned long vga_ram_offset, int vga_ram_size)\n\n{\n\n    int i, j, v, b;\n\n\n\n    for(i = 0;i < 256; i++) {\n\n        v = 0;\n\n        for(j = 0; j < 8; j++) {\n\n            v |= ((i >> j) & 1) << (j * 4);\n\n        }\n\n        expand4[i] = v;\n\n\n\n        v = 0;\n\n        for(j = 0; j < 4; j++) {\n\n            v |= ((i >> (2 * j)) & 3) << (j * 4);\n\n        }\n\n        expand2[i] = v;\n\n    }\n\n    for(i = 0; i < 16; i++) {\n\n        v = 0;\n\n        for(j = 0; j < 4; j++) {\n\n            b = ((i >> j) & 1);\n\n            v |= b << (2 * j);\n\n            v |= b << (2 * j + 1);\n\n        }\n\n        expand4to8[i] = v;\n\n    }\n\n\n\n    vga_reset(s);\n\n\n\n    s->vram_ptr = vga_ram_base;\n\n    s->vram_offset = vga_ram_offset;\n\n    s->vram_size = vga_ram_size;\n\n    s->ds = ds;\n\n    s->get_bpp = vga_get_bpp;\n\n    s->get_offsets = vga_get_offsets;\n\n    s->get_resolution = vga_get_resolution;\n\n    s->update = vga_update_display;\n\n    s->invalidate = vga_invalidate_display;\n\n    s->screen_dump = vga_screen_dump;\n\n    s->text_update = vga_update_text;\n\n    switch (vga_retrace_method) {\n\n    case VGA_RETRACE_DUMB:\n\n        s->retrace = vga_dumb_retrace;\n\n        s->update_retrace_info = vga_dumb_update_retrace_info;\n\n        break;\n\n\n\n    case VGA_RETRACE_PRECISE:\n\n        s->retrace = vga_precise_retrace;\n\n        s->update_retrace_info = vga_precise_update_retrace_info;\n\n        memset(&s->retrace_info, 0, sizeof (s->retrace_info));\n\n        break;\n\n    }\n\n}\n", "idx": 8971, "_split": "valid", "_hash": "c5d41776e7e4a6b6e5ca4553c6d4ed85"}
{"project": "qemu", "commit_id": "871271615108fd58273423d98b7cefe08e6f75a0", "target": 0, "func": "void monitor_init(CharDriverState *chr, int show_banner)\n\n{\n\n    int i;\n\n\n\n    if (is_first_init) {\n\n        key_timer = qemu_new_timer(vm_clock, release_keys, NULL);\n\n        if (!key_timer)\n\n            return;\n\n        for (i = 0; i < MAX_MON; i++) {\n\n            monitor_hd[i] = NULL;\n\n        }\n\n        is_first_init = 0;\n\n    }\n\n    for (i = 0; i < MAX_MON; i++) {\n\n        if (monitor_hd[i] == NULL) {\n\n            monitor_hd[i] = chr;\n\n            break;\n\n        }\n\n    }\n\n\n\n    hide_banner = !show_banner;\n\n\n\n    qemu_chr_add_handlers(chr, term_can_read, term_read, term_event, cur_mon);\n\n\n\n    readline_start(\"\", 0, monitor_command_cb, NULL);\n\n}\n", "idx": 8978, "_split": "valid", "_hash": "a6648db86414a08b193527b53c166ad9"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int iommu_dma_memory_rw(DMAContext *dma, dma_addr_t addr,\n\n                        void *buf, dma_addr_t len, DMADirection dir)\n\n{\n\n    target_phys_addr_t paddr, plen;\n\n    int err;\n\n\n\n#ifdef DEBUG_IOMMU\n\n    fprintf(stderr, \"dma_memory_rw context=%p addr=0x\" DMA_ADDR_FMT \" len=0x\"\n\n            DMA_ADDR_FMT \" dir=%d\\n\", dma, addr, len, dir);\n\n#endif\n\n\n\n    while (len) {\n\n        err = dma->translate(dma, addr, &paddr, &plen, dir);\n\n        if (err) {\n\n\t    /*\n\n             * In case of failure on reads from the guest, we clean the\n\n             * destination buffer so that a device that doesn't test\n\n             * for errors will not expose qemu internal memory.\n\n\t     */\n\n\t    memset(buf, 0, len);\n\n            return -1;\n\n        }\n\n\n\n        /* The translation might be valid for larger regions. */\n\n        if (plen > len) {\n\n            plen = len;\n\n        }\n\n\n\n        address_space_rw(dma->as, paddr, buf, plen, dir == DMA_DIRECTION_FROM_DEVICE);\n\n\n\n        len -= plen;\n\n        addr += plen;\n\n        buf += plen;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9001, "_split": "valid", "_hash": "c3e5d71131ad243fb90426d948843e84"}
{"project": "qemu", "commit_id": "ef76dc59fa5203d146a2acf85a0ad5a5971a4824", "target": 0, "func": "START_TEST(simple_list)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        LiteralQObject decoded;\n\n    } test_cases[] = {\n\n        {\n\n            .encoded = \"[43,42]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \"[43]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \"[]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \"[{}]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    {},\n\n                                        })),\n\n                        {},\n\n                            })),\n\n        },\n\n        { }\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded);\n\n        fail_unless(obj != NULL);\n\n        fail_unless(qobject_type(obj) == QTYPE_QLIST);\n\n\n\n        fail_unless(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        str = qobject_to_json(obj);\n\n        qobject_decref(obj);\n\n\n\n        obj = qobject_from_json(qstring_get_str(str));\n\n        fail_unless(obj != NULL);\n\n        fail_unless(qobject_type(obj) == QTYPE_QLIST);\n\n\n\n        fail_unless(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n        qobject_decref(obj);\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 9032, "_split": "valid", "_hash": "a9d2efbce12b11ed9fb02eb23e874eac"}
{"project": "qemu", "commit_id": "c60bf3391bf4cb79b7adc6650094e21671ddaabd", "target": 0, "func": "static void readline_update(ReadLineState *rs)\n\n{\n\n    int i, delta, len;\n\n\n\n    if (rs->cmd_buf_size != rs->last_cmd_buf_size ||\n\n        memcmp(rs->cmd_buf, rs->last_cmd_buf, rs->cmd_buf_size) != 0) {\n\n        for(i = 0; i < rs->last_cmd_buf_index; i++) {\n\n            monitor_printf(rs->mon, \"\\033[D\");\n\n        }\n\n        rs->cmd_buf[rs->cmd_buf_size] = '\\0';\n\n        if (rs->read_password) {\n\n            len = strlen(rs->cmd_buf);\n\n            for(i = 0; i < len; i++)\n\n                monitor_printf(rs->mon, \"*\");\n\n        } else {\n\n            monitor_printf(rs->mon, \"%s\", rs->cmd_buf);\n\n        }\n\n        monitor_printf(rs->mon, \"\\033[K\");\n\n        memcpy(rs->last_cmd_buf, rs->cmd_buf, rs->cmd_buf_size);\n\n        rs->last_cmd_buf_size = rs->cmd_buf_size;\n\n        rs->last_cmd_buf_index = rs->cmd_buf_size;\n\n    }\n\n    if (rs->cmd_buf_index != rs->last_cmd_buf_index) {\n\n        delta = rs->cmd_buf_index - rs->last_cmd_buf_index;\n\n        if (delta > 0) {\n\n            for(i = 0;i < delta; i++) {\n\n                monitor_printf(rs->mon, \"\\033[C\");\n\n            }\n\n        } else {\n\n            delta = -delta;\n\n            for(i = 0;i < delta; i++) {\n\n                monitor_printf(rs->mon, \"\\033[D\");\n\n            }\n\n        }\n\n        rs->last_cmd_buf_index = rs->cmd_buf_index;\n\n    }\n\n    monitor_flush(rs->mon);\n\n}\n", "idx": 9051, "_split": "valid", "_hash": "f7e07f1064657d68a9239dec82ab4833"}
{"project": "qemu", "commit_id": "758ead31c7e17bf17a9ef2e0ca1c3e86ab296b43", "target": 1, "func": "void virtio_queue_update_rings(VirtIODevice *vdev, int n)\n\n{\n\n    VRing *vring = &vdev->vq[n].vring;\n\n\n\n    if (!vring->desc) {\n\n        /* not yet setup -> nothing to do */\n\n        return;\n\n    }\n\n    vring->avail = vring->desc + vring->num * sizeof(VRingDesc);\n\n    vring->used = vring_align(vring->avail +\n\n                              offsetof(VRingAvail, ring[vring->num]),\n\n                              vring->align);\n\n    virtio_init_region_cache(vdev, n);\n\n}\n", "idx": 9079, "_split": "valid", "_hash": "6d0a28d8a8a8731344ea5c53f6533e55"}
{"project": "qemu", "commit_id": "f6977f15561973d4a67b6aa46da88aa678c505dd", "target": 1, "func": "static int qcow2_write_snapshots(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowSnapshot *sn;\n\n    QCowSnapshotHeader h;\n\n    QCowSnapshotExtraData extra;\n\n    int i, name_size, id_str_size, snapshots_size;\n\n    struct {\n\n        uint32_t nb_snapshots;\n\n        uint64_t snapshots_offset;\n\n    } QEMU_PACKED header_data;\n\n    int64_t offset, snapshots_offset;\n\n    int ret;\n\n\n\n    /* compute the size of the snapshots */\n\n    offset = 0;\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        offset = align_offset(offset, 8);\n\n        offset += sizeof(h);\n\n        offset += sizeof(extra);\n\n        offset += strlen(sn->id_str);\n\n        offset += strlen(sn->name);\n\n    }\n\n    snapshots_size = offset;\n\n\n\n    /* Allocate space for the new snapshot list */\n\n    snapshots_offset = qcow2_alloc_clusters(bs, snapshots_size);\n\n    bdrv_flush(bs->file);\n\n    offset = snapshots_offset;\n\n    if (offset < 0) {\n\n        return offset;\n\n    }\n\n\n\n    /* Write all snapshots to the new list */\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        memset(&h, 0, sizeof(h));\n\n        h.l1_table_offset = cpu_to_be64(sn->l1_table_offset);\n\n        h.l1_size = cpu_to_be32(sn->l1_size);\n\n        /* If it doesn't fit in 32 bit, older implementations should treat it\n\n         * as a disk-only snapshot rather than truncate the VM state */\n\n        if (sn->vm_state_size <= 0xffffffff) {\n\n            h.vm_state_size = cpu_to_be32(sn->vm_state_size);\n\n        }\n\n        h.date_sec = cpu_to_be32(sn->date_sec);\n\n        h.date_nsec = cpu_to_be32(sn->date_nsec);\n\n        h.vm_clock_nsec = cpu_to_be64(sn->vm_clock_nsec);\n\n        h.extra_data_size = cpu_to_be32(sizeof(extra));\n\n\n\n        memset(&extra, 0, sizeof(extra));\n\n        extra.vm_state_size_large = cpu_to_be64(sn->vm_state_size);\n\n        extra.disk_size = cpu_to_be64(sn->disk_size);\n\n\n\n        id_str_size = strlen(sn->id_str);\n\n        name_size = strlen(sn->name);\n\n        h.id_str_size = cpu_to_be16(id_str_size);\n\n        h.name_size = cpu_to_be16(name_size);\n\n        offset = align_offset(offset, 8);\n\n\n\n        ret = bdrv_pwrite(bs->file, offset, &h, sizeof(h));\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        offset += sizeof(h);\n\n\n\n        ret = bdrv_pwrite(bs->file, offset, &extra, sizeof(extra));\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        offset += sizeof(extra);\n\n\n\n        ret = bdrv_pwrite(bs->file, offset, sn->id_str, id_str_size);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        offset += id_str_size;\n\n\n\n        ret = bdrv_pwrite(bs->file, offset, sn->name, name_size);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        offset += name_size;\n\n    }\n\n\n\n    /*\n\n     * Update the header to point to the new snapshot table. This requires the\n\n     * new table and its refcounts to be stable on disk.\n\n     */\n\n    ret = bdrv_flush(bs);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    QEMU_BUILD_BUG_ON(offsetof(QCowHeader, snapshots_offset) !=\n\n        offsetof(QCowHeader, nb_snapshots) + sizeof(header_data.nb_snapshots));\n\n\n\n    header_data.nb_snapshots        = cpu_to_be32(s->nb_snapshots);\n\n    header_data.snapshots_offset    = cpu_to_be64(snapshots_offset);\n\n\n\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, nb_snapshots),\n\n                           &header_data, sizeof(header_data));\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* free the old snapshot table */\n\n    qcow2_free_clusters(bs, s->snapshots_offset, s->snapshots_size);\n\n    s->snapshots_offset = snapshots_offset;\n\n    s->snapshots_size = snapshots_size;\n\n    return 0;\n\n\n\nfail:\n\n    return ret;\n\n}\n", "idx": 9082, "_split": "valid", "_hash": "41d192da006d57d9703a5e0097c800fe"}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void mirror_start_job(const char *job_id, BlockDriverState *bs,\n\n                             BlockDriverState *target, const char *replaces,\n\n                             int64_t speed, uint32_t granularity,\n\n                             int64_t buf_size,\n\n                             BlockMirrorBackingMode backing_mode,\n\n                             BlockdevOnError on_source_error,\n\n                             BlockdevOnError on_target_error,\n\n                             bool unmap,\n\n                             BlockCompletionFunc *cb,\n\n                             void *opaque, Error **errp,\n\n                             const BlockJobDriver *driver,\n\n                             bool is_none_mode, BlockDriverState *base)\n\n{\n\n    MirrorBlockJob *s;\n\n\n\n    if (granularity == 0) {\n\n        granularity = bdrv_get_default_bitmap_granularity(target);\n\n    }\n\n\n\n    assert ((granularity & (granularity - 1)) == 0);\n\n\n\n    if (buf_size < 0) {\n\n        error_setg(errp, \"Invalid parameter 'buf-size'\");\n\n        return;\n\n    }\n\n\n\n    if (buf_size == 0) {\n\n        buf_size = DEFAULT_MIRROR_BUF_SIZE;\n\n    }\n\n\n\n    s = block_job_create(job_id, driver, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->target = blk_new();\n\n    blk_insert_bs(s->target, target);\n\n\n\n    s->replaces = g_strdup(replaces);\n\n    s->on_source_error = on_source_error;\n\n    s->on_target_error = on_target_error;\n\n    s->is_none_mode = is_none_mode;\n\n    s->backing_mode = backing_mode;\n\n    s->base = base;\n\n    s->granularity = granularity;\n\n    s->buf_size = ROUND_UP(buf_size, granularity);\n\n    s->unmap = unmap;\n\n\n\n    s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp);\n\n    if (!s->dirty_bitmap) {\n\n        g_free(s->replaces);\n\n        blk_unref(s->target);\n\n        block_job_unref(&s->common);\n\n        return;\n\n    }\n\n\n\n    bdrv_op_block_all(target, s->common.blocker);\n\n\n\n    s->common.co = qemu_coroutine_create(mirror_run);\n\n    trace_mirror_start(bs, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}\n", "idx": 9089, "_split": "valid", "_hash": "565d01f619d54148de7ac14cf1a3b901"}
{"project": "qemu", "commit_id": "c8389550dedc65892fba9c3df29423efd802f544", "target": 1, "func": "static void vmgenid_realize(DeviceState *dev, Error **errp)\n\n{\n\n    VmGenIdState *vms = VMGENID(dev);\n\n\n\n    if (!vms->write_pointer_available) {\n\n        error_setg(errp, \"%s requires DMA write support in fw_cfg, \"\n\n                   \"which this machine type does not provide\", VMGENID_DEVICE);\n\n        return;\n\n    }\n\n\n\n    /* Given that this function is executing, there is at least one VMGENID\n\n     * device. Check if there are several.\n\n     */\n\n    if (!find_vmgenid_dev()) {\n\n        error_setg(errp, \"at most one %s device is permitted\", VMGENID_DEVICE);\n\n        return;\n\n    }\n\n\n\n    qemu_register_reset(vmgenid_handle_reset, vms);\n\n}\n", "idx": 9110, "_split": "valid", "_hash": "cf2d75b3a3d6ab3fcd863f4f24fcfabc"}
{"project": "qemu", "commit_id": "2db59a76c421cdd1039d10e32a9798952d3ff5ba", "target": 1, "func": "static void gen_window_check1(DisasContext *dc, unsigned r1)\n\n{\n\n    if (dc->tb->flags & XTENSA_TBFLAG_EXCM) {\n\n        return;\n\n    }\n\n    if (option_enabled(dc, XTENSA_OPTION_WINDOWED_REGISTER) &&\n\n            r1 / 4 > dc->used_window) {\n\n        int label = gen_new_label();\n\n        TCGv_i32 ws = tcg_temp_new_i32();\n\n\n\n        dc->used_window = r1 / 4;\n\n        tcg_gen_deposit_i32(ws, cpu_SR[WINDOW_START], cpu_SR[WINDOW_START],\n\n                dc->config->nareg / 4, dc->config->nareg / 4);\n\n        tcg_gen_shr_i32(ws, ws, cpu_SR[WINDOW_BASE]);\n\n        tcg_gen_andi_i32(ws, ws, (2 << (r1 / 4)) - 2);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, ws, 0, label);\n\n        {\n\n            TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n            TCGv_i32 w = tcg_const_i32(r1 / 4);\n\n\n\n            gen_advance_ccount_cond(dc);\n\n            gen_helper_window_check(cpu_env, pc, w);\n\n\n\n            tcg_temp_free(w);\n\n            tcg_temp_free(pc);\n\n        }\n\n        gen_set_label(label);\n\n        tcg_temp_free(ws);\n\n    }\n\n}\n", "idx": 9142, "_split": "valid", "_hash": "62b4244afc7131512d2fafa9c90aebce"}
{"project": "qemu", "commit_id": "4f298a4b2957b7833bc607c951ca27c458d98d88", "target": 1, "func": "static void set_watchdog_timer(IPMIBmcSim *ibs,\n\n                               uint8_t *cmd, unsigned int cmd_len,\n\n                               uint8_t *rsp, unsigned int *rsp_len,\n\n                               unsigned int max_rsp_len)\n\n{\n\n    IPMIInterface *s = ibs->parent.intf;\n\n    IPMIInterfaceClass *k = IPMI_INTERFACE_GET_CLASS(s);\n\n    unsigned int val;\n\n\n\n    IPMI_CHECK_CMD_LEN(8);\n\n    val = cmd[2] & 0x7; /* Validate use */\n\n    if (val == 0 || val > 5) {\n\n        rsp[2] = IPMI_CC_INVALID_DATA_FIELD;\n\n        return;\n\n    }\n\n    val = cmd[3] & 0x7; /* Validate action */\n\n    switch (val) {\n\n    case IPMI_BMC_WATCHDOG_ACTION_NONE:\n\n        break;\n\n\n\n    case IPMI_BMC_WATCHDOG_ACTION_RESET:\n\n        rsp[2] = k->do_hw_op(s, IPMI_RESET_CHASSIS, 1);\n\n        break;\n\n\n\n    case IPMI_BMC_WATCHDOG_ACTION_POWER_DOWN:\n\n        rsp[2] = k->do_hw_op(s, IPMI_POWEROFF_CHASSIS, 1);\n\n        break;\n\n\n\n    case IPMI_BMC_WATCHDOG_ACTION_POWER_CYCLE:\n\n        rsp[2] = k->do_hw_op(s, IPMI_POWERCYCLE_CHASSIS, 1);\n\n        break;\n\n\n\n    default:\n\n        rsp[2] = IPMI_CC_INVALID_DATA_FIELD;\n\n    }\n\n    if (rsp[2]) {\n\n        rsp[2] = IPMI_CC_INVALID_DATA_FIELD;\n\n        return;\n\n    }\n\n\n\n    val = (cmd[3] >> 4) & 0x7; /* Validate preaction */\n\n    switch (val) {\n\n    case IPMI_BMC_WATCHDOG_PRE_MSG_INT:\n\n    case IPMI_BMC_WATCHDOG_PRE_NONE:\n\n        break;\n\n\n\n    case IPMI_BMC_WATCHDOG_PRE_NMI:\n\n        if (!k->do_hw_op(s, IPMI_SEND_NMI, 1)) {\n\n            /* NMI not supported. */\n\n            rsp[2] = IPMI_CC_INVALID_DATA_FIELD;\n\n            return;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        /* We don't support PRE_SMI */\n\n        rsp[2] = IPMI_CC_INVALID_DATA_FIELD;\n\n        return;\n\n    }\n\n\n\n    ibs->watchdog_initialized = 1;\n\n    ibs->watchdog_use = cmd[2] & IPMI_BMC_WATCHDOG_USE_MASK;\n\n    ibs->watchdog_action = cmd[3] & IPMI_BMC_WATCHDOG_ACTION_MASK;\n\n    ibs->watchdog_pretimeout = cmd[4];\n\n    ibs->watchdog_expired &= ~cmd[5];\n\n    ibs->watchdog_timeout = cmd[6] | (((uint16_t) cmd[7]) << 8);\n\n    if (ibs->watchdog_running & IPMI_BMC_WATCHDOG_GET_DONT_STOP(ibs)) {\n\n        do_watchdog_reset(ibs);\n\n    } else {\n\n        ibs->watchdog_running = 0;\n\n    }\n\n}\n", "idx": 9146, "_split": "valid", "_hash": "43840d811ac9ae834b1fe93a36a6635b"}
{"project": "qemu", "commit_id": "9d8f818cdee83e726a5dd14b645738ec632d2577", "target": 0, "func": "int nbd_client_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)\n\n{\n\n    NBDClientSession *client = nbd_get_client_session(bs);\n\n    NBDRequest request = {\n\n        .type = NBD_CMD_TRIM,\n\n        .from = offset,\n\n        .len = bytes,\n\n    };\n\n\n\n    assert(!(client->info.flags & NBD_FLAG_READ_ONLY));\n\n    if (!(client->info.flags & NBD_FLAG_SEND_TRIM)) {\n\n        return 0;\n\n    }\n\n\n\n    return nbd_co_request(bs, &request, NULL);\n\n}\n", "idx": 9207, "_split": "valid", "_hash": "fee343c490aa1569c68baff34ee0c8d4"}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static QEMUCursor *qxl_cursor(PCIQXLDevice *qxl, QXLCursor *cursor,\n\n                              uint32_t group_id)\n\n{\n\n    QEMUCursor *c;\n\n    size_t size;\n\n\n\n    c = cursor_alloc(cursor->header.width, cursor->header.height);\n\n    c->hot_x = cursor->header.hot_spot_x;\n\n    c->hot_y = cursor->header.hot_spot_y;\n\n    switch (cursor->header.type) {\n\n    case SPICE_CURSOR_TYPE_ALPHA:\n\n        size = sizeof(uint32_t) * cursor->header.width * cursor->header.height;\n\n        qxl_unpack_chunks(c->data, size, qxl, &cursor->chunk, group_id);\n\n        if (qxl->debug > 2) {\n\n            cursor_print_ascii_art(c, \"qxl/alpha\");\n\n        }\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: not implemented: type %d\\n\",\n\n                __FUNCTION__, cursor->header.type);\n\n        goto fail;\n\n    }\n\n    return c;\n\n\n\nfail:\n\n    cursor_put(c);\n\n    return NULL;\n\n}\n", "idx": 9211, "_split": "valid", "_hash": "e59c3d8f99868729b507e03cbe79c525"}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "QFloat *qfloat_from_double(double value)\n\n{\n\n    QFloat *qf;\n\n\n\n    qf = g_malloc(sizeof(*qf));\n\n    qf->value = value;\n\n    QOBJECT_INIT(qf, &qfloat_type);\n\n\n\n    return qf;\n\n}\n", "idx": 9218, "_split": "valid", "_hash": "7b7e48a6248d3fc2ba6aa2b9f0c31545"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void *qemu_blockalign(BlockDriverState *bs, size_t size)\n\n{\n\n    return qemu_memalign(bdrv_opt_mem_align(bs), size);\n\n}\n", "idx": 9220, "_split": "valid", "_hash": "45d338c97b5307b4699927296e9738e6"}
{"project": "qemu", "commit_id": "f1c52354e5bdab6983d13a4c174759c585e834b3", "target": 0, "func": "static void spapr_drc_release(sPAPRDRConnector *drc)\n\n{\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n\n\n    drck->release(drc->dev);\n\n\n\n    drc->awaiting_release = false;\n\n    g_free(drc->fdt);\n\n    drc->fdt = NULL;\n\n    drc->fdt_start_offset = 0;\n\n    object_property_del(OBJECT(drc), \"device\", &error_abort);\n\n    drc->dev = NULL;\n\n}\n", "idx": 9226, "_split": "valid", "_hash": "b7546429156427eddaeecb6408fe566d"}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void gen_neon_narrow(int size, TCGv dest, TCGv src)\n\n{\n\n    switch (size) {\n\n    case 0: gen_helper_neon_narrow_u8(dest, src); break;\n\n    case 1: gen_helper_neon_narrow_u16(dest, src); break;\n\n    case 2: tcg_gen_trunc_i64_i32(dest, src); break;\n\n    default: abort();\n\n    }\n\n}\n", "idx": 9249, "_split": "valid", "_hash": "d1a57200eace6ddbf88b4e8d8658e874"}
{"project": "qemu", "commit_id": "daa23699031693b434ec263b212f77ba505e353e", "target": 0, "func": "int spapr_populate_pci_dt(sPAPRPHBState *phb,\n\n                          uint32_t xics_phandle,\n\n                          void *fdt)\n\n{\n\n    int bus_off, i, j, ret;\n\n    char nodename[FDT_NAME_MAX];\n\n    uint32_t bus_range[] = { cpu_to_be32(0), cpu_to_be32(0xff) };\n\n    const uint64_t mmiosize = memory_region_size(&phb->memwindow);\n\n    const uint64_t w32max = (1ULL << 32) - SPAPR_PCI_MEM_WIN_BUS_OFFSET;\n\n    const uint64_t w32size = MIN(w32max, mmiosize);\n\n    const uint64_t w64size = (mmiosize > w32size) ? (mmiosize - w32size) : 0;\n\n    struct {\n\n        uint32_t hi;\n\n        uint64_t child;\n\n        uint64_t parent;\n\n        uint64_t size;\n\n    } QEMU_PACKED ranges[] = {\n\n        {\n\n            cpu_to_be32(b_ss(1)), cpu_to_be64(0),\n\n            cpu_to_be64(phb->io_win_addr),\n\n            cpu_to_be64(memory_region_size(&phb->iospace)),\n\n        },\n\n        {\n\n            cpu_to_be32(b_ss(2)), cpu_to_be64(SPAPR_PCI_MEM_WIN_BUS_OFFSET),\n\n            cpu_to_be64(phb->mem_win_addr),\n\n            cpu_to_be64(w32size),\n\n        },\n\n        {\n\n            cpu_to_be32(b_ss(3)), cpu_to_be64(1ULL << 32),\n\n            cpu_to_be64(phb->mem_win_addr + w32size),\n\n            cpu_to_be64(w64size)\n\n        },\n\n    };\n\n    const unsigned sizeof_ranges = (w64size ? 3 : 2) * sizeof(ranges[0]);\n\n    uint64_t bus_reg[] = { cpu_to_be64(phb->buid), 0 };\n\n    uint32_t interrupt_map_mask[] = {\n\n        cpu_to_be32(b_ddddd(-1)|b_fff(0)), 0x0, 0x0, cpu_to_be32(-1)};\n\n    uint32_t interrupt_map[PCI_SLOT_MAX * PCI_NUM_PINS][7];\n\n    uint32_t ddw_applicable[] = {\n\n        cpu_to_be32(RTAS_IBM_QUERY_PE_DMA_WINDOW),\n\n        cpu_to_be32(RTAS_IBM_CREATE_PE_DMA_WINDOW),\n\n        cpu_to_be32(RTAS_IBM_REMOVE_PE_DMA_WINDOW)\n\n    };\n\n    uint32_t ddw_extensions[] = {\n\n        cpu_to_be32(1),\n\n        cpu_to_be32(RTAS_IBM_RESET_PE_DMA_WINDOW)\n\n    };\n\n    uint32_t associativity[] = {cpu_to_be32(0x4),\n\n                                cpu_to_be32(0x0),\n\n                                cpu_to_be32(0x0),\n\n                                cpu_to_be32(0x0),\n\n                                cpu_to_be32(phb->numa_node)};\n\n    sPAPRTCETable *tcet;\n\n    PCIBus *bus = PCI_HOST_BRIDGE(phb)->bus;\n\n    sPAPRFDT s_fdt;\n\n\n\n    /* Start populating the FDT */\n\n    snprintf(nodename, FDT_NAME_MAX, \"pci@%\" PRIx64, phb->buid);\n\n    bus_off = fdt_add_subnode(fdt, 0, nodename);\n\n    if (bus_off < 0) {\n\n        return bus_off;\n\n    }\n\n\n\n    /* Write PHB properties */\n\n    _FDT(fdt_setprop_string(fdt, bus_off, \"device_type\", \"pci\"));\n\n    _FDT(fdt_setprop_string(fdt, bus_off, \"compatible\", \"IBM,Logical_PHB\"));\n\n    _FDT(fdt_setprop_cell(fdt, bus_off, \"#address-cells\", 0x3));\n\n    _FDT(fdt_setprop_cell(fdt, bus_off, \"#size-cells\", 0x2));\n\n    _FDT(fdt_setprop_cell(fdt, bus_off, \"#interrupt-cells\", 0x1));\n\n    _FDT(fdt_setprop(fdt, bus_off, \"used-by-rtas\", NULL, 0));\n\n    _FDT(fdt_setprop(fdt, bus_off, \"bus-range\", &bus_range, sizeof(bus_range)));\n\n    _FDT(fdt_setprop(fdt, bus_off, \"ranges\", &ranges, sizeof_ranges));\n\n    _FDT(fdt_setprop(fdt, bus_off, \"reg\", &bus_reg, sizeof(bus_reg)));\n\n    _FDT(fdt_setprop_cell(fdt, bus_off, \"ibm,pci-config-space-type\", 0x1));\n\n    _FDT(fdt_setprop_cell(fdt, bus_off, \"ibm,pe-total-#msi\", XICS_IRQS_SPAPR));\n\n\n\n    /* Dynamic DMA window */\n\n    if (phb->ddw_enabled) {\n\n        _FDT(fdt_setprop(fdt, bus_off, \"ibm,ddw-applicable\", &ddw_applicable,\n\n                         sizeof(ddw_applicable)));\n\n        _FDT(fdt_setprop(fdt, bus_off, \"ibm,ddw-extensions\",\n\n                         &ddw_extensions, sizeof(ddw_extensions)));\n\n    }\n\n\n\n    /* Advertise NUMA via ibm,associativity */\n\n    if (nb_numa_nodes > 1) {\n\n        _FDT(fdt_setprop(fdt, bus_off, \"ibm,associativity\", associativity,\n\n                         sizeof(associativity)));\n\n    }\n\n\n\n    /* Build the interrupt-map, this must matches what is done\n\n     * in pci_spapr_map_irq\n\n     */\n\n    _FDT(fdt_setprop(fdt, bus_off, \"interrupt-map-mask\",\n\n                     &interrupt_map_mask, sizeof(interrupt_map_mask)));\n\n    for (i = 0; i < PCI_SLOT_MAX; i++) {\n\n        for (j = 0; j < PCI_NUM_PINS; j++) {\n\n            uint32_t *irqmap = interrupt_map[i*PCI_NUM_PINS + j];\n\n            int lsi_num = pci_spapr_swizzle(i, j);\n\n\n\n            irqmap[0] = cpu_to_be32(b_ddddd(i)|b_fff(0));\n\n            irqmap[1] = 0;\n\n            irqmap[2] = 0;\n\n            irqmap[3] = cpu_to_be32(j+1);\n\n            irqmap[4] = cpu_to_be32(xics_phandle);\n\n            irqmap[5] = cpu_to_be32(phb->lsi_table[lsi_num].irq);\n\n            irqmap[6] = cpu_to_be32(0x8);\n\n        }\n\n    }\n\n    /* Write interrupt map */\n\n    _FDT(fdt_setprop(fdt, bus_off, \"interrupt-map\", &interrupt_map,\n\n                     sizeof(interrupt_map)));\n\n\n\n    tcet = spapr_tce_find_by_liobn(phb->dma_liobn[0]);\n\n    if (!tcet) {\n\n        return -1;\n\n    }\n\n    spapr_dma_dt(fdt, bus_off, \"ibm,dma-window\",\n\n                 tcet->liobn, tcet->bus_offset,\n\n                 tcet->nb_table << tcet->page_shift);\n\n\n\n    /* Walk the bridges and program the bus numbers*/\n\n    spapr_phb_pci_enumerate(phb);\n\n    _FDT(fdt_setprop_cell(fdt, bus_off, \"qemu,phb-enumerated\", 0x1));\n\n\n\n    /* Populate tree nodes with PCI devices attached */\n\n    s_fdt.fdt = fdt;\n\n    s_fdt.node_off = bus_off;\n\n    s_fdt.sphb = phb;\n\n    pci_for_each_device(bus, pci_bus_num(bus),\n\n                        spapr_populate_pci_devices_dt,\n\n                        &s_fdt);\n\n\n\n    ret = spapr_drc_populate_dt(fdt, bus_off, OBJECT(phb),\n\n                                SPAPR_DR_CONNECTOR_TYPE_PCI);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9250, "_split": "valid", "_hash": "9920da11efcf0291ad20aa085a66169b"}
{"project": "qemu", "commit_id": "ffbb1705a33df8e2fb12b24d96663d63b22eaf8b", "target": 0, "func": "void spapr_dt_events(void *fdt, uint32_t check_exception_irq)\n\n{\n\n    int event_sources, epow_events;\n\n    uint32_t irq_ranges[] = {cpu_to_be32(check_exception_irq), cpu_to_be32(1)};\n\n    uint32_t interrupts[] = {cpu_to_be32(check_exception_irq), 0};\n\n\n\n    _FDT(event_sources = fdt_add_subnode(fdt, 0, \"event-sources\"));\n\n\n\n    _FDT(fdt_setprop(fdt, event_sources, \"interrupt-controller\", NULL, 0));\n\n    _FDT(fdt_setprop_cell(fdt, event_sources, \"#interrupt-cells\", 2));\n\n    _FDT(fdt_setprop(fdt, event_sources, \"interrupt-ranges\",\n\n                     irq_ranges, sizeof(irq_ranges)));\n\n\n\n    _FDT(epow_events = fdt_add_subnode(fdt, event_sources, \"epow-events\"));\n\n    _FDT(fdt_setprop(fdt, epow_events, \"interrupts\",\n\n                     interrupts, sizeof(interrupts)));\n\n}\n", "idx": 9307, "_split": "valid", "_hash": "64672ead44e95b5ce97ca1863630c27b"}
{"project": "qemu", "commit_id": "585ea0c841df47c1542d33e17c5c6d532316ef74", "target": 1, "func": "static int vmdk_write(BlockDriverState *bs, int64_t sector_num,\n\n                      const uint8_t *buf, int nb_sectors,\n\n                      bool zeroed, bool zero_dry_run)\n\n{\n\n    BDRVVmdkState *s = bs->opaque;\n\n    VmdkExtent *extent = NULL;\n\n    int n, ret;\n\n    int64_t index_in_cluster;\n\n    uint64_t extent_begin_sector, extent_relative_sector_num;\n\n    uint64_t cluster_offset;\n\n    VmdkMetaData m_data;\n\n\n\n    if (sector_num > bs->total_sectors) {\n\n        error_report(\"Wrong offset: sector_num=0x%\" PRIx64\n\n                \" total_sectors=0x%\" PRIx64 \"\\n\",\n\n                sector_num, bs->total_sectors);\n\n        return -EIO;\n\n    }\n\n\n\n    while (nb_sectors > 0) {\n\n        extent = find_extent(s, sector_num, extent);\n\n        if (!extent) {\n\n            return -EIO;\n\n        }\n\n        ret = get_cluster_offset(\n\n                                bs,\n\n                                extent,\n\n                                &m_data,\n\n                                sector_num << 9, !extent->compressed,\n\n                                &cluster_offset);\n\n        if (extent->compressed) {\n\n            if (ret == VMDK_OK) {\n\n                /* Refuse write to allocated cluster for streamOptimized */\n\n                error_report(\"Could not write to allocated cluster\"\n\n                              \" for streamOptimized\");\n\n                return -EIO;\n\n            } else {\n\n                /* allocate */\n\n                ret = get_cluster_offset(\n\n                                        bs,\n\n                                        extent,\n\n                                        &m_data,\n\n                                        sector_num << 9, 1,\n\n                                        &cluster_offset);\n\n            }\n\n        }\n\n        if (ret == VMDK_ERROR) {\n\n            return -EINVAL;\n\n        }\n\n        extent_begin_sector = extent->end_sector - extent->sectors;\n\n        extent_relative_sector_num = sector_num - extent_begin_sector;\n\n        index_in_cluster = extent_relative_sector_num % extent->cluster_sectors;\n\n        n = extent->cluster_sectors - index_in_cluster;\n\n        if (n > nb_sectors) {\n\n            n = nb_sectors;\n\n        }\n\n        if (zeroed) {\n\n            /* Do zeroed write, buf is ignored */\n\n            if (extent->has_zero_grain &&\n\n                    index_in_cluster == 0 &&\n\n                    n >= extent->cluster_sectors) {\n\n                n = extent->cluster_sectors;\n\n                if (!zero_dry_run) {\n\n                    m_data.offset = VMDK_GTE_ZEROED;\n\n                    /* update L2 tables */\n\n                    if (vmdk_L2update(extent, &m_data) != VMDK_OK) {\n\n                        return -EIO;\n\n                    }\n\n                }\n\n            } else {\n\n                return -ENOTSUP;\n\n            }\n\n        } else {\n\n            ret = vmdk_write_extent(extent,\n\n                            cluster_offset, index_in_cluster * 512,\n\n                            buf, n, sector_num);\n\n            if (ret) {\n\n                return ret;\n\n            }\n\n            if (m_data.valid) {\n\n                /* update L2 tables */\n\n                if (vmdk_L2update(extent, &m_data) != VMDK_OK) {\n\n                    return -EIO;\n\n                }\n\n            }\n\n        }\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n\n\n        /* update CID on the first write every time the virtual disk is\n\n         * opened */\n\n        if (!s->cid_updated) {\n\n            ret = vmdk_write_cid(bs, time(NULL));\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n            s->cid_updated = true;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 9333, "_split": "valid", "_hash": "5660de071ee8569f7349f145f3e0c702"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qmp_migrate_set_capabilities(MigrationCapabilityStatusList *params,\n\n                                  Error **errp)\n\n{\n\n    MigrationState *s = migrate_get_current();\n\n    MigrationCapabilityStatusList *cap;\n\n\n\n    if (s->state == MIG_STATE_ACTIVE || s->state == MIG_STATE_SETUP) {\n\n        error_set(errp, QERR_MIGRATION_ACTIVE);\n\n        return;\n\n    }\n\n\n\n    for (cap = params; cap; cap = cap->next) {\n\n        s->enabled_capabilities[cap->value->capability] = cap->value->state;\n\n    }\n\n}\n", "idx": 9334, "_split": "valid", "_hash": "b8760905e20cdc1f0b14fa20ac8ab8ee"}
{"project": "qemu", "commit_id": "635db18f68ded6abec11cd4cf64ebc15c1c6b190", "target": 1, "func": "void qmp_qmp_capabilities(Error **errp)\n\n{\n\n    cur_mon->qmp.in_command_mode = true;\n\n}\n", "idx": 9346, "_split": "valid", "_hash": "3fb1e007cdb6c2d38972a255d734d5c1"}
{"project": "qemu", "commit_id": "a78b1299f1bbb9608e3e3a36a7f16cf700a2789d", "target": 0, "func": "static inline int handle_cpu_signal(uintptr_t pc, unsigned long address,\n\n                                    int is_write, sigset_t *old_set)\n\n{\n\n    CPUState *cpu = current_cpu;\n\n    CPUClass *cc;\n\n    int ret;\n\n\n\n    /* We must handle PC addresses from two different sources:\n\n     * a call return address and a signal frame address.\n\n     *\n\n     * Within cpu_restore_state_from_tb we assume the former and adjust\n\n     * the address by -GETPC_ADJ so that the address is within the call\n\n     * insn so that addr does not accidentally match the beginning of the\n\n     * next guest insn.\n\n     *\n\n     * However, when the PC comes from the signal frame, it points to\n\n     * the actual faulting host insn and not a call insn.  Subtracting\n\n     * GETPC_ADJ in that case may accidentally match the previous guest insn.\n\n     *\n\n     * So for the later case, adjust forward to compensate for what\n\n     * will be done later by cpu_restore_state_from_tb.\n\n     */\n\n    if (helper_retaddr) {\n\n        pc = helper_retaddr;\n\n    } else {\n\n        pc += GETPC_ADJ;\n\n    }\n\n\n\n    /* For synchronous signals we expect to be coming from the vCPU\n\n     * thread (so current_cpu should be valid) and either from running\n\n     * code or during translation which can fault as we cross pages.\n\n     *\n\n     * If neither is true then something has gone wrong and we should\n\n     * abort rather than try and restart the vCPU execution.\n\n     */\n\n    if (!cpu || !cpu->running) {\n\n        printf(\"qemu:%s received signal outside vCPU context @ pc=0x%\"\n\n               PRIxPTR \"\\n\",  __func__, pc);\n\n        abort();\n\n    }\n\n\n\n#if defined(DEBUG_SIGNAL)\n\n    printf(\"qemu: SIGSEGV pc=0x%08lx address=%08lx w=%d oldset=0x%08lx\\n\",\n\n           pc, address, is_write, *(unsigned long *)old_set);\n\n#endif\n\n    /* XXX: locking issue */\n\n    if (is_write && h2g_valid(address)) {\n\n        switch (page_unprotect(h2g(address), pc)) {\n\n        case 0:\n\n            /* Fault not caused by a page marked unwritable to protect\n\n             * cached translations, must be the guest binary's problem.\n\n             */\n\n            break;\n\n        case 1:\n\n            /* Fault caused by protection of cached translation; TBs\n\n             * invalidated, so resume execution.  Retain helper_retaddr\n\n             * for a possible second fault.\n\n             */\n\n            return 1;\n\n        case 2:\n\n            /* Fault caused by protection of cached translation, and the\n\n             * currently executing TB was modified and must be exited\n\n             * immediately.  Clear helper_retaddr for next execution.\n\n             */\n\n            helper_retaddr = 0;\n\n            cpu_exit_tb_from_sighandler(cpu, old_set);\n\n            /* NORETURN */\n\n\n\n        default:\n\n            g_assert_not_reached();\n\n        }\n\n    }\n\n\n\n    /* Convert forcefully to guest address space, invalid addresses\n\n       are still valid segv ones */\n\n    address = h2g_nocheck(address);\n\n\n\n    cc = CPU_GET_CLASS(cpu);\n\n    /* see if it is an MMU fault */\n\n    g_assert(cc->handle_mmu_fault);\n\n    ret = cc->handle_mmu_fault(cpu, address, is_write, MMU_USER_IDX);\n\n\n\n    if (ret == 0) {\n\n        /* The MMU fault was handled without causing real CPU fault.\n\n         *  Retain helper_retaddr for a possible second fault.\n\n         */\n\n        return 1;\n\n    }\n\n\n\n    /* All other paths lead to cpu_exit; clear helper_retaddr\n\n     * for next execution.\n\n     */\n\n    helper_retaddr = 0;\n\n\n\n    if (ret < 0) {\n\n        return 0; /* not an MMU fault */\n\n    }\n\n\n\n    /* Now we have a real cpu fault.  */\n\n    cpu_restore_state(cpu, pc);\n\n\n\n    sigprocmask(SIG_SETMASK, old_set, NULL);\n\n    cpu_loop_exit(cpu);\n\n\n\n    /* never comes here */\n\n    return 1;\n\n}\n", "idx": 9375, "_split": "valid", "_hash": "1eb8f6cb2922ab903fef620851a30a13"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline bool media_is_cd(SCSIDiskState *s)\n\n{\n\n    uint64_t nb_sectors;\n\n    if (s->qdev.type != TYPE_ROM) {\n\n        return false;\n\n    }\n\n    if (!bdrv_is_inserted(s->qdev.conf.bs)) {\n\n        return false;\n\n    }\n\n    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n    return nb_sectors <= CD_MAX_SECTORS;\n\n}\n", "idx": 9390, "_split": "valid", "_hash": "2df63812f277eef1df9a8a650416d665"}
{"project": "qemu", "commit_id": "f41152bd9d01ab327c19a3828bb7896d67cf0752", "target": 1, "func": "static void lm32_uclinux_init(QEMUMachineInitArgs *args)\n{\n    const char *cpu_model = args->cpu_model;\n    const char *kernel_filename = args->kernel_filename;\n    const char *kernel_cmdline = args->kernel_cmdline;\n    const char *initrd_filename = args->initrd_filename;\n    LM32CPU *cpu;\n    CPULM32State *env;\n    DriveInfo *dinfo;\n    MemoryRegion *address_space_mem =  get_system_memory();\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n    qemu_irq *cpu_irq, irq[32];\n    HWSetup *hw;\n    ResetInfo *reset_info;\n    int i;\n    /* memory map */\n    hwaddr flash_base   = 0x04000000;\n    size_t flash_sector_size        = 256 * 1024;\n    size_t flash_size               = 32 * 1024 * 1024;\n    hwaddr ram_base     = 0x08000000;\n    size_t ram_size                 = 64 * 1024 * 1024;\n    hwaddr uart0_base   = 0x80000000;\n    hwaddr timer0_base  = 0x80002000;\n    hwaddr timer1_base  = 0x80010000;\n    hwaddr timer2_base  = 0x80012000;\n    int uart0_irq                   = 0;\n    int timer0_irq                  = 1;\n    int timer1_irq                  = 20;\n    int timer2_irq                  = 21;\n    hwaddr hwsetup_base = 0x0bffe000;\n    hwaddr cmdline_base = 0x0bfff000;\n    hwaddr initrd_base  = 0x08400000;\n    size_t initrd_max               = 0x01000000;\n    reset_info = g_malloc0(sizeof(ResetInfo));\n    if (cpu_model == NULL) {\n        cpu_model = \"lm32-full\";\n    cpu = cpu_lm32_init(cpu_model);\n    env = &cpu->env;\n    reset_info->cpu = cpu;\n    reset_info->flash_base = flash_base;\n    memory_region_init_ram(phys_ram, NULL, \"lm32_uclinux.sdram\", ram_size);\n    vmstate_register_ram_global(phys_ram);\n    memory_region_add_subregion(address_space_mem, ram_base, phys_ram);\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n    /* Spansion S29NS128P */\n    pflash_cfi02_register(flash_base, NULL, \"lm32_uclinux.flash\", flash_size,\n                          dinfo ? dinfo->bdrv : NULL, flash_sector_size,\n                          flash_size / flash_sector_size, 1, 2,\n                          0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1);\n    /* create irq lines */\n    cpu_irq = qemu_allocate_irqs(cpu_irq_handler, env, 1);\n    env->pic_state = lm32_pic_init(*cpu_irq);\n    for (i = 0; i < 32; i++) {\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n    sysbus_create_simple(\"lm32-uart\", uart0_base, irq[uart0_irq]);\n    sysbus_create_simple(\"lm32-timer\", timer0_base, irq[timer0_irq]);\n    sysbus_create_simple(\"lm32-timer\", timer1_base, irq[timer1_irq]);\n    sysbus_create_simple(\"lm32-timer\", timer2_base, irq[timer2_irq]);\n    /* make sure juart isn't the first chardev */\n    env->juart_state = lm32_juart_init();\n    reset_info->bootstrap_pc = flash_base;\n    if (kernel_filename) {\n        uint64_t entry;\n        int kernel_size;\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n                               1, ELF_MACHINE, 0);\n        reset_info->bootstrap_pc = entry;\n        if (kernel_size < 0) {\n            kernel_size = load_image_targphys(kernel_filename, ram_base,\n                                              ram_size);\n            reset_info->bootstrap_pc = ram_base;\n        if (kernel_size < 0) {\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n                    kernel_filename);\n    /* generate a rom with the hardware description */\n    hw = hwsetup_init();\n    hwsetup_add_cpu(hw, \"LM32\", 75000000);\n    hwsetup_add_flash(hw, \"flash\", flash_base, flash_size);\n    hwsetup_add_ddr_sdram(hw, \"ddr_sdram\", ram_base, ram_size);\n    hwsetup_add_timer(hw, \"timer0\", timer0_base, timer0_irq);\n    hwsetup_add_timer(hw, \"timer1_dev_only\", timer1_base, timer1_irq);\n    hwsetup_add_timer(hw, \"timer2_dev_only\", timer2_base, timer2_irq);\n    hwsetup_add_uart(hw, \"uart\", uart0_base, uart0_irq);\n    hwsetup_add_trailer(hw);\n    hwsetup_create_rom(hw, hwsetup_base);\n    hwsetup_free(hw);\n    reset_info->hwsetup_base = hwsetup_base;\n    if (kernel_cmdline && strlen(kernel_cmdline)) {\n        pstrcpy_targphys(\"cmdline\", cmdline_base, TARGET_PAGE_SIZE,\n                kernel_cmdline);\n        reset_info->cmdline_base = cmdline_base;\n    if (initrd_filename) {\n        size_t initrd_size;\n        initrd_size = load_image_targphys(initrd_filename, initrd_base,\n                initrd_max);\n        reset_info->initrd_base = initrd_base;\n        reset_info->initrd_size = initrd_size;\n    qemu_register_reset(main_cpu_reset, reset_info);", "idx": 9400, "_split": "valid", "_hash": "b2ddea35da2499af133bd48b773dc26a"}
{"project": "qemu", "commit_id": "c99a55d38dd5b5131f3fcbbaf41828a09ee62544", "target": 1, "func": "static void arm_cpu_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    CPUState *cs = CPU(dev);\n\n    ARMCPU *cpu = ARM_CPU(dev);\n\n    ARMCPUClass *acc = ARM_CPU_GET_CLASS(dev);\n\n    CPUARMState *env = &cpu->env;\n\n    int pagebits;\n\n    Error *local_err = NULL;\n\n\n\n    cpu_exec_realizefn(cs, &local_err);\n\n    if (local_err != NULL) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    /* Some features automatically imply others: */\n\n    if (arm_feature(env, ARM_FEATURE_V8)) {\n\n        set_feature(env, ARM_FEATURE_V7);\n\n        set_feature(env, ARM_FEATURE_ARM_DIV);\n\n        set_feature(env, ARM_FEATURE_LPAE);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V7)) {\n\n        set_feature(env, ARM_FEATURE_VAPA);\n\n        set_feature(env, ARM_FEATURE_THUMB2);\n\n        set_feature(env, ARM_FEATURE_MPIDR);\n\n        if (!arm_feature(env, ARM_FEATURE_M)) {\n\n            set_feature(env, ARM_FEATURE_V6K);\n\n        } else {\n\n            set_feature(env, ARM_FEATURE_V6);\n\n        }\n\n\n\n        /* Always define VBAR for V7 CPUs even if it doesn't exist in\n\n         * non-EL3 configs. This is needed by some legacy boards.\n\n         */\n\n        set_feature(env, ARM_FEATURE_VBAR);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V6K)) {\n\n        set_feature(env, ARM_FEATURE_V6);\n\n        set_feature(env, ARM_FEATURE_MVFR);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V6)) {\n\n        set_feature(env, ARM_FEATURE_V5);\n\n\n        if (!arm_feature(env, ARM_FEATURE_M)) {\n\n            set_feature(env, ARM_FEATURE_AUXCR);\n\n        }\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V5)) {\n\n        set_feature(env, ARM_FEATURE_V4T);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        set_feature(env, ARM_FEATURE_THUMB_DIV);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_ARM_DIV)) {\n\n        set_feature(env, ARM_FEATURE_THUMB_DIV);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_VFP4)) {\n\n        set_feature(env, ARM_FEATURE_VFP3);\n\n        set_feature(env, ARM_FEATURE_VFP_FP16);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_VFP3)) {\n\n        set_feature(env, ARM_FEATURE_VFP);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_LPAE)) {\n\n        set_feature(env, ARM_FEATURE_V7MP);\n\n        set_feature(env, ARM_FEATURE_PXN);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_CBAR_RO)) {\n\n        set_feature(env, ARM_FEATURE_CBAR);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_THUMB2) &&\n\n        !arm_feature(env, ARM_FEATURE_M)) {\n\n        set_feature(env, ARM_FEATURE_THUMB_DSP);\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_V7) &&\n\n        !arm_feature(env, ARM_FEATURE_M) &&\n\n        !arm_feature(env, ARM_FEATURE_PMSA)) {\n\n        /* v7VMSA drops support for the old ARMv5 tiny pages, so we\n\n         * can use 4K pages.\n\n         */\n\n        pagebits = 12;\n\n    } else {\n\n        /* For CPUs which might have tiny 1K pages, or which have an\n\n         * MPU and might have small region sizes, stick with 1K pages.\n\n         */\n\n        pagebits = 10;\n\n    }\n\n    if (!set_preferred_target_page_bits(pagebits)) {\n\n        /* This can only ever happen for hotplugging a CPU, or if\n\n         * the board code incorrectly creates a CPU which it has\n\n         * promised via minimum_page_size that it will not.\n\n         */\n\n        error_setg(errp, \"This CPU requires a smaller page size than the \"\n\n                   \"system is using\");\n\n        return;\n\n    }\n\n\n\n    /* This cpu-id-to-MPIDR affinity is used only for TCG; KVM will override it.\n\n     * We don't support setting cluster ID ([16..23]) (known as Aff2\n\n     * in later ARM ARM versions), or any of the higher affinity level fields,\n\n     * so these bits always RAZ.\n\n     */\n\n    if (cpu->mp_affinity == ARM64_AFFINITY_INVALID) {\n\n        cpu->mp_affinity = arm_cpu_mp_affinity(cs->cpu_index,\n\n                                               ARM_DEFAULT_CPUS_PER_CLUSTER);\n\n    }\n\n\n\n    if (cpu->reset_hivecs) {\n\n            cpu->reset_sctlr |= (1 << 13);\n\n    }\n\n\n\n    if (cpu->cfgend) {\n\n        if (arm_feature(&cpu->env, ARM_FEATURE_V7)) {\n\n            cpu->reset_sctlr |= SCTLR_EE;\n\n        } else {\n\n            cpu->reset_sctlr |= SCTLR_B;\n\n        }\n\n    }\n\n\n\n    if (!cpu->has_el3) {\n\n        /* If the has_el3 CPU property is disabled then we need to disable the\n\n         * feature.\n\n         */\n\n        unset_feature(env, ARM_FEATURE_EL3);\n\n\n\n        /* Disable the security extension feature bits in the processor feature\n\n         * registers as well. These are id_pfr1[7:4] and id_aa64pfr0[15:12].\n\n         */\n\n        cpu->id_pfr1 &= ~0xf0;\n\n        cpu->id_aa64pfr0 &= ~0xf000;\n\n    }\n\n\n\n    if (!cpu->has_el2) {\n\n        unset_feature(env, ARM_FEATURE_EL2);\n\n    }\n\n\n\n    if (!cpu->has_pmu) {\n\n        unset_feature(env, ARM_FEATURE_PMU);\n\n        cpu->id_aa64dfr0 &= ~0xf00;\n\n    }\n\n\n\n    if (!arm_feature(env, ARM_FEATURE_EL2)) {\n\n        /* Disable the hypervisor feature bits in the processor feature\n\n         * registers if we don't have EL2. These are id_pfr1[15:12] and\n\n         * id_aa64pfr0_el1[11:8].\n\n         */\n\n        cpu->id_aa64pfr0 &= ~0xf00;\n\n        cpu->id_pfr1 &= ~0xf000;\n\n    }\n\n\n\n    /* MPU can be configured out of a PMSA CPU either by setting has-mpu\n\n     * to false or by setting pmsav7-dregion to 0.\n\n     */\n\n    if (!cpu->has_mpu) {\n\n        cpu->pmsav7_dregion = 0;\n\n    }\n\n    if (cpu->pmsav7_dregion == 0) {\n\n        cpu->has_mpu = false;\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_PMSA) &&\n\n        arm_feature(env, ARM_FEATURE_V7)) {\n\n        uint32_t nr = cpu->pmsav7_dregion;\n\n\n\n        if (nr > 0xff) {\n\n            error_setg(errp, \"PMSAv7 MPU #regions invalid %\" PRIu32, nr);\n\n            return;\n\n        }\n\n\n\n        if (nr) {\n\n            if (arm_feature(env, ARM_FEATURE_V8)) {\n\n                /* PMSAv8 */\n\n                env->pmsav8.rbar[M_REG_NS] = g_new0(uint32_t, nr);\n\n                env->pmsav8.rlar[M_REG_NS] = g_new0(uint32_t, nr);\n\n                if (arm_feature(env, ARM_FEATURE_M_SECURITY)) {\n\n                    env->pmsav8.rbar[M_REG_S] = g_new0(uint32_t, nr);\n\n                    env->pmsav8.rlar[M_REG_S] = g_new0(uint32_t, nr);\n\n                }\n\n            } else {\n\n                env->pmsav7.drbar = g_new0(uint32_t, nr);\n\n                env->pmsav7.drsr = g_new0(uint32_t, nr);\n\n                env->pmsav7.dracr = g_new0(uint32_t, nr);\n\n            }\n\n        }\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_EL3)) {\n\n        set_feature(env, ARM_FEATURE_VBAR);\n\n    }\n\n\n\n    register_cp_regs_for_features(cpu);\n\n    arm_cpu_register_gdb_regs_for_features(cpu);\n\n\n\n    init_cpreg_list(cpu);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if (cpu->has_el3 || arm_feature(env, ARM_FEATURE_M_SECURITY)) {\n\n        AddressSpace *as;\n\n\n\n        cs->num_ases = 2;\n\n\n\n        if (!cpu->secure_memory) {\n\n            cpu->secure_memory = cs->memory;\n\n        }\n\n        as = address_space_init_shareable(cpu->secure_memory,\n\n                                          \"cpu-secure-memory\");\n\n        cpu_address_space_init(cs, as, ARMASIdx_S);\n\n    } else {\n\n        cs->num_ases = 1;\n\n    }\n\n\n\n    cpu_address_space_init(cs,\n\n                           address_space_init_shareable(cs->memory,\n\n                                                        \"cpu-memory\"),\n\n                           ARMASIdx_NS);\n\n#endif\n\n\n\n    qemu_init_vcpu(cs);\n\n    cpu_reset(cs);\n\n\n\n    acc->parent_realize(dev, errp);\n\n}", "idx": 9439, "_split": "valid", "_hash": "b1defaff4127f2cc9071ea4d23927963"}
{"project": "qemu", "commit_id": "e2dd21e510ed66daeb4c5d58638450c1fb8c6fea", "target": 1, "func": "static void wait_for_serial(const char *side)\n\n{\n\n    char *serialpath = g_strdup_printf(\"%s/%s\", tmpfs, side);\n\n    FILE *serialfile = fopen(serialpath, \"r\");\n\n    const char *arch = qtest_get_arch();\n\n    int started = (strcmp(side, \"src_serial\") == 0 &&\n\n                   strcmp(arch, \"ppc64\") == 0) ? 0 : 1;\n\n\n\n    do {\n\n        int readvalue = fgetc(serialfile);\n\n\n\n        if (!started) {\n\n            /* SLOF prints its banner before starting test,\n\n             * to ignore it, mark the start of the test with '_',\n\n             * ignore all characters until this marker\n\n             */\n\n            switch (readvalue) {\n\n            case '_':\n\n                started = 1;\n\n                break;\n\n            case EOF:\n\n                fseek(serialfile, 0, SEEK_SET);\n\n                usleep(1000);\n\n                break;\n\n            }\n\n            continue;\n\n        }\n\n        switch (readvalue) {\n\n        case 'A':\n\n            /* Fine */\n\n            break;\n\n\n\n        case 'B':\n\n            /* It's alive! */\n\n            fclose(serialfile);\n\n            g_free(serialpath);\n\n            return;\n\n\n\n        case EOF:\n\n            started = (strcmp(side, \"src_serial\") == 0 &&\n\n                       strcmp(arch, \"ppc64\") == 0) ? 0 : 1;\n\n            fseek(serialfile, 0, SEEK_SET);\n\n            usleep(1000);\n\n            break;\n\n\n\n        default:\n\n            fprintf(stderr, \"Unexpected %d on %s serial\\n\", readvalue, side);\n\n            g_assert_not_reached();\n\n        }\n\n    } while (true);\n\n}\n", "idx": 9441, "_split": "valid", "_hash": "780ce219fda3a3244babc56264dfe284"}
{"project": "qemu", "commit_id": "ebfe27c593e5b222aa2a1fc545b447be3d995faa", "target": 1, "func": "static void disas_thumb_insn(CPUARMState *env, DisasContext *s)\n\n{\n\n    uint32_t val, insn, op, rm, rn, rd, shift, cond;\n\n    int32_t offset;\n\n    int i;\n\n    TCGv_i32 tmp;\n\n    TCGv_i32 tmp2;\n\n    TCGv_i32 addr;\n\n\n\n    if (s->condexec_mask) {\n\n        cond = s->condexec_cond;\n\n        if (cond != 0x0e) {     /* Skip conditional when condition is AL. */\n\n          s->condlabel = gen_new_label();\n\n          arm_gen_test_cc(cond ^ 1, s->condlabel);\n\n          s->condjmp = 1;\n\n        }\n\n    }\n\n\n\n    insn = arm_lduw_code(env, s->pc, s->sctlr_b);\n\n    s->pc += 2;\n\n\n\n    switch (insn >> 12) {\n\n    case 0: case 1:\n\n\n\n        rd = insn & 7;\n\n        op = (insn >> 11) & 3;\n\n        if (op == 3) {\n\n            /* add/subtract */\n\n            rn = (insn >> 3) & 7;\n\n            tmp = load_reg(s, rn);\n\n            if (insn & (1 << 10)) {\n\n                /* immediate */\n\n                tmp2 = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(tmp2, (insn >> 6) & 7);\n\n            } else {\n\n                /* reg */\n\n                rm = (insn >> 6) & 7;\n\n                tmp2 = load_reg(s, rm);\n\n            }\n\n            if (insn & (1 << 9)) {\n\n                if (s->condexec_mask)\n\n                    tcg_gen_sub_i32(tmp, tmp, tmp2);\n\n                else\n\n                    gen_sub_CC(tmp, tmp, tmp2);\n\n            } else {\n\n                if (s->condexec_mask)\n\n                    tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                else\n\n                    gen_add_CC(tmp, tmp, tmp2);\n\n            }\n\n            tcg_temp_free_i32(tmp2);\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* shift immediate */\n\n            rm = (insn >> 3) & 7;\n\n            shift = (insn >> 6) & 0x1f;\n\n            tmp = load_reg(s, rm);\n\n            gen_arm_shift_im(tmp, op, shift, s->condexec_mask == 0);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            store_reg(s, rd, tmp);\n\n        }\n\n        break;\n\n    case 2: case 3:\n\n        /* arithmetic large immediate */\n\n        op = (insn >> 11) & 3;\n\n        rd = (insn >> 8) & 0x7;\n\n        if (op == 0) { /* mov */\n\n            tmp = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp, insn & 0xff);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            tmp = load_reg(s, rd);\n\n            tmp2 = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp2, insn & 0xff);\n\n            switch (op) {\n\n            case 1: /* cmp */\n\n                gen_sub_CC(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp);\n\n                tcg_temp_free_i32(tmp2);\n\n                break;\n\n            case 2: /* add */\n\n                if (s->condexec_mask)\n\n                    tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                else\n\n                    gen_add_CC(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                store_reg(s, rd, tmp);\n\n                break;\n\n            case 3: /* sub */\n\n                if (s->condexec_mask)\n\n                    tcg_gen_sub_i32(tmp, tmp, tmp2);\n\n                else\n\n                    gen_sub_CC(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                store_reg(s, rd, tmp);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    case 4:\n\n        if (insn & (1 << 11)) {\n\n            rd = (insn >> 8) & 7;\n\n            /* load pc-relative.  Bit 1 of PC is ignored.  */\n\n            val = s->pc + 2 + ((insn & 0xff) * 4);\n\n            val &= ~(uint32_t)2;\n\n            addr = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(addr, val);\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld32u_iss(s, tmp, addr, get_mem_index(s),\n\n                               rd | ISSIs16Bit);\n\n            tcg_temp_free_i32(addr);\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        }\n\n        if (insn & (1 << 10)) {\n\n            /* data processing extended or blx */\n\n            rd = (insn & 7) | ((insn >> 4) & 8);\n\n            rm = (insn >> 3) & 0xf;\n\n            op = (insn >> 8) & 3;\n\n            switch (op) {\n\n            case 0: /* add */\n\n                tmp = load_reg(s, rd);\n\n                tmp2 = load_reg(s, rm);\n\n                tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                store_reg(s, rd, tmp);\n\n                break;\n\n            case 1: /* cmp */\n\n                tmp = load_reg(s, rd);\n\n                tmp2 = load_reg(s, rm);\n\n                gen_sub_CC(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                tcg_temp_free_i32(tmp);\n\n                break;\n\n            case 2: /* mov/cpy */\n\n                tmp = load_reg(s, rm);\n\n                store_reg(s, rd, tmp);\n\n                break;\n\n            case 3:/* branch [and link] exchange thumb register */\n\n                tmp = load_reg(s, rm);\n\n                if (insn & (1 << 7)) {\n\n                    ARCH(5);\n\n                    val = (uint32_t)s->pc | 1;\n\n                    tmp2 = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(tmp2, val);\n\n                    store_reg(s, 14, tmp2);\n\n                    gen_bx(s, tmp);\n\n                } else {\n\n                    /* Only BX works as exception-return, not BLX */\n\n                    gen_bx_excret(s, tmp);\n\n                }\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n\n\n        /* data processing register */\n\n        rd = insn & 7;\n\n        rm = (insn >> 3) & 7;\n\n        op = (insn >> 6) & 0xf;\n\n        if (op == 2 || op == 3 || op == 4 || op == 7) {\n\n            /* the shift/rotate ops want the operands backwards */\n\n            val = rm;\n\n            rm = rd;\n\n            rd = val;\n\n            val = 1;\n\n        } else {\n\n            val = 0;\n\n        }\n\n\n\n        if (op == 9) { /* neg */\n\n            tmp = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp, 0);\n\n        } else if (op != 0xf) { /* mvn doesn't read its first operand */\n\n            tmp = load_reg(s, rd);\n\n        } else {\n\n            TCGV_UNUSED_I32(tmp);\n\n        }\n\n\n\n        tmp2 = load_reg(s, rm);\n\n        switch (op) {\n\n        case 0x0: /* and */\n\n            tcg_gen_and_i32(tmp, tmp, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            break;\n\n        case 0x1: /* eor */\n\n            tcg_gen_xor_i32(tmp, tmp, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            break;\n\n        case 0x2: /* lsl */\n\n            if (s->condexec_mask) {\n\n                gen_shl(tmp2, tmp2, tmp);\n\n            } else {\n\n                gen_helper_shl_cc(tmp2, cpu_env, tmp2, tmp);\n\n                gen_logic_CC(tmp2);\n\n            }\n\n            break;\n\n        case 0x3: /* lsr */\n\n            if (s->condexec_mask) {\n\n                gen_shr(tmp2, tmp2, tmp);\n\n            } else {\n\n                gen_helper_shr_cc(tmp2, cpu_env, tmp2, tmp);\n\n                gen_logic_CC(tmp2);\n\n            }\n\n            break;\n\n        case 0x4: /* asr */\n\n            if (s->condexec_mask) {\n\n                gen_sar(tmp2, tmp2, tmp);\n\n            } else {\n\n                gen_helper_sar_cc(tmp2, cpu_env, tmp2, tmp);\n\n                gen_logic_CC(tmp2);\n\n            }\n\n            break;\n\n        case 0x5: /* adc */\n\n            if (s->condexec_mask) {\n\n                gen_adc(tmp, tmp2);\n\n            } else {\n\n                gen_adc_CC(tmp, tmp, tmp2);\n\n            }\n\n            break;\n\n        case 0x6: /* sbc */\n\n            if (s->condexec_mask) {\n\n                gen_sub_carry(tmp, tmp, tmp2);\n\n            } else {\n\n                gen_sbc_CC(tmp, tmp, tmp2);\n\n            }\n\n            break;\n\n        case 0x7: /* ror */\n\n            if (s->condexec_mask) {\n\n                tcg_gen_andi_i32(tmp, tmp, 0x1f);\n\n                tcg_gen_rotr_i32(tmp2, tmp2, tmp);\n\n            } else {\n\n                gen_helper_ror_cc(tmp2, cpu_env, tmp2, tmp);\n\n                gen_logic_CC(tmp2);\n\n            }\n\n            break;\n\n        case 0x8: /* tst */\n\n            tcg_gen_and_i32(tmp, tmp, tmp2);\n\n            gen_logic_CC(tmp);\n\n            rd = 16;\n\n            break;\n\n        case 0x9: /* neg */\n\n            if (s->condexec_mask)\n\n                tcg_gen_neg_i32(tmp, tmp2);\n\n            else\n\n                gen_sub_CC(tmp, tmp, tmp2);\n\n            break;\n\n        case 0xa: /* cmp */\n\n            gen_sub_CC(tmp, tmp, tmp2);\n\n            rd = 16;\n\n            break;\n\n        case 0xb: /* cmn */\n\n            gen_add_CC(tmp, tmp, tmp2);\n\n            rd = 16;\n\n            break;\n\n        case 0xc: /* orr */\n\n            tcg_gen_or_i32(tmp, tmp, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            break;\n\n        case 0xd: /* mul */\n\n            tcg_gen_mul_i32(tmp, tmp, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            break;\n\n        case 0xe: /* bic */\n\n            tcg_gen_andc_i32(tmp, tmp, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            break;\n\n        case 0xf: /* mvn */\n\n            tcg_gen_not_i32(tmp2, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp2);\n\n            val = 1;\n\n            rm = rd;\n\n            break;\n\n        }\n\n        if (rd != 16) {\n\n            if (val) {\n\n                store_reg(s, rm, tmp2);\n\n                if (op != 0xf)\n\n                    tcg_temp_free_i32(tmp);\n\n            } else {\n\n                store_reg(s, rd, tmp);\n\n                tcg_temp_free_i32(tmp2);\n\n            }\n\n        } else {\n\n            tcg_temp_free_i32(tmp);\n\n            tcg_temp_free_i32(tmp2);\n\n        }\n\n        break;\n\n\n\n    case 5:\n\n        /* load/store register offset.  */\n\n        rd = insn & 7;\n\n        rn = (insn >> 3) & 7;\n\n        rm = (insn >> 6) & 7;\n\n        op = (insn >> 9) & 7;\n\n        addr = load_reg(s, rn);\n\n        tmp = load_reg(s, rm);\n\n        tcg_gen_add_i32(addr, addr, tmp);\n\n        tcg_temp_free_i32(tmp);\n\n\n\n        if (op < 3) { /* store */\n\n            tmp = load_reg(s, rd);\n\n        } else {\n\n            tmp = tcg_temp_new_i32();\n\n        }\n\n\n\n        switch (op) {\n\n        case 0: /* str */\n\n            gen_aa32_st32_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 1: /* strh */\n\n            gen_aa32_st16_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 2: /* strb */\n\n            gen_aa32_st8_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 3: /* ldrsb */\n\n            gen_aa32_ld8s_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 4: /* ldr */\n\n            gen_aa32_ld32u_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 5: /* ldrh */\n\n            gen_aa32_ld16u_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 6: /* ldrb */\n\n            gen_aa32_ld8u_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 7: /* ldrsh */\n\n            gen_aa32_ld16s_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        }\n\n        if (op >= 3) { /* load */\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        break;\n\n\n\n    case 6:\n\n        /* load/store word immediate offset */\n\n        rd = insn & 7;\n\n        rn = (insn >> 3) & 7;\n\n        addr = load_reg(s, rn);\n\n        val = (insn >> 4) & 0x7c;\n\n        tcg_gen_addi_i32(addr, addr, val);\n\n\n\n        if (insn & (1 << 11)) {\n\n            /* load */\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld32u(s, tmp, addr, get_mem_index(s));\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* store */\n\n            tmp = load_reg(s, rd);\n\n            gen_aa32_st32(s, tmp, addr, get_mem_index(s));\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        break;\n\n\n\n    case 7:\n\n        /* load/store byte immediate offset */\n\n        rd = insn & 7;\n\n        rn = (insn >> 3) & 7;\n\n        addr = load_reg(s, rn);\n\n        val = (insn >> 6) & 0x1f;\n\n        tcg_gen_addi_i32(addr, addr, val);\n\n\n\n        if (insn & (1 << 11)) {\n\n            /* load */\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld8u_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* store */\n\n            tmp = load_reg(s, rd);\n\n            gen_aa32_st8_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        break;\n\n\n\n    case 8:\n\n        /* load/store halfword immediate offset */\n\n        rd = insn & 7;\n\n        rn = (insn >> 3) & 7;\n\n        addr = load_reg(s, rn);\n\n        val = (insn >> 5) & 0x3e;\n\n        tcg_gen_addi_i32(addr, addr, val);\n\n\n\n        if (insn & (1 << 11)) {\n\n            /* load */\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld16u_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* store */\n\n            tmp = load_reg(s, rd);\n\n            gen_aa32_st16_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        break;\n\n\n\n    case 9:\n\n        /* load/store from stack */\n\n        rd = (insn >> 8) & 7;\n\n        addr = load_reg(s, 13);\n\n        val = (insn & 0xff) * 4;\n\n        tcg_gen_addi_i32(addr, addr, val);\n\n\n\n        if (insn & (1 << 11)) {\n\n            /* load */\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld32u_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* store */\n\n            tmp = load_reg(s, rd);\n\n            gen_aa32_st32_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        break;\n\n\n\n    case 10:\n\n        /* add to high reg */\n\n        rd = (insn >> 8) & 7;\n\n        if (insn & (1 << 11)) {\n\n            /* SP */\n\n            tmp = load_reg(s, 13);\n\n        } else {\n\n            /* PC. bit 1 is ignored.  */\n\n            tmp = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp, (s->pc + 2) & ~(uint32_t)2);\n\n        }\n\n        val = (insn & 0xff) * 4;\n\n        tcg_gen_addi_i32(tmp, tmp, val);\n\n        store_reg(s, rd, tmp);\n\n        break;\n\n\n\n    case 11:\n\n        /* misc */\n\n        op = (insn >> 8) & 0xf;\n\n        switch (op) {\n\n        case 0:\n\n            /* adjust stack pointer */\n\n            tmp = load_reg(s, 13);\n\n            val = (insn & 0x7f) * 4;\n\n            if (insn & (1 << 7))\n\n                val = -(int32_t)val;\n\n            tcg_gen_addi_i32(tmp, tmp, val);\n\n            store_reg(s, 13, tmp);\n\n            break;\n\n\n\n        case 2: /* sign/zero extend.  */\n\n            ARCH(6);\n\n            rd = insn & 7;\n\n            rm = (insn >> 3) & 7;\n\n            tmp = load_reg(s, rm);\n\n            switch ((insn >> 6) & 3) {\n\n            case 0: gen_sxth(tmp); break;\n\n            case 1: gen_sxtb(tmp); break;\n\n            case 2: gen_uxth(tmp); break;\n\n            case 3: gen_uxtb(tmp); break;\n\n            }\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        case 4: case 5: case 0xc: case 0xd:\n\n            /* push/pop */\n\n            addr = load_reg(s, 13);\n\n            if (insn & (1 << 8))\n\n                offset = 4;\n\n            else\n\n                offset = 0;\n\n            for (i = 0; i < 8; i++) {\n\n                if (insn & (1 << i))\n\n                    offset += 4;\n\n            }\n\n            if ((insn & (1 << 11)) == 0) {\n\n                tcg_gen_addi_i32(addr, addr, -offset);\n\n            }\n\n            for (i = 0; i < 8; i++) {\n\n                if (insn & (1 << i)) {\n\n                    if (insn & (1 << 11)) {\n\n                        /* pop */\n\n                        tmp = tcg_temp_new_i32();\n\n                        gen_aa32_ld32u(s, tmp, addr, get_mem_index(s));\n\n                        store_reg(s, i, tmp);\n\n                    } else {\n\n                        /* push */\n\n                        tmp = load_reg(s, i);\n\n                        gen_aa32_st32(s, tmp, addr, get_mem_index(s));\n\n                        tcg_temp_free_i32(tmp);\n\n                    }\n\n                    /* advance to the next address.  */\n\n                    tcg_gen_addi_i32(addr, addr, 4);\n\n                }\n\n            }\n\n            TCGV_UNUSED_I32(tmp);\n\n            if (insn & (1 << 8)) {\n\n                if (insn & (1 << 11)) {\n\n                    /* pop pc */\n\n                    tmp = tcg_temp_new_i32();\n\n                    gen_aa32_ld32u(s, tmp, addr, get_mem_index(s));\n\n                    /* don't set the pc until the rest of the instruction\n\n                       has completed */\n\n                } else {\n\n                    /* push lr */\n\n                    tmp = load_reg(s, 14);\n\n                    gen_aa32_st32(s, tmp, addr, get_mem_index(s));\n\n                    tcg_temp_free_i32(tmp);\n\n                }\n\n                tcg_gen_addi_i32(addr, addr, 4);\n\n            }\n\n            if ((insn & (1 << 11)) == 0) {\n\n                tcg_gen_addi_i32(addr, addr, -offset);\n\n            }\n\n            /* write back the new stack pointer */\n\n            store_reg(s, 13, addr);\n\n            /* set the new PC value */\n\n            if ((insn & 0x0900) == 0x0900) {\n\n                store_reg_from_load(s, 15, tmp);\n\n            }\n\n            break;\n\n\n\n        case 1: case 3: case 9: case 11: /* czb */\n\n            rm = insn & 7;\n\n            tmp = load_reg(s, rm);\n\n            s->condlabel = gen_new_label();\n\n            s->condjmp = 1;\n\n            if (insn & (1 << 11))\n\n                tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, s->condlabel);\n\n            else\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, tmp, 0, s->condlabel);\n\n            tcg_temp_free_i32(tmp);\n\n            offset = ((insn & 0xf8) >> 2) | (insn & 0x200) >> 3;\n\n            val = (uint32_t)s->pc + 2;\n\n            val += offset;\n\n            gen_jmp(s, val);\n\n            break;\n\n\n\n        case 15: /* IT, nop-hint.  */\n\n            if ((insn & 0xf) == 0) {\n\n                gen_nop_hint(s, (insn >> 4) & 0xf);\n\n                break;\n\n            }\n\n            /* If Then.  */\n\n            s->condexec_cond = (insn >> 4) & 0xe;\n\n            s->condexec_mask = insn & 0x1f;\n\n            /* No actual code generated for this insn, just setup state.  */\n\n            break;\n\n\n\n        case 0xe: /* bkpt */\n\n        {\n\n            int imm8 = extract32(insn, 0, 8);\n\n            ARCH(5);\n\n            gen_exception_insn(s, 2, EXCP_BKPT, syn_aa32_bkpt(imm8, true),\n\n                               default_exception_el(s));\n\n            break;\n\n        }\n\n\n\n        case 0xa: /* rev, and hlt */\n\n        {\n\n            int op1 = extract32(insn, 6, 2);\n\n\n\n            if (op1 == 2) {\n\n                /* HLT */\n\n                int imm6 = extract32(insn, 0, 6);\n\n\n\n                gen_hlt(s, imm6);\n\n                break;\n\n            }\n\n\n\n            /* Otherwise this is rev */\n\n            ARCH(6);\n\n            rn = (insn >> 3) & 0x7;\n\n            rd = insn & 0x7;\n\n            tmp = load_reg(s, rn);\n\n            switch (op1) {\n\n            case 0: tcg_gen_bswap32_i32(tmp, tmp); break;\n\n            case 1: gen_rev16(tmp); break;\n\n            case 3: gen_revsh(tmp); break;\n\n            default:\n\n                g_assert_not_reached();\n\n            }\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        }\n\n\n\n        case 6:\n\n            switch ((insn >> 5) & 7) {\n\n            case 2:\n\n                /* setend */\n\n                ARCH(6);\n\n                if (((insn >> 3) & 1) != !!(s->be_data == MO_BE)) {\n\n                    gen_helper_setend(cpu_env);\n\n                    s->is_jmp = DISAS_UPDATE;\n\n                }\n\n                break;\n\n            case 3:\n\n                /* cps */\n\n                ARCH(6);\n\n                if (IS_USER(s)) {\n\n                    break;\n\n                }\n\n                if (arm_dc_feature(s, ARM_FEATURE_M)) {\n\n                    tmp = tcg_const_i32((insn & (1 << 4)) != 0);\n\n                    /* FAULTMASK */\n\n                    if (insn & 1) {\n\n                        addr = tcg_const_i32(19);\n\n                        gen_helper_v7m_msr(cpu_env, addr, tmp);\n\n                        tcg_temp_free_i32(addr);\n\n                    }\n\n                    /* PRIMASK */\n\n                    if (insn & 2) {\n\n                        addr = tcg_const_i32(16);\n\n                        gen_helper_v7m_msr(cpu_env, addr, tmp);\n\n                        tcg_temp_free_i32(addr);\n\n                    }\n\n                    tcg_temp_free_i32(tmp);\n\n                    gen_lookup_tb(s);\n\n                } else {\n\n                    if (insn & (1 << 4)) {\n\n                        shift = CPSR_A | CPSR_I | CPSR_F;\n\n                    } else {\n\n                        shift = 0;\n\n                    }\n\n                    gen_set_psr_im(s, ((insn & 7) << 6), 0, shift);\n\n                }\n\n                break;\n\n            default:\n\n                goto undef;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            goto undef;\n\n        }\n\n        break;\n\n\n\n    case 12:\n\n    {\n\n        /* load/store multiple */\n\n        TCGv_i32 loaded_var;\n\n        TCGV_UNUSED_I32(loaded_var);\n\n        rn = (insn >> 8) & 0x7;\n\n        addr = load_reg(s, rn);\n\n        for (i = 0; i < 8; i++) {\n\n            if (insn & (1 << i)) {\n\n                if (insn & (1 << 11)) {\n\n                    /* load */\n\n                    tmp = tcg_temp_new_i32();\n\n                    gen_aa32_ld32u(s, tmp, addr, get_mem_index(s));\n\n                    if (i == rn) {\n\n                        loaded_var = tmp;\n\n                    } else {\n\n                        store_reg(s, i, tmp);\n\n                    }\n\n                } else {\n\n                    /* store */\n\n                    tmp = load_reg(s, i);\n\n                    gen_aa32_st32(s, tmp, addr, get_mem_index(s));\n\n                    tcg_temp_free_i32(tmp);\n\n                }\n\n                /* advance to the next address */\n\n                tcg_gen_addi_i32(addr, addr, 4);\n\n            }\n\n        }\n\n        if ((insn & (1 << rn)) == 0) {\n\n            /* base reg not in list: base register writeback */\n\n            store_reg(s, rn, addr);\n\n        } else {\n\n            /* base reg in list: if load, complete it now */\n\n            if (insn & (1 << 11)) {\n\n                store_reg(s, rn, loaded_var);\n\n            }\n\n            tcg_temp_free_i32(addr);\n\n        }\n\n        break;\n\n    }\n\n    case 13:\n\n        /* conditional branch or swi */\n\n        cond = (insn >> 8) & 0xf;\n\n        if (cond == 0xe)\n\n            goto undef;\n\n\n\n        if (cond == 0xf) {\n\n            /* swi */\n\n            gen_set_pc_im(s, s->pc);\n\n            s->svc_imm = extract32(insn, 0, 8);\n\n            s->is_jmp = DISAS_SWI;\n\n            break;\n\n        }\n\n        /* generate a conditional jump to next instruction */\n\n        s->condlabel = gen_new_label();\n\n        arm_gen_test_cc(cond ^ 1, s->condlabel);\n\n        s->condjmp = 1;\n\n\n\n        /* jump to the offset */\n\n        val = (uint32_t)s->pc + 2;\n\n        offset = ((int32_t)insn << 24) >> 24;\n\n        val += offset << 1;\n\n        gen_jmp(s, val);\n\n        break;\n\n\n\n    case 14:\n\n        if (insn & (1 << 11)) {\n\n            if (disas_thumb2_insn(env, s, insn))\n\n              goto undef32;\n\n            break;\n\n        }\n\n        /* unconditional branch */\n\n        val = (uint32_t)s->pc;\n\n        offset = ((int32_t)insn << 21) >> 21;\n\n        val += (offset << 1) + 2;\n\n        gen_jmp(s, val);\n\n        break;\n\n\n\n    case 15:\n\n        if (disas_thumb2_insn(env, s, insn))\n\n            goto undef32;\n\n        break;\n\n    }\n\n    return;\n\nundef32:\n\n    gen_exception_insn(s, 4, EXCP_UDEF, syn_uncategorized(),\n\n                       default_exception_el(s));\n\n    return;\n\nillegal_op:\n\nundef:\n\n    gen_exception_insn(s, 2, EXCP_UDEF, syn_uncategorized(),\n\n                       default_exception_el(s));\n\n}\n", "idx": 9458, "_split": "valid", "_hash": "a8c3a88619591537efeb16109fc23b4c"}
{"project": "qemu", "commit_id": "c1d4096b0f033d0a52c542f0948403783c3682e9", "target": 1, "func": "static int iscsi_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    struct iscsi_context *iscsi = NULL;\n    struct iscsi_url *iscsi_url = NULL;\n    struct scsi_task *task = NULL;\n    struct scsi_inquiry_standard *inq = NULL;\n    struct scsi_inquiry_supported_pages *inq_vpd;\n    char *initiator_name = NULL;\n    QemuOpts *opts;\n    Error *local_err = NULL;\n    const char *filename;\n    int i, ret;\n    if ((BDRV_SECTOR_SIZE % 512) != 0) {\n        error_setg(errp, \"iSCSI: Invalid BDRV_SECTOR_SIZE. \"\n                   \"BDRV_SECTOR_SIZE(%lld) is not a multiple \"\n                   \"of 512\", BDRV_SECTOR_SIZE);\n        return -EINVAL;\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n    filename = qemu_opt_get(opts, \"filename\");\n    iscsi_url = iscsi_parse_full_url(iscsi, filename);\n    if (iscsi_url == NULL) {\n        error_setg(errp, \"Failed to parse URL : %s\", filename);\n        ret = -EINVAL;\n    memset(iscsilun, 0, sizeof(IscsiLun));\n    initiator_name = parse_initiator_name(iscsi_url->target);\n    iscsi = iscsi_create_context(initiator_name);\n    if (iscsi == NULL) {\n        error_setg(errp, \"iSCSI: Failed to create iSCSI context.\");\n        ret = -ENOMEM;\n    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {\n        error_setg(errp, \"iSCSI: Failed to set target name.\");\n        ret = -EINVAL;\n    if (iscsi_url->user != NULL) {\n        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,\n                                              iscsi_url->passwd);\n        if (ret != 0) {\n            error_setg(errp, \"Failed to set initiator username and password\");\n            ret = -EINVAL;\n    /* check if we got CHAP username/password via the options */\n    parse_chap(iscsi, iscsi_url->target, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) {\n        error_setg(errp, \"iSCSI: Failed to set session type to normal.\");\n        ret = -EINVAL;\n    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n    /* check if we got HEADER_DIGEST via the options */\n    parse_header_digest(iscsi, iscsi_url->target, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n    if (iscsi_full_connect_sync(iscsi, iscsi_url->portal, iscsi_url->lun) != 0) {\n        error_setg(errp, \"iSCSI: Failed to connect to LUN : %s\",\n            iscsi_get_error(iscsi));\n        ret = -EINVAL;\n    iscsilun->iscsi = iscsi;\n    iscsilun->aio_context = bdrv_get_aio_context(bs);\n    iscsilun->lun   = iscsi_url->lun;\n    iscsilun->has_write_same = true;\n    task = iscsi_do_inquiry(iscsilun->iscsi, iscsilun->lun, 0, 0,\n                            (void **) &inq, errp);\n    if (task == NULL) {\n        ret = -EINVAL;\n    iscsilun->type = inq->periperal_device_type;\n    scsi_free_scsi_task(task);\n    task = NULL;\n    iscsi_readcapacity_sync(iscsilun, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n    bs->total_sectors = sector_lun2qemu(iscsilun->num_blocks, iscsilun);\n    bs->request_alignment = iscsilun->block_size;\n    /* We don't have any emulation for devices other than disks and CD-ROMs, so\n     * this must be sg ioctl compatible. We force it to be sg, otherwise qemu\n     * will try to read from the device to guess the image format.\n     */\n    if (iscsilun->type != TYPE_DISK && iscsilun->type != TYPE_ROM) {\n        bs->sg = 1;\n    task = iscsi_do_inquiry(iscsilun->iscsi, iscsilun->lun, 1,\n                            SCSI_INQUIRY_PAGECODE_SUPPORTED_VPD_PAGES,\n                            (void **) &inq_vpd, errp);\n    if (task == NULL) {\n        ret = -EINVAL;\n    for (i = 0; i < inq_vpd->num_pages; i++) {\n        struct scsi_task *inq_task;\n        struct scsi_inquiry_logical_block_provisioning *inq_lbp;\n        struct scsi_inquiry_block_limits *inq_bl;\n        switch (inq_vpd->pages[i]) {\n        case SCSI_INQUIRY_PAGECODE_LOGICAL_BLOCK_PROVISIONING:\n            inq_task = iscsi_do_inquiry(iscsilun->iscsi, iscsilun->lun, 1,\n                                        SCSI_INQUIRY_PAGECODE_LOGICAL_BLOCK_PROVISIONING,\n                                        (void **) &inq_lbp, errp);\n            if (inq_task == NULL) {\n                ret = -EINVAL;\n            memcpy(&iscsilun->lbp, inq_lbp,\n                   sizeof(struct scsi_inquiry_logical_block_provisioning));\n            scsi_free_scsi_task(inq_task);\n            break;\n        case SCSI_INQUIRY_PAGECODE_BLOCK_LIMITS:\n            inq_task = iscsi_do_inquiry(iscsilun->iscsi, iscsilun->lun, 1,\n                                    SCSI_INQUIRY_PAGECODE_BLOCK_LIMITS,\n                                    (void **) &inq_bl, errp);\n            if (inq_task == NULL) {\n                ret = -EINVAL;\n            memcpy(&iscsilun->bl, inq_bl,\n                   sizeof(struct scsi_inquiry_block_limits));\n            scsi_free_scsi_task(inq_task);\n            break;\n        default:\n            break;\n    scsi_free_scsi_task(task);\n    task = NULL;\n    iscsi_attach_aio_context(bs, iscsilun->aio_context);\n    /* Guess the internal cluster (page) size of the iscsi target by the means\n     * of opt_unmap_gran. Transfer the unmap granularity only if it has a\n     * reasonable size */\n    if (iscsilun->bl.opt_unmap_gran * iscsilun->block_size >= 4 * 1024 &&\n        iscsilun->bl.opt_unmap_gran * iscsilun->block_size <= 16 * 1024 * 1024) {\n        iscsilun->cluster_sectors = (iscsilun->bl.opt_unmap_gran *\n                                     iscsilun->block_size) >> BDRV_SECTOR_BITS;\n        if (iscsilun->lbprz && !(bs->open_flags & BDRV_O_NOCACHE)) {\n            iscsilun->allocationmap = iscsi_allocationmap_init(iscsilun);\n            if (iscsilun->allocationmap == NULL) {\n                ret = -ENOMEM;\nout:\n    qemu_opts_del(opts);\n    g_free(initiator_name);\n    if (iscsi_url != NULL) {\n        iscsi_destroy_url(iscsi_url);\n    if (task != NULL) {\n        scsi_free_scsi_task(task);\n    if (ret) {\n        if (iscsi != NULL) {\n            iscsi_destroy_context(iscsi);\n        memset(iscsilun, 0, sizeof(IscsiLun));\n    return ret;", "idx": 9460, "_split": "valid", "_hash": "0e02211fbb6fe533459b44d55de3d369"}
{"project": "qemu", "commit_id": "35f9304d925a5423c51bd2c83a81fa3cc2b6e680", "target": 1, "func": "static target_ulong remove_hpte(CPUPPCState *env, target_ulong ptex,\n\n                                target_ulong avpn,\n\n                                target_ulong flags,\n\n                                target_ulong *vp, target_ulong *rp)\n\n{\n\n    uint8_t *hpte;\n\n    target_ulong v, r, rb;\n\n\n\n    if ((ptex * HASH_PTE_SIZE_64) & ~env->htab_mask) {\n\n        return REMOVE_PARM;\n\n    }\n\n\n\n    hpte = env->external_htab + (ptex * HASH_PTE_SIZE_64);\n\n    while (!lock_hpte(hpte, HPTE_V_HVLOCK)) {\n\n        /* We have no real concurrency in qemu soft-emulation, so we\n\n         * will never actually have a contested lock */\n\n        assert(0);\n\n    }\n\n\n\n    v = ldq_p(hpte);\n\n    r = ldq_p(hpte + (HASH_PTE_SIZE_64/2));\n\n\n\n    if ((v & HPTE_V_VALID) == 0 ||\n\n        ((flags & H_AVPN) && (v & ~0x7fULL) != avpn) ||\n\n        ((flags & H_ANDCOND) && (v & avpn) != 0)) {\n\n        stq_p(hpte, v & ~HPTE_V_HVLOCK);\n\n        assert(!(ldq_p(hpte) & HPTE_V_HVLOCK));\n\n        return REMOVE_NOT_FOUND;\n\n    }\n\n    *vp = v & ~HPTE_V_HVLOCK;\n\n    *rp = r;\n\n    stq_p(hpte, 0);\n\n    rb = compute_tlbie_rb(v, r, ptex);\n\n    ppc_tlb_invalidate_one(env, rb);\n\n    assert(!(ldq_p(hpte) & HPTE_V_HVLOCK));\n\n    return REMOVE_SUCCESS;\n\n}\n", "idx": 9495, "_split": "valid", "_hash": "69deaa3effab7616b9127b90be304d69"}
{"project": "qemu", "commit_id": "81174dae3f9189519cd60c7b79e91c291b021bbe", "target": 1, "func": "SerialState *serial_init(int base, qemu_irq irq, int baudbase,\n\n                         CharDriverState *chr)\n\n{\n\n    SerialState *s;\n\n\n\n    s = qemu_mallocz(sizeof(SerialState));\n\n    if (!s)\n\n        return NULL;\n\n    s->irq = irq;\n\n    s->baudbase = baudbase;\n\n\n\n    s->tx_timer = qemu_new_timer(vm_clock, serial_tx_done, s);\n\n    if (!s->tx_timer)\n\n        return NULL;\n\n\n\n    qemu_register_reset(serial_reset, s);\n\n    serial_reset(s);\n\n\n\n    register_savevm(\"serial\", base, 2, serial_save, serial_load, s);\n\n\n\n    register_ioport_write(base, 8, 1, serial_ioport_write, s);\n\n    register_ioport_read(base, 8, 1, serial_ioport_read, s);\n\n    s->chr = chr;\n\n    qemu_chr_add_handlers(chr, serial_can_receive1, serial_receive1,\n\n                          serial_event, s);\n\n    return s;\n\n}\n", "idx": 9512, "_split": "valid", "_hash": "6b655a9b64c4e9a1ac7f6e947e4279bf"}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void kvmclock_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = kvmclock_realize;\n\n    dc->vmsd = &kvmclock_vmsd;\n\n    dc->props = kvmclock_properties;\n\n\n\n\n\n\n}", "idx": 9514, "_split": "valid", "_hash": "fc07170b58cfa23948371c3a896cfe6f"}
{"project": "qemu", "commit_id": "f3a06403b82c7f036564e4caf18b52ce6885fcfb", "target": 1, "func": "static int64_t guest_file_handle_add(FILE *fh, Error **errp)\n\n{\n\n    GuestFileHandle *gfh;\n\n    int64_t handle;\n\n\n\n    handle = ga_get_fd_handle(ga_state, errp);\n\n    if (handle < 0) {\n\n        return -1;\n\n    }\n\n\n\n    gfh = g_malloc0(sizeof(GuestFileHandle));\n\n    gfh->id = handle;\n\n    gfh->fh = fh;\n\n    QTAILQ_INSERT_TAIL(&guest_file_state.filehandles, gfh, next);\n\n\n\n    return handle;\n\n}\n", "idx": 9523, "_split": "valid", "_hash": "d29658f58906ca80237c3962f434dadc"}
{"project": "qemu", "commit_id": "d718b14b8cc2a28dcf48b68c87f16a36d280c36e", "target": 0, "func": "static inline void cpu_handle_interrupt(CPUState *cpu,\n\n                                        TranslationBlock **last_tb)\n\n{\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    int interrupt_request = cpu->interrupt_request;\n\n\n\n    if (unlikely(interrupt_request)) {\n\n        if (unlikely(cpu->singlestep_enabled & SSTEP_NOIRQ)) {\n\n            /* Mask out external interrupts for this step. */\n\n            interrupt_request &= ~CPU_INTERRUPT_SSTEP_MASK;\n\n        }\n\n        if (interrupt_request & CPU_INTERRUPT_DEBUG) {\n\n            cpu->interrupt_request &= ~CPU_INTERRUPT_DEBUG;\n\n            cpu->exception_index = EXCP_DEBUG;\n\n            cpu_loop_exit(cpu);\n\n        }\n\n        if (replay_mode == REPLAY_MODE_PLAY && !replay_has_interrupt()) {\n\n            /* Do nothing */\n\n        } else if (interrupt_request & CPU_INTERRUPT_HALT) {\n\n            replay_interrupt();\n\n            cpu->interrupt_request &= ~CPU_INTERRUPT_HALT;\n\n            cpu->halted = 1;\n\n            cpu->exception_index = EXCP_HLT;\n\n            cpu_loop_exit(cpu);\n\n        }\n\n#if defined(TARGET_I386)\n\n        else if (interrupt_request & CPU_INTERRUPT_INIT) {\n\n            X86CPU *x86_cpu = X86_CPU(cpu);\n\n            CPUArchState *env = &x86_cpu->env;\n\n            replay_interrupt();\n\n            cpu_svm_check_intercept_param(env, SVM_EXIT_INIT, 0);\n\n            do_cpu_init(x86_cpu);\n\n            cpu->exception_index = EXCP_HALTED;\n\n            cpu_loop_exit(cpu);\n\n        }\n\n#else\n\n        else if (interrupt_request & CPU_INTERRUPT_RESET) {\n\n            replay_interrupt();\n\n            cpu_reset(cpu);\n\n            cpu_loop_exit(cpu);\n\n        }\n\n#endif\n\n        /* The target hook has 3 exit conditions:\n\n           False when the interrupt isn't processed,\n\n           True when it is, and we should restart on a new TB,\n\n           and via longjmp via cpu_loop_exit.  */\n\n        else {\n\n            replay_interrupt();\n\n            if (cc->cpu_exec_interrupt(cpu, interrupt_request)) {\n\n                *last_tb = NULL;\n\n            }\n\n            /* The target hook may have updated the 'cpu->interrupt_request';\n\n             * reload the 'interrupt_request' value */\n\n            interrupt_request = cpu->interrupt_request;\n\n        }\n\n        if (interrupt_request & CPU_INTERRUPT_EXITTB) {\n\n            cpu->interrupt_request &= ~CPU_INTERRUPT_EXITTB;\n\n            /* ensure that no TB jump will be modified as\n\n               the program flow was changed */\n\n            *last_tb = NULL;\n\n        }\n\n    }\n\n    if (unlikely(atomic_read(&cpu->exit_request) || replay_has_interrupt())) {\n\n        atomic_set(&cpu->exit_request, 0);\n\n        cpu->exception_index = EXCP_INTERRUPT;\n\n        cpu_loop_exit(cpu);\n\n    }\n\n}\n", "idx": 9538, "_split": "valid", "_hash": "757bac5a50d1b8555e71cfdb9a8d4cd2"}
{"project": "qemu", "commit_id": "ea5bef49eadd240c7924f287f2da1bb457a3f92c", "target": 0, "func": "static void test_redirector_tx(void)\n\n{\n\n    int backend_sock[2], recv_sock;\n\n    char *cmdline;\n\n    uint32_t ret = 0, len = 0;\n\n    char send_buf[] = \"Hello!!\";\n\n    char sock_path0[] = \"filter-redirector0.XXXXXX\";\n\n    char sock_path1[] = \"filter-redirector1.XXXXXX\";\n\n    char *recv_buf;\n\n    uint32_t size = sizeof(send_buf);\n\n    size = htonl(size);\n\n\n\n    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, backend_sock);\n\n    g_assert_cmpint(ret, !=, -1);\n\n\n\n    ret = mkstemp(sock_path0);\n\n    g_assert_cmpint(ret, !=, -1);\n\n    ret = mkstemp(sock_path1);\n\n    g_assert_cmpint(ret, !=, -1);\n\n\n\n    cmdline = g_strdup_printf(\"-netdev socket,id=qtest-bn0,fd=%d \"\n\n                \"-device rtl8139,netdev=qtest-bn0,id=qtest-e0 \"\n\n                \"-chardev socket,id=redirector0,path=%s,server,nowait \"\n\n                \"-chardev socket,id=redirector1,path=%s,server,nowait \"\n\n                \"-chardev socket,id=redirector2,path=%s,nowait \"\n\n                \"-object filter-redirector,id=qtest-f0,netdev=qtest-bn0,\"\n\n                \"queue=tx,outdev=redirector0 \"\n\n                \"-object filter-redirector,id=qtest-f1,netdev=qtest-bn0,\"\n\n                \"queue=tx,indev=redirector2 \"\n\n                \"-object filter-redirector,id=qtest-f2,netdev=qtest-bn0,\"\n\n                \"queue=tx,outdev=redirector1 \"\n\n                , backend_sock[1], sock_path0, sock_path1, sock_path0);\n\n    qtest_start(cmdline);\n\n    g_free(cmdline);\n\n\n\n    recv_sock = unix_connect(sock_path1, NULL);\n\n    g_assert_cmpint(recv_sock, !=, -1);\n\n\n\n    /* send a qmp command to guarantee that 'connected' is setting to true. */\n\n    qmp_discard_response(\"{ 'execute' : 'query-status'}\");\n\n\n\n    struct iovec iov[] = {\n\n        {\n\n            .iov_base = &size,\n\n            .iov_len = sizeof(size),\n\n        }, {\n\n            .iov_base = send_buf,\n\n            .iov_len = sizeof(send_buf),\n\n        },\n\n    };\n\n\n\n    ret = iov_send(backend_sock[0], iov, 2, 0, sizeof(size) + sizeof(send_buf));\n\n    g_assert_cmpint(ret, ==, sizeof(send_buf) + sizeof(size));\n\n    close(backend_sock[0]);\n\n\n\n    ret = qemu_recv(recv_sock, &len, sizeof(len), 0);\n\n    g_assert_cmpint(ret, ==, sizeof(len));\n\n    len = ntohl(len);\n\n\n\n    g_assert_cmpint(len, ==, sizeof(send_buf));\n\n    recv_buf = g_malloc(len);\n\n    ret = qemu_recv(recv_sock, recv_buf, len, 0);\n\n    g_assert_cmpstr(recv_buf, ==, send_buf);\n\n\n\n    g_free(recv_buf);\n\n    close(recv_sock);\n\n    unlink(sock_path0);\n\n    unlink(sock_path1);\n\n    qtest_end();\n\n}\n", "idx": 9540, "_split": "valid", "_hash": "5366f498c9f9848bd90787a050ab1b9f"}
{"project": "qemu", "commit_id": "104bf02eb50e080ac9d0de5905f80f9a09730154", "target": 0, "func": "int acpi_table_add(const char *t)\n\n{\n\n    static const char *dfl_id = \"QEMUQEMU\";\n\n    char buf[1024], *p, *f;\n\n    struct acpi_table_header acpi_hdr;\n\n    unsigned long val;\n\n    uint32_t length;\n\n    struct acpi_table_header *acpi_hdr_p;\n\n    size_t off;\n\n\n\n    memset(&acpi_hdr, 0, sizeof(acpi_hdr));\n\n  \n\n    if (get_param_value(buf, sizeof(buf), \"sig\", t)) {\n\n        strncpy(acpi_hdr.signature, buf, 4);\n\n    } else {\n\n        strncpy(acpi_hdr.signature, dfl_id, 4);\n\n    }\n\n    if (get_param_value(buf, sizeof(buf), \"rev\", t)) {\n\n        val = strtoul(buf, &p, 10);\n\n        if (val > 255 || *p != '\\0')\n\n            goto out;\n\n    } else {\n\n        val = 1;\n\n    }\n\n    acpi_hdr.revision = (int8_t)val;\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"oem_id\", t)) {\n\n        strncpy(acpi_hdr.oem_id, buf, 6);\n\n    } else {\n\n        strncpy(acpi_hdr.oem_id, dfl_id, 6);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"oem_table_id\", t)) {\n\n        strncpy(acpi_hdr.oem_table_id, buf, 8);\n\n    } else {\n\n        strncpy(acpi_hdr.oem_table_id, dfl_id, 8);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"oem_rev\", t)) {\n\n        val = strtol(buf, &p, 10);\n\n        if(*p != '\\0')\n\n            goto out;\n\n    } else {\n\n        val = 1;\n\n    }\n\n    acpi_hdr.oem_revision = cpu_to_le32(val);\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"asl_compiler_id\", t)) {\n\n        strncpy(acpi_hdr.asl_compiler_id, buf, 4);\n\n    } else {\n\n        strncpy(acpi_hdr.asl_compiler_id, dfl_id, 4);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"asl_compiler_rev\", t)) {\n\n        val = strtol(buf, &p, 10);\n\n        if(*p != '\\0')\n\n            goto out;\n\n    } else {\n\n        val = 1;\n\n    }\n\n    acpi_hdr.asl_compiler_revision = cpu_to_le32(val);\n\n    \n\n    if (!get_param_value(buf, sizeof(buf), \"data\", t)) {\n\n         buf[0] = '\\0';\n\n    }\n\n\n\n    length = sizeof(acpi_hdr);\n\n\n\n    f = buf;\n\n    while (buf[0]) {\n\n        struct stat s;\n\n        char *n = strchr(f, ':');\n\n        if (n)\n\n            *n = '\\0';\n\n        if(stat(f, &s) < 0) {\n\n            fprintf(stderr, \"Can't stat file '%s': %s\\n\", f, strerror(errno));\n\n            goto out;\n\n        }\n\n        length += s.st_size;\n\n        if (!n)\n\n            break;\n\n        *n = ':';\n\n        f = n + 1;\n\n    }\n\n\n\n    if (!acpi_tables) {\n\n        acpi_tables_len = sizeof(uint16_t);\n\n        acpi_tables = qemu_mallocz(acpi_tables_len);\n\n    }\n\n    acpi_tables = qemu_realloc(acpi_tables,\n\n                               acpi_tables_len + sizeof(uint16_t) + length);\n\n    p = acpi_tables + acpi_tables_len;\n\n    acpi_tables_len += sizeof(uint16_t) + length;\n\n\n\n    *(uint16_t*)p = cpu_to_le32(length);\n\n    p += sizeof(uint16_t);\n\n    memcpy(p, &acpi_hdr, sizeof(acpi_hdr));\n\n    off = sizeof(acpi_hdr);\n\n\n\n    f = buf;\n\n    while (buf[0]) {\n\n        struct stat s;\n\n        int fd;\n\n        char *n = strchr(f, ':');\n\n        if (n)\n\n            *n = '\\0';\n\n        fd = open(f, O_RDONLY);\n\n\n\n        if(fd < 0)\n\n            goto out;\n\n        if(fstat(fd, &s) < 0) {\n\n            close(fd);\n\n            goto out;\n\n        }\n\n\n\n        /* off < length is necessary because file size can be changed\n\n           under our foot */\n\n        while(s.st_size && off < length) {\n\n            int r;\n\n            r = read(fd, p + off, s.st_size);\n\n            if (r > 0) {\n\n                off += r;\n\n                s.st_size -= r;\n\n            } else if ((r < 0 && errno != EINTR) || r == 0) {\n\n                close(fd);\n\n                goto out;\n\n            }\n\n        }\n\n\n\n        close(fd);\n\n        if (!n)\n\n            break;\n\n        f = n + 1;\n\n    }\n\n    if (off < length) {\n\n        /* don't pass random value in process to guest */\n\n        memset(p + off, 0, length - off);\n\n    }\n\n\n\n    acpi_hdr_p = (struct acpi_table_header*)p;\n\n    acpi_hdr_p->length = cpu_to_le32(length);\n\n    acpi_hdr_p->checksum = acpi_checksum((uint8_t*)p, length);\n\n    /* increase number of tables */\n\n    (*(uint16_t*)acpi_tables) =\n\n\t    cpu_to_le32(le32_to_cpu(*(uint16_t*)acpi_tables) + 1);\n\n    return 0;\n\nout:\n\n    if (acpi_tables) {\n\n        qemu_free(acpi_tables);\n\n        acpi_tables = NULL;\n\n    }\n\n    return -1;\n\n}\n", "idx": 9577, "_split": "valid", "_hash": "eed81a2f6a6a64c36b5a89dc88b1fca0"}
{"project": "qemu", "commit_id": "55e00a19b6dc8f20e5688866451bb4a60e649459", "target": 0, "func": "static void armv7m_nvic_class_init(ObjectClass *klass, void *data)\n\n{\n\n    NVICClass *nc = NVIC_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    nc->parent_reset = dc->reset;\n\n    nc->parent_init = sdc->init;\n\n    sdc->init = armv7m_nvic_init;\n\n    dc->vmsd  = &vmstate_nvic;\n\n    dc->reset = armv7m_nvic_reset;\n\n    dc->props = armv7m_nvic_properties;\n\n}\n", "idx": 9579, "_split": "valid", "_hash": "e222332a2d56c6812bdea7be23f12324"}
{"project": "qemu", "commit_id": "68d553587c0aa271c3eb2902921b503740d775b6", "target": 0, "func": "static int ehci_qh_do_overlay(EHCIQueue *q)\n\n{\n\n    int i;\n\n    int dtoggle;\n\n    int ping;\n\n    int eps;\n\n    int reload;\n\n\n\n    // remember values in fields to preserve in qh after overlay\n\n\n\n    dtoggle = q->qh.token & QTD_TOKEN_DTOGGLE;\n\n    ping    = q->qh.token & QTD_TOKEN_PING;\n\n\n\n    q->qh.current_qtd = q->qtdaddr;\n\n    q->qh.next_qtd    = q->qtd.next;\n\n    q->qh.altnext_qtd = q->qtd.altnext;\n\n    q->qh.token       = q->qtd.token;\n\n\n\n\n\n    eps = get_field(q->qh.epchar, QH_EPCHAR_EPS);\n\n    if (eps == EHCI_QH_EPS_HIGH) {\n\n        q->qh.token &= ~QTD_TOKEN_PING;\n\n        q->qh.token |= ping;\n\n    }\n\n\n\n    reload = get_field(q->qh.epchar, QH_EPCHAR_RL);\n\n    set_field(&q->qh.altnext_qtd, reload, QH_ALTNEXT_NAKCNT);\n\n\n\n    for (i = 0; i < 5; i++) {\n\n        q->qh.bufptr[i] = q->qtd.bufptr[i];\n\n    }\n\n\n\n    if (!(q->qh.epchar & QH_EPCHAR_DTC)) {\n\n        // preserve QH DT bit\n\n        q->qh.token &= ~QTD_TOKEN_DTOGGLE;\n\n        q->qh.token |= dtoggle;\n\n    }\n\n\n\n    q->qh.bufptr[1] &= ~BUFPTR_CPROGMASK_MASK;\n\n    q->qh.bufptr[2] &= ~BUFPTR_FRAMETAG_MASK;\n\n\n\n    put_dwords(NLPTR_GET(q->qhaddr), (uint32_t *) &q->qh, sizeof(EHCIqh) >> 2);\n\n\n\n    return 0;\n\n}\n", "idx": 9583, "_split": "valid", "_hash": "42d01bded29e6b40a4ff13050c603052"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t intel_hda_mmio_readw(void *opaque, target_phys_addr_t addr)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    return intel_hda_reg_read(d, reg, 0xffff);\n\n}\n", "idx": 9585, "_split": "valid", "_hash": "e50bc347c190b1b7e8ca9b593c1281ac"}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void rtas_ibm_read_pci_config(sPAPREnvironment *spapr,\n\n                                     uint32_t token, uint32_t nargs,\n\n                                     target_ulong args,\n\n                                     uint32_t nret, target_ulong rets)\n\n{\n\n    uint64_t buid;\n\n    uint32_t size, addr;\n\n\n\n    if ((nargs != 4) || (nret != 2)) {\n\n        rtas_st(rets, 0, -1);\n\n        return;\n\n    }\n\n\n\n    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);\n\n    size = rtas_ld(args, 3);\n\n    addr = rtas_ld(args, 0);\n\n\n\n    finish_read_pci_config(spapr, buid, addr, size, rets);\n\n}\n", "idx": 9586, "_split": "valid", "_hash": "98ae1dccc6056bd993849bbcb85e4157"}
{"project": "qemu", "commit_id": "5923f85fb82df7c8c60a89458a5ae856045e5ab1", "target": 1, "func": "static bool acpi_get_mcfg(AcpiMcfgInfo *mcfg)\n\n{\n\n    Object *pci_host;\n\n    QObject *o;\n\n\n\n    pci_host = acpi_get_i386_pci_host();\n\n    g_assert(pci_host);\n\n\n\n    o = object_property_get_qobject(pci_host, PCIE_HOST_MCFG_BASE, NULL);\n\n    if (!o) {\n\n        return false;\n\n    }\n\n    mcfg->mcfg_base = qnum_get_int(qobject_to_qnum(o));\n\n    qobject_decref(o);\n\n\n\n    o = object_property_get_qobject(pci_host, PCIE_HOST_MCFG_SIZE, NULL);\n\n    assert(o);\n\n    mcfg->mcfg_size = qnum_get_int(qobject_to_qnum(o));\n\n    qobject_decref(o);\n\n    return true;\n\n}\n", "idx": 9611, "_split": "valid", "_hash": "944433c7c190c4f5f1da6394894fe928"}
{"project": "qemu", "commit_id": "b14ef7c9ab41ea824c3ccadb070ad95567cca84e", "target": 1, "func": "static void unassigned_mem_writel(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n#ifdef DEBUG_UNASSIGNED\n\n    printf(\"Unassigned mem write \" TARGET_FMT_plx \" = 0x%x\\n\", addr, val);\n\n#endif\n\n#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)\n\n    do_unassigned_access(addr, 1, 0, 0, 4);\n\n#endif\n\n}\n", "idx": 9613, "_split": "valid", "_hash": "af09ae5d1bbfa1fb97b58322328052de"}
{"project": "qemu", "commit_id": "1c275925bfbbc2de84a8f0e09d1dd70bbefb6da3", "target": 0, "func": "void sparc64_get_context(CPUSPARCState *env)\n\n{\n\n    abi_ulong ucp_addr;\n\n    struct target_ucontext *ucp;\n\n    target_mc_gregset_t *grp;\n\n    target_mcontext_t *mcp;\n\n    abi_ulong fp, i7, w_addr;\n\n    int err;\n\n    unsigned int i;\n\n    target_sigset_t target_set;\n\n    sigset_t set;\n\n\n\n    ucp_addr = env->regwptr[UREG_I0];\n\n    if (!lock_user_struct(VERIFY_WRITE, ucp, ucp_addr, 0))\n\n        goto do_sigsegv;\n\n    \n\n    mcp = &ucp->tuc_mcontext;\n\n    grp = &mcp->mc_gregs;\n\n\n\n    /* Skip over the trap instruction, first. */\n\n    env->pc = env->npc;\n\n    env->npc += 4;\n\n\n\n    err = 0;\n\n\n\n    sigprocmask(0, NULL, &set);\n\n    host_to_target_sigset_internal(&target_set, &set);\n\n    if (TARGET_NSIG_WORDS == 1) {\n\n        err |= __put_user(target_set.sig[0],\n\n                          (abi_ulong *)&ucp->tuc_sigmask);\n\n    } else {\n\n        abi_ulong *src, *dst;\n\n        src = target_set.sig;\n\n        dst = ucp->tuc_sigmask.sig;\n\n        for (i = 0; i < TARGET_NSIG_WORDS; i++, dst++, src++) {\n\n            err |= __put_user(*src, dst);\n\n        }\n\n        if (err)\n\n            goto do_sigsegv;\n\n    }\n\n\n\n    /* XXX: tstate must be saved properly */\n\n    //    err |= __put_user(env->tstate, &((*grp)[MC_TSTATE]));\n\n    err |= __put_user(env->pc, &((*grp)[MC_PC]));\n\n    err |= __put_user(env->npc, &((*grp)[MC_NPC]));\n\n    err |= __put_user(env->y, &((*grp)[MC_Y]));\n\n    err |= __put_user(env->gregs[1], &((*grp)[MC_G1]));\n\n    err |= __put_user(env->gregs[2], &((*grp)[MC_G2]));\n\n    err |= __put_user(env->gregs[3], &((*grp)[MC_G3]));\n\n    err |= __put_user(env->gregs[4], &((*grp)[MC_G4]));\n\n    err |= __put_user(env->gregs[5], &((*grp)[MC_G5]));\n\n    err |= __put_user(env->gregs[6], &((*grp)[MC_G6]));\n\n    err |= __put_user(env->gregs[7], &((*grp)[MC_G7]));\n\n    err |= __put_user(env->regwptr[UREG_I0], &((*grp)[MC_O0]));\n\n    err |= __put_user(env->regwptr[UREG_I1], &((*grp)[MC_O1]));\n\n    err |= __put_user(env->regwptr[UREG_I2], &((*grp)[MC_O2]));\n\n    err |= __put_user(env->regwptr[UREG_I3], &((*grp)[MC_O3]));\n\n    err |= __put_user(env->regwptr[UREG_I4], &((*grp)[MC_O4]));\n\n    err |= __put_user(env->regwptr[UREG_I5], &((*grp)[MC_O5]));\n\n    err |= __put_user(env->regwptr[UREG_I6], &((*grp)[MC_O6]));\n\n    err |= __put_user(env->regwptr[UREG_I7], &((*grp)[MC_O7]));\n\n\n\n    w_addr = TARGET_STACK_BIAS+env->regwptr[UREG_I6];\n\n    fp = i7 = 0;\n\n    if (get_user(fp, w_addr + offsetof(struct target_reg_window, ins[6]), \n\n                 abi_ulong) != 0)\n\n        goto do_sigsegv;\n\n    if (get_user(i7, w_addr + offsetof(struct target_reg_window, ins[7]), \n\n                 abi_ulong) != 0)\n\n        goto do_sigsegv;\n\n    err |= __put_user(fp, &(mcp->mc_fp));\n\n    err |= __put_user(i7, &(mcp->mc_i7));\n\n\n\n    {\n\n        uint32_t *dst = ucp->tuc_mcontext.mc_fpregs.mcfpu_fregs.sregs;\n\n        for (i = 0; i < 64; i++, dst++) {\n\n            if (i & 1) {\n\n                err |= __put_user(env->fpr[i/2].l.lower, dst);\n\n            } else {\n\n                err |= __put_user(env->fpr[i/2].l.upper, dst);\n\n            }\n\n        }\n\n    }\n\n    err |= __put_user(env->fsr, &(mcp->mc_fpregs.mcfpu_fsr));\n\n    err |= __put_user(env->gsr, &(mcp->mc_fpregs.mcfpu_gsr));\n\n    err |= __put_user(env->fprs, &(mcp->mc_fpregs.mcfpu_fprs));\n\n\n\n    if (err)\n\n        goto do_sigsegv;\n\n    unlock_user_struct(ucp, ucp_addr, 1);\n\n    return;\n\n do_sigsegv:\n\n    unlock_user_struct(ucp, ucp_addr, 1);\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 9627, "_split": "valid", "_hash": "903f475346ab85edc091f42995fc5dc5"}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_utimensat(FsContext *s, V9fsPath *fs_path,\n\n                           const struct timespec *buf)\n\n{\n\n    int retval;\n\n    retval = v9fs_request(s->private, T_UTIME, NULL, \"sqqqq\",\n\n                          fs_path,\n\n                          buf[0].tv_sec, buf[0].tv_nsec,\n\n                          buf[1].tv_sec, buf[1].tv_nsec);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n    }\n\n    return retval;\n\n}\n", "idx": 9642, "_split": "valid", "_hash": "2ab1f57f3914c29444ddb86d07c31654"}
{"project": "qemu", "commit_id": "141af038dd1e73ed32e473046adeb822537c1152", "target": 1, "func": "static int csrhci_write(struct CharDriverState *chr,\n\n                const uint8_t *buf, int len)\n\n{\n\n    struct csrhci_s *s = (struct csrhci_s *) chr->opaque;\n\n    int plen = s->in_len;\n\n\n\n    if (!s->enable)\n\n        return 0;\n\n\n\n    s->in_len += len;\n\n    memcpy(s->inpkt + plen, buf, len);\n\n\n\n    while (1) {\n\n        if (s->in_len >= 2 && plen < 2)\n\n            s->in_hdr = csrhci_header_len(s->inpkt) + 1;\n\n\n\n        if (s->in_len >= s->in_hdr && plen < s->in_hdr)\n\n            s->in_data = csrhci_data_len(s->inpkt) + s->in_hdr;\n\n\n\n        if (s->in_len >= s->in_data) {\n\n            csrhci_in_packet(s, s->inpkt);\n\n\n\n            memmove(s->inpkt, s->inpkt + s->in_len, s->in_len - s->in_data);\n\n            s->in_len -= s->in_data;\n\n            s->in_hdr = INT_MAX;\n\n            s->in_data = INT_MAX;\n\n            plen = 0;\n\n        } else\n\n            break;\n\n    }\n\n\n\n    return len;\n\n}\n", "idx": 9660, "_split": "valid", "_hash": "aa35f3ec0d2a1aa2d2ecc600da10fa2a"}
{"project": "qemu", "commit_id": "4782a23b270ecbb9ce0ca6f3f1b60857a09cef0e", "target": 0, "func": "static void do_program_interrupt(CPUS390XState *env)\n\n{\n\n    uint64_t mask, addr;\n\n    LowCore *lowcore;\n\n    hwaddr len = TARGET_PAGE_SIZE;\n\n    int ilen = env->int_pgm_ilen;\n\n\n\n    switch (ilen) {\n\n    case ILEN_LATER:\n\n        ilen = get_ilen(cpu_ldub_code(env, env->psw.addr));\n\n        break;\n\n    case ILEN_LATER_INC:\n\n        ilen = get_ilen(cpu_ldub_code(env, env->psw.addr));\n\n        env->psw.addr += ilen;\n\n        break;\n\n    default:\n\n        assert(ilen == 2 || ilen == 4 || ilen == 6);\n\n    }\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"%s: code=0x%x ilen=%d\\n\",\n\n                  __func__, env->int_pgm_code, ilen);\n\n\n\n    lowcore = cpu_physical_memory_map(env->psa, &len, 1);\n\n\n\n    lowcore->pgm_ilen = cpu_to_be16(ilen);\n\n    lowcore->pgm_code = cpu_to_be16(env->int_pgm_code);\n\n    lowcore->program_old_psw.mask = cpu_to_be64(get_psw_mask(env));\n\n    lowcore->program_old_psw.addr = cpu_to_be64(env->psw.addr);\n\n    mask = be64_to_cpu(lowcore->program_new_psw.mask);\n\n    addr = be64_to_cpu(lowcore->program_new_psw.addr);\n\n\n\n    cpu_physical_memory_unmap(lowcore, len, 1, len);\n\n\n\n    DPRINTF(\"%s: %x %x %\" PRIx64 \" %\" PRIx64 \"\\n\", __func__,\n\n            env->int_pgm_code, ilen, env->psw.mask,\n\n            env->psw.addr);\n\n\n\n    load_psw(env, mask, addr);\n\n}\n", "idx": 9666, "_split": "valid", "_hash": "5e2229cae2db251f4d54dde34f539736"}
{"project": "qemu", "commit_id": "29e179bc3f5e804ab58b975e65c91cb9cd287846", "target": 0, "func": "int get_physical_address(CPUState * env, target_ulong * physical,\n\n\t\t\t int *prot, target_ulong address,\n\n\t\t\t int rw, int access_type)\n\n{\n\n    /* P1, P2 and P4 areas do not use translation */\n\n    if ((address >= 0x80000000 && address < 0xc0000000) ||\n\n\taddress >= 0xe0000000) {\n\n\tif (!(env->sr & SR_MD)\n\n\t    && (address < 0xe0000000 || address > 0xe4000000)) {\n\n\t    /* Unauthorized access in user mode (only store queues are available) */\n\n\t    fprintf(stderr, \"Unauthorized access\\n\");\n\n\t    return (rw & PAGE_WRITE) ? MMU_DTLB_MISS_WRITE :\n\n\t\tMMU_DTLB_MISS_READ;\n\n\t}\n\n\t/* Mask upper 3 bits */\n\n\t*physical = address & 0x1FFFFFFF;\n\n\t*prot = PAGE_READ | PAGE_WRITE;\n\n\treturn MMU_OK;\n\n    }\n\n\n\n    /* If MMU is disabled, return the corresponding physical page */\n\n    if (!env->mmucr & MMUCR_AT) {\n\n\t*physical = address & 0x1FFFFFFF;\n\n\t*prot = PAGE_READ | PAGE_WRITE;\n\n\treturn MMU_OK;\n\n    }\n\n\n\n    /* We need to resort to the MMU */\n\n    return get_mmu_address(env, physical, prot, address, rw, access_type);\n\n}\n", "idx": 9669, "_split": "valid", "_hash": "4411db698716876ff3fd559d43909a10"}
{"project": "qemu", "commit_id": "b062ad86dcd33ab39be5060b0655d8e13834b167", "target": 0, "func": "static int multiwrite_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, qflag = 0;\n\n    int c, cnt;\n\n    char **buf;\n\n    int64_t offset, first_offset = 0;\n\n    /* Some compilers get confused and warn if this is not initialized.  */\n\n    int total = 0;\n\n    int nr_iov;\n\n    int nr_reqs;\n\n    int pattern = 0xcd;\n\n    QEMUIOVector *qiovs;\n\n    int i;\n\n    BlockRequest *reqs;\n\n\n\n    while ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n        switch (c) {\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n                return 0;\n\n            }\n\n            break;\n\n        default:\n\n            return qemuio_command_usage(&writev_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n        return qemuio_command_usage(&writev_cmd);\n\n    }\n\n\n\n    nr_reqs = 1;\n\n    for (i = optind; i < argc; i++) {\n\n        if (!strcmp(argv[i], \";\")) {\n\n            nr_reqs++;\n\n        }\n\n    }\n\n\n\n    reqs = g_new0(BlockRequest, nr_reqs);\n\n    buf = g_new0(char *, nr_reqs);\n\n    qiovs = g_new(QEMUIOVector, nr_reqs);\n\n\n\n    for (i = 0; i < nr_reqs && optind < argc; i++) {\n\n        int j;\n\n\n\n        /* Read the offset of the request */\n\n        offset = cvtnum(argv[optind]);\n\n        if (offset < 0) {\n\n            printf(\"non-numeric offset argument -- %s\\n\", argv[optind]);\n\n            goto out;\n\n        }\n\n        optind++;\n\n\n\n        if (offset & 0x1ff) {\n\n            printf(\"offset %lld is not sector aligned\\n\",\n\n                   (long long)offset);\n\n            goto out;\n\n        }\n\n\n\n        if (i == 0) {\n\n            first_offset = offset;\n\n        }\n\n\n\n        /* Read lengths for qiov entries */\n\n        for (j = optind; j < argc; j++) {\n\n            if (!strcmp(argv[j], \";\")) {\n\n                break;\n\n            }\n\n        }\n\n\n\n        nr_iov = j - optind;\n\n\n\n        /* Build request */\n\n        buf[i] = create_iovec(blk, &qiovs[i], &argv[optind], nr_iov, pattern);\n\n        if (buf[i] == NULL) {\n\n            goto out;\n\n        }\n\n\n\n        reqs[i].qiov = &qiovs[i];\n\n        reqs[i].sector = offset >> 9;\n\n        reqs[i].nb_sectors = reqs[i].qiov->size >> 9;\n\n\n\n        optind = j + 1;\n\n\n\n        pattern++;\n\n    }\n\n\n\n    /* If there were empty requests at the end, ignore them */\n\n    nr_reqs = i;\n\n\n\n    gettimeofday(&t1, NULL);\n\n    cnt = do_aio_multiwrite(blk, reqs, nr_reqs, &total);\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"aio_multiwrite failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"wrote\", &t2, first_offset, total, total, cnt, Cflag);\n\nout:\n\n    for (i = 0; i < nr_reqs; i++) {\n\n        qemu_io_free(buf[i]);\n\n        if (reqs[i].qiov != NULL) {\n\n            qemu_iovec_destroy(&qiovs[i]);\n\n        }\n\n    }\n\n    g_free(buf);\n\n    g_free(reqs);\n\n    g_free(qiovs);\n\n    return 0;\n\n}\n", "idx": 9678, "_split": "valid", "_hash": "7355c4cd69827dedcb6677603cbe1716"}
{"project": "qemu", "commit_id": "b0457b69209fca3fb40a85bd54d7f27eb4bad7e7", "target": 0, "func": "static void n8x0_init(ram_addr_t ram_size, const char *boot_device,\n\n                const char *kernel_filename,\n\n                const char *kernel_cmdline, const char *initrd_filename,\n\n                const char *cpu_model, struct arm_boot_info *binfo, int model)\n\n{\n\n    struct n800_s *s = (struct n800_s *) qemu_mallocz(sizeof(*s));\n\n    int sdram_size = binfo->ram_size;\n\n    int onenandram_size = 0x00010000;\n\n    DisplayState *ds;\n\n\n\n    if (ram_size < sdram_size + onenandram_size + OMAP242X_SRAM_SIZE) {\n\n        fprintf(stderr, \"This architecture uses %i bytes of memory\\n\",\n\n                        sdram_size + onenandram_size + OMAP242X_SRAM_SIZE);\n\n        exit(1);\n\n    }\n\n\n\n    s->cpu = omap2420_mpu_init(sdram_size, cpu_model);\n\n\n\n    /* Setup peripherals\n\n     *\n\n     * Believed external peripherals layout in the N810:\n\n     * (spi bus 1)\n\n     *   tsc2005\n\n     *   lcd_mipid\n\n     * (spi bus 2)\n\n     *   Conexant cx3110x (WLAN)\n\n     *   optional: pc2400m (WiMAX)\n\n     * (i2c bus 0)\n\n     *   TLV320AIC33 (audio codec)\n\n     *   TCM825x (camera by Toshiba)\n\n     *   lp5521 (clever LEDs)\n\n     *   tsl2563 (light sensor, hwmon, model 7, rev. 0)\n\n     *   lm8323 (keypad, manf 00, rev 04)\n\n     * (i2c bus 1)\n\n     *   tmp105 (temperature sensor, hwmon)\n\n     *   menelaus (pm)\n\n     * (somewhere on i2c - maybe N800-only)\n\n     *   tea5761 (FM tuner)\n\n     * (serial 0)\n\n     *   GPS\n\n     * (some serial port)\n\n     *   csr41814 (Bluetooth)\n\n     */\n\n    n8x0_gpio_setup(s);\n\n    n8x0_nand_setup(s);\n\n    n8x0_i2c_setup(s);\n\n    if (model == 800)\n\n        n800_tsc_kbd_setup(s);\n\n    else if (model == 810) {\n\n        n810_tsc_setup(s);\n\n        n810_kbd_setup(s);\n\n    }\n\n    n8x0_spi_setup(s);\n\n    n8x0_dss_setup(s);\n\n    n8x0_cbus_setup(s);\n\n    n8x0_uart_setup(s);\n\n    if (usb_enabled)\n\n        n8x0_usb_setup(s);\n\n\n\n    /* Setup initial (reset) machine state */\n\n\n\n    /* Start at the OneNAND bootloader.  */\n\n    s->cpu->env->regs[15] = 0;\n\n\n\n    if (kernel_filename) {\n\n        /* Or at the linux loader.  */\n\n        binfo->kernel_filename = kernel_filename;\n\n        binfo->kernel_cmdline = kernel_cmdline;\n\n        binfo->initrd_filename = initrd_filename;\n\n        arm_load_kernel(s->cpu->env, binfo);\n\n\n\n        qemu_register_reset(n8x0_boot_init, s);\n\n        n8x0_boot_init(s);\n\n    }\n\n\n\n    if (option_rom[0] && (boot_device[0] == 'n' || !kernel_filename)) {\n\n        int rom_size;\n\n        uint8_t nolo_tags[0x10000];\n\n        /* No, wait, better start at the ROM.  */\n\n        s->cpu->env->regs[15] = OMAP2_Q2_BASE + 0x400000;\n\n\n\n        /* This is intended for loading the `secondary.bin' program from\n\n         * Nokia images (the NOLO bootloader).  The entry point seems\n\n         * to be at OMAP2_Q2_BASE + 0x400000.\n\n         *\n\n         * The `2nd.bin' files contain some kind of earlier boot code and\n\n         * for them the entry point needs to be set to OMAP2_SRAM_BASE.\n\n         *\n\n         * The code above is for loading the `zImage' file from Nokia\n\n         * images.  */\n\n        rom_size = load_image_targphys(option_rom[0],\n\n                                       OMAP2_Q2_BASE + 0x400000,\n\n                                       sdram_size - 0x400000);\n\n        printf(\"%i bytes of image loaded\\n\", rom_size);\n\n\n\n        n800_setup_nolo_tags(nolo_tags);\n\n        cpu_physical_memory_write(OMAP2_SRAM_BASE, nolo_tags, 0x10000);\n\n    }\n\n    /* FIXME: We shouldn't really be doing this here.  The LCD controller\n\n       will set the size once configured, so this just sets an initial\n\n       size until the guest activates the display.  */\n\n    ds = get_displaystate();\n\n    ds->surface = qemu_resize_displaysurface(ds, 800, 480);\n\n    dpy_resize(ds);\n\n}\n", "idx": 9697, "_split": "valid", "_hash": "2f21ad1e971b7e3659b4086d849f590c"}
{"project": "qemu", "commit_id": "f186d64d8fda4bb22c15beb8e45b7814fbd8b51e", "target": 0, "func": "void replay_fetch_data_kind(void)\n\n{\n\n    if (replay_file) {\n\n        if (!replay_has_unread_data) {\n\n            replay_data_kind = replay_get_byte();\n\n            if (replay_data_kind == EVENT_INSTRUCTION) {\n\n                replay_state.instructions_count = replay_get_dword();\n\n            }\n\n            replay_check_error();\n\n            replay_has_unread_data = 1;\n\n            if (replay_data_kind >= EVENT_COUNT) {\n\n                error_report(\"Replay: unknown event kind %d\", replay_data_kind);\n\n                exit(1);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 9699, "_split": "valid", "_hash": "0bc0c3f0f47666a391fcfbbc851e1305"}
{"project": "qemu", "commit_id": "19d2b5e6ff7202c2bf45c547efa85ae6c2d76bbd", "target": 0, "func": "static void DMA_run (void)\n\n{\n\n    struct dma_cont *d;\n\n    int icont, ichan;\n\n    int rearm = 0;\n\n    static int running = 0;\n\n\n\n    if (running) {\n\n        rearm = 1;\n\n        goto out;\n\n    } else {\n\n        running = 1;\n\n    }\n\n\n\n    d = dma_controllers;\n\n\n\n    for (icont = 0; icont < 2; icont++, d++) {\n\n        for (ichan = 0; ichan < 4; ichan++) {\n\n            int mask;\n\n\n\n            mask = 1 << ichan;\n\n\n\n            if ((0 == (d->mask & mask)) && (0 != (d->status & (mask << 4)))) {\n\n                channel_run (icont, ichan);\n\n                rearm = 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    running = 0;\n\nout:\n\n    if (rearm)\n\n        qemu_bh_schedule_idle(dma_bh);\n\n}\n", "idx": 9700, "_split": "valid", "_hash": "4e09f16f98338fbf996c8613f92e8f70"}
{"project": "qemu", "commit_id": "792da93a635bce0181c8a46a26941560bf2f7412", "target": 0, "func": "int bdrv_img_create(const char *filename, const char *fmt,\n\n                    const char *base_filename, const char *base_fmt,\n\n                    char *options, uint64_t img_size, int flags)\n\n{\n\n    QEMUOptionParameter *param = NULL, *create_options = NULL;\n\n    QEMUOptionParameter *backing_fmt;\n\n    BlockDriverState *bs = NULL;\n\n    BlockDriver *drv, *proto_drv;\n\n    int ret = 0;\n\n\n\n    /* Find driver and parse its options */\n\n    drv = bdrv_find_format(fmt);\n\n    if (!drv) {\n\n        error_report(\"Unknown file format '%s'\", fmt);\n\n        ret = -1;\n\n        goto out;\n\n    }\n\n\n\n    proto_drv = bdrv_find_protocol(filename);\n\n    if (!proto_drv) {\n\n        error_report(\"Unknown protocol '%s'\", filename);\n\n        ret = -1;\n\n        goto out;\n\n    }\n\n\n\n    create_options = append_option_parameters(create_options,\n\n                                              drv->create_options);\n\n    create_options = append_option_parameters(create_options,\n\n                                              proto_drv->create_options);\n\n\n\n    /* Create parameter list with default values */\n\n    param = parse_option_parameters(\"\", create_options, param);\n\n\n\n    set_option_parameter_int(param, BLOCK_OPT_SIZE, img_size);\n\n\n\n    /* Parse -o options */\n\n    if (options) {\n\n        param = parse_option_parameters(options, create_options, param);\n\n        if (param == NULL) {\n\n            error_report(\"Invalid options for file format '%s'.\", fmt);\n\n            ret = -1;\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    if (base_filename) {\n\n        if (set_option_parameter(param, BLOCK_OPT_BACKING_FILE,\n\n                                 base_filename)) {\n\n            error_report(\"Backing file not supported for file format '%s'\",\n\n                         fmt);\n\n            ret = -1;\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    if (base_fmt) {\n\n        if (set_option_parameter(param, BLOCK_OPT_BACKING_FMT, base_fmt)) {\n\n            error_report(\"Backing file format not supported for file \"\n\n                         \"format '%s'\", fmt);\n\n            ret = -1;\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    backing_fmt = get_option_parameter(param, BLOCK_OPT_BACKING_FMT);\n\n    if (backing_fmt && backing_fmt->value.s) {\n\n        if (!bdrv_find_format(backing_fmt->value.s)) {\n\n            error_report(\"Unknown backing file format '%s'\",\n\n                         backing_fmt->value.s);\n\n            ret = -1;\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    // The size for the image must always be specified, with one exception:\n\n    // If we are using a backing file, we can obtain the size from there\n\n    if (get_option_parameter(param, BLOCK_OPT_SIZE)->value.n == -1) {\n\n        QEMUOptionParameter *backing_file =\n\n            get_option_parameter(param, BLOCK_OPT_BACKING_FILE);\n\n\n\n        if (backing_file && backing_file->value.s) {\n\n            uint64_t size;\n\n            const char *fmt = NULL;\n\n            char buf[32];\n\n\n\n            if (backing_fmt && backing_fmt->value.s) {\n\n                fmt = backing_fmt->value.s;\n\n            }\n\n\n\n            bs = bdrv_new(\"\");\n\n\n\n            ret = bdrv_open(bs, backing_file->value.s, flags, drv);\n\n            if (ret < 0) {\n\n                error_report(\"Could not open '%s'\", filename);\n\n                ret = -1;\n\n                goto out;\n\n            }\n\n            bdrv_get_geometry(bs, &size);\n\n            size *= 512;\n\n\n\n            snprintf(buf, sizeof(buf), \"%\" PRId64, size);\n\n            set_option_parameter(param, BLOCK_OPT_SIZE, buf);\n\n        } else {\n\n            error_report(\"Image creation needs a size parameter\");\n\n            ret = -1;\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    printf(\"Formatting '%s', fmt=%s \", filename, fmt);\n\n    print_option_parameters(param);\n\n    puts(\"\");\n\n\n\n    ret = bdrv_create(drv, filename, param);\n\n\n\n    if (ret < 0) {\n\n        if (ret == -ENOTSUP) {\n\n            error_report(\"Formatting or formatting option not supported for \"\n\n                         \"file format '%s'\", fmt);\n\n        } else if (ret == -EFBIG) {\n\n            error_report(\"The image size is too large for file format '%s'\",\n\n                         fmt);\n\n        } else {\n\n            error_report(\"%s: error while creating %s: %s\", filename, fmt,\n\n                         strerror(-ret));\n\n        }\n\n    }\n\n\n\nout:\n\n    free_option_parameters(create_options);\n\n    free_option_parameters(param);\n\n\n\n    if (bs) {\n\n        bdrv_delete(bs);\n\n    }\n\n    if (ret) {\n\n        return 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 9701, "_split": "valid", "_hash": "71263fd18174bb4521c8bc72368f24a3"}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static inline void reset_bit(uint32_t *field, int bit)\n\n{\n\n    field[bit >> 5] &= ~(1 << (bit & 0x1F));\n\n}\n", "idx": 9712, "_split": "valid", "_hash": "da5e538a2eed4c1b5df1afc4e54938fe"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_aio_cancel_async(BlockAIOCB *acb)\n\n{\n\n    if (acb->aiocb_info->cancel_async) {\n\n        acb->aiocb_info->cancel_async(acb);\n\n    }\n\n}\n", "idx": 9743, "_split": "valid", "_hash": "fb891a7c3a741e5d8aa06ae4ddd1ed46"}
{"project": "qemu", "commit_id": "2c0ef9f411ae6081efa9eca5b3eab2dbeee45a6c", "target": 0, "func": "Visitor *qapi_dealloc_get_visitor(QapiDeallocVisitor *v)\n\n{\n\n    return &v->visitor;\n\n}\n", "idx": 9745, "_split": "valid", "_hash": "39a9a5b233fe62e9e9360d9bf3912623"}
{"project": "qemu", "commit_id": "852d481faf7070ac6e46653b77f6c9ecbdfb9efc", "target": 0, "func": "static void _decode_opc(DisasContext * ctx)\n\n{\n\n#if 0\n\n    fprintf(stderr, \"Translating opcode 0x%04x\\n\", ctx->opcode);\n\n#endif\n\n\n\n    switch (ctx->opcode) {\n\n    case 0x0019:\t\t/* div0u */\n\n\ttcg_gen_andi_i32(cpu_sr, cpu_sr, ~(SR_M | SR_Q | SR_T));\n\n\treturn;\n\n    case 0x000b:\t\t/* rts */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, cpu_pr);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0028:\t\t/* clrmac */\n\n\ttcg_gen_movi_i32(cpu_mach, 0);\n\n\ttcg_gen_movi_i32(cpu_macl, 0);\n\n\treturn;\n\n    case 0x0048:\t\t/* clrs */\n\n\ttcg_gen_andi_i32(cpu_sr, cpu_sr, ~SR_S);\n\n\treturn;\n\n    case 0x0008:\t\t/* clrt */\n\n\tgen_clr_t();\n\n\treturn;\n\n    case 0x0038:\t\t/* ldtlb */\n\n\tCHECK_PRIVILEGED\n\n\tgen_helper_ldtlb();\n\n\treturn;\n\n    case 0x002b:\t\t/* rte */\n\n\tCHECK_PRIVILEGED\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_sr, cpu_ssr);\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, cpu_spc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0058:\t\t/* sets */\n\n\ttcg_gen_ori_i32(cpu_sr, cpu_sr, SR_S);\n\n\treturn;\n\n    case 0x0018:\t\t/* sett */\n\n\tgen_set_t();\n\n\treturn;\n\n    case 0xfbfd:\t\t/* frchg */\n\n\ttcg_gen_xori_i32(cpu_fpscr, cpu_fpscr, FPSCR_FR);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0xf3fd:\t\t/* fschg */\n\n\ttcg_gen_xori_i32(cpu_fpscr, cpu_fpscr, FPSCR_SZ);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x0009:\t\t/* nop */\n\n\treturn;\n\n    case 0x001b:\t\t/* sleep */\n\n\tCHECK_PRIVILEGED\n\n\tgen_helper_sleep(tcg_const_i32(ctx->pc + 2));\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf000) {\n\n    case 0x1000:\t\t/* mov.l Rm,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B11_8), B3_0 * 4);\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x5000:\t\t/* mov.l @(disp,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 4);\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xe000:\t\t/* mov #imm,Rn */\n\n\ttcg_gen_movi_i32(REG(B11_8), B7_0s);\n\n\treturn;\n\n    case 0x9000:\t\t/* mov.w @(disp,PC),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_const_i32(ctx->pc + 4 + B7_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xd000:\t\t/* mov.l @(disp,PC),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_const_i32((ctx->pc + 4 + B7_0 * 4) & ~3);\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x7000:\t\t/* add #imm,Rn */\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), B7_0s);\n\n\treturn;\n\n    case 0xa000:\t\t/* bra disp */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tctx->delayed_pc = ctx->pc + 4 + B11_0s * 2;\n\n\ttcg_gen_movi_i32(cpu_delayed_pc, ctx->delayed_pc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\treturn;\n\n    case 0xb000:\t\t/* bsr disp */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\tctx->delayed_pc = ctx->pc + 4 + B11_0s * 2;\n\n\ttcg_gen_movi_i32(cpu_delayed_pc, ctx->delayed_pc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf00f) {\n\n    case 0x6003:\t\t/* mov Rm,Rn */\n\n\ttcg_gen_mov_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x2000:\t\t/* mov.b Rm,@Rn */\n\n\ttcg_gen_qemu_st8(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x2001:\t\t/* mov.w Rm,@Rn */\n\n\ttcg_gen_qemu_st16(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x2002:\t\t/* mov.l Rm,@Rn */\n\n\ttcg_gen_qemu_st32(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x6000:\t\t/* mov.b @Rm,Rn */\n\n\ttcg_gen_qemu_ld8s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x6001:\t\t/* mov.w @Rm,Rn */\n\n\ttcg_gen_qemu_ld16s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x6002:\t\t/* mov.l @Rm,Rn */\n\n\ttcg_gen_qemu_ld32s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x2004:\t\t/* mov.b Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 1);\n\n\t    tcg_gen_qemu_st8(REG(B7_4), addr, ctx->memidx);\t/* might cause re-execution */\n\n\t    tcg_gen_subi_i32(REG(B11_8), REG(B11_8), 1);\t/* modify register status */\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x2005:\t\t/* mov.w Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 2);\n\n\t    tcg_gen_qemu_st16(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_gen_subi_i32(REG(B11_8), REG(B11_8), 2);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x2006:\t\t/* mov.l Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_gen_subi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t}\n\n\treturn;\n\n    case 0x6004:\t\t/* mov.b @Rm+,Rn */\n\n\ttcg_gen_qemu_ld8s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 1);\n\n\treturn;\n\n    case 0x6005:\t\t/* mov.w @Rm+,Rn */\n\n\ttcg_gen_qemu_ld16s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 2);\n\n\treturn;\n\n    case 0x6006:\t\t/* mov.l @Rm+,Rn */\n\n\ttcg_gen_qemu_ld32s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\treturn;\n\n    case 0x0004:\t\t/* mov.b Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st8(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x0005:\t\t/* mov.w Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st16(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x0006:\t\t/* mov.l Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000c:\t\t/* mov.b @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld8s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000d:\t\t/* mov.w @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld16s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000e:\t\t/* mov.l @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x6008:\t\t/* swap.b Rm,Rn */\n\n\t{\n\n\t    TCGv highw, high, low;\n\n\t    highw = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(highw, REG(B7_4), 0xffff0000);\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_ext8u_i32(high, REG(B7_4));\n\n\t    tcg_gen_shli_i32(high, high, 8);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_shri_i32(low, REG(B7_4), 8);\n\n\t    tcg_gen_ext8u_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), REG(B11_8), highw);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x6009:\t\t/* swap.w Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(high, REG(B7_4));\n\n\t    tcg_gen_shli_i32(high, high, 16);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_shri_i32(low, REG(B7_4), 16);\n\n\t    tcg_gen_ext16u_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x200d:\t\t/* xtrct Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(high, REG(B7_4));\n\n\t    tcg_gen_shli_i32(high, high, 16);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_shri_i32(low, REG(B11_8), 16);\n\n\t    tcg_gen_ext16u_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x300c:\t\t/* add Rm,Rn */\n\n\ttcg_gen_add_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x300e:\t\t/* addc Rm,Rn */\n\n\tgen_helper_addc(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300f:\t\t/* addv Rm,Rn */\n\n\tgen_helper_addv(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x2009:\t\t/* and Rm,Rn */\n\n\ttcg_gen_and_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x3000:\t\t/* cmp/eq Rm,Rn */\n\n\tgen_cmp(TCG_COND_EQ, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3003:\t\t/* cmp/ge Rm,Rn */\n\n\tgen_cmp(TCG_COND_GE, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3007:\t\t/* cmp/gt Rm,Rn */\n\n\tgen_cmp(TCG_COND_GT, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3006:\t\t/* cmp/hi Rm,Rn */\n\n\tgen_cmp(TCG_COND_GTU, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3002:\t\t/* cmp/hs Rm,Rn */\n\n\tgen_cmp(TCG_COND_GEU, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x200c:\t\t/* cmp/str Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    TCGv cmp1 = tcg_temp_local_new();\n\n\t    TCGv cmp2 = tcg_temp_local_new();\n\n\t    tcg_gen_xor_i32(cmp1, REG(B7_4), REG(B11_8));\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0xff000000);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x00ff0000);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x0000ff00);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x000000ff);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cpu_sr, cpu_sr, ~SR_T);\n\n\t    tcg_gen_br(label2);\n\n\t    gen_set_label(label1);\n\n\t    tcg_gen_ori_i32(cpu_sr, cpu_sr, SR_T);\n\n\t    gen_set_label(label2);\n\n\t    tcg_temp_free(cmp2);\n\n\t    tcg_temp_free(cmp1);\n\n\t}\n\n\treturn;\n\n    case 0x2007:\t\t/* div0s Rm,Rn */\n\n\t{\n\n\t    gen_copy_bit_i32(cpu_sr, 8, REG(B11_8), 31);\t/* SR_Q */\n\n\t    gen_copy_bit_i32(cpu_sr, 9, REG(B7_4), 31);\t\t/* SR_M */\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_xor_i32(val, REG(B7_4), REG(B11_8));\n\n\t    gen_copy_bit_i32(cpu_sr, 0, val, 31);\t\t/* SR_T */\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x3004:\t\t/* div1 Rm,Rn */\n\n\tgen_helper_div1(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300d:\t\t/* dmuls.l Rm,Rn */\n\n\t{\n\n\t    TCGv_i64 tmp1 = tcg_temp_new_i64();\n\n\t    TCGv_i64 tmp2 = tcg_temp_new_i64();\n\n\n\n\t    tcg_gen_ext_i32_i64(tmp1, REG(B7_4));\n\n\t    tcg_gen_ext_i32_i64(tmp2, REG(B11_8));\n\n\t    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n\n\t    tcg_gen_trunc_i64_i32(cpu_macl, tmp1);\n\n\t    tcg_gen_shri_i64(tmp1, tmp1, 32);\n\n\t    tcg_gen_trunc_i64_i32(cpu_mach, tmp1);\n\n\n\n\t    tcg_temp_free_i64(tmp2);\n\n\t    tcg_temp_free_i64(tmp1);\n\n\t}\n\n\treturn;\n\n    case 0x3005:\t\t/* dmulu.l Rm,Rn */\n\n\t{\n\n\t    TCGv_i64 tmp1 = tcg_temp_new_i64();\n\n\t    TCGv_i64 tmp2 = tcg_temp_new_i64();\n\n\n\n\t    tcg_gen_extu_i32_i64(tmp1, REG(B7_4));\n\n\t    tcg_gen_extu_i32_i64(tmp2, REG(B11_8));\n\n\t    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n\n\t    tcg_gen_trunc_i64_i32(cpu_macl, tmp1);\n\n\t    tcg_gen_shri_i64(tmp1, tmp1, 32);\n\n\t    tcg_gen_trunc_i64_i32(cpu_mach, tmp1);\n\n\n\n\t    tcg_temp_free_i64(tmp2);\n\n\t    tcg_temp_free_i64(tmp1);\n\n\t}\n\n\treturn;\n\n    case 0x600e:\t\t/* exts.b Rm,Rn */\n\n\ttcg_gen_ext8s_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600f:\t\t/* exts.w Rm,Rn */\n\n\ttcg_gen_ext16s_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600c:\t\t/* extu.b Rm,Rn */\n\n\ttcg_gen_ext8u_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600d:\t\t/* extu.w Rm,Rn */\n\n\ttcg_gen_ext16u_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x000f:\t\t/* mac.l @Rm+,@Rn+ */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg0, REG(B7_4), ctx->memidx);\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg1, REG(B11_8), ctx->memidx);\n\n\t    gen_helper_macl(arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t}\n\n\treturn;\n\n    case 0x400f:\t\t/* mac.w @Rm+,@Rn+ */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg0, REG(B7_4), ctx->memidx);\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg1, REG(B11_8), ctx->memidx);\n\n\t    gen_helper_macw(arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 2);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 2);\n\n\t}\n\n\treturn;\n\n    case 0x0007:\t\t/* mul.l Rm,Rn */\n\n\ttcg_gen_mul_i32(cpu_macl, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x200f:\t\t/* muls.w Rm,Rn */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_ext16s_i32(arg0, REG(B7_4));\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_ext16s_i32(arg1, REG(B11_8));\n\n\t    tcg_gen_mul_i32(cpu_macl, arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t}\n\n\treturn;\n\n    case 0x200e:\t\t/* mulu.w Rm,Rn */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(arg0, REG(B7_4));\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(arg1, REG(B11_8));\n\n\t    tcg_gen_mul_i32(cpu_macl, arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t}\n\n\treturn;\n\n    case 0x600b:\t\t/* neg Rm,Rn */\n\n\ttcg_gen_neg_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600a:\t\t/* negc Rm,Rn */\n\n\tgen_helper_negc(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x6007:\t\t/* not Rm,Rn */\n\n\ttcg_gen_not_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x200b:\t\t/* or Rm,Rn */\n\n\ttcg_gen_or_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x400c:\t\t/* shad Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    int label3 = gen_new_label();\n\n\t    int label4 = gen_new_label();\n\n\t    TCGv shift = tcg_temp_local_new();\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B7_4), 0, label1);\n\n\t    /* Rm positive, shift to the left */\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_shl_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_gen_br(label4);\n\n\t    /* Rm negative, shift to the right */\n\n\t    gen_set_label(label1);\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, shift, 0, label2);\n\n\t    tcg_gen_not_i32(shift, REG(B7_4));\n\n\t    tcg_gen_andi_i32(shift, shift, 0x1f);\n\n\t    tcg_gen_addi_i32(shift, shift, 1);\n\n\t    tcg_gen_sar_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_gen_br(label4);\n\n\t    /* Rm = -32 */\n\n\t    gen_set_label(label2);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B11_8), 0, label3);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0);\n\n\t    tcg_gen_br(label4);\n\n\t    gen_set_label(label3);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0xffffffff);\n\n\t    gen_set_label(label4);\n\n\t    tcg_temp_free(shift);\n\n\t}\n\n\treturn;\n\n    case 0x400d:\t\t/* shld Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    int label3 = gen_new_label();\n\n\t    TCGv shift = tcg_temp_local_new();\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B7_4), 0, label1);\n\n\t    /* Rm positive, shift to the left */\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_shl_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_gen_br(label3);\n\n\t    /* Rm negative, shift to the right */\n\n\t    gen_set_label(label1);\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, shift, 0, label2);\n\n\t    tcg_gen_not_i32(shift, REG(B7_4));\n\n\t    tcg_gen_andi_i32(shift, shift, 0x1f);\n\n\t    tcg_gen_addi_i32(shift, shift, 1);\n\n\t    tcg_gen_shr_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_gen_br(label3);\n\n\t    /* Rm = -32 */\n\n\t    gen_set_label(label2);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0);\n\n\t    gen_set_label(label3);\n\n\t    tcg_temp_free(shift);\n\n\t}\n\n\treturn;\n\n    case 0x3008:\t\t/* sub Rm,Rn */\n\n\ttcg_gen_sub_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x300a:\t\t/* subc Rm,Rn */\n\n\tgen_helper_subc(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300b:\t\t/* subv Rm,Rn */\n\n\tgen_helper_subv(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x2008:\t\t/* tst Rm,Rn */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_and_i32(val, REG(B7_4), REG(B11_8));\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x200a:\t\t/* xor Rm,Rn */\n\n\ttcg_gen_xor_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0xf00c: /* fmov {F,D,X}Rm,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, XREG(B7_4));\n\n\t    gen_store_fpr64(fp, XREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    tcg_gen_mov_i32(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n\t}\n\n\treturn;\n\n    case 0xf00a: /* fmov {F,D,X}Rm,@Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B7_4);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr  ], REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr+1], addr_hi,\t   ctx->memidx);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], REG(B11_8), ctx->memidx);\n\n\t}\n\n\treturn;\n\n    case 0xf008: /* fmov @Rm,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B11_8);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B7_4), 4);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr  ], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr_hi,   ctx->memidx);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], REG(B7_4), ctx->memidx);\n\n\t}\n\n\treturn;\n\n    case 0xf009: /* fmov @Rm+,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B11_8);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B7_4), 4);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr  ], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr_hi,   ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 8);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\t}\n\n\treturn;\n\n    case 0xf00b: /* fmov {F,D,X}Rm,@-Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr = tcg_temp_new_i32();\n\n\t    int fr = XREG(B7_4);\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 8);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr  ], addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t} else {\n\n\t    TCGv addr;\n\n\t    addr = tcg_temp_new_i32();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t    tcg_gen_subi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t}\n\n\treturn;\n\n    case 0xf006: /* fmov @(R0,Rm),{F,D,X}Rm - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new_i32();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    if (ctx->fpscr & FPSCR_SZ) {\n\n\t\tint fr = XREG(B11_8);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr\t ], addr, ctx->memidx);\n\n\t\ttcg_gen_addi_i32(addr, addr, 4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    } else {\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], addr, ctx->memidx);\n\n\t    }\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf007: /* fmov {F,D,X}Rn,@(R0,Rn) - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    if (ctx->fpscr & FPSCR_SZ) {\n\n\t\tint fr = XREG(B7_4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr\t ], addr, ctx->memidx);\n\n\t\ttcg_gen_addi_i32(addr, addr, 4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    } else {\n\n\t\ttcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], addr, ctx->memidx);\n\n\t    }\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf000: /* fadd Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf001: /* fsub Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf002: /* fmul Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf003: /* fdiv Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf004: /* fcmp/eq Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n    case 0xf005: /* fcmp/gt Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n\t{\n\n\t    CHECK_FPU_ENABLED\n\n\t    if (ctx->fpscr & FPSCR_PR) {\n\n                TCGv_i64 fp0, fp1;\n\n\n\n\t\tif (ctx->opcode & 0x0110)\n\n\t\t    break; /* illegal instruction */\n\n\t\tfp0 = tcg_temp_new_i64();\n\n\t\tfp1 = tcg_temp_new_i64();\n\n\t\tgen_load_fpr64(fp0, DREG(B11_8));\n\n\t\tgen_load_fpr64(fp1, DREG(B7_4));\n\n                switch (ctx->opcode & 0xf00f) {\n\n                case 0xf000:\t\t/* fadd Rm,Rn */\n\n                    gen_helper_fadd_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf001:\t\t/* fsub Rm,Rn */\n\n                    gen_helper_fsub_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf002:\t\t/* fmul Rm,Rn */\n\n                    gen_helper_fmul_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf003:\t\t/* fdiv Rm,Rn */\n\n                    gen_helper_fdiv_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf004:\t\t/* fcmp/eq Rm,Rn */\n\n                    gen_helper_fcmp_eq_DT(fp0, fp1);\n\n                    return;\n\n                case 0xf005:\t\t/* fcmp/gt Rm,Rn */\n\n                    gen_helper_fcmp_gt_DT(fp0, fp1);\n\n                    return;\n\n                }\n\n\t\tgen_store_fpr64(fp0, DREG(B11_8));\n\n                tcg_temp_free_i64(fp0);\n\n                tcg_temp_free_i64(fp1);\n\n\t    } else {\n\n                switch (ctx->opcode & 0xf00f) {\n\n                case 0xf000:\t\t/* fadd Rm,Rn */\n\n                    gen_helper_fadd_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf001:\t\t/* fsub Rm,Rn */\n\n                    gen_helper_fsub_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf002:\t\t/* fmul Rm,Rn */\n\n                    gen_helper_fmul_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf003:\t\t/* fdiv Rm,Rn */\n\n                    gen_helper_fdiv_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf004:\t\t/* fcmp/eq Rm,Rn */\n\n                    gen_helper_fcmp_eq_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    return;\n\n                case 0xf005:\t\t/* fcmp/gt Rm,Rn */\n\n                    gen_helper_fcmp_gt_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    return;\n\n                }\n\n\t    }\n\n\t}\n\n\treturn;\n\n    case 0xf00e: /* fmac FR0,RM,Rn */\n\n        {\n\n            CHECK_FPU_ENABLED\n\n            if (ctx->fpscr & FPSCR_PR) {\n\n                break; /* illegal instruction */\n\n            } else {\n\n                gen_helper_fmac_FT(cpu_fregs[FREG(B11_8)],\n\n                                   cpu_fregs[FREG(0)], cpu_fregs[FREG(B7_4)], cpu_fregs[FREG(B11_8)]);\n\n                return;\n\n            }\n\n        }\n\n    }\n\n\n\n    switch (ctx->opcode & 0xff00) {\n\n    case 0xc900:\t\t/* and #imm,R0 */\n\n\ttcg_gen_andi_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xcd00:\t\t/* and.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_andi_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8b00:\t\t/* bf label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\t    gen_conditional_jump(ctx, ctx->pc + 2,\n\n\t\t\t\t ctx->pc + 4 + B7_0s * 2);\n\n\tctx->bstate = BS_BRANCH;\n\n\treturn;\n\n    case 0x8f00:\t\t/* bf/s label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tgen_branch_slot(ctx->delayed_pc = ctx->pc + 4 + B7_0s * 2, 0);\n\n\tctx->flags |= DELAY_SLOT_CONDITIONAL;\n\n\treturn;\n\n    case 0x8900:\t\t/* bt label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\t    gen_conditional_jump(ctx, ctx->pc + 4 + B7_0s * 2,\n\n\t\t\t\t ctx->pc + 2);\n\n\tctx->bstate = BS_BRANCH;\n\n\treturn;\n\n    case 0x8d00:\t\t/* bt/s label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tgen_branch_slot(ctx->delayed_pc = ctx->pc + 4 + B7_0s * 2, 1);\n\n\tctx->flags |= DELAY_SLOT_CONDITIONAL;\n\n\treturn;\n\n    case 0x8800:\t\t/* cmp/eq #imm,R0 */\n\n\tgen_cmp_imm(TCG_COND_EQ, REG(0), B7_0s);\n\n\treturn;\n\n    case 0xc400:\t\t/* mov.b @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0);\n\n\t    tcg_gen_qemu_ld8s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc500:\t\t/* mov.w @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc600:\t\t/* mov.l @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 4);\n\n\t    tcg_gen_qemu_ld32s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc000:\t\t/* mov.b R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0);\n\n\t    tcg_gen_qemu_st8(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc100:\t\t/* mov.w R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 2);\n\n\t    tcg_gen_qemu_st16(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc200:\t\t/* mov.l R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 4);\n\n\t    tcg_gen_qemu_st32(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8000:\t\t/* mov.b R0,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0);\n\n\t    tcg_gen_qemu_st8(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8100:\t\t/* mov.w R0,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 2);\n\n\t    tcg_gen_qemu_st16(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8400:\t\t/* mov.b @(disp,Rn),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0);\n\n\t    tcg_gen_qemu_ld8s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8500:\t\t/* mov.w @(disp,Rn),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc700:\t\t/* mova @(disp,PC),R0 */\n\n\ttcg_gen_movi_i32(REG(0), ((ctx->pc & 0xfffffffc) + 4 + B7_0 * 4) & ~3);\n\n\treturn;\n\n    case 0xcb00:\t\t/* or #imm,R0 */\n\n\ttcg_gen_ori_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xcf00:\t\t/* or.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_ori_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc300:\t\t/* trapa #imm */\n\n\t{\n\n\t    TCGv imm;\n\n\t    CHECK_NOT_DELAY_SLOT\n\n\t    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n\t    imm = tcg_const_i32(B7_0);\n\n\t    gen_helper_trapa(imm);\n\n\t    tcg_temp_free(imm);\n\n\t    ctx->bstate = BS_BRANCH;\n\n\t}\n\n\treturn;\n\n    case 0xc800:\t\t/* tst #imm,R0 */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(val, REG(0), B7_0);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0xcc00:\t\t/* tst.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_add_i32(val, REG(0), cpu_gbr);\n\n\t    tcg_gen_qemu_ld8u(val, val, ctx->memidx);\n\n\t    tcg_gen_andi_i32(val, val, B7_0);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0xca00:\t\t/* xor #imm,R0 */\n\n\ttcg_gen_xori_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xce00:\t\t/* xor.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_xori_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf08f) {\n\n    case 0x408e:\t\t/* ldc Rm,Rn_BANK */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(ALTREG(B6_4), REG(B11_8));\n\n\treturn;\n\n    case 0x4087:\t\t/* ldc.l @Rm+,Rn_BANK */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_qemu_ld32s(ALTREG(B6_4), REG(B11_8), ctx->memidx);\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\treturn;\n\n    case 0x0082:\t\t/* stc Rm_BANK,Rn */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(REG(B11_8), ALTREG(B6_4));\n\n\treturn;\n\n    case 0x4083:\t\t/* stc.l Rm_BANK,@-Rn */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(ALTREG(B6_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t    tcg_gen_subi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t}\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf0ff) {\n\n    case 0x0023:\t\t/* braf Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_addi_i32(cpu_delayed_pc, REG(B11_8), ctx->pc + 4);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0003:\t\t/* bsrf Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\ttcg_gen_add_i32(cpu_delayed_pc, REG(B11_8), cpu_pr);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x4015:\t\t/* cmp/pl Rn */\n\n\tgen_cmp_imm(TCG_COND_GT, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x4011:\t\t/* cmp/pz Rn */\n\n\tgen_cmp_imm(TCG_COND_GE, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x4010:\t\t/* dt Rn */\n\n\ttcg_gen_subi_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_cmp_imm(TCG_COND_EQ, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x402b:\t\t/* jmp @Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, REG(B11_8));\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x400b:\t\t/* jsr @Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, REG(B11_8));\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x400e:\t\t/* ldc Rm,SR */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_andi_i32(cpu_sr, REG(B11_8), 0x700083f3);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x4007:\t\t/* ldc.l @Rm+,SR */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(val, REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_andi_i32(cpu_sr, val, 0x700083f3);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t    ctx->bstate = BS_STOP;\n\n\t}\n\n\treturn;\n\n    case 0x0002:\t\t/* stc SR,Rn */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(REG(B11_8), cpu_sr);\n\n\treturn;\n\n    case 0x4003:\t\t/* stc SR,@-Rn */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_sr, addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t    tcg_gen_subi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t}\n\n\treturn;\n\n#define LDST(reg,ldnum,ldpnum,stnum,stpnum,prechk)\t\t\\\n\n  case ldnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_mov_i32 (cpu_##reg, REG(B11_8));\t\t\t\\\n\n    return;\t\t\t\t\t\t\t\\\n\n  case ldpnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_qemu_ld32s (cpu_##reg, REG(B11_8), ctx->memidx);\t\\\n\n    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\t\t\\\n\n    return;\t\t\t\t\t\t\t\\\n\n  case stnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_mov_i32 (REG(B11_8), cpu_##reg);\t\t\t\\\n\n    return;\t\t\t\t\t\t\t\\\n\n  case stpnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    {\t\t\t\t\t\t\t\t\\\n\n\tTCGv addr = tcg_temp_new();\t\t\t\\\n\n\ttcg_gen_subi_i32(addr, REG(B11_8), 4);\t\t\t\\\n\n\ttcg_gen_qemu_st32 (cpu_##reg, addr, ctx->memidx);\t\\\n\n\ttcg_temp_free(addr);\t\t\t\t\t\\\n\n\ttcg_gen_subi_i32(REG(B11_8), REG(B11_8), 4);\t\t\\\n\n    }\t\t\t\t\t\t\t\t\\\n\n    return;\n\n\tLDST(gbr,  0x401e, 0x4017, 0x0012, 0x4013, {})\n\n\tLDST(vbr,  0x402e, 0x4027, 0x0022, 0x4023, CHECK_PRIVILEGED)\n\n\tLDST(ssr,  0x403e, 0x4037, 0x0032, 0x4033, CHECK_PRIVILEGED)\n\n\tLDST(spc,  0x404e, 0x4047, 0x0042, 0x4043, CHECK_PRIVILEGED)\n\n\tLDST(dbr,  0x40fa, 0x40f6, 0x00fa, 0x40f2, CHECK_PRIVILEGED)\n\n\tLDST(mach, 0x400a, 0x4006, 0x000a, 0x4002, {})\n\n\tLDST(macl, 0x401a, 0x4016, 0x001a, 0x4012, {})\n\n\tLDST(pr,   0x402a, 0x4026, 0x002a, 0x4022, {})\n\n\tLDST(fpul, 0x405a, 0x4056, 0x005a, 0x4052, {CHECK_FPU_ENABLED})\n\n    case 0x406a:\t\t/* lds Rm,FPSCR */\n\n\tCHECK_FPU_ENABLED\n\n\tgen_helper_ld_fpscr(REG(B11_8));\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x4066:\t\t/* lds.l @Rm+,FPSCR */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(addr, REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t    gen_helper_ld_fpscr(addr);\n\n\t    tcg_temp_free(addr);\n\n\t    ctx->bstate = BS_STOP;\n\n\t}\n\n\treturn;\n\n    case 0x006a:\t\t/* sts FPSCR,Rn */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_andi_i32(REG(B11_8), cpu_fpscr, 0x003fffff);\n\n\treturn;\n\n    case 0x4062:\t\t/* sts FPSCR,@-Rn */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(val, cpu_fpscr, 0x003fffff);\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_gen_subi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t}\n\n\treturn;\n\n    case 0x00c3:\t\t/* movca.l R0,@Rm */\n\n\ttcg_gen_qemu_st32(REG(0), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x40a9:\n\n\t/* MOVUA.L @Rm,R0 (Rm) -> R0\n\n\t   Load non-boundary-aligned data */\n\n\ttcg_gen_qemu_ld32u(REG(0), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x40e9:\n\n\t/* MOVUA.L @Rm+,R0   (Rm) -> R0, Rm + 4 -> Rm\n\n\t   Load non-boundary-aligned data */\n\n\ttcg_gen_qemu_ld32u(REG(0), REG(B11_8), ctx->memidx);\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\treturn;\n\n    case 0x0029:\t\t/* movt Rn */\n\n\ttcg_gen_andi_i32(REG(B11_8), cpu_sr, SR_T);\n\n\treturn;\n\n    case 0x0073:\n\n        /* MOVCO.L\n\n\t       LDST -> T\n\n               If (T == 1) R0 -> (Rn)\n\n               0 -> LDST\n\n        */\n\n        if (ctx->features & SH_FEATURE_SH4A) {\n\n\t    int label = gen_new_label();\n\n\t    gen_clr_t();\n\n\t    tcg_gen_or_i32(cpu_sr, cpu_sr, cpu_ldst);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cpu_ldst, 0, label);\n\n\t    tcg_gen_qemu_st32(REG(0), REG(B11_8), ctx->memidx);\n\n\t    gen_set_label(label);\n\n\t    tcg_gen_movi_i32(cpu_ldst, 0);\n\n\t    return;\n\n\t} else\n\n\t    break;\n\n    case 0x0063:\n\n        /* MOVLI.L @Rm,R0\n\n               1 -> LDST\n\n               (Rm) -> R0\n\n               When interrupt/exception\n\n               occurred 0 -> LDST\n\n        */\n\n\tif (ctx->features & SH_FEATURE_SH4A) {\n\n\t    tcg_gen_movi_i32(cpu_ldst, 0);\n\n\t    tcg_gen_qemu_ld32s(REG(0), REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_movi_i32(cpu_ldst, 1);\n\n\t    return;\n\n\t} else\n\n\t    break;\n\n    case 0x0093:\t\t/* ocbi @Rn */\n\n\t{\n\n\t    TCGv dummy = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);\n\n\t    tcg_temp_free(dummy);\n\n\t}\n\n\treturn;\n\n    case 0x00a3:\t\t/* ocbp @Rn */\n\n\t{\n\n\t    TCGv dummy = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);\n\n\t    tcg_temp_free(dummy);\n\n\t}\n\n\treturn;\n\n    case 0x00b3:\t\t/* ocbwb @Rn */\n\n\t{\n\n\t    TCGv dummy = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);\n\n\t    tcg_temp_free(dummy);\n\n\t}\n\n\treturn;\n\n    case 0x0083:\t\t/* pref @Rn */\n\n\treturn;\n\n    case 0x00d3:\t\t/* prefi @Rn */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x00e3:\t\t/* icbi @Rn */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x00ab:\t\t/* synco */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x4024:\t\t/* rotcl Rn */\n\n\t{\n\n\t    TCGv tmp = tcg_temp_new();\n\n\t    tcg_gen_mov_i32(tmp, cpu_sr);\n\n\t    gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\t    tcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\t    gen_copy_bit_i32(REG(B11_8), 0, tmp, 0);\n\n\t    tcg_temp_free(tmp);\n\n\t}\n\n\treturn;\n\n    case 0x4025:\t\t/* rotcr Rn */\n\n\t{\n\n\t    TCGv tmp = tcg_temp_new();\n\n\t    tcg_gen_mov_i32(tmp, cpu_sr);\n\n\t    gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\t    tcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\t    gen_copy_bit_i32(REG(B11_8), 31, tmp, 0);\n\n\t    tcg_temp_free(tmp);\n\n\t}\n\n\treturn;\n\n    case 0x4004:\t\t/* rotl Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_copy_bit_i32(REG(B11_8), 0, cpu_sr, 0);\n\n\treturn;\n\n    case 0x4005:\t\t/* rotr Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_copy_bit_i32(REG(B11_8), 31, cpu_sr, 0);\n\n\treturn;\n\n    case 0x4000:\t\t/* shll Rn */\n\n    case 0x4020:\t\t/* shal Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4021:\t\t/* shar Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_sari_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4001:\t\t/* shlr Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4008:\t\t/* shll2 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 2);\n\n\treturn;\n\n    case 0x4018:\t\t/* shll8 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 8);\n\n\treturn;\n\n    case 0x4028:\t\t/* shll16 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 16);\n\n\treturn;\n\n    case 0x4009:\t\t/* shlr2 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 2);\n\n\treturn;\n\n    case 0x4019:\t\t/* shlr8 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 8);\n\n\treturn;\n\n    case 0x4029:\t\t/* shlr16 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 16);\n\n\treturn;\n\n    case 0x401b:\t\t/* tas.b @Rn */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_local_new();\n\n\t    tcg_gen_mov_i32(addr, REG(B11_8));\n\n\t    val = tcg_temp_local_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_gen_ori_i32(val, val, 0x80);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf00d: /* fsts FPUL,FRn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_mov_i32(cpu_fregs[FREG(B11_8)], cpu_fpul);\n\n\treturn;\n\n    case 0xf01d: /* flds FRm,FPUL - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_mov_i32(cpu_fpul, cpu_fregs[FREG(B11_8)]);\n\n\treturn;\n\n    case 0xf02d: /* float FPUL,FRn/DRn - FPSCR: R[PR,Enable.I]/W[Cause,Flag] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    TCGv_i64 fp;\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    fp = tcg_temp_new_i64();\n\n\t    gen_helper_float_DT(fp, cpu_fpul);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\telse {\n\n\t    gen_helper_float_FT(cpu_fregs[FREG(B11_8)], cpu_fpul);\n\n\t}\n\n\treturn;\n\n    case 0xf03d: /* ftrc FRm/DRm,FPUL - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    TCGv_i64 fp;\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_ftrc_DT(cpu_fpul, fp);\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\telse {\n\n\t    gen_helper_ftrc_FT(cpu_fpul, cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf04d: /* fneg FRn/DRn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    gen_helper_fneg_T(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf05d: /* fabs FRn/DRn */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fabs_DT(fp, fp);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    gen_helper_fabs_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf06d: /* fsqrt FRn */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fsqrt_DT(fp, fp);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    gen_helper_fsqrt_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf07d: /* fsrra FRn */\n\n\tCHECK_FPU_ENABLED\n\n\tbreak;\n\n    case 0xf08d: /* fldi0 FRn - FPSCR: R[PR] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (!(ctx->fpscr & FPSCR_PR)) {\n\n\t    tcg_gen_movi_i32(cpu_fregs[FREG(B11_8)], 0);\n\n\t}\n\n\treturn;\n\n    case 0xf09d: /* fldi1 FRn - FPSCR: R[PR] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (!(ctx->fpscr & FPSCR_PR)) {\n\n\t    tcg_gen_movi_i32(cpu_fregs[FREG(B11_8)], 0x3f800000);\n\n\t}\n\n\treturn;\n\n    case 0xf0ad: /* fcnvsd FPUL,DRn */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_helper_fcnvsd_FT_DT(fp, cpu_fpul);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\treturn;\n\n    case 0xf0bd: /* fcnvds DRn,FPUL */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fcnvds_DT_FT(cpu_fpul, fp);\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\treturn;\n\n    }\n\n#if 0\n\n    fprintf(stderr, \"unknown instruction 0x%04x at pc 0x%08x\\n\",\n\n\t    ctx->opcode, ctx->pc);\n\n    fflush(stderr);\n\n#endif\n\n    gen_helper_raise_illegal_instruction();\n\n    ctx->bstate = BS_EXCP;\n\n}\n", "idx": 9749, "_split": "valid", "_hash": "2d55b773eed484f0e360b5944b7ec464"}
{"project": "qemu", "commit_id": "9dfef5aae422d479d8e561889da05cf31d850d5c", "target": 0, "func": "static void *spapr_create_fdt_skel(const char *cpu_model,\n\n                                   target_phys_addr_t initrd_base,\n\n                                   target_phys_addr_t initrd_size,\n\n                                   const char *boot_device,\n\n                                   const char *kernel_cmdline,\n\n                                   long hash_shift)\n\n{\n\n    void *fdt;\n\n    CPUState *env;\n\n    uint64_t mem_reg_property[] = { 0, cpu_to_be64(ram_size) };\n\n    uint32_t start_prop = cpu_to_be32(initrd_base);\n\n    uint32_t end_prop = cpu_to_be32(initrd_base + initrd_size);\n\n    uint32_t pft_size_prop[] = {0, cpu_to_be32(hash_shift)};\n\n    char hypertas_prop[] = \"hcall-pft\\0hcall-term\\0hcall-dabr\\0hcall-interrupt\"\n\n        \"\\0hcall-tce\\0hcall-vio\\0hcall-splpar\";\n\n    uint32_t interrupt_server_ranges_prop[] = {0, cpu_to_be32(smp_cpus)};\n\n    int i;\n\n    char *modelname;\n\n\n\n#define _FDT(exp) \\\n\n    do { \\\n\n        int ret = (exp);                                           \\\n\n        if (ret < 0) {                                             \\\n\n            fprintf(stderr, \"qemu: error creating device tree: %s: %s\\n\", \\\n\n                    #exp, fdt_strerror(ret));                      \\\n\n            exit(1);                                               \\\n\n        }                                                          \\\n\n    } while (0)\n\n\n\n    fdt = g_malloc0(FDT_MAX_SIZE);\n\n    _FDT((fdt_create(fdt, FDT_MAX_SIZE)));\n\n\n\n    _FDT((fdt_finish_reservemap(fdt)));\n\n\n\n    /* Root node */\n\n    _FDT((fdt_begin_node(fdt, \"\")));\n\n    _FDT((fdt_property_string(fdt, \"device_type\", \"chrp\")));\n\n    _FDT((fdt_property_string(fdt, \"model\", \"IBM pSeries (emulated by qemu)\")));\n\n\n\n    _FDT((fdt_property_cell(fdt, \"#address-cells\", 0x2)));\n\n    _FDT((fdt_property_cell(fdt, \"#size-cells\", 0x2)));\n\n\n\n    /* /chosen */\n\n    _FDT((fdt_begin_node(fdt, \"chosen\")));\n\n\n\n    _FDT((fdt_property_string(fdt, \"bootargs\", kernel_cmdline)));\n\n    _FDT((fdt_property(fdt, \"linux,initrd-start\",\n\n                       &start_prop, sizeof(start_prop))));\n\n    _FDT((fdt_property(fdt, \"linux,initrd-end\",\n\n                       &end_prop, sizeof(end_prop))));\n\n    _FDT((fdt_property_string(fdt, \"qemu,boot-device\", boot_device)));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* memory node */\n\n    _FDT((fdt_begin_node(fdt, \"memory@0\")));\n\n\n\n    _FDT((fdt_property_string(fdt, \"device_type\", \"memory\")));\n\n    _FDT((fdt_property(fdt, \"reg\",\n\n                       mem_reg_property, sizeof(mem_reg_property))));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* cpus */\n\n    _FDT((fdt_begin_node(fdt, \"cpus\")));\n\n\n\n    _FDT((fdt_property_cell(fdt, \"#address-cells\", 0x1)));\n\n    _FDT((fdt_property_cell(fdt, \"#size-cells\", 0x0)));\n\n\n\n    modelname = g_strdup(cpu_model);\n\n\n\n    for (i = 0; i < strlen(modelname); i++) {\n\n        modelname[i] = toupper(modelname[i]);\n\n    }\n\n\n\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n\n        int index = env->cpu_index;\n\n        uint32_t gserver_prop[] = {cpu_to_be32(index), 0}; /* HACK! */\n\n        char *nodename;\n\n        uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),\n\n                           0xffffffff, 0xffffffff};\n\n        uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq() : TIMEBASE_FREQ;\n\n        uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;\n\n\n\n        if (asprintf(&nodename, \"%s@%x\", modelname, index) < 0) {\n\n            fprintf(stderr, \"Allocation failure\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        _FDT((fdt_begin_node(fdt, nodename)));\n\n\n\n        free(nodename);\n\n\n\n        _FDT((fdt_property_cell(fdt, \"reg\", index)));\n\n        _FDT((fdt_property_string(fdt, \"device_type\", \"cpu\")));\n\n\n\n        _FDT((fdt_property_cell(fdt, \"cpu-version\", env->spr[SPR_PVR])));\n\n        _FDT((fdt_property_cell(fdt, \"dcache-block-size\",\n\n                                env->dcache_line_size)));\n\n        _FDT((fdt_property_cell(fdt, \"icache-block-size\",\n\n                                env->icache_line_size)));\n\n        _FDT((fdt_property_cell(fdt, \"timebase-frequency\", tbfreq)));\n\n        _FDT((fdt_property_cell(fdt, \"clock-frequency\", cpufreq)));\n\n        _FDT((fdt_property_cell(fdt, \"ibm,slb-size\", env->slb_nr)));\n\n        _FDT((fdt_property(fdt, \"ibm,pft-size\",\n\n                           pft_size_prop, sizeof(pft_size_prop))));\n\n        _FDT((fdt_property_string(fdt, \"status\", \"okay\")));\n\n        _FDT((fdt_property(fdt, \"64-bit\", NULL, 0)));\n\n        _FDT((fdt_property_cell(fdt, \"ibm,ppc-interrupt-server#s\", index)));\n\n        _FDT((fdt_property(fdt, \"ibm,ppc-interrupt-gserver#s\",\n\n                           gserver_prop, sizeof(gserver_prop))));\n\n\n\n        if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n            _FDT((fdt_property(fdt, \"ibm,processor-segment-sizes\",\n\n                               segs, sizeof(segs))));\n\n        }\n\n\n\n        _FDT((fdt_end_node(fdt)));\n\n    }\n\n\n\n    g_free(modelname);\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* RTAS */\n\n    _FDT((fdt_begin_node(fdt, \"rtas\")));\n\n\n\n    _FDT((fdt_property(fdt, \"ibm,hypertas-functions\", hypertas_prop,\n\n                       sizeof(hypertas_prop))));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* interrupt controller */\n\n    _FDT((fdt_begin_node(fdt, \"interrupt-controller@0\")));\n\n\n\n    _FDT((fdt_property_string(fdt, \"device_type\",\n\n                              \"PowerPC-External-Interrupt-Presentation\")));\n\n    _FDT((fdt_property_string(fdt, \"compatible\", \"IBM,ppc-xicp\")));\n\n    _FDT((fdt_property_cell(fdt, \"reg\", 0)));\n\n    _FDT((fdt_property(fdt, \"interrupt-controller\", NULL, 0)));\n\n    _FDT((fdt_property(fdt, \"ibm,interrupt-server-ranges\",\n\n                       interrupt_server_ranges_prop,\n\n                       sizeof(interrupt_server_ranges_prop))));\n\n    _FDT((fdt_property_cell(fdt, \"#interrupt-cells\", 2)));\n\n    _FDT((fdt_property_cell(fdt, \"linux,phandle\", PHANDLE_XICP)));\n\n    _FDT((fdt_property_cell(fdt, \"phandle\", PHANDLE_XICP)));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* vdevice */\n\n    _FDT((fdt_begin_node(fdt, \"vdevice\")));\n\n\n\n    _FDT((fdt_property_string(fdt, \"device_type\", \"vdevice\")));\n\n    _FDT((fdt_property_string(fdt, \"compatible\", \"IBM,vdevice\")));\n\n    _FDT((fdt_property_cell(fdt, \"#address-cells\", 0x1)));\n\n    _FDT((fdt_property_cell(fdt, \"#size-cells\", 0x0)));\n\n    _FDT((fdt_property_cell(fdt, \"#interrupt-cells\", 0x2)));\n\n    _FDT((fdt_property(fdt, \"interrupt-controller\", NULL, 0)));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    _FDT((fdt_end_node(fdt))); /* close root node */\n\n    _FDT((fdt_finish(fdt)));\n\n\n\n    return fdt;\n\n}\n", "idx": 9756, "_split": "valid", "_hash": "2a00af2848fc48e19ebe238996c4cecc"}
{"project": "qemu", "commit_id": "c834cba90521576224c30b15ebb4d6aeab7b42c4", "target": 1, "func": "int qcow2_get_cluster_offset(BlockDriverState *bs, uint64_t offset,\n\n                             unsigned int *bytes, uint64_t *cluster_offset)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    unsigned int l2_index;\n\n    uint64_t l1_index, l2_offset, *l2_table;\n\n    int l1_bits, c;\n\n    unsigned int offset_in_cluster, nb_clusters;\n\n    uint64_t bytes_available, bytes_needed;\n\n    int ret;\n\n\n\n    offset_in_cluster = offset_into_cluster(s, offset);\n\n    bytes_needed = (uint64_t) *bytes + offset_in_cluster;\n\n\n\n    l1_bits = s->l2_bits + s->cluster_bits;\n\n\n\n    /* compute how many bytes there are between the start of the cluster\n\n     * containing offset and the end of the l1 entry */\n\n    bytes_available = (1ULL << l1_bits) - (offset & ((1ULL << l1_bits) - 1))\n\n                    + offset_in_cluster;\n\n\n\n    if (bytes_needed > bytes_available) {\n\n        bytes_needed = bytes_available;\n\n    }\n\n    assert(bytes_needed <= INT_MAX);\n\n\n\n    *cluster_offset = 0;\n\n\n\n    /* seek to the l2 offset in the l1 table */\n\n\n\n    l1_index = offset >> l1_bits;\n\n    if (l1_index >= s->l1_size) {\n\n        ret = QCOW2_CLUSTER_UNALLOCATED;\n\n        goto out;\n\n    }\n\n\n\n    l2_offset = s->l1_table[l1_index] & L1E_OFFSET_MASK;\n\n    if (!l2_offset) {\n\n        ret = QCOW2_CLUSTER_UNALLOCATED;\n\n        goto out;\n\n    }\n\n\n\n    if (offset_into_cluster(s, l2_offset)) {\n\n        qcow2_signal_corruption(bs, true, -1, -1, \"L2 table offset %#\" PRIx64\n\n                                \" unaligned (L1 index: %#\" PRIx64 \")\",\n\n                                l2_offset, l1_index);\n\n        return -EIO;\n\n    }\n\n\n\n    /* load the l2 table in memory */\n\n\n\n    ret = l2_load(bs, l2_offset, &l2_table);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* find the cluster offset for the given disk offset */\n\n\n\n    l2_index = (offset >> s->cluster_bits) & (s->l2_size - 1);\n\n    *cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n\n\n    /* nb_needed <= INT_MAX, thus nb_clusters <= INT_MAX, too */\n\n    nb_clusters = size_to_clusters(s, bytes_needed);\n\n\n\n    ret = qcow2_get_cluster_type(*cluster_offset);\n\n    switch (ret) {\n\n    case QCOW2_CLUSTER_COMPRESSED:\n\n        /* Compressed clusters can only be processed one by one */\n\n        c = 1;\n\n        *cluster_offset &= L2E_COMPRESSED_OFFSET_SIZE_MASK;\n\n        break;\n\n    case QCOW2_CLUSTER_ZERO:\n\n        if (s->qcow_version < 3) {\n\n            qcow2_signal_corruption(bs, true, -1, -1, \"Zero cluster entry found\"\n\n                                    \" in pre-v3 image (L2 offset: %#\" PRIx64\n\n                                    \", L2 index: %#x)\", l2_offset, l2_index);\n\n            ret = -EIO;\n\n            goto fail;\n\n        }\n\n        c = count_contiguous_clusters_by_type(nb_clusters, &l2_table[l2_index],\n\n                                              QCOW2_CLUSTER_ZERO);\n\n        *cluster_offset = 0;\n\n        break;\n\n    case QCOW2_CLUSTER_UNALLOCATED:\n\n        /* how many empty clusters ? */\n\n        c = count_contiguous_clusters_by_type(nb_clusters, &l2_table[l2_index],\n\n                                              QCOW2_CLUSTER_UNALLOCATED);\n\n        *cluster_offset = 0;\n\n        break;\n\n    case QCOW2_CLUSTER_NORMAL:\n\n        /* how many allocated clusters ? */\n\n        c = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], QCOW_OFLAG_ZERO);\n\n        *cluster_offset &= L2E_OFFSET_MASK;\n\n        if (offset_into_cluster(s, *cluster_offset)) {\n\n            qcow2_signal_corruption(bs, true, -1, -1, \"Data cluster offset %#\"\n\n                                    PRIx64 \" unaligned (L2 offset: %#\" PRIx64\n\n                                    \", L2 index: %#x)\", *cluster_offset,\n\n                                    l2_offset, l2_index);\n\n            ret = -EIO;\n\n            goto fail;\n\n        }\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n\n\n    qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n\n\n    bytes_available = (c * s->cluster_size);\n\n\n\nout:\n\n    if (bytes_available > bytes_needed) {\n\n        bytes_available = bytes_needed;\n\n    }\n\n\n\n    *bytes = bytes_available - offset_in_cluster;\n\n\n\n    return ret;\n\n\n\nfail:\n\n    qcow2_cache_put(bs, s->l2_table_cache, (void **)&l2_table);\n\n    return ret;\n\n}\n", "idx": 9765, "_split": "valid", "_hash": "7bb61c501f51c2ebd4b38b823f9330bc"}
{"project": "qemu", "commit_id": "446f16a6906e9d05aa9ce0dde727d4f731a89298", "target": 1, "func": "static int kvm_init(MachineState *ms)\n\n{\n\n    MachineClass *mc = MACHINE_GET_CLASS(ms);\n\n    static const char upgrade_note[] =\n\n        \"Please upgrade to at least kernel 2.6.29 or recent kvm-kmod\\n\"\n\n        \"(see http://sourceforge.net/projects/kvm).\\n\";\n\n    struct {\n\n        const char *name;\n\n        int num;\n\n    } num_cpus[] = {\n\n        { \"SMP\",          smp_cpus },\n\n        { \"hotpluggable\", max_cpus },\n\n        { NULL, }\n\n    }, *nc = num_cpus;\n\n    int soft_vcpus_limit, hard_vcpus_limit;\n\n    KVMState *s;\n\n    const KVMCapabilityInfo *missing_cap;\n\n    int ret;\n\n    int i, type = 0;\n\n    const char *kvm_type;\n\n\n\n    s = KVM_STATE(ms->accelerator);\n\n\n\n    /*\n\n     * On systems where the kernel can support different base page\n\n     * sizes, host page size may be different from TARGET_PAGE_SIZE,\n\n     * even with KVM.  TARGET_PAGE_SIZE is assumed to be the minimum\n\n     * page size for the system though.\n\n     */\n\n    assert(TARGET_PAGE_SIZE <= getpagesize());\n\n    page_size_init();\n\n\n\n    s->sigmask_len = 8;\n\n\n\n#ifdef KVM_CAP_SET_GUEST_DEBUG\n\n    QTAILQ_INIT(&s->kvm_sw_breakpoints);\n\n#endif\n\n    s->vmfd = -1;\n\n    s->fd = qemu_open(\"/dev/kvm\", O_RDWR);\n\n    if (s->fd == -1) {\n\n        fprintf(stderr, \"Could not access KVM kernel module: %m\\n\");\n\n        ret = -errno;\n\n        goto err;\n\n    }\n\n\n\n    ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0);\n\n    if (ret < KVM_API_VERSION) {\n\n        if (ret >= 0) {\n\n            ret = -EINVAL;\n\n        }\n\n        fprintf(stderr, \"kvm version too old\\n\");\n\n        goto err;\n\n    }\n\n\n\n    if (ret > KVM_API_VERSION) {\n\n        ret = -EINVAL;\n\n        fprintf(stderr, \"kvm version not supported\\n\");\n\n        goto err;\n\n    }\n\n\n\n    s->nr_slots = kvm_check_extension(s, KVM_CAP_NR_MEMSLOTS);\n\n\n\n    /* If unspecified, use the default value */\n\n    if (!s->nr_slots) {\n\n        s->nr_slots = 32;\n\n    }\n\n\n\n    s->slots = g_malloc0(s->nr_slots * sizeof(KVMSlot));\n\n\n\n    for (i = 0; i < s->nr_slots; i++) {\n\n        s->slots[i].slot = i;\n\n    }\n\n\n\n    /* check the vcpu limits */\n\n    soft_vcpus_limit = kvm_recommended_vcpus(s);\n\n    hard_vcpus_limit = kvm_max_vcpus(s);\n\n\n\n    while (nc->name) {\n\n        if (nc->num > soft_vcpus_limit) {\n\n            fprintf(stderr,\n\n                    \"Warning: Number of %s cpus requested (%d) exceeds \"\n\n                    \"the recommended cpus supported by KVM (%d)\\n\",\n\n                    nc->name, nc->num, soft_vcpus_limit);\n\n\n\n            if (nc->num > hard_vcpus_limit) {\n\n                fprintf(stderr, \"Number of %s cpus requested (%d) exceeds \"\n\n                        \"the maximum cpus supported by KVM (%d)\\n\",\n\n                        nc->name, nc->num, hard_vcpus_limit);\n\n                exit(1);\n\n            }\n\n        }\n\n        nc++;\n\n    }\n\n\n\n    kvm_type = qemu_opt_get(qemu_get_machine_opts(), \"kvm-type\");\n\n    if (mc->kvm_type) {\n\n        type = mc->kvm_type(kvm_type);\n\n    } else if (kvm_type) {\n\n        ret = -EINVAL;\n\n        fprintf(stderr, \"Invalid argument kvm-type=%s\\n\", kvm_type);\n\n        goto err;\n\n    }\n\n\n\n    do {\n\n        ret = kvm_ioctl(s, KVM_CREATE_VM, type);\n\n    } while (ret == -EINTR);\n\n\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ioctl(KVM_CREATE_VM) failed: %d %s\\n\", -ret,\n\n                strerror(-ret));\n\n\n\n#ifdef TARGET_S390X\n\n        fprintf(stderr, \"Please add the 'switch_amode' kernel parameter to \"\n\n                        \"your host kernel command line\\n\");\n\n#endif\n\n        goto err;\n\n    }\n\n\n\n    s->vmfd = ret;\n\n    missing_cap = kvm_check_extension_list(s, kvm_required_capabilites);\n\n    if (!missing_cap) {\n\n        missing_cap =\n\n            kvm_check_extension_list(s, kvm_arch_required_capabilities);\n\n    }\n\n    if (missing_cap) {\n\n        ret = -EINVAL;\n\n        fprintf(stderr, \"kvm does not support %s\\n%s\",\n\n                missing_cap->name, upgrade_note);\n\n        goto err;\n\n    }\n\n\n\n    s->coalesced_mmio = kvm_check_extension(s, KVM_CAP_COALESCED_MMIO);\n\n\n\n    s->broken_set_mem_region = 1;\n\n    ret = kvm_check_extension(s, KVM_CAP_JOIN_MEMORY_REGIONS_WORKS);\n\n    if (ret > 0) {\n\n        s->broken_set_mem_region = 0;\n\n    }\n\n\n\n#ifdef KVM_CAP_VCPU_EVENTS\n\n    s->vcpu_events = kvm_check_extension(s, KVM_CAP_VCPU_EVENTS);\n\n#endif\n\n\n\n    s->robust_singlestep =\n\n        kvm_check_extension(s, KVM_CAP_X86_ROBUST_SINGLESTEP);\n\n\n\n#ifdef KVM_CAP_DEBUGREGS\n\n    s->debugregs = kvm_check_extension(s, KVM_CAP_DEBUGREGS);\n\n#endif\n\n\n\n#ifdef KVM_CAP_XSAVE\n\n    s->xsave = kvm_check_extension(s, KVM_CAP_XSAVE);\n\n#endif\n\n\n\n#ifdef KVM_CAP_XCRS\n\n    s->xcrs = kvm_check_extension(s, KVM_CAP_XCRS);\n\n#endif\n\n\n\n#ifdef KVM_CAP_PIT_STATE2\n\n    s->pit_state2 = kvm_check_extension(s, KVM_CAP_PIT_STATE2);\n\n#endif\n\n\n\n#ifdef KVM_CAP_IRQ_ROUTING\n\n    s->direct_msi = (kvm_check_extension(s, KVM_CAP_SIGNAL_MSI) > 0);\n\n#endif\n\n\n\n    s->intx_set_mask = kvm_check_extension(s, KVM_CAP_PCI_2_3);\n\n\n\n    s->irq_set_ioctl = KVM_IRQ_LINE;\n\n    if (kvm_check_extension(s, KVM_CAP_IRQ_INJECT_STATUS)) {\n\n        s->irq_set_ioctl = KVM_IRQ_LINE_STATUS;\n\n    }\n\n\n\n#ifdef KVM_CAP_READONLY_MEM\n\n    kvm_readonly_mem_allowed =\n\n        (kvm_check_extension(s, KVM_CAP_READONLY_MEM) > 0);\n\n#endif\n\n\n\n    kvm_eventfds_allowed =\n\n        (kvm_check_extension(s, KVM_CAP_IOEVENTFD) > 0);\n\n\n\n    kvm_irqfds_allowed =\n\n        (kvm_check_extension(s, KVM_CAP_IRQFD) > 0);\n\n\n\n    kvm_resamplefds_allowed =\n\n        (kvm_check_extension(s, KVM_CAP_IRQFD_RESAMPLE) > 0);\n\n\n\n    ret = kvm_arch_init(s);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    ret = kvm_irqchip_create(s);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    kvm_state = s;\n\n    memory_listener_register(&kvm_memory_listener, &address_space_memory);\n\n    memory_listener_register(&kvm_io_listener, &address_space_io);\n\n\n\n    s->many_ioeventfds = kvm_check_many_ioeventfds();\n\n\n\n    cpu_interrupt_handler = kvm_handle_interrupt;\n\n\n\n    return 0;\n\n\n\nerr:\n\n    assert(ret < 0);\n\n    if (s->vmfd >= 0) {\n\n        close(s->vmfd);\n\n    }\n\n    if (s->fd != -1) {\n\n        close(s->fd);\n\n    }\n\n    g_free(s->slots);\n\n\n\n    return ret;\n\n}\n", "idx": 9775, "_split": "valid", "_hash": "c6b6329009079fc0a356ca6ba991fdaf"}
{"project": "qemu", "commit_id": "fc9c0a9c4b2c07cf2b8683f2617af584f14c93e7", "target": 1, "func": "void block_job_sleep_ns(BlockJob *job, QEMUClockType type, int64_t ns)\n\n{\n\n    assert(job->busy);\n\n\n\n    /* Check cancellation *before* setting busy = false, too!  */\n\n    if (block_job_is_cancelled(job)) {\n\n        return;\n\n    }\n\n\n\n    job->busy = false;\n\n    if (!block_job_should_pause(job)) {\n\n        co_aio_sleep_ns(blk_get_aio_context(job->blk), type, ns);\n\n    }\n\n    /* The job can be paused while sleeping, so check this again */\n\n    if (block_job_should_pause(job)) {\n\n        qemu_coroutine_yield();\n\n    }\n\n    job->busy = true;\n\n}\n", "idx": 9780, "_split": "valid", "_hash": "8fc4887c978637bad03bc3673215736c"}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static void adb_mouse_reset(DeviceState *dev)\n\n{\n\n    ADBDevice *d = ADB_DEVICE(dev);\n\n    MouseState *s = ADB_MOUSE(dev);\n\n\n\n    d->handler = 2;\n\n    d->devaddr = ADB_DEVID_MOUSE;\n\n    s->last_buttons_state = s->buttons_state = 0;\n\n    s->dx = s->dy = s->dz = 0;\n\n}\n", "idx": 9793, "_split": "valid", "_hash": "0fbd95d6564beff75cb876f877bd9ce4"}
{"project": "qemu", "commit_id": "f8a83245d9ec685bc6aa6173d6765fe03e20688f", "target": 1, "func": "static void raw_close(BlockDriverState *bs)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    if (s->fd >= 0) {\n\n        close(s->fd);\n\n        s->fd = -1;\n\n        if (s->aligned_buf != NULL)\n\n            qemu_free(s->aligned_buf);\n\n    }\n\n}\n", "idx": 9795, "_split": "valid", "_hash": "6256d31fb5ef75b52bc37e8d141a60b7"}
{"project": "qemu", "commit_id": "ef76dc59fa5203d146a2acf85a0ad5a5971a4824", "target": 0, "func": "START_TEST(simple_dict)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        LiteralQObject decoded;\n\n    } test_cases[] = {\n\n        {\n\n            .encoded = \"{\\\"foo\\\": 42, \\\"bar\\\": \\\"hello world\\\"}\",\n\n            .decoded = QLIT_QDICT(((LiteralQDictEntry[]){\n\n                        { \"foo\", QLIT_QINT(42) },\n\n                        { \"bar\", QLIT_QSTR(\"hello world\") },\n\n                        { }\n\n                    })),\n\n        }, {\n\n            .encoded = \"{}\",\n\n            .decoded = QLIT_QDICT(((LiteralQDictEntry[]){\n\n                        { }\n\n                    })),\n\n        }, {\n\n            .encoded = \"{\\\"foo\\\": 43}\",\n\n            .decoded = QLIT_QDICT(((LiteralQDictEntry[]){\n\n                        { \"foo\", QLIT_QINT(43) },\n\n                        { }\n\n                    })),\n\n        },\n\n        { }\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded);\n\n        fail_unless(obj != NULL);\n\n        fail_unless(qobject_type(obj) == QTYPE_QDICT);\n\n\n\n        fail_unless(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        str = qobject_to_json(obj);\n\n        qobject_decref(obj);\n\n\n\n        obj = qobject_from_json(qstring_get_str(str));\n\n        fail_unless(obj != NULL);\n\n        fail_unless(qobject_type(obj) == QTYPE_QDICT);\n\n\n\n        fail_unless(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n        qobject_decref(obj);\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 9860, "_split": "valid", "_hash": "964bfa55fd1cec42a04e8b3d1619587d"}
{"project": "qemu", "commit_id": "a0efbf16604770b9d805bcf210ec29942321134f", "target": 0, "func": "static void i440fx_pcihost_get_pci_hole64_end(Object *obj, Visitor *v,\n\n                                              const char *name, void *opaque,\n\n                                              Error **errp)\n\n{\n\n    PCIHostState *h = PCI_HOST_BRIDGE(obj);\n\n    Range w64;\n\n\n\n    pci_bus_get_w64_range(h->bus, &w64);\n\n\n\n    visit_type_uint64(v, name, &w64.end, errp);\n\n}\n", "idx": 9861, "_split": "valid", "_hash": "76cfd3fe585b80af2cef6d45e039dfa1"}
{"project": "qemu", "commit_id": "7e01376daea75e888c370aab521a7d4aeaf2ffd1", "target": 0, "func": "void ioinst_handle_stsch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)\n\n{\n\n    int cssid, ssid, schid, m;\n\n    SubchDev *sch;\n\n    uint64_t addr;\n\n    int cc;\n\n    SCHIB schib;\n\n    CPUS390XState *env = &cpu->env;\n\n    uint8_t ar;\n\n\n\n    addr = decode_basedisp_s(env, ipb, &ar);\n\n    if (addr & 3) {\n\n        program_interrupt(env, PGM_SPECIFICATION, 2);\n\n        return;\n\n    }\n\n\n\n    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid)) {\n\n        /*\n\n         * As operand exceptions have a lower priority than access exceptions,\n\n         * we check whether the memory area is writeable (injecting the\n\n         * access execption if it is not) first.\n\n         */\n\n        if (!s390_cpu_virt_mem_check_write(cpu, addr, ar, sizeof(schib))) {\n\n            program_interrupt(env, PGM_OPERAND, 2);\n\n        }\n\n        return;\n\n    }\n\n    trace_ioinst_sch_id(\"stsch\", cssid, ssid, schid);\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (sch) {\n\n        if (css_subch_visible(sch)) {\n\n            css_do_stsch(sch, &schib);\n\n            cc = 0;\n\n        } else {\n\n            /* Indicate no more subchannels in this css/ss */\n\n            cc = 3;\n\n        }\n\n    } else {\n\n        if (css_schid_final(m, cssid, ssid, schid)) {\n\n            cc = 3; /* No more subchannels in this css/ss */\n\n        } else {\n\n            /* Store an empty schib. */\n\n            memset(&schib, 0, sizeof(schib));\n\n            cc = 0;\n\n        }\n\n    }\n\n    if (cc != 3) {\n\n        if (s390_cpu_virt_mem_write(cpu, addr, ar, &schib,\n\n                                    sizeof(schib)) != 0) {\n\n            return;\n\n        }\n\n    } else {\n\n        /* Access exceptions have a higher priority than cc3 */\n\n        if (s390_cpu_virt_mem_check_write(cpu, addr, ar, sizeof(schib)) != 0) {\n\n            return;\n\n        }\n\n    }\n\n    setcc(cpu, cc);\n\n}\n", "idx": 9866, "_split": "valid", "_hash": "698bbea998499f7005e765c31ec47032"}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static void cow_close(BlockDriverState *bs)\n\n{\n\n}\n", "idx": 9872, "_split": "valid", "_hash": "63a5d8dfac5ae64baafda10a0e6a0345"}
{"project": "qemu", "commit_id": "0ccff151b42a5b684ce22473b68972a94bc708fb", "target": 1, "func": "void mips_malta_init (ram_addr_t ram_size, int vga_ram_size,\n\n                      const char *boot_device,\n\n                      const char *kernel_filename, const char *kernel_cmdline,\n\n                      const char *initrd_filename, const char *cpu_model)\n\n{\n\n    char buf[1024];\n\n    unsigned long bios_offset;\n\n    target_long bios_size;\n\n    int64_t kernel_entry;\n\n    PCIBus *pci_bus;\n\n    CPUState *env;\n\n    RTCState *rtc_state;\n\n    fdctrl_t *floppy_controller;\n\n    MaltaFPGAState *malta_fpga;\n\n    qemu_irq *i8259;\n\n    int piix4_devfn;\n\n    uint8_t *eeprom_buf;\n\n    i2c_bus *smbus;\n\n    int i;\n\n    int index;\n\n    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BlockDriverState *fd[MAX_FD];\n\n    int fl_idx = 0;\n\n    int fl_sectors = 0;\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n#ifdef TARGET_MIPS64\n\n        cpu_model = \"20Kc\";\n\n#else\n\n        cpu_model = \"24Kf\";\n\n#endif\n\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n\n\n    qemu_register_reset(main_cpu_reset, env);\n\n\n\n    /* allocate RAM */\n\n\n\n\n\n\n\n    cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);\n\n\n\n    /* Map the bios at two physical locations, as on the real board. */\n\n    bios_offset = ram_size + vga_ram_size;\n\n    cpu_register_physical_memory(0x1e000000LL,\n\n                                 BIOS_SIZE, bios_offset | IO_MEM_ROM);\n\n    cpu_register_physical_memory(0x1fc00000LL,\n\n                                 BIOS_SIZE, bios_offset | IO_MEM_ROM);\n\n\n\n    /* FPGA */\n\n    malta_fpga = malta_fpga_init(0x1f000000LL, env->irq[2], serial_hds[2]);\n\n\n\n    /* Load firmware in flash / BIOS unless we boot directly into a kernel. */\n\n    if (kernel_filename) {\n\n        /* Write a small bootloader to the flash location. */\n\n        loaderparams.ram_size = ram_size;\n\n        loaderparams.kernel_filename = kernel_filename;\n\n        loaderparams.kernel_cmdline = kernel_cmdline;\n\n        loaderparams.initrd_filename = initrd_filename;\n\n        kernel_entry = load_kernel(env);\n\n        env->CP0_Status &= ~((1 << CP0St_BEV) | (1 << CP0St_ERL));\n\n        write_bootloader(env, bios_offset, kernel_entry);\n\n    } else {\n\n        index = drive_get_index(IF_PFLASH, 0, fl_idx);\n\n        if (index != -1) {\n\n            /* Load firmware from flash. */\n\n            bios_size = 0x400000;\n\n            fl_sectors = bios_size >> 16;\n\n#ifdef DEBUG_BOARD_INIT\n\n            printf(\"Register parallel flash %d size \" TARGET_FMT_lx \" at \"\n\n                   \"offset %08lx addr %08llx '%s' %x\\n\",\n\n                   fl_idx, bios_size, bios_offset, 0x1e000000LL,\n\n                   bdrv_get_device_name(drives_table[index].bdrv), fl_sectors);\n\n#endif\n\n            pflash_cfi01_register(0x1e000000LL, bios_offset,\n\n                                  drives_table[index].bdrv, 65536, fl_sectors,\n\n                                  4, 0x0000, 0x0000, 0x0000, 0x0000);\n\n            fl_idx++;\n\n        } else {\n\n            /* Load a BIOS image. */\n\n            if (bios_name == NULL)\n\n                bios_name = BIOS_FILENAME;\n\n            snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, bios_name);\n\n            bios_size = load_image(buf, phys_ram_base + bios_offset);\n\n            if ((bios_size < 0 || bios_size > BIOS_SIZE) && !kernel_filename) {\n\n\n                        \"qemu: Could not load MIPS bios '%s', and no -kernel argument was specified\\n\",\n\n                        buf);\n\n\n\n\n        /* In little endian mode the 32bit words in the bios are swapped,\n\n           a neat trick which allows bi-endian firmware. */\n\n#ifndef TARGET_WORDS_BIGENDIAN\n\n        {\n\n            uint32_t *addr;\n\n            for (addr = (uint32_t *)(phys_ram_base + bios_offset);\n\n                 addr < (uint32_t *)(phys_ram_base + bios_offset + bios_size);\n\n                 addr++) {\n\n                *addr = bswap32(*addr);\n\n\n\n#endif\n\n\n\n\n    /* Board ID = 0x420 (Malta Board with CoreLV)\n\n       XXX: theoretically 0x1e000010 should map to flash and 0x1fc00010 should\n\n       map to the board ID. */\n\n    stl_raw(phys_ram_base + bios_offset + 0x10, 0x00000420);\n\n\n\n    /* Init internal devices */\n\n    cpu_mips_irq_init_cpu(env);\n\n    cpu_mips_clock_init(env);\n\n\n\n    /* Interrupt controller */\n\n    /* The 8259 is attached to the MIPS CPU INT0 pin, ie interrupt 2 */\n\n    i8259 = i8259_init(env->irq[2]);\n\n\n\n    /* Northbridge */\n\n    pci_bus = pci_gt64120_init(i8259);\n\n\n\n    /* Southbridge */\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n        if (index != -1)\n\n            hd[i] = drives_table[index].bdrv;\n\n        else\n\n            hd[i] = NULL;\n\n\n\n\n    piix4_devfn = piix4_init(pci_bus, 80);\n\n    pci_piix4_ide_init(pci_bus, hd, piix4_devfn + 1, i8259);\n\n    usb_uhci_piix4_init(pci_bus, piix4_devfn + 2);\n\n    smbus = piix4_pm_init(pci_bus, piix4_devfn + 3, 0x1100, i8259[9]);\n\n    eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */\n\n    for (i = 0; i < 8; i++) {\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus_eeprom_device_init(smbus, 0x50 + i, eeprom_buf + (i * 256));\n\n\n    pit = pit_init(0x40, i8259[0]);\n\n    DMA_init(0);\n\n\n\n    /* Super I/O */\n\n    i8042_init(i8259[1], i8259[12], 0x60);\n\n    rtc_state = rtc_init(0x70, i8259[8]);\n\n    serial_init(0x3f8, i8259[4], 115200, serial_hds[0]);\n\n    serial_init(0x2f8, i8259[3], 115200, serial_hds[1]);\n\n    if (parallel_hds[0])\n\n        parallel_init(0x378, i8259[7], parallel_hds[0]);\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        index = drive_get_index(IF_FLOPPY, 0, i);\n\n       if (index != -1)\n\n           fd[i] = drives_table[index].bdrv;\n\n       else\n\n           fd[i] = NULL;\n\n\n    floppy_controller = fdctrl_init(i8259[6], 2, 0, 0x3f0, fd);\n\n\n\n    /* Sound card */\n\n#ifdef HAS_AUDIO\n\n    audio_init(pci_bus);\n\n#endif\n\n\n\n    /* Network card */\n\n    network_init(pci_bus);\n\n\n\n    /* Optional PCI video card */\n\n    pci_cirrus_vga_init(pci_bus, phys_ram_base + ram_size,\n\n                        ram_size, vga_ram_size);\n", "idx": 9889, "_split": "valid", "_hash": "c206c5869d4226b1c34a350a3323ca60"}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int ohci_service_td(OHCIState *ohci, struct ohci_ed *ed)\n\n{\n\n    int dir;\n\n    size_t len = 0;\n\n#ifdef DEBUG_PACKET\n\n    const char *str = NULL;\n\n#endif\n\n    int pid;\n\n    int ret;\n\n    int i;\n\n    USBDevice *dev;\n\n    struct ohci_td td;\n\n    uint32_t addr;\n\n    int flag_r;\n\n    int completion;\n\n\n\n    addr = ed->head & OHCI_DPTR_MASK;\n\n    /* See if this TD has already been submitted to the device.  */\n\n    completion = (addr == ohci->async_td);\n\n    if (completion && !ohci->async_complete) {\n\n#ifdef DEBUG_PACKET\n\n        DPRINTF(\"Skipping async TD\\n\");\n\n#endif\n\n        return 1;\n\n    }\n\n    if (!ohci_read_td(ohci, addr, &td)) {\n\n        fprintf(stderr, \"usb-ohci: TD read error at %x\\n\", addr);\n\n        return 0;\n\n    }\n\n\n\n    dir = OHCI_BM(ed->flags, ED_D);\n\n    switch (dir) {\n\n    case OHCI_TD_DIR_OUT:\n\n    case OHCI_TD_DIR_IN:\n\n        /* Same value.  */\n\n        break;\n\n    default:\n\n        dir = OHCI_BM(td.flags, TD_DP);\n\n        break;\n\n    }\n\n\n\n    switch (dir) {\n\n    case OHCI_TD_DIR_IN:\n\n#ifdef DEBUG_PACKET\n\n        str = \"in\";\n\n#endif\n\n        pid = USB_TOKEN_IN;\n\n        break;\n\n    case OHCI_TD_DIR_OUT:\n\n#ifdef DEBUG_PACKET\n\n        str = \"out\";\n\n#endif\n\n        pid = USB_TOKEN_OUT;\n\n        break;\n\n    case OHCI_TD_DIR_SETUP:\n\n#ifdef DEBUG_PACKET\n\n        str = \"setup\";\n\n#endif\n\n        pid = USB_TOKEN_SETUP;\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"usb-ohci: Bad direction\\n\");\n\n        return 1;\n\n    }\n\n    if (td.cbp && td.be) {\n\n        if ((td.cbp & 0xfffff000) != (td.be & 0xfffff000)) {\n\n            len = (td.be & 0xfff) + 0x1001 - (td.cbp & 0xfff);\n\n        } else {\n\n            len = (td.be - td.cbp) + 1;\n\n        }\n\n\n\n        if (len && dir != OHCI_TD_DIR_IN && !completion) {\n\n            ohci_copy_td(ohci, &td, ohci->usb_buf, len, 0);\n\n        }\n\n    }\n\n\n\n    flag_r = (td.flags & OHCI_TD_R) != 0;\n\n#ifdef DEBUG_PACKET\n\n    DPRINTF(\" TD @ 0x%.8x %\" PRId64 \" bytes %s r=%d cbp=0x%.8x be=0x%.8x\\n\",\n\n            addr, (int64_t)len, str, flag_r, td.cbp, td.be);\n\n\n\n    if (len > 0 && dir != OHCI_TD_DIR_IN) {\n\n        DPRINTF(\"  data:\");\n\n        for (i = 0; i < len; i++)\n\n            printf(\" %.2x\", ohci->usb_buf[i]);\n\n        DPRINTF(\"\\n\");\n\n    }\n\n#endif\n\n    if (completion) {\n\n        ret = ohci->usb_packet.len;\n\n        ohci->async_td = 0;\n\n        ohci->async_complete = 0;\n\n    } else {\n\n        ret = USB_RET_NODEV;\n\n        for (i = 0; i < ohci->num_ports; i++) {\n\n            dev = ohci->rhport[i].port.dev;\n\n            if ((ohci->rhport[i].ctrl & OHCI_PORT_PES) == 0)\n\n                continue;\n\n\n\n            if (ohci->async_td) {\n\n                /* ??? The hardware should allow one active packet per\n\n                   endpoint.  We only allow one active packet per controller.\n\n                   This should be sufficient as long as devices respond in a\n\n                   timely manner.\n\n                 */\n\n#ifdef DEBUG_PACKET\n\n                DPRINTF(\"Too many pending packets\\n\");\n\n#endif\n\n                return 1;\n\n            }\n\n            ohci->usb_packet.pid = pid;\n\n            ohci->usb_packet.devaddr = OHCI_BM(ed->flags, ED_FA);\n\n            ohci->usb_packet.devep = OHCI_BM(ed->flags, ED_EN);\n\n            ohci->usb_packet.data = ohci->usb_buf;\n\n            ohci->usb_packet.len = len;\n\n            ret = usb_handle_packet(dev, &ohci->usb_packet);\n\n            if (ret != USB_RET_NODEV)\n\n                break;\n\n        }\n\n#ifdef DEBUG_PACKET\n\n        DPRINTF(\"ret=%d\\n\", ret);\n\n#endif\n\n        if (ret == USB_RET_ASYNC) {\n\n            ohci->async_td = addr;\n\n            return 1;\n\n        }\n\n    }\n\n    if (ret >= 0) {\n\n        if (dir == OHCI_TD_DIR_IN) {\n\n            ohci_copy_td(ohci, &td, ohci->usb_buf, ret, 1);\n\n#ifdef DEBUG_PACKET\n\n            DPRINTF(\"  data:\");\n\n            for (i = 0; i < ret; i++)\n\n                printf(\" %.2x\", ohci->usb_buf[i]);\n\n            DPRINTF(\"\\n\");\n\n#endif\n\n        } else {\n\n            ret = len;\n\n        }\n\n    }\n\n\n\n    /* Writeback */\n\n    if (ret == len || (dir == OHCI_TD_DIR_IN && ret >= 0 && flag_r)) {\n\n        /* Transmission succeeded.  */\n\n        if (ret == len) {\n\n            td.cbp = 0;\n\n        } else {\n\n            td.cbp += ret;\n\n            if ((td.cbp & 0xfff) + ret > 0xfff) {\n\n                td.cbp &= 0xfff;\n\n                td.cbp |= td.be & ~0xfff;\n\n            }\n\n        }\n\n        td.flags |= OHCI_TD_T1;\n\n        td.flags ^= OHCI_TD_T0;\n\n        OHCI_SET_BM(td.flags, TD_CC, OHCI_CC_NOERROR);\n\n        OHCI_SET_BM(td.flags, TD_EC, 0);\n\n\n\n        ed->head &= ~OHCI_ED_C;\n\n        if (td.flags & OHCI_TD_T0)\n\n            ed->head |= OHCI_ED_C;\n\n    } else {\n\n        if (ret >= 0) {\n\n            DPRINTF(\"usb-ohci: Underrun\\n\");\n\n            OHCI_SET_BM(td.flags, TD_CC, OHCI_CC_DATAUNDERRUN);\n\n        } else {\n\n            switch (ret) {\n\n            case USB_RET_NODEV:\n\n                OHCI_SET_BM(td.flags, TD_CC, OHCI_CC_DEVICENOTRESPONDING);\n\n            case USB_RET_NAK:\n\n                DPRINTF(\"usb-ohci: got NAK\\n\");\n\n                return 1;\n\n            case USB_RET_STALL:\n\n                DPRINTF(\"usb-ohci: got STALL\\n\");\n\n                OHCI_SET_BM(td.flags, TD_CC, OHCI_CC_STALL);\n\n                break;\n\n            case USB_RET_BABBLE:\n\n                DPRINTF(\"usb-ohci: got BABBLE\\n\");\n\n                OHCI_SET_BM(td.flags, TD_CC, OHCI_CC_DATAOVERRUN);\n\n                break;\n\n            default:\n\n                fprintf(stderr, \"usb-ohci: Bad device response %d\\n\", ret);\n\n                OHCI_SET_BM(td.flags, TD_CC, OHCI_CC_UNDEXPETEDPID);\n\n                OHCI_SET_BM(td.flags, TD_EC, 3);\n\n                break;\n\n            }\n\n        }\n\n        ed->head |= OHCI_ED_H;\n\n    }\n\n\n\n    /* Retire this TD */\n\n    ed->head &= ~OHCI_DPTR_MASK;\n\n    ed->head |= td.next & OHCI_DPTR_MASK;\n\n    td.next = ohci->done;\n\n    ohci->done = addr;\n\n    i = OHCI_BM(td.flags, TD_DI);\n\n    if (i < ohci->done_count)\n\n        ohci->done_count = i;\n\n    ohci_put_td(ohci, addr, &td);\n\n    return OHCI_BM(td.flags, TD_CC) != OHCI_CC_NOERROR;\n\n}\n", "idx": 9890, "_split": "valid", "_hash": "adcebf4313c8fc3c22ce8eae92ec5c38"}
{"project": "qemu", "commit_id": "8daea510951dd309a44cea8de415c685c43851cf", "target": 1, "func": "void qdev_prop_set_drive(DeviceState *dev, const char *name,\n\n                         BlockBackend *value, Error **errp)\n\n{\n\n    object_property_set_str(OBJECT(dev), value ? blk_name(value) : \"\",\n\n                            name, errp);\n\n}\n", "idx": 9893, "_split": "valid", "_hash": "05a0e22e139c015fd37f1d3bce430b78"}
{"project": "qemu", "commit_id": "5c843af22604edecda10d4bb89d4eede9e1bd3d0", "target": 1, "func": "int net_slirp_redir(const char *redir_str)\n\n{\n\n    struct slirp_config_str *config;\n\n\n\n    if (QTAILQ_EMPTY(&slirp_stacks)) {\n\n        config = g_malloc(sizeof(*config));\n\n        pstrcpy(config->str, sizeof(config->str), redir_str);\n\n        config->flags = SLIRP_CFG_HOSTFWD | SLIRP_CFG_LEGACY;\n\n        config->next = slirp_configs;\n\n        slirp_configs = config;\n\n        return 0;\n\n    }\n\n\n\n    return slirp_hostfwd(QTAILQ_FIRST(&slirp_stacks), redir_str, 1);\n\n}\n", "idx": 9894, "_split": "valid", "_hash": "5604361b5b02c4fc870fc112b255d7a6"}
{"project": "qemu", "commit_id": "b0b1d69079fcb9453f45aade9e9f6b71422147b0", "target": 1, "func": "static void kvm_invoke_set_guest_debug(void *data)\n\n{\n\n    struct kvm_set_guest_debug_data *dbg_data = data;\n\n    CPUState *env = dbg_data->env;\n\n\n\n    if (env->kvm_vcpu_dirty) {\n\n        kvm_arch_put_registers(env);\n\n        env->kvm_vcpu_dirty = 0;\n\n    }\n\n    dbg_data->err = kvm_vcpu_ioctl(env, KVM_SET_GUEST_DEBUG, &dbg_data->dbg);\n\n}\n", "idx": 9904, "_split": "valid", "_hash": "bb462e5ab445f0679ad34ebed43cd275"}
{"project": "qemu", "commit_id": "f8c35c1d59c9fecf79f6d5a02cd09f472a6f411d", "target": 0, "func": "static void bdrv_rw_em_cb(void *opaque, int ret)\n\n{\n\n    *(int *)opaque = ret;\n\n}\n", "idx": 9964, "_split": "valid", "_hash": "c4f67f4dec5526bcdb0330d1ea86105a"}
{"project": "qemu", "commit_id": "9d6f106552fa5ad9e3128b5052863835526ba271", "target": 0, "func": "void ppc_set_compat(PowerPCCPU *cpu, uint32_t compat_pvr, Error **errp)\n\n{\n\n    int ret = 0;\n\n    CPUPPCState *env = &cpu->env;\n\n    PowerPCCPUClass *host_pcc;\n\n\n\n    cpu->compat_pvr = compat_pvr;\n\n\n\n    switch (compat_pvr) {\n\n    case CPU_POWERPC_LOGICAL_2_05:\n\n        env->spr[SPR_PCR] = PCR_TM_DIS | PCR_VSX_DIS | PCR_COMPAT_2_07 |\n\n                            PCR_COMPAT_2_06 | PCR_COMPAT_2_05;\n\n        break;\n\n    case CPU_POWERPC_LOGICAL_2_06:\n\n    case CPU_POWERPC_LOGICAL_2_06_PLUS:\n\n        env->spr[SPR_PCR] = PCR_TM_DIS | PCR_COMPAT_2_07 | PCR_COMPAT_2_06;\n\n        break;\n\n    case CPU_POWERPC_LOGICAL_2_07:\n\n        env->spr[SPR_PCR] = PCR_COMPAT_2_07;\n\n        break;\n\n    default:\n\n        env->spr[SPR_PCR] = 0;\n\n        break;\n\n    }\n\n\n\n    host_pcc = kvm_ppc_get_host_cpu_class();\n\n    if (host_pcc) {\n\n        env->spr[SPR_PCR] &= host_pcc->pcr_mask;\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        ret = kvmppc_set_compat(cpu, cpu->compat_pvr);\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret,\n\n                             \"Unable to set CPU compatibility mode in KVM\");\n\n        }\n\n    }\n\n}\n", "idx": 9969, "_split": "valid", "_hash": "7f1980dad85954c71247abd8c192bb0c"}
{"project": "qemu", "commit_id": "acf6e5f0962c4be670d4a93ede77423512521876", "target": 0, "func": "static coroutine_fn int sd_co_pdiscard(BlockDriverState *bs, int64_t offset,\n\n                                      int count)\n\n{\n\n    SheepdogAIOCB acb;\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    QEMUIOVector discard_iov;\n\n    struct iovec iov;\n\n    uint32_t zero = 0;\n\n\n\n    if (!s->discard_supported) {\n\n        return 0;\n\n    }\n\n\n\n    memset(&discard_iov, 0, sizeof(discard_iov));\n\n    memset(&iov, 0, sizeof(iov));\n\n    iov.iov_base = &zero;\n\n    iov.iov_len = sizeof(zero);\n\n    discard_iov.iov = &iov;\n\n    discard_iov.niov = 1;\n\n    if (!QEMU_IS_ALIGNED(offset | count, BDRV_SECTOR_SIZE)) {\n\n        return -ENOTSUP;\n\n    }\n\n    sd_aio_setup(&acb, s, &discard_iov, offset >> BDRV_SECTOR_BITS,\n\n                 count >> BDRV_SECTOR_BITS, AIOCB_DISCARD_OBJ);\n\n\n\nretry:\n\n    if (check_overlapping_aiocb(s, &acb)) {\n\n        qemu_co_queue_wait(&s->overlapping_queue);\n\n        goto retry;\n\n    }\n\n\n\n    sd_co_rw_vector(&acb);\n\n\n\n    QLIST_REMOVE(&acb, aiocb_siblings);\n\n    qemu_co_queue_restart_all(&s->overlapping_queue);\n\n    return acb.ret;\n\n}\n", "idx": 10004, "_split": "valid", "_hash": "8bec95c15307866f97a32dc1812babe2"}
{"project": "qemu", "commit_id": "880a7578381d1c7ed4d41c7599ae3cc06567a824", "target": 0, "func": "static void gdb_vm_stopped(void *opaque, int reason)\n\n{\n\n    GDBState *s = opaque;\n\n    char buf[256];\n\n    const char *type;\n\n    int ret;\n\n\n\n    if (s->state == RS_SYSCALL)\n\n        return;\n\n\n\n    /* disable single step if it was enable */\n\n    cpu_single_step(s->env, 0);\n\n\n\n    if (reason == EXCP_DEBUG) {\n\n        if (s->env->watchpoint_hit) {\n\n            switch (s->env->watchpoint_hit->flags & BP_MEM_ACCESS) {\n\n            case BP_MEM_READ:\n\n                type = \"r\";\n\n                break;\n\n            case BP_MEM_ACCESS:\n\n                type = \"a\";\n\n                break;\n\n            default:\n\n                type = \"\";\n\n                break;\n\n            }\n\n            snprintf(buf, sizeof(buf), \"T%02x%swatch:\" TARGET_FMT_lx \";\",\n\n                     SIGTRAP, type, s->env->watchpoint_hit->vaddr);\n\n            put_packet(s, buf);\n\n            s->env->watchpoint_hit = NULL;\n\n            return;\n\n        }\n\n\ttb_flush(s->env);\n\n        ret = SIGTRAP;\n\n    } else if (reason == EXCP_INTERRUPT) {\n\n        ret = SIGINT;\n\n    } else {\n\n        ret = 0;\n\n    }\n\n    snprintf(buf, sizeof(buf), \"S%02x\", ret);\n\n    put_packet(s, buf);\n\n}\n", "idx": 10013, "_split": "valid", "_hash": "4518e588f2188e8d423f65e6767137d1"}
{"project": "qemu", "commit_id": "d6085e3ace20bc9b0fa625d8d79b22668710e217", "target": 0, "func": "void qemu_peer_set_offload(NetClientState *nc, int csum, int tso4, int tso6,\n\n                          int ecn, int ufo)\n\n{\n\n    if (!nc->peer || !nc->peer->info->set_offload) {\n\n        return;\n\n    }\n\n\n\n    nc->peer->info->set_offload(nc->peer, csum, tso4, tso6, ecn, ufo);\n\n}\n", "idx": 10015, "_split": "valid", "_hash": "b9d3d0deeca476009d7b24ae778dc529"}
{"project": "qemu", "commit_id": "071663dfc3b93e3f3e573d726cfb685fd25472fa", "target": 0, "func": "uint32_t helper_bcdsetsgn(ppc_avr_t *r, ppc_avr_t *b, uint32_t ps)\n\n{\n\n    int i;\n\n    int invalid = 0;\n\n    int sgnb = bcd_get_sgn(b);\n\n\n\n    *r = *b;\n\n    bcd_put_digit(r, bcd_preferred_sgn(sgnb, ps), 0);\n\n\n\n    for (i = 1; i < 32; i++) {\n\n        bcd_get_digit(b, i, &invalid);\n\n        if (unlikely(invalid)) {\n\n            return CRF_SO;\n\n        }\n\n    }\n\n\n\n    return bcd_cmp_zero(r);\n\n}\n", "idx": 10018, "_split": "valid", "_hash": "5940386aa4e767cf16e9e5eca995bc05"}
{"project": "qemu", "commit_id": "393a98924eb00df76231384b86652e1d5f964d67", "target": 0, "func": "uint32_t msix_bar_size(PCIDevice *dev)\n\n{\n\n    return (dev->cap_present & QEMU_PCI_CAP_MSIX) ?\n\n        dev->msix_bar_size : 0;\n\n}\n", "idx": 10020, "_split": "valid", "_hash": "f3836683b4f28bb7a2ed501f1e4d17cb"}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf)\n\n{\n\n    VirtIOBlock *s;\n\n    int cylinders, heads, secs;\n\n    static int virtio_blk_id;\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = conf->dinfo->bdrv;\n\n    s->conf = conf;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    register_savevm(\"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n\n\n    return &s->vdev;\n\n}\n", "idx": 10056, "_split": "valid", "_hash": "3ec84c93d10098e73148015b7ce0142e"}
{"project": "qemu", "commit_id": "e5b8b0d4ba29fe1268ba049519a1b0cf8552a21a", "target": 0, "func": "static bool e1000_has_rxbufs(E1000State *s, size_t total_size)\n\n{\n\n    int bufs;\n\n    /* Fast-path short packets */\n\n    if (total_size <= s->rxbuf_size) {\n\n        return s->mac_reg[RDH] != s->mac_reg[RDT] || !s->check_rxov;\n\n    }\n\n    if (s->mac_reg[RDH] < s->mac_reg[RDT]) {\n\n        bufs = s->mac_reg[RDT] - s->mac_reg[RDH];\n\n    } else if (s->mac_reg[RDH] > s->mac_reg[RDT] || !s->check_rxov) {\n\n        bufs = s->mac_reg[RDLEN] /  sizeof(struct e1000_rx_desc) +\n\n            s->mac_reg[RDT] - s->mac_reg[RDH];\n\n    } else {\n\n        return false;\n\n    }\n\n    return total_size <= bufs * s->rxbuf_size;\n\n}\n", "idx": 10077, "_split": "valid", "_hash": "64236f37efe92f94151568677dbcaa34"}
{"project": "qemu", "commit_id": "d2164ad35c411d97abd2aa5c6f160283d215e214", "target": 1, "func": "static int get_uint8_equal(QEMUFile *f, void *pv, size_t size,\n\n                           VMStateField *field)\n\n{\n\n    uint8_t *v = pv;\n\n    uint8_t v2;\n\n    qemu_get_8s(f, &v2);\n\n\n\n    if (*v == v2) {\n\n        return 0;\n\n\n    error_report(\"%x != %x\", *v, v2);\n\n\n\n\n    return -EINVAL;\n", "idx": 10110, "_split": "valid", "_hash": "f1f7a0d2f553eda363de3da2ce4bad49"}
{"project": "qemu", "commit_id": "a67e128a4f40cf07abd86f92d0d3c913db2ad885", "target": 1, "func": "static int vhdx_create_bat(BlockDriverState *bs, BDRVVHDXState *s,\n\n                           uint64_t image_size, VHDXImageType type,\n\n                           bool use_zero_blocks, uint64_t file_offset,\n\n                           uint32_t length)\n\n{\n\n    int ret = 0;\n\n    uint64_t data_file_offset;\n\n    uint64_t total_sectors = 0;\n\n    uint64_t sector_num = 0;\n\n    uint64_t unused;\n\n    int block_state;\n\n    VHDXSectorInfo sinfo;\n\n\n\n    assert(s->bat == NULL);\n\n\n\n    /* this gives a data start after BAT/bitmap entries, and well\n\n     * past any metadata entries (with a 4 MB buffer for future\n\n     * expansion */\n\n    data_file_offset = file_offset + length + 5 * MiB;\n\n    total_sectors = image_size >> s->logical_sector_size_bits;\n\n\n\n    if (type == VHDX_TYPE_DYNAMIC) {\n\n        /* All zeroes, so we can just extend the file - the end of the BAT\n\n         * is the furthest thing we have written yet */\n\n        ret = bdrv_truncate(bs, data_file_offset);\n\n        if (ret < 0) {\n\n            goto exit;\n\n        }\n\n    } else if (type == VHDX_TYPE_FIXED) {\n\n        ret = bdrv_truncate(bs, data_file_offset + image_size);\n\n        if (ret < 0) {\n\n            goto exit;\n\n        }\n\n    } else {\n\n        ret = -ENOTSUP;\n\n        goto exit;\n\n    }\n\n\n\n    if (type == VHDX_TYPE_FIXED ||\n\n                use_zero_blocks ||\n\n                bdrv_has_zero_init(bs) == 0) {\n\n        /* for a fixed file, the default BAT entry is not zero */\n\n        s->bat = g_malloc0(length);\n\n        block_state = type == VHDX_TYPE_FIXED ? PAYLOAD_BLOCK_FULLY_PRESENT :\n\n                                                PAYLOAD_BLOCK_NOT_PRESENT;\n\n        block_state = use_zero_blocks ? PAYLOAD_BLOCK_ZERO : block_state;\n\n        /* fill the BAT by emulating sector writes of sectors_per_block size */\n\n        while (sector_num < total_sectors) {\n\n            vhdx_block_translate(s, sector_num, s->sectors_per_block, &sinfo);\n\n            sinfo.file_offset = data_file_offset +\n\n                                (sector_num << s->logical_sector_size_bits);\n\n            sinfo.file_offset = ROUND_UP(sinfo.file_offset, MiB);\n\n            vhdx_update_bat_table_entry(bs, s, &sinfo, &unused, &unused,\n\n                                        block_state);\n\n            cpu_to_le64s(&s->bat[sinfo.bat_idx]);\n\n            sector_num += s->sectors_per_block;\n\n        }\n\n        ret = bdrv_pwrite(bs, file_offset, s->bat, length);\n\n        if (ret < 0) {\n\n            goto exit;\n\n        }\n\n    }\n\n\n\n\n\n\n\nexit:\n\n    g_free(s->bat);\n\n    return ret;\n\n}\n", "idx": 10115, "_split": "valid", "_hash": "3886ef61562421fa9f5c1d23e28b1bed"}
{"project": "qemu", "commit_id": "249e7e0fff080df0eff54730f3b6459d92d61e5a", "target": 0, "func": "static void cpu_ioreq_move(ioreq_t *req)\n\n{\n\n    int i;\n\n\n\n    if (!req->data_is_ptr) {\n\n        if (req->dir == IOREQ_READ) {\n\n            for (i = 0; i < req->count; i++) {\n\n                read_phys_req_item(req->addr, req, i, &req->data);\n\n            }\n\n        } else if (req->dir == IOREQ_WRITE) {\n\n            for (i = 0; i < req->count; i++) {\n\n                write_phys_req_item(req->addr, req, i, &req->data);\n\n            }\n\n        }\n\n    } else {\n\n        uint64_t tmp;\n\n\n\n        if (req->dir == IOREQ_READ) {\n\n            for (i = 0; i < req->count; i++) {\n\n                read_phys_req_item(req->addr, req, i, &tmp);\n\n                write_phys_req_item(req->data, req, i, &tmp);\n\n            }\n\n        } else if (req->dir == IOREQ_WRITE) {\n\n            for (i = 0; i < req->count; i++) {\n\n                read_phys_req_item(req->data, req, i, &tmp);\n\n                write_phys_req_item(req->addr, req, i, &tmp);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 10124, "_split": "valid", "_hash": "fc77b27ebbeb0bfc6db43a13577729db"}
{"project": "qemu", "commit_id": "e1c37d0e94048502f9874e6356ce7136d4b05bdb", "target": 0, "func": "bool qemu_savevm_state_blocked(Monitor *mon)\n\n{\n\n    SaveStateEntry *se;\n\n\n\n    QTAILQ_FOREACH(se, &savevm_handlers, entry) {\n\n        if (se->no_migrate) {\n\n            monitor_printf(mon, \"state blocked by non-migratable device '%s'\\n\",\n\n                           se->idstr);\n\n            return true;\n\n        }\n\n    }\n\n    return false;\n\n}\n", "idx": 10133, "_split": "valid", "_hash": "5e942700f0f2ed8a212dfe8d9754beff"}
{"project": "qemu", "commit_id": "d2cb36af2b0040d421b347e6e4e803e07220f78d", "target": 0, "func": "static coroutine_fn int qcow2_co_pwrite_zeroes(BlockDriverState *bs,\n\n    int64_t offset, int count, BdrvRequestFlags flags)\n\n{\n\n    int ret;\n\n    BDRVQcow2State *s = bs->opaque;\n\n\n\n    uint32_t head = offset % s->cluster_size;\n\n    uint32_t tail = (offset + count) % s->cluster_size;\n\n\n\n    trace_qcow2_pwrite_zeroes_start_req(qemu_coroutine_self(), offset, count);\n\n    if (offset + count == bs->total_sectors * BDRV_SECTOR_SIZE) {\n\n        tail = 0;\n\n    }\n\n\n\n    if (head || tail) {\n\n        int64_t cl_start = (offset - head) >> BDRV_SECTOR_BITS;\n\n        uint64_t off;\n\n        unsigned int nr;\n\n\n\n        assert(head + count <= s->cluster_size);\n\n\n\n        /* check whether remainder of cluster already reads as zero */\n\n        if (!(is_zero_sectors(bs, cl_start,\n\n                              DIV_ROUND_UP(head, BDRV_SECTOR_SIZE)) &&\n\n              is_zero_sectors(bs, (offset + count) >> BDRV_SECTOR_BITS,\n\n                              DIV_ROUND_UP(-tail & (s->cluster_size - 1),\n\n                                           BDRV_SECTOR_SIZE)))) {\n\n            return -ENOTSUP;\n\n        }\n\n\n\n        qemu_co_mutex_lock(&s->lock);\n\n        /* We can have new write after previous check */\n\n        offset = cl_start << BDRV_SECTOR_BITS;\n\n        count = s->cluster_size;\n\n        nr = s->cluster_size;\n\n        ret = qcow2_get_cluster_offset(bs, offset, &nr, &off);\n\n        if (ret != QCOW2_CLUSTER_UNALLOCATED &&\n\n            ret != QCOW2_CLUSTER_ZERO_PLAIN &&\n\n            ret != QCOW2_CLUSTER_ZERO_ALLOC) {\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            return -ENOTSUP;\n\n        }\n\n    } else {\n\n        qemu_co_mutex_lock(&s->lock);\n\n    }\n\n\n\n    trace_qcow2_pwrite_zeroes(qemu_coroutine_self(), offset, count);\n\n\n\n    /* Whatever is left can use real zero clusters */\n\n    ret = qcow2_zero_clusters(bs, offset, count >> BDRV_SECTOR_BITS, flags);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    return ret;\n\n}\n", "idx": 10136, "_split": "valid", "_hash": "462e6dbb0e18166c682ca9920dd80e92"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_abso(DisasContext *ctx)\n\n{\n\n    int l1 = gen_new_label();\n\n    int l2 = gen_new_label();\n\n    int l3 = gen_new_label();\n\n    /* Start with XER OV disabled, the most likely case */\n\n    tcg_gen_movi_tl(cpu_ov, 0);\n\n    tcg_gen_brcondi_tl(TCG_COND_GE, cpu_gpr[rA(ctx->opcode)], 0, l2);\n\n    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_gpr[rA(ctx->opcode)], 0x80000000, l1);\n\n    tcg_gen_movi_tl(cpu_ov, 1);\n\n    tcg_gen_movi_tl(cpu_so, 1);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_neg_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_br(l3);\n\n    gen_set_label(l2);\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    gen_set_label(l3);\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rD(ctx->opcode)]);\n\n}\n", "idx": 10137, "_split": "valid", "_hash": "72c586ddec49acf68e027997ee912d97"}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "DeviceState *sysbus_create_varargs(const char *name,\n\n                                   target_phys_addr_t addr, ...)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    va_list va;\n\n    qemu_irq irq;\n\n    int n;\n\n\n\n    dev = qdev_create(NULL, name);\n\n    s = sysbus_from_qdev(dev);\n\n    qdev_init(dev);\n\n    if (addr != (target_phys_addr_t)-1) {\n\n        sysbus_mmio_map(s, 0, addr);\n\n    }\n\n    va_start(va, addr);\n\n    n = 0;\n\n    while (1) {\n\n        irq = va_arg(va, qemu_irq);\n\n        if (!irq) {\n\n            break;\n\n        }\n\n        sysbus_connect_irq(s, n, irq);\n\n        n++;\n\n    }\n\n    return dev;\n\n}\n", "idx": 10146, "_split": "valid", "_hash": "fb154af83e810c73d2224fb42f9e8062"}
{"project": "qemu", "commit_id": "9dbae97723e964692364fb43012c6fa5448a661f", "target": 1, "func": "int spapr_populate_pci_dt(sPAPRPHBState *phb,\n\n                          uint32_t xics_phandle,\n\n                          void *fdt)\n\n{\n\n    int bus_off, i, j;\n\n    char nodename[256];\n\n    uint32_t bus_range[] = { cpu_to_be32(0), cpu_to_be32(0xff) };\n\n    struct {\n\n        uint32_t hi;\n\n        uint64_t child;\n\n        uint64_t parent;\n\n        uint64_t size;\n\n    } QEMU_PACKED ranges[] = {\n\n        {\n\n            cpu_to_be32(b_ss(1)), cpu_to_be64(0),\n\n            cpu_to_be64(phb->io_win_addr),\n\n            cpu_to_be64(memory_region_size(&phb->iospace)),\n\n        },\n\n        {\n\n            cpu_to_be32(b_ss(2)), cpu_to_be64(SPAPR_PCI_MEM_WIN_BUS_OFFSET),\n\n            cpu_to_be64(phb->mem_win_addr),\n\n            cpu_to_be64(memory_region_size(&phb->memwindow)),\n\n        },\n\n    };\n\n    uint64_t bus_reg[] = { cpu_to_be64(phb->buid), 0 };\n\n    uint32_t interrupt_map_mask[] = {\n\n        cpu_to_be32(b_ddddd(-1)|b_fff(0)), 0x0, 0x0, cpu_to_be32(-1)};\n\n    uint32_t interrupt_map[PCI_SLOT_MAX * PCI_NUM_PINS][7];\n\n\n\n    /* Start populating the FDT */\n\n    sprintf(nodename, \"pci@%\" PRIx64, phb->buid);\n\n    bus_off = fdt_add_subnode(fdt, 0, nodename);\n\n    if (bus_off < 0) {\n\n        return bus_off;\n\n    }\n\n\n\n#define _FDT(exp) \\\n\n    do { \\\n\n        int ret = (exp);                                           \\\n\n        if (ret < 0) {                                             \\\n\n            return ret;                                            \\\n\n        }                                                          \\\n\n    } while (0)\n\n\n\n    /* Write PHB properties */\n\n    _FDT(fdt_setprop_string(fdt, bus_off, \"device_type\", \"pci\"));\n\n    _FDT(fdt_setprop_string(fdt, bus_off, \"compatible\", \"IBM,Logical_PHB\"));\n\n    _FDT(fdt_setprop_cell(fdt, bus_off, \"#address-cells\", 0x3));\n\n    _FDT(fdt_setprop_cell(fdt, bus_off, \"#size-cells\", 0x2));\n\n    _FDT(fdt_setprop_cell(fdt, bus_off, \"#interrupt-cells\", 0x1));\n\n    _FDT(fdt_setprop(fdt, bus_off, \"used-by-rtas\", NULL, 0));\n\n    _FDT(fdt_setprop(fdt, bus_off, \"bus-range\", &bus_range, sizeof(bus_range)));\n\n    _FDT(fdt_setprop(fdt, bus_off, \"ranges\", &ranges, sizeof(ranges)));\n\n    _FDT(fdt_setprop(fdt, bus_off, \"reg\", &bus_reg, sizeof(bus_reg)));\n\n    _FDT(fdt_setprop_cell(fdt, bus_off, \"ibm,pci-config-space-type\", 0x1));\n\n\n\n\n    /* Build the interrupt-map, this must matches what is done\n\n     * in pci_spapr_map_irq\n\n     */\n\n    _FDT(fdt_setprop(fdt, bus_off, \"interrupt-map-mask\",\n\n                     &interrupt_map_mask, sizeof(interrupt_map_mask)));\n\n    for (i = 0; i < PCI_SLOT_MAX; i++) {\n\n        for (j = 0; j < PCI_NUM_PINS; j++) {\n\n            uint32_t *irqmap = interrupt_map[i*PCI_NUM_PINS + j];\n\n            int lsi_num = pci_spapr_swizzle(i, j);\n\n\n\n            irqmap[0] = cpu_to_be32(b_ddddd(i)|b_fff(0));\n\n            irqmap[1] = 0;\n\n            irqmap[2] = 0;\n\n            irqmap[3] = cpu_to_be32(j+1);\n\n            irqmap[4] = cpu_to_be32(xics_phandle);\n\n            irqmap[5] = cpu_to_be32(phb->lsi_table[lsi_num].irq);\n\n            irqmap[6] = cpu_to_be32(0x8);\n\n        }\n\n    }\n\n    /* Write interrupt map */\n\n    _FDT(fdt_setprop(fdt, bus_off, \"interrupt-map\", &interrupt_map,\n\n                     sizeof(interrupt_map)));\n\n\n\n    object_child_foreach(OBJECT(phb), spapr_phb_children_dt,\n\n                         &((sPAPRTCEDT){ .fdt = fdt, .node_off = bus_off }));\n\n\n\n    return 0;\n\n}", "idx": 10159, "_split": "valid", "_hash": "c9b543414e0ce1dbceb01297afc8b298"}
{"project": "qemu", "commit_id": "2b584959ed300ddff4acba0d7554becad5f274fd", "target": 0, "func": "void bdrv_set_translation_hint(BlockDriverState *bs, int translation)\n\n{\n\n    bs->translation = translation;\n\n}\n", "idx": 10187, "_split": "valid", "_hash": "1eae7132eb409323e0d936fd7c9c4226"}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static int coroutine_fn raw_co_preadv(BlockDriverState *bs, uint64_t offset,\n\n                                      uint64_t bytes, QEMUIOVector *qiov,\n\n                                      int flags)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n\n\n    if (offset > UINT64_MAX - s->offset) {\n\n        return -EINVAL;\n\n    }\n\n    offset += s->offset;\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);\n\n}\n", "idx": 10193, "_split": "valid", "_hash": "87461bbb660d800fa705de60d327434b"}
{"project": "qemu", "commit_id": "ef546f1275f6563e8934dd5e338d29d9f9909ca6", "target": 0, "func": "static bool balloon_stats_supported(const VirtIOBalloon *s)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    return vdev->guest_features & (1 << VIRTIO_BALLOON_F_STATS_VQ);\n\n}\n", "idx": 10212, "_split": "valid", "_hash": "4f62d62e3e8fa16b72281e9e78f46809"}
{"project": "qemu", "commit_id": "82258945ef2cc4a4ec7cdcef02e751bd30cb199f", "target": 1, "func": "static void pm_update_sci(PIIX4PMState *s)\n\n{\n\n    int sci_level, pmsts;\n\n    int64_t expire_time;\n\n\n\n    pmsts = get_pmsts(s);\n\n    sci_level = (((pmsts & s->pmen) &\n\n                  (RTC_EN | PWRBTN_EN | GBL_EN | TMROF_EN)) != 0);\n\n    qemu_set_irq(s->irq, sci_level);\n\n    /* schedule a timer interruption if needed */\n\n    if ((s->pmen & TMROF_EN) && !(pmsts & TMROF_EN)) {\n\n        expire_time = muldiv64(s->tmr_overflow_time, ticks_per_sec, PM_FREQ);\n\n        qemu_mod_timer(s->tmr_timer, expire_time);\n\n        s->tmr_overflow_time += 0x800000;\n\n    } else {\n\n        qemu_del_timer(s->tmr_timer);\n\n    }\n\n}\n", "idx": 10215, "_split": "valid", "_hash": "9763bcca84685ab0224f4bf3f4ba68da"}
{"project": "qemu", "commit_id": "237d78f8fc62e62f62246883ecf62e44ed35fb80", "target": 0, "func": "static int discard_single_l2(BlockDriverState *bs, uint64_t offset,\n\n                             uint64_t nb_clusters, enum qcow2_discard_type type,\n\n                             bool full_discard)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t *l2_table;\n\n    int l2_index;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Limit nb_clusters to one L2 table */\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n    assert(nb_clusters <= INT_MAX);\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t old_l2_entry;\n\n\n\n        old_l2_entry = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        /*\n\n         * If full_discard is false, make sure that a discarded area reads back\n\n         * as zeroes for v3 images (we cannot do it for v2 without actually\n\n         * writing a zero-filled buffer). We can skip the operation if the\n\n         * cluster is already marked as zero, or if it's unallocated and we\n\n         * don't have a backing file.\n\n         *\n\n         * TODO We might want to use bdrv_get_block_status(bs) here, but we're\n\n         * holding s->lock, so that doesn't work today.\n\n         *\n\n         * If full_discard is true, the sector should not read back as zeroes,\n\n         * but rather fall through to the backing file.\n\n         */\n\n        switch (qcow2_get_cluster_type(old_l2_entry)) {\n\n        case QCOW2_CLUSTER_UNALLOCATED:\n\n            if (full_discard || !bs->backing) {\n\n                continue;\n\n            }\n\n            break;\n\n\n\n        case QCOW2_CLUSTER_ZERO_PLAIN:\n\n            if (!full_discard) {\n\n                continue;\n\n            }\n\n            break;\n\n\n\n        case QCOW2_CLUSTER_ZERO_ALLOC:\n\n        case QCOW2_CLUSTER_NORMAL:\n\n        case QCOW2_CLUSTER_COMPRESSED:\n\n            break;\n\n\n\n        default:\n\n            abort();\n\n        }\n\n\n\n        /* First remove L2 entries */\n\n        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n\n        if (!full_discard && s->qcow_version >= 3) {\n\n            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);\n\n        } else {\n\n            l2_table[l2_index + i] = cpu_to_be64(0);\n\n        }\n\n\n\n        /* Then decrease the refcount */\n\n        qcow2_free_any_clusters(bs, old_l2_entry, 1, type);\n\n    }\n\n\n\n    qcow2_cache_put(bs, s->l2_table_cache, (void **) &l2_table);\n\n\n\n    return nb_clusters;\n\n}\n", "idx": 10222, "_split": "valid", "_hash": "8d6d7f642e86944bebddd0312b9727d2"}
{"project": "qemu", "commit_id": "2c62f08ddbf3fa80dc7202eb9a2ea60ae44e2cc5", "target": 0, "func": "static void g364fb_init(DeviceState *dev, G364State *s)\n\n{\n\n    s->vram = g_malloc0(s->vram_size);\n\n\n\n    s->con = graphic_console_init(g364fb_update_display,\n\n                                  g364fb_invalidate_display,\n\n                                  g364fb_screen_dump, NULL, s);\n\n\n\n    memory_region_init_io(&s->mem_ctrl, &g364fb_ctrl_ops, s, \"ctrl\", 0x180000);\n\n    memory_region_init_ram_ptr(&s->mem_vram, \"vram\",\n\n                               s->vram_size, s->vram);\n\n    vmstate_register_ram(&s->mem_vram, dev);\n\n    memory_region_set_coalescing(&s->mem_vram);\n\n}\n", "idx": 10239, "_split": "valid", "_hash": "890613d2eb7e6ea7741afdc658466187"}
{"project": "qemu", "commit_id": "28c5af54c661e73e5596918fa67a22b5e87c2022", "target": 0, "func": "static void ppc_prep_init (int ram_size, int vga_ram_size, const char *boot_device,\n\n                           DisplayState *ds, const char **fd_filename,\n\n                           int snapshot, const char *kernel_filename,\n\n                           const char *kernel_cmdline,\n\n                           const char *initrd_filename,\n\n                           const char *cpu_model)\n\n{\n\n    CPUState *env, *envs[MAX_CPUS];\n\n    char buf[1024];\n\n    nvram_t nvram;\n\n    m48t59_t *m48t59;\n\n    int PPC_io_memory;\n\n    int linux_boot, i, nb_nics1, bios_size;\n\n    unsigned long bios_offset;\n\n    uint32_t kernel_base, kernel_size, initrd_base, initrd_size;\n\n    PCIBus *pci_bus;\n\n    qemu_irq *i8259;\n\n    int ppc_boot_device = boot_device[0];\n\n\n\n    sysctrl = qemu_mallocz(sizeof(sysctrl_t));\n\n    if (sysctrl == NULL)\n\n        return;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL)\n\n        cpu_model = \"default\";\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        /* Set time-base frequency to 100 Mhz */\n\n        cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n        qemu_register_reset(&cpu_ppc_reset, env);\n\n        register_savevm(\"cpu\", 0, 3, cpu_save, cpu_load, env);\n\n        envs[i] = env;\n\n    }\n\n\n\n    /* allocate RAM */\n\n    cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);\n\n\n\n    /* allocate and load BIOS */\n\n    bios_offset = ram_size + vga_ram_size;\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, bios_name);\n\n    bios_size = load_image(buf, phys_ram_base + bios_offset);\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        cpu_abort(env, \"qemu: could not load PPC PREP bios '%s'\\n\", buf);\n\n        exit(1);\n\n    }\n\n    if (env->nip < 0xFFF80000 && bios_size < 0x00100000) {\n\n        cpu_abort(env, \"PowerPC 601 / 620 / 970 need a 1MB BIOS\\n\");\n\n    }\n\n    bios_size = (bios_size + 0xfff) & ~0xfff;\n\n    cpu_register_physical_memory((uint32_t)(-bios_size),\n\n                                 bios_size, bios_offset | IO_MEM_ROM);\n\n\n\n    if (linux_boot) {\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* now we can load the kernel */\n\n        kernel_size = load_image(kernel_filename, phys_ram_base + kernel_base);\n\n        if (kernel_size < 0) {\n\n            cpu_abort(env, \"qemu: could not load kernel '%s'\\n\",\n\n                      kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image(initrd_filename,\n\n                                     phys_ram_base + initrd_base);\n\n            if (initrd_size < 0) {\n\n                cpu_abort(env, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                          initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n    }\n\n\n\n    isa_mem_base = 0xc0000000;\n\n    if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) {\n\n        cpu_abort(env, \"Only 6xx bus is supported on PREP machine\\n\");\n\n        exit(1);\n\n    }\n\n    i8259 = i8259_init(first_cpu->irq_inputs[PPC6xx_INPUT_INT]);\n\n    pci_bus = pci_prep_init(i8259);\n\n    //    pci_bus = i440fx_init();\n\n    /* Register 8 MB of ISA IO space (needed for non-contiguous map) */\n\n    PPC_io_memory = cpu_register_io_memory(0, PPC_prep_io_read,\n\n                                           PPC_prep_io_write, sysctrl);\n\n    cpu_register_physical_memory(0x80000000, 0x00800000, PPC_io_memory);\n\n\n\n    /* init basic PC hardware */\n\n    pci_vga_init(pci_bus, ds, phys_ram_base + ram_size, ram_size,\n\n                 vga_ram_size, 0, 0);\n\n    //    openpic = openpic_init(0x00000000, 0xF0000000, 1);\n\n    //    pit = pit_init(0x40, i8259[0]);\n\n    rtc_init(0x70, i8259[8]);\n\n\n\n    serial_init(0x3f8, i8259[4], serial_hds[0]);\n\n    nb_nics1 = nb_nics;\n\n    if (nb_nics1 > NE2000_NB_MAX)\n\n        nb_nics1 = NE2000_NB_MAX;\n\n    for(i = 0; i < nb_nics1; i++) {\n\n        if (nd_table[i].model == NULL\n\n            || strcmp(nd_table[i].model, \"ne2k_isa\") == 0) {\n\n            isa_ne2000_init(ne2000_io[i], i8259[ne2000_irq[i]], &nd_table[i]);\n\n        } else {\n\n            pci_nic_init(pci_bus, &nd_table[i], -1);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < 2; i++) {\n\n        isa_ide_init(ide_iobase[i], ide_iobase2[i], i8259[ide_irq[i]],\n\n                     bs_table[2 * i], bs_table[2 * i + 1]);\n\n    }\n\n    i8042_init(i8259[1], i8259[12], 0x60);\n\n    DMA_init(1);\n\n    //    AUD_init();\n\n    //    SB16_init();\n\n\n\n    fdctrl_init(i8259[6], 2, 0, 0x3f0, fd_table);\n\n\n\n    /* Register speaker port */\n\n    register_ioport_read(0x61, 1, 1, speaker_ioport_read, NULL);\n\n    register_ioport_write(0x61, 1, 1, speaker_ioport_write, NULL);\n\n    /* Register fake IO ports for PREP */\n\n    sysctrl->reset_irq = first_cpu->irq_inputs[PPC6xx_INPUT_HRESET];\n\n    register_ioport_read(0x398, 2, 1, &PREP_io_read, sysctrl);\n\n    register_ioport_write(0x398, 2, 1, &PREP_io_write, sysctrl);\n\n    /* System control ports */\n\n    register_ioport_read(0x0092, 0x01, 1, &PREP_io_800_readb, sysctrl);\n\n    register_ioport_write(0x0092, 0x01, 1, &PREP_io_800_writeb, sysctrl);\n\n    register_ioport_read(0x0800, 0x52, 1, &PREP_io_800_readb, sysctrl);\n\n    register_ioport_write(0x0800, 0x52, 1, &PREP_io_800_writeb, sysctrl);\n\n    /* PCI intack location */\n\n    PPC_io_memory = cpu_register_io_memory(0, PPC_intack_read,\n\n                                           PPC_intack_write, NULL);\n\n    cpu_register_physical_memory(0xBFFFFFF0, 0x4, PPC_io_memory);\n\n    /* PowerPC control and status register group */\n\n#if 0\n\n    PPC_io_memory = cpu_register_io_memory(0, PPC_XCSR_read, PPC_XCSR_write,\n\n                                           NULL);\n\n    cpu_register_physical_memory(0xFEFF0000, 0x1000, PPC_io_memory);\n\n#endif\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, 3, -1);\n\n    }\n\n\n\n    m48t59 = m48t59_init(i8259[8], 0, 0x0074, NVRAM_SIZE, 59);\n\n    if (m48t59 == NULL)\n\n        return;\n\n    sysctrl->nvram = m48t59;\n\n\n\n    /* Initialise NVRAM */\n\n    nvram.opaque = m48t59;\n\n    nvram.read_fn = &m48t59_read;\n\n    nvram.write_fn = &m48t59_write;\n\n    PPC_NVRAM_set_params(&nvram, NVRAM_SIZE, \"PREP\", ram_size, ppc_boot_device,\n\n                         kernel_base, kernel_size,\n\n                         kernel_cmdline,\n\n                         initrd_base, initrd_size,\n\n                         /* XXX: need an option to load a NVRAM image */\n\n                         0,\n\n                         graphic_width, graphic_height, graphic_depth);\n\n\n\n    /* Special port to get debug messages from Open-Firmware */\n\n    register_ioport_write(0x0F00, 4, 1, &PPC_debug_write, NULL);\n\n}\n", "idx": 10240, "_split": "valid", "_hash": "f20a2a24ec7f115a7419c7d470beb877"}
{"project": "qemu", "commit_id": "a8d411abac9347aadeac87687b8a3c9895ea0fd7", "target": 0, "func": "void helper_xssqrtqp(CPUPPCState *env, uint32_t opcode)\n\n{\n\n    ppc_vsr_t xb;\n\n    ppc_vsr_t xt;\n\n    float_status tstat;\n\n\n\n    getVSR(rB(opcode) + 32, &xb, env);\n\n    memset(&xt, 0, sizeof(xt));\n\n    helper_reset_fpstatus(env);\n\n\n\n    if (unlikely(Rc(opcode) != 0)) {\n\n        /* TODO: Support xsadddpo after round-to-odd is implemented */\n\n        abort();\n\n    }\n\n\n\n    tstat = env->fp_status;\n\n    set_float_exception_flags(0, &tstat);\n\n    xt.f128 = float128_sqrt(xb.f128, &tstat);\n\n    env->fp_status.float_exception_flags |= tstat.float_exception_flags;\n\n\n\n    if (unlikely(tstat.float_exception_flags & float_flag_invalid)) {\n\n        if (float128_is_signaling_nan(xb.f128, &tstat)) {\n\n            float_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN, 1);\n\n            xt.f128 = float128_snan_to_qnan(xb.f128);\n\n        } else if  (float128_is_quiet_nan(xb.f128, &tstat)) {\n\n            xt.f128 = xb.f128;\n\n        } else if (float128_is_neg(xb.f128) && !float128_is_zero(xb.f128)) {\n\n            float_invalid_op_excp(env, POWERPC_EXCP_FP_VXSQRT, 1);\n\n            set_snan_bit_is_one(0, &env->fp_status);\n\n            xt.f128 = float128_default_nan(&env->fp_status);\n\n        }\n\n    }\n\n\n\n    helper_compute_fprf_float128(env, xt.f128);\n\n    putVSR(rD(opcode) + 32, &xt, env);\n\n    float_check_status(env);\n\n}\n", "idx": 10264, "_split": "valid", "_hash": "98d671d58aea9bf3710a9aa1285a7752"}
{"project": "qemu", "commit_id": "ad96090a01d848df67d70c5259ed8aa321fa8716", "target": 0, "func": "static int is_dup_page(uint8_t *page, uint8_t ch)\n\n{\n\n    uint32_t val = ch << 24 | ch << 16 | ch << 8 | ch;\n\n    uint32_t *array = (uint32_t *)page;\n\n    int i;\n\n\n\n    for (i = 0; i < (TARGET_PAGE_SIZE / 4); i++) {\n\n        if (array[i] != val)\n\n            return 0;\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 10274, "_split": "valid", "_hash": "2efe64e3daf6f4e9b3d475612dfc5027"}
{"project": "qemu", "commit_id": "fae2afb10e3fdceab612c62a2b1e8b944ff578d9", "target": 0, "func": "void qxl_log_command(PCIQXLDevice *qxl, const char *ring, QXLCommandExt *ext)\n\n{\n\n    bool compat = ext->flags & QXL_COMMAND_FLAG_COMPAT;\n\n    void *data;\n\n\n\n    if (!qxl->cmdlog) {\n\n        return;\n\n    }\n\n    fprintf(stderr, \"%\" PRId64 \" qxl-%d/%s:\", qemu_get_clock_ns(vm_clock),\n\n            qxl->id, ring);\n\n    fprintf(stderr, \" cmd @ 0x%\" PRIx64 \" %s%s\", ext->cmd.data,\n\n            qxl_name(qxl_type, ext->cmd.type),\n\n            compat ? \"(compat)\" : \"\");\n\n\n\n    data = qxl_phys2virt(qxl, ext->cmd.data, ext->group_id);\n\n    switch (ext->cmd.type) {\n\n    case QXL_CMD_DRAW:\n\n        if (!compat) {\n\n            qxl_log_cmd_draw(qxl, data, ext->group_id);\n\n        } else {\n\n            qxl_log_cmd_draw_compat(qxl, data, ext->group_id);\n\n        }\n\n        break;\n\n    case QXL_CMD_SURFACE:\n\n        qxl_log_cmd_surface(qxl, data);\n\n        break;\n\n    case QXL_CMD_CURSOR:\n\n        qxl_log_cmd_cursor(qxl, data, ext->group_id);\n\n        break;\n\n    }\n\n    fprintf(stderr, \"\\n\");\n\n}\n", "idx": 10283, "_split": "valid", "_hash": "e655e152c95de19c0ef387ef509835d6"}
{"project": "qemu", "commit_id": "7dfbfc7927c1f7ab9f6910768ed6d966645b5866", "target": 0, "func": "int vnc_display_disable_login(DisplayState *ds)\n\n{\n\n    VncDisplay *vs = ds ? (VncDisplay *)ds->opaque : vnc_display;\n\n\n\n    if (!vs) {\n\n        return -1;\n\n    }\n\n\n\n    if (vs->password) {\n\n        g_free(vs->password);\n\n    }\n\n\n\n    vs->password = NULL;\n\n    vs->auth = VNC_AUTH_VNC;\n\n\n\n    return 0;\n\n}\n", "idx": 10288, "_split": "valid", "_hash": "1313ac4910f6db83fec2fc1a40c0443e"}
{"project": "qemu", "commit_id": "b02ef3d92b19ad304a84433d3817f0903296ebc7", "target": 0, "func": "static void read_storage_element0_info(SCLPDevice *sclp, SCCB *sccb)\n\n{\n\n    int i, assigned;\n\n    int subincrement_id = SCLP_STARTING_SUBINCREMENT_ID;\n\n    ReadStorageElementInfo *storage_info = (ReadStorageElementInfo *) sccb;\n\n    sclpMemoryHotplugDev *mhd = get_sclp_memory_hotplug_dev();\n\n\n\n    assert(mhd);\n\n\n\n    if ((ram_size >> mhd->increment_size) >= 0x10000) {\n\n        sccb->h.response_code = cpu_to_be16(SCLP_RC_SCCB_BOUNDARY_VIOLATION);\n\n        return;\n\n    }\n\n\n\n    /* Return information regarding core memory */\n\n    storage_info->max_id = cpu_to_be16(mhd->standby_mem_size ? 1 : 0);\n\n    assigned = ram_size >> mhd->increment_size;\n\n    storage_info->assigned = cpu_to_be16(assigned);\n\n\n\n    for (i = 0; i < assigned; i++) {\n\n        storage_info->entries[i] = cpu_to_be32(subincrement_id);\n\n        subincrement_id += SCLP_INCREMENT_UNIT;\n\n    }\n\n    sccb->h.response_code = cpu_to_be16(SCLP_RC_NORMAL_READ_COMPLETION);\n\n}\n", "idx": 10293, "_split": "valid", "_hash": "45eaa5fe3a7d177b63792655bcbfe89f"}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "void net_rx_pkt_attach_data(struct NetRxPkt *pkt, const void *data,\n\n                               size_t len, bool strip_vlan)\n\n{\n\n    uint16_t tci = 0;\n\n    uint16_t ploff;\n\n    assert(pkt);\n\n    pkt->vlan_stripped = false;\n\n\n\n    if (strip_vlan) {\n\n        pkt->vlan_stripped = eth_strip_vlan(data, pkt->ehdr_buf, &ploff, &tci);\n\n    }\n\n\n\n    if (pkt->vlan_stripped) {\n\n        pkt->vec[0].iov_base = pkt->ehdr_buf;\n\n        pkt->vec[0].iov_len = ploff - sizeof(struct vlan_header);\n\n        pkt->vec[1].iov_base = (uint8_t *) data + ploff;\n\n        pkt->vec[1].iov_len = len - ploff;\n\n        pkt->vec_len = 2;\n\n        pkt->tot_len = len - ploff + sizeof(struct eth_header);\n\n    } else {\n\n        pkt->vec[0].iov_base = (void *)data;\n\n        pkt->vec[0].iov_len = len;\n\n        pkt->vec_len = 1;\n\n        pkt->tot_len = len;\n\n    }\n\n\n\n    pkt->tci = tci;\n\n}\n", "idx": 10317, "_split": "valid", "_hash": "c2d6e5758ed0fd164bb3370876890145"}
{"project": "qemu", "commit_id": "95c318f5e1f88d7e5bcc6deac17330fd4806a2d3", "target": 1, "func": "static int subpage_register (subpage_t *mmio, uint32_t start, uint32_t end,\n\n                             ram_addr_t memory, ram_addr_t region_offset)\n\n{\n\n    int idx, eidx;\n\n\n\n    if (start >= TARGET_PAGE_SIZE || end >= TARGET_PAGE_SIZE)\n\n        return -1;\n\n    idx = SUBPAGE_IDX(start);\n\n    eidx = SUBPAGE_IDX(end);\n\n#if defined(DEBUG_SUBPAGE)\n\n    printf(\"%s: %p start %08x end %08x idx %08x eidx %08x mem %ld\\n\", __func__,\n\n           mmio, start, end, idx, eidx, memory);\n\n#endif\n\n\n\n    memory = (memory >> IO_MEM_SHIFT) & (IO_MEM_NB_ENTRIES - 1);\n\n    for (; idx <= eidx; idx++) {\n\n        mmio->sub_io_index[idx] = memory;\n\n        mmio->region_offset[idx] = region_offset;\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 10349, "_split": "valid", "_hash": "c4943044358dd6b67bd2820b4f0a2fc4"}
{"project": "qemu", "commit_id": "fee8ea12eba366db5ef8f72478cb746bda375d6f", "target": 0, "func": "static int load_dtb(hwaddr addr, const struct arm_boot_info *binfo)\n\n{\n\n    void *fdt = NULL;\n\n    int size, rc;\n\n    uint32_t acells, scells;\n\n\n\n    if (binfo->dtb_filename) {\n\n        char *filename;\n\n        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, binfo->dtb_filename);\n\n        if (!filename) {\n\n            fprintf(stderr, \"Couldn't open dtb file %s\\n\", binfo->dtb_filename);\n\n            goto fail;\n\n        }\n\n\n\n        fdt = load_device_tree(filename, &size);\n\n        if (!fdt) {\n\n            fprintf(stderr, \"Couldn't open dtb file %s\\n\", filename);\n\n            g_free(filename);\n\n            goto fail;\n\n        }\n\n        g_free(filename);\n\n    } else if (binfo->get_dtb) {\n\n        fdt = binfo->get_dtb(binfo, &size);\n\n        if (!fdt) {\n\n            fprintf(stderr, \"Board was unable to create a dtb blob\\n\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    acells = qemu_fdt_getprop_cell(fdt, \"/\", \"#address-cells\");\n\n    scells = qemu_fdt_getprop_cell(fdt, \"/\", \"#size-cells\");\n\n    if (acells == 0 || scells == 0) {\n\n        fprintf(stderr, \"dtb file invalid (#address-cells or #size-cells 0)\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    if (scells < 2 && binfo->ram_size >= (1ULL << 32)) {\n\n        /* This is user error so deserves a friendlier error message\n\n         * than the failure of setprop_sized_cells would provide\n\n         */\n\n        fprintf(stderr, \"qemu: dtb file not compatible with \"\n\n                \"RAM size > 4GB\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    rc = qemu_fdt_setprop_sized_cells(fdt, \"/memory\", \"reg\",\n\n                                      acells, binfo->loader_start,\n\n                                      scells, binfo->ram_size);\n\n    if (rc < 0) {\n\n        fprintf(stderr, \"couldn't set /memory/reg\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    if (binfo->kernel_cmdline && *binfo->kernel_cmdline) {\n\n        rc = qemu_fdt_setprop_string(fdt, \"/chosen\", \"bootargs\",\n\n                                     binfo->kernel_cmdline);\n\n        if (rc < 0) {\n\n            fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    if (binfo->initrd_size) {\n\n        rc = qemu_fdt_setprop_cell(fdt, \"/chosen\", \"linux,initrd-start\",\n\n                                   binfo->initrd_start);\n\n        if (rc < 0) {\n\n            fprintf(stderr, \"couldn't set /chosen/linux,initrd-start\\n\");\n\n            goto fail;\n\n        }\n\n\n\n        rc = qemu_fdt_setprop_cell(fdt, \"/chosen\", \"linux,initrd-end\",\n\n                                   binfo->initrd_start + binfo->initrd_size);\n\n        if (rc < 0) {\n\n            fprintf(stderr, \"couldn't set /chosen/linux,initrd-end\\n\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    if (binfo->modify_dtb) {\n\n        binfo->modify_dtb(binfo, fdt);\n\n    }\n\n\n\n    qemu_fdt_dumpdtb(fdt, size);\n\n\n\n    /* Put the DTB into the memory map as a ROM image: this will ensure\n\n     * the DTB is copied again upon reset, even if addr points into RAM.\n\n     */\n\n    rom_add_blob_fixed(\"dtb\", fdt, size, addr);\n\n\n\n    g_free(fdt);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    g_free(fdt);\n\n    return -1;\n\n}\n", "idx": 10356, "_split": "valid", "_hash": "6cff4d5cd353fc08587f7b4ea1f45e65"}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void onenand_write(void *opaque, hwaddr addr,\n\n                          uint64_t value, unsigned size)\n\n{\n\n    OneNANDState *s = (OneNANDState *) opaque;\n\n    int offset = addr >> s->shift;\n\n    int sec;\n\n\n\n    switch (offset) {\n\n    case 0x0000 ... 0x01ff:\n\n    case 0x8000 ... 0x800f:\n\n        if (s->cycle) {\n\n            s->cycle = 0;\n\n\n\n            if (value == 0x0000) {\n\n                SETADDR(ONEN_BUF_BLOCK, ONEN_BUF_PAGE)\n\n                onenand_load_main(s, sec,\n\n                                1 << (PAGE_SHIFT - 9), s->data[0][0]);\n\n                s->addr[ONEN_BUF_PAGE] += 4;\n\n                s->addr[ONEN_BUF_PAGE] &= 0xff;\n\n            }\n\n            break;\n\n        }\n\n\n\n        switch (value) {\n\n        case 0x00f0:\t/* Reset OneNAND */\n\n            onenand_reset(s, 0);\n\n            break;\n\n\n\n        case 0x00e0:\t/* Load Data into Buffer */\n\n            s->cycle = 1;\n\n            break;\n\n\n\n        case 0x0090:\t/* Read Identification Data */\n\n            memset(s->boot[0], 0, 3 << s->shift);\n\n            s->boot[0][0 << s->shift] = s->id.man & 0xff;\n\n            s->boot[0][1 << s->shift] = s->id.dev & 0xff;\n\n            s->boot[0][2 << s->shift] = s->wpstatus & 0xff;\n\n            break;\n\n\n\n        default:\n\n            fprintf(stderr, \"%s: unknown OneNAND boot command %\"PRIx64\"\\n\",\n\n                            __FUNCTION__, value);\n\n        }\n\n        break;\n\n\n\n    case 0xf100 ... 0xf107:\t/* Start addresses */\n\n        s->addr[offset - 0xf100] = value;\n\n        break;\n\n\n\n    case 0xf200:\t/* Start buffer */\n\n        s->bufaddr = (value >> 8) & 0xf;\n\n        if (PAGE_SHIFT == 11)\n\n            s->count = (value & 3) ?: 4;\n\n        else if (PAGE_SHIFT == 10)\n\n            s->count = (value & 1) ?: 2;\n\n        break;\n\n\n\n    case 0xf220:\t/* Command */\n\n        if (s->intstatus & (1 << 15))\n\n            break;\n\n        s->command = value;\n\n        onenand_command(s);\n\n        break;\n\n    case 0xf221:\t/* System Configuration 1 */\n\n        s->config[0] = value;\n\n        onenand_intr_update(s);\n\n        qemu_set_irq(s->rdy, (s->config[0] >> 7) & 1);\n\n        break;\n\n    case 0xf222:\t/* System Configuration 2 */\n\n        s->config[1] = value;\n\n        break;\n\n\n\n    case 0xf241:\t/* Interrupt */\n\n        s->intstatus &= value;\n\n        if ((1 << 15) & ~s->intstatus)\n\n            s->status &= ~(ONEN_ERR_CMD | ONEN_ERR_ERASE |\n\n                            ONEN_ERR_PROG | ONEN_ERR_LOAD);\n\n        onenand_intr_update(s);\n\n        break;\n\n    case 0xf24c:\t/* Unlock Start Block Address */\n\n        s->unladdr[0] = value & (s->blocks - 1);\n\n        /* For some reason we have to set the end address to by default\n\n         * be same as start because the software forgets to write anything\n\n         * in there.  */\n\n        s->unladdr[1] = value & (s->blocks - 1);\n\n        break;\n\n    case 0xf24d:\t/* Unlock End Block Address */\n\n        s->unladdr[1] = value & (s->blocks - 1);\n\n        break;\n\n\n\n    default:\n\n        fprintf(stderr, \"%s: unknown OneNAND register %x\\n\",\n\n                        __FUNCTION__, offset);\n\n    }\n\n}\n", "idx": 10369, "_split": "valid", "_hash": "5502528c4c189e3b946c450dc916d151"}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_output_type_null(Visitor *v, const char *name, Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    qmp_output_add_obj(qov, name, qnull());\n\n}\n", "idx": 10376, "_split": "valid", "_hash": "4e31f5c19eb9d780ef1b9617e7793b43"}
{"project": "qemu", "commit_id": "463c534db516701ac732ac606c33c7101cf22e56", "target": 0, "func": "static void xhci_child_detach(USBPort *uport, USBDevice *child)\n\n{\n\n    USBBus *bus = usb_bus_from_device(child);\n\n    XHCIState *xhci = container_of(bus, XHCIState, bus);\n\n\n\n    xhci_detach_slot(xhci, uport);\n\n}\n", "idx": 10383, "_split": "valid", "_hash": "84a00adbe0d69b88f9e43e6a6d389b6c"}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(addme)\n\n{\n\n    T1 = T0;\n\n    T0 += xer_ca + (-1);\n\n    if (T1 != 0)\n\n        xer_ca = 1;\n\n    RETURN();\n\n}\n", "idx": 10389, "_split": "valid", "_hash": "ab57027c86d7a6f87fe0236275c9ed13"}
{"project": "qemu", "commit_id": "15fa08f8451babc88d733bd411d4c94976f9d0f8", "target": 1, "func": "static bool liveness_pass_2(TCGContext *s)\n\n{\n\n    int nb_globals = s->nb_globals;\n\n    int nb_temps, i, oi, oi_next;\n\n    bool changes = false;\n\n\n\n    /* Create a temporary for each indirect global.  */\n\n    for (i = 0; i < nb_globals; ++i) {\n\n        TCGTemp *its = &s->temps[i];\n\n        if (its->indirect_reg) {\n\n            TCGTemp *dts = tcg_temp_alloc(s);\n\n            dts->type = its->type;\n\n            dts->base_type = its->base_type;\n\n            its->state_ptr = dts;\n\n        } else {\n\n            its->state_ptr = NULL;\n\n        }\n\n        /* All globals begin dead.  */\n\n        its->state = TS_DEAD;\n\n    }\n\n    for (nb_temps = s->nb_temps; i < nb_temps; ++i) {\n\n        TCGTemp *its = &s->temps[i];\n\n        its->state_ptr = NULL;\n\n        its->state = TS_DEAD;\n\n    }\n\n\n\n    for (oi = s->gen_op_buf[0].next; oi != 0; oi = oi_next) {\n\n        TCGOp *op = &s->gen_op_buf[oi];\n\n        TCGOpcode opc = op->opc;\n\n        const TCGOpDef *def = &tcg_op_defs[opc];\n\n        TCGLifeData arg_life = op->life;\n\n        int nb_iargs, nb_oargs, call_flags;\n\n        TCGTemp *arg_ts, *dir_ts;\n\n\n\n        oi_next = op->next;\n\n\n\n        if (opc == INDEX_op_call) {\n\n            nb_oargs = op->callo;\n\n            nb_iargs = op->calli;\n\n            call_flags = op->args[nb_oargs + nb_iargs + 1];\n\n        } else {\n\n            nb_iargs = def->nb_iargs;\n\n            nb_oargs = def->nb_oargs;\n\n\n\n            /* Set flags similar to how calls require.  */\n\n            if (def->flags & TCG_OPF_BB_END) {\n\n                /* Like writing globals: save_globals */\n\n                call_flags = 0;\n\n            } else if (def->flags & TCG_OPF_SIDE_EFFECTS) {\n\n                /* Like reading globals: sync_globals */\n\n                call_flags = TCG_CALL_NO_WRITE_GLOBALS;\n\n            } else {\n\n                /* No effect on globals.  */\n\n                call_flags = (TCG_CALL_NO_READ_GLOBALS |\n\n                              TCG_CALL_NO_WRITE_GLOBALS);\n\n            }\n\n        }\n\n\n\n        /* Make sure that input arguments are available.  */\n\n        for (i = nb_oargs; i < nb_iargs + nb_oargs; i++) {\n\n            arg_ts = arg_temp(op->args[i]);\n\n            if (arg_ts) {\n\n                dir_ts = arg_ts->state_ptr;\n\n                if (dir_ts && arg_ts->state == TS_DEAD) {\n\n                    TCGOpcode lopc = (arg_ts->type == TCG_TYPE_I32\n\n                                      ? INDEX_op_ld_i32\n\n                                      : INDEX_op_ld_i64);\n\n                    TCGOp *lop = tcg_op_insert_before(s, op, lopc, 3);\n\n\n\n                    lop->args[0] = temp_arg(dir_ts);\n\n                    lop->args[1] = temp_arg(arg_ts->mem_base);\n\n                    lop->args[2] = arg_ts->mem_offset;\n\n\n\n                    /* Loaded, but synced with memory.  */\n\n                    arg_ts->state = TS_MEM;\n\n                }\n\n            }\n\n        }\n\n\n\n        /* Perform input replacement, and mark inputs that became dead.\n\n           No action is required except keeping temp_state up to date\n\n           so that we reload when needed.  */\n\n        for (i = nb_oargs; i < nb_iargs + nb_oargs; i++) {\n\n            arg_ts = arg_temp(op->args[i]);\n\n            if (arg_ts) {\n\n                dir_ts = arg_ts->state_ptr;\n\n                if (dir_ts) {\n\n                    op->args[i] = temp_arg(dir_ts);\n\n                    changes = true;\n\n                    if (IS_DEAD_ARG(i)) {\n\n                        arg_ts->state = TS_DEAD;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        /* Liveness analysis should ensure that the following are\n\n           all correct, for call sites and basic block end points.  */\n\n        if (call_flags & TCG_CALL_NO_READ_GLOBALS) {\n\n            /* Nothing to do */\n\n        } else if (call_flags & TCG_CALL_NO_WRITE_GLOBALS) {\n\n            for (i = 0; i < nb_globals; ++i) {\n\n                /* Liveness should see that globals are synced back,\n\n                   that is, either TS_DEAD or TS_MEM.  */\n\n                arg_ts = &s->temps[i];\n\n                tcg_debug_assert(arg_ts->state_ptr == 0\n\n                                 || arg_ts->state != 0);\n\n            }\n\n        } else {\n\n            for (i = 0; i < nb_globals; ++i) {\n\n                /* Liveness should see that globals are saved back,\n\n                   that is, TS_DEAD, waiting to be reloaded.  */\n\n                arg_ts = &s->temps[i];\n\n                tcg_debug_assert(arg_ts->state_ptr == 0\n\n                                 || arg_ts->state == TS_DEAD);\n\n            }\n\n        }\n\n\n\n        /* Outputs become available.  */\n\n        for (i = 0; i < nb_oargs; i++) {\n\n            arg_ts = arg_temp(op->args[i]);\n\n            dir_ts = arg_ts->state_ptr;\n\n            if (!dir_ts) {\n\n                continue;\n\n            }\n\n            op->args[i] = temp_arg(dir_ts);\n\n            changes = true;\n\n\n\n            /* The output is now live and modified.  */\n\n            arg_ts->state = 0;\n\n\n\n            /* Sync outputs upon their last write.  */\n\n            if (NEED_SYNC_ARG(i)) {\n\n                TCGOpcode sopc = (arg_ts->type == TCG_TYPE_I32\n\n                                  ? INDEX_op_st_i32\n\n                                  : INDEX_op_st_i64);\n\n                TCGOp *sop = tcg_op_insert_after(s, op, sopc, 3);\n\n\n\n                sop->args[0] = temp_arg(dir_ts);\n\n                sop->args[1] = temp_arg(arg_ts->mem_base);\n\n                sop->args[2] = arg_ts->mem_offset;\n\n\n\n                arg_ts->state = TS_MEM;\n\n            }\n\n            /* Drop outputs that are dead.  */\n\n            if (IS_DEAD_ARG(i)) {\n\n                arg_ts->state = TS_DEAD;\n\n            }\n\n        }\n\n    }\n\n\n\n    return changes;\n\n}\n", "idx": 10391, "_split": "valid", "_hash": "4e059edb768d10bf3737eacd3728b7dd"}
{"project": "qemu", "commit_id": "8ce1ee4618f4a557959f5a5731f6726b30416df5", "target": 1, "func": "GuestMemoryBlockInfo *qmp_guest_get_memory_block_info(Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    char *dirpath;\n\n    int dirfd;\n\n    char *buf;\n\n    GuestMemoryBlockInfo *info;\n\n\n\n    dirpath = g_strdup_printf(\"/sys/devices/system/memory/\");\n\n    dirfd = open(dirpath, O_RDONLY | O_DIRECTORY);\n\n    if (dirfd == -1) {\n\n        error_setg_errno(errp, errno, \"open(\\\"%s\\\")\", dirpath);\n\n        g_free(dirpath);\n\n        return NULL;\n\n    }\n\n    g_free(dirpath);\n\n\n\n    buf = g_malloc0(20);\n\n    ga_read_sysfs_file(dirfd, \"block_size_bytes\", buf, 20, &local_err);\n\n\n    if (local_err) {\n\n        g_free(buf);\n\n        error_propagate(errp, local_err);\n\n        return NULL;\n\n    }\n\n\n\n    info = g_new0(GuestMemoryBlockInfo, 1);\n\n    info->size = strtol(buf, NULL, 16); /* the unit is bytes */\n\n\n\n    g_free(buf);\n\n\n\n    return info;\n\n}", "idx": 10409, "_split": "valid", "_hash": "9a5d0301f60e833a64696a8c57bf9bf6"}
{"project": "qemu", "commit_id": "f76f665547f4a954a2c83552a88816fc2a316be0", "target": 1, "func": "static int virtio_balloon_init_pci(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n    VirtIODevice *vdev;\n\n\n\n    vdev = virtio_balloon_init(&pci_dev->qdev);\n\n\n\n\n    virtio_init_pci(proxy, vdev);\n\n    return 0;\n", "idx": 10422, "_split": "valid", "_hash": "5c204e9d63ac0e447b97f096b6b86ffb"}
{"project": "qemu", "commit_id": "6787d27b04a79524c547c60701400eb0418e3533", "target": 1, "func": "static target_ulong h_client_architecture_support(PowerPCCPU *cpu_,\n\n                                                  sPAPRMachineState *spapr,\n\n                                                  target_ulong opcode,\n\n                                                  target_ulong *args)\n\n{\n\n    target_ulong list = ppc64_phys_to_real(args[0]);\n\n    target_ulong ov_table;\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu_);\n\n    CPUState *cs;\n\n    bool cpu_match = false, cpu_update = true;\n\n    unsigned old_cpu_version = cpu_->cpu_version;\n\n    unsigned compat_lvl = 0, cpu_version = 0;\n\n    unsigned max_lvl = get_compat_level(cpu_->max_compat);\n\n    int counter;\n\n    sPAPROptionVector *ov5_guest;\n\n\n\n    /* Parse PVR list */\n\n    for (counter = 0; counter < 512; ++counter) {\n\n        uint32_t pvr, pvr_mask;\n\n\n\n        pvr_mask = ldl_be_phys(&address_space_memory, list);\n\n        list += 4;\n\n        pvr = ldl_be_phys(&address_space_memory, list);\n\n        list += 4;\n\n\n\n        trace_spapr_cas_pvr_try(pvr);\n\n        if (!max_lvl &&\n\n            ((cpu_->env.spr[SPR_PVR] & pvr_mask) == (pvr & pvr_mask))) {\n\n            cpu_match = true;\n\n            cpu_version = 0;\n\n        } else if (pvr == cpu_->cpu_version) {\n\n            cpu_match = true;\n\n            cpu_version = cpu_->cpu_version;\n\n        } else if (!cpu_match) {\n\n            cas_handle_compat_cpu(pcc, pvr, max_lvl, &compat_lvl, &cpu_version);\n\n        }\n\n        /* Terminator record */\n\n        if (~pvr_mask & pvr) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Parsing finished */\n\n    trace_spapr_cas_pvr(cpu_->cpu_version, cpu_match,\n\n                        cpu_version, pcc->pcr_mask);\n\n\n\n    /* Update CPUs */\n\n    if (old_cpu_version != cpu_version) {\n\n        CPU_FOREACH(cs) {\n\n            SetCompatState s = {\n\n                .cpu_version = cpu_version,\n\n                .err = NULL,\n\n            };\n\n\n\n            run_on_cpu(cs, do_set_compat, &s);\n\n\n\n            if (s.err) {\n\n                error_report_err(s.err);\n\n                return H_HARDWARE;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!cpu_version) {\n\n        cpu_update = false;\n\n    }\n\n\n\n    /* For the future use: here @ov_table points to the first option vector */\n\n    ov_table = list;\n\n\n\n    ov5_guest = spapr_ovec_parse_vector(ov_table, 5);\n\n\n\n    /* NOTE: there are actually a number of ov5 bits where input from the\n\n     * guest is always zero, and the platform/QEMU enables them independently\n\n     * of guest input. To model these properly we'd want some sort of mask,\n\n     * but since they only currently apply to memory migration as defined\n\n     * by LoPAPR 1.1, 14.5.4.8, which QEMU doesn't implement, we don't need\n\n     * to worry about this.\n\n     */\n\n    spapr_ovec_intersect(spapr->ov5_cas, spapr->ov5, ov5_guest);\n\n    spapr_ovec_cleanup(ov5_guest);\n\n\n\n    if (spapr_h_cas_compose_response(spapr, args[1], args[2],\n\n                                     cpu_update)) {\n\n        qemu_system_reset_request();\n\n    }\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 10439, "_split": "valid", "_hash": "26d9abd63c37c7ba17b642554a9bce4a"}
{"project": "qemu", "commit_id": "1104d83c726d2b20f9cec7b99ab3570a2fdbd46d", "target": 1, "func": "int nbd_client_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)\n\n{\n\n    NBDClientSession *client = nbd_get_client_session(bs);\n\n    NBDRequest request = {\n\n        .type = NBD_CMD_TRIM,\n\n        .from = offset,\n\n        .len = bytes,\n\n    };\n\n\n\n\n    if (!(client->info.flags & NBD_FLAG_SEND_TRIM)) {\n\n        return 0;\n\n    }\n\n\n\n    return nbd_co_request(bs, &request, NULL);\n\n}", "idx": 10462, "_split": "valid", "_hash": "48c8f3c1f4a23dbdc4edcfc8f9222cd4"}
{"project": "qemu", "commit_id": "fa0cfdf24a75f3e6aa6c8b6efcbebd09e7f054aa", "target": 0, "func": "static void vnc_disconnect_finish(VncState *vs)\n\n{\n\n    if (vs->input.buffer) qemu_free(vs->input.buffer);\n\n    if (vs->output.buffer) qemu_free(vs->output.buffer);\n\n#ifdef CONFIG_VNC_TLS\n\n    vnc_tls_client_cleanup(vs);\n\n#endif /* CONFIG_VNC_TLS */\n\n#ifdef CONFIG_VNC_SASL\n\n    vnc_sasl_client_cleanup(vs);\n\n#endif /* CONFIG_VNC_SASL */\n\n    audio_del(vs);\n\n\n\n    VncState *p, *parent = NULL;\n\n    for (p = vs->vd->clients; p != NULL; p = p->next) {\n\n        if (p == vs) {\n\n            if (parent)\n\n                parent->next = p->next;\n\n            else\n\n                vs->vd->clients = p->next;\n\n            break;\n\n        }\n\n        parent = p;\n\n    }\n\n    if (!vs->vd->clients)\n\n        dcl->idle = 1;\n\n\n\n    vnc_remove_timer(vs->vd);\n\n    qemu_free(vs);\n\n}\n", "idx": 10494, "_split": "valid", "_hash": "ef5ee56b7a6586b64b4096a986178c90"}
{"project": "qemu", "commit_id": "e6908bfe8e07f2b452e78e677da1b45b1c0f6829", "target": 1, "func": "static void set_pixel_format(VncState *vs,\n                             int bits_per_pixel, int depth,\n                             int big_endian_flag, int true_color_flag,\n                             int red_max, int green_max, int blue_max,\n                             int red_shift, int green_shift, int blue_shift)\n{\n    if (!true_color_flag) {\n    vs->client_pf.rmax = red_max;\n    vs->client_pf.rbits = hweight_long(red_max);\n    vs->client_pf.rshift = red_shift;\n    vs->client_pf.rmask = red_max << red_shift;\n    vs->client_pf.gmax = green_max;\n    vs->client_pf.gbits = hweight_long(green_max);\n    vs->client_pf.gshift = green_shift;\n    vs->client_pf.gmask = green_max << green_shift;\n    vs->client_pf.bmax = blue_max;\n    vs->client_pf.bbits = hweight_long(blue_max);\n    vs->client_pf.bshift = blue_shift;\n    vs->client_pf.bmask = blue_max << blue_shift;\n    vs->client_pf.bits_per_pixel = bits_per_pixel;\n    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;\n    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;\n    vs->client_be = big_endian_flag;\n    set_pixel_conversion(vs);\n    graphic_hw_invalidate(NULL);\n    graphic_hw_update(NULL);", "idx": 10501, "_split": "valid", "_hash": "3cce7e762c900ccb0fc4eddcc406990d"}
{"project": "qemu", "commit_id": "a879125b47c3ae554c01824f996a64a45a86556e", "target": 1, "func": "static uint8_t qpci_pc_config_readb(QPCIBus *bus, int devfn, uint8_t offset)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    return inb(0xcfc);\n\n}\n", "idx": 10522, "_split": "valid", "_hash": "35dcbefbef9a468f2a70eb2b5addfe0d"}
{"project": "qemu", "commit_id": "28143b409f698210d85165ca518235ac7e7c5ac5", "target": 0, "func": "int kvm_has_xcrs(void)\n\n{\n\n    return kvm_state->xcrs;\n\n}\n", "idx": 10575, "_split": "valid", "_hash": "7efd735418f81dd41e331329a84f3244"}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_eval_bl(TCGv dst, TCGv_i32 src)\n\n{\n\n    gen_mov_reg_V(cpu_tmp0, src);\n\n    gen_mov_reg_N(dst, src);\n\n    tcg_gen_xor_tl(dst, dst, cpu_tmp0);\n\n}\n", "idx": 10579, "_split": "valid", "_hash": "6e31fb005afdf561eed23d5570317fa8"}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void tilegx_cpu_initfn(Object *obj)\n\n{\n\n    CPUState *cs = CPU(obj);\n\n    TileGXCPU *cpu = TILEGX_CPU(obj);\n\n    CPUTLGState *env = &cpu->env;\n\n    static bool tcg_initialized;\n\n\n\n    cs->env_ptr = env;\n\n    cpu_exec_init(cs, &error_abort);\n\n\n\n    if (tcg_enabled() && !tcg_initialized) {\n\n        tcg_initialized = true;\n\n        tilegx_tcg_init();\n\n    }\n\n}\n", "idx": 10590, "_split": "valid", "_hash": "5c33510c0cf3b600ce1e1d05005b9f9a"}
{"project": "qemu", "commit_id": "df46189412567906312684eb72ba87c6a86a4cdb", "target": 1, "func": "getouraddr(void)\n\n{\n\n\tchar buff[256];\n\n\tstruct hostent *he = NULL;\n\n\n\n\tif (gethostname(buff,256) == 0)\n\n            he = gethostbyname(buff);\n\n        if (he)\n\n            our_addr = *(struct in_addr *)he->h_addr;\n\n        if (our_addr.s_addr == 0)\n\n            our_addr.s_addr = loopback_addr.s_addr;\n\n}\n", "idx": 10592, "_split": "valid", "_hash": "7c61206868c49b645d4c436fae04b749"}
{"project": "qemu", "commit_id": "249127d0dfeb2cf5e24d9353b6d54c91c1666ddc", "target": 1, "func": "static void spapr_cpu_core_realize_child(Object *child, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_machine());\n\n    CPUState *cs = CPU(child);\n\n    PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n    Object *obj;\n\n\n\n    obj = object_new(spapr->icp_type);\n\n    object_property_add_child(OBJECT(cpu), \"icp\", obj, NULL);\n\n    object_property_add_const_link(obj, \"xics\", OBJECT(spapr), &error_abort);\n\n    object_property_set_bool(obj, true, \"realized\", &local_err);\n\n    if (local_err) {\n\n        goto error;\n\n    }\n\n\n\n    object_property_set_bool(child, true, \"realized\", &local_err);\n\n    if (local_err) {\n\n        goto error;\n\n    }\n\n\n\n    spapr_cpu_init(spapr, cpu, &local_err);\n\n    if (local_err) {\n\n        goto error;\n\n    }\n\n\n\n    xics_cpu_setup(XICS_FABRIC(spapr), cpu, ICP(obj));\n\n    return;\n\n\n\nerror:\n\n    object_unparent(obj);\n\n    error_propagate(errp, local_err);\n\n}\n", "idx": 10599, "_split": "valid", "_hash": "63d519dfb7484b069eafec7715e33c0f"}
{"project": "qemu", "commit_id": "90527d2a8bb08ca5b4774eacfdd6b8fe9671c077", "target": 1, "func": "static int get_real_id(const char *devpath, const char *idname, uint16_t *val)\n\n{\n\n    FILE *f;\n\n    char name[128];\n\n    long id;\n\n\n\n    snprintf(name, sizeof(name), \"%s%s\", devpath, idname);\n\n    f = fopen(name, \"r\");\n\n    if (f == NULL) {\n\n        error_report(\"%s: %s: %m\", __func__, name);\n\n        return -1;\n\n    }\n\n    if (fscanf(f, \"%li\\n\", &id) == 1) {\n\n        *val = id;\n\n    } else {\n\n\n        return -1;\n\n    }\n\n\n\n\n    return 0;\n\n}", "idx": 10611, "_split": "valid", "_hash": "599e503b8d4d4126b6bd56b1375cace8"}
{"project": "qemu", "commit_id": "dfda68377e20943f474505e75238cb96bc6874bf", "target": 1, "func": "static int get_S2prot(CPUARMState *env, int s2ap, int xn)\n\n{\n\n    int prot = 0;\n\n\n\n    if (s2ap & 1) {\n\n        prot |= PAGE_READ;\n\n    }\n\n    if (s2ap & 2) {\n\n        prot |= PAGE_WRITE;\n\n    }\n\n    if (!xn) {\n\n        prot |= PAGE_EXEC;\n\n    }\n\n    return prot;\n\n}\n", "idx": 10679, "_split": "valid", "_hash": "e347da12e64486b3a416665cdeb12df4"}
{"project": "qemu", "commit_id": "c4523aae0664aecaa366d45e3d0f3d810ca33062", "target": 1, "func": "void qvirtio_pci_foreach(QPCIBus *bus, uint16_t device_type,\n\n                void (*func)(QVirtioDevice *d, void *data), void *data)\n\n{\n\n    QVirtioPCIForeachData d = { .func = func,\n\n                                .device_type = device_type,\n\n                                .user_data = data };\n\n\n\n    qpci_device_foreach(bus, PCI_VENDOR_ID_REDHAT_QUMRANET, -1,\n\n                                qvirtio_pci_foreach_callback, &d);\n\n}\n", "idx": 10683, "_split": "valid", "_hash": "6647cf0ef209c68326ba55e16dfbbb60"}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_slbmfee(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    gen_helper_load_slb_esid(cpu_gpr[rS(ctx->opcode)], cpu_env,\n\n                             cpu_gpr[rB(ctx->opcode)]);\n\n#endif\n\n}\n", "idx": 10685, "_split": "valid", "_hash": "5146b7ff8dd0df628572aea2f5f92cec"}
{"project": "qemu", "commit_id": "4096974e1885913dfe2931863be47bd35b266521", "target": 1, "func": "static int qcow2_make_empty(BlockDriverState *bs)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t offset, end_offset;\n\n    int step = QEMU_ALIGN_DOWN(INT_MAX, s->cluster_size);\n\n    int l1_clusters, ret = 0;\n\n\n\n    l1_clusters = DIV_ROUND_UP(s->l1_size, s->cluster_size / sizeof(uint64_t));\n\n\n\n    if (s->qcow_version >= 3 && !s->snapshots &&\n\n        3 + l1_clusters <= s->refcount_block_size &&\n\n        s->crypt_method_header != QCOW_CRYPT_LUKS) {\n\n        /* The following function only works for qcow2 v3 images (it requires\n\n         * the dirty flag) and only as long as there are no snapshots (because\n\n         * it completely empties the image). Furthermore, the L1 table and three\n\n         * additional clusters (image header, refcount table, one refcount\n\n         * block) have to fit inside one refcount block. It cannot be used\n\n         * for LUKS (yet) as it throws away the LUKS header cluster(s) */\n\n        return make_completely_empty(bs);\n\n    }\n\n\n\n    /* This fallback code simply discards every active cluster; this is slow,\n\n     * but works in all cases */\n\n    end_offset = bs->total_sectors * BDRV_SECTOR_SIZE;\n\n    for (offset = 0; offset < end_offset; offset += step) {\n\n        /* As this function is generally used after committing an external\n\n         * snapshot, QCOW2_DISCARD_SNAPSHOT seems appropriate. Also, the\n\n         * default action for this kind of discard is to pass the discard,\n\n         * which will ideally result in an actually smaller image file, as\n\n         * is probably desired. */\n\n        ret = qcow2_cluster_discard(bs, offset, MIN(step, end_offset - offset),\n\n                                    QCOW2_DISCARD_SNAPSHOT, true);\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 10692, "_split": "valid", "_hash": "e3d27e84dc61afa7cd9173a664c01125"}
{"project": "qemu", "commit_id": "2a7e6857cd3178d705a49c4adde2f3af26ed3ae1", "target": 0, "func": "static VncBasicInfoList *qmp_query_server_entry(QIOChannelSocket *ioc,\n\n                                                bool websocket,\n\n                                                VncBasicInfoList *prev)\n\n{\n\n    VncBasicInfoList *list;\n\n    VncBasicInfo *info;\n\n    Error *err = NULL;\n\n    SocketAddress *addr;\n\n\n\n    addr = qio_channel_socket_get_local_address(ioc, &err);\n\n    if (!addr) {\n\n        error_free(err);\n\n        return prev;\n\n    }\n\n\n\n    info = g_new0(VncBasicInfo, 1);\n\n    vnc_init_basic_info(addr, info, &err);\n\n    qapi_free_SocketAddress(addr);\n\n    if (err) {\n\n        qapi_free_VncBasicInfo(info);\n\n        error_free(err);\n\n        return prev;\n\n    }\n\n    info->websocket = websocket;\n\n\n\n    list = g_new0(VncBasicInfoList, 1);\n\n    list->value = info;\n\n    list->next = prev;\n\n    return list;\n\n}\n", "idx": 10722, "_split": "valid", "_hash": "73d255ab1a3521adf05c31eabf28594b"}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "uint32_t HELPER(get_cp_reg)(CPUARMState *env, void *rip)\n\n{\n\n    const ARMCPRegInfo *ri = rip;\n\n\n\n    return ri->readfn(env, ri);\n\n}\n", "idx": 10728, "_split": "valid", "_hash": "ae3b36f293a0644e98adc5c7092256b9"}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static NetSocketState *net_socket_fd_init_dgram(VLANState *vlan, int fd, \n\n                                          int is_connected)\n\n{\n\n    struct sockaddr_in saddr;\n\n    int newfd;\n\n    socklen_t saddr_len;\n\n    NetSocketState *s;\n\n\n\n    /* fd passed: multicast: \"learn\" dgram_dst address from bound address and save it\n\n     * Because this may be \"shared\" socket from a \"master\" process, datagrams would be recv() \n\n     * by ONLY ONE process: we must \"clone\" this dgram socket --jjo\n\n     */\n\n\n\n    if (is_connected) {\n\n\tif (getsockname(fd, (struct sockaddr *) &saddr, &saddr_len) == 0) {\n\n\t    /* must be bound */\n\n\t    if (saddr.sin_addr.s_addr==0) {\n\n\t\tfprintf(stderr, \"qemu: error: init_dgram: fd=%d unbound, cannot setup multicast dst addr\\n\",\n\n\t\t\tfd);\n\n\t\treturn NULL;\n\n\t    }\n\n\t    /* clone dgram socket */\n\n\t    newfd = net_socket_mcast_create(&saddr);\n\n\t    if (newfd < 0) {\n\n\t\t/* error already reported by net_socket_mcast_create() */\n\n\t\tclose(fd);\n\n\t\treturn NULL;\n\n\t    }\n\n\t    /* clone newfd to fd, close newfd */\n\n\t    dup2(newfd, fd);\n\n\t    close(newfd);\n\n\t\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: error: init_dgram: fd=%d failed getsockname(): %s\\n\",\n\n\t\t    fd, strerror(errno));\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    s = qemu_mallocz(sizeof(NetSocketState));\n\n    if (!s)\n\n        return NULL;\n\n    s->fd = fd;\n\n\n\n    s->vc = qemu_new_vlan_client(vlan, net_socket_receive_dgram, s);\n\n    qemu_set_fd_handler(s->fd, net_socket_send_dgram, NULL, s);\n\n\n\n    /* mcast: save bound address as dst */\n\n    if (is_connected) s->dgram_dst=saddr;\n\n\n\n    snprintf(s->vc->info_str, sizeof(s->vc->info_str),\n\n\t    \"socket: fd=%d (%s mcast=%s:%d)\", \n\n\t    fd, is_connected? \"cloned\" : \"\",\n\n\t    inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));\n\n    return s;\n\n}\n", "idx": 10729, "_split": "valid", "_hash": "c3f6165e40bcb7be8b5a8a52f69c0c1d"}
{"project": "qemu", "commit_id": "a7c36ee4920ea3acc227a0248dd161693f207357", "target": 1, "func": "int net_init_tap(QemuOpts *opts, Monitor *mon, const char *name, VLANState *vlan)\n\n{\n\n    TAPState *s;\n\n    int fd, vnet_hdr = 0;\n\n\n\n    if (qemu_opt_get(opts, \"fd\")) {\n\n        if (qemu_opt_get(opts, \"ifname\") ||\n\n            qemu_opt_get(opts, \"script\") ||\n\n            qemu_opt_get(opts, \"downscript\") ||\n\n            qemu_opt_get(opts, \"vnet_hdr\")) {\n\n            error_report(\"ifname=, script=, downscript= and vnet_hdr= is invalid with fd=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = net_handle_fd_param(mon, qemu_opt_get(opts, \"fd\"));\n\n        if (fd == -1) {\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n    } else {\n\n        if (!qemu_opt_get(opts, \"script\")) {\n\n            qemu_opt_set(opts, \"script\", DEFAULT_NETWORK_SCRIPT);\n\n        }\n\n\n\n        if (!qemu_opt_get(opts, \"downscript\")) {\n\n            qemu_opt_set(opts, \"downscript\", DEFAULT_NETWORK_DOWN_SCRIPT);\n\n        }\n\n\n\n        fd = net_tap_init(opts, &vnet_hdr);\n\n        if (fd == -1) {\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    s = net_tap_fd_init(vlan, \"tap\", name, fd, vnet_hdr);\n\n    if (!s) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    if (tap_set_sndbuf(s->fd, opts) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"fd\")) {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"fd=%d\", fd);\n\n    } else {\n\n        const char *ifname, *script, *downscript;\n\n\n\n        ifname     = qemu_opt_get(opts, \"ifname\");\n\n        script     = qemu_opt_get(opts, \"script\");\n\n        downscript = qemu_opt_get(opts, \"downscript\");\n\n\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n                 \"ifname=%s,script=%s,downscript=%s\",\n\n                 ifname, script, downscript);\n\n\n\n        if (strcmp(downscript, \"no\") != 0) {\n\n            snprintf(s->down_script, sizeof(s->down_script), \"%s\", downscript);\n\n            snprintf(s->down_script_arg, sizeof(s->down_script_arg), \"%s\", ifname);\n\n        }\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"vhost\", !!qemu_opt_get(opts, \"vhostfd\") ||\n\n                          qemu_opt_get_bool(opts, \"vhostforce\", false))) {\n\n        int vhostfd, r;\n\n        bool force = qemu_opt_get_bool(opts, \"vhostforce\", false);\n\n        if (qemu_opt_get(opts, \"vhostfd\")) {\n\n            r = net_handle_fd_param(mon, qemu_opt_get(opts, \"vhostfd\"));\n\n            if (r == -1) {\n\n                return -1;\n\n            }\n\n            vhostfd = r;\n\n        } else {\n\n            vhostfd = -1;\n\n        }\n\n        s->vhost_net = vhost_net_init(&s->nc, vhostfd, force);\n\n        if (!s->vhost_net) {\n\n            error_report(\"vhost-net requested but could not be initialized\");\n\n            return -1;\n\n        }\n\n    } else if (qemu_opt_get(opts, \"vhostfd\")) {\n\n        error_report(\"vhostfd= is not valid without vhost\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 10783, "_split": "valid", "_hash": "73ec9670762a2e7ab2ac2fe86aeab023"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint64_equal(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint64_t *v = pv;\n\n    uint64_t v2;\n\n    qemu_get_be64s(f, &v2);\n\n\n\n    if (*v == v2) {\n\n        return 0;\n\n    }\n\n    return -EINVAL;\n\n}\n", "idx": 10803, "_split": "valid", "_hash": "352e4b2ca91e72e92e192c25d8014626"}
{"project": "qemu", "commit_id": "82a93a1d307064f35c363f79b04b0a0149ac53d9", "target": 1, "func": "void spapr_drc_detach(sPAPRDRConnector *drc, DeviceState *d, Error **errp)\n\n{\n\n    trace_spapr_drc_detach(spapr_drc_index(drc));\n\n\n\n    if (drc->isolation_state != SPAPR_DR_ISOLATION_STATE_ISOLATED) {\n\n        trace_spapr_drc_awaiting_isolated(spapr_drc_index(drc));\n\n        drc->awaiting_release = true;\n\n        return;\n\n    }\n\n\n\n    if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&\n\n        drc->allocation_state != SPAPR_DR_ALLOCATION_STATE_UNUSABLE) {\n\n        trace_spapr_drc_awaiting_unusable(spapr_drc_index(drc));\n\n        drc->awaiting_release = true;\n\n        return;\n\n    }\n\n\n\n    if (drc->awaiting_allocation) {\n\n        drc->awaiting_release = true;\n\n        trace_spapr_drc_awaiting_allocation(spapr_drc_index(drc));\n\n        return;\n\n    }\n\n\n\n    spapr_drc_release(drc);\n\n}\n", "idx": 10813, "_split": "valid", "_hash": "eca88cef2c117327329e540bd498f739"}
{"project": "qemu", "commit_id": "7f4a930e64b9e69cd340395a7e4f0494aef4fcdd", "target": 1, "func": "static int vhost_user_set_log_base(struct vhost_dev *dev, uint64_t base,\n\n                                   struct vhost_log *log)\n\n{\n\n    int fds[VHOST_MEMORY_MAX_NREGIONS];\n\n    size_t fd_num = 0;\n\n    bool shmfd = virtio_has_feature(dev->protocol_features,\n\n                                    VHOST_USER_PROTOCOL_F_LOG_SHMFD);\n\n    VhostUserMsg msg = {\n\n        .request = VHOST_USER_SET_LOG_BASE,\n\n        .flags = VHOST_USER_VERSION,\n\n        .u64 = base,\n\n        .size = sizeof(m.u64),\n\n    };\n\n\n\n    if (shmfd && log->fd != -1) {\n\n        fds[fd_num++] = log->fd;\n\n    }\n\n\n\n    vhost_user_write(dev, &msg, fds, fd_num);\n\n\n\n    if (shmfd) {\n\n        msg.size = 0;\n\n        if (vhost_user_read(dev, &msg) < 0) {\n\n            return 0;\n\n        }\n\n\n\n        if (msg.request != VHOST_USER_SET_LOG_BASE) {\n\n            error_report(\"Received unexpected msg type. \"\n\n                         \"Expected %d received %d\",\n\n                         VHOST_USER_SET_LOG_BASE, msg.request);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 10815, "_split": "valid", "_hash": "6845f41967c7ffc2a85c3b22215640fe"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void *vmstate_base_addr(void *opaque, VMStateField *field, bool alloc)\n\n{\n\n    void *base_addr = opaque + field->offset;\n\n\n\n    if (field->flags & VMS_POINTER) {\n\n        if (alloc && (field->flags & VMS_ALLOC)) {\n\n            gsize size = 0;\n\n            if (field->flags & VMS_VBUFFER) {\n\n                size = vmstate_size(opaque, field);\n\n            } else {\n\n                int n_elems = vmstate_n_elems(opaque, field);\n\n                if (n_elems) {\n\n                    size = n_elems * field->size;\n\n                }\n\n            }\n\n            if (size) {\n\n                *((void **)base_addr + field->start) = g_malloc(size);\n\n            }\n\n        }\n\n        base_addr = *(void **)base_addr + field->start;\n\n    }\n\n\n\n    return base_addr;\n\n}\n", "idx": 10820, "_split": "valid", "_hash": "dfd1ff3ee3666b37c44709edae9e1f79"}
{"project": "qemu", "commit_id": "4fa62005d0a85df9bb14ea9f53109d7c5f66eeb9", "target": 1, "func": "static int coroutine_fn v9fs_complete_renameat(V9fsPDU *pdu, int32_t olddirfid,\n\n                                               V9fsString *old_name,\n\n                                               int32_t newdirfid,\n\n                                               V9fsString *new_name)\n\n{\n\n    int err = 0;\n\n    V9fsState *s = pdu->s;\n\n    V9fsFidState *newdirfidp = NULL, *olddirfidp = NULL;\n\n\n\n    olddirfidp = get_fid(pdu, olddirfid);\n\n    if (olddirfidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out;\n\n    }\n\n    if (newdirfid != -1) {\n\n        newdirfidp = get_fid(pdu, newdirfid);\n\n        if (newdirfidp == NULL) {\n\n            err = -ENOENT;\n\n            goto out;\n\n        }\n\n    } else {\n\n        newdirfidp = get_fid(pdu, olddirfid);\n\n    }\n\n\n\n    err = v9fs_co_renameat(pdu, &olddirfidp->path, old_name,\n\n                           &newdirfidp->path, new_name);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    if (s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT) {\n\n        /* Only for path based fid  we need to do the below fixup */\n\n        v9fs_fix_fid_paths(pdu, &olddirfidp->path, old_name,\n\n                           &newdirfidp->path, new_name);\n\n    }\n\nout:\n\n    if (olddirfidp) {\n\n        put_fid(pdu, olddirfidp);\n\n    }\n\n    if (newdirfidp) {\n\n        put_fid(pdu, newdirfidp);\n\n    }\n\n    return err;\n\n}\n", "idx": 10860, "_split": "valid", "_hash": "aac3315284ab9d42e3ac8a817c1a51e7"}
{"project": "qemu", "commit_id": "46c5874e9cd752ed8ded31af03472edd8fc3efc1", "target": 0, "func": "static void rtas_ibm_set_eeh_option(PowerPCCPU *cpu,\n\n                                    sPAPREnvironment *spapr,\n\n                                    uint32_t token, uint32_t nargs,\n\n                                    target_ulong args, uint32_t nret,\n\n                                    target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    sPAPRPHBClass *spc;\n\n    uint32_t addr, option;\n\n    uint64_t buid;\n\n    int ret;\n\n\n\n    if ((nargs != 4) || (nret != 1)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);\n\n    addr = rtas_ld(args, 0);\n\n    option = rtas_ld(args, 3);\n\n\n\n    sphb = find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);\n\n    if (!spc->eeh_set_option) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    ret = spc->eeh_set_option(sphb, addr, option);\n\n    rtas_st(rets, 0, ret);\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 10889, "_split": "valid", "_hash": "e4bd4b43bda3c5b003112e090eb37a57"}
{"project": "qemu", "commit_id": "9d40cd8a68cfc7606f4548cc9e812bab15c6dc28", "target": 0, "func": "static bool nvic_user_access_ok(NVICState *s, hwaddr offset)\n\n{\n\n    /* Return true if unprivileged access to this register is permitted. */\n\n    switch (offset) {\n\n    case 0xf00: /* STIR: accessible only if CCR.USERSETMPEND permits */\n\n        return s->cpu->env.v7m.ccr & R_V7M_CCR_USERSETMPEND_MASK;\n\n    default:\n\n        /* All other user accesses cause a BusFault unconditionally */\n\n        return false;\n\n    }\n\n}\n", "idx": 10897, "_split": "valid", "_hash": "bea4494b6dd6b5d679fe23c70c38df2b"}
{"project": "qemu", "commit_id": "5543d1abb6e218a9d3b8887b777fd3947c86c4cf", "target": 1, "func": "static void kvm_arm_gic_realize(DeviceState *dev, Error **errp)\n{\n    int i;\n    GICState *s = KVM_ARM_GIC(dev);\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n    KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s);\n    Error *local_err = NULL;\n    int ret;\n    kgc->parent_realize(dev, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n    i = s->num_irq - GIC_INTERNAL;\n    /* For the GIC, also expose incoming GPIO lines for PPIs for each CPU.\n     * GPIO array layout is thus:\n     *  [0..N-1] SPIs\n     *  [N..N+31] PPIs for CPU 0\n     *  [N+32..N+63] PPIs for CPU 1\n     *   ...\n     */\n    i += (GIC_INTERNAL * s->num_cpu);\n    qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i);\n    /* We never use our outbound IRQ/FIQ lines but provide them so that\n     * we maintain the same interface as the non-KVM GIC.\n     */\n    for (i = 0; i < s->num_cpu; i++) {\n        sysbus_init_irq(sbd, &s->parent_irq[i]);\n    for (i = 0; i < s->num_cpu; i++) {\n        sysbus_init_irq(sbd, &s->parent_fiq[i]);\n    /* Try to create the device via the device control API */\n    s->dev_fd = -1;\n    ret = kvm_create_device(kvm_state, KVM_DEV_TYPE_ARM_VGIC_V2, false);\n    if (ret >= 0) {\n        s->dev_fd = ret;\n    } else if (ret != -ENODEV && ret != -ENOTSUP) {\n        error_setg_errno(errp, -ret, \"error creating in-kernel VGIC\");\n    if (kvm_gic_supports_attr(s, KVM_DEV_ARM_VGIC_GRP_NR_IRQS, 0)) {\n        uint32_t numirqs = s->num_irq;\n        kvm_gic_access(s, KVM_DEV_ARM_VGIC_GRP_NR_IRQS, 0, 0, &numirqs, 1);\n    /* Tell the kernel to complete VGIC initialization now */\n    if (kvm_gic_supports_attr(s, KVM_DEV_ARM_VGIC_GRP_CTRL,\n                              KVM_DEV_ARM_VGIC_CTRL_INIT)) {\n        kvm_gic_access(s, KVM_DEV_ARM_VGIC_GRP_CTRL,\n                          KVM_DEV_ARM_VGIC_CTRL_INIT, 0, 0, 1);\n    /* Distributor */\n    memory_region_init_reservation(&s->iomem, OBJECT(s),\n                                   \"kvm-gic_dist\", 0x1000);\n    sysbus_init_mmio(sbd, &s->iomem);\n    kvm_arm_register_device(&s->iomem,\n                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)\n                            | KVM_VGIC_V2_ADDR_TYPE_DIST,\n                            KVM_DEV_ARM_VGIC_GRP_ADDR,\n                            KVM_VGIC_V2_ADDR_TYPE_DIST,\n                            s->dev_fd);\n    /* CPU interface for current core. Unlike arm_gic, we don't\n     * provide the \"interface for core #N\" memory regions, because\n     * cores with a VGIC don't have those.\n     */\n    memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s),\n                                   \"kvm-gic_cpu\", 0x1000);\n    sysbus_init_mmio(sbd, &s->cpuiomem[0]);\n    kvm_arm_register_device(&s->cpuiomem[0],\n                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)\n                            | KVM_VGIC_V2_ADDR_TYPE_CPU,\n                            KVM_DEV_ARM_VGIC_GRP_ADDR,\n                            KVM_VGIC_V2_ADDR_TYPE_CPU,\n                            s->dev_fd);", "idx": 10912, "_split": "valid", "_hash": "835f97e823912690137f2881d94744c9"}
{"project": "qemu", "commit_id": "2a62914bd8209d97e918f30f0de74bec2bf622c4", "target": 0, "func": "static int64_t cpu_get_icount_locked(void)\n\n{\n\n    int64_t icount;\n\n    CPUState *cpu = current_cpu;\n\n\n\n    icount = timers_state.qemu_icount;\n\n    if (cpu) {\n\n        if (!cpu_can_do_io(cpu)) {\n\n            fprintf(stderr, \"Bad clock read\\n\");\n\n        }\n\n        icount -= (cpu->icount_decr.u16.low + cpu->icount_extra);\n\n    }\n\n    return timers_state.qemu_icount_bias + cpu_icount_to_ns(icount);\n\n}\n", "idx": 10932, "_split": "valid", "_hash": "6720748eca9ac2c8297ab79f9af344e0"}
{"project": "qemu", "commit_id": "74b4c74d5efb0a489bdf0acc5b5d0197167e7649", "target": 0, "func": "static void sigp_start(CPUState *cs, run_on_cpu_data arg)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    SigpInfo *si = arg.host_ptr;\n\n\n\n    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {\n\n        si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n        return;\n\n    }\n\n\n\n    s390_cpu_set_state(CPU_STATE_OPERATING, cpu);\n\n    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n}\n", "idx": 10938, "_split": "valid", "_hash": "b94d280fd762e333afc6e03935d35775"}
{"project": "qemu", "commit_id": "678421650dc166cd6cb35bb2bc0baf1b481b40ca", "target": 0, "func": "static void pchip_write(void *opaque, hwaddr addr,\n\n                        uint64_t v32, unsigned size)\n\n{\n\n    TyphoonState *s = opaque;\n\n    uint64_t val, oldval;\n\n\n\n    if (addr & 4) {\n\n        val = v32 << 32 | s->latch_tmp;\n\n        addr ^= 4;\n\n    } else {\n\n        s->latch_tmp = v32;\n\n        return;\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x0000:\n\n        /* WSBA0: Window Space Base Address Register.  */\n\n        s->pchip.win[0].base_addr = val;\n\n        break;\n\n    case 0x0040:\n\n        /* WSBA1 */\n\n        s->pchip.win[1].base_addr = val;\n\n        break;\n\n    case 0x0080:\n\n        /* WSBA2 */\n\n        s->pchip.win[2].base_addr = val;\n\n        break;\n\n    case 0x00c0:\n\n        /* WSBA3 */\n\n        s->pchip.win[3].base_addr = val;\n\n        break;\n\n\n\n    case 0x0100:\n\n        /* WSM0: Window Space Mask Register.  */\n\n        s->pchip.win[0].mask = val;\n\n        break;\n\n    case 0x0140:\n\n        /* WSM1 */\n\n        s->pchip.win[1].mask = val;\n\n        break;\n\n    case 0x0180:\n\n        /* WSM2 */\n\n        s->pchip.win[2].mask = val;\n\n        break;\n\n    case 0x01c0:\n\n        /* WSM3 */\n\n        s->pchip.win[3].mask = val;\n\n        break;\n\n\n\n    case 0x0200:\n\n        /* TBA0: Translated Base Address Register.  */\n\n        s->pchip.win[0].translated_base_pfn = val >> 10;\n\n        break;\n\n    case 0x0240:\n\n        /* TBA1 */\n\n        s->pchip.win[1].translated_base_pfn = val >> 10;\n\n        break;\n\n    case 0x0280:\n\n        /* TBA2 */\n\n        s->pchip.win[2].translated_base_pfn = val >> 10;\n\n        break;\n\n    case 0x02c0:\n\n        /* TBA3 */\n\n        s->pchip.win[3].translated_base_pfn = val >> 10;\n\n        break;\n\n\n\n    case 0x0300:\n\n        /* PCTL: Pchip Control Register.  */\n\n        oldval = s->pchip.ctl;\n\n        oldval &= ~0x00001cff0fc7ffull;       /* RW fields */\n\n        oldval |= val & 0x00001cff0fc7ffull;\n\n\n\n        s->pchip.ctl = oldval;\n\n        break;\n\n\n\n    case 0x0340:\n\n        /* PLAT: Pchip Master Latency Register.  */\n\n        break;\n\n    case 0x03c0:\n\n        /* PERROR: Pchip Error Register.  */\n\n        break;\n\n    case 0x0400:\n\n        /* PERRMASK: Pchip Error Mask Register.  */\n\n        break;\n\n    case 0x0440:\n\n        /* PERRSET: Pchip Error Set Register.  */\n\n        break;\n\n\n\n    case 0x0480:\n\n        /* TLBIV: Translation Buffer Invalidate Virtual Register.  */\n\n        break;\n\n\n\n    case 0x04c0:\n\n        /* TLBIA: Translation Buffer Invalidate All Register (WO).  */\n\n        break;\n\n\n\n    case 0x0500:\n\n        /* PMONCTL */\n\n    case 0x0540:\n\n        /* PMONCNT */\n\n    case 0x0800:\n\n        /* SPRST */\n\n        break;\n\n\n\n    default:\n\n        cpu_unassigned_access(current_cpu, addr, true, false, 0, size);\n\n        return;\n\n    }\n\n}\n", "idx": 10941, "_split": "valid", "_hash": "c29be074dcfb1bddd1074b1201c709b6"}
{"project": "qemu", "commit_id": "b0f74c87a1dbd6b0c5e4de7f1c5cb40197e3fbe9", "target": 1, "func": "static void vga_precise_update_retrace_info(VGAState *s)\n\n{\n\n    int htotal_chars;\n\n    int hretr_start_char;\n\n    int hretr_skew_chars;\n\n    int hretr_end_char;\n\n\n\n    int vtotal_lines;\n\n    int vretr_start_line;\n\n    int vretr_end_line;\n\n\n\n    int div2, sldiv2, dots;\n\n    int clocking_mode;\n\n    int clock_sel;\n\n    const int hz[] = {25175000, 28322000, 25175000, 25175000};\n\n    int64_t chars_per_sec;\n\n    struct vga_precise_retrace *r = &s->retrace_info.precise;\n\n\n\n    htotal_chars = s->cr[0x00] + 5;\n\n    hretr_start_char = s->cr[0x04];\n\n    hretr_skew_chars = (s->cr[0x05] >> 5) & 3;\n\n    hretr_end_char = s->cr[0x05] & 0x1f;\n\n\n\n    vtotal_lines = (s->cr[0x06]\n\n                    | (((s->cr[0x07] & 1) | ((s->cr[0x07] >> 4) & 2)) << 8)) + 2\n\n        ;\n\n    vretr_start_line = s->cr[0x10]\n\n        | ((((s->cr[0x07] >> 2) & 1) | ((s->cr[0x07] >> 6) & 2)) << 8)\n\n        ;\n\n    vretr_end_line = s->cr[0x11] & 0xf;\n\n\n\n\n\n    div2 = (s->cr[0x17] >> 2) & 1;\n\n    sldiv2 = (s->cr[0x17] >> 3) & 1;\n\n\n\n    clocking_mode = (s->sr[0x01] >> 3) & 1;\n\n    clock_sel = (s->msr >> 2) & 3;\n\n    dots = (s->msr & 1) ? 8 : 9;\n\n\n\n    chars_per_sec = hz[clock_sel] / dots;\n\n\n\n    htotal_chars <<= clocking_mode;\n\n\n\n    r->total_chars = vtotal_lines * htotal_chars;\n\n    if (r->freq) {\n\n        r->ticks_per_char = ticks_per_sec / (r->total_chars * r->freq);\n\n    } else {\n\n        r->ticks_per_char = ticks_per_sec / chars_per_sec;\n\n    }\n\n\n\n    r->vstart = vretr_start_line;\n\n    r->vend = r->vstart + vretr_end_line + 1;\n\n\n\n    r->hstart = hretr_start_char + hretr_skew_chars;\n\n    r->hend = r->hstart + hretr_end_char + 1;\n\n    r->htotal = htotal_chars;\n\n\n\n#if 0\n\n    printf (\n\n        \"hz=%f\\n\"\n\n        \"htotal = %d\\n\"\n\n        \"hretr_start = %d\\n\"\n\n        \"hretr_skew = %d\\n\"\n\n        \"hretr_end = %d\\n\"\n\n        \"vtotal = %d\\n\"\n\n        \"vretr_start = %d\\n\"\n\n        \"vretr_end = %d\\n\"\n\n        \"div2 = %d sldiv2 = %d\\n\"\n\n        \"clocking_mode = %d\\n\"\n\n        \"clock_sel = %d %d\\n\"\n\n        \"dots = %d\\n\"\n\n        \"ticks/char = %lld\\n\"\n\n        \"\\n\",\n\n        (double) ticks_per_sec / (r->ticks_per_char * r->total_chars),\n\n        htotal_chars,\n\n        hretr_start_char,\n\n        hretr_skew_chars,\n\n        hretr_end_char,\n\n        vtotal_lines,\n\n        vretr_start_line,\n\n        vretr_end_line,\n\n        div2, sldiv2,\n\n        clocking_mode,\n\n        clock_sel,\n\n        hz[clock_sel],\n\n        dots,\n\n        r->ticks_per_char\n\n        );\n\n#endif\n\n}\n", "idx": 10956, "_split": "valid", "_hash": "b7a02f014d3faaecaa6ab72c0888bdc7"}
{"project": "qemu", "commit_id": "2563c9c6b8670400c48e562034b321a7cf3d9a85", "target": 1, "func": "static ssize_t drop_sync(QIOChannel *ioc, size_t size)\n\n{\n\n    ssize_t ret = 0;\n\n    char small[1024];\n\n    char *buffer;\n\n\n\n    buffer = sizeof(small) < size ? small : g_malloc(MIN(65536, size));\n\n    while (size > 0) {\n\n        ssize_t count = read_sync(ioc, buffer, MIN(65536, size));\n\n\n\n        if (count <= 0) {\n\n            goto cleanup;\n\n        }\n\n        assert(count <= size);\n\n        size -= count;\n\n        ret += count;\n\n    }\n\n\n\n cleanup:\n\n    if (buffer != small) {\n\n        g_free(buffer);\n\n    }\n\n    return ret;\n\n}\n", "idx": 10964, "_split": "valid", "_hash": "f235f09882fb6d37a977ad39e39eb29a"}
{"project": "qemu", "commit_id": "262a69f4282e44426c7a132138581d400053e0a1", "target": 1, "func": "void *qemu_get_virtqueue_element(VirtIODevice *vdev, QEMUFile *f, size_t sz)\n\n{\n\n    VirtQueueElement *elem;\n\n    VirtQueueElementOld data;\n\n    int i;\n\n\n\n    qemu_get_buffer(f, (uint8_t *)&data, sizeof(VirtQueueElementOld));\n\n\n\n    /* TODO: teach all callers that this can fail, and return failure instead\n\n     * of asserting here.\n\n     * When we do, we might be able to re-enable NDEBUG below.\n\n     */\n\n#ifdef NDEBUG\n\n#error building with NDEBUG is not supported\n\n#endif\n\n    assert(ARRAY_SIZE(data.in_addr) >= data.in_num);\n\n    assert(ARRAY_SIZE(data.out_addr) >= data.out_num);\n\n\n\n    elem = virtqueue_alloc_element(sz, data.out_num, data.in_num);\n\n    elem->index = data.index;\n\n\n\n    for (i = 0; i < elem->in_num; i++) {\n\n        elem->in_addr[i] = data.in_addr[i];\n\n    }\n\n\n\n    for (i = 0; i < elem->out_num; i++) {\n\n        elem->out_addr[i] = data.out_addr[i];\n\n    }\n\n\n\n    for (i = 0; i < elem->in_num; i++) {\n\n        /* Base is overwritten by virtqueue_map.  */\n\n        elem->in_sg[i].iov_base = 0;\n\n        elem->in_sg[i].iov_len = data.in_sg[i].iov_len;\n\n    }\n\n\n\n    for (i = 0; i < elem->out_num; i++) {\n\n        /* Base is overwritten by virtqueue_map.  */\n\n        elem->out_sg[i].iov_base = 0;\n\n        elem->out_sg[i].iov_len = data.out_sg[i].iov_len;\n\n    }\n\n\n\n    virtqueue_map(vdev, elem);\n\n    return elem;\n\n}\n", "idx": 10965, "_split": "valid", "_hash": "e3c4755ee6a79502efb9fbbf94d1e0c2"}
{"project": "qemu", "commit_id": "c4237dfa635900e4d1cdc6038d5efe3507f45f0c", "target": 1, "func": "static void mirror_read_complete(void *opaque, int ret)\n\n{\n\n    MirrorOp *op = opaque;\n\n    MirrorBlockJob *s = op->s;\n\n    if (ret < 0) {\n\n        BlockDriverState *source = s->common.bs;\n\n        BlockErrorAction action;\n\n\n\n        bdrv_set_dirty(source, op->sector_num, op->nb_sectors);\n\n        action = mirror_error_action(s, true, -ret);\n\n        if (action == BLOCK_ERROR_ACTION_REPORT && s->ret >= 0) {\n\n            s->ret = ret;\n\n        }\n\n\n\n        mirror_iteration_done(op, ret);\n\n        return;\n\n    }\n\n    bdrv_aio_writev(s->target, op->sector_num, &op->qiov, op->nb_sectors,\n\n                    mirror_write_complete, op);\n\n}\n", "idx": 10970, "_split": "valid", "_hash": "0ef051c0667d10713f106f230e5b5087"}
{"project": "qemu", "commit_id": "e268ca52328eb0460ae0d10b7f4313a63d5b000c", "target": 0, "func": "static BlockDriverAIOCB *qcow_aio_writev(BlockDriverState *bs,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowAIOCB *acb;\n\n\n\n    s->cluster_cache_offset = -1; /* disable compressed cache */\n\n\n\n    acb = qemu_aio_get(bs, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    acb->hd_aiocb = NULL;\n\n    acb->sector_num = sector_num;\n\n    acb->qiov = qiov;\n\n    if (qiov->niov > 1) {\n\n        acb->buf = acb->orig_buf = qemu_memalign(512, qiov->size);\n\n        qemu_iovec_to_buffer(qiov, acb->buf);\n\n    } else {\n\n        acb->buf = (uint8_t *)qiov->iov->iov_base;\n\n    }\n\n    acb->nb_sectors = nb_sectors;\n\n    acb->n = 0;\n\n\n\n    qcow_aio_write_cb(acb, 0);\n\n    return &acb->common;\n\n}\n", "idx": 10986, "_split": "valid", "_hash": "6489c539157d3104a9975cbe5db87f89"}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static uint32_t vmsvga_bios_read(void *opaque, uint32_t address)\n\n{\n\n    printf(\"%s: what are we supposed to return?\\n\", __FUNCTION__);\n\n    return 0xcafe;\n\n}\n", "idx": 11006, "_split": "valid", "_hash": "4a9171ddc0f18aaf40b012d9903f2b15"}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "func": "static void v9fs_lcreate(void *opaque)\n\n{\n\n    int32_t dfid, flags, mode;\n\n    gid_t gid;\n\n    ssize_t err = 0;\n\n    ssize_t offset = 7;\n\n    V9fsString name;\n\n    V9fsFidState *fidp;\n\n    struct stat stbuf;\n\n    V9fsQID qid;\n\n    int32_t iounit;\n\n    V9fsPDU *pdu = opaque;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dsddd\", &dfid, &name, &flags,\n\n                  &mode, &gid);\n\n\n\n\n    fidp = get_fid(pdu, dfid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n\n\n    flags = get_dotl_openflags(pdu->s, flags);\n\n    err = v9fs_co_open2(pdu, fidp, &name, gid,\n\n                        flags | O_CREAT, mode, &stbuf);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    fidp->fid_type = P9_FID_FILE;\n\n    fidp->open_flags = flags;\n\n    if (flags & O_EXCL) {\n\n        /*\n\n         * We let the host file system do O_EXCL check\n\n         * We should not reclaim such fd\n\n         */\n\n        fidp->flags |= FID_NON_RECLAIMABLE;\n\n    }\n\n    iounit =  get_iounit(pdu, &fidp->path);\n\n    stat_to_qid(&stbuf, &qid);\n\n    offset += pdu_marshal(pdu, offset, \"Qd\", &qid, iounit);\n\n    err = offset;\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    trace_v9fs_lcreate_return(pdu->tag, pdu->id,\n\n                              qid.type, qid.version, qid.path, iounit);\n\n    complete_pdu(pdu->s, pdu, err);\n\n    v9fs_string_free(&name);\n\n}", "idx": 11055, "_split": "valid", "_hash": "7aab5334ffcb5154fd18d6f5876bc8e3"}
{"project": "qemu", "commit_id": "af7e9e74c6a62a5bcd911726a9e88d28b61490e0", "target": 1, "func": "static void openpic_cpu_write_internal(void *opaque, hwaddr addr,\n\n                                       uint32_t val, int idx)\n\n{\n\n    OpenPICState *opp = opaque;\n\n    IRQ_src_t *src;\n\n    IRQ_dst_t *dst;\n\n    int s_IRQ, n_IRQ;\n\n\n\n    DPRINTF(\"%s: cpu %d addr \" TARGET_FMT_plx \" <= %08x\\n\", __func__, idx,\n\n            addr, val);\n\n\n\n    if (idx < 0) {\n\n        return;\n\n    }\n\n\n\n    if (addr & 0xF)\n\n        return;\n\n    dst = &opp->dst[idx];\n\n    addr &= 0xFF0;\n\n    switch (addr) {\n\n    case 0x40: /* IPIDR */\n\n    case 0x50:\n\n    case 0x60:\n\n    case 0x70:\n\n        idx = (addr - 0x40) >> 4;\n\n        /* we use IDE as mask which CPUs to deliver the IPI to still. */\n\n        write_IRQreg_ide(opp, opp->irq_ipi0 + idx,\n\n                         opp->src[opp->irq_ipi0 + idx].ide | val);\n\n        openpic_set_irq(opp, opp->irq_ipi0 + idx, 1);\n\n        openpic_set_irq(opp, opp->irq_ipi0 + idx, 0);\n\n        break;\n\n    case 0x80: /* PCTP */\n\n        dst->pctp = val & 0x0000000F;\n\n        break;\n\n    case 0x90: /* WHOAMI */\n\n        /* Read-only register */\n\n        break;\n\n    case 0xA0: /* PIAC */\n\n        /* Read-only register */\n\n        break;\n\n    case 0xB0: /* PEOI */\n\n        DPRINTF(\"PEOI\\n\");\n\n        s_IRQ = IRQ_get_next(opp, &dst->servicing);\n\n        IRQ_resetbit(&dst->servicing, s_IRQ);\n\n        dst->servicing.next = -1;\n\n        /* Set up next servicing IRQ */\n\n        s_IRQ = IRQ_get_next(opp, &dst->servicing);\n\n        /* Check queued interrupts. */\n\n        n_IRQ = IRQ_get_next(opp, &dst->raised);\n\n        src = &opp->src[n_IRQ];\n\n        if (n_IRQ != -1 &&\n\n            (s_IRQ == -1 ||\n\n             IPVP_PRIORITY(src->ipvp) > dst->servicing.priority)) {\n\n            DPRINTF(\"Raise OpenPIC INT output cpu %d irq %d\\n\",\n\n                    idx, n_IRQ);\n\n            openpic_irq_raise(opp, idx, src);\n\n        }\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 11069, "_split": "valid", "_hash": "02482ce0385484ce4e28d72876684f83"}
{"project": "qemu", "commit_id": "a01672d3968cf91208666d371784110bfde9d4f8", "target": 1, "func": "int kvm_init(void)\n\n{\n\n    static const char upgrade_note[] =\n\n        \"Please upgrade to at least kernel 2.6.29 or recent kvm-kmod\\n\"\n\n        \"(see http://sourceforge.net/projects/kvm).\\n\";\n\n    KVMState *s;\n\n    const KVMCapabilityInfo *missing_cap;\n\n    int ret;\n\n    int i;\n\n\n\n    s = g_malloc0(sizeof(KVMState));\n\n\n\n#ifdef KVM_CAP_SET_GUEST_DEBUG\n\n    QTAILQ_INIT(&s->kvm_sw_breakpoints);\n\n#endif\n\n    for (i = 0; i < ARRAY_SIZE(s->slots); i++) {\n\n        s->slots[i].slot = i;\n\n    }\n\n    s->vmfd = -1;\n\n    s->fd = qemu_open(\"/dev/kvm\", O_RDWR);\n\n    if (s->fd == -1) {\n\n        fprintf(stderr, \"Could not access KVM kernel module: %m\\n\");\n\n        ret = -errno;\n\n        goto err;\n\n    }\n\n\n\n    ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0);\n\n    if (ret < KVM_API_VERSION) {\n\n        if (ret > 0) {\n\n            ret = -EINVAL;\n\n        }\n\n        fprintf(stderr, \"kvm version too old\\n\");\n\n        goto err;\n\n    }\n\n\n\n    if (ret > KVM_API_VERSION) {\n\n        ret = -EINVAL;\n\n        fprintf(stderr, \"kvm version not supported\\n\");\n\n        goto err;\n\n    }\n\n\n\n    s->vmfd = kvm_ioctl(s, KVM_CREATE_VM, 0);\n\n    if (s->vmfd < 0) {\n\n#ifdef TARGET_S390X\n\n        fprintf(stderr, \"Please add the 'switch_amode' kernel parameter to \"\n\n                        \"your host kernel command line\\n\");\n\n#endif\n\n        ret = s->vmfd;\n\n        goto err;\n\n    }\n\n\n\n    missing_cap = kvm_check_extension_list(s, kvm_required_capabilites);\n\n    if (!missing_cap) {\n\n        missing_cap =\n\n            kvm_check_extension_list(s, kvm_arch_required_capabilities);\n\n    }\n\n    if (missing_cap) {\n\n        ret = -EINVAL;\n\n        fprintf(stderr, \"kvm does not support %s\\n%s\",\n\n                missing_cap->name, upgrade_note);\n\n        goto err;\n\n    }\n\n\n\n    s->coalesced_mmio = kvm_check_extension(s, KVM_CAP_COALESCED_MMIO);\n\n\n\n    s->broken_set_mem_region = 1;\n\n    ret = kvm_check_extension(s, KVM_CAP_JOIN_MEMORY_REGIONS_WORKS);\n\n    if (ret > 0) {\n\n        s->broken_set_mem_region = 0;\n\n    }\n\n\n\n#ifdef KVM_CAP_VCPU_EVENTS\n\n    s->vcpu_events = kvm_check_extension(s, KVM_CAP_VCPU_EVENTS);\n\n#endif\n\n\n\n    s->robust_singlestep =\n\n        kvm_check_extension(s, KVM_CAP_X86_ROBUST_SINGLESTEP);\n\n\n\n#ifdef KVM_CAP_DEBUGREGS\n\n    s->debugregs = kvm_check_extension(s, KVM_CAP_DEBUGREGS);\n\n#endif\n\n\n\n#ifdef KVM_CAP_XSAVE\n\n    s->xsave = kvm_check_extension(s, KVM_CAP_XSAVE);\n\n#endif\n\n\n\n#ifdef KVM_CAP_XCRS\n\n    s->xcrs = kvm_check_extension(s, KVM_CAP_XCRS);\n\n#endif\n\n\n\n    ret = kvm_arch_init(s);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    kvm_state = s;\n\n    cpu_register_phys_memory_client(&kvm_cpu_phys_memory_client);\n\n\n\n    s->many_ioeventfds = kvm_check_many_ioeventfds();\n\n\n\n    cpu_interrupt_handler = kvm_handle_interrupt;\n\n\n\n    return 0;\n\n\n\nerr:\n\n    if (s) {\n\n        if (s->vmfd >= 0) {\n\n            close(s->vmfd);\n\n        }\n\n        if (s->fd != -1) {\n\n            close(s->fd);\n\n        }\n\n    }\n\n    g_free(s);\n\n\n\n    return ret;\n\n}\n", "idx": 11075, "_split": "valid", "_hash": "11945bbbaa00a1c751c4f71d8b466825"}
{"project": "qemu", "commit_id": "9d7a4c6690ef9962a3b20034f65008f1ea15c1d6", "target": 1, "func": "g_malloc(size_t n_bytes)\n\n{\n\n    void *mem;\n\n    __coverity_negative_sink__(n_bytes);\n\n    mem = malloc(n_bytes == 0 ? 1 : n_bytes);\n\n    if (!mem) __coverity_panic__();\n\n    return mem;\n\n}\n", "idx": 11095, "_split": "valid", "_hash": "cd2df1b67600fe01decad7e999bf76d3"}
{"project": "qemu", "commit_id": "2ed1ebcf65edf6757d8904000889ce52cc0a9d1b", "target": 0, "func": "void qemu_get_timedate(struct tm *tm, int offset)\n\n{\n\n    time_t ti;\n\n\n\n    time(&ti);\n\n    ti += offset;\n\n    if (rtc_date_offset == -1) {\n\n        if (rtc_utc)\n\n            gmtime_r(&ti, tm);\n\n        else\n\n            localtime_r(&ti, tm);\n\n    } else {\n\n        ti -= rtc_date_offset;\n\n        gmtime_r(&ti, tm);\n\n    }\n\n}\n", "idx": 11124, "_split": "valid", "_hash": "b6f6301dc50ee990c2f34749f24cb185"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_lpg_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    struct omap_lpg_s *s = (struct omap_lpg_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n\n\n    if (size != 1) {\n\n        return omap_badwidth_read8(opaque, addr);\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* LCR */\n\n        return s->control;\n\n\n\n    case 0x04:\t/* PMR */\n\n        return s->power;\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 11132, "_split": "valid", "_hash": "fedc75364ecbd124f3763324cadecbdf"}
{"project": "qemu", "commit_id": "63729c36924348e494d69adbbdec6fdda339b76b", "target": 0, "func": "static int local_mksock(FsContext *ctx2, const char *path)\n\n{\n\n    struct sockaddr_un addr;\n\n    int s;\n\n\n\n    addr.sun_family = AF_UNIX;\n\n    snprintf(addr.sun_path, 108, \"%s\", rpath(ctx2, path));\n\n\n\n    s = socket(PF_UNIX, SOCK_STREAM, 0);\n\n    if (s == -1) {\n\n        return -1;\n\n    }\n\n\n\n    if (bind(s, (struct sockaddr *)&addr, sizeof(addr))) {\n\n        close(s);\n\n        return -1;\n\n    }\n\n\n\n    close(s);\n\n    return 0;\n\n}\n", "idx": 11155, "_split": "valid", "_hash": "ea8fac7cf8adf770ac7d6ba7d2677506"}
{"project": "qemu", "commit_id": "e0e2d644096c79a71099b176d08f465f6803a8b1", "target": 1, "func": "static void virtio_device_free_virtqueues(VirtIODevice *vdev)\n\n{\n\n    int i;\n\n    if (!vdev->vq) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < VIRTIO_QUEUE_MAX; i++) {\n\n        VRingMemoryRegionCaches *caches;\n\n        if (vdev->vq[i].vring.num == 0) {\n\n            break;\n\n        }\n\n        caches = atomic_read(&vdev->vq[i].vring.caches);\n\n        atomic_set(&vdev->vq[i].vring.caches, NULL);\n\n        virtio_free_region_cache(caches);\n\n    }\n\n    g_free(vdev->vq);\n\n}\n", "idx": 11160, "_split": "valid", "_hash": "fd554bd27680b2cc2fd46a5184670b40"}
{"project": "qemu", "commit_id": "97a2ae34537882df34810d538ab1f51085499d2c", "target": 1, "func": "static int coroutine_fn raw_co_write_zeroes(\n\n    BlockDriverState *bs, int64_t sector_num,\n\n    int nb_sectors, BdrvRequestFlags flags)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n\n\n    if (!(flags & BDRV_REQ_MAY_UNMAP)) {\n\n        return -ENOTSUP;\n\n    }\n\n    if (!s->discard_zeroes) {\n\n        return -ENOTSUP;\n\n    }\n\n    return paio_submit_co(bs, s->fd, sector_num, NULL, nb_sectors,\n\n                          QEMU_AIO_DISCARD);\n\n}\n", "idx": 11254, "_split": "valid", "_hash": "d48b195edf44d67fbe3ba6058e0a106a"}
{"project": "qemu", "commit_id": "f7736b91c40a617e93505e32dcbd2cb56aad8a23", "target": 0, "func": "static int dma_buf_prepare(BMDMAState *bm, int is_write)\n\n{\n\n    IDEState *s = bmdma_active_if(bm);\n\n    struct {\n\n        uint32_t addr;\n\n        uint32_t size;\n\n    } prd;\n\n    int l, len;\n\n\n\n    qemu_sglist_init(&s->sg, s->nsector / (TARGET_PAGE_SIZE/512) + 1);\n\n    s->io_buffer_size = 0;\n\n    for(;;) {\n\n        if (bm->cur_prd_len == 0) {\n\n            /* end of table (with a fail safe of one page) */\n\n            if (bm->cur_prd_last ||\n\n                (bm->cur_addr - bm->addr) >= 4096)\n\n                return s->io_buffer_size != 0;\n\n            cpu_physical_memory_read(bm->cur_addr, (uint8_t *)&prd, 8);\n\n            bm->cur_addr += 8;\n\n            prd.addr = le32_to_cpu(prd.addr);\n\n            prd.size = le32_to_cpu(prd.size);\n\n            len = prd.size & 0xfffe;\n\n            if (len == 0)\n\n                len = 0x10000;\n\n            bm->cur_prd_len = len;\n\n            bm->cur_prd_addr = prd.addr;\n\n            bm->cur_prd_last = (prd.size & 0x80000000);\n\n        }\n\n        l = bm->cur_prd_len;\n\n        if (l > 0) {\n\n            qemu_sglist_add(&s->sg, bm->cur_prd_addr, l);\n\n            bm->cur_prd_addr += l;\n\n            bm->cur_prd_len -= l;\n\n            s->io_buffer_size += l;\n\n        }\n\n    }\n\n    return 1;\n\n}\n", "idx": 11263, "_split": "valid", "_hash": "61355fe4930db44ae01fec18aa17d30f"}
{"project": "qemu", "commit_id": "1294ca797c6bee39d4dbc3e92010873ce4047e0e", "target": 0, "func": "static int usb_host_claim_interfaces(USBHostDevice *s, int configuration)\n\n{\n\n    USBDevice *udev = USB_DEVICE(s);\n\n    struct libusb_config_descriptor *conf;\n\n    int rc, i;\n\n\n\n    for (i = 0; i < USB_MAX_INTERFACES; i++) {\n\n        udev->altsetting[i] = 0;\n\n    }\n\n    udev->ninterfaces   = 0;\n\n    udev->configuration = 0;\n\n\n\n    if (configuration == 0) {\n\n        /* address state - ignore */\n\n        return USB_RET_SUCCESS;\n\n    }\n\n\n\n    usb_host_detach_kernel(s);\n\n\n\n    rc = libusb_get_active_config_descriptor(s->dev, &conf);\n\n    if (rc != 0) {\n\n        return USB_RET_STALL;\n\n    }\n\n\n\n    for (i = 0; i < conf->bNumInterfaces; i++) {\n\n        trace_usb_host_claim_interface(s->bus_num, s->addr, configuration, i);\n\n        rc = libusb_claim_interface(s->dh, i);\n\n        usb_host_libusb_error(\"libusb_claim_interface\", rc);\n\n        if (rc != 0) {\n\n            return USB_RET_STALL;\n\n        }\n\n        s->ifs[i].claimed = true;\n\n    }\n\n\n\n    udev->ninterfaces   = conf->bNumInterfaces;\n\n    udev->configuration = configuration;\n\n\n\n    libusb_free_config_descriptor(conf);\n\n    return USB_RET_SUCCESS;\n\n}\n", "idx": 11264, "_split": "valid", "_hash": "da81d619682e04b84d8eed9d3caf0587"}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_completion(void)\n\n{\n\n    int len, i, j, max_width, nb_cols;\n\n    char *cmdline;\n\n\n\n    nb_completions = 0;\n\n    \n\n    cmdline = qemu_malloc(term_cmd_buf_index + 1);\n\n    if (!cmdline)\n\n        return;\n\n    memcpy(cmdline, term_cmd_buf, term_cmd_buf_index);\n\n    cmdline[term_cmd_buf_index] = '\\0';\n\n    find_completion(cmdline);\n\n    qemu_free(cmdline);\n\n\n\n    /* no completion found */\n\n    if (nb_completions <= 0)\n\n        return;\n\n    if (nb_completions == 1) {\n\n        len = strlen(completions[0]);\n\n        for(i = completion_index; i < len; i++) {\n\n            term_insert_char(completions[0][i]);\n\n        }\n\n        /* extra space for next argument. XXX: make it more generic */\n\n        if (len > 0 && completions[0][len - 1] != '/')\n\n            term_insert_char(' ');\n\n    } else {\n\n        term_printf(\"\\n\");\n\n        max_width = 0;\n\n        for(i = 0; i < nb_completions; i++) {\n\n            len = strlen(completions[i]);\n\n            if (len > max_width)\n\n                max_width = len;\n\n        }\n\n        max_width += 2;\n\n        if (max_width < 10)\n\n            max_width = 10;\n\n        else if (max_width > 80)\n\n            max_width = 80;\n\n        nb_cols = 80 / max_width;\n\n        j = 0;\n\n        for(i = 0; i < nb_completions; i++) {\n\n            term_printf(\"%-*s\", max_width, completions[i]);\n\n            if (++j == nb_cols || i == (nb_completions - 1)) {\n\n                term_printf(\"\\n\");\n\n                j = 0;\n\n            }\n\n        }\n\n        term_show_prompt2();\n\n    }\n\n}\n", "idx": 11270, "_split": "valid", "_hash": "a915ee1f32292b61548726a7a96d6d86"}
{"project": "qemu", "commit_id": "36bcac16fdd6ecb75314db06171f54dcd400ab8c", "target": 1, "func": "static int parse_vdiname(BDRVSheepdogState *s, const char *filename,\n\n                         char *vdi, uint32_t *snapid, char *tag)\n\n{\n\n    char *p, *q, *uri;\n\n    const char *host_spec, *vdi_spec;\n\n    int nr_sep, ret;\n\n\n\n    strstart(filename, \"sheepdog:\", &filename);\n\n    p = q = g_strdup(filename);\n\n\n\n    /* count the number of separators */\n\n    nr_sep = 0;\n\n    while (*p) {\n\n        if (*p == ':') {\n\n            nr_sep++;\n\n        }\n\n        p++;\n\n    }\n\n    p = q;\n\n\n\n    /* use the first two tokens as host_spec. */\n\n    if (nr_sep >= 2) {\n\n        host_spec = p;\n\n        p = strchr(p, ':');\n\n        p++;\n\n        p = strchr(p, ':');\n\n        *p++ = '\\0';\n\n    } else {\n\n        host_spec = \"\";\n\n    }\n\n\n\n    vdi_spec = p;\n\n\n\n    p = strchr(vdi_spec, ':');\n\n    if (p) {\n\n        *p++ = '#';\n\n    }\n\n\n\n    uri = g_strdup_printf(\"sheepdog://%s/%s\", host_spec, vdi_spec);\n\n\n\n    ret = sd_parse_uri(s, uri, vdi, snapid, tag);\n\n\n\n    g_free(q);\n\n    g_free(uri);\n\n\n\n    return ret;\n\n}\n", "idx": 11288, "_split": "valid", "_hash": "fdf7dea400761b49f94e675294f66e10"}
{"project": "qemu", "commit_id": "be1fea9bc286f64c6c995bb0d7145a0b738aeddb", "target": 0, "func": "static inline uint16_t vring_avail_idx(VirtQueue *vq)\n\n{\n\n    hwaddr pa;\n\n    pa = vq->vring.avail + offsetof(VRingAvail, idx);\n\n    return virtio_lduw_phys(vq->vdev, pa);\n\n}\n", "idx": 11309, "_split": "valid", "_hash": "d38c6f35369f5c9b950095c027dfb0ec"}
{"project": "qemu", "commit_id": "1ac157da77c863b62b1d2f467626a440d57cf17d", "target": 0, "func": "void cpu_x86_update_cr0(CPUX86State *env)\n\n{\n\n    int pg_state, pe_state;\n\n\n\n#if defined(DEBUG_MMU)\n\n    printf(\"CR0 update: CR0=0x%08x\\n\", env->cr[0]);\n\n#endif\n\n    pg_state = env->cr[0] & CR0_PG_MASK;\n\n    if (pg_state != last_pg_state) {\n\n        tlb_flush(env);\n\n        last_pg_state = pg_state;\n\n    }\n\n    /* update PE flag in hidden flags */\n\n    pe_state = (env->cr[0] & CR0_PE_MASK);\n\n    env->hflags = (env->hflags & ~HF_PE_MASK) | (pe_state << HF_PE_SHIFT);\n\n    /* ensure that ADDSEG is always set in real mode */\n\n    env->hflags |= ((pe_state ^ 1) << HF_ADDSEG_SHIFT);\n\n}\n", "idx": 11313, "_split": "valid", "_hash": "3ed1e7e2de70de0fc3b2e560961d0c9b"}
{"project": "qemu", "commit_id": "ad674e53b5cce265fadafbde2c6a4f190345cd00", "target": 0, "func": "static void branch(DBDMA_channel *ch)\n\n{\n\n    dbdma_cmd *current = &ch->current;\n\n\n\n    ch->regs[DBDMA_CMDPTR_LO] = current->cmd_dep;\n\n    ch->regs[DBDMA_STATUS] |= cpu_to_be32(BT);\n\n    dbdma_cmdptr_load(ch);\n\n}\n", "idx": 11314, "_split": "valid", "_hash": "39d022f8a908a682f2907941e52078b7"}
{"project": "qemu", "commit_id": "7d99f4c1b5d12de7644a5bd8c3d46bff05c9ca7c", "target": 1, "func": "static int scsi_get_configuration(SCSIDiskState *s, uint8_t *outbuf)\n\n{\n\n    int current;\n\n\n\n    if (s->qdev.type != TYPE_ROM) {\n\n        return -1;\n\n    }\n\n    current = media_is_dvd(s) ? MMC_PROFILE_DVD_ROM : MMC_PROFILE_CD_ROM;\n\n    memset(outbuf, 0, 40);\n\n    stl_be_p(&outbuf[0], 36); /* Bytes after the data length field */\n\n    stw_be_p(&outbuf[6], current);\n\n    /* outbuf[8] - outbuf[19]: Feature 0 - Profile list */\n\n    outbuf[10] = 0x03; /* persistent, current */\n\n    outbuf[11] = 8; /* two profiles */\n\n    stw_be_p(&outbuf[12], MMC_PROFILE_DVD_ROM);\n\n    outbuf[14] = (current == MMC_PROFILE_DVD_ROM);\n\n    stw_be_p(&outbuf[16], MMC_PROFILE_CD_ROM);\n\n    outbuf[18] = (current == MMC_PROFILE_CD_ROM);\n\n    /* outbuf[20] - outbuf[31]: Feature 1 - Core feature */\n\n    stw_be_p(&outbuf[20], 1);\n\n    outbuf[22] = 0x08 | 0x03; /* version 2, persistent, current */\n\n    outbuf[23] = 8;\n\n    stl_be_p(&outbuf[24], 1); /* SCSI */\n\n    outbuf[28] = 1; /* DBE = 1, mandatory */\n\n    /* outbuf[32] - outbuf[39]: Feature 3 - Removable media feature */\n\n    stw_be_p(&outbuf[32], 3);\n\n    outbuf[34] = 0x08 | 0x03; /* version 2, persistent, current */\n\n    outbuf[35] = 4;\n\n    outbuf[36] = 0x39; /* tray, load=1, eject=1, unlocked at powerup, lock=1 */\n\n    /* TODO: Random readable, CD read, DVD read, drive serial number,\n\n       power management */\n\n    return 40;\n\n}\n", "idx": 11343, "_split": "valid", "_hash": "fb36f2708cb5527bee7178ba275d567f"}
{"project": "qemu", "commit_id": "1ec3b71cde6997db866a76ff3311cb97c0b6741a", "target": 1, "func": "static void rx_stop_cont_test(const QVirtioBus *bus, QVirtioDevice *dev,\n\n                              QGuestAllocator *alloc, QVirtQueue *vq,\n\n                              int socket)\n\n{\n\n    uint64_t req_addr;\n\n    uint32_t free_head;\n\n    char test[] = \"TEST\";\n\n    char buffer[64];\n\n    int len = htonl(sizeof(test));\n\n    struct iovec iov[] = {\n\n        {\n\n            .iov_base = &len,\n\n            .iov_len = sizeof(len),\n\n        }, {\n\n            .iov_base = test,\n\n            .iov_len = sizeof(test),\n\n        },\n\n    };\n\n    int ret;\n\n\n\n    req_addr = guest_alloc(alloc, 64);\n\n\n\n    free_head = qvirtqueue_add(vq, req_addr, 64, true, false);\n\n    qvirtqueue_kick(bus, dev, vq, free_head);\n\n\n\n    qmp(\"{ 'execute' : 'stop'}\");\n\n\n\n    ret = iov_send(socket, iov, 2, 0, sizeof(len) + sizeof(test));\n\n    g_assert_cmpint(ret, ==, sizeof(test) + sizeof(len));\n\n\n\n    /* We could check the status, but this command is more importantly to\n\n     * ensure the packet data gets queued in QEMU, before we do 'cont'.\n\n     */\n\n    qmp(\"{ 'execute' : 'query-status'}\");\n\n    qmp(\"{ 'execute' : 'cont'}\");\n\n\n\n    qvirtio_wait_queue_isr(bus, dev, vq, QVIRTIO_NET_TIMEOUT_US);\n\n    memread(req_addr + VNET_HDR_SIZE, buffer, sizeof(test));\n\n    g_assert_cmpstr(buffer, ==, \"TEST\");\n\n\n\n    guest_free(alloc, req_addr);\n\n}\n", "idx": 11349, "_split": "valid", "_hash": "650331b68e6f3d843025df5182989e0e"}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void nbd_read(void *opaque)\n\n{\n\n    NBDClient *client = opaque;\n\n\n\n    if (client->recv_coroutine) {\n\n        qemu_coroutine_enter(client->recv_coroutine, NULL);\n\n    } else {\n\n        qemu_coroutine_enter(qemu_coroutine_create(nbd_trip), client);\n\n    }\n\n}\n", "idx": 11357, "_split": "valid", "_hash": "9c44ed9c00ce028c3ce86b566d6d7960"}
{"project": "qemu", "commit_id": "27463101f15bee17d2f46642c48a7373bc6c595e", "target": 1, "func": "int qemu_eventfd(int *fds)\n\n{\n\n#if defined(SYS_eventfd)\n\n    int ret;\n\n\n\n    ret = syscall(SYS_eventfd, 0);\n\n    if (ret >= 0) {\n\n        fds[0] = fds[1] = ret;\n\n        return 0;\n\n    } else if (!(ret == -1 && errno == ENOSYS))\n\n        return ret;\n\n#endif\n\n\n\n    return pipe(fds);\n\n}\n", "idx": 11373, "_split": "valid", "_hash": "980c4c972db7979b8fe741c10a22b860"}
{"project": "qemu", "commit_id": "ce7f7cc2715145eadf1ac45a5dae63f535fc8bbf", "target": 1, "func": "int64_t ga_get_fd_handle(GAState *s, Error **errp)\n\n{\n\n    int64_t handle;\n\n\n\n    g_assert(s->pstate_filepath);\n\n    /* we blacklist commands and avoid operations that potentially require\n\n     * writing to disk when we're in a frozen state. this includes opening\n\n     * new files, so we should never get here in that situation\n\n     */\n\n    g_assert(!ga_is_frozen(s));\n\n\n\n    handle = s->pstate.fd_counter++;\n\n    if (s->pstate.fd_counter < 0) {\n\n        s->pstate.fd_counter = 0;\n\n    }\n\n    if (!write_persistent_state(&s->pstate, s->pstate_filepath)) {\n\n        error_setg(errp, \"failed to commit persistent state to disk\");\n\n    }\n\n\n\n    return handle;\n\n}\n", "idx": 11384, "_split": "valid", "_hash": "cef0c7ed46ffb560bf60e437445344c6"}
{"project": "qemu", "commit_id": "7f6613cedc59fa849105668ae971dc31004bca1c", "target": 0, "func": "static void gen_load_fpr32h(TCGv_i32 t, int reg)\n\n{\n\n    TCGv_i64 t64 = tcg_temp_new_i64();\n\n    tcg_gen_shri_i64(t64, fpu_f64[reg], 32);\n\n    tcg_gen_trunc_i64_i32(t, t64);\n\n    tcg_temp_free_i64(t64);\n\n}\n", "idx": 11402, "_split": "valid", "_hash": "e5643bbb9c552a57c5a6830e65775372"}
{"project": "qemu", "commit_id": "3718d8ab65f68de2acccbe6a315907805f54e3cc", "target": 0, "func": "void block_job_completed(BlockJob *job, int ret)\n\n{\n\n    BlockDriverState *bs = job->bs;\n\n\n\n    assert(bs->job == job);\n\n    job->cb(job->opaque, ret);\n\n    bs->job = NULL;\n\n    g_free(job);\n\n    bdrv_set_in_use(bs, 0);\n\n}\n", "idx": 11414, "_split": "valid", "_hash": "216476d06c4a2952444010605a4c3a26"}
{"project": "qemu", "commit_id": "b4176cb314995ad225d6c2b531568801feb04f3f", "target": 1, "func": "static int nbd_parse_offset_hole_payload(NBDStructuredReplyChunk *chunk,\n\n                                         uint8_t *payload, uint64_t orig_offset,\n\n                                         QEMUIOVector *qiov, Error **errp)\n\n{\n\n    uint64_t offset;\n\n    uint32_t hole_size;\n\n\n\n    if (chunk->length != sizeof(offset) + sizeof(hole_size)) {\n\n        error_setg(errp, \"Protocol error: invalid payload for \"\n\n                         \"NBD_REPLY_TYPE_OFFSET_HOLE\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    offset = payload_advance64(&payload);\n\n    hole_size = payload_advance32(&payload);\n\n\n\n    if (offset < orig_offset || hole_size > qiov->size ||\n\n        offset > orig_offset + qiov->size - hole_size) {\n\n        error_setg(errp, \"Protocol error: server sent chunk exceeding requested\"\n\n                         \" region\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    qemu_iovec_memset(qiov, offset - orig_offset, 0, hole_size);\n\n\n\n    return 0;\n\n}\n", "idx": 11457, "_split": "valid", "_hash": "1301b9d69578887b3c5717ab9388126b"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int qemu_rdma_post_send_control(RDMAContext *rdma, uint8_t *buf,\n\n                                       RDMAControlHeader *head)\n\n{\n\n    int ret = 0;\n\n    RDMAWorkRequestData *wr = &rdma->wr_data[RDMA_WRID_CONTROL];\n\n    struct ibv_send_wr *bad_wr;\n\n    struct ibv_sge sge = {\n\n                           .addr = (uint64_t)(wr->control),\n\n                           .length = head->len + sizeof(RDMAControlHeader),\n\n                           .lkey = wr->control_mr->lkey,\n\n                         };\n\n    struct ibv_send_wr send_wr = {\n\n                                   .wr_id = RDMA_WRID_SEND_CONTROL,\n\n                                   .opcode = IBV_WR_SEND,\n\n                                   .send_flags = IBV_SEND_SIGNALED,\n\n                                   .sg_list = &sge,\n\n                                   .num_sge = 1,\n\n                                };\n\n\n\n    DDDPRINTF(\"CONTROL: sending %s..\\n\", control_desc[head->type]);\n\n\n\n    /*\n\n     * We don't actually need to do a memcpy() in here if we used\n\n     * the \"sge\" properly, but since we're only sending control messages\n\n     * (not RAM in a performance-critical path), then its OK for now.\n\n     *\n\n     * The copy makes the RDMAControlHeader simpler to manipulate\n\n     * for the time being.\n\n     */\n\n    assert(head->len <= RDMA_CONTROL_MAX_BUFFER - sizeof(*head));\n\n    memcpy(wr->control, head, sizeof(RDMAControlHeader));\n\n    control_to_network((void *) wr->control);\n\n\n\n    if (buf) {\n\n        memcpy(wr->control + sizeof(RDMAControlHeader), buf, head->len);\n\n    }\n\n\n\n\n\n    ret = ibv_post_send(rdma->qp, &send_wr, &bad_wr);\n\n\n\n    if (ret > 0) {\n\n        fprintf(stderr, \"Failed to use post IB SEND for control!\\n\");\n\n        return -ret;\n\n    }\n\n\n\n    ret = qemu_rdma_block_for_wrid(rdma, RDMA_WRID_SEND_CONTROL, NULL);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"rdma migration: send polling control error!\\n\");\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 11497, "_split": "valid", "_hash": "d2783436223d71b8d38a76751b5afe2a"}
{"project": "qemu", "commit_id": "1108b2f8a939fb5778d384149e2f1b99062a72da", "target": 1, "func": "static void pci_ich9_ahci_realize(PCIDevice *dev, Error **errp)\n\n{\n\n    struct AHCIPCIState *d;\n\n    int sata_cap_offset;\n\n    uint8_t *sata_cap;\n\n    d = ICH_AHCI(dev);\n\n\n\n    ahci_realize(&d->ahci, DEVICE(dev), pci_get_address_space(dev), 6);\n\n\n\n    pci_config_set_prog_interface(dev->config, AHCI_PROGMODE_MAJOR_REV_1);\n\n\n\n    dev->config[PCI_CACHE_LINE_SIZE] = 0x08;  /* Cache line size */\n\n    dev->config[PCI_LATENCY_TIMER]   = 0x00;  /* Latency timer */\n\n    pci_config_set_interrupt_pin(dev->config, 1);\n\n\n\n    /* XXX Software should program this register */\n\n    dev->config[0x90]   = 1 << 6; /* Address Map Register - AHCI mode */\n\n\n\n    d->ahci.irq = pci_allocate_irq(dev);\n\n\n\n    pci_register_bar(dev, ICH9_IDP_BAR, PCI_BASE_ADDRESS_SPACE_IO,\n\n                     &d->ahci.idp);\n\n    pci_register_bar(dev, ICH9_MEM_BAR, PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                     &d->ahci.mem);\n\n\n\n    sata_cap_offset = pci_add_capability2(dev, PCI_CAP_ID_SATA,\n\n                                          ICH9_SATA_CAP_OFFSET, SATA_CAP_SIZE,\n\n                                          errp);\n\n    if (sata_cap_offset < 0) {\n\n        return;\n\n    }\n\n\n\n    sata_cap = dev->config + sata_cap_offset;\n\n    pci_set_word(sata_cap + SATA_CAP_REV, 0x10);\n\n    pci_set_long(sata_cap + SATA_CAP_BAR,\n\n                 (ICH9_IDP_BAR + 0x4) | (ICH9_IDP_INDEX_LOG2 << 4));\n\n    d->ahci.idp_offset = ICH9_IDP_INDEX;\n\n\n\n    /* Although the AHCI 1.3 specification states that the first capability\n\n     * should be PMCAP, the Intel ICH9 data sheet specifies that the ICH9\n\n     * AHCI device puts the MSI capability first, pointing to 0x80. */\n\n    msi_init(dev, ICH9_MSI_CAP_OFFSET, 1, true, false);\n\n}\n", "idx": 11498, "_split": "valid", "_hash": "85e53defedc041e4bc20ec63b633149d"}
{"project": "qemu", "commit_id": "dcc70cdf0932172fc5cf27617a3b033ca58d0176", "target": 1, "func": "static void parse_cmdline(const char *cmdline,\n\n                          int *pnb_args, char **args)\n\n{\n\n    const char *p;\n\n    int nb_args, ret;\n\n    char buf[1024];\n\n\n\n    p = cmdline;\n\n    nb_args = 0;\n\n    for (;;) {\n\n        while (qemu_isspace(*p)) {\n\n            p++;\n\n        }\n\n        if (*p == '\\0') {\n\n            break;\n\n        }\n\n        if (nb_args >= MAX_ARGS) {\n\n            break;\n\n        }\n\n        ret = get_str(buf, sizeof(buf), &p);\n\n        args[nb_args] = g_strdup(buf);\n\n        nb_args++;\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n    }\n\n    *pnb_args = nb_args;\n\n}\n", "idx": 11504, "_split": "valid", "_hash": "690e2121e15d9d67f93c1163e4176c8e"}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "static void mpc8544ds_init(ram_addr_t ram_size,\n\n                         const char *boot_device,\n\n                         const char *kernel_filename,\n\n                         const char *kernel_cmdline,\n\n                         const char *initrd_filename,\n\n                         const char *cpu_model)\n\n{\n\n    PCIBus *pci_bus;\n\n    CPUState *env;\n\n    uint64_t elf_entry;\n\n    uint64_t elf_lowaddr;\n\n    target_phys_addr_t entry=0;\n\n    target_phys_addr_t loadaddr=UIMAGE_LOAD_BASE;\n\n    target_long kernel_size=0;\n\n    target_ulong dt_base=DTB_LOAD_BASE;\n\n    target_ulong initrd_base=INITRD_LOAD_BASE;\n\n    target_long initrd_size=0;\n\n    void *fdt;\n\n    int i=0;\n\n    unsigned int pci_irq_nrs[4] = {1, 2, 3, 4};\n\n    qemu_irq *irqs, *mpic, *pci_irqs;\n\n    SerialState * serial[2];\n\n\n\n    /* Setup CPU */\n\n    env = cpu_ppc_init(\"e500v2_v30\");\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Fixup Memory size on a alignment boundary */\n\n    ram_size &= ~(RAM_SIZES_ALIGN - 1);\n\n\n\n    /* Register Memory */\n\n    cpu_register_physical_memory(0, ram_size, qemu_ram_alloc(ram_size));\n\n\n\n    /* MPIC */\n\n    irqs = qemu_mallocz(sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);\n\n    irqs[OPENPIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPCE500_INPUT_INT];\n\n    irqs[OPENPIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPCE500_INPUT_CINT];\n\n    mpic = mpic_init(MPC8544_MPIC_REGS_BASE, 1, &irqs, NULL);\n\n\n\n    /* Serial */\n\n    if (serial_hds[0])\n\n        serial[0] = serial_mm_init(MPC8544_SERIAL0_REGS_BASE,\n\n                               0, mpic[12+26], 399193,\n\n                        serial_hds[0], 1);\n\n\n\n    if (serial_hds[1])\n\n        serial[0] = serial_mm_init(MPC8544_SERIAL1_REGS_BASE,\n\n                        0, mpic[12+26], 399193,\n\n                        serial_hds[0], 1);\n\n\n\n    /* PCI */\n\n    pci_irqs = qemu_malloc(sizeof(qemu_irq) * 4);\n\n    pci_irqs[0] = mpic[pci_irq_nrs[0]];\n\n    pci_irqs[1] = mpic[pci_irq_nrs[1]];\n\n    pci_irqs[2] = mpic[pci_irq_nrs[2]];\n\n    pci_irqs[3] = mpic[pci_irq_nrs[3]];\n\n    pci_bus = ppce500_pci_init(pci_irqs, MPC8544_PCI_REGS_BASE);\n\n    if (!pci_bus)\n\n        printf(\"couldn't create PCI controller!\\n\");\n\n\n\n    isa_mmio_init(MPC8544_PCI_IO, MPC8544_PCI_IOLEN);\n\n\n\n    if (pci_bus) {\n\n        /* Register network interfaces. */\n\n        for (i = 0; i < nb_nics; i++) {\n\n            pci_nic_init(&nd_table[i], \"virtio\", NULL);\n\n        }\n\n    }\n\n\n\n    /* Load kernel. */\n\n    if (kernel_filename) {\n\n        kernel_size = load_uimage(kernel_filename, &entry, &loadaddr, NULL);\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_elf(kernel_filename, 0, &elf_entry, &elf_lowaddr,\n\n                                   NULL, 1, ELF_MACHINE, 0);\n\n            entry = elf_entry;\n\n            loadaddr = elf_lowaddr;\n\n        }\n\n        /* XXX try again as binary */\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Load initrd. */\n\n    if (initrd_filename) {\n\n        initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                          ram_size - initrd_base);\n\n\n\n        if (initrd_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    initrd_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* If we're loading a kernel directly, we must load the device tree too. */\n\n    if (kernel_filename) {\n\n        fdt = mpc8544_load_device_tree(dt_base, ram_size,\n\n                                      initrd_base, initrd_size, kernel_cmdline);\n\n        if (fdt == NULL) {\n\n            fprintf(stderr, \"couldn't load device tree\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        /* Set initial guest state. */\n\n        env->gpr[1] = (16<<20) - 8;\n\n        env->gpr[3] = dt_base;\n\n        env->nip = entry;\n\n        /* XXX we currently depend on KVM to create some initial TLB entries. */\n\n    }\n\n\n\n    if (kvm_enabled())\n\n        kvmppc_init();\n\n\n\n    return;\n\n}\n", "idx": 11517, "_split": "valid", "_hash": "f8c4255122897296794c81f0caaf241b"}
{"project": "qemu", "commit_id": "94ef4f337fb614f18b765a8e0e878a4c23cdedcd", "target": 1, "func": "static void vga_update_memory_access(VGACommonState *s)\n\n{\n\n    hwaddr base, offset, size;\n\n\n\n    if (s->legacy_address_space == NULL) {\n\n        return;\n\n    }\n\n\n\n    if (s->has_chain4_alias) {\n\n        memory_region_del_subregion(s->legacy_address_space, &s->chain4_alias);\n\n        object_unparent(OBJECT(&s->chain4_alias));\n\n        s->has_chain4_alias = false;\n\n        s->plane_updated = 0xf;\n\n    }\n\n    if ((s->sr[VGA_SEQ_PLANE_WRITE] & VGA_SR02_ALL_PLANES) ==\n\n        VGA_SR02_ALL_PLANES && s->sr[VGA_SEQ_MEMORY_MODE] & VGA_SR04_CHN_4M) {\n\n        offset = 0;\n\n        switch ((s->gr[VGA_GFX_MISC] >> 2) & 3) {\n\n        case 0:\n\n            base = 0xa0000;\n\n            size = 0x20000;\n\n            break;\n\n        case 1:\n\n            base = 0xa0000;\n\n            size = 0x10000;\n\n            offset = s->bank_offset;\n\n            break;\n\n        case 2:\n\n            base = 0xb0000;\n\n            size = 0x8000;\n\n            break;\n\n        case 3:\n\n        default:\n\n            base = 0xb8000;\n\n            size = 0x8000;\n\n            break;\n\n        }\n\n        assert(offset + size <= s->vram_size);\n\n        memory_region_init_alias(&s->chain4_alias, memory_region_owner(&s->vram),\n\n                                 \"vga.chain4\", &s->vram, offset, size);\n\n        memory_region_add_subregion_overlap(s->legacy_address_space, base,\n\n                                            &s->chain4_alias, 2);\n\n        s->has_chain4_alias = true;\n\n    }\n\n}\n", "idx": 11549, "_split": "valid", "_hash": "a95dd25a36bd566946b012647153c9d1"}
{"project": "qemu", "commit_id": "2436b61a6b386d712a1813b036921443bd1c5c39", "target": 0, "func": "void helper_sysexit(void)\n\n{\n\n    int cpl;\n\n\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    if (env->sysenter_cs == 0 || cpl != 0) {\n\n        raise_exception_err(EXCP0D_GPF, 0);\n\n    }\n\n    cpu_x86_set_cpl(env, 3);\n\n    cpu_x86_load_seg_cache(env, R_CS, ((env->sysenter_cs + 16) & 0xfffc) | 3,\n\n                           0, 0xffffffff,\n\n                           DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                           DESC_S_MASK | (3 << DESC_DPL_SHIFT) |\n\n                           DESC_CS_MASK | DESC_R_MASK | DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_SS, ((env->sysenter_cs + 24) & 0xfffc) | 3,\n\n                           0, 0xffffffff,\n\n                           DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                           DESC_S_MASK | (3 << DESC_DPL_SHIFT) |\n\n                           DESC_W_MASK | DESC_A_MASK);\n\n    ESP = ECX;\n\n    EIP = EDX;\n\n#ifdef USE_KQEMU\n\n    if (kqemu_is_ok(env)) {\n\n        env->exception_index = -1;\n\n        cpu_loop_exit();\n\n    }\n\n#endif\n\n}\n", "idx": 11595, "_split": "valid", "_hash": "970fefedc1bb79d4b1bfe1a8a567756a"}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_efsnabs(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);\n\n}\n", "idx": 11597, "_split": "valid", "_hash": "f3221006aba85c421de59784431d4ec9"}
{"project": "qemu", "commit_id": "f95d7cc7fecbc0e320e83c864ce2d99fee3d9236", "target": 0, "func": "static int pte64_check(struct mmu_ctx_hash64 *ctx, target_ulong pte0,\n\n                       target_ulong pte1, int h, int rwx)\n\n{\n\n    target_ulong mmask;\n\n    int access, ret, pp;\n\n\n\n    ret = -1;\n\n    /* Check validity and table match */\n\n    if ((pte0 & HPTE64_V_VALID) && (h == !!(pte0 & HPTE64_V_SECONDARY))) {\n\n        bool nx;\n\n\n\n        /* Check vsid & api */\n\n        mmask = PTE64_CHECK_MASK;\n\n        pp = (pte1 & HPTE64_R_PP) | ((pte1 & HPTE64_R_PP0) >> 61);\n\n        /* No execute if either noexec or guarded bits set */\n\n        nx = (pte1 & HPTE64_R_N) || (pte1 & HPTE64_R_G);\n\n        if (HPTE64_V_COMPARE(pte0, ctx->ptem)) {\n\n            if (ctx->raddr != (hwaddr)-1ULL) {\n\n                /* all matches should have equal RPN, WIMG & PP */\n\n                if ((ctx->raddr & mmask) != (pte1 & mmask)) {\n\n                    qemu_log(\"Bad RPN/WIMG/PP\\n\");\n\n                    return -3;\n\n                }\n\n            }\n\n            /* Compute access rights */\n\n            access = ppc_hash64_pp_check(ctx->key, pp, nx);\n\n            /* Keep the matching PTE informations */\n\n            ctx->raddr = pte1;\n\n            ctx->prot = access;\n\n            ret = ppc_hash64_check_prot(ctx->prot, rwx);\n\n            if (ret == 0) {\n\n                /* Access granted */\n\n                LOG_MMU(\"PTE access granted !\\n\");\n\n            } else {\n\n                /* Access right violation */\n\n                LOG_MMU(\"PTE access rejected\\n\");\n\n            }\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 11611, "_split": "valid", "_hash": "92475590e9935ace745fe0fee3068216"}
{"project": "qemu", "commit_id": "552908fef5b67ad9d96b76d7cb8371ebc26c9bc8", "target": 0, "func": "static uint64_t bmdma_addr_read(void *opaque, target_phys_addr_t addr,\n\n                                unsigned width)\n\n{\n\n    BMDMAState *bm = opaque;\n\n    uint32_t mask = (1ULL << (width * 8)) - 1;\n\n    uint64_t data;\n\n\n\n    data = (bm->addr >> (addr * 8)) & mask;\n\n#ifdef DEBUG_IDE\n\n    printf(\"%s: 0x%08x\\n\", __func__, (unsigned)*data);\n\n#endif\n\n    return data;\n\n}\n", "idx": 11612, "_split": "valid", "_hash": "15956f883565f695315753fca3e17a24"}
{"project": "qemu", "commit_id": "8b7968f7c4ac8c07cad6a1a0891d38cf239a2839", "target": 0, "func": "static void qerror_abort(const QError *qerr, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n\n\n    fprintf(stderr, \"qerror: bad call in function '%s':\\n\", qerr->func);\n\n    fprintf(stderr, \"qerror: -> \");\n\n\n\n    va_start(ap, fmt);\n\n    vfprintf(stderr, fmt, ap);\n\n    va_end(ap);\n\n\n\n    fprintf(stderr, \"\\nqerror: call at %s:%d\\n\", qerr->file, qerr->linenr);\n\n    abort();\n\n}\n", "idx": 11613, "_split": "valid", "_hash": "788671a727900afce9d5c20a22253b1b"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_nabs(DisasContext *ctx)\n\n{\n\n    int l1 = gen_new_label();\n\n    int l2 = gen_new_label();\n\n    tcg_gen_brcondi_tl(TCG_COND_GT, cpu_gpr[rA(ctx->opcode)], 0, l1);\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_neg_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    gen_set_label(l2);\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rD(ctx->opcode)]);\n\n}\n", "idx": 11616, "_split": "valid", "_hash": "db6ef70b366aae853780ce70ed76d789"}
{"project": "qemu", "commit_id": "d66b969b0d9c8eefdcbff4b48535b0fe1501d139", "target": 0, "func": "static void vtd_iotlb_page_invalidate(IntelIOMMUState *s, uint16_t domain_id,\n\n                                      hwaddr addr, uint8_t am)\n\n{\n\n    VTDIOTLBPageInvInfo info;\n\n\n\n    assert(am <= VTD_MAMV);\n\n    info.domain_id = domain_id;\n\n    info.gfn = addr >> VTD_PAGE_SHIFT_4K;\n\n    info.mask = ~((1 << am) - 1);\n\n    g_hash_table_foreach_remove(s->iotlb, vtd_hash_remove_by_page, &info);\n\n}\n", "idx": 11628, "_split": "valid", "_hash": "515f593eadd133661441e230d911323f"}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "static void sh_serial_write(void *opaque, hwaddr offs,\n\n                            uint64_t val, unsigned size)\n\n{\n\n    sh_serial_state *s = opaque;\n\n    unsigned char ch;\n\n\n\n#ifdef DEBUG_SERIAL\n\n    printf(\"sh_serial: write offs=0x%02x val=0x%02x\\n\",\n\n\t   offs, val);\n\n#endif\n\n    switch(offs) {\n\n    case 0x00: /* SMR */\n\n        s->smr = val & ((s->feat & SH_SERIAL_FEAT_SCIF) ? 0x7b : 0xff);\n\n        return;\n\n    case 0x04: /* BRR */\n\n        s->brr = val;\n\n\treturn;\n\n    case 0x08: /* SCR */\n\n        /* TODO : For SH7751, SCIF mask should be 0xfb. */\n\n        s->scr = val & ((s->feat & SH_SERIAL_FEAT_SCIF) ? 0xfa : 0xff);\n\n        if (!(val & (1 << 5)))\n\n            s->flags |= SH_SERIAL_FLAG_TEND;\n\n        if ((s->feat & SH_SERIAL_FEAT_SCIF) && s->txi) {\n\n\t    qemu_set_irq(s->txi, val & (1 << 7));\n\n        }\n\n        if (!(val & (1 << 6))) {\n\n\t    qemu_set_irq(s->rxi, 0);\n\n        }\n\n        return;\n\n    case 0x0c: /* FTDR / TDR */\n\n        if (s->chr) {\n\n            ch = val;\n\n            qemu_chr_fe_write(s->chr, &ch, 1);\n\n\t}\n\n\ts->dr = val;\n\n\ts->flags &= ~SH_SERIAL_FLAG_TDE;\n\n        return;\n\n#if 0\n\n    case 0x14: /* FRDR / RDR */\n\n        ret = 0;\n\n        break;\n\n#endif\n\n    }\n\n    if (s->feat & SH_SERIAL_FEAT_SCIF) {\n\n        switch(offs) {\n\n        case 0x10: /* FSR */\n\n            if (!(val & (1 << 6)))\n\n                s->flags &= ~SH_SERIAL_FLAG_TEND;\n\n            if (!(val & (1 << 5)))\n\n                s->flags &= ~SH_SERIAL_FLAG_TDE;\n\n            if (!(val & (1 << 4)))\n\n                s->flags &= ~SH_SERIAL_FLAG_BRK;\n\n            if (!(val & (1 << 1)))\n\n                s->flags &= ~SH_SERIAL_FLAG_RDF;\n\n            if (!(val & (1 << 0)))\n\n                s->flags &= ~SH_SERIAL_FLAG_DR;\n\n\n\n            if (!(val & (1 << 1)) || !(val & (1 << 0))) {\n\n                if (s->rxi) {\n\n                    qemu_set_irq(s->rxi, 0);\n\n                }\n\n            }\n\n            return;\n\n        case 0x18: /* FCR */\n\n            s->fcr = val;\n\n            switch ((val >> 6) & 3) {\n\n            case 0:\n\n                s->rtrg = 1;\n\n                break;\n\n            case 1:\n\n                s->rtrg = 4;\n\n                break;\n\n            case 2:\n\n                s->rtrg = 8;\n\n                break;\n\n            case 3:\n\n                s->rtrg = 14;\n\n                break;\n\n            }\n\n            if (val & (1 << 1)) {\n\n                sh_serial_clear_fifo(s);\n\n                s->sr &= ~(1 << 1);\n\n            }\n\n\n\n            return;\n\n        case 0x20: /* SPTR */\n\n            s->sptr = val & 0xf3;\n\n            return;\n\n        case 0x24: /* LSR */\n\n            return;\n\n        }\n\n    }\n\n    else {\n\n        switch(offs) {\n\n#if 0\n\n        case 0x0c:\n\n            ret = s->dr;\n\n            break;\n\n        case 0x10:\n\n            ret = 0;\n\n            break;\n\n#endif\n\n        case 0x1c:\n\n            s->sptr = val & 0x8f;\n\n            return;\n\n        }\n\n    }\n\n\n\n    fprintf(stderr, \"sh_serial: unsupported write to 0x%02\"\n\n            HWADDR_PRIx \"\\n\", offs);\n\n    abort();\n\n}\n", "idx": 11657, "_split": "valid", "_hash": "2e33ca2e32cd6110b2ac93e68224702b"}
{"project": "qemu", "commit_id": "568c73a4783cd981e9aa6de4f15dcda7829643ad", "target": 0, "func": "void qmp_x_input_send_event(bool has_console, int64_t console,\n\n                            InputEventList *events, Error **errp)\n\n{\n\n    InputEventList *e;\n\n    QemuConsole *con;\n\n\n\n    con = NULL;\n\n    if (has_console) {\n\n        con = qemu_console_lookup_by_index(console);\n\n        if (!con) {\n\n            error_setg(errp, \"console %\" PRId64 \" not found\", console);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (!runstate_is_running() && !runstate_check(RUN_STATE_SUSPENDED)) {\n\n        error_setg(errp, \"VM not running\");\n\n        return;\n\n    }\n\n\n\n    for (e = events; e != NULL; e = e->next) {\n\n        InputEvent *event = e->value;\n\n\n\n        if (!qemu_input_find_handler(1 << event->kind, con)) {\n\n            error_setg(errp, \"Input handler not found for \"\n\n                             \"event type %s\",\n\n                            InputEventKind_lookup[event->kind]);\n\n            return;\n\n        }\n\n    }\n\n\n\n    for (e = events; e != NULL; e = e->next) {\n\n        InputEvent *event = e->value;\n\n\n\n        qemu_input_event_send(con, event);\n\n    }\n\n\n\n    qemu_input_event_sync();\n\n}\n", "idx": 11683, "_split": "valid", "_hash": "53b98e757fe9f9d822544f5f76e124a9"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int scsi_event_status_media(SCSIDiskState *s, uint8_t *outbuf)\n\n{\n\n    uint8_t event_code, media_status;\n\n\n\n    media_status = 0;\n\n    if (s->tray_open) {\n\n        media_status = MS_TRAY_OPEN;\n\n    } else if (bdrv_is_inserted(s->qdev.conf.bs)) {\n\n        media_status = MS_MEDIA_PRESENT;\n\n    }\n\n\n\n    /* Event notification descriptor */\n\n    event_code = MEC_NO_CHANGE;\n\n    if (media_status != MS_TRAY_OPEN) {\n\n        if (s->media_event) {\n\n            event_code = MEC_NEW_MEDIA;\n\n            s->media_event = false;\n\n        } else if (s->eject_request) {\n\n            event_code = MEC_EJECT_REQUESTED;\n\n            s->eject_request = false;\n\n        }\n\n    }\n\n\n\n    outbuf[0] = event_code;\n\n    outbuf[1] = media_status;\n\n\n\n    /* These fields are reserved, just clear them. */\n\n    outbuf[2] = 0;\n\n    outbuf[3] = 0;\n\n    return 4;\n\n}\n", "idx": 11687, "_split": "valid", "_hash": "2768df090f02fc2bc1d5b340db4edca7"}
{"project": "qemu", "commit_id": "2c0ef9f411ae6081efa9eca5b3eab2dbeee45a6c", "target": 0, "func": "void qapi_dealloc_visitor_cleanup(QapiDeallocVisitor *v)\n\n{\n\n    g_free(v);\n\n}\n", "idx": 11691, "_split": "valid", "_hash": "b14e94c52d5ff6cb40d5110f7496a3b6"}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "static void imx25_pdk_init(MachineState *machine)\n\n{\n\n    IMX25PDK *s = g_new0(IMX25PDK, 1);\n\n    unsigned int ram_size;\n\n    unsigned int alias_offset;\n\n    int i;\n\n\n\n    object_initialize(&s->soc, sizeof(s->soc), TYPE_FSL_IMX25);\n\n    object_property_add_child(OBJECT(machine), \"soc\", OBJECT(&s->soc),\n\n                              &error_abort);\n\n\n\n    object_property_set_bool(OBJECT(&s->soc), true, \"realized\", &error_fatal);\n\n\n\n    /* We need to initialize our memory */\n\n    if (machine->ram_size > (FSL_IMX25_SDRAM0_SIZE + FSL_IMX25_SDRAM1_SIZE)) {\n\n        error_report(\"WARNING: RAM size \" RAM_ADDR_FMT \" above max supported, \"\n\n                     \"reduced to %x\", machine->ram_size,\n\n                     FSL_IMX25_SDRAM0_SIZE + FSL_IMX25_SDRAM1_SIZE);\n\n        machine->ram_size = FSL_IMX25_SDRAM0_SIZE + FSL_IMX25_SDRAM1_SIZE;\n\n    }\n\n\n\n    memory_region_allocate_system_memory(&s->ram, NULL, \"imx25.ram\",\n\n                                         machine->ram_size);\n\n    memory_region_add_subregion(get_system_memory(), FSL_IMX25_SDRAM0_ADDR,\n\n                                &s->ram);\n\n\n\n    /* initialize the alias memory if any */\n\n    for (i = 0, ram_size = machine->ram_size, alias_offset = 0;\n\n         (i < 2) && ram_size; i++) {\n\n        unsigned int size;\n\n        static const struct {\n\n            hwaddr addr;\n\n            unsigned int size;\n\n        } ram[2] = {\n\n            { FSL_IMX25_SDRAM0_ADDR, FSL_IMX25_SDRAM0_SIZE },\n\n            { FSL_IMX25_SDRAM1_ADDR, FSL_IMX25_SDRAM1_SIZE },\n\n        };\n\n\n\n        size = MIN(ram_size, ram[i].size);\n\n\n\n        ram_size -= size;\n\n\n\n        if (size < ram[i].size) {\n\n            memory_region_init_alias(&s->ram_alias, NULL, \"ram.alias\",\n\n                                     &s->ram, alias_offset, ram[i].size - size);\n\n            memory_region_add_subregion(get_system_memory(),\n\n                                        ram[i].addr + size, &s->ram_alias);\n\n        }\n\n\n\n        alias_offset += ram[i].size;\n\n    }\n\n\n\n    imx25_pdk_binfo.ram_size = machine->ram_size;\n\n    imx25_pdk_binfo.kernel_filename = machine->kernel_filename;\n\n    imx25_pdk_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    imx25_pdk_binfo.initrd_filename = machine->initrd_filename;\n\n    imx25_pdk_binfo.loader_start = FSL_IMX25_SDRAM0_ADDR;\n\n    imx25_pdk_binfo.board_id = 1771,\n\n    imx25_pdk_binfo.nb_cpus = 1;\n\n\n\n    /*\n\n     * We test explicitly for qtest here as it is not done (yet?) in\n\n     * arm_load_kernel(). Without this the \"make check\" command would\n\n     * fail.\n\n     */\n\n    if (!qtest_enabled()) {\n\n        arm_load_kernel(&s->soc.cpu, &imx25_pdk_binfo);\n\n    } else {\n\n        /*\n\n         * This I2C device doesn't exist on the real board.\n\n         * We add it here (only on qtest usage) to be able to do a bit\n\n         * of simple qtest. See \"make check\" for details.\n\n         */\n\n        i2c_create_slave((I2CBus *)qdev_get_child_bus(DEVICE(&s->soc.i2c[0]),\n\n                                                      \"i2c-bus.0\"),\n\n                         \"ds1338\", 0x68);\n\n    }\n\n}\n", "idx": 11692, "_split": "valid", "_hash": "050513d91f521672b79ad63e4418c1ba"}
{"project": "qemu", "commit_id": "ecce1929bcb0d8f4efde39df5ceb1aac42df75d4", "target": 0, "func": "static void gd_ungrab_pointer(GtkDisplayState *s)\n\n{\n\n#if GTK_CHECK_VERSION(3, 0, 0)\n\n    GdkDisplay *display = gtk_widget_get_display(s->drawing_area);\n\n    GdkDeviceManager *mgr = gdk_display_get_device_manager(display);\n\n    GList *devices = gdk_device_manager_list_devices(mgr,\n\n                                                     GDK_DEVICE_TYPE_MASTER);\n\n    GList *tmp = devices;\n\n    while (tmp) {\n\n        GdkDevice *dev = tmp->data;\n\n        if (gdk_device_get_source(dev) == GDK_SOURCE_MOUSE) {\n\n            gdk_device_ungrab(dev,\n\n                              GDK_CURRENT_TIME);\n\n        }\n\n        tmp = tmp->next;\n\n    }\n\n    g_list_free(devices);\n\n#else\n\n    gdk_pointer_ungrab(GDK_CURRENT_TIME);\n\n#endif\n\n}\n", "idx": 11693, "_split": "valid", "_hash": "06cc37f461e3498bce5bd386e8919ed6"}
{"project": "qemu", "commit_id": "adae837d40dea7100040136647e3de44898994df", "target": 1, "func": "void machine_register_compat_props(MachineState *machine)\n\n{\n\n    MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n    int i;\n\n    GlobalProperty *p;\n\n\n\n    if (!mc->compat_props) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < mc->compat_props->len; i++) {\n\n        p = g_array_index(mc->compat_props, GlobalProperty *, i);\n\n\n\n        qdev_prop_register_global(p);\n\n    }\n\n}", "idx": 11696, "_split": "valid", "_hash": "5e73e6297ead501dcb2f0b25354ee85a"}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_addo (void)\n\n{\n\n    T2 = T0;\n\n    T0 += T1;\n\n    if (likely(!((T2 ^ T1 ^ (-1)) & (T2 ^ T0) & (1 << 31)))) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n    }\n\n}\n", "idx": 11731, "_split": "valid", "_hash": "a03d3f0f9f3e7cd1e8b782863ea43760"}
{"project": "qemu", "commit_id": "9bc9732faeff09828fe38c0ebe2401ee131a6fca", "target": 1, "func": "static void nbd_coroutine_start(NbdClientSession *s,\n\n   struct nbd_request *request)\n\n{\n\n    /* Poor man semaphore.  The free_sema is locked when no other request\n\n     * can be accepted, and unlocked after receiving one reply.  */\n\n    if (s->in_flight >= MAX_NBD_REQUESTS - 1) {\n\n        qemu_co_mutex_lock(&s->free_sema);\n\n        assert(s->in_flight < MAX_NBD_REQUESTS);\n\n    }\n\n    s->in_flight++;\n\n\n\n    /* s->recv_coroutine[i] is set as soon as we get the send_lock.  */\n\n}\n", "idx": 11732, "_split": "valid", "_hash": "c0f54bdd07c0bb446242b006660af5ae"}
{"project": "qemu", "commit_id": "f65ed4c1529f29a7d62d6733eaa50bed24a4b2ed", "target": 1, "func": "void vga_init(VGAState *s)\n\n{\n\n    int vga_io_memory;\n\n\n\n    register_savevm(\"vga\", 0, 2, vga_save, vga_load, s);\n\n\n\n    register_ioport_write(0x3c0, 16, 1, vga_ioport_write, s);\n\n\n\n    register_ioport_write(0x3b4, 2, 1, vga_ioport_write, s);\n\n    register_ioport_write(0x3d4, 2, 1, vga_ioport_write, s);\n\n    register_ioport_write(0x3ba, 1, 1, vga_ioport_write, s);\n\n    register_ioport_write(0x3da, 1, 1, vga_ioport_write, s);\n\n\n\n    register_ioport_read(0x3c0, 16, 1, vga_ioport_read, s);\n\n\n\n    register_ioport_read(0x3b4, 2, 1, vga_ioport_read, s);\n\n    register_ioport_read(0x3d4, 2, 1, vga_ioport_read, s);\n\n    register_ioport_read(0x3ba, 1, 1, vga_ioport_read, s);\n\n    register_ioport_read(0x3da, 1, 1, vga_ioport_read, s);\n\n    s->bank_offset = 0;\n\n\n\n#ifdef CONFIG_BOCHS_VBE\n\n    s->vbe_regs[VBE_DISPI_INDEX_ID] = VBE_DISPI_ID0;\n\n    s->vbe_bank_mask = ((s->vram_size >> 16) - 1);\n\n#if defined (TARGET_I386)\n\n    register_ioport_read(0x1ce, 1, 2, vbe_ioport_read_index, s);\n\n    register_ioport_read(0x1cf, 1, 2, vbe_ioport_read_data, s);\n\n\n\n    register_ioport_write(0x1ce, 1, 2, vbe_ioport_write_index, s);\n\n    register_ioport_write(0x1cf, 1, 2, vbe_ioport_write_data, s);\n\n\n\n    /* old Bochs IO ports */\n\n    register_ioport_read(0xff80, 1, 2, vbe_ioport_read_index, s);\n\n    register_ioport_read(0xff81, 1, 2, vbe_ioport_read_data, s);\n\n\n\n    register_ioport_write(0xff80, 1, 2, vbe_ioport_write_index, s);\n\n    register_ioport_write(0xff81, 1, 2, vbe_ioport_write_data, s);\n\n#else\n\n    register_ioport_read(0x1ce, 1, 2, vbe_ioport_read_index, s);\n\n    register_ioport_read(0x1d0, 1, 2, vbe_ioport_read_data, s);\n\n\n\n    register_ioport_write(0x1ce, 1, 2, vbe_ioport_write_index, s);\n\n    register_ioport_write(0x1d0, 1, 2, vbe_ioport_write_data, s);\n\n#endif\n\n#endif /* CONFIG_BOCHS_VBE */\n\n\n\n    vga_io_memory = cpu_register_io_memory(0, vga_mem_read, vga_mem_write, s);\n\n    cpu_register_physical_memory(isa_mem_base + 0x000a0000, 0x20000,\n\n                                 vga_io_memory);\n\n\n}", "idx": 11735, "_split": "valid", "_hash": "363b8c74a0b8e9c12d5508bd67edc758"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void ide_sector_start_dma(IDEState *s, enum ide_dma_cmd dma_cmd)\n\n{\n\n    s->status = READY_STAT | SEEK_STAT | DRQ_STAT | BUSY_STAT;\n\n    s->io_buffer_index = 0;\n\n    s->io_buffer_size = 0;\n\n    s->dma_cmd = dma_cmd;\n\n\n\n    switch (dma_cmd) {\n\n    case IDE_DMA_READ:\n\n        block_acct_start(bdrv_get_stats(s->bs), &s->acct,\n\n                         s->nsector * BDRV_SECTOR_SIZE, BLOCK_ACCT_READ);\n\n        break;\n\n    case IDE_DMA_WRITE:\n\n        block_acct_start(bdrv_get_stats(s->bs), &s->acct,\n\n                         s->nsector * BDRV_SECTOR_SIZE, BLOCK_ACCT_WRITE);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    ide_start_dma(s, ide_dma_cb);\n\n}\n", "idx": 11841, "_split": "valid", "_hash": "79b329c8c165bacf2dff6645deb42750"}
{"project": "qemu", "commit_id": "8b3d6cb1fa6ae12e80ed8c266a637468b52835c7", "target": 0, "func": "void s390_feat_bitmap_to_ascii(const S390FeatBitmap bitmap, void *opaque,\n\n                               void (*fn)(const char *name, void *opaque))\n\n{\n\n    S390Feat feat;\n\n\n\n    feat = find_first_bit(bitmap, S390_FEAT_MAX);\n\n    while (feat < S390_FEAT_MAX) {\n\n        fn(s390_feat_def(feat)->name, opaque);\n\n        feat = find_next_bit(bitmap, S390_FEAT_MAX, feat + 1);\n\n    };\n\n}\n", "idx": 11847, "_split": "valid", "_hash": "7c39769c4b929537984854611a3956ad"}
{"project": "qemu", "commit_id": "27bb0b2d6f80f058bdb6fcc8fcdfa69b0c8a6d71", "target": 1, "func": "static uint64_t hpet_get_ticks(void)\n\n{\n\n    uint64_t ticks;\n\n    ticks = ns_to_ticks(qemu_get_clock(vm_clock) + hpet_statep->hpet_offset);\n\n    return ticks;\n\n}\n", "idx": 11863, "_split": "valid", "_hash": "71dfb0208fb86c60be2133d2e8182d36"}
{"project": "qemu", "commit_id": "2f8b50083b321e470ef8e2502910ade40cbfa020", "target": 0, "func": "FWCfgState *pc_memory_init(PCMachineState *pcms,\n\n                           MemoryRegion *system_memory,\n\n                           MemoryRegion *rom_memory,\n\n                           MemoryRegion **ram_memory,\n\n                           PcGuestInfo *guest_info)\n\n{\n\n    int linux_boot, i;\n\n    MemoryRegion *ram, *option_rom_mr;\n\n    MemoryRegion *ram_below_4g, *ram_above_4g;\n\n    FWCfgState *fw_cfg;\n\n    MachineState *machine = MACHINE(pcms);\n\n\n\n    assert(machine->ram_size == pcms->below_4g_mem_size +\n\n                                pcms->above_4g_mem_size);\n\n\n\n    linux_boot = (machine->kernel_filename != NULL);\n\n\n\n    /* Allocate RAM.  We allocate it as a single memory region and use\n\n     * aliases to address portions of it, mostly for backwards compatibility\n\n     * with older qemus that used qemu_ram_alloc().\n\n     */\n\n    ram = g_malloc(sizeof(*ram));\n\n    memory_region_allocate_system_memory(ram, NULL, \"pc.ram\",\n\n                                         machine->ram_size);\n\n    *ram_memory = ram;\n\n    ram_below_4g = g_malloc(sizeof(*ram_below_4g));\n\n    memory_region_init_alias(ram_below_4g, NULL, \"ram-below-4g\", ram,\n\n                             0, pcms->below_4g_mem_size);\n\n    memory_region_add_subregion(system_memory, 0, ram_below_4g);\n\n    e820_add_entry(0, pcms->below_4g_mem_size, E820_RAM);\n\n    if (pcms->above_4g_mem_size > 0) {\n\n        ram_above_4g = g_malloc(sizeof(*ram_above_4g));\n\n        memory_region_init_alias(ram_above_4g, NULL, \"ram-above-4g\", ram,\n\n                                 pcms->below_4g_mem_size,\n\n                                 pcms->above_4g_mem_size);\n\n        memory_region_add_subregion(system_memory, 0x100000000ULL,\n\n                                    ram_above_4g);\n\n        e820_add_entry(0x100000000ULL, pcms->above_4g_mem_size, E820_RAM);\n\n    }\n\n\n\n    if (!guest_info->has_reserved_memory &&\n\n        (machine->ram_slots ||\n\n         (machine->maxram_size > machine->ram_size))) {\n\n        MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n\n\n        error_report(\"\\\"-memory 'slots|maxmem'\\\" is not supported by: %s\",\n\n                     mc->name);\n\n        exit(EXIT_FAILURE);\n\n    }\n\n\n\n    /* initialize hotplug memory address space */\n\n    if (guest_info->has_reserved_memory &&\n\n        (machine->ram_size < machine->maxram_size)) {\n\n        ram_addr_t hotplug_mem_size =\n\n            machine->maxram_size - machine->ram_size;\n\n\n\n        if (machine->ram_slots > ACPI_MAX_RAM_SLOTS) {\n\n            error_report(\"unsupported amount of memory slots: %\"PRIu64,\n\n                         machine->ram_slots);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n\n\n        if (QEMU_ALIGN_UP(machine->maxram_size,\n\n                          TARGET_PAGE_SIZE) != machine->maxram_size) {\n\n            error_report(\"maximum memory size must by aligned to multiple of \"\n\n                         \"%d bytes\", TARGET_PAGE_SIZE);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n\n\n        pcms->hotplug_memory.base =\n\n            ROUND_UP(0x100000000ULL + pcms->above_4g_mem_size, 1ULL << 30);\n\n\n\n        if (pcms->enforce_aligned_dimm) {\n\n            /* size hotplug region assuming 1G page max alignment per slot */\n\n            hotplug_mem_size += (1ULL << 30) * machine->ram_slots;\n\n        }\n\n\n\n        if ((pcms->hotplug_memory.base + hotplug_mem_size) <\n\n            hotplug_mem_size) {\n\n            error_report(\"unsupported amount of maximum memory: \" RAM_ADDR_FMT,\n\n                         machine->maxram_size);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n\n\n        memory_region_init(&pcms->hotplug_memory.mr, OBJECT(pcms),\n\n                           \"hotplug-memory\", hotplug_mem_size);\n\n        memory_region_add_subregion(system_memory, pcms->hotplug_memory.base,\n\n                                    &pcms->hotplug_memory.mr);\n\n    }\n\n\n\n    /* Initialize PC system firmware */\n\n    pc_system_firmware_init(rom_memory, guest_info->isapc_ram_fw);\n\n\n\n    option_rom_mr = g_malloc(sizeof(*option_rom_mr));\n\n    memory_region_init_ram(option_rom_mr, NULL, \"pc.rom\", PC_ROM_SIZE,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(option_rom_mr);\n\n    memory_region_add_subregion_overlap(rom_memory,\n\n                                        PC_ROM_MIN_VGA,\n\n                                        option_rom_mr,\n\n                                        1);\n\n\n\n    fw_cfg = bochs_bios_init();\n\n    rom_set_fw(fw_cfg);\n\n\n\n    if (guest_info->has_reserved_memory && pcms->hotplug_memory.base) {\n\n        uint64_t *val = g_malloc(sizeof(*val));\n\n        uint64_t res_mem_end = pcms->hotplug_memory.base +\n\n                               memory_region_size(&pcms->hotplug_memory.mr);\n\n        *val = cpu_to_le64(ROUND_UP(res_mem_end, 0x1ULL << 30));\n\n        fw_cfg_add_file(fw_cfg, \"etc/reserved-memory-end\", val, sizeof(*val));\n\n    }\n\n\n\n    if (linux_boot) {\n\n        load_linux(pcms, fw_cfg);\n\n    }\n\n\n\n    for (i = 0; i < nb_option_roms; i++) {\n\n        rom_add_option(option_rom[i].name, option_rom[i].bootindex);\n\n    }\n\n    guest_info->fw_cfg = fw_cfg;\n\n    return fw_cfg;\n\n}\n", "idx": 11899, "_split": "valid", "_hash": "4480eb0753d4a5555b5564fd62258a94"}
{"project": "qemu", "commit_id": "c07a9008ac6985cd5a15909c2b9977d982defc12", "target": 0, "func": "static BlockDriverAIOCB *bdrv_aio_rw_vector(BlockDriverState *bs,\n\n                                            int64_t sector_num,\n\n                                            QEMUIOVector *iov,\n\n                                            int nb_sectors,\n\n                                            BlockDriverCompletionFunc *cb,\n\n                                            void *opaque,\n\n                                            int is_write)\n\n\n\n{\n\n    VectorTranslationState *s = qemu_mallocz(sizeof(*s));\n\n    BlockDriverAIOCB *aiocb = qemu_aio_get(bs, cb, opaque);\n\n\n\n    s->this_aiocb = aiocb;\n\n    s->iov = iov;\n\n    s->bounce = qemu_memalign(512, nb_sectors * 512);\n\n    s->is_write = is_write;\n\n    if (is_write) {\n\n        qemu_iovec_to_buffer(s->iov, s->bounce);\n\n        s->aiocb = bdrv_aio_write(bs, sector_num, s->bounce, nb_sectors,\n\n                                  bdrv_aio_rw_vector_cb, s);\n\n    } else {\n\n        s->aiocb = bdrv_aio_read(bs, sector_num, s->bounce, nb_sectors,\n\n                                 bdrv_aio_rw_vector_cb, s);\n\n    }\n\n    return aiocb;\n\n}\n", "idx": 11912, "_split": "valid", "_hash": "80f97f4d43350febbcdec48f0e022959"}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "static void pc_machine_set_max_ram_below_4g(Object *obj, Visitor *v,\n\n                                            const char *name, void *opaque,\n\n                                            Error **errp)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(obj);\n\n    Error *error = NULL;\n\n    uint64_t value;\n\n\n\n    visit_type_size(v, name, &value, &error);\n\n    if (error) {\n\n        error_propagate(errp, error);\n\n        return;\n\n    }\n\n    if (value > (1ULL << 32)) {\n\n        error_setg(&error,\n\n                   \"Machine option 'max-ram-below-4g=%\"PRIu64\n\n                   \"' expects size less than or equal to 4G\", value);\n\n        error_propagate(errp, error);\n\n        return;\n\n    }\n\n\n\n    if (value < (1ULL << 20)) {\n\n        error_report(\"Warning: small max_ram_below_4g(%\"PRIu64\n\n                     \") less than 1M.  BIOS may not work..\",\n\n                     value);\n\n    }\n\n\n\n    pcms->max_ram_below_4g = value;\n\n}\n", "idx": 11914, "_split": "valid", "_hash": "97df91f510275c7cc38dedcdba7f5d69"}
{"project": "qemu", "commit_id": "595ab64169be9063d64c3b1aa1c249fbe2662221", "target": 1, "func": "static int stdio_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)\n\n{\n\n    QEMUFileStdio *s = opaque;\n\n    FILE *fp = s->stdio_file;\n\n    int bytes;\n\n\n\n    do {\n\n        clearerr(fp);\n\n        bytes = fread(buf, 1, size, fp);\n\n    } while ((bytes == 0) && ferror(fp) && (errno == EINTR));\n\n    return bytes;\n\n}\n", "idx": 11930, "_split": "valid", "_hash": "b1833983c66c4c9b8730de8eb2b3338f"}
{"project": "qemu", "commit_id": "03f4995781a64e106e6f73864a1e9c4163dac53b", "target": 0, "func": "static MemoryRegionSection *phys_page_find(PhysPageEntry lp, hwaddr index,\n\n                                           Node *nodes, MemoryRegionSection *sections)\n\n{\n\n    PhysPageEntry *p;\n\n    int i;\n\n\n\n    for (i = P_L2_LEVELS - 1; i >= 0 && !lp.is_leaf; i--) {\n\n        if (lp.ptr == PHYS_MAP_NODE_NIL) {\n\n            return &sections[PHYS_SECTION_UNASSIGNED];\n\n        }\n\n        p = nodes[lp.ptr];\n\n        lp = p[(index >> (i * L2_BITS)) & (L2_SIZE - 1)];\n\n    }\n\n    return &sections[lp.ptr];\n\n}\n", "idx": 11945, "_split": "valid", "_hash": "cf77a049b35051fe4a3a8768b05663dc"}
{"project": "qemu", "commit_id": "4c8ae0f60e63478aea0a1741cca95474b68fb949", "target": 0, "func": "static int ram_save_block(QEMUFile *f, bool last_stage)\n\n{\n\n    RAMBlock *block = last_seen_block;\n\n    ram_addr_t offset = last_offset;\n\n    int bytes_sent = -1;\n\n    MemoryRegion *mr;\n\n    ram_addr_t current_addr;\n\n\n\n    if (!block)\n\n        block = QTAILQ_FIRST(&ram_list.blocks);\n\n\n\n    do {\n\n        mr = block->mr;\n\n        if (migration_bitmap_test_and_reset_dirty(mr, offset)) {\n\n            uint8_t *p;\n\n            int cont = (block == last_sent_block) ?\n\n                RAM_SAVE_FLAG_CONTINUE : 0;\n\n\n\n            p = memory_region_get_ram_ptr(mr) + offset;\n\n\n\n            if (is_dup_page(p)) {\n\n                acct_info.dup_pages++;\n\n                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);\n\n                qemu_put_byte(f, *p);\n\n                bytes_sent = 1;\n\n            } else if (migrate_use_xbzrle()) {\n\n                current_addr = block->offset + offset;\n\n                bytes_sent = save_xbzrle_page(f, p, current_addr, block,\n\n                                              offset, cont, last_stage);\n\n                if (!last_stage) {\n\n                    p = get_cached_data(XBZRLE.cache, current_addr);\n\n                }\n\n            }\n\n\n\n            /* either we didn't send yet (we may have had XBZRLE overflow) */\n\n            if (bytes_sent == -1) {\n\n                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);\n\n                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);\n\n                bytes_sent = TARGET_PAGE_SIZE;\n\n                acct_info.norm_pages++;\n\n            }\n\n\n\n            /* if page is unmodified, continue to the next */\n\n            if (bytes_sent != 0) {\n\n                last_sent_block = block;\n\n                break;\n\n            }\n\n        }\n\n\n\n        offset += TARGET_PAGE_SIZE;\n\n        if (offset >= block->length) {\n\n            offset = 0;\n\n            block = QTAILQ_NEXT(block, next);\n\n            if (!block)\n\n                block = QTAILQ_FIRST(&ram_list.blocks);\n\n        }\n\n    } while (block != last_seen_block || offset != last_offset);\n\n\n\n    last_seen_block = block;\n\n    last_offset = offset;\n\n\n\n    return bytes_sent;\n\n}\n", "idx": 11947, "_split": "valid", "_hash": "d910940147ed51a2705d5656b4bf015e"}
{"project": "qemu", "commit_id": "7d175d29c9430fcba7a98f2c71925137b7870da4", "target": 0, "func": "static int os_host_main_loop_wait(int64_t timeout)\n\n{\n\n    int ret;\n\n    static int spin_counter;\n\n\n\n    glib_pollfds_fill(&timeout);\n\n\n\n    /* If the I/O thread is very busy or we are incorrectly busy waiting in\n\n     * the I/O thread, this can lead to starvation of the BQL such that the\n\n     * VCPU threads never run.  To make sure we can detect the later case,\n\n     * print a message to the screen.  If we run into this condition, create\n\n     * a fake timeout in order to give the VCPU threads a chance to run.\n\n     */\n\n    if (!timeout && (spin_counter > MAX_MAIN_LOOP_SPIN)) {\n\n        static bool notified;\n\n\n\n        if (!notified && !qtest_driver()) {\n\n            fprintf(stderr,\n\n                    \"main-loop: WARNING: I/O thread spun for %d iterations\\n\",\n\n                    MAX_MAIN_LOOP_SPIN);\n\n            notified = true;\n\n        }\n\n\n\n        timeout = SCALE_MS;\n\n    }\n\n\n\n    if (timeout) {\n\n        spin_counter = 0;\n\n        qemu_mutex_unlock_iothread();\n\n    } else {\n\n        spin_counter++;\n\n    }\n\n\n\n    ret = qemu_poll_ns((GPollFD *)gpollfds->data, gpollfds->len, timeout);\n\n\n\n    if (timeout) {\n\n        qemu_mutex_lock_iothread();\n\n    }\n\n\n\n    glib_pollfds_poll();\n\n    return ret;\n\n}\n", "idx": 11955, "_split": "valid", "_hash": "cc014e6e103c96656a103165db6d4548"}
{"project": "qemu", "commit_id": "f61eddcb2bb5cbbdd1d911b7e937db9affc29028", "target": 0, "func": "static void qemu_kill_report(void)\n\n{\n\n    if (!qtest_driver() && shutdown_signal != -1) {\n\n        fprintf(stderr, \"qemu: terminating on signal %d\", shutdown_signal);\n\n        if (shutdown_pid == 0) {\n\n            /* This happens for eg ^C at the terminal, so it's worth\n\n             * avoiding printing an odd message in that case.\n\n             */\n\n            fputc('\\n', stderr);\n\n        } else {\n\n            fprintf(stderr, \" from pid \" FMT_pid \"\\n\", shutdown_pid);\n\n        }\n\n        shutdown_signal = -1;\n\n    }\n\n}\n", "idx": 11963, "_split": "valid", "_hash": "3b80941cbf1b706b89e659b441ee346c"}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_bol(void)\n\n{\n\n    term_cmd_buf_index = 0;\n\n}\n", "idx": 11965, "_split": "valid", "_hash": "183ff870b07b19e2ba13f0111452bc2d"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void imx_serial_write(void *opaque, target_phys_addr_t offset,\n\n                      uint64_t value, unsigned size)\n\n{\n\n    IMXSerialState *s = (IMXSerialState *)opaque;\n\n    unsigned char ch;\n\n\n\n    DPRINTF(\"write(offset=%x, value = %x) to %s\\n\",\n\n            offset >> 2,\n\n            (unsigned int)value, s->chr ? s->chr->label : \"NODEV\");\n\n\n\n    switch (offset >> 2) {\n\n    case 0x10: /* UTXD */\n\n        ch = value;\n\n        if (s->ucr2 & UCR2_TXEN) {\n\n            if (s->chr) {\n\n                qemu_chr_fe_write(s->chr, &ch, 1);\n\n            }\n\n            s->usr1 &= ~USR1_TRDY;\n\n            imx_update(s);\n\n            s->usr1 |= USR1_TRDY;\n\n            imx_update(s);\n\n        }\n\n        break;\n\n\n\n    case 0x20: /* UCR1 */\n\n        s->ucr1 = value & 0xffff;\n\n        DPRINTF(\"write(ucr1=%x)\\n\", (unsigned int)value);\n\n        imx_update(s);\n\n        break;\n\n\n\n    case 0x21: /* UCR2 */\n\n        /*\n\n         * Only a few bits in control register 2 are implemented as yet.\n\n         * If it's intended to use a real serial device as a back-end, this\n\n         * register will have to be implemented more fully.\n\n         */\n\n        if (!(value & UCR2_SRST)) {\n\n            imx_serial_reset(s);\n\n            imx_update(s);\n\n            value |= UCR2_SRST;\n\n        }\n\n        if (value & UCR2_RXEN) {\n\n            if (!(s->ucr2 & UCR2_RXEN)) {\n\n                qemu_chr_accept_input(s->chr);\n\n            }\n\n        }\n\n        s->ucr2 = value & 0xffff;\n\n        break;\n\n\n\n    case 0x25: /* USR1 */\n\n        value &= USR1_AWAKE | USR1_AIRINT | USR1_DTRD | USR1_AGTIM |\n\n            USR1_FRAMERR | USR1_ESCF | USR1_RTSD | USR1_PARTYER;\n\n        s->usr1 &= ~value;\n\n        break;\n\n\n\n    case 0x26: /* USR2 */\n\n       /*\n\n        * Writing 1 to some bits clears them; all other\n\n        * values are ignored\n\n        */\n\n        value &= USR2_ADET | USR2_DTRF | USR2_IDLE | USR2_ACST |\n\n            USR2_RIDELT | USR2_IRINT | USR2_WAKE |\n\n            USR2_DCDDELT | USR2_RTSF | USR2_BRCD | USR2_ORE;\n\n        s->usr2 &= ~value;\n\n        break;\n\n\n\n        /*\n\n         * Linux expects to see what it writes to these registers\n\n         * We don't currently alter the baud rate\n\n         */\n\n    case 0x29: /* UBIR */\n\n        s->ubrc = value & 0xffff;\n\n        break;\n\n\n\n    case 0x2a: /* UBMR */\n\n        s->ubmr = value & 0xffff;\n\n        break;\n\n\n\n    case 0x2c: /* One ms reg */\n\n        s->onems = value & 0xffff;\n\n        break;\n\n\n\n    case 0x24: /* FIFO control register */\n\n        s->ufcr = value & 0xffff;\n\n        break;\n\n\n\n    case 0x22: /* UCR3 */\n\n        s->ucr3 = value & 0xffff;\n\n        break;\n\n\n\n    case 0x2d: /* UTS1 */\n\n    case 0x23: /* UCR4 */\n\n        IPRINTF(\"Unimplemented Register %x written to\\n\", offset >> 2);\n\n        /* TODO */\n\n        break;\n\n\n\n    default:\n\n        IPRINTF(\"imx_serial_write: Bad offset 0x%x\\n\", (int)offset);\n\n    }\n\n}\n", "idx": 11968, "_split": "valid", "_hash": "5d23f9e9496d2cc29aead444143d81c1"}
{"project": "qemu", "commit_id": "80fa3341a70151d250be92ae900e3c1580817540", "target": 1, "func": "int qcow2_check_refcounts(BlockDriverState *bs, BdrvCheckResult *res)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t size;\n\n    int nb_clusters, refcount1, refcount2, i;\n\n    QCowSnapshot *sn;\n\n    uint16_t *refcount_table;\n\n    int ret;\n\n\n\n    size = bdrv_getlength(bs->file);\n\n    nb_clusters = size_to_clusters(s, size);\n\n    refcount_table = qemu_mallocz(nb_clusters * sizeof(uint16_t));\n\n\n\n    /* header */\n\n    inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n        0, s->cluster_size);\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                       s->l1_table_offset, s->l1_size, 1);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* snapshots */\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n            sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n        s->snapshots_offset, s->snapshots_size);\n\n\n\n    /* refcount data */\n\n    inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n        s->refcount_table_offset,\n\n        s->refcount_table_size * sizeof(uint64_t));\n\n\n\n    for(i = 0; i < s->refcount_table_size; i++) {\n\n        uint64_t offset, cluster;\n\n        offset = s->refcount_table[i];\n\n        cluster = offset >> s->cluster_bits;\n\n\n\n        /* Refcount blocks are cluster aligned */\n\n        if (offset & (s->cluster_size - 1)) {\n\n            fprintf(stderr, \"ERROR refcount block %d is not \"\n\n                \"cluster aligned; refcount table entry corrupted\\n\", i);\n\n            res->corruptions++;\n\n            continue;\n\n        }\n\n\n\n        if (cluster >= nb_clusters) {\n\n            fprintf(stderr, \"ERROR refcount block %d is outside image\\n\", i);\n\n            res->corruptions++;\n\n            continue;\n\n        }\n\n\n\n        if (offset != 0) {\n\n            inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                offset, s->cluster_size);\n\n            if (refcount_table[cluster] != 1) {\n\n                fprintf(stderr, \"ERROR refcount block %d refcount=%d\\n\",\n\n                    i, refcount_table[cluster]);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* compare ref counts */\n\n    for(i = 0; i < nb_clusters; i++) {\n\n        refcount1 = get_refcount(bs, i);\n\n        if (refcount1 < 0) {\n\n            fprintf(stderr, \"Can't get refcount for cluster %d: %s\\n\",\n\n                i, strerror(-refcount1));\n\n            res->check_errors++;\n\n            continue;\n\n        }\n\n\n\n        refcount2 = refcount_table[i];\n\n        if (refcount1 != refcount2) {\n\n            fprintf(stderr, \"%s cluster %d refcount=%d reference=%d\\n\",\n\n                   refcount1 < refcount2 ? \"ERROR\" : \"Leaked\",\n\n                   i, refcount1, refcount2);\n\n            if (refcount1 < refcount2) {\n\n                res->corruptions++;\n\n            } else {\n\n                res->leaks++;\n\n            }\n\n        }\n\n    }\n\n\n\n    qemu_free(refcount_table);\n\n\n\n    return 0;\n\n}\n", "idx": 11984, "_split": "valid", "_hash": "482ccfeabb91d2920d4557b3d211ae2f"}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static int gen_set_psr_im(DisasContext *s, uint32_t mask, int spsr, uint32_t val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_movi_i32(tmp, val);\n\n    return gen_set_psr(s, mask, spsr, tmp);\n\n}\n", "idx": 12004, "_split": "valid", "_hash": "daf209b6f313dae0664a67ab9b9b85fe"}
{"project": "qemu", "commit_id": "621ff94d5074d88253a5818c6b9c4db718fbfc65", "target": 0, "func": "static void vhost_ccw_scsi_realize(VirtioCcwDevice *ccw_dev, Error **errp)\n\n{\n\n    VHostSCSICcw *dev = VHOST_SCSI_CCW(ccw_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n    Error *err = NULL;\n\n\n\n    qdev_set_parent_bus(vdev, BUS(&ccw_dev->bus));\n\n    object_property_set_bool(OBJECT(vdev), true, \"realized\", &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n    }\n\n}\n", "idx": 12030, "_split": "valid", "_hash": "5ccedbec10aa8f375aef76d5ec335f57"}
{"project": "qemu", "commit_id": "185b43386ad999c80bdc58e41b87f05e5b3e8463", "target": 0, "func": "ssize_t nbd_send_request(int csock, struct nbd_request *request)\n\n{\n\n    uint8_t buf[4 + 4 + 8 + 8 + 4];\n\n\n\n    cpu_to_be32w((uint32_t*)buf, NBD_REQUEST_MAGIC);\n\n    cpu_to_be32w((uint32_t*)(buf + 4), request->type);\n\n    cpu_to_be64w((uint64_t*)(buf + 8), request->handle);\n\n    cpu_to_be64w((uint64_t*)(buf + 16), request->from);\n\n    cpu_to_be32w((uint32_t*)(buf + 24), request->len);\n\n\n\n    TRACE(\"Sending request to client: \"\n\n          \"{ .from = %\" PRIu64\", .len = %u, .handle = %\" PRIu64\", .type=%i}\",\n\n          request->from, request->len, request->handle, request->type);\n\n\n\n    if (write_sync(csock, buf, sizeof(buf)) != sizeof(buf)) {\n\n        LOG(\"writing to socket failed\");\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 12041, "_split": "valid", "_hash": "86256169cb1c05972a3de368e5ebfbf9"}
{"project": "qemu", "commit_id": "64a31d5c3d73396a88563d7a504654edc85aa854", "target": 0, "func": "static void dmg_close(BlockDriverState *bs)\n\n{\n\n    BDRVDMGState *s = bs->opaque;\n\n    close(s->fd);\n\n    if(s->n_chunks>0) {\n\n\tfree(s->types);\n\n\tfree(s->offsets);\n\n\tfree(s->lengths);\n\n\tfree(s->sectors);\n\n\tfree(s->sectorcounts);\n\n    }\n\n    free(s->compressed_chunk);\n\n    free(s->uncompressed_chunk);\n\n    inflateEnd(&s->zstream);\n\n}\n", "idx": 12049, "_split": "valid", "_hash": "d249db813b188f953b25e65f923a2564"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void lance_mem_write(void *opaque, target_phys_addr_t addr,\n\n                            uint64_t val, unsigned size)\n\n{\n\n    SysBusPCNetState *d = opaque;\n\n\n\n    trace_lance_mem_writew(addr, val & 0xffff);\n\n    pcnet_ioport_writew(&d->state, addr, val & 0xffff);\n\n}\n", "idx": 12053, "_split": "valid", "_hash": "e056a88b4fabc59daacafa4dccf1310a"}
{"project": "qemu", "commit_id": "0745eb1e4336bf665a911754d18ddd63794b352d", "target": 1, "func": "device_init(usb_host_register_devices)\n\n\n\nUSBDevice *usb_host_device_open(const char *devname)\n\n{\n\n    struct USBAutoFilter filter = { 0, 0, 0, 0 };\n\n    USBDevice *dev;\n\n    USBHostDevice *s;\n\n    char *p;\n\n\n\n    dev = usb_create(NULL /* FIXME */, \"USB Host Device\");\n\n    s = DO_UPCAST(USBHostDevice, dev, dev);\n\n\n\n    if (strstr(devname, \"auto:\")) {\n\n        if (parse_filter(devname+5, &filter) < 0)\n\n            goto fail;\n\n    } else {\n\n        if ((p = strchr(devname, '.'))) {\n\n            filter.bus_num = strtoul(devname, NULL, 0);\n\n            filter.addr    = strtoul(devname, NULL, 0);\n\n        } else if ((p = strchr(devname, ':'))) {\n\n            filter.vendor_id  = strtoul(devname, NULL, 16);\n\n            filter.product_id = strtoul(devname, NULL, 16);\n\n        } else {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    qdev_prop_set_uint32(&dev->qdev, \"bus\",       filter.bus_num);\n\n    qdev_prop_set_uint32(&dev->qdev, \"addr\",      filter.addr);\n\n    qdev_prop_set_uint32(&dev->qdev, \"vendorid\",  filter.vendor_id);\n\n    qdev_prop_set_uint32(&dev->qdev, \"productid\", filter.product_id);\n\n    qdev_init(&dev->qdev);\n\n    return dev;\n\n\n\nfail:\n\n    qdev_free(&dev->qdev);\n\n    return NULL;\n\n}\n", "idx": 12093, "_split": "valid", "_hash": "a6f862dd9e927e35373388698a119ed5"}
{"project": "qemu", "commit_id": "27a749fb733dc64b7a215998be7f228a09bb27a7", "target": 1, "func": "void qemu_error_internal(const char *file, int linenr, const char *func,\n\n                         const char *fmt, ...)\n\n{\n\n    va_list va;\n\n    QError *qerror;\n\n\n\n    assert(qemu_error_sink != NULL);\n\n\n\n    va_start(va, fmt);\n\n    qerror = qerror_from_info(file, linenr, func, fmt, &va);\n\n    va_end(va);\n\n\n\n    switch (qemu_error_sink->dest) {\n\n    case ERR_SINK_FILE:\n\n        qerror_print(qerror);\n\n        QDECREF(qerror);\n\n        break;\n\n    case ERR_SINK_MONITOR:\n\n        assert(qemu_error_sink->mon->error == NULL);\n\n        qemu_error_sink->mon->error = qerror;\n\n        break;\n\n    }\n\n}\n", "idx": 12094, "_split": "valid", "_hash": "bf3ffdbce8862812288476fd2eabbf35"}
{"project": "qemu", "commit_id": "daa23699031693b434ec263b212f77ba505e353e", "target": 0, "func": "static void spapr_phb_placement(sPAPRMachineState *spapr, uint32_t index,\n\n                                uint64_t *buid, hwaddr *pio, hwaddr *mmio,\n\n                                unsigned n_dma, uint32_t *liobns, Error **errp)\n\n{\n\n    const uint64_t base_buid = 0x800000020000000ULL;\n\n    const hwaddr phb_spacing = 0x1000000000ULL; /* 64 GiB */\n\n    const hwaddr mmio_offset = 0xa0000000; /* 2 GiB + 512 MiB */\n\n    const hwaddr pio_offset = 0x80000000; /* 2 GiB */\n\n    const uint32_t max_index = 255;\n\n    const hwaddr phb0_alignment = 0x10000000000ULL; /* 1 TiB */\n\n\n\n    uint64_t ram_top = MACHINE(spapr)->ram_size;\n\n    hwaddr phb0_base, phb_base;\n\n    int i;\n\n\n\n    /* Do we have hotpluggable memory? */\n\n    if (MACHINE(spapr)->maxram_size > ram_top) {\n\n        /* Can't just use maxram_size, because there may be an\n\n         * alignment gap between normal and hotpluggable memory\n\n         * regions */\n\n        ram_top = spapr->hotplug_memory.base +\n\n            memory_region_size(&spapr->hotplug_memory.mr);\n\n    }\n\n\n\n    phb0_base = QEMU_ALIGN_UP(ram_top, phb0_alignment);\n\n\n\n    if (index > max_index) {\n\n        error_setg(errp, \"\\\"index\\\" for PAPR PHB is too large (max %u)\",\n\n                   max_index);\n\n        return;\n\n    }\n\n\n\n    *buid = base_buid + index;\n\n    for (i = 0; i < n_dma; ++i) {\n\n        liobns[i] = SPAPR_PCI_LIOBN(index, i);\n\n    }\n\n\n\n    phb_base = phb0_base + index * phb_spacing;\n\n    *pio = phb_base + pio_offset;\n\n    *mmio = phb_base + mmio_offset;\n\n}\n", "idx": 12105, "_split": "valid", "_hash": "60d0aa35fd90f76ecaac32a195fbae77"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_save_vmstate(BlockDriverState *bs, const uint8_t *buf,\n\n                      int64_t pos, int size)\n\n{\n\n    QEMUIOVector qiov;\n\n    struct iovec iov = {\n\n        .iov_base   = (void *) buf,\n\n        .iov_len    = size,\n\n    };\n\n\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n    return bdrv_writev_vmstate(bs, &qiov, pos);\n\n}\n", "idx": 12109, "_split": "valid", "_hash": "2aa639f0771f74eafad72221dbe01971"}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "void helper_fcmpo (uint64_t arg1, uint64_t arg2, uint32_t crfD)\n\n{\n\n    CPU_DoubleU farg1, farg2;\n\n    uint32_t ret = 0;\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n\n\n    if (unlikely(float64_is_nan(farg1.d) ||\n\n                 float64_is_nan(farg2.d))) {\n\n        ret = 0x01UL;\n\n    } else if (float64_lt(farg1.d, farg2.d, &env->fp_status)) {\n\n        ret = 0x08UL;\n\n    } else if (!float64_le(farg1.d, farg2.d, &env->fp_status)) {\n\n        ret = 0x04UL;\n\n    } else {\n\n        ret = 0x02UL;\n\n    }\n\n\n\n    env->fpscr &= ~(0x0F << FPSCR_FPRF);\n\n    env->fpscr |= ret << FPSCR_FPRF;\n\n    env->crf[crfD] = ret;\n\n    if (unlikely (ret == 0x01UL)) {\n\n        if (float64_is_signaling_nan(farg1.d) ||\n\n            float64_is_signaling_nan(farg2.d)) {\n\n            /* sNaN comparison */\n\n            fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN |\n\n                                  POWERPC_EXCP_FP_VXVC);\n\n        } else {\n\n            /* qNaN comparison */\n\n            fload_invalid_op_excp(POWERPC_EXCP_FP_VXVC);\n\n        }\n\n    }\n\n}\n", "idx": 12121, "_split": "valid", "_hash": "f0d53f4a7d4ad23aa3d6e94a09c0aba4"}
{"project": "qemu", "commit_id": "801f70445293ec8ed2d78fd92313c2f71fa48ac9", "target": 0, "func": "int qcow2_check_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                          BdrvCheckMode fix)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t size, i, highest_cluster;\n\n    int nb_clusters, refcount1, refcount2;\n\n    QCowSnapshot *sn;\n\n    uint16_t *refcount_table;\n\n    int ret;\n\n\n\n    size = bdrv_getlength(bs->file);\n\n    nb_clusters = size_to_clusters(s, size);\n\n    refcount_table = g_malloc0(nb_clusters * sizeof(uint16_t));\n\n\n\n    /* header */\n\n    inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n        0, s->cluster_size);\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                       s->l1_table_offset, s->l1_size, 1);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* snapshots */\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n            sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n    inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n        s->snapshots_offset, s->snapshots_size);\n\n\n\n    /* refcount data */\n\n    inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n        s->refcount_table_offset,\n\n        s->refcount_table_size * sizeof(uint64_t));\n\n\n\n    for(i = 0; i < s->refcount_table_size; i++) {\n\n        uint64_t offset, cluster;\n\n        offset = s->refcount_table[i];\n\n        cluster = offset >> s->cluster_bits;\n\n\n\n        /* Refcount blocks are cluster aligned */\n\n        if (offset & (s->cluster_size - 1)) {\n\n            fprintf(stderr, \"ERROR refcount block %\" PRId64 \" is not \"\n\n                \"cluster aligned; refcount table entry corrupted\\n\", i);\n\n            res->corruptions++;\n\n            continue;\n\n        }\n\n\n\n        if (cluster >= nb_clusters) {\n\n            fprintf(stderr, \"ERROR refcount block %\" PRId64\n\n                    \" is outside image\\n\", i);\n\n            res->corruptions++;\n\n            continue;\n\n        }\n\n\n\n        if (offset != 0) {\n\n            inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                offset, s->cluster_size);\n\n            if (refcount_table[cluster] != 1) {\n\n                fprintf(stderr, \"ERROR refcount block %\" PRId64\n\n                    \" refcount=%d\\n\",\n\n                    i, refcount_table[cluster]);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* compare ref counts */\n\n    for (i = 0, highest_cluster = 0; i < nb_clusters; i++) {\n\n        refcount1 = get_refcount(bs, i);\n\n        if (refcount1 < 0) {\n\n            fprintf(stderr, \"Can't get refcount for cluster %\" PRId64 \": %s\\n\",\n\n                i, strerror(-refcount1));\n\n            res->check_errors++;\n\n            continue;\n\n        }\n\n\n\n        refcount2 = refcount_table[i];\n\n\n\n        if (refcount1 > 0 || refcount2 > 0) {\n\n            highest_cluster = i;\n\n        }\n\n\n\n        if (refcount1 != refcount2) {\n\n\n\n            /* Check if we're allowed to fix the mismatch */\n\n            int *num_fixed = NULL;\n\n            if (refcount1 > refcount2 && (fix & BDRV_FIX_LEAKS)) {\n\n                num_fixed = &res->leaks_fixed;\n\n            } else if (refcount1 < refcount2 && (fix & BDRV_FIX_ERRORS)) {\n\n                num_fixed = &res->corruptions_fixed;\n\n            }\n\n\n\n            fprintf(stderr, \"%s cluster %\" PRId64 \" refcount=%d reference=%d\\n\",\n\n                   num_fixed != NULL     ? \"Repairing\" :\n\n                   refcount1 < refcount2 ? \"ERROR\" :\n\n                                           \"Leaked\",\n\n                   i, refcount1, refcount2);\n\n\n\n            if (num_fixed) {\n\n                ret = update_refcount(bs, i << s->cluster_bits, 1,\n\n                                      refcount2 - refcount1);\n\n                if (ret >= 0) {\n\n                    (*num_fixed)++;\n\n                    continue;\n\n                }\n\n            }\n\n\n\n            /* And if we couldn't, print an error */\n\n            if (refcount1 < refcount2) {\n\n                res->corruptions++;\n\n            } else {\n\n                res->leaks++;\n\n            }\n\n        }\n\n    }\n\n\n\n    res->image_end_offset = (highest_cluster + 1) * s->cluster_size;\n\n    ret = 0;\n\n\n\nfail:\n\n    g_free(refcount_table);\n\n\n\n    return ret;\n\n}\n", "idx": 12123, "_split": "valid", "_hash": "7d6aae0ad64c459ffa279ad4bca69bf1"}
{"project": "qemu", "commit_id": "882e9b89af7c1086d97cee11b2437337e756fa00", "target": 0, "func": "void qmp_x_blockdev_set_iothread(const char *node_name, StrOrNull *iothread,\n\n                                 Error **errp)\n\n{\n\n    AioContext *old_context;\n\n    AioContext *new_context;\n\n    BlockDriverState *bs;\n\n\n\n    bs = bdrv_find_node(node_name);\n\n    if (!bs) {\n\n        error_setg(errp, \"Cannot find node %s\", node_name);\n\n        return;\n\n    }\n\n\n\n    /* If we want to allow more extreme test scenarios this guard could be\n\n     * removed.  For now it protects against accidents. */\n\n    if (bdrv_has_blk(bs)) {\n\n        error_setg(errp, \"Node %s is in use\", node_name);\n\n        return;\n\n    }\n\n\n\n    if (iothread->type == QTYPE_QSTRING) {\n\n        IOThread *obj = iothread_by_id(iothread->u.s);\n\n        if (!obj) {\n\n            error_setg(errp, \"Cannot find iothread %s\", iothread->u.s);\n\n            return;\n\n        }\n\n\n\n        new_context = iothread_get_aio_context(obj);\n\n    } else {\n\n        new_context = qemu_get_aio_context();\n\n    }\n\n\n\n    old_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(old_context);\n\n\n\n    bdrv_set_aio_context(bs, new_context);\n\n\n\n    aio_context_release(old_context);\n\n}\n", "idx": 12132, "_split": "valid", "_hash": "7a7078da491a3a9e9a1390bb73040989"}
{"project": "qemu", "commit_id": "240f64b6dc3346d044d7beb7cc3a53668ce47384", "target": 0, "func": "static void test_dealloc_partial(void)\n\n{\n\n    static const char text[] = \"don't leak me\";\n\n\n\n    UserDefTwo *ud2 = NULL;\n\n    Error *err = NULL;\n\n\n\n    /* create partial object */\n\n    {\n\n        QDict *ud2_dict;\n\n        QmpInputVisitor *qiv;\n\n\n\n        ud2_dict = qdict_new();\n\n        qdict_put_obj(ud2_dict, \"string0\", QOBJECT(qstring_from_str(text)));\n\n\n\n        qiv = qmp_input_visitor_new(QOBJECT(ud2_dict), false);\n\n        visit_type_UserDefTwo(qmp_input_get_visitor(qiv), NULL, &ud2, &err);\n\n        qmp_input_visitor_cleanup(qiv);\n\n        QDECREF(ud2_dict);\n\n    }\n\n\n\n    /* verify partial success */\n\n    assert(ud2 != NULL);\n\n    assert(ud2->string0 != NULL);\n\n    assert(strcmp(ud2->string0, text) == 0);\n\n    assert(ud2->dict1 == NULL);\n\n\n\n    /* confirm & release construction error */\n\n    error_free_or_abort(&err);\n\n\n\n    /* tear down partial object */\n\n    qapi_free_UserDefTwo(ud2);\n\n}\n", "idx": 12137, "_split": "valid", "_hash": "a1b44db67a70124cfa344da3e8dc0da8"}
{"project": "qemu", "commit_id": "3468b59e18b179bc63c7ce934de912dfa9596122", "target": 0, "func": "size_t tcg_code_size(void)\n\n{\n\n    unsigned int i;\n\n    size_t total;\n\n\n\n    qemu_mutex_lock(&region.lock);\n\n    total = region.agg_size_full;\n\n    for (i = 0; i < n_tcg_ctxs; i++) {\n\n        const TCGContext *s = tcg_ctxs[i];\n\n        size_t size;\n\n\n\n        size = atomic_read(&s->code_gen_ptr) - s->code_gen_buffer;\n\n        g_assert(size <= s->code_gen_buffer_size);\n\n        total += size;\n\n    }\n\n    qemu_mutex_unlock(&region.lock);\n\n    return total;\n\n}\n", "idx": 12139, "_split": "valid", "_hash": "e83a067f77d20ef34bf3d7ef6f6bfd12"}
{"project": "qemu", "commit_id": "8b0ee8c576a6f3e107c80f70f6dacb2964feb4a7", "target": 0, "func": "static inline abi_long host_to_target_stat64(void *cpu_env,\n\n                                             abi_ulong target_addr,\n\n                                             struct stat *host_st)\n\n{\n\n#ifdef TARGET_ARM\n\n    if (((CPUARMState *)cpu_env)->eabi) {\n\n        struct target_eabi_stat64 *target_st;\n\n\n\n        if (!lock_user_struct(VERIFY_WRITE, target_st, target_addr, 0))\n\n            return -TARGET_EFAULT;\n\n        memset(target_st, 0, sizeof(struct target_eabi_stat64));\n\n        __put_user(host_st->st_dev, &target_st->st_dev);\n\n        __put_user(host_st->st_ino, &target_st->st_ino);\n\n#ifdef TARGET_STAT64_HAS_BROKEN_ST_INO\n\n        __put_user(host_st->st_ino, &target_st->__st_ino);\n\n#endif\n\n        __put_user(host_st->st_mode, &target_st->st_mode);\n\n        __put_user(host_st->st_nlink, &target_st->st_nlink);\n\n        __put_user(host_st->st_uid, &target_st->st_uid);\n\n        __put_user(host_st->st_gid, &target_st->st_gid);\n\n        __put_user(host_st->st_rdev, &target_st->st_rdev);\n\n        __put_user(host_st->st_size, &target_st->st_size);\n\n        __put_user(host_st->st_blksize, &target_st->st_blksize);\n\n        __put_user(host_st->st_blocks, &target_st->st_blocks);\n\n        __put_user(host_st->st_atime, &target_st->target_st_atime);\n\n        __put_user(host_st->st_mtime, &target_st->target_st_mtime);\n\n        __put_user(host_st->st_ctime, &target_st->target_st_ctime);\n\n        unlock_user_struct(target_st, target_addr, 1);\n\n    } else\n\n#endif\n\n    {\n\n#if TARGET_LONG_BITS == 64\n\n        struct target_stat *target_st;\n\n#else\n\n        struct target_stat64 *target_st;\n\n#endif\n\n\n\n        if (!lock_user_struct(VERIFY_WRITE, target_st, target_addr, 0))\n\n            return -TARGET_EFAULT;\n\n        memset(target_st, 0, sizeof(*target_st));\n\n        __put_user(host_st->st_dev, &target_st->st_dev);\n\n        __put_user(host_st->st_ino, &target_st->st_ino);\n\n#ifdef TARGET_STAT64_HAS_BROKEN_ST_INO\n\n        __put_user(host_st->st_ino, &target_st->__st_ino);\n\n#endif\n\n        __put_user(host_st->st_mode, &target_st->st_mode);\n\n        __put_user(host_st->st_nlink, &target_st->st_nlink);\n\n        __put_user(host_st->st_uid, &target_st->st_uid);\n\n        __put_user(host_st->st_gid, &target_st->st_gid);\n\n        __put_user(host_st->st_rdev, &target_st->st_rdev);\n\n        /* XXX: better use of kernel struct */\n\n        __put_user(host_st->st_size, &target_st->st_size);\n\n        __put_user(host_st->st_blksize, &target_st->st_blksize);\n\n        __put_user(host_st->st_blocks, &target_st->st_blocks);\n\n        __put_user(host_st->st_atime, &target_st->target_st_atime);\n\n        __put_user(host_st->st_mtime, &target_st->target_st_mtime);\n\n        __put_user(host_st->st_ctime, &target_st->target_st_ctime);\n\n        unlock_user_struct(target_st, target_addr, 1);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12148, "_split": "valid", "_hash": "88ec3efa71b58392ca86f6841e417e29"}
{"project": "qemu", "commit_id": "703e0e89c669a70bbd6bf33c5e75f910d8d8cca3", "target": 1, "func": "static abi_ulong setup_arg_pages(abi_ulong p, struct linux_binprm *bprm,\n\n                                 struct image_info *info)\n\n{\n\n    abi_ulong stack_base, size, error;\n\n    int i;\n\n\n\n    /* Create enough stack to hold everything.  If we don't use\n\n     * it for args, we'll use it for something else...\n\n     */\n\n    size = x86_stack_size;\n\n    if (size < MAX_ARG_PAGES*TARGET_PAGE_SIZE)\n\n        size = MAX_ARG_PAGES*TARGET_PAGE_SIZE;\n\n    error = target_mmap(0,\n\n                        size + qemu_host_page_size,\n\n                        PROT_READ | PROT_WRITE,\n\n                        MAP_PRIVATE | MAP_ANONYMOUS,\n\n                        -1, 0);\n\n    if (error == -1) {\n\n        perror(\"stk mmap\");\n\n        exit(-1);\n\n    }\n\n    /* we reserve one extra page at the top of the stack as guard */\n\n    target_mprotect(error + size, qemu_host_page_size, PROT_NONE);\n\n\n\n    stack_base = error + size - MAX_ARG_PAGES*TARGET_PAGE_SIZE;\n\n    p += stack_base;\n\n\n\n    for (i = 0 ; i < MAX_ARG_PAGES ; i++) {\n\n\tif (bprm->page[i]) {\n\n\t    info->rss++;\n\n            /* FIXME - check return value of memcpy_to_target() for failure */\n\n\t    memcpy_to_target(stack_base, bprm->page[i], TARGET_PAGE_SIZE);\n\n\t    free(bprm->page[i]);\n\n\t}\n\n        stack_base += TARGET_PAGE_SIZE;\n\n    }\n\n    return p;\n\n}\n", "idx": 12166, "_split": "valid", "_hash": "89eeb9dfae250fc1e57cf146d4d946a1"}
{"project": "qemu", "commit_id": "56c119e52ca229869912b22a5bec283487b0cf9b", "target": 1, "func": "void xen_map_cache_init(void)\n\n{\n\n    unsigned long size;\n\n    struct rlimit rlimit_as;\n\n\n\n    mapcache = g_malloc0(sizeof (MapCache));\n\n\n\n    QTAILQ_INIT(&mapcache->locked_entries);\n\n    mapcache->last_address_index = -1;\n\n\n\n    getrlimit(RLIMIT_AS, &rlimit_as);\n\n    if (rlimit_as.rlim_max < MCACHE_MAX_SIZE) {\n\n        rlimit_as.rlim_cur = rlimit_as.rlim_max;\n\n    } else {\n\n        rlimit_as.rlim_cur = MCACHE_MAX_SIZE;\n\n    }\n\n\n\n    setrlimit(RLIMIT_AS, &rlimit_as);\n\n    mapcache->max_mcache_size = rlimit_as.rlim_cur;\n\n\n\n    mapcache->nr_buckets =\n\n        (((mapcache->max_mcache_size >> XC_PAGE_SHIFT) +\n\n          (1UL << (MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT)) - 1) >>\n\n         (MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT));\n\n\n\n    size = mapcache->nr_buckets * sizeof (MapCacheEntry);\n\n    size = (size + XC_PAGE_SIZE - 1) & ~(XC_PAGE_SIZE - 1);\n\n    DPRINTF(\"%s, nr_buckets = %lx size %lu\\n\", __func__,\n\n            mapcache->nr_buckets, size);\n\n    mapcache->entry = g_malloc0(size);\n\n}\n", "idx": 12194, "_split": "valid", "_hash": "a75311819813d4e417446750940890ab"}
{"project": "qemu", "commit_id": "38f3ef574b48afc507c6f636ae4393fd36bda072", "target": 1, "func": "static BlockDriver *bdrv_probe_all(const uint8_t *buf, int buf_size,\n\n                                   const char *filename)\n\n{\n\n    int score_max = 0, score;\n\n    BlockDriver *drv = NULL, *d;\n\n\n\n    QLIST_FOREACH(d, &bdrv_drivers, list) {\n\n        if (d->bdrv_probe) {\n\n            score = d->bdrv_probe(buf, buf_size, filename);\n\n            if (score > score_max) {\n\n                score_max = score;\n\n                drv = d;\n\n            }\n\n        }\n\n    }\n\n\n\n    return drv;\n\n}\n", "idx": 12203, "_split": "valid", "_hash": "d73f1af357ef8f9dc7452aeca254a08f"}
{"project": "qemu", "commit_id": "2ecea9b8de5cd74df314541b87f712ae77f862ec", "target": 1, "func": "static void do_change(const char *device, const char *target)\n\n{\n\n    if (strcmp(device, \"vnc\") == 0) {\n\n\tdo_change_vnc(target);\n\n    } else {\n\n\tdo_change_block(device, target);\n\n    }\n\n}\n", "idx": 12211, "_split": "valid", "_hash": "516f446ad80add3b99a3af5a4c701156"}
{"project": "qemu", "commit_id": "c627e7526a902dd5bb1907dbbd5cf961679dfa68", "target": 1, "func": "static void rc4030_unrealize(DeviceState *dev, Error **errp)\n\n{\n\n    rc4030State *s = RC4030(dev);\n\n    int i;\n\n\n\n    timer_free(s->periodic_timer);\n\n\n\n    address_space_destroy(&s->dma_as);\n\n    object_unparent(OBJECT(&s->dma_tt));\n\n    object_unparent(OBJECT(&s->dma_tt_alias));\n\n    object_unparent(OBJECT(&s->dma_mr));\n\n    for (i = 0; i < MAX_TL_ENTRIES; ++i) {\n\n        memory_region_del_subregion(&s->dma_mr, &s->dma_mrs[i]);\n\n        object_unparent(OBJECT(&s->dma_mrs[i]));\n\n    }\n\n}\n", "idx": 12225, "_split": "valid", "_hash": "162f2385a8ac478549c2e09f32e661e4"}
{"project": "qemu", "commit_id": "eff235eb2bcd7092901f4698a7907e742f3b7f2f", "target": 1, "func": "static ExitStatus trans_fop_dew_0e(DisasContext *ctx, uint32_t insn,\n\n                                   const DisasInsn *di)\n\n{\n\n    unsigned rt = extract32(insn, 0, 5);\n\n    unsigned ra = assemble_ra64(insn);\n\n    return do_fop_dew(ctx, rt, ra, di->f_dew);\n\n}\n", "idx": 12259, "_split": "valid", "_hash": "2a56f134e57b797fb10ea116bfb500cb"}
{"project": "qemu", "commit_id": "5a3165263ae6782a7fe712a0a0c29c17468b9b68", "target": 0, "func": "static void check_watchpoint(int offset, int len_mask, int flags)\n\n{\n\n    CPUArchState *env = cpu_single_env;\n\n    target_ulong pc, cs_base;\n\n    TranslationBlock *tb;\n\n    target_ulong vaddr;\n\n    CPUWatchpoint *wp;\n\n    int cpu_flags;\n\n\n\n    if (env->watchpoint_hit) {\n\n        /* We re-entered the check after replacing the TB. Now raise\n\n         * the debug interrupt so that is will trigger after the\n\n         * current instruction. */\n\n        cpu_interrupt(env, CPU_INTERRUPT_DEBUG);\n\n        return;\n\n    }\n\n    vaddr = (env->mem_io_vaddr & TARGET_PAGE_MASK) + offset;\n\n    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {\n\n        if ((vaddr == (wp->vaddr & len_mask) ||\n\n             (vaddr & wp->len_mask) == wp->vaddr) && (wp->flags & flags)) {\n\n            wp->flags |= BP_WATCHPOINT_HIT;\n\n            if (!env->watchpoint_hit) {\n\n                env->watchpoint_hit = wp;\n\n                tb = tb_find_pc(env->mem_io_pc);\n\n                if (!tb) {\n\n                    cpu_abort(env, \"check_watchpoint: could not find TB for \"\n\n                              \"pc=%p\", (void *)env->mem_io_pc);\n\n                }\n\n                cpu_restore_state(tb, env, env->mem_io_pc);\n\n                tb_phys_invalidate(tb, -1);\n\n                if (wp->flags & BP_STOP_BEFORE_ACCESS) {\n\n                    env->exception_index = EXCP_DEBUG;\n\n                    cpu_loop_exit(env);\n\n                } else {\n\n                    cpu_get_tb_cpu_state(env, &pc, &cs_base, &cpu_flags);\n\n                    tb_gen_code(env, pc, cs_base, cpu_flags, 1);\n\n                    cpu_resume_from_signal(env, NULL);\n\n                }\n\n            }\n\n        } else {\n\n            wp->flags &= ~BP_WATCHPOINT_HIT;\n\n        }\n\n    }\n\n}\n", "idx": 12298, "_split": "valid", "_hash": "e1e8c324f587a5f62b44701dd45dd4d1"}
{"project": "qemu", "commit_id": "6502a14734e71b2f6dd079b0a1e546e6aa2d2f8d", "target": 0, "func": "BalloonInfo *qmp_query_balloon(Error **errp)\n\n{\n\n    BalloonInfo *info;\n\n\n\n    if (kvm_enabled() && !kvm_has_sync_mmu()) {\n\n        error_set(errp, QERR_KVM_MISSING_CAP, \"synchronous MMU\", \"balloon\");\n\n        return NULL;\n\n    }\n\n\n\n    info = g_malloc0(sizeof(*info));\n\n\n\n    if (qemu_balloon_status(info) == 0) {\n\n        error_set(errp, QERR_DEVICE_NOT_ACTIVE, \"balloon\");\n\n        qapi_free_BalloonInfo(info);\n\n        return NULL;\n\n    }\n\n\n\n    return info;\n\n}\n", "idx": 12308, "_split": "valid", "_hash": "601b0a4b1eeba6e42e80e53b1583ac96"}
{"project": "qemu", "commit_id": "39ae4972390f78f8891a355545c56d20a9fb7770", "target": 0, "func": "static void pc_init1(MemoryRegion *system_memory,\n\n                     MemoryRegion *system_io,\n\n                     ram_addr_t ram_size,\n\n                     const char *boot_device,\n\n                     const char *kernel_filename,\n\n                     const char *kernel_cmdline,\n\n                     const char *initrd_filename,\n\n                     const char *cpu_model,\n\n                     int pci_enabled,\n\n                     int kvmclock_enabled)\n\n{\n\n    int i;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size;\n\n    PCIBus *pci_bus;\n\n    ISABus *isa_bus;\n\n    PCII440FXState *i440fx_state;\n\n    int piix3_devfn = -1;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *gsi;\n\n    qemu_irq *i8259;\n\n    qemu_irq *smi_irq;\n\n    GSIState *gsi_state;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BusState *idebus[MAX_IDE_BUS];\n\n    ISADevice *rtc_state;\n\n    ISADevice *floppy;\n\n    MemoryRegion *ram_memory;\n\n    MemoryRegion *pci_memory;\n\n    MemoryRegion *rom_memory;\n\n    DeviceState *icc_bridge;\n\n    FWCfgState *fw_cfg = NULL;\n\n\n\n    if (xen_enabled() && xen_hvm_init() != 0) {\n\n        fprintf(stderr, \"xen hardware virtual machine initialisation failed\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    icc_bridge = qdev_create(NULL, TYPE_ICC_BRIDGE);\n\n    object_property_add_child(qdev_get_machine(), \"icc-bridge\",\n\n                              OBJECT(icc_bridge), NULL);\n\n\n\n    pc_cpus_init(cpu_model, icc_bridge);\n\n    pc_acpi_init(\"acpi-dsdt.aml\");\n\n\n\n    if (kvm_enabled() && kvmclock_enabled) {\n\n        kvmclock_create();\n\n    }\n\n\n\n    if (ram_size >= 0xe0000000 ) {\n\n        above_4g_mem_size = ram_size - 0xe0000000;\n\n        below_4g_mem_size = 0xe0000000;\n\n    } else {\n\n        above_4g_mem_size = 0;\n\n        below_4g_mem_size = ram_size;\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_memory = g_new(MemoryRegion, 1);\n\n        memory_region_init(pci_memory, \"pci\", INT64_MAX);\n\n        rom_memory = pci_memory;\n\n    } else {\n\n        pci_memory = NULL;\n\n        rom_memory = system_memory;\n\n    }\n\n\n\n    /* allocate ram and load rom/bios */\n\n    if (!xen_enabled()) {\n\n        fw_cfg = pc_memory_init(system_memory,\n\n                       kernel_filename, kernel_cmdline, initrd_filename,\n\n                       below_4g_mem_size, above_4g_mem_size,\n\n                       rom_memory, &ram_memory);\n\n    }\n\n\n\n    gsi_state = g_malloc0(sizeof(*gsi_state));\n\n    if (kvm_irqchip_in_kernel()) {\n\n        kvm_pc_setup_irq_routing(pci_enabled);\n\n        gsi = qemu_allocate_irqs(kvm_pc_gsi_handler, gsi_state,\n\n                                 GSI_NUM_PINS);\n\n    } else {\n\n        gsi = qemu_allocate_irqs(gsi_handler, gsi_state, GSI_NUM_PINS);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, &isa_bus, gsi,\n\n                              system_memory, system_io, ram_size,\n\n                              below_4g_mem_size,\n\n                              0x100000000ULL - below_4g_mem_size,\n\n                              0x100000000ULL + above_4g_mem_size,\n\n                              (sizeof(hwaddr) == 4\n\n                               ? 0\n\n                               : ((uint64_t)1 << 62)),\n\n                              pci_memory, ram_memory);\n\n    } else {\n\n        pci_bus = NULL;\n\n        i440fx_state = NULL;\n\n        isa_bus = isa_bus_new(NULL, system_io);\n\n        no_hpet = 1;\n\n    }\n\n    isa_bus_irqs(isa_bus, gsi);\n\n\n\n    if (kvm_irqchip_in_kernel()) {\n\n        i8259 = kvm_i8259_init(isa_bus);\n\n    } else if (xen_enabled()) {\n\n        i8259 = xen_interrupt_controller_init();\n\n    } else {\n\n        cpu_irq = pc_allocate_cpu_irq();\n\n        i8259 = i8259_init(isa_bus, cpu_irq[0]);\n\n    }\n\n\n\n    for (i = 0; i < ISA_NUM_IRQS; i++) {\n\n        gsi_state->i8259_irq[i] = i8259[i];\n\n    }\n\n    if (pci_enabled) {\n\n        ioapic_init_gsi(gsi_state, \"i440fx\");\n\n    }\n\n    qdev_init_nofail(icc_bridge);\n\n\n\n    pc_register_ferr_irq(gsi[13]);\n\n\n\n    pc_vga_init(isa_bus, pci_enabled ? pci_bus : NULL);\n\n    if (xen_enabled()) {\n\n        pci_create_simple(pci_bus, -1, \"xen-platform\");\n\n    }\n\n\n\n    /* init basic PC hardware */\n\n    pc_basic_device_init(isa_bus, gsi, &rtc_state, &floppy, xen_enabled());\n\n\n\n    pc_nic_init(isa_bus, pci_bus);\n\n\n\n    ide_drive_get(hd, MAX_IDE_BUS);\n\n    if (pci_enabled) {\n\n        PCIDevice *dev;\n\n        if (xen_enabled()) {\n\n            dev = pci_piix3_xen_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        } else {\n\n            dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        }\n\n        idebus[0] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\");\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            ISADevice *dev;\n\n            dev = isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i],\n\n                               ide_irq[i],\n\n                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n            idebus[i] = qdev_get_child_bus(DEVICE(dev), \"ide.0\");\n\n        }\n\n    }\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device,\n\n                 floppy, idebus[0], idebus[1], rtc_state);\n\n\n\n    if (pci_enabled && usb_enabled(false)) {\n\n        pci_create_simple(pci_bus, piix3_devfn + 2, \"piix3-usb-uhci\");\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        i2c_bus *smbus;\n\n\n\n        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt,\n\n                                     x86_env_get_cpu(first_cpu), 1);\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              gsi[9], *smi_irq,\n\n                              kvm_enabled(), fw_cfg);\n\n        smbus_eeprom_init(smbus, 8, NULL, 0);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n\n\n    if (has_pvpanic) {\n\n        pvpanic_init(isa_bus);\n\n    }\n\n}\n", "idx": 12310, "_split": "valid", "_hash": "ac26763f9746a81a2b03c3d82b4eb49d"}
{"project": "qemu", "commit_id": "ca6b6e1e68ac44b2e8895da10dd1c80dc03d08b7", "target": 0, "func": "static void test_visitor_out_alternate(TestOutputVisitorData *data,\n\n                                       const void *unused)\n\n{\n\n    QObject *arg;\n\n    UserDefAlternate *tmp;\n\n    QDict *qdict;\n\n\n\n    tmp = g_new0(UserDefAlternate, 1);\n\n    tmp->type = QTYPE_QINT;\n\n    tmp->u.i = 42;\n\n\n\n    visit_type_UserDefAlternate(data->ov, NULL, &tmp, &error_abort);\n\n    arg = visitor_get(data);\n\n\n\n    g_assert(qobject_type(arg) == QTYPE_QINT);\n\n    g_assert_cmpint(qint_get_int(qobject_to_qint(arg)), ==, 42);\n\n\n\n    qapi_free_UserDefAlternate(tmp);\n\n\n\n    visitor_reset(data);\n\n    tmp = g_new0(UserDefAlternate, 1);\n\n    tmp->type = QTYPE_QSTRING;\n\n    tmp->u.s = g_strdup(\"hello\");\n\n\n\n    visit_type_UserDefAlternate(data->ov, NULL, &tmp, &error_abort);\n\n    arg = visitor_get(data);\n\n\n\n    g_assert(qobject_type(arg) == QTYPE_QSTRING);\n\n    g_assert_cmpstr(qstring_get_str(qobject_to_qstring(arg)), ==, \"hello\");\n\n\n\n    qapi_free_UserDefAlternate(tmp);\n\n\n\n    visitor_reset(data);\n\n    tmp = g_new0(UserDefAlternate, 1);\n\n    tmp->type = QTYPE_QDICT;\n\n    tmp->u.udfu.integer = 1;\n\n    tmp->u.udfu.string = g_strdup(\"str\");\n\n    tmp->u.udfu.enum1 = ENUM_ONE_VALUE1;\n\n    tmp->u.udfu.u.value1.boolean = true;\n\n\n\n    visit_type_UserDefAlternate(data->ov, NULL, &tmp, &error_abort);\n\n    arg = visitor_get(data);\n\n\n\n    g_assert_cmpint(qobject_type(arg), ==, QTYPE_QDICT);\n\n    qdict = qobject_to_qdict(arg);\n\n    g_assert_cmpint(qdict_size(qdict), ==, 4);\n\n    g_assert_cmpint(qdict_get_int(qdict, \"integer\"), ==, 1);\n\n    g_assert_cmpstr(qdict_get_str(qdict, \"string\"), ==, \"str\");\n\n    g_assert_cmpstr(qdict_get_str(qdict, \"enum1\"), ==, \"value1\");\n\n    g_assert_cmpint(qdict_get_bool(qdict, \"boolean\"), ==, true);\n\n\n\n    qapi_free_UserDefAlternate(tmp);\n\n}\n", "idx": 12317, "_split": "valid", "_hash": "7d380267a6782ecdf64fb497a0e9a9ad"}
{"project": "qemu", "commit_id": "23482f8a603a7fc591b770c94ff75651a7da88b2", "target": 0, "func": "static int qcow2_discard_refcount_block(BlockDriverState *bs,\n\n                                        uint64_t discard_block_offs)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t refblock_offs = get_refblock_offset(s, discard_block_offs);\n\n    uint64_t cluster_index = discard_block_offs >> s->cluster_bits;\n\n    uint32_t block_index = cluster_index & (s->refcount_block_size - 1);\n\n    void *refblock;\n\n    int ret;\n\n\n\n    assert(discard_block_offs != 0);\n\n\n\n    ret = qcow2_cache_get(bs, s->refcount_block_cache, refblock_offs,\n\n                          &refblock);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (s->get_refcount(refblock, block_index) != 1) {\n\n        qcow2_signal_corruption(bs, true, -1, -1, \"Invalid refcount:\"\n\n                                \" refblock offset %#\" PRIx64\n\n                                \", reftable index %u\"\n\n                                \", block offset %#\" PRIx64\n\n                                \", refcount %#\" PRIx64,\n\n                                refblock_offs,\n\n                                offset_to_reftable_index(s, discard_block_offs),\n\n                                discard_block_offs,\n\n                                s->get_refcount(refblock, block_index));\n\n        qcow2_cache_put(bs, s->refcount_block_cache, &refblock);\n\n        return -EINVAL;\n\n    }\n\n    s->set_refcount(refblock, block_index, 0);\n\n\n\n    qcow2_cache_entry_mark_dirty(bs, s->refcount_block_cache, refblock);\n\n\n\n    qcow2_cache_put(bs, s->refcount_block_cache, &refblock);\n\n\n\n    if (cluster_index < s->free_cluster_index) {\n\n        s->free_cluster_index = cluster_index;\n\n    }\n\n\n\n    refblock = qcow2_cache_is_table_offset(bs, s->refcount_block_cache,\n\n                                           discard_block_offs);\n\n    if (refblock) {\n\n        /* discard refblock from the cache if refblock is cached */\n\n        qcow2_cache_discard(bs, s->refcount_block_cache, refblock);\n\n    }\n\n    update_refcount_discard(bs, discard_block_offs, s->cluster_size);\n\n\n\n    return 0;\n\n}\n", "idx": 12322, "_split": "valid", "_hash": "1f218df5adca4e53683ec54aeb630f39"}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_full_correct(void)\n\n{\n\n    const char *str = \"123\";\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, NULL, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 123);\n\n}\n", "idx": 12325, "_split": "valid", "_hash": "7e238ba144efae1d24e71573f21c5f6b"}
{"project": "qemu", "commit_id": "83e6813a93e38976391b8c382c3375e3e188df3e", "target": 0, "func": "static void arm_cpu_register_types(void)\n\n{\n\n    int i;\n\n\n\n    type_register_static(&arm_cpu_type_info);\n\n    for (i = 0; i < ARRAY_SIZE(arm_cpus); i++) {\n\n        cpu_register(&arm_cpus[i]);\n\n    }\n\n}\n", "idx": 12373, "_split": "valid", "_hash": "50ab83d85167f0414412de96e49b3263"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void gpio_write(void *opaque, target_phys_addr_t addr, uint64_t value,\n\n                       unsigned size)\n\n{\n\n    struct gpio_state_t *s = opaque;\n\n    D(printf(\"%s %x=%x\\n\", __func__, addr, (unsigned)value));\n\n\n\n    addr >>= 2;\n\n    switch (addr)\n\n    {\n\n        case RW_PA_DOUT:\n\n            /* Decode nand pins.  */\n\n            s->nand->ale = !!(value & (1 << 6));\n\n            s->nand->cle = !!(value & (1 << 5));\n\n            s->nand->ce  = !!(value & (1 << 4));\n\n\n\n            s->regs[addr] = value;\n\n            break;\n\n\n\n        case RW_PD_DOUT:\n\n            /* Temp sensor clk.  */\n\n            if ((s->regs[addr] ^ value) & 2)\n\n                tempsensor_clkedge(&s->tempsensor, !!(value & 2),\n\n                                   !!(value & 16));\n\n            s->regs[addr] = value;\n\n            break;\n\n\n\n        default:\n\n            s->regs[addr] = value;\n\n            break;\n\n    }\n\n}\n", "idx": 12375, "_split": "valid", "_hash": "1c3dcbcfc49fb588734a465bef2957f5"}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "static ssize_t eth_rx(NetClientState *nc, const uint8_t *buf, size_t size)\n\n{\n\n    XilinxAXIEnet *s = qemu_get_nic_opaque(nc);\n\n    static const unsigned char sa_bcast[6] = {0xff, 0xff, 0xff,\n\n                                              0xff, 0xff, 0xff};\n\n    static const unsigned char sa_ipmcast[3] = {0x01, 0x00, 0x52};\n\n    uint32_t app[6] = {0};\n\n    int promisc = s->fmi & (1 << 31);\n\n    int unicast, broadcast, multicast, ip_multicast = 0;\n\n    uint32_t csum32;\n\n    uint16_t csum16;\n\n    int i;\n\n\n\n    DENET(qemu_log(\"%s: %zd bytes\\n\", __func__, size));\n\n\n\n    unicast = ~buf[0] & 0x1;\n\n    broadcast = memcmp(buf, sa_bcast, 6) == 0;\n\n    multicast = !unicast && !broadcast;\n\n    if (multicast && (memcmp(sa_ipmcast, buf, sizeof sa_ipmcast) == 0)) {\n\n        ip_multicast = 1;\n\n    }\n\n\n\n    /* Jumbo or vlan sizes ?  */\n\n    if (!(s->rcw[1] & RCW1_JUM)) {\n\n        if (size > 1518 && size <= 1522 && !(s->rcw[1] & RCW1_VLAN)) {\n\n            return size;\n\n        }\n\n    }\n\n\n\n    /* Basic Address filters.  If you want to use the extended filters\n\n       you'll generally have to place the ethernet mac into promiscuous mode\n\n       to avoid the basic filtering from dropping most frames.  */\n\n    if (!promisc) {\n\n        if (unicast) {\n\n            if (!enet_match_addr(buf, s->uaw[0], s->uaw[1])) {\n\n                return size;\n\n            }\n\n        } else {\n\n            if (broadcast) {\n\n                /* Broadcast.  */\n\n                if (s->regs[R_RAF] & RAF_BCAST_REJ) {\n\n                    return size;\n\n                }\n\n            } else {\n\n                int drop = 1;\n\n\n\n                /* Multicast.  */\n\n                if (s->regs[R_RAF] & RAF_MCAST_REJ) {\n\n                    return size;\n\n                }\n\n\n\n                for (i = 0; i < 4; i++) {\n\n                    if (enet_match_addr(buf, s->maddr[i][0], s->maddr[i][1])) {\n\n                        drop = 0;\n\n                        break;\n\n                    }\n\n                }\n\n\n\n                if (drop) {\n\n                    return size;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    /* Extended mcast filtering enabled?  */\n\n    if (axienet_newfunc_enabled(s) && axienet_extmcf_enabled(s)) {\n\n        if (unicast) {\n\n            if (!enet_match_addr(buf, s->ext_uaw[0], s->ext_uaw[1])) {\n\n                return size;\n\n            }\n\n        } else {\n\n            if (broadcast) {\n\n                /* Broadcast. ???  */\n\n                if (s->regs[R_RAF] & RAF_BCAST_REJ) {\n\n                    return size;\n\n                }\n\n            } else {\n\n                int idx, bit;\n\n\n\n                /* Multicast.  */\n\n                if (!memcmp(buf, sa_ipmcast, 3)) {\n\n                    return size;\n\n                }\n\n\n\n                idx  = (buf[4] & 0x7f) << 8;\n\n                idx |= buf[5];\n\n\n\n                bit = 1 << (idx & 0x1f);\n\n                idx >>= 5;\n\n\n\n                if (!(s->ext_mtable[idx] & bit)) {\n\n                    return size;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if (size < 12) {\n\n        s->regs[R_IS] |= IS_RX_REJECT;\n\n        enet_update_irq(s);\n\n        return -1;\n\n    }\n\n\n\n    if (size > (s->c_rxmem - 4)) {\n\n        size = s->c_rxmem - 4;\n\n    }\n\n\n\n    memcpy(s->rxmem, buf, size);\n\n    memset(s->rxmem + size, 0, 4); /* Clear the FCS.  */\n\n\n\n    if (s->rcw[1] & RCW1_FCS) {\n\n        size += 4; /* fcs is inband.  */\n\n    }\n\n\n\n    app[0] = 5 << 28;\n\n    csum32 = net_checksum_add(size - 14, (uint8_t *)s->rxmem + 14);\n\n    /* Fold it once.  */\n\n    csum32 = (csum32 & 0xffff) + (csum32 >> 16);\n\n    /* And twice to get rid of possible carries.  */\n\n    csum16 = (csum32 & 0xffff) + (csum32 >> 16);\n\n    app[3] = csum16;\n\n    app[4] = size & 0xffff;\n\n\n\n    s->stats.rx_bytes += size;\n\n    s->stats.rx++;\n\n    if (multicast) {\n\n        s->stats.rx_mcast++;\n\n        app[2] |= 1 | (ip_multicast << 1);\n\n    } else if (broadcast) {\n\n        s->stats.rx_bcast++;\n\n        app[2] |= 1 << 3;\n\n    }\n\n\n\n    /* Good frame.  */\n\n    app[2] |= 1 << 6;\n\n\n\n    s->rxsize = size;\n\n    s->rxpos = 0;\n\n    s->rxapp = g_memdup(app, sizeof(app));\n\n    axienet_eth_rx_notify(s);\n\n\n\n    enet_update_irq(s);\n\n    return size;\n\n}\n", "idx": 12379, "_split": "valid", "_hash": "d8c972a70aaeb151132dcbbdbab56bae"}
{"project": "qemu", "commit_id": "b8e9fc0625c49404d63b4391f6dc5cf27be8b45b", "target": 0, "func": "static int get_physical_address_code(CPUState *env,\n\n                                     target_phys_addr_t *physical, int *prot,\n\n                                     target_ulong address, int mmu_idx)\n\n{\n\n    unsigned int i;\n\n    uint64_t context;\n\n\n\n    int is_user = (mmu_idx == MMU_USER_IDX ||\n\n                   mmu_idx == MMU_USER_SECONDARY_IDX);\n\n\n\n    if ((env->lsu & IMMU_E) == 0 || (env->pstate & PS_RED) != 0) {\n\n        /* IMMU disabled */\n\n        *physical = ultrasparc_truncate_physical(address);\n\n        *prot = PAGE_EXEC;\n\n        return 0;\n\n    }\n\n\n\n    if (env->tl == 0) {\n\n        /* PRIMARY context */\n\n        context = env->dmmu.mmu_primary_context & 0x1fff;\n\n    } else {\n\n        /* NUCLEUS context */\n\n        context = 0;\n\n    }\n\n\n\n    for (i = 0; i < 64; i++) {\n\n        // ctx match, vaddr match, valid?\n\n        if (ultrasparc_tag_match(&env->itlb[i],\n\n                                 address, context, physical)) {\n\n            // access ok?\n\n            if ((env->itlb[i].tte & 0x4) && is_user) {\n\n                if (env->immu.sfsr) /* Fault status register */\n\n                    env->immu.sfsr = 2; /* overflow (not read before\n\n                                             another fault) */\n\n                env->immu.sfsr |= (is_user << 3) | 1;\n\n                env->exception_index = TT_TFAULT;\n\n#ifdef DEBUG_MMU\n\n                printf(\"TFAULT at 0x%\" PRIx64 \"\\n\", address);\n\n#endif\n\n                return 1;\n\n            }\n\n            *prot = PAGE_EXEC;\n\n            TTE_SET_USED(env->itlb[i].tte);\n\n            return 0;\n\n        }\n\n    }\n\n#ifdef DEBUG_MMU\n\n    printf(\"TMISS at 0x%\" PRIx64 \"\\n\", address);\n\n#endif\n\n    /* Context is stored in DMMU (dmmuregs[1]) also for IMMU */\n\n    env->immu.tag_access = (address & ~0x1fffULL) | context;\n\n    env->exception_index = TT_TMISS;\n\n    return 1;\n\n}\n", "idx": 12386, "_split": "valid", "_hash": "b70759179e4cb8c015b9d64734b75fb2"}
{"project": "qemu", "commit_id": "3f66aa9c07d6392757f9d7b83849c7f791981725", "target": 1, "func": "ISADevice *isa_create_simple(const char *name)\n\n{\n\n    ISADevice *dev;\n\n\n\n    dev = isa_create(name);\n\n    if (qdev_init(&dev->qdev) != 0) {\n\n        return NULL;\n\n    }\n\n    return dev;\n\n}\n", "idx": 12426, "_split": "valid", "_hash": "ca43509b376334eec5cf0348a22f39c6"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "envlist_create(void)\n\n{\n\n\tenvlist_t *envlist;\n\n\n\n\tif ((envlist = malloc(sizeof (*envlist))) == NULL)\n\n\t\treturn (NULL);\n\n\n\n\tLIST_INIT(&envlist->el_entries);\n\n\tenvlist->el_count = 0;\n\n\n\n\treturn (envlist);\n\n}\n", "idx": 12440, "_split": "valid", "_hash": "88235cdac9fac165fd32aa995502d511"}
{"project": "qemu", "commit_id": "0d82d0e8b98cf0ea03a45f8542d835ebd3a84cd3", "target": 0, "func": "void qemu_fopen_ops_buffered(MigrationState *migration_state)\n\n{\n\n    QEMUFileBuffered *s;\n\n\n\n    s = g_malloc0(sizeof(*s));\n\n\n\n    s->migration_state = migration_state;\n\n    s->xfer_limit = migration_state->bandwidth_limit / 10;\n\n    s->migration_state->complete = false;\n\n\n\n    s->file = qemu_fopen_ops(s, &buffered_file_ops);\n\n\n\n    migration_state->file = s->file;\n\n\n\n    qemu_thread_create(&s->thread, buffered_file_thread, s,\n\n                       QEMU_THREAD_DETACHED);\n\n}\n", "idx": 12446, "_split": "valid", "_hash": "6e515f2e03d2dcbb018ff6f3320cc37a"}
{"project": "qemu", "commit_id": "943cec86d0864464ab29b42940c49d1ccbe8d268", "target": 0, "func": "static int nbd_negotiate_handle_export_name(NBDClient *client, uint32_t length)\n\n{\n\n    int rc = -EINVAL;\n\n    char name[256];\n\n\n\n    /* Client sends:\n\n        [20 ..  xx]   export name (length bytes)\n\n     */\n\n    TRACE(\"Checking length\");\n\n    if (length > 255) {\n\n        LOG(\"Bad length received\");\n\n        goto fail;\n\n    }\n\n    if (nbd_negotiate_read(client->ioc, name, length) != length) {\n\n        LOG(\"read failed\");\n\n        goto fail;\n\n    }\n\n    name[length] = '\\0';\n\n\n\n    TRACE(\"Client requested export '%s'\", name);\n\n\n\n    client->exp = nbd_export_find(name);\n\n    if (!client->exp) {\n\n        LOG(\"export not found\");\n\n        goto fail;\n\n    }\n\n\n\n    QTAILQ_INSERT_TAIL(&client->exp->clients, client, next);\n\n    nbd_export_get(client->exp);\n\n    rc = 0;\n\nfail:\n\n    return rc;\n\n}\n", "idx": 12485, "_split": "valid", "_hash": "f97418c4363957726c0df169f371cc2a"}
{"project": "qemu", "commit_id": "78dbbbe4dff95369c63bf77ee0df23371e1d6602", "target": 1, "func": "static inline bool extended_addresses_enabled(CPUARMState *env)\n\n{\n\n    return arm_feature(env, ARM_FEATURE_LPAE)\n\n        && (env->cp15.c2_control & (1 << 31));\n\n}\n", "idx": 12522, "_split": "valid", "_hash": "14951b9f4b7583e282115df80d4f9eb8"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "uint64_t migrate_max_downtime(void)\n\n{\n\n    return max_downtime;\n\n}\n", "idx": 12567, "_split": "valid", "_hash": "9d2cd74883c5a566d26ef43f4b010ad3"}
{"project": "qemu", "commit_id": "80f5ce758ac277e76c016dd7c0b246e40d4fca2d", "target": 0, "func": "static void fill_note(struct memelfnote *note, const char *name, int type,\n\n                      unsigned int sz, void *data)\n\n{\n\n    unsigned int namesz;\n\n\n\n    namesz = strlen(name) + 1;\n\n    note->name = name;\n\n    note->namesz = namesz;\n\n    note->namesz_rounded = roundup(namesz, sizeof (int32_t));\n\n    note->type = type;\n\n    note->datasz = roundup(sz, sizeof (int32_t));;\n\n    note->data = data;\n\n\n\n    /*\n\n     * We calculate rounded up note size here as specified by\n\n     * ELF document.\n\n     */\n\n    note->notesz = sizeof (struct elf_note) +\n\n        note->namesz_rounded + note->datasz;\n\n}\n", "idx": 12628, "_split": "valid", "_hash": "8588eab70e26e42882cb19ba74772bb2"}
{"project": "qemu", "commit_id": "de08c606f9ddafe647b6843e2b10a6d6030b0fc0", "target": 0, "func": "int bdrv_snapshot_goto(BlockDriverState *bs,\n\n                       const char *snapshot_id)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    int ret, open_ret;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n    if (drv->bdrv_snapshot_goto)\n\n        return drv->bdrv_snapshot_goto(bs, snapshot_id);\n\n\n\n    if (bs->file) {\n\n        drv->bdrv_close(bs);\n\n        ret = bdrv_snapshot_goto(bs->file, snapshot_id);\n\n        open_ret = drv->bdrv_open(bs, NULL, bs->open_flags);\n\n        if (open_ret < 0) {\n\n            bdrv_delete(bs->file);\n\n            bs->drv = NULL;\n\n            return open_ret;\n\n        }\n\n        return ret;\n\n    }\n\n\n\n    return -ENOTSUP;\n\n}\n", "idx": 12648, "_split": "valid", "_hash": "18eb7b9d9b31591491120317bc387065"}
{"project": "qemu", "commit_id": "c021db86a4968f456f6365eab158107c131df22e", "target": 0, "func": "static void lsi_execute_script(LSIState *s)\n\n{\n\n    uint32_t insn;\n\n    uint32_t addr, addr_high;\n\n    int opcode;\n\n    int insn_processed = 0;\n\n\n\n    s->istat1 |= LSI_ISTAT1_SRUN;\n\nagain:\n\n    insn_processed++;\n\n    insn = read_dword(s, s->dsp);\n\n    addr = read_dword(s, s->dsp + 4);\n\n    addr_high = 0;\n\n    DPRINTF(\"SCRIPTS dsp=%08x opcode %08x arg %08x\\n\", s->dsp, insn, addr);\n\n    s->dsps = addr;\n\n    s->dcmd = insn >> 24;\n\n    s->dsp += 8;\n\n    switch (insn >> 30) {\n\n    case 0: /* Block move.  */\n\n        if (s->sist1 & LSI_SIST1_STO) {\n\n            DPRINTF(\"Delayed select timeout\\n\");\n\n            lsi_stop_script(s);\n\n            break;\n\n        }\n\n        s->dbc = insn & 0xffffff;\n\n        s->rbc = s->dbc;\n\n        if (insn & (1 << 29)) {\n\n            /* Indirect addressing.  */\n\n            addr = read_dword(s, addr);\n\n        } else if (insn & (1 << 28)) {\n\n            uint32_t buf[2];\n\n            int32_t offset;\n\n            /* Table indirect addressing.  */\n\n            offset = sxt24(addr);\n\n            cpu_physical_memory_read(s->dsa + offset, (uint8_t *)buf, 8);\n\n            /* byte count is stored in bits 0:23 only */\n\n            s->dbc = cpu_to_le32(buf[0]) & 0xffffff;\n\n            s->rbc = s->dbc;\n\n            addr = cpu_to_le32(buf[1]);\n\n\n\n            /* 40-bit DMA, upper addr bits [39:32] stored in first DWORD of\n\n             * table, bits [31:24] */\n\n            if (lsi_dma_40bit(s))\n\n                addr_high = cpu_to_le32(buf[0]) >> 24;\n\n        }\n\n        if ((s->sstat1 & PHASE_MASK) != ((insn >> 24) & 7)) {\n\n            DPRINTF(\"Wrong phase got %d expected %d\\n\",\n\n                    s->sstat1 & PHASE_MASK, (insn >> 24) & 7);\n\n            lsi_script_scsi_interrupt(s, LSI_SIST0_MA, 0);\n\n            break;\n\n        }\n\n        s->dnad = addr;\n\n        s->dnad64 = addr_high;\n\n        /* ??? Set ESA.  */\n\n        s->ia = s->dsp - 8;\n\n        switch (s->sstat1 & 0x7) {\n\n        case PHASE_DO:\n\n            s->waiting = 2;\n\n            lsi_do_dma(s, 1);\n\n            if (s->waiting)\n\n                s->waiting = 3;\n\n            break;\n\n        case PHASE_DI:\n\n            s->waiting = 2;\n\n            s->current_dma_len = s->dbc;\n\n            lsi_do_dma(s, 0);\n\n            if (s->waiting)\n\n                s->waiting = 3;\n\n            break;\n\n        case PHASE_CMD:\n\n            lsi_do_command(s);\n\n            break;\n\n        case PHASE_ST:\n\n            lsi_do_status(s);\n\n            break;\n\n        case PHASE_MO:\n\n            lsi_do_msgout(s);\n\n            break;\n\n        case PHASE_MI:\n\n            lsi_do_msgin(s);\n\n            break;\n\n        default:\n\n            BADF(\"Unimplemented phase %d\\n\", s->sstat1 & PHASE_MASK);\n\n            exit(1);\n\n        }\n\n        s->dfifo = s->dbc & 0xff;\n\n        s->ctest5 = (s->ctest5 & 0xfc) | ((s->dbc >> 8) & 3);\n\n        s->sbc = s->dbc;\n\n        s->rbc -= s->dbc;\n\n        s->ua = addr + s->dbc;\n\n        break;\n\n\n\n    case 1: /* IO or Read/Write instruction.  */\n\n        opcode = (insn >> 27) & 7;\n\n        if (opcode < 5) {\n\n            uint32_t id;\n\n\n\n            if (insn & (1 << 25)) {\n\n                id = read_dword(s, s->dsa + sxt24(insn));\n\n            } else {\n\n                id = addr;\n\n            }\n\n            id = (id >> 16) & 0xf;\n\n            if (insn & (1 << 26)) {\n\n                addr = s->dsp + sxt24(addr);\n\n            }\n\n            s->dnad = addr;\n\n            switch (opcode) {\n\n            case 0: /* Select */\n\n                s->sdid = id;\n\n                if (s->current_dma_len && (s->ssid & 0xf) == id) {\n\n                    DPRINTF(\"Already reselected by target %d\\n\", id);\n\n                    break;\n\n                }\n\n                s->sstat0 |= LSI_SSTAT0_WOA;\n\n                s->scntl1 &= ~LSI_SCNTL1_IARB;\n\n                if (id >= LSI_MAX_DEVS || !s->scsi_dev[id]) {\n\n                    DPRINTF(\"Selected absent target %d\\n\", id);\n\n                    lsi_script_scsi_interrupt(s, 0, LSI_SIST1_STO);\n\n                    lsi_disconnect(s);\n\n                    break;\n\n                }\n\n                DPRINTF(\"Selected target %d%s\\n\",\n\n                        id, insn & (1 << 3) ? \" ATN\" : \"\");\n\n                /* ??? Linux drivers compain when this is set.  Maybe\n\n                   it only applies in low-level mode (unimplemented).\n\n                lsi_script_scsi_interrupt(s, LSI_SIST0_CMP, 0); */\n\n                s->current_dev = s->scsi_dev[id];\n\n                s->current_tag = id << 8;\n\n                s->scntl1 |= LSI_SCNTL1_CON;\n\n                if (insn & (1 << 3)) {\n\n                    s->socl |= LSI_SOCL_ATN;\n\n                }\n\n                lsi_set_phase(s, PHASE_MO);\n\n                break;\n\n            case 1: /* Disconnect */\n\n                DPRINTF(\"Wait Disconect\\n\");\n\n                s->scntl1 &= ~LSI_SCNTL1_CON;\n\n                break;\n\n            case 2: /* Wait Reselect */\n\n                lsi_wait_reselect(s);\n\n                break;\n\n            case 3: /* Set */\n\n                DPRINTF(\"Set%s%s%s%s\\n\",\n\n                        insn & (1 << 3) ? \" ATN\" : \"\",\n\n                        insn & (1 << 6) ? \" ACK\" : \"\",\n\n                        insn & (1 << 9) ? \" TM\" : \"\",\n\n                        insn & (1 << 10) ? \" CC\" : \"\");\n\n                if (insn & (1 << 3)) {\n\n                    s->socl |= LSI_SOCL_ATN;\n\n                    lsi_set_phase(s, PHASE_MO);\n\n                }\n\n                if (insn & (1 << 9)) {\n\n                    BADF(\"Target mode not implemented\\n\");\n\n                    exit(1);\n\n                }\n\n                if (insn & (1 << 10))\n\n                    s->carry = 1;\n\n                break;\n\n            case 4: /* Clear */\n\n                DPRINTF(\"Clear%s%s%s%s\\n\",\n\n                        insn & (1 << 3) ? \" ATN\" : \"\",\n\n                        insn & (1 << 6) ? \" ACK\" : \"\",\n\n                        insn & (1 << 9) ? \" TM\" : \"\",\n\n                        insn & (1 << 10) ? \" CC\" : \"\");\n\n                if (insn & (1 << 3)) {\n\n                    s->socl &= ~LSI_SOCL_ATN;\n\n                }\n\n                if (insn & (1 << 10))\n\n                    s->carry = 0;\n\n                break;\n\n            }\n\n        } else {\n\n            uint8_t op0;\n\n            uint8_t op1;\n\n            uint8_t data8;\n\n            int reg;\n\n            int operator;\n\n#ifdef DEBUG_LSI\n\n            static const char *opcode_names[3] =\n\n                {\"Write\", \"Read\", \"Read-Modify-Write\"};\n\n            static const char *operator_names[8] =\n\n                {\"MOV\", \"SHL\", \"OR\", \"XOR\", \"AND\", \"SHR\", \"ADD\", \"ADC\"};\n\n#endif\n\n\n\n            reg = ((insn >> 16) & 0x7f) | (insn & 0x80);\n\n            data8 = (insn >> 8) & 0xff;\n\n            opcode = (insn >> 27) & 7;\n\n            operator = (insn >> 24) & 7;\n\n            DPRINTF(\"%s reg 0x%x %s data8=0x%02x sfbr=0x%02x%s\\n\",\n\n                    opcode_names[opcode - 5], reg,\n\n                    operator_names[operator], data8, s->sfbr,\n\n                    (insn & (1 << 23)) ? \" SFBR\" : \"\");\n\n            op0 = op1 = 0;\n\n            switch (opcode) {\n\n            case 5: /* From SFBR */\n\n                op0 = s->sfbr;\n\n                op1 = data8;\n\n                break;\n\n            case 6: /* To SFBR */\n\n                if (operator)\n\n                    op0 = lsi_reg_readb(s, reg);\n\n                op1 = data8;\n\n                break;\n\n            case 7: /* Read-modify-write */\n\n                if (operator)\n\n                    op0 = lsi_reg_readb(s, reg);\n\n                if (insn & (1 << 23)) {\n\n                    op1 = s->sfbr;\n\n                } else {\n\n                    op1 = data8;\n\n                }\n\n                break;\n\n            }\n\n\n\n            switch (operator) {\n\n            case 0: /* move */\n\n                op0 = op1;\n\n                break;\n\n            case 1: /* Shift left */\n\n                op1 = op0 >> 7;\n\n                op0 = (op0 << 1) | s->carry;\n\n                s->carry = op1;\n\n                break;\n\n            case 2: /* OR */\n\n                op0 |= op1;\n\n                break;\n\n            case 3: /* XOR */\n\n                op0 ^= op1;\n\n                break;\n\n            case 4: /* AND */\n\n                op0 &= op1;\n\n                break;\n\n            case 5: /* SHR */\n\n                op1 = op0 & 1;\n\n                op0 = (op0 >> 1) | (s->carry << 7);\n\n                s->carry = op1;\n\n                break;\n\n            case 6: /* ADD */\n\n                op0 += op1;\n\n                s->carry = op0 < op1;\n\n                break;\n\n            case 7: /* ADC */\n\n                op0 += op1 + s->carry;\n\n                if (s->carry)\n\n                    s->carry = op0 <= op1;\n\n                else\n\n                    s->carry = op0 < op1;\n\n                break;\n\n            }\n\n\n\n            switch (opcode) {\n\n            case 5: /* From SFBR */\n\n            case 7: /* Read-modify-write */\n\n                lsi_reg_writeb(s, reg, op0);\n\n                break;\n\n            case 6: /* To SFBR */\n\n                s->sfbr = op0;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 2: /* Transfer Control.  */\n\n        {\n\n            int cond;\n\n            int jmp;\n\n\n\n            if ((insn & 0x002e0000) == 0) {\n\n                DPRINTF(\"NOP\\n\");\n\n                break;\n\n            }\n\n            if (s->sist1 & LSI_SIST1_STO) {\n\n                DPRINTF(\"Delayed select timeout\\n\");\n\n                lsi_stop_script(s);\n\n                break;\n\n            }\n\n            cond = jmp = (insn & (1 << 19)) != 0;\n\n            if (cond == jmp && (insn & (1 << 21))) {\n\n                DPRINTF(\"Compare carry %d\\n\", s->carry == jmp);\n\n                cond = s->carry != 0;\n\n            }\n\n            if (cond == jmp && (insn & (1 << 17))) {\n\n                DPRINTF(\"Compare phase %d %c= %d\\n\",\n\n                        (s->sstat1 & PHASE_MASK),\n\n                        jmp ? '=' : '!',\n\n                        ((insn >> 24) & 7));\n\n                cond = (s->sstat1 & PHASE_MASK) == ((insn >> 24) & 7);\n\n            }\n\n            if (cond == jmp && (insn & (1 << 18))) {\n\n                uint8_t mask;\n\n\n\n                mask = (~insn >> 8) & 0xff;\n\n                DPRINTF(\"Compare data 0x%x & 0x%x %c= 0x%x\\n\",\n\n                        s->sfbr, mask, jmp ? '=' : '!', insn & mask);\n\n                cond = (s->sfbr & mask) == (insn & mask);\n\n            }\n\n            if (cond == jmp) {\n\n                if (insn & (1 << 23)) {\n\n                    /* Relative address.  */\n\n                    addr = s->dsp + sxt24(addr);\n\n                }\n\n                switch ((insn >> 27) & 7) {\n\n                case 0: /* Jump */\n\n                    DPRINTF(\"Jump to 0x%08x\\n\", addr);\n\n                    s->dsp = addr;\n\n                    break;\n\n                case 1: /* Call */\n\n                    DPRINTF(\"Call 0x%08x\\n\", addr);\n\n                    s->temp = s->dsp;\n\n                    s->dsp = addr;\n\n                    break;\n\n                case 2: /* Return */\n\n                    DPRINTF(\"Return to 0x%08x\\n\", s->temp);\n\n                    s->dsp = s->temp;\n\n                    break;\n\n                case 3: /* Interrupt */\n\n                    DPRINTF(\"Interrupt 0x%08x\\n\", s->dsps);\n\n                    if ((insn & (1 << 20)) != 0) {\n\n                        s->istat0 |= LSI_ISTAT0_INTF;\n\n                        lsi_update_irq(s);\n\n                    } else {\n\n                        lsi_script_dma_interrupt(s, LSI_DSTAT_SIR);\n\n                    }\n\n                    break;\n\n                default:\n\n                    DPRINTF(\"Illegal transfer control\\n\");\n\n                    lsi_script_dma_interrupt(s, LSI_DSTAT_IID);\n\n                    break;\n\n                }\n\n            } else {\n\n                DPRINTF(\"Control condition failed\\n\");\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 3:\n\n        if ((insn & (1 << 29)) == 0) {\n\n            /* Memory move.  */\n\n            uint32_t dest;\n\n            /* ??? The docs imply the destination address is loaded into\n\n               the TEMP register.  However the Linux drivers rely on\n\n               the value being presrved.  */\n\n            dest = read_dword(s, s->dsp);\n\n            s->dsp += 4;\n\n            lsi_memcpy(s, dest, addr, insn & 0xffffff);\n\n        } else {\n\n            uint8_t data[7];\n\n            int reg;\n\n            int n;\n\n            int i;\n\n\n\n            if (insn & (1 << 28)) {\n\n                addr = s->dsa + sxt24(addr);\n\n            }\n\n            n = (insn & 7);\n\n            reg = (insn >> 16) & 0xff;\n\n            if (insn & (1 << 24)) {\n\n                cpu_physical_memory_read(addr, data, n);\n\n                DPRINTF(\"Load reg 0x%x size %d addr 0x%08x = %08x\\n\", reg, n,\n\n                        addr, *(int *)data);\n\n                for (i = 0; i < n; i++) {\n\n                    lsi_reg_writeb(s, reg + i, data[i]);\n\n                }\n\n            } else {\n\n                DPRINTF(\"Store reg 0x%x size %d addr 0x%08x\\n\", reg, n, addr);\n\n                for (i = 0; i < n; i++) {\n\n                    data[i] = lsi_reg_readb(s, reg + i);\n\n                }\n\n                cpu_physical_memory_write(addr, data, n);\n\n            }\n\n        }\n\n    }\n\n    if (insn_processed > 10000 && !s->waiting) {\n\n        /* Some windows drivers make the device spin waiting for a memory\n\n           location to change.  If we have been executed a lot of code then\n\n           assume this is the case and force an unexpected device disconnect.\n\n           This is apparently sufficient to beat the drivers into submission.\n\n         */\n\n        if (!(s->sien0 & LSI_SIST0_UDC))\n\n            fprintf(stderr, \"inf. loop with UDC masked\\n\");\n\n        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);\n\n        lsi_disconnect(s);\n\n    } else if (s->istat1 & LSI_ISTAT1_SRUN && !s->waiting) {\n\n        if (s->dcntl & LSI_DCNTL_SSM) {\n\n            lsi_script_dma_interrupt(s, LSI_DSTAT_SSI);\n\n        } else {\n\n            goto again;\n\n        }\n\n    }\n\n    DPRINTF(\"SCRIPTS execution stopped\\n\");\n\n}\n", "idx": 12664, "_split": "valid", "_hash": "4285facd39765acbccff986a54b149a8"}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void kqemu_update_cpuid(CPUState *env)\n\n{\n\n    int critical_features_mask, features, ext_features, ext_features_mask;\n\n    uint32_t eax, ebx, ecx, edx;\n\n\n\n    /* the following features are kept identical on the host and\n\n       target cpus because they are important for user code. Strictly\n\n       speaking, only SSE really matters because the OS must support\n\n       it if the user code uses it. */\n\n    critical_features_mask =\n\n        CPUID_CMOV | CPUID_CX8 |\n\n        CPUID_FXSR | CPUID_MMX | CPUID_SSE |\n\n        CPUID_SSE2 | CPUID_SEP;\n\n    ext_features_mask = CPUID_EXT_SSE3 | CPUID_EXT_MONITOR;\n\n    if (!is_cpuid_supported()) {\n\n        features = 0;\n\n        ext_features = 0;\n\n    } else {\n\n        cpuid(1, eax, ebx, ecx, edx);\n\n        features = edx;\n\n        ext_features = ecx;\n\n    }\n\n#ifdef __x86_64__\n\n    /* NOTE: on x86_64 CPUs, SYSENTER is not supported in\n\n       compatibility mode, so in order to have the best performances\n\n       it is better not to use it */\n\n    features &= ~CPUID_SEP;\n\n#endif\n\n    env->cpuid_features = (env->cpuid_features & ~critical_features_mask) |\n\n        (features & critical_features_mask);\n\n    env->cpuid_ext_features = (env->cpuid_ext_features & ~ext_features_mask) |\n\n        (ext_features & ext_features_mask);\n\n    /* XXX: we could update more of the target CPUID state so that the\n\n       non accelerated code sees exactly the same CPU features as the\n\n       accelerated code */\n\n}\n", "idx": 12666, "_split": "valid", "_hash": "40b965ed72f3a3f1e78eb8322022c6ad"}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "static GenericList *qapi_dealloc_next_list(Visitor *v, GenericList **listp,\n\n                                           size_t size)\n\n{\n\n    GenericList *list = *listp;\n\n    QapiDeallocVisitor *qov = to_qov(v);\n\n    StackEntry *e = QTAILQ_FIRST(&qov->stack);\n\n\n\n    if (e && e->is_list_head) {\n\n        e->is_list_head = false;\n\n        return list;\n\n    }\n\n\n\n    if (list) {\n\n        list = list->next;\n\n        g_free(*listp);\n\n        return list;\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 12671, "_split": "valid", "_hash": "c828b518822396ee81b0839255ed9547"}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "static void qbool_destroy_obj(QObject *obj)\n\n{\n\n    assert(obj != NULL);\n\n    g_free(qobject_to_qbool(obj));\n\n}\n", "idx": 12674, "_split": "valid", "_hash": "ebf05b988176da2284cf58fc7ee06902"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static QemuOpt *qemu_opt_find(QemuOpts *opts, const char *name)\n\n{\n\n    QemuOpt *opt;\n\n\n\n    TAILQ_FOREACH(opt, &opts->head, next) {\n\n        if (strcmp(opt->name, name) != 0)\n\n            continue;\n\n        return opt;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 12685, "_split": "valid", "_hash": "75c456d07c70555d21d2c1a866f44d78"}
{"project": "qemu", "commit_id": "a4d2d1a063897b859b7f25e414b229370b679bc8", "target": 0, "func": "uint64_t helper_cmptun (uint64_t a, uint64_t b)\n\n{\n\n    float64 fa, fb;\n\n\n\n    fa = t_to_float64(a);\n\n    fb = t_to_float64(b);\n\n\n\n    if (float64_is_quiet_nan(fa) || float64_is_quiet_nan(fb))\n\n        return 0x4000000000000000ULL;\n\n    else\n\n        return 0;\n\n}\n", "idx": 12702, "_split": "valid", "_hash": "bed2389039eaf7cb711c25929a0bee17"}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "Aml *aml_arg(int pos)\n\n{\n\n    Aml *var;\n\n    uint8_t op = 0x68 /* ARG0 op */ + pos;\n\n\n\n    assert(pos <= 6);\n\n    var = aml_opcode(op);\n\n    return var;\n\n}\n", "idx": 12727, "_split": "valid", "_hash": "0a65deefa0112604a1a3358c2dde6723"}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static int vnc_display_listen_addr(VncDisplay *vd,\n\n                                   SocketAddressLegacy *addr,\n\n                                   const char *name,\n\n                                   QIOChannelSocket ***lsock,\n\n                                   guint **lsock_tag,\n\n                                   size_t *nlsock,\n\n                                   Error **errp)\n\n{\n\n    QIODNSResolver *resolver = qio_dns_resolver_get_instance();\n\n    SocketAddressLegacy **rawaddrs = NULL;\n\n    size_t nrawaddrs = 0;\n\n    Error *listenerr = NULL;\n\n    bool listening = false;\n\n    size_t i;\n\n\n\n    if (qio_dns_resolver_lookup_sync(resolver, addr, &nrawaddrs,\n\n                                     &rawaddrs, errp) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    for (i = 0; i < nrawaddrs; i++) {\n\n        QIOChannelSocket *sioc = qio_channel_socket_new();\n\n\n\n        qio_channel_set_name(QIO_CHANNEL(sioc), name);\n\n        if (qio_channel_socket_listen_sync(\n\n                sioc, rawaddrs[i], listenerr == NULL ? &listenerr : NULL) < 0) {\n\n            object_unref(OBJECT(sioc));\n\n            continue;\n\n        }\n\n        listening = true;\n\n        (*nlsock)++;\n\n        *lsock = g_renew(QIOChannelSocket *, *lsock, *nlsock);\n\n        *lsock_tag = g_renew(guint, *lsock_tag, *nlsock);\n\n\n\n        (*lsock)[*nlsock - 1] = sioc;\n\n        (*lsock_tag)[*nlsock - 1] = 0;\n\n    }\n\n\n\n    for (i = 0; i < nrawaddrs; i++) {\n\n        qapi_free_SocketAddressLegacy(rawaddrs[i]);\n\n    }\n\n    g_free(rawaddrs);\n\n\n\n    if (listenerr) {\n\n        if (!listening) {\n\n            error_propagate(errp, listenerr);\n\n            return -1;\n\n        } else {\n\n            error_free(listenerr);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < *nlsock; i++) {\n\n        (*lsock_tag)[i] = qio_channel_add_watch(\n\n            QIO_CHANNEL((*lsock)[i]),\n\n            G_IO_IN, vnc_listen_io, vd, NULL);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12745, "_split": "valid", "_hash": "4cc8ecfc10138901ab635a67c6593acb"}
{"project": "qemu", "commit_id": "c11e80e299e57c64934c164b231fa0d4279db445", "target": 0, "func": "static void OPLWriteReg(FM_OPL *OPL, int r, int v)\n\n{\n\n\tOPL_CH *CH;\n\n\tint slot;\n\n\tint block_fnum;\n\n\n\n\tswitch(r&0xe0)\n\n\t{\n\n\tcase 0x00: /* 00-1f:control */\n\n\t\tswitch(r&0x1f)\n\n\t\t{\n\n\t\tcase 0x01:\n\n\t\t\t/* wave selector enable */\n\n\t\t\tif(OPL->type&OPL_TYPE_WAVESEL)\n\n\t\t\t{\n\n\t\t\t\tOPL->wavesel = v&0x20;\n\n\t\t\t\tif(!OPL->wavesel)\n\n\t\t\t\t{\n\n\t\t\t\t\t/* preset compatible mode */\n\n\t\t\t\t\tint c;\n\n\t\t\t\t\tfor(c=0;c<OPL->max_ch;c++)\n\n\t\t\t\t\t{\n\n\t\t\t\t\t\tOPL->P_CH[c].SLOT[SLOT1].wavetable = &SIN_TABLE[0];\n\n\t\t\t\t\t\tOPL->P_CH[c].SLOT[SLOT2].wavetable = &SIN_TABLE[0];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\tcase 0x02:\t/* Timer 1 */\n\n\t\t\tOPL->T[0] = (256-v)*4;\n\n\t\t\tbreak;\n\n\t\tcase 0x03:\t/* Timer 2 */\n\n\t\t\tOPL->T[1] = (256-v)*16;\n\n\t\t\treturn;\n\n\t\tcase 0x04:\t/* IRQ clear / mask and Timer enable */\n\n\t\t\tif(v&0x80)\n\n\t\t\t{\t/* IRQ flag clear */\n\n\t\t\t\tOPL_STATUS_RESET(OPL,0x7f);\n\n\t\t\t}\n\n\t\t\telse\n\n\t\t\t{\t/* set IRQ mask ,timer enable*/\n\n\t\t\t\tUINT8 st1 = v&1;\n\n\t\t\t\tUINT8 st2 = (v>>1)&1;\n\n\t\t\t\t/* IRQRST,T1MSK,t2MSK,EOSMSK,BRMSK,x,ST2,ST1 */\n\n\t\t\t\tOPL_STATUS_RESET(OPL,v&0x78);\n\n\t\t\t\tOPL_STATUSMASK_SET(OPL,((~v)&0x78)|0x01);\n\n\t\t\t\t/* timer 2 */\n\n\t\t\t\tif(OPL->st[1] != st2)\n\n\t\t\t\t{\n\n\t\t\t\t\tdouble interval = st2 ? (double)OPL->T[1]*OPL->TimerBase : 0.0;\n\n\t\t\t\t\tOPL->st[1] = st2;\n\n\t\t\t\t\tif (OPL->TimerHandler) (OPL->TimerHandler)(OPL->TimerParam+1,interval);\n\n\t\t\t\t}\n\n\t\t\t\t/* timer 1 */\n\n\t\t\t\tif(OPL->st[0] != st1)\n\n\t\t\t\t{\n\n\t\t\t\t\tdouble interval = st1 ? (double)OPL->T[0]*OPL->TimerBase : 0.0;\n\n\t\t\t\t\tOPL->st[0] = st1;\n\n\t\t\t\t\tif (OPL->TimerHandler) (OPL->TimerHandler)(OPL->TimerParam+0,interval);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn;\n\n#if BUILD_Y8950\n\n\t\tcase 0x06:\t\t/* Key Board OUT */\n\n\t\t\tif(OPL->type&OPL_TYPE_KEYBOARD)\n\n\t\t\t{\n\n\t\t\t\tif(OPL->keyboardhandler_w)\n\n\t\t\t\t\tOPL->keyboardhandler_w(OPL->keyboard_param,v);\n\n\t\t\t\telse\n\n\t\t\t\t\tLOG(LOG_WAR,(\"OPL:write unmapped KEYBOARD port\\n\"));\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\tcase 0x07:\t/* DELTA-T control : START,REC,MEMDATA,REPT,SPOFF,x,x,RST */\n\n\t\t\tif(OPL->type&OPL_TYPE_ADPCM)\n\n\t\t\t\tYM_DELTAT_ADPCM_Write(OPL->deltat,r-0x07,v);\n\n\t\t\treturn;\n\n\t\tcase 0x08:\t/* MODE,DELTA-T : CSM,NOTESEL,x,x,smpl,da/ad,64k,rom */\n\n\t\t\tOPL->mode = v;\n\n\t\t\tv&=0x1f;\t/* for DELTA-T unit */\n\n\t\tcase 0x09:\t\t/* START ADD */\n\n\t\tcase 0x0a:\n\n\t\tcase 0x0b:\t\t/* STOP ADD  */\n\n\t\tcase 0x0c:\n\n\t\tcase 0x0d:\t\t/* PRESCALE   */\n\n\t\tcase 0x0e:\n\n\t\tcase 0x0f:\t\t/* ADPCM data */\n\n\t\tcase 0x10: \t\t/* DELTA-N    */\n\n\t\tcase 0x11: \t\t/* DELTA-N    */\n\n\t\tcase 0x12: \t\t/* EG-CTRL    */\n\n\t\t\tif(OPL->type&OPL_TYPE_ADPCM)\n\n\t\t\t\tYM_DELTAT_ADPCM_Write(OPL->deltat,r-0x07,v);\n\n\t\t\treturn;\n\n#if 0\n\n\t\tcase 0x15:\t\t/* DAC data    */\n\n\t\tcase 0x16:\n\n\t\tcase 0x17:\t\t/* SHIFT    */\n\n\t\t\treturn;\n\n\t\tcase 0x18:\t\t/* I/O CTRL (Direction) */\n\n\t\t\tif(OPL->type&OPL_TYPE_IO)\n\n\t\t\t\tOPL->portDirection = v&0x0f;\n\n\t\t\treturn;\n\n\t\tcase 0x19:\t\t/* I/O DATA */\n\n\t\t\tif(OPL->type&OPL_TYPE_IO)\n\n\t\t\t{\n\n\t\t\t\tOPL->portLatch = v;\n\n\t\t\t\tif(OPL->porthandler_w)\n\n\t\t\t\t\tOPL->porthandler_w(OPL->port_param,v&OPL->portDirection);\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\tcase 0x1a:\t\t/* PCM data */\n\n\t\t\treturn;\n\n#endif\n\n#endif\n\n\t\t}\n\n\t\tbreak;\n\n\tcase 0x20:\t/* am,vib,ksr,eg type,mul */\n\n\t\tslot = slot_array[r&0x1f];\n\n\t\tif(slot == -1) return;\n\n\t\tset_mul(OPL,slot,v);\n\n\t\treturn;\n\n\tcase 0x40:\n\n\t\tslot = slot_array[r&0x1f];\n\n\t\tif(slot == -1) return;\n\n\t\tset_ksl_tl(OPL,slot,v);\n\n\t\treturn;\n\n\tcase 0x60:\n\n\t\tslot = slot_array[r&0x1f];\n\n\t\tif(slot == -1) return;\n\n\t\tset_ar_dr(OPL,slot,v);\n\n\t\treturn;\n\n\tcase 0x80:\n\n\t\tslot = slot_array[r&0x1f];\n\n\t\tif(slot == -1) return;\n\n\t\tset_sl_rr(OPL,slot,v);\n\n\t\treturn;\n\n\tcase 0xa0:\n\n\t\tswitch(r)\n\n\t\t{\n\n\t\tcase 0xbd:\n\n\t\t\t/* amsep,vibdep,r,bd,sd,tom,tc,hh */\n\n\t\t\t{\n\n\t\t\tUINT8 rkey = OPL->rythm^v;\n\n\t\t\tOPL->ams_table = &AMS_TABLE[v&0x80 ? AMS_ENT : 0];\n\n\t\t\tOPL->vib_table = &VIB_TABLE[v&0x40 ? VIB_ENT : 0];\n\n\t\t\tOPL->rythm  = v&0x3f;\n\n\t\t\tif(OPL->rythm&0x20)\n\n\t\t\t{\n\n#if 0\n\n\t\t\t\tusrintf_showmessage(\"OPL Rythm mode select\");\n\n#endif\n\n\t\t\t\t/* BD key on/off */\n\n\t\t\t\tif(rkey&0x10)\n\n\t\t\t\t{\n\n\t\t\t\t\tif(v&0x10)\n\n\t\t\t\t\t{\n\n\t\t\t\t\t\tOPL->P_CH[6].op1_out[0] = OPL->P_CH[6].op1_out[1] = 0;\n\n\t\t\t\t\t\tOPL_KEYON(&OPL->P_CH[6].SLOT[SLOT1]);\n\n\t\t\t\t\t\tOPL_KEYON(&OPL->P_CH[6].SLOT[SLOT2]);\n\n\t\t\t\t\t}\n\n\t\t\t\t\telse\n\n\t\t\t\t\t{\n\n\t\t\t\t\t\tOPL_KEYOFF(&OPL->P_CH[6].SLOT[SLOT1]);\n\n\t\t\t\t\t\tOPL_KEYOFF(&OPL->P_CH[6].SLOT[SLOT2]);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t/* SD key on/off */\n\n\t\t\t\tif(rkey&0x08)\n\n\t\t\t\t{\n\n\t\t\t\t\tif(v&0x08) OPL_KEYON(&OPL->P_CH[7].SLOT[SLOT2]);\n\n\t\t\t\t\telse       OPL_KEYOFF(&OPL->P_CH[7].SLOT[SLOT2]);\n\n\t\t\t\t}/* TAM key on/off */\n\n\t\t\t\tif(rkey&0x04)\n\n\t\t\t\t{\n\n\t\t\t\t\tif(v&0x04) OPL_KEYON(&OPL->P_CH[8].SLOT[SLOT1]);\n\n\t\t\t\t\telse       OPL_KEYOFF(&OPL->P_CH[8].SLOT[SLOT1]);\n\n\t\t\t\t}\n\n\t\t\t\t/* TOP-CY key on/off */\n\n\t\t\t\tif(rkey&0x02)\n\n\t\t\t\t{\n\n\t\t\t\t\tif(v&0x02) OPL_KEYON(&OPL->P_CH[8].SLOT[SLOT2]);\n\n\t\t\t\t\telse       OPL_KEYOFF(&OPL->P_CH[8].SLOT[SLOT2]);\n\n\t\t\t\t}\n\n\t\t\t\t/* HH key on/off */\n\n\t\t\t\tif(rkey&0x01)\n\n\t\t\t\t{\n\n\t\t\t\t\tif(v&0x01) OPL_KEYON(&OPL->P_CH[7].SLOT[SLOT1]);\n\n\t\t\t\t\telse       OPL_KEYOFF(&OPL->P_CH[7].SLOT[SLOT1]);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t/* keyon,block,fnum */\n\n\t\tif( (r&0x0f) > 8) return;\n\n\t\tCH = &OPL->P_CH[r&0x0f];\n\n\t\tif(!(r&0x10))\n\n\t\t{\t/* a0-a8 */\n\n\t\t\tblock_fnum  = (CH->block_fnum&0x1f00) | v;\n\n\t\t}\n\n\t\telse\n\n\t\t{\t/* b0-b8 */\n\n\t\t\tint keyon = (v>>5)&1;\n\n\t\t\tblock_fnum = ((v&0x1f)<<8) | (CH->block_fnum&0xff);\n\n\t\t\tif(CH->keyon != keyon)\n\n\t\t\t{\n\n\t\t\t\tif( (CH->keyon=keyon) )\n\n\t\t\t\t{\n\n\t\t\t\t\tCH->op1_out[0] = CH->op1_out[1] = 0;\n\n\t\t\t\t\tOPL_KEYON(&CH->SLOT[SLOT1]);\n\n\t\t\t\t\tOPL_KEYON(&CH->SLOT[SLOT2]);\n\n\t\t\t\t}\n\n\t\t\t\telse\n\n\t\t\t\t{\n\n\t\t\t\t\tOPL_KEYOFF(&CH->SLOT[SLOT1]);\n\n\t\t\t\t\tOPL_KEYOFF(&CH->SLOT[SLOT2]);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/* update */\n\n\t\tif(CH->block_fnum != block_fnum)\n\n\t\t{\n\n\t\t\tint blockRv = 7-(block_fnum>>10);\n\n\t\t\tint fnum   = block_fnum&0x3ff;\n\n\t\t\tCH->block_fnum = block_fnum;\n\n\n\n\t\t\tCH->ksl_base = KSL_TABLE[block_fnum>>6];\n\n\t\t\tCH->fc = OPL->FN_TABLE[fnum]>>blockRv;\n\n\t\t\tCH->kcode = CH->block_fnum>>9;\n\n\t\t\tif( (OPL->mode&0x40) && CH->block_fnum&0x100) CH->kcode |=1;\n\n\t\t\tCALC_FCSLOT(CH,&CH->SLOT[SLOT1]);\n\n\t\t\tCALC_FCSLOT(CH,&CH->SLOT[SLOT2]);\n\n\t\t}\n\n\t\treturn;\n\n\tcase 0xc0:\n\n\t\t/* FB,C */\n\n\t\tif( (r&0x0f) > 8) return;\n\n\t\tCH = &OPL->P_CH[r&0x0f];\n\n\t\t{\n\n\t\tint feedback = (v>>1)&7;\n\n\t\tCH->FB   = feedback ? (8+1) - feedback : 0;\n\n\t\tCH->CON = v&1;\n\n\t\tset_algorythm(CH);\n\n\t\t}\n\n\t\treturn;\n\n\tcase 0xe0: /* wave type */\n\n\t\tslot = slot_array[r&0x1f];\n\n\t\tif(slot == -1) return;\n\n\t\tCH = &OPL->P_CH[slot/2];\n\n\t\tif(OPL->wavesel)\n\n\t\t{\n\n\t\t\t/* LOG(LOG_INF,(\"OPL SLOT %d wave select %d\\n\",slot,v&3)); */\n\n\t\t\tCH->SLOT[slot&1].wavetable = &SIN_TABLE[(v&0x03)*SIN_ENT];\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n}\n", "idx": 12762, "_split": "valid", "_hash": "69c36b65c5dc0d1a821c0e09fe2295ac"}
{"project": "qemu", "commit_id": "c7cacb3e7a2e9fdf929c993b98268e4179147cbb", "target": 0, "func": "static int qemu_rbd_set_conf(rados_t cluster, const char *conf,\n\n                             bool only_read_conf_file,\n\n                             Error **errp)\n\n{\n\n    char *p, *buf;\n\n    char *name;\n\n    char *value;\n\n    Error *local_err = NULL;\n\n    int ret = 0;\n\n\n\n    buf = g_strdup(conf);\n\n    p = buf;\n\n\n\n    while (p) {\n\n        name = qemu_rbd_next_tok(RBD_MAX_CONF_NAME_SIZE, p,\n\n                                 '=', \"conf option name\", &p, &local_err);\n\n        if (local_err) {\n\n            break;\n\n        }\n\n        qemu_rbd_unescape(name);\n\n\n\n        if (!p) {\n\n            error_setg(errp, \"conf option %s has no value\", name);\n\n            ret = -EINVAL;\n\n            break;\n\n        }\n\n\n\n        value = qemu_rbd_next_tok(RBD_MAX_CONF_VAL_SIZE, p,\n\n                                  ':', \"conf option value\", &p, &local_err);\n\n        if (local_err) {\n\n            break;\n\n        }\n\n        qemu_rbd_unescape(value);\n\n\n\n        if (strcmp(name, \"conf\") == 0) {\n\n            /* read the conf file alone, so it doesn't override more\n\n               specific settings for a particular device */\n\n            if (only_read_conf_file) {\n\n                ret = rados_conf_read_file(cluster, value);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"error reading conf file %s\",\n\n                                     value);\n\n                    break;\n\n                }\n\n            }\n\n        } else if (strcmp(name, \"id\") == 0) {\n\n            /* ignore, this is parsed by qemu_rbd_parse_clientname() */\n\n        } else if (!only_read_conf_file) {\n\n            ret = rados_conf_set(cluster, name, value);\n\n            if (ret < 0) {\n\n                error_setg_errno(errp, -ret, \"invalid conf option %s\", name);\n\n                ret = -EINVAL;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n    }\n\n    g_free(buf);\n\n    return ret;\n\n}\n", "idx": 12765, "_split": "valid", "_hash": "7cf3ad72389fd1278e7c62acdc25346f"}
{"project": "qemu", "commit_id": "e508a92b621c7160122e99d3754e568f2b8e255e", "target": 0, "func": "static int arm946_prbs_read(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                            uint64_t *value)\n\n{\n\n    if (ri->crm >= 8) {\n\n        return EXCP_UDEF;\n\n    }\n\n    *value = env->cp15.c6_region[ri->crm];\n\n    return 0;\n\n}\n", "idx": 12778, "_split": "valid", "_hash": "4ee3f50927aed1e46d634b1aa1212588"}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void lsi_do_dma(LSIState *s, int out)\n\n{\n\n    uint32_t count, id;\n\n    target_phys_addr_t addr;\n\n    SCSIDevice *dev;\n\n\n\n    assert(s->current);\n\n    if (!s->current->dma_len) {\n\n        /* Wait until data is available.  */\n\n        DPRINTF(\"DMA no data available\\n\");\n\n        return;\n\n    }\n\n\n\n    id = (s->current->tag >> 8) & 0xf;\n\n    dev = s->bus.devs[id];\n\n    if (!dev) {\n\n        lsi_bad_selection(s, id);\n\n        return;\n\n    }\n\n\n\n    count = s->dbc;\n\n    if (count > s->current->dma_len)\n\n        count = s->current->dma_len;\n\n\n\n    addr = s->dnad;\n\n    /* both 40 and Table Indirect 64-bit DMAs store upper bits in dnad64 */\n\n    if (lsi_dma_40bit(s) || lsi_dma_ti64bit(s))\n\n        addr |= ((uint64_t)s->dnad64 << 32);\n\n    else if (s->dbms)\n\n        addr |= ((uint64_t)s->dbms << 32);\n\n    else if (s->sbms)\n\n        addr |= ((uint64_t)s->sbms << 32);\n\n\n\n    DPRINTF(\"DMA addr=0x\" TARGET_FMT_plx \" len=%d\\n\", addr, count);\n\n    s->csbc += count;\n\n    s->dnad += count;\n\n    s->dbc -= count;\n\n\n\n    if (s->current->dma_buf == NULL) {\n\n        s->current->dma_buf = dev->info->get_buf(dev, s->current->tag);\n\n    }\n\n\n\n    /* ??? Set SFBR to first data byte.  */\n\n    if (out) {\n\n        cpu_physical_memory_read(addr, s->current->dma_buf, count);\n\n    } else {\n\n        cpu_physical_memory_write(addr, s->current->dma_buf, count);\n\n    }\n\n    s->current->dma_len -= count;\n\n    if (s->current->dma_len == 0) {\n\n        s->current->dma_buf = NULL;\n\n        if (out) {\n\n            /* Write the data.  */\n\n            dev->info->write_data(dev, s->current->tag);\n\n        } else {\n\n            /* Request any remaining data.  */\n\n            dev->info->read_data(dev, s->current->tag);\n\n        }\n\n    } else {\n\n        s->current->dma_buf += count;\n\n        lsi_resume_script(s);\n\n    }\n\n}\n", "idx": 12796, "_split": "valid", "_hash": "ff8f11bee7461c82c05d993f2f95974a"}
{"project": "qemu", "commit_id": "eb7b5c35117bfb90dcfa881a0e3b23368c73fba6", "target": 1, "func": "static void iothread_instance_finalize(Object *obj)\n\n{\n\n    IOThread *iothread = IOTHREAD(obj);\n\n\n\n    iothread_stop(obj, NULL);\n\n    qemu_cond_destroy(&iothread->init_done_cond);\n\n    qemu_mutex_destroy(&iothread->init_done_lock);\n\n\n\n\n    aio_context_unref(iothread->ctx);\n", "idx": 12801, "_split": "valid", "_hash": "aa9c2690d080bffd86988325341cfd8e"}
{"project": "qemu", "commit_id": "e3cffe6fad29e07d401eabb913a6d88501d5c143", "target": 1, "func": "static void gen_isync(DisasContext *ctx)\n\n{\n\n    /*\n\n     * We need to check for a pending TLB flush. This can only happen in\n\n     * kernel mode however so check MSR_PR\n\n     */\n\n    if (!ctx->pr) {\n\n        gen_check_tlb_flush(ctx);\n\n    }\n\n    gen_stop_exception(ctx);\n\n}\n", "idx": 12817, "_split": "valid", "_hash": "55cfe369a8b6d67ffcd1921b2e5ca235"}
{"project": "qemu", "commit_id": "e6b3c8ca0222f6633516c0461a713e7bddc4f076", "target": 1, "func": "static void realview_init(ram_addr_t ram_size,\n\n                     const char *boot_device,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename, const char *cpu_model,\n\n                     enum realview_board_type board_type)\n\n{\n\n    CPUState *env = NULL;\n\n    ram_addr_t ram_offset;\n\n    DeviceState *dev, *sysctl, *gpio2;\n\n    SysBusDevice *busdev;\n\n    qemu_irq *irqp;\n\n    qemu_irq pic[64];\n\n    qemu_irq mmc_irq[2];\n\n    PCIBus *pci_bus;\n\n    NICInfo *nd;\n\n    i2c_bus *i2c;\n\n    int n;\n\n    int done_nic = 0;\n\n    qemu_irq cpu_irq[4];\n\n    int is_mpcore = 0;\n\n    int is_pb = 0;\n\n    uint32_t proc_id = 0;\n\n    uint32_t sys_id;\n\n    ram_addr_t low_ram_size;\n\n\n\n    switch (board_type) {\n\n    case BOARD_EB:\n\n        break;\n\n    case BOARD_EB_MPCORE:\n\n        is_mpcore = 1;\n\n        break;\n\n    case BOARD_PB_A8:\n\n        is_pb = 1;\n\n        break;\n\n    case BOARD_PBX_A9:\n\n        is_mpcore = 1;\n\n        is_pb = 1;\n\n        break;\n\n    }\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        irqp = arm_pic_init_cpu(env);\n\n        cpu_irq[n] = irqp[ARM_PIC_CPU_IRQ];\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V7)) {\n\n        if (is_mpcore) {\n\n            proc_id = 0x0c000000;\n\n        } else {\n\n            proc_id = 0x0e000000;\n\n        }\n\n    } else if (arm_feature(env, ARM_FEATURE_V6K)) {\n\n        proc_id = 0x06000000;\n\n    } else if (arm_feature(env, ARM_FEATURE_V6)) {\n\n        proc_id = 0x04000000;\n\n    } else {\n\n        proc_id = 0x02000000;\n\n    }\n\n\n\n    if (is_pb && ram_size > 0x20000000) {\n\n        /* Core tile RAM.  */\n\n        low_ram_size = ram_size - 0x20000000;\n\n        ram_size = 0x20000000;\n\n        ram_offset = qemu_ram_alloc(NULL, \"realview.lowmem\", low_ram_size);\n\n        cpu_register_physical_memory(0x20000000, low_ram_size,\n\n                                     ram_offset | IO_MEM_RAM);\n\n    }\n\n\n\n    ram_offset = qemu_ram_alloc(NULL, \"realview.highmem\", ram_size);\n\n    low_ram_size = ram_size;\n\n    if (low_ram_size > 0x10000000)\n\n      low_ram_size = 0x10000000;\n\n    /* SDRAM at address zero.  */\n\n    cpu_register_physical_memory(0, low_ram_size, ram_offset | IO_MEM_RAM);\n\n    if (is_pb) {\n\n        /* And again at a high address.  */\n\n        cpu_register_physical_memory(0x70000000, ram_size,\n\n                                     ram_offset | IO_MEM_RAM);\n\n    } else {\n\n        ram_size = low_ram_size;\n\n    }\n\n\n\n    sys_id = is_pb ? 0x01780500 : 0xc1400400;\n\n    sysctl = qdev_create(NULL, \"realview_sysctl\");\n\n    qdev_prop_set_uint32(sysctl, \"sys_id\", sys_id);\n\n    qdev_init_nofail(sysctl);\n\n    qdev_prop_set_uint32(sysctl, \"proc_id\", proc_id);\n\n    sysbus_mmio_map(sysbus_from_qdev(sysctl), 0, 0x10000000);\n\n\n\n    if (is_mpcore) {\n\n        dev = qdev_create(NULL, is_pb ? \"a9mpcore_priv\": \"realview_mpcore\");\n\n        qdev_prop_set_uint32(dev, \"num-cpu\", smp_cpus);\n\n        qdev_init_nofail(dev);\n\n        busdev = sysbus_from_qdev(dev);\n\n        if (is_pb) {\n\n            realview_binfo.smp_priv_base = 0x1f000000;\n\n        } else {\n\n            realview_binfo.smp_priv_base = 0x10100000;\n\n        }\n\n        sysbus_mmio_map(busdev, 0, realview_binfo.smp_priv_base);\n\n        for (n = 0; n < smp_cpus; n++) {\n\n            sysbus_connect_irq(busdev, n, cpu_irq[n]);\n\n        }\n\n    } else {\n\n        uint32_t gic_addr = is_pb ? 0x1e000000 : 0x10040000;\n\n        /* For now just create the nIRQ GIC, and ignore the others.  */\n\n        dev = sysbus_create_simple(\"realview_gic\", gic_addr, cpu_irq[0]);\n\n    }\n\n    for (n = 0; n < 64; n++) {\n\n        pic[n] = qdev_get_gpio_in(dev, n);\n\n    }\n\n\n\n    sysbus_create_simple(\"pl050_keyboard\", 0x10006000, pic[20]);\n\n    sysbus_create_simple(\"pl050_mouse\", 0x10007000, pic[21]);\n\n\n\n    sysbus_create_simple(\"pl011\", 0x10009000, pic[12]);\n\n    sysbus_create_simple(\"pl011\", 0x1000a000, pic[13]);\n\n    sysbus_create_simple(\"pl011\", 0x1000b000, pic[14]);\n\n    sysbus_create_simple(\"pl011\", 0x1000c000, pic[15]);\n\n\n\n    /* DMA controller is optional, apparently.  */\n\n    sysbus_create_simple(\"pl081\", 0x10030000, pic[24]);\n\n\n\n    sysbus_create_simple(\"sp804\", 0x10011000, pic[4]);\n\n    sysbus_create_simple(\"sp804\", 0x10012000, pic[5]);\n\n\n\n    sysbus_create_simple(\"pl061\", 0x10013000, pic[6]);\n\n    sysbus_create_simple(\"pl061\", 0x10014000, pic[7]);\n\n    gpio2 = sysbus_create_simple(\"pl061\", 0x10015000, pic[8]);\n\n\n\n    sysbus_create_simple(\"pl110_versatile\", 0x10020000, pic[23]);\n\n\n\n    dev = sysbus_create_varargs(\"pl181\", 0x10005000, pic[17], pic[18], NULL);\n\n    /* Wire up MMC card detect and read-only signals. These have\n\n     * to go to both the PL061 GPIO and the sysctl register.\n\n     * Note that the PL181 orders these lines (readonly,inserted)\n\n     * and the PL061 has them the other way about. Also the card\n\n     * detect line is inverted.\n\n     */\n\n    mmc_irq[0] = qemu_irq_split(\n\n        qdev_get_gpio_in(sysctl, ARM_SYSCTL_GPIO_MMC_WPROT),\n\n        qdev_get_gpio_in(gpio2, 1));\n\n    mmc_irq[1] = qemu_irq_split(\n\n        qdev_get_gpio_in(sysctl, ARM_SYSCTL_GPIO_MMC_CARDIN),\n\n        qemu_irq_invert(qdev_get_gpio_in(gpio2, 0)));\n\n    qdev_connect_gpio_out(dev, 0, mmc_irq[0]);\n\n    qdev_connect_gpio_out(dev, 1, mmc_irq[1]);\n\n\n\n    sysbus_create_simple(\"pl031\", 0x10017000, pic[10]);\n\n\n\n    if (!is_pb) {\n\n        dev = sysbus_create_varargs(\"realview_pci\", 0x60000000,\n\n                                    pic[48], pic[49], pic[50], pic[51], NULL);\n\n        pci_bus = (PCIBus *)qdev_get_child_bus(dev, \"pci\");\n\n        if (usb_enabled) {\n\n            usb_ohci_init_pci(pci_bus, -1);\n\n        }\n\n        n = drive_get_max_bus(IF_SCSI);\n\n        while (n >= 0) {\n\n            pci_create_simple(pci_bus, -1, \"lsi53c895a\");\n\n            n--;\n\n        }\n\n    }\n\n    for(n = 0; n < nb_nics; n++) {\n\n        nd = &nd_table[n];\n\n\n\n        if ((!nd->model && !done_nic)\n\n            || strcmp(nd->model, is_pb ? \"lan9118\" : \"smc91c111\") == 0) {\n\n            if (is_pb) {\n\n                lan9118_init(nd, 0x4e000000, pic[28]);\n\n            } else {\n\n                smc91c111_init(nd, 0x4e000000, pic[28]);\n\n            }\n\n            done_nic = 1;\n\n        } else {\n\n            pci_nic_init_nofail(nd, \"rtl8139\", NULL);\n\n        }\n\n    }\n\n\n\n    dev = sysbus_create_simple(\"realview_i2c\", 0x10002000, NULL);\n\n    i2c = (i2c_bus *)qdev_get_child_bus(dev, \"i2c\");\n\n    i2c_create_slave(i2c, \"ds1338\", 0x68);\n\n\n\n    /* Memory map for RealView Emulation Baseboard:  */\n\n    /* 0x10000000 System registers.  */\n\n    /*  0x10001000 System controller.  */\n\n    /* 0x10002000 Two-Wire Serial Bus.  */\n\n    /* 0x10003000 Reserved.  */\n\n    /*  0x10004000 AACI.  */\n\n    /*  0x10005000 MCI.  */\n\n    /* 0x10006000 KMI0.  */\n\n    /* 0x10007000 KMI1.  */\n\n    /*  0x10008000 Character LCD. (EB) */\n\n    /* 0x10009000 UART0.  */\n\n    /* 0x1000a000 UART1.  */\n\n    /* 0x1000b000 UART2.  */\n\n    /* 0x1000c000 UART3.  */\n\n    /*  0x1000d000 SSPI.  */\n\n    /*  0x1000e000 SCI.  */\n\n    /* 0x1000f000 Reserved.  */\n\n    /*  0x10010000 Watchdog.  */\n\n    /* 0x10011000 Timer 0+1.  */\n\n    /* 0x10012000 Timer 2+3.  */\n\n    /*  0x10013000 GPIO 0.  */\n\n    /*  0x10014000 GPIO 1.  */\n\n    /*  0x10015000 GPIO 2.  */\n\n    /*  0x10002000 Two-Wire Serial Bus - DVI. (PB) */\n\n    /* 0x10017000 RTC.  */\n\n    /*  0x10018000 DMC.  */\n\n    /*  0x10019000 PCI controller config.  */\n\n    /*  0x10020000 CLCD.  */\n\n    /* 0x10030000 DMA Controller.  */\n\n    /* 0x10040000 GIC1. (EB) */\n\n    /*  0x10050000 GIC2. (EB) */\n\n    /*  0x10060000 GIC3. (EB) */\n\n    /*  0x10070000 GIC4. (EB) */\n\n    /*  0x10080000 SMC.  */\n\n    /* 0x1e000000 GIC1. (PB) */\n\n    /*  0x1e001000 GIC2. (PB) */\n\n    /*  0x1e002000 GIC3. (PB) */\n\n    /*  0x1e003000 GIC4. (PB) */\n\n    /*  0x40000000 NOR flash.  */\n\n    /*  0x44000000 DoC flash.  */\n\n    /*  0x48000000 SRAM.  */\n\n    /*  0x4c000000 Configuration flash.  */\n\n    /* 0x4e000000 Ethernet.  */\n\n    /*  0x4f000000 USB.  */\n\n    /*  0x50000000 PISMO.  */\n\n    /*  0x54000000 PISMO.  */\n\n    /*  0x58000000 PISMO.  */\n\n    /*  0x5c000000 PISMO.  */\n\n    /* 0x60000000 PCI.  */\n\n    /* 0x61000000 PCI Self Config.  */\n\n    /* 0x62000000 PCI Config.  */\n\n    /* 0x63000000 PCI IO.  */\n\n    /* 0x64000000 PCI mem 0.  */\n\n    /* 0x68000000 PCI mem 1.  */\n\n    /* 0x6c000000 PCI mem 2.  */\n\n\n\n    /* ??? Hack to map an additional page of ram for the secondary CPU\n\n       startup code.  I guess this works on real hardware because the\n\n       BootROM happens to be in ROM/flash or in memory that isn't clobbered\n\n       until after Linux boots the secondary CPUs.  */\n\n    ram_offset = qemu_ram_alloc(NULL, \"realview.hack\", 0x1000);\n\n    cpu_register_physical_memory(SMP_BOOT_ADDR, 0x1000,\n\n                                 ram_offset | IO_MEM_RAM);\n\n\n\n    realview_binfo.ram_size = ram_size;\n\n    realview_binfo.kernel_filename = kernel_filename;\n\n    realview_binfo.kernel_cmdline = kernel_cmdline;\n\n    realview_binfo.initrd_filename = initrd_filename;\n\n    realview_binfo.nb_cpus = smp_cpus;\n\n    realview_binfo.board_id = realview_board_id[board_type];\n\n    realview_binfo.loader_start = (board_type == BOARD_PB_A8 ? 0x70000000 : 0);\n\n    arm_load_kernel(first_cpu, &realview_binfo);\n\n}\n", "idx": 12823, "_split": "valid", "_hash": "864b244ef5555f95936aaef727e3b57e"}
{"project": "qemu", "commit_id": "e2a176dfda32f5cf80703c2921a19fe75850c38c", "target": 0, "func": "static uint32_t taihu_cpld_readb (void *opaque, hwaddr addr)\n\n{\n\n    taihu_cpld_t *cpld;\n\n    uint32_t ret;\n\n\n\n    cpld = opaque;\n\n    switch (addr) {\n\n    case 0x0:\n\n        ret = cpld->reg0;\n\n        break;\n\n    case 0x1:\n\n        ret = cpld->reg1;\n\n        break;\n\n    default:\n\n        ret = 0;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 12829, "_split": "valid", "_hash": "bebfd18275622c0364925e868970039f"}
{"project": "qemu", "commit_id": "a9c0183059d6a4e4d940cd86ac0f9402b0655d24", "target": 0, "func": "static void sd_lock_command(SDState *sd)\n\n{\n\n    int erase, lock, clr_pwd, set_pwd, pwd_len;\n\n    erase = !!(sd->data[0] & 0x08);\n\n    lock = sd->data[0] & 0x04;\n\n    clr_pwd = sd->data[0] & 0x02;\n\n    set_pwd = sd->data[0] & 0x01;\n\n\n\n    if (sd->blk_len > 1)\n\n        pwd_len = sd->data[1];\n\n    else\n\n        pwd_len = 0;\n\n\n\n    if (erase) {\n\n        if (!(sd->card_status & CARD_IS_LOCKED) || sd->blk_len > 1 ||\n\n                        set_pwd || clr_pwd || lock || sd->wp_switch ||\n\n                        (sd->csd[14] & 0x20)) {\n\n            sd->card_status |= LOCK_UNLOCK_FAILED;\n\n            return;\n\n        }\n\n        memset(sd->wp_groups, 0, sizeof(int) * (sd->size >>\n\n                        (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)));\n\n        sd->csd[14] &= ~0x10;\n\n        sd->card_status &= ~CARD_IS_LOCKED;\n\n        sd->pwd_len = 0;\n\n        /* Erasing the entire card here! */\n\n        fprintf(stderr, \"SD: Card force-erased by CMD42\\n\");\n\n        return;\n\n    }\n\n\n\n    if (sd->blk_len < 2 + pwd_len ||\n\n                    pwd_len <= sd->pwd_len ||\n\n                    pwd_len > sd->pwd_len + 16) {\n\n        sd->card_status |= LOCK_UNLOCK_FAILED;\n\n        return;\n\n    }\n\n\n\n    if (sd->pwd_len && memcmp(sd->pwd, sd->data + 2, sd->pwd_len)) {\n\n        sd->card_status |= LOCK_UNLOCK_FAILED;\n\n        return;\n\n    }\n\n\n\n    pwd_len -= sd->pwd_len;\n\n    if ((pwd_len && !set_pwd) ||\n\n                    (clr_pwd && (set_pwd || lock)) ||\n\n                    (lock && !sd->pwd_len && !set_pwd) ||\n\n                    (!set_pwd && !clr_pwd &&\n\n                     (((sd->card_status & CARD_IS_LOCKED) && lock) ||\n\n                      (!(sd->card_status & CARD_IS_LOCKED) && !lock)))) {\n\n        sd->card_status |= LOCK_UNLOCK_FAILED;\n\n        return;\n\n    }\n\n\n\n    if (set_pwd) {\n\n        memcpy(sd->pwd, sd->data + 2 + sd->pwd_len, pwd_len);\n\n        sd->pwd_len = pwd_len;\n\n    }\n\n\n\n    if (clr_pwd) {\n\n        sd->pwd_len = 0;\n\n    }\n\n\n\n    if (lock)\n\n        sd->card_status |= CARD_IS_LOCKED;\n\n    else\n\n        sd->card_status &= ~CARD_IS_LOCKED;\n\n}\n", "idx": 12830, "_split": "valid", "_hash": "f04a5e711434922167cca13ff256f4b0"}
{"project": "qemu", "commit_id": "6a2b3d89fa49ec060db646d196864a8fd15c10cf", "target": 0, "func": "static void spin_reset(void *opaque)\n\n{\n\n    SpinState *s = opaque;\n\n    int i;\n\n\n\n    for (i = 0; i < MAX_CPUS; i++) {\n\n        SpinInfo *info = &s->spin[i];\n\n\n\n        info->pir = i;\n\n        info->r3 = i;\n\n        info->addr = 1;\n\n    }\n\n}\n", "idx": 12854, "_split": "valid", "_hash": "4d7ed77cfe17a818001aadebbd17b26f"}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static QObject *parser_context_pop_token(JSONParserContext *ctxt)\n\n{\n\n    qobject_decref(ctxt->current);\n\n    assert(!g_queue_is_empty(ctxt->buf));\n\n    ctxt->current = g_queue_pop_head(ctxt->buf);\n\n    return ctxt->current;\n\n}\n", "idx": 12869, "_split": "valid", "_hash": "ea694cd6e762b40bc27108b039ecefaf"}
{"project": "qemu", "commit_id": "d26d9e14c15837eba2b7447e8d15230bab8e0940", "target": 0, "func": "static void pc_fw_cfg_guest_info(PcGuestInfo *guest_info)\n\n{\n\n    PcRomPciInfo *info;\n\n    if (!guest_info->has_pci_info) {\n\n        return;\n\n    }\n\n\n\n    info = g_malloc(sizeof *info);\n\n    info->w32_min = cpu_to_le64(guest_info->pci_info.w32.begin);\n\n    info->w32_max = cpu_to_le64(guest_info->pci_info.w32.end);\n\n    info->w64_min = cpu_to_le64(guest_info->pci_info.w64.begin);\n\n    info->w64_max = cpu_to_le64(guest_info->pci_info.w64.end);\n\n    /* Pass PCI hole info to guest via a side channel.\n\n     * Required so guest PCI enumeration does the right thing. */\n\n    fw_cfg_add_file(guest_info->fw_cfg, \"etc/pci-info\", info, sizeof *info);\n\n}\n", "idx": 12871, "_split": "valid", "_hash": "5b5476f4d57212d8b7d2b51ef5a86d0e"}
{"project": "qemu", "commit_id": "3a3b8502e6f0c8d30865c5f36d2c3ae4114000b5", "target": 1, "func": "int spapr_rtas_register(const char *name, spapr_rtas_fn fn)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < (rtas_next - rtas_table); i++) {\n\n        if (strcmp(name, rtas_table[i].name) == 0) {\n\n            fprintf(stderr, \"RTAS call \\\"%s\\\" registered twice\\n\", name);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    assert(rtas_next < (rtas_table + TOKEN_MAX));\n\n\n\n    rtas_next->name = name;\n\n    rtas_next->fn = fn;\n\n\n\n    return (rtas_next++ - rtas_table) + TOKEN_BASE;\n\n}\n", "idx": 12963, "_split": "valid", "_hash": "3cb25dac8a496d0c1ff1da5cd11c0560"}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtol_whitespace(void)\n\n{\n\n    const char *str = \"  \\t  \";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtol(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 12966, "_split": "valid", "_hash": "f4b1e23b9f37c369531ecdbe091d5709"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t nvram_readw (void *opaque, target_phys_addr_t addr)\n\n{\n\n    M48t59State *NVRAM = opaque;\n\n    uint32_t retval;\n\n\n\n    retval = m48t59_read(NVRAM, addr) << 8;\n\n    retval |= m48t59_read(NVRAM, addr + 1);\n\n    return retval;\n\n}\n", "idx": 12999, "_split": "valid", "_hash": "07dd0e1096106af31a79fe3d5f7847c2"}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static uint32_t sdhci_read(SDHCIState *s, unsigned int offset, unsigned size)\n\n{\n\n    uint32_t ret = 0;\n\n\n\n    switch (offset & ~0x3) {\n\n    case SDHC_SYSAD:\n\n        ret = s->sdmasysad;\n\n        break;\n\n    case SDHC_BLKSIZE:\n\n        ret = s->blksize | (s->blkcnt << 16);\n\n        break;\n\n    case SDHC_ARGUMENT:\n\n        ret = s->argument;\n\n        break;\n\n    case SDHC_TRNMOD:\n\n        ret = s->trnmod | (s->cmdreg << 16);\n\n        break;\n\n    case SDHC_RSPREG0 ... SDHC_RSPREG3:\n\n        ret = s->rspreg[((offset & ~0x3) - SDHC_RSPREG0) >> 2];\n\n        break;\n\n    case  SDHC_BDATA:\n\n        if (sdhci_buff_access_is_sequential(s, offset - SDHC_BDATA)) {\n\n            ret = SDHCI_GET_CLASS(s)->bdata_read(s, size);\n\n            DPRINT_L2(\"read %ub: addr[0x%04x] -> %u(0x%x)\\n\", size, offset,\n\n                      ret, ret);\n\n            return ret;\n\n        }\n\n        break;\n\n    case SDHC_PRNSTS:\n\n        ret = s->prnsts;\n\n        break;\n\n    case SDHC_HOSTCTL:\n\n        ret = s->hostctl | (s->pwrcon << 8) | (s->blkgap << 16) |\n\n              (s->wakcon << 24);\n\n        break;\n\n    case SDHC_CLKCON:\n\n        ret = s->clkcon | (s->timeoutcon << 16);\n\n        break;\n\n    case SDHC_NORINTSTS:\n\n        ret = s->norintsts | (s->errintsts << 16);\n\n        break;\n\n    case SDHC_NORINTSTSEN:\n\n        ret = s->norintstsen | (s->errintstsen << 16);\n\n        break;\n\n    case SDHC_NORINTSIGEN:\n\n        ret = s->norintsigen | (s->errintsigen << 16);\n\n        break;\n\n    case SDHC_ACMD12ERRSTS:\n\n        ret = s->acmd12errsts;\n\n        break;\n\n    case SDHC_CAPAREG:\n\n        ret = s->capareg;\n\n        break;\n\n    case SDHC_MAXCURR:\n\n        ret = s->maxcurr;\n\n        break;\n\n    case SDHC_ADMAERR:\n\n        ret =  s->admaerr;\n\n        break;\n\n    case SDHC_ADMASYSADDR:\n\n        ret = (uint32_t)s->admasysaddr;\n\n        break;\n\n    case SDHC_ADMASYSADDR + 4:\n\n        ret = (uint32_t)(s->admasysaddr >> 32);\n\n        break;\n\n    case SDHC_SLOT_INT_STATUS:\n\n        ret = (SD_HOST_SPECv2_VERS << 16) | sdhci_slotint(s);\n\n        break;\n\n    default:\n\n        ERRPRINT(\"bad %ub read: addr[0x%04x]\\n\", size, offset);\n\n        break;\n\n    }\n\n\n\n    ret >>= (offset & 0x3) * 8;\n\n    ret &= (1ULL << (size * 8)) - 1;\n\n    DPRINT_L2(\"read %ub: addr[0x%04x] -> %u(0x%x)\\n\", size, offset, ret, ret);\n\n    return ret;\n\n}\n", "idx": 13016, "_split": "valid", "_hash": "cba8aaf1d7133206ea014222014b1929"}
{"project": "qemu", "commit_id": "bdd03cdf5dc3176bc7169a1d5709303e9279fffb", "target": 0, "func": "static int raw_reopen_prepare(BDRVReopenState *state,\n\n                              BlockReopenQueue *queue, Error **errp)\n\n{\n\n    BDRVRawState *s;\n\n    BDRVRawReopenState *raw_s;\n\n    int ret = 0;\n\n    Error *local_err = NULL;\n\n\n\n    assert(state != NULL);\n\n    assert(state->bs != NULL);\n\n\n\n    s = state->bs->opaque;\n\n\n\n    state->opaque = g_new0(BDRVRawReopenState, 1);\n\n    raw_s = state->opaque;\n\n\n\n#ifdef CONFIG_LINUX_AIO\n\n    raw_s->use_aio = s->use_aio;\n\n\n\n    /* we can use s->aio_ctx instead of a copy, because the use_aio flag is\n\n     * valid in the 'false' condition even if aio_ctx is set, and raw_set_aio()\n\n     * won't override aio_ctx if aio_ctx is non-NULL */\n\n    if (raw_set_aio(&s->aio_ctx, &raw_s->use_aio, state->flags)) {\n\n        error_setg(errp, \"Could not set AIO state\");\n\n        return -1;\n\n    }\n\n#endif\n\n\n\n    if (s->type == FTYPE_FD || s->type == FTYPE_CD) {\n\n        raw_s->open_flags |= O_NONBLOCK;\n\n    }\n\n\n\n    raw_parse_flags(state->flags, &raw_s->open_flags);\n\n\n\n    raw_s->fd = -1;\n\n\n\n    int fcntl_flags = O_APPEND | O_NONBLOCK;\n\n#ifdef O_NOATIME\n\n    fcntl_flags |= O_NOATIME;\n\n#endif\n\n\n\n#ifdef O_ASYNC\n\n    /* Not all operating systems have O_ASYNC, and those that don't\n\n     * will not let us track the state into raw_s->open_flags (typically\n\n     * you achieve the same effect with an ioctl, for example I_SETSIG\n\n     * on Solaris). But we do not use O_ASYNC, so that's fine.\n\n     */\n\n    assert((s->open_flags & O_ASYNC) == 0);\n\n#endif\n\n\n\n    if ((raw_s->open_flags & ~fcntl_flags) == (s->open_flags & ~fcntl_flags)) {\n\n        /* dup the original fd */\n\n        /* TODO: use qemu fcntl wrapper */\n\n#ifdef F_DUPFD_CLOEXEC\n\n        raw_s->fd = fcntl(s->fd, F_DUPFD_CLOEXEC, 0);\n\n#else\n\n        raw_s->fd = dup(s->fd);\n\n        if (raw_s->fd != -1) {\n\n            qemu_set_cloexec(raw_s->fd);\n\n        }\n\n#endif\n\n        if (raw_s->fd >= 0) {\n\n            ret = fcntl_setfl(raw_s->fd, raw_s->open_flags);\n\n            if (ret) {\n\n                qemu_close(raw_s->fd);\n\n                raw_s->fd = -1;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* If we cannot use fcntl, or fcntl failed, fall back to qemu_open() */\n\n    if (raw_s->fd == -1) {\n\n        assert(!(raw_s->open_flags & O_CREAT));\n\n        raw_s->fd = qemu_open(state->bs->filename, raw_s->open_flags);\n\n        if (raw_s->fd == -1) {\n\n            error_setg_errno(errp, errno, \"Could not reopen file\");\n\n            ret = -1;\n\n        }\n\n    }\n\n\n\n    /* Fail already reopen_prepare() if we can't get a working O_DIRECT\n\n     * alignment with the new fd. */\n\n    if (raw_s->fd != -1) {\n\n        raw_probe_alignment(state->bs, raw_s->fd, &local_err);\n\n        if (local_err) {\n\n            qemu_close(raw_s->fd);\n\n            raw_s->fd = -1;\n\n            error_propagate(errp, local_err);\n\n            ret = -EINVAL;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 13017, "_split": "valid", "_hash": "560775a34e2579dc6a9e9ae8c31f1d32"}
{"project": "qemu", "commit_id": "75e347d66ab81944b5b657d17cc90ef92af3f016", "target": 1, "func": "static int enable_write_target(BDRVVVFATState *s, Error **errp)\n\n{\n\n    BlockDriver *bdrv_qcow;\n\n    QEMUOptionParameter *options;\n\n    int ret;\n\n    int size = sector2cluster(s, s->sector_count);\n\n    s->used_clusters = calloc(size, 1);\n\n\n\n    array_init(&(s->commits), sizeof(commit_t));\n\n\n\n    s->qcow_filename = g_malloc(1024);\n\n    ret = get_tmp_filename(s->qcow_filename, 1024);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"can't create temporary file\");\n\n        goto err;\n\n    }\n\n\n\n    bdrv_qcow = bdrv_find_format(\"qcow\");\n\n    options = parse_option_parameters(\"\", bdrv_qcow->create_options, NULL);\n\n    set_option_parameter_int(options, BLOCK_OPT_SIZE, s->sector_count * 512);\n\n    set_option_parameter(options, BLOCK_OPT_BACKING_FILE, \"fat:\");\n\n\n\n    ret = bdrv_create(bdrv_qcow, s->qcow_filename, options, errp);\n\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    s->qcow = NULL;\n\n    ret = bdrv_open(&s->qcow, s->qcow_filename, NULL, NULL,\n\n                    BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH,\n\n                    bdrv_qcow, errp);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n#ifndef _WIN32\n\n    unlink(s->qcow_filename);\n\n#endif\n\n\n\n    bdrv_set_backing_hd(s->bs, bdrv_new(\"\", &error_abort));\n\n    s->bs->backing_hd->drv = &vvfat_write_target;\n\n    s->bs->backing_hd->opaque = g_malloc(sizeof(void*));\n\n    *(void**)s->bs->backing_hd->opaque = s;\n\n\n\n    return 0;\n\n\n\nerr:\n\n    g_free(s->qcow_filename);\n\n    s->qcow_filename = NULL;\n\n    return ret;\n\n}", "idx": 13036, "_split": "valid", "_hash": "0f6a14b3667c3c93b6fe9fb4a4eaca55"}
{"project": "qemu", "commit_id": "412e0e81b17488e228b4f8451df6a4af26064bb4", "target": 0, "func": "static unsigned virtqueue_read_next_desc(VirtIODevice *vdev, VRingDesc *desc,\n\n                                         hwaddr desc_pa, unsigned int max)\n\n{\n\n    unsigned int next;\n\n\n\n    /* If this descriptor says it doesn't chain, we're done. */\n\n    if (!(desc->flags & VRING_DESC_F_NEXT)) {\n\n        return max;\n\n    }\n\n\n\n    /* Check they're not leading us off end of descriptors. */\n\n    next = desc->next;\n\n    /* Make sure compiler knows to grab that: we don't want it changing! */\n\n    smp_wmb();\n\n\n\n    if (next >= max) {\n\n        error_report(\"Desc next is %u\", next);\n\n        exit(1);\n\n    }\n\n\n\n    vring_desc_read(vdev, desc, desc_pa, next);\n\n    return next;\n\n}\n", "idx": 13046, "_split": "valid", "_hash": "8e012841e80e1dc7c91010d30859d920"}
{"project": "qemu", "commit_id": "f8b0aa25599782eef91edc00ebf620bd14db720c", "target": 0, "func": "static void setup_rt_frame(int usig, struct emulated_sigaction *ka,\n\n                           target_siginfo_t *info,\n\n\t\t\t   target_sigset_t *set, CPUState *env)\n\n{\n\n\tstruct rt_sigframe *frame;\n\n\tabi_ulong frame_addr = get_sigframe(ka, env, sizeof(*frame));\n\n\tstruct target_sigaltstack stack;\n\n\tint i, err = 0;\n\n\n\n\tif (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0))\n\n            return /* 1 */;\n\n\n\n\t__put_user_error(&frame->info, (abi_ulong *)&frame->pinfo, err);\n\n\t__put_user_error(&frame->uc, (abi_ulong *)&frame->puc, err);\n\n\terr |= copy_siginfo_to_user(&frame->info, info);\n\n\n\n\t/* Clear all the bits of the ucontext we don't use.  */\n\n\tmemset(&frame->uc, 0, offsetof(struct target_ucontext, tuc_mcontext));\n\n\n\n        memset(&stack, 0, sizeof(stack));\n\n        __put_user(target_sigaltstack_used.ss_sp, &stack.ss_sp);\n\n        __put_user(target_sigaltstack_used.ss_size, &stack.ss_size);\n\n        __put_user(sas_ss_flags(get_sp_from_cpustate(env)), &stack.ss_flags);\n\n        memcpy(&frame->uc.tuc_stack, &stack, sizeof(stack));\n\n\n\n\terr |= setup_sigcontext(&frame->uc.tuc_mcontext, /*&frame->fpstate,*/\n\n\t\t\t\tenv, set->sig[0]);\n\n        for(i = 0; i < TARGET_NSIG_WORDS; i++) {\n\n            if (__put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]))\n\n                goto end;\n\n        }\n\n\n\n\tif (err == 0)\n\n\t\terr = setup_return(env, ka, &frame->retcode, frame, usig);\n\n\n\n\tif (err == 0) {\n\n\t\t/*\n\n\t\t * For realtime signals we must also set the second and third\n\n\t\t * arguments for the signal handler.\n\n\t\t *   -- Peter Maydell <pmaydell@chiark.greenend.org.uk> 2000-12-06\n\n\t\t */\n\n            env->regs[1] = (abi_ulong)frame->pinfo;\n\n            env->regs[2] = (abi_ulong)frame->puc;\n\n\t}\n\n\n\nend:\n\n\tunlock_user_struct(frame, frame_addr, 1);\n\n\n\n        //\treturn err;\n\n}\n", "idx": 13060, "_split": "valid", "_hash": "15248ac603b85b4734fa6f503bc96391"}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_POWER_abso (void)\n\n{\n\n    if (T0 == INT32_MIN) {\n\n        T0 = INT32_MAX;\n\n        xer_ov = 1;\n\n        xer_so = 1;\n\n    } else {\n\n        T0 = -T0;\n\n        xer_ov = 0;\n\n    }\n\n}\n", "idx": 13091, "_split": "valid", "_hash": "00f85678a4e475b7c18c7a70fba40c8a"}
{"project": "qemu", "commit_id": "d3532a0db02296e687711b8cdc7791924efccea0", "target": 1, "func": "static int cirrus_bitblt_common_patterncopy(CirrusVGAState * s,\n\n\t\t\t\t\t    const uint8_t * src)\n\n{\n\n    uint8_t *dst;\n\n\n\n    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);\n\n\n\n    if (BLTUNSAFE(s))\n\n        return 0;\n\n\n\n    (*s->cirrus_rop) (s, dst, src,\n\n                      s->cirrus_blt_dstpitch, 0,\n\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n                             s->cirrus_blt_height);\n\n    return 1;\n\n}\n", "idx": 13135, "_split": "valid", "_hash": "fb1ae61c3dd14d473b5101352bc1377d"}
{"project": "qemu", "commit_id": "722387e78daf6a330220082934cfaaf68fa4d492", "target": 0, "func": "static void spapr_core_pre_plug(HotplugHandler *hotplug_dev, DeviceState *dev,\n\n                                Error **errp)\n\n{\n\n    MachineState *machine = MACHINE(OBJECT(hotplug_dev));\n\n    MachineClass *mc = MACHINE_GET_CLASS(hotplug_dev);\n\n    Error *local_err = NULL;\n\n    CPUCore *cc = CPU_CORE(dev);\n\n    sPAPRCPUCore *sc = SPAPR_CPU_CORE(dev);\n\n    char *base_core_type = spapr_get_cpu_core_type(machine->cpu_model);\n\n    const char *type = object_get_typename(OBJECT(dev));\n\n    CPUArchId *core_slot;\n\n    int node_id;\n\n    int index;\n\n\n\n    if (dev->hotplugged && !mc->has_hotpluggable_cpus) {\n\n        error_setg(&local_err, \"CPU hotplug not supported for this machine\");\n\n        goto out;\n\n    }\n\n\n\n    if (strcmp(base_core_type, type)) {\n\n        error_setg(&local_err, \"CPU core type should be %s\", base_core_type);\n\n        goto out;\n\n    }\n\n\n\n    if (cc->core_id % smp_threads) {\n\n        error_setg(&local_err, \"invalid core id %d\", cc->core_id);\n\n        goto out;\n\n    }\n\n\n\n    if (cc->nr_threads != smp_threads) {\n\n        error_setg(errp, \"invalid nr-threads %d, must be %d\",\n\n                   cc->nr_threads, smp_threads);\n\n        return;\n\n    }\n\n\n\n    core_slot = spapr_find_cpu_slot(MACHINE(hotplug_dev), cc->core_id, &index);\n\n    if (!core_slot) {\n\n        error_setg(&local_err, \"core id %d out of range\", cc->core_id);\n\n        goto out;\n\n    }\n\n\n\n    if (core_slot->cpu) {\n\n        error_setg(&local_err, \"core %d already populated\", cc->core_id);\n\n        goto out;\n\n    }\n\n\n\n    node_id = numa_get_node_for_cpu(cc->core_id);\n\n    if (node_id == nb_numa_nodes) {\n\n        /* by default CPUState::numa_node was 0 if it's not set via CLI\n\n         * keep it this way for now but in future we probably should\n\n         * refuse to start up with incomplete numa mapping */\n\n        node_id = 0;\n\n    }\n\n    if (sc->node_id == CPU_UNSET_NUMA_NODE_ID) {\n\n        sc->node_id = node_id;\n\n    } else if (sc->node_id != node_id) {\n\n        error_setg(&local_err, \"node-id %d must match numa node specified\"\n\n            \"with -numa option for cpu-index %d\", sc->node_id, cc->core_id);\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    g_free(base_core_type);\n\n    error_propagate(errp, local_err);\n\n}\n", "idx": 13167, "_split": "valid", "_hash": "482873003bca39fd5e1220219620e748"}
{"project": "qemu", "commit_id": "225d4be7099f0cfdf5c85b4e4be1fa1e5169543c", "target": 0, "func": "void sparc_iommu_memory_rw(void *opaque, target_phys_addr_t addr,\n\n                           uint8_t *buf, int len, int is_write)\n\n{\n\n    int l;\n\n    uint32_t flags;\n\n    target_phys_addr_t page, phys_addr;\n\n\n\n    while (len > 0) {\n\n        page = addr & TARGET_PAGE_MASK;\n\n        l = (page + TARGET_PAGE_SIZE) - addr;\n\n        if (l > len)\n\n            l = len;\n\n        flags = iommu_page_get_flags(opaque, page);\n\n        if (!(flags & IOPTE_VALID))\n\n            return;\n\n        phys_addr = iommu_translate_pa(opaque, addr, flags);\n\n        if (is_write) {\n\n            if (!(flags & IOPTE_WRITE))\n\n                return;\n\n            cpu_physical_memory_write(phys_addr, buf, len);\n\n        } else {\n\n            cpu_physical_memory_read(phys_addr, buf, len);\n\n        }\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n    }\n\n}\n", "idx": 13176, "_split": "valid", "_hash": "f2348338d3c55c9533019b13fa5d11cb"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void *qemu_try_blockalign0(BlockDriverState *bs, size_t size)\n\n{\n\n    void *mem = qemu_try_blockalign(bs, size);\n\n\n\n    if (mem) {\n\n        memset(mem, 0, size);\n\n    }\n\n\n\n    return mem;\n\n}\n", "idx": 13180, "_split": "valid", "_hash": "85581b693e5d3e93ec025f5db28e8f6e"}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_underflow(void)\n\n{\n\n    const char *str = \"-99999999999999999999999999999999999999999999\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err  = qemu_strtoul(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, -ERANGE);\n\n    g_assert_cmpint(res, ==, -1ul);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n", "idx": 13182, "_split": "valid", "_hash": "4567d1ffc61b4313234fc26f1b7a2b97"}
{"project": "qemu", "commit_id": "675463d9b6b2c2b65a713a6d906aeebe9e6750ae", "target": 1, "func": "void isa_bus_irqs(ISABus *bus, qemu_irq *irqs)\n\n{\n\n    if (!bus) {\n\n        hw_error(\"Can't set isa irqs with no isa bus present.\");\n\n    }\n\n    bus->irqs = irqs;\n\n}\n", "idx": 13248, "_split": "valid", "_hash": "8bb72a539313df82833448dbb7b07a0a"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_put_buffer(QEMUFile *f, const uint8_t *buf, int size)\n\n{\n\n    int l;\n\n\n\n    if (f->last_error) {\n\n        return;\n\n    }\n\n\n\n    while (size > 0) {\n\n        l = IO_BUF_SIZE - f->buf_index;\n\n        if (l > size) {\n\n            l = size;\n\n        }\n\n        memcpy(f->buf + f->buf_index, buf, l);\n\n        f->bytes_xfer += l;\n\n        if (f->ops->writev_buffer) {\n\n            add_to_iovec(f, f->buf + f->buf_index, l);\n\n        }\n\n        f->buf_index += l;\n\n        if (f->buf_index == IO_BUF_SIZE) {\n\n            qemu_fflush(f);\n\n        }\n\n        if (qemu_file_get_error(f)) {\n\n            break;\n\n        }\n\n        buf += l;\n\n        size -= l;\n\n    }\n\n}\n", "idx": 13270, "_split": "valid", "_hash": "211ddc9f511365e5967faf57f570f8d6"}
{"project": "qemu", "commit_id": "3bcbe4aa803c1a41e5392ecac7b4fc3c99a42f89", "target": 1, "func": "static void process_ncq_command(AHCIState *s, int port, uint8_t *cmd_fis,\n\n                                int slot)\n\n{\n\n    AHCIDevice *ad = &s->dev[port];\n\n    IDEState *ide_state = &ad->port.ifs[0];\n\n    NCQFrame *ncq_fis = (NCQFrame*)cmd_fis;\n\n    uint8_t tag = ncq_fis->tag >> 3;\n\n    NCQTransferState *ncq_tfs = &ad->ncq_tfs[tag];\n\n\n\n    if (ncq_tfs->used) {\n\n        /* error - already in use */\n\n        fprintf(stderr, \"%s: tag %d already used\\n\", __FUNCTION__, tag);\n\n        return;\n\n    }\n\n\n\n    ncq_tfs->used = 1;\n\n    ncq_tfs->drive = ad;\n\n    ncq_tfs->slot = slot;\n\n    ncq_tfs->lba = ((uint64_t)ncq_fis->lba5 << 40) |\n\n                   ((uint64_t)ncq_fis->lba4 << 32) |\n\n                   ((uint64_t)ncq_fis->lba3 << 24) |\n\n                   ((uint64_t)ncq_fis->lba2 << 16) |\n\n                   ((uint64_t)ncq_fis->lba1 << 8) |\n\n                   (uint64_t)ncq_fis->lba0;\n\n\n\n    /* Note: We calculate the sector count, but don't currently rely on it.\n\n     * The total size of the DMA buffer tells us the transfer size instead. */\n\n    ncq_tfs->sector_count = ((uint16_t)ncq_fis->sector_count_high << 8) |\n\n                                ncq_fis->sector_count_low;\n\n\n\n    DPRINTF(port, \"NCQ transfer LBA from %\"PRId64\" to %\"PRId64\", \"\n\n            \"drive max %\"PRId64\"\\n\",\n\n            ncq_tfs->lba, ncq_tfs->lba + ncq_tfs->sector_count - 2,\n\n            ide_state->nb_sectors - 1);\n\n\n\n    ahci_populate_sglist(ad, &ncq_tfs->sglist, 0);\n\n    ncq_tfs->tag = tag;\n\n\n\n    switch(ncq_fis->command) {\n\n        case READ_FPDMA_QUEUED:\n\n            DPRINTF(port, \"NCQ reading %d sectors from LBA %\"PRId64\", \"\n\n                    \"tag %d\\n\",\n\n                    ncq_tfs->sector_count-1, ncq_tfs->lba, ncq_tfs->tag);\n\n\n\n            DPRINTF(port, \"tag %d aio read %\"PRId64\"\\n\",\n\n                    ncq_tfs->tag, ncq_tfs->lba);\n\n\n\n            dma_acct_start(ide_state->blk, &ncq_tfs->acct,\n\n                           &ncq_tfs->sglist, BLOCK_ACCT_READ);\n\n            ncq_tfs->aiocb = dma_blk_read(ide_state->blk,\n\n                                          &ncq_tfs->sglist, ncq_tfs->lba,\n\n                                          ncq_cb, ncq_tfs);\n\n            break;\n\n        case WRITE_FPDMA_QUEUED:\n\n            DPRINTF(port, \"NCQ writing %d sectors to LBA %\"PRId64\", tag %d\\n\",\n\n                    ncq_tfs->sector_count-1, ncq_tfs->lba, ncq_tfs->tag);\n\n\n\n            DPRINTF(port, \"tag %d aio write %\"PRId64\"\\n\",\n\n                    ncq_tfs->tag, ncq_tfs->lba);\n\n\n\n            dma_acct_start(ide_state->blk, &ncq_tfs->acct,\n\n                           &ncq_tfs->sglist, BLOCK_ACCT_WRITE);\n\n            ncq_tfs->aiocb = dma_blk_write(ide_state->blk,\n\n                                           &ncq_tfs->sglist, ncq_tfs->lba,\n\n                                           ncq_cb, ncq_tfs);\n\n            break;\n\n        default:\n\n            if (is_ncq(cmd_fis[2])) {\n\n                DPRINTF(port,\n\n                        \"error: unsupported NCQ command (0x%02x) received\\n\",\n\n                        cmd_fis[2]);\n\n            } else {\n\n                DPRINTF(port,\n\n                        \"error: tried to process non-NCQ command as NCQ\\n\");\n\n            }\n\n            qemu_sglist_destroy(&ncq_tfs->sglist);\n\n    }\n\n}\n", "idx": 13291, "_split": "valid", "_hash": "2f1dad109fe8cb5e2d4d51cb3101614b"}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void pl190_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    k->init = pl190_init;\n\n    dc->no_user = 1;\n\n    dc->reset = pl190_reset;\n\n    dc->vmsd = &vmstate_pl190;\n\n}\n", "idx": 13293, "_split": "valid", "_hash": "10e426b12f5f10c25536dc28dc1d4543"}
{"project": "qemu", "commit_id": "a21a7a701252717f05defee8a1a33d72c28fabb7", "target": 1, "func": "static void spapr_finalize_fdt(sPAPREnvironment *spapr,\n\n                               hwaddr fdt_addr,\n\n                               hwaddr rtas_addr,\n\n                               hwaddr rtas_size)\n\n{\n\n    int ret, i;\n\n    size_t cb = 0;\n\n    char *bootlist;\n\n    void *fdt;\n\n    sPAPRPHBState *phb;\n\n\n\n    fdt = g_malloc(FDT_MAX_SIZE);\n\n\n\n    /* open out the base tree into a temp buffer for the final tweaks */\n\n    _FDT((fdt_open_into(spapr->fdt_skel, fdt, FDT_MAX_SIZE)));\n\n\n\n    ret = spapr_populate_memory(spapr, fdt);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"couldn't setup memory nodes in fdt\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    ret = spapr_populate_vdevice(spapr->vio_bus, fdt);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"couldn't setup vio devices in fdt\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    QLIST_FOREACH(phb, &spapr->phbs, list) {\n\n        ret = spapr_populate_pci_dt(phb, PHANDLE_XICP, fdt);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"couldn't setup PCI devices in fdt\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* RTAS */\n\n    ret = spapr_rtas_device_tree_setup(fdt, rtas_addr, rtas_size);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"Couldn't set up RTAS device tree properties\\n\");\n\n    }\n\n\n\n    /* Advertise NUMA via ibm,associativity */\n\n    ret = spapr_fixup_cpu_dt(fdt, spapr);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"Couldn't finalize CPU device tree properties\\n\");\n\n    }\n\n\n\n    bootlist = get_boot_devices_list(&cb, true);\n\n    if (cb && bootlist) {\n\n        int offset = fdt_path_offset(fdt, \"/chosen\");\n\n        if (offset < 0) {\n\n            exit(1);\n\n        }\n\n        for (i = 0; i < cb; i++) {\n\n            if (bootlist[i] == '\\n') {\n\n                bootlist[i] = ' ';\n\n            }\n\n\n\n        }\n\n        ret = fdt_setprop_string(fdt, offset, \"qemu,boot-list\", bootlist);\n\n    }\n\n\n\n    if (!spapr->has_graphics) {\n\n        spapr_populate_chosen_stdout(fdt, spapr->vio_bus);\n\n    }\n\n\n\n    _FDT((fdt_pack(fdt)));\n\n\n\n    if (fdt_totalsize(fdt) > FDT_MAX_SIZE) {\n\n        hw_error(\"FDT too big ! 0x%x bytes (max is 0x%x)\\n\",\n\n                 fdt_totalsize(fdt), FDT_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n\n\n    cpu_physical_memory_write(fdt_addr, fdt, fdt_totalsize(fdt));\n\n\n\n\n    g_free(fdt);\n\n}", "idx": 13303, "_split": "valid", "_hash": "861574d0bd601492bdee92827175feee"}
{"project": "qemu", "commit_id": "ab7a0f0b6dbe8836d490c736803abef6e3695e1f", "target": 1, "func": "static void pxa2xx_gpio_write(void *opaque, hwaddr offset,\n\n                              uint64_t value, unsigned size)\n\n{\n\n    PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque;\n\n    int bank;\n\n    if (offset >= 0x200)\n\n        return;\n\n\n\n    bank = pxa2xx_gpio_regs[offset].bank;\n\n    switch (pxa2xx_gpio_regs[offset].reg) {\n\n    case GPDR:\t\t/* GPIO Pin-Direction registers */\n\n        s->dir[bank] = value;\n\n        pxa2xx_gpio_handler_update(s);\n\n        break;\n\n\n\n    case GPSR:\t\t/* GPIO Pin-Output Set registers */\n\n        s->olevel[bank] |= value;\n\n        pxa2xx_gpio_handler_update(s);\n\n        s->gpsr[bank] = value;\n\n        break;\n\n\n\n    case GPCR:\t\t/* GPIO Pin-Output Clear registers */\n\n        s->olevel[bank] &= ~value;\n\n        pxa2xx_gpio_handler_update(s);\n\n        break;\n\n\n\n    case GRER:\t\t/* GPIO Rising-Edge Detect Enable registers */\n\n        s->rising[bank] = value;\n\n        break;\n\n\n\n    case GFER:\t\t/* GPIO Falling-Edge Detect Enable registers */\n\n        s->falling[bank] = value;\n\n        break;\n\n\n\n    case GAFR_L:\t/* GPIO Alternate Function registers */\n\n        s->gafr[bank * 2] = value;\n\n        break;\n\n\n\n    case GAFR_U:\t/* GPIO Alternate Function registers */\n\n        s->gafr[bank * 2 + 1] = value;\n\n        break;\n\n\n\n    case GEDR:\t\t/* GPIO Edge Detect Status registers */\n\n        s->status[bank] &= ~value;\n\n        pxa2xx_gpio_irq_update(s);\n\n        break;\n\n\n\n    default:\n\n        hw_error(\"%s: Bad offset \" REG_FMT \"\\n\", __FUNCTION__, offset);\n\n    }\n\n}\n", "idx": 13324, "_split": "valid", "_hash": "b42a25c85114811113f20070a76fb24f"}
{"project": "qemu", "commit_id": "21f88d021d0d2b4ecee8f6cd6ca63a943a3ce71d", "target": 1, "func": "opts_check_struct(Visitor *v, Error **errp)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n    GHashTableIter iter;\n\n    GQueue *any;\n\n\n\n    if (ov->depth > 0) {\n\n        return;\n\n    }\n\n\n\n    /* we should have processed all (distinct) QemuOpt instances */\n\n    g_hash_table_iter_init(&iter, ov->unprocessed_opts);\n\n    if (g_hash_table_iter_next(&iter, NULL, (void **)&any)) {\n\n        const QemuOpt *first;\n\n\n\n        first = g_queue_peek_head(any);\n\n        error_setg(errp, QERR_INVALID_PARAMETER, first->name);\n\n    }\n\n}\n", "idx": 13337, "_split": "valid", "_hash": "4a94134df42d50643ba00a966e65ffdc"}
{"project": "qemu", "commit_id": "d5b27167e17e0d9393d6364703cc68e7f018023c", "target": 1, "func": "static int parse_chr(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    CharDriverState **ptr = qdev_get_prop_ptr(dev, prop);\n\n\n\n    *ptr = qemu_chr_find(str);\n\n    if (*ptr == NULL) {\n\n        return -ENOENT;\n\n    }\n\n    if ((*ptr)->assigned) {\n\n        return -EEXIST;\n\n    }\n\n    (*ptr)->assigned = 1;\n\n    return 0;\n\n}\n", "idx": 13346, "_split": "valid", "_hash": "999fed05abbaf5dfd74854866d382980"}
{"project": "qemu", "commit_id": "45a50b1668822c23afc2a89f724654e176518bc4", "target": 0, "func": "int load_uimage(const char *filename, target_phys_addr_t *ep,\n\n                target_phys_addr_t *loadaddr, int *is_linux)\n\n{\n\n    int fd;\n\n    int size;\n\n    uboot_image_header_t h;\n\n    uboot_image_header_t *hdr = &h;\n\n    uint8_t *data = NULL;\n\n    int ret = -1;\n\n\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n\n    if (fd < 0)\n\n        return -1;\n\n\n\n    size = read(fd, hdr, sizeof(uboot_image_header_t));\n\n    if (size < 0)\n\n        goto out;\n\n\n\n    bswap_uboot_header(hdr);\n\n\n\n    if (hdr->ih_magic != IH_MAGIC)\n\n        goto out;\n\n\n\n    /* TODO: Implement other image types.  */\n\n    if (hdr->ih_type != IH_TYPE_KERNEL) {\n\n        fprintf(stderr, \"Can only load u-boot image type \\\"kernel\\\"\\n\");\n\n        goto out;\n\n    }\n\n\n\n    switch (hdr->ih_comp) {\n\n    case IH_COMP_NONE:\n\n    case IH_COMP_GZIP:\n\n        break;\n\n    default:\n\n        fprintf(stderr,\n\n                \"Unable to load u-boot images with compression type %d\\n\",\n\n                hdr->ih_comp);\n\n        goto out;\n\n    }\n\n\n\n    /* TODO: Check CPU type.  */\n\n    if (is_linux) {\n\n        if (hdr->ih_os == IH_OS_LINUX)\n\n            *is_linux = 1;\n\n        else\n\n            *is_linux = 0;\n\n    }\n\n\n\n    *ep = hdr->ih_ep;\n\n    data = qemu_malloc(hdr->ih_size);\n\n\n\n    if (read(fd, data, hdr->ih_size) != hdr->ih_size) {\n\n        fprintf(stderr, \"Error reading file\\n\");\n\n        goto out;\n\n    }\n\n\n\n    if (hdr->ih_comp == IH_COMP_GZIP) {\n\n        uint8_t *compressed_data;\n\n        size_t max_bytes;\n\n        ssize_t bytes;\n\n\n\n        compressed_data = data;\n\n        max_bytes = UBOOT_MAX_GUNZIP_BYTES;\n\n        data = qemu_malloc(max_bytes);\n\n\n\n        bytes = gunzip(data, max_bytes, compressed_data, hdr->ih_size);\n\n        qemu_free(compressed_data);\n\n        if (bytes < 0) {\n\n            fprintf(stderr, \"Unable to decompress gzipped image!\\n\");\n\n            goto out;\n\n        }\n\n        hdr->ih_size = bytes;\n\n    }\n\n\n\n    cpu_physical_memory_write_rom(hdr->ih_load, data, hdr->ih_size);\n\n\n\n    if (loadaddr)\n\n        *loadaddr = hdr->ih_load;\n\n\n\n    ret = hdr->ih_size;\n\n\n\nout:\n\n    if (data)\n\n        qemu_free(data);\n\n    close(fd);\n\n    return ret;\n\n}\n", "idx": 13360, "_split": "valid", "_hash": "4ff4487032a732969e5a4df653ea0c38"}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void fpu_dump_state(CPUState *env, FILE *f, \n\n                    int (*fpu_fprintf)(FILE *f, const char *fmt, ...),\n\n                    int flags)\n\n{\n\n    int i;\n\n    int is_fpu64 = !!(env->CP0_Status & (1 << CP0St_FR));\n\n\n\n#define printfpr(fp)                                                        \\\n\n    do {                                                                    \\\n\n        if (is_fpu64)                                                       \\\n\n            fpu_fprintf(f, \"w:%08x d:%016lx fd:%13g fs:%13g psu: %13g\\n\",   \\\n\n                        (fp)->w[FP_ENDIAN_IDX], (fp)->d, (fp)->fd,          \\\n\n                        (fp)->fs[FP_ENDIAN_IDX], (fp)->fs[!FP_ENDIAN_IDX]); \\\n\n        else {                                                              \\\n\n            fpr_t tmp;                                                      \\\n\n            tmp.w[FP_ENDIAN_IDX] = (fp)->w[FP_ENDIAN_IDX];                  \\\n\n            tmp.w[!FP_ENDIAN_IDX] = ((fp) + 1)->w[FP_ENDIAN_IDX];           \\\n\n            fpu_fprintf(f, \"w:%08x d:%016lx fd:%13g fs:%13g psu:%13g\\n\",    \\\n\n                        tmp.w[FP_ENDIAN_IDX], tmp.d, tmp.fd,                \\\n\n                        tmp.fs[FP_ENDIAN_IDX], tmp.fs[!FP_ENDIAN_IDX]);     \\\n\n        }                                                                   \\\n\n    } while(0)\n\n\n\n\n\n    fpu_fprintf(f, \"CP1 FCR0 0x%08x  FCR31 0x%08x  SR.FR %d  fp_status 0x%08x(0x%02x)\\n\",\n\n                env->fcr0, env->fcr31, is_fpu64, env->fp_status, get_float_exception_flags(&env->fp_status));\n\n    fpu_fprintf(f, \"FT0: \"); printfpr(&env->ft0);\n\n    fpu_fprintf(f, \"FT1: \"); printfpr(&env->ft1);\n\n    fpu_fprintf(f, \"FT2: \"); printfpr(&env->ft2);\n\n    for (i = 0; i < 32; (is_fpu64) ? i++ : (i += 2)) {\n\n        fpu_fprintf(f, \"%3s: \", fregnames[i]);\n\n        printfpr(&env->fpr[i]);\n\n    }\n\n\n\n#undef printfpr\n\n}\n", "idx": 13367, "_split": "valid", "_hash": "fba763992aaeef397100cd448eff4020"}
{"project": "qemu", "commit_id": "8d2f850a5ab7579a852f23b28273940a47dfd7ff", "target": 0, "func": "uint32_t HELPER(mvcos)(CPUS390XState *env, uint64_t dest, uint64_t src,\n\n                       uint64_t len)\n\n{\n\n    const uint8_t psw_key = (env->psw.mask & PSW_MASK_KEY) >> PSW_SHIFT_KEY;\n\n    const uint8_t psw_as = (env->psw.mask & PSW_MASK_ASC) >> PSW_SHIFT_ASC;\n\n    const uint64_t r0 = env->regs[0];\n\n    const uintptr_t ra = GETPC();\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    uint8_t dest_key, dest_as, dest_k, dest_a;\n\n    uint8_t src_key, src_as, src_k, src_a;\n\n    uint64_t val;\n\n    int cc = 0;\n\n\n\n    HELPER_LOG(\"%s dest %\" PRIx64 \", src %\" PRIx64 \", len %\" PRIx64 \"\\n\",\n\n               __func__, dest, src, len);\n\n\n\n    if (!(env->psw.mask & PSW_MASK_DAT)) {\n\n        cpu_restore_state(cs, ra);\n\n        program_interrupt(env, PGM_SPECIAL_OP, 6);\n\n    }\n\n\n\n    /* OAC (operand access control) for the first operand -> dest */\n\n    val = (r0 & 0xffff0000ULL) >> 16;\n\n    dest_key = (val >> 12) & 0xf;\n\n    dest_as = (val >> 6) & 0x3;\n\n    dest_k = (val >> 1) & 0x1;\n\n    dest_a = val & 0x1;\n\n\n\n    /* OAC (operand access control) for the second operand -> src */\n\n    val = (r0 & 0x0000ffffULL);\n\n    src_key = (val >> 12) & 0xf;\n\n    src_as = (val >> 6) & 0x3;\n\n    src_k = (val >> 1) & 0x1;\n\n    src_a = val & 0x1;\n\n\n\n    if (!dest_k) {\n\n        dest_key = psw_key;\n\n    }\n\n    if (!src_k) {\n\n        src_key = psw_key;\n\n    }\n\n    if (!dest_a) {\n\n        dest_as = psw_as;\n\n    }\n\n    if (!src_a) {\n\n        src_as = psw_as;\n\n    }\n\n\n\n    if (dest_a && dest_as == AS_HOME && (env->psw.mask & PSW_MASK_PSTATE)) {\n\n        cpu_restore_state(cs, ra);\n\n        program_interrupt(env, PGM_SPECIAL_OP, 6);\n\n    }\n\n    if (!(env->cregs[0] & CR0_SECONDARY) &&\n\n        (dest_as == AS_SECONDARY || src_as == AS_SECONDARY)) {\n\n        cpu_restore_state(cs, ra);\n\n        program_interrupt(env, PGM_SPECIAL_OP, 6);\n\n    }\n\n    if (!psw_key_valid(env, dest_key) || !psw_key_valid(env, src_key)) {\n\n        cpu_restore_state(cs, ra);\n\n        program_interrupt(env, PGM_PRIVILEGED, 6);\n\n    }\n\n\n\n    len = wrap_length(env, len);\n\n    if (len > 4096) {\n\n        cc = 3;\n\n        len = 4096;\n\n    }\n\n\n\n    /* FIXME: AR-mode and proper problem state mode (using PSW keys) missing */\n\n    if (src_as == AS_ACCREG || dest_as == AS_ACCREG ||\n\n        (env->psw.mask & PSW_MASK_PSTATE)) {\n\n        qemu_log_mask(LOG_UNIMP, \"%s: AR-mode and PSTATE support missing\\n\",\n\n                      __func__);\n\n        cpu_restore_state(cs, ra);\n\n        program_interrupt(env, PGM_ADDRESSING, 6);\n\n    }\n\n\n\n    /* FIXME: a) LAP\n\n     *        b) Access using correct keys\n\n     *        c) AR-mode\n\n     */\n\n#ifdef CONFIG_USER_ONLY\n\n    /* psw keys are never valid in user mode, we will never reach this */\n\n    g_assert_not_reached();\n\n#else\n\n    fast_memmove_as(env, dest, src, len, dest_as, src_as, ra);\n\n#endif\n\n\n\n    return cc;\n\n}\n", "idx": 13373, "_split": "valid", "_hash": "bb161dbe0a0791f4b598b022716f12e2"}
{"project": "qemu", "commit_id": "bf26ae32a92a8446bd9db569f9cdb53cc272aaad", "target": 0, "func": "static void unrealize(DeviceState *d, Error **errp)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);\n\n    Object *root_container;\n\n    char name[256];\n\n    Error *err = NULL;\n\n\n\n    trace_spapr_drc_unrealize(spapr_drc_index(drc));\n\n    root_container = container_get(object_get_root(), DRC_CONTAINER_PATH);\n\n    snprintf(name, sizeof(name), \"%x\", spapr_drc_index(drc));\n\n    object_property_del(root_container, name, &err);\n\n    if (err) {\n\n        error_report_err(err);\n\n        object_unref(OBJECT(drc));\n\n    }\n\n}\n", "idx": 13375, "_split": "valid", "_hash": "e6f5f568217058b231946db2b0cf060f"}
{"project": "qemu", "commit_id": "d1fdf257d52822695f5ace6c586e059aa17d4b79", "target": 0, "func": "static void nbd_co_receive_reply(NBDClientSession *s,\n\n                                 NBDRequest *request,\n\n                                 NBDReply *reply,\n\n                                 QEMUIOVector *qiov)\n\n{\n\n    int ret;\n\n\n\n    /* Wait until we're woken up by nbd_read_reply_entry.  */\n\n    qemu_coroutine_yield();\n\n    *reply = s->reply;\n\n    if (reply->handle != request->handle ||\n\n        !s->ioc) {\n\n        reply->error = EIO;\n\n    } else {\n\n        if (qiov && reply->error == 0) {\n\n            ret = nbd_wr_syncv(s->ioc, qiov->iov, qiov->niov, request->len,\n\n                               true, NULL);\n\n            if (ret != request->len) {\n\n                reply->error = EIO;\n\n            }\n\n        }\n\n\n\n        /* Tell the read handler to read another header.  */\n\n        s->reply.handle = 0;\n\n    }\n\n}\n", "idx": 13377, "_split": "valid", "_hash": "c6b4fea5ee13a926a1636f685d5aa321"}
{"project": "qemu", "commit_id": "554f802da3f8b09b16b9a84ad5847b2eb0e9ad2b", "target": 1, "func": "void pcie_cap_slot_hotplug_cb(HotplugHandler *hotplug_dev, DeviceState *dev,\n\n                              Error **errp)\n\n{\n\n    uint8_t *exp_cap;\n\n    PCIDevice *pci_dev = PCI_DEVICE(dev);\n\n\n\n    pcie_cap_slot_hotplug_common(PCI_DEVICE(hotplug_dev), dev, &exp_cap, errp);\n\n\n\n    /* Don't send event when device is enabled during qemu machine creation:\n\n     * it is present on boot, no hotplug event is necessary. We do send an\n\n     * event when the device is disabled later. */\n\n    if (!dev->hotplugged) {\n\n        pci_word_test_and_set_mask(exp_cap + PCI_EXP_SLTSTA,\n\n                                   PCI_EXP_SLTSTA_PDS);\n\n        return;\n\n    }\n\n\n\n    /* TODO: multifunction hot-plug.\n\n     * Right now, only a device of function = 0 is allowed to be\n\n     * hot plugged/unplugged.\n\n     */\n\n    assert(PCI_FUNC(pci_dev->devfn) == 0);\n\n\n\n    pci_word_test_and_set_mask(exp_cap + PCI_EXP_SLTSTA,\n\n                               PCI_EXP_SLTSTA_PDS);\n\n    pcie_cap_slot_event(PCI_DEVICE(hotplug_dev), PCI_EXP_HP_EV_PDC);\n\n}\n", "idx": 13396, "_split": "valid", "_hash": "04ec638ea098b02a02b4b06b66f685f0"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void do_info_snapshots(Monitor *mon)\n\n{\n\n    DriveInfo *dinfo;\n\n    BlockDriverState *bs, *bs1;\n\n    QEMUSnapshotInfo *sn_tab, *sn;\n\n    int nb_sns, i;\n\n    char buf[256];\n\n\n\n    bs = get_bs_snapshots();\n\n    if (!bs) {\n\n        monitor_printf(mon, \"No available block device supports snapshots\\n\");\n\n        return;\n\n    }\n\n    monitor_printf(mon, \"Snapshot devices:\");\n\n    TAILQ_FOREACH(dinfo, &drives, next) {\n\n        bs1 = dinfo->bdrv;\n\n        if (bdrv_has_snapshot(bs1)) {\n\n            if (bs == bs1)\n\n                monitor_printf(mon, \" %s\", bdrv_get_device_name(bs1));\n\n        }\n\n    }\n\n    monitor_printf(mon, \"\\n\");\n\n\n\n    nb_sns = bdrv_snapshot_list(bs, &sn_tab);\n\n    if (nb_sns < 0) {\n\n        monitor_printf(mon, \"bdrv_snapshot_list: error %d\\n\", nb_sns);\n\n        return;\n\n    }\n\n    monitor_printf(mon, \"Snapshot list (from %s):\\n\",\n\n                   bdrv_get_device_name(bs));\n\n    monitor_printf(mon, \"%s\\n\", bdrv_snapshot_dump(buf, sizeof(buf), NULL));\n\n    for(i = 0; i < nb_sns; i++) {\n\n        sn = &sn_tab[i];\n\n        monitor_printf(mon, \"%s\\n\", bdrv_snapshot_dump(buf, sizeof(buf), sn));\n\n    }\n\n    qemu_free(sn_tab);\n\n}\n", "idx": 13424, "_split": "valid", "_hash": "19563646a0da6d2e3f4a7634daf6c8c2"}
{"project": "qemu", "commit_id": "b08d0ea0446aa91f373c9df4254ba3bc4ee84098", "target": 0, "func": "static SCSIRequest *scsi_block_new_request(SCSIDevice *d, uint32_t tag,\n\n                                           uint32_t lun, uint8_t *buf,\n\n                                           void *hba_private)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n\n\n\n    switch (buf[0]) {\n\n    case READ_6:\n\n    case READ_10:\n\n    case READ_12:\n\n    case READ_16:\n\n    case VERIFY_10:\n\n    case VERIFY_12:\n\n    case VERIFY_16:\n\n    case WRITE_6:\n\n    case WRITE_10:\n\n    case WRITE_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_10:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_VERIFY_16:\n\n        /* If we are not using O_DIRECT, we might read stale data from the\n\n\t * host cache if writes were made using other commands than these\n\n\t * ones (such as WRITE SAME or EXTENDED COPY, etc.).  So, without\n\n\t * O_DIRECT everything must go through SG_IO.\n\n         */\n\n        if (bdrv_get_flags(s->qdev.conf.bs) & BDRV_O_NOCACHE) {\n\n            break;\n\n        }\n\n\n\n        /* MMC writing cannot be done via pread/pwrite, because it sometimes\n\n         * involves writing beyond the maximum LBA or to negative LBA (lead-in).\n\n         * And once you do these writes, reading from the block device is\n\n         * unreliable, too.  It is even possible that reads deliver random data\n\n         * from the host page cache (this is probably a Linux bug).\n\n         *\n\n         * We might use scsi_disk_reqops as long as no writing commands are\n\n         * seen, but performance usually isn't paramount on optical media.  So,\n\n         * just make scsi-block operate the same as scsi-generic for them.\n\n         */\n\n        if (s->qdev.type == TYPE_ROM) {\n\n            break;\n\n\t}\n\n        return scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun,\n\n                              hba_private);\n\n    }\n\n\n\n    return scsi_req_alloc(&scsi_generic_req_ops, &s->qdev, tag, lun,\n\n                          hba_private);\n\n}\n", "idx": 13427, "_split": "valid", "_hash": "982a5e9b5c6387cbcea044ad7838ec1f"}
{"project": "qemu", "commit_id": "faadf50e2962dd54175647a80bd6fc4319c91973", "target": 1, "func": "static void init_excp_4xx_softmmu (CPUPPCState *env)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->excp_vectors[POWERPC_EXCP_CRITICAL] = 0x00000100;\n\n    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;\n\n    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;\n\n    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;\n\n    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;\n\n    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;\n\n    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;\n\n    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;\n\n    env->excp_vectors[POWERPC_EXCP_PIT]      = 0x00001000;\n\n    env->excp_vectors[POWERPC_EXCP_FIT]      = 0x00001010;\n\n    env->excp_vectors[POWERPC_EXCP_WDT]      = 0x00001020;\n\n    env->excp_vectors[POWERPC_EXCP_DTLB]     = 0x00001100;\n\n    env->excp_vectors[POWERPC_EXCP_ITLB]     = 0x00001200;\n\n    env->excp_vectors[POWERPC_EXCP_DEBUG]    = 0x00002000;\n\n    env->excp_prefix = 0x00000000;\n\n    env->ivor_mask = 0x0000FFF0;\n\n    env->ivpr_mask = 0xFFFF0000;\n\n    /* Hardware reset vector */\n\n    env->hreset_vector = 0xFFFFFFFCUL;\n\n#endif\n\n}\n", "idx": 13449, "_split": "valid", "_hash": "aceaa46cfffc0c38fbf372e83acbbb1e"}
{"project": "qemu", "commit_id": "56c4bfb3f07f3107894c00281276aea4f5e8834d", "target": 1, "func": "int cpu_get_dump_info(ArchDumpInfo *info)\n\n{\n\n    return -1;\n\n}\n", "idx": 13459, "_split": "valid", "_hash": "3f5ef0b76494596af01cc98fe85aa285"}
{"project": "qemu", "commit_id": "eb513f82f04fab442cdef9db698dafc852275f7f", "target": 1, "func": "void helper_st_asi(CPUSPARCState *env, target_ulong addr, target_ulong val,\n\n                   int asi, int size)\n\n{\n\n#ifdef DEBUG_ASI\n\n    dump_asi(\"write\", addr, asi, size, val);\n\n#endif\n\n    if (asi < 0x80) {\n\n        helper_raise_exception(env, TT_PRIV_ACT);\n\n    }\n\n\n\n    helper_check_align(env, addr, size - 1);\n\n    addr = asi_address_mask(env, asi, addr);\n\n\n\n    /* Convert to little endian */\n\n    switch (asi) {\n\n    case 0x88: /* Primary LE */\n\n    case 0x89: /* Secondary LE */\n\n        switch (size) {\n\n        case 2:\n\n            val = bswap16(val);\n\n            break;\n\n        case 4:\n\n            val = bswap32(val);\n\n            break;\n\n        case 8:\n\n            val = bswap64(val);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    default:\n\n        break;\n\n    }\n\n\n\n    switch (asi) {\n\n    case 0x80: /* Primary */\n\n    case 0x88: /* Primary LE */\n\n        {\n\n            switch (size) {\n\n            case 1:\n\n                stb_raw(addr, val);\n\n                break;\n\n            case 2:\n\n                stw_raw(addr, val);\n\n                break;\n\n            case 4:\n\n                stl_raw(addr, val);\n\n                break;\n\n            case 8:\n\n            default:\n\n                stq_raw(addr, val);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    case 0x81: /* Secondary */\n\n    case 0x89: /* Secondary LE */\n\n        /* XXX */\n\n        return;\n\n\n\n    case 0x82: /* Primary no-fault, RO */\n\n    case 0x83: /* Secondary no-fault, RO */\n\n    case 0x8a: /* Primary no-fault LE, RO */\n\n    case 0x8b: /* Secondary no-fault LE, RO */\n\n    default:\n\n        helper_raise_exception(env, TT_DATA_ACCESS);\n\n        return;\n\n    }\n\n}\n", "idx": 13467, "_split": "valid", "_hash": "071a32403b90f84e49b53c9f3fca2f62"}
{"project": "qemu", "commit_id": "374ec0669a1aa3affac7850a16c6cad18221c439", "target": 1, "func": "static ssize_t sdp_svc_search_attr_get(struct bt_l2cap_sdp_state_s *sdp,\n\n                uint8_t *rsp, const uint8_t *req, ssize_t len)\n\n{\n\n    ssize_t seqlen;\n\n    int i, j, start, end, max;\n\n    struct sdp_service_record_s *record;\n\n    uint8_t *lst;\n\n\n\n    /* Perform the search */\n\n    for (i = 0; i < sdp->services; i ++) {\n\n        sdp->service_list[i].match = 0;\n\n            for (j = 0; j < sdp->service_list[i].attributes; j ++)\n\n                sdp->service_list[i].attribute_list[j].match = 0;\n\n    }\n\n\n\n    if (len < 1)\n\n        return -SDP_INVALID_SYNTAX;\n\n    if ((*req & ~SDP_DSIZE_MASK) == SDP_DTYPE_SEQ) {\n\n        seqlen = sdp_datalen(&req, &len);\n\n        if (seqlen < 3 || len < seqlen)\n\n            return -SDP_INVALID_SYNTAX;\n\n        len -= seqlen;\n\n\n\n        while (seqlen)\n\n            if (sdp_svc_match(sdp, &req, &seqlen))\n\n                return -SDP_INVALID_SYNTAX;\n\n    } else if (sdp_svc_match(sdp, &req, &seqlen))\n\n        return -SDP_INVALID_SYNTAX;\n\n\n\n    if (len < 3)\n\n        return -SDP_INVALID_SYNTAX;\n\n    max = (req[0] << 8) | req[1];\n\n    req += 2;\n\n    len -= 2;\n\n    if (max < 0x0007)\n\n        return -SDP_INVALID_SYNTAX;\n\n\n\n    if ((*req & ~SDP_DSIZE_MASK) == SDP_DTYPE_SEQ) {\n\n        seqlen = sdp_datalen(&req, &len);\n\n        if (seqlen < 3 || len < seqlen)\n\n            return -SDP_INVALID_SYNTAX;\n\n        len -= seqlen;\n\n\n\n        while (seqlen)\n\n            if (sdp_svc_attr_match(sdp, &req, &seqlen))\n\n                return -SDP_INVALID_SYNTAX;\n\n    } else if (sdp_svc_attr_match(sdp, &req, &seqlen))\n\n        return -SDP_INVALID_SYNTAX;\n\n\n\n    if (len < 1)\n\n        return -SDP_INVALID_SYNTAX;\n\n\n\n    if (*req) {\n\n        if (len <= sizeof(int))\n\n            return -SDP_INVALID_SYNTAX;\n\n        len -= sizeof(int);\n\n        memcpy(&start, req + 1, sizeof(int));\n\n    } else\n\n        start = 0;\n\n\n\n    if (len > 1)\n\n        return -SDP_INVALID_SYNTAX;\n\n\n\n    /* Output the results */\n\n    /* This assumes empty attribute lists are never to be returned even\n\n     * for matching Service Records.  In practice this shouldn't happen\n\n     * as the requestor will usually include the always present\n\n     * ServiceRecordHandle AttributeID in AttributeIDList.  */\n\n    lst = rsp + 2;\n\n    max = MIN(max, MAX_RSP_PARAM_SIZE);\n\n    len = 3 - start;\n\n    end = 0;\n\n    for (i = 0; i < sdp->services; i ++)\n\n        if ((record = &sdp->service_list[i])->match) {\n\n            len += 3;\n\n            seqlen = len;\n\n            for (j = 0; j < record->attributes; j ++)\n\n                if (record->attribute_list[j].match) {\n\n                    if (len >= 0)\n\n                        if (len + record->attribute_list[j].len < max) {\n\n                            memcpy(lst + len, record->attribute_list[j].pair,\n\n                                            record->attribute_list[j].len);\n\n                            end = len + record->attribute_list[j].len;\n\n                        }\n\n                    len += record->attribute_list[j].len;\n\n                }\n\n            if (seqlen == len)\n\n                len -= 3;\n\n            else if (seqlen >= 3 && seqlen < max) {\n\n                lst[seqlen - 3] = SDP_DTYPE_SEQ | SDP_DSIZE_NEXT2;\n\n                lst[seqlen - 2] = (len - seqlen) >> 8;\n\n                lst[seqlen - 1] = (len - seqlen) & 0xff;\n\n            }\n\n        }\n\n    if (len == 3 - start)\n\n        len -= 3;\n\n    else if (0 >= start) {\n\n       lst[0] = SDP_DTYPE_SEQ | SDP_DSIZE_NEXT2;\n\n       lst[1] = (len + start - 3) >> 8;\n\n       lst[2] = (len + start - 3) & 0xff;\n\n    }\n\n\n\n    rsp[0] = end >> 8;\n\n    rsp[1] = end & 0xff;\n\n\n\n    if (end < len) {\n\n        len = end + start;\n\n        lst[end ++] = sizeof(int);\n\n        memcpy(lst + end, &len, sizeof(int));\n\n        end += sizeof(int);\n\n    } else\n\n        lst[end ++] = 0;\n\n\n\n    return end + 2;\n\n}\n", "idx": 13483, "_split": "valid", "_hash": "4660d20777a9f59dc2698104feddc780"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void mcf_intc_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t val, unsigned size)\n\n{\n\n    int offset;\n\n    mcf_intc_state *s = (mcf_intc_state *)opaque;\n\n    offset = addr & 0xff;\n\n    if (offset >= 0x40 && offset < 0x80) {\n\n        int n = offset - 0x40;\n\n        s->icr[n] = val;\n\n        if (val == 0)\n\n            s->enabled &= ~(1ull << n);\n\n        else\n\n            s->enabled |= (1ull << n);\n\n        mcf_intc_update(s);\n\n        return;\n\n    }\n\n    switch (offset) {\n\n    case 0x00: case 0x04:\n\n        /* Ignore IPR writes.  */\n\n        return;\n\n    case 0x08:\n\n        s->imr = (s->imr & 0xffffffff) | ((uint64_t)val << 32);\n\n        break;\n\n    case 0x0c:\n\n        s->imr = (s->imr & 0xffffffff00000000ull) | (uint32_t)val;\n\n        break;\n\n    default:\n\n        hw_error(\"mcf_intc_write: Bad write offset %d\\n\", offset);\n\n        break;\n\n    }\n\n    mcf_intc_update(s);\n\n}\n", "idx": 13499, "_split": "valid", "_hash": "6f6913524cb038e0f25101602e2dcc18"}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static int cow_write(BlockDriverState *bs, int64_t sector_num,\n\n                     const uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVCowState *s = bs->opaque;\n\n    int ret;\n\n\n\n    ret = bdrv_pwrite(bs->file, s->cow_sectors_offset + sector_num * 512,\n\n                      buf, nb_sectors * 512);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return cow_update_bitmap(bs, sector_num, nb_sectors);\n\n}\n", "idx": 13515, "_split": "valid", "_hash": "b99a70979798e15b5b7163c7a251f22b"}
{"project": "qemu", "commit_id": "afff2b15e89ac81c113f2ebfd729aaa02b40edb6", "target": 1, "func": "QemuConsole *qemu_console_lookup_by_device(DeviceState *dev, uint32_t head)\n\n{\n\n    Error *local_err = NULL;\n\n    Object *obj;\n\n    uint32_t h;\n\n    int i;\n\n\n\n    for (i = 0; i < nb_consoles; i++) {\n\n        if (!consoles[i]) {\n\n            continue;\n\n        }\n\n        obj = object_property_get_link(OBJECT(consoles[i]),\n\n                                       \"device\", &local_err);\n\n        if (DEVICE(obj) != dev) {\n\n            continue;\n\n        }\n\n        h = object_property_get_int(OBJECT(consoles[i]),\n\n                                    \"head\", &local_err);\n\n        if (h != head) {\n\n            continue;\n\n        }\n\n        return consoles[i];\n\n    }\n\n    return NULL;\n\n}\n", "idx": 13529, "_split": "valid", "_hash": "d8904ca6350682ab50ee36f50c7e8562"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "int qemu_file_get_error(QEMUFile *f)\n\n{\n\n    return f->last_error;\n\n}\n", "idx": 13546, "_split": "valid", "_hash": "543b1f181a34c113947235fb8c0cdc37"}
{"project": "qemu", "commit_id": "de00982e9e14e2d6ba3d148f02c5a1e94deaa985", "target": 0, "func": "static void platform_fixed_ioport_init(PCIXenPlatformState* s)\n\n{\n\n    register_ioport_write(XEN_PLATFORM_IOPORT, 16, 4, platform_fixed_ioport_writel, s);\n\n    register_ioport_write(XEN_PLATFORM_IOPORT, 16, 2, platform_fixed_ioport_writew, s);\n\n    register_ioport_write(XEN_PLATFORM_IOPORT, 16, 1, platform_fixed_ioport_writeb, s);\n\n    register_ioport_read(XEN_PLATFORM_IOPORT, 16, 2, platform_fixed_ioport_readw, s);\n\n    register_ioport_read(XEN_PLATFORM_IOPORT, 16, 1, platform_fixed_ioport_readb, s);\n\n}\n", "idx": 13565, "_split": "valid", "_hash": "a5c515787e973c6a5c87977b08102ed6"}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fctidz(CPUPPCState *env, uint64_t arg)\n\n{\n\n    CPU_DoubleU farg;\n\n\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN conversion */\n\n        farg.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN |\n\n                                        POWERPC_EXCP_FP_VXCVI);\n\n    } else if (unlikely(float64_is_quiet_nan(farg.d) ||\n\n                        float64_is_infinity(farg.d))) {\n\n        /* qNan / infinity conversion */\n\n        farg.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXCVI);\n\n    } else {\n\n        farg.ll = float64_to_int64_round_to_zero(farg.d, &env->fp_status);\n\n    }\n\n    return farg.ll;\n\n}\n", "idx": 13569, "_split": "valid", "_hash": "c7a7dd0234a59f69100b89d25221d6d6"}
{"project": "qemu", "commit_id": "7ad4c7200111d20eb97eed4f46b6026e3f0b0eef", "target": 0, "func": "void g_free(void *ptr)\n\n{\n\n    __coverity_free__(ptr);\n\n    __coverity_mark_as_afm_freed__(ptr, AFM_free);\n\n}\n", "idx": 13592, "_split": "valid", "_hash": "7e24ba4b822e106c8af6145b7cad9acf"}
{"project": "qemu", "commit_id": "45a50b1668822c23afc2a89f724654e176518bc4", "target": 0, "func": "static int load_multiboot(void *fw_cfg,\n\n                          FILE *f,\n\n                          const char *kernel_filename,\n\n                          const char *initrd_filename,\n\n                          const char *kernel_cmdline,\n\n                          uint8_t *header)\n\n{\n\n    int i, t, is_multiboot = 0;\n\n    uint32_t flags = 0;\n\n    uint32_t mh_entry_addr;\n\n    uint32_t mh_load_addr;\n\n    uint32_t mb_kernel_size;\n\n    uint32_t mmap_addr = MULTIBOOT_STRUCT_ADDR;\n\n    uint32_t mb_bootinfo = MULTIBOOT_STRUCT_ADDR + 0x500;\n\n    uint32_t mb_cmdline = mb_bootinfo + 0x200;\n\n    uint32_t mb_mod_end;\n\n\n\n    /* Ok, let's see if it is a multiboot image.\n\n       The header is 12x32bit long, so the latest entry may be 8192 - 48. */\n\n    for (i = 0; i < (8192 - 48); i += 4) {\n\n        if (ldl_p(header+i) == 0x1BADB002) {\n\n            uint32_t checksum = ldl_p(header+i+8);\n\n            flags = ldl_p(header+i+4);\n\n            checksum += flags;\n\n            checksum += (uint32_t)0x1BADB002;\n\n            if (!checksum) {\n\n                is_multiboot = 1;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!is_multiboot)\n\n        return 0; /* no multiboot */\n\n\n\n#ifdef DEBUG_MULTIBOOT\n\n    fprintf(stderr, \"qemu: I believe we found a multiboot image!\\n\");\n\n#endif\n\n\n\n    if (flags & 0x00000004) { /* MULTIBOOT_HEADER_HAS_VBE */\n\n        fprintf(stderr, \"qemu: multiboot knows VBE. we don't.\\n\");\n\n    }\n\n    if (!(flags & 0x00010000)) { /* MULTIBOOT_HEADER_HAS_ADDR */\n\n        uint64_t elf_entry;\n\n        int kernel_size;\n\n        fclose(f);\n\n        kernel_size = load_elf(kernel_filename, 0, &elf_entry, NULL, NULL,\n\n                               0, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"Error while loading elf kernel\\n\");\n\n            exit(1);\n\n        }\n\n        mh_load_addr = mh_entry_addr = elf_entry;\n\n        mb_kernel_size = kernel_size;\n\n\n\n#ifdef DEBUG_MULTIBOOT\n\n        fprintf(stderr, \"qemu: loading multiboot-elf kernel (%#x bytes) with entry %#zx\\n\",\n\n                mb_kernel_size, (size_t)mh_entry_addr);\n\n#endif\n\n    } else {\n\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_ADDR. */\n\n        uint32_t mh_header_addr = ldl_p(header+i+12);\n\n        mh_load_addr = ldl_p(header+i+16);\n\n#ifdef DEBUG_MULTIBOOT\n\n        uint32_t mh_load_end_addr = ldl_p(header+i+20);\n\n        uint32_t mh_bss_end_addr = ldl_p(header+i+24);\n\n#endif\n\n        uint32_t mb_kernel_text_offset = i - (mh_header_addr - mh_load_addr);\n\n\n\n        mh_entry_addr = ldl_p(header+i+28);\n\n        mb_kernel_size = get_file_size(f) - mb_kernel_text_offset;\n\n\n\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_VBE.\n\n        uint32_t mh_mode_type = ldl_p(header+i+32);\n\n        uint32_t mh_width = ldl_p(header+i+36);\n\n        uint32_t mh_height = ldl_p(header+i+40);\n\n        uint32_t mh_depth = ldl_p(header+i+44); */\n\n\n\n#ifdef DEBUG_MULTIBOOT\n\n        fprintf(stderr, \"multiboot: mh_header_addr = %#x\\n\", mh_header_addr);\n\n        fprintf(stderr, \"multiboot: mh_load_addr = %#x\\n\", mh_load_addr);\n\n        fprintf(stderr, \"multiboot: mh_load_end_addr = %#x\\n\", mh_load_end_addr);\n\n        fprintf(stderr, \"multiboot: mh_bss_end_addr = %#x\\n\", mh_bss_end_addr);\n\n#endif\n\n\n\n        fseek(f, mb_kernel_text_offset, SEEK_SET);\n\n\n\n#ifdef DEBUG_MULTIBOOT\n\n        fprintf(stderr, \"qemu: loading multiboot kernel (%#x bytes) at %#x\\n\",\n\n                mb_kernel_size, mh_load_addr);\n\n#endif\n\n\n\n        if (!fread_targphys_ok(mh_load_addr, mb_kernel_size, f)) {\n\n            fprintf(stderr, \"qemu: read error on multiboot kernel '%s' (%#x)\\n\",\n\n                    kernel_filename, mb_kernel_size);\n\n            exit(1);\n\n        }\n\n        fclose(f);\n\n    }\n\n\n\n    /* blob size is only the kernel for now */\n\n    mb_mod_end = mh_load_addr + mb_kernel_size;\n\n\n\n    /* load modules */\n\n    stl_phys(mb_bootinfo + 20, 0x0); /* mods_count */\n\n    if (initrd_filename) {\n\n        uint32_t mb_mod_info = mb_bootinfo + 0x100;\n\n        uint32_t mb_mod_cmdline = mb_bootinfo + 0x300;\n\n        uint32_t mb_mod_start = mh_load_addr;\n\n        uint32_t mb_mod_length = mb_kernel_size;\n\n        char *next_initrd;\n\n        char *next_space;\n\n        int mb_mod_count = 0;\n\n\n\n        do {\n\n            next_initrd = strchr(initrd_filename, ',');\n\n            if (next_initrd)\n\n                *next_initrd = '\\0';\n\n            /* if a space comes after the module filename, treat everything\n\n               after that as parameters */\n\n            cpu_physical_memory_write(mb_mod_cmdline, (uint8_t*)initrd_filename,\n\n                                      strlen(initrd_filename) + 1);\n\n            stl_phys(mb_mod_info + 8, mb_mod_cmdline); /* string */\n\n            mb_mod_cmdline += strlen(initrd_filename) + 1;\n\n            if ((next_space = strchr(initrd_filename, ' ')))\n\n                *next_space = '\\0';\n\n#ifdef DEBUG_MULTIBOOT\n\n            printf(\"multiboot loading module: %s\\n\", initrd_filename);\n\n#endif\n\n            f = fopen(initrd_filename, \"rb\");\n\n            if (f) {\n\n                mb_mod_start = (mb_mod_start + mb_mod_length + (TARGET_PAGE_SIZE - 1))\n\n                             & (TARGET_PAGE_MASK);\n\n                mb_mod_length = get_file_size(f);\n\n                mb_mod_end = mb_mod_start + mb_mod_length;\n\n\n\n                if (!fread_targphys_ok(mb_mod_start, mb_mod_length, f)) {\n\n                    fprintf(stderr, \"qemu: read error on multiboot module '%s' (%#x)\\n\",\n\n                            initrd_filename, mb_mod_length);\n\n                    exit(1);\n\n                }\n\n\n\n                mb_mod_count++;\n\n                stl_phys(mb_mod_info + 0, mb_mod_start);\n\n                stl_phys(mb_mod_info + 4, mb_mod_start + mb_mod_length);\n\n#ifdef DEBUG_MULTIBOOT\n\n                printf(\"mod_start: %#x\\nmod_end:   %#x\\n\", mb_mod_start,\n\n                       mb_mod_start + mb_mod_length);\n\n#endif\n\n                stl_phys(mb_mod_info + 12, 0x0); /* reserved */\n\n            }\n\n            initrd_filename = next_initrd+1;\n\n            mb_mod_info += 16;\n\n        } while (next_initrd);\n\n        stl_phys(mb_bootinfo + 20, mb_mod_count); /* mods_count */\n\n        stl_phys(mb_bootinfo + 24, mb_bootinfo + 0x100); /* mods_addr */\n\n    }\n\n\n\n    /* Make sure we're getting kernel + modules back after reset */\n\n    option_rom_setup_reset(mh_load_addr, mb_mod_end - mh_load_addr);\n\n\n\n    /* Commandline support */\n\n    stl_phys(mb_bootinfo + 16, mb_cmdline);\n\n    t = strlen(kernel_filename);\n\n    cpu_physical_memory_write(mb_cmdline, (uint8_t*)kernel_filename, t);\n\n    mb_cmdline += t;\n\n    stb_phys(mb_cmdline++, ' ');\n\n    t = strlen(kernel_cmdline) + 1;\n\n    cpu_physical_memory_write(mb_cmdline, (uint8_t*)kernel_cmdline, t);\n\n\n\n    /* the kernel is where we want it to be now */\n\n\n\n#define MULTIBOOT_FLAGS_MEMORY (1 << 0)\n\n#define MULTIBOOT_FLAGS_BOOT_DEVICE (1 << 1)\n\n#define MULTIBOOT_FLAGS_CMDLINE (1 << 2)\n\n#define MULTIBOOT_FLAGS_MODULES (1 << 3)\n\n#define MULTIBOOT_FLAGS_MMAP (1 << 6)\n\n    stl_phys(mb_bootinfo, MULTIBOOT_FLAGS_MEMORY\n\n                        | MULTIBOOT_FLAGS_BOOT_DEVICE\n\n                        | MULTIBOOT_FLAGS_CMDLINE\n\n                        | MULTIBOOT_FLAGS_MODULES\n\n                        | MULTIBOOT_FLAGS_MMAP);\n\n    stl_phys(mb_bootinfo + 4, 640); /* mem_lower */\n\n    stl_phys(mb_bootinfo + 8, ram_size / 1024); /* mem_upper */\n\n    stl_phys(mb_bootinfo + 12, 0x8001ffff); /* XXX: use the -boot switch? */\n\n    stl_phys(mb_bootinfo + 48, mmap_addr); /* mmap_addr */\n\n\n\n#ifdef DEBUG_MULTIBOOT\n\n    fprintf(stderr, \"multiboot: mh_entry_addr = %#x\\n\", mh_entry_addr);\n\n#endif\n\n\n\n    /* Pass variables to option rom */\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, mh_entry_addr);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, mb_bootinfo);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, mmap_addr);\n\n\n\n    /* Make sure we're getting the config space back after reset */\n\n    option_rom_setup_reset(mb_bootinfo, 0x500);\n\n\n\n    option_rom[nb_option_roms] = \"multiboot.bin\";\n\n    nb_option_roms++;\n\n\n\n    return 1; /* yes, we are multiboot */\n\n}\n", "idx": 13595, "_split": "valid", "_hash": "5a0782b4689d702610da195a4072f30e"}
{"project": "qemu", "commit_id": "4790b03d308f6c7dea7dc6941ddab9867c9530b8", "target": 1, "func": "iscsi_aio_writev(BlockDriverState *bs, int64_t sector_num,\n\n                 QEMUIOVector *qiov, int nb_sectors,\n\n                 BlockDriverCompletionFunc *cb,\n\n                 void *opaque)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct iscsi_context *iscsi = iscsilun->iscsi;\n\n    IscsiAIOCB *acb;\n\n    size_t size;\n\n    uint32_t num_sectors;\n\n    uint64_t lba;\n\n    struct iscsi_data data;\n\n\n\n    acb = qemu_aio_get(&iscsi_aiocb_info, bs, cb, opaque);\n\n    trace_iscsi_aio_writev(iscsi, sector_num, nb_sectors, opaque, acb);\n\n\n\n    acb->iscsilun = iscsilun;\n\n    acb->qiov     = qiov;\n\n\n\n    acb->canceled   = 0;\n\n    acb->bh         = NULL;\n\n    acb->status     = -EINPROGRESS;\n\n\n\n    /* XXX we should pass the iovec to write16 to avoid the extra copy */\n\n    /* this will allow us to get rid of 'buf' completely */\n\n    size = nb_sectors * BDRV_SECTOR_SIZE;\n\n    data.size = MIN(size, acb->qiov->size);\n\n\n\n    /* if the iovec only contains one buffer we can pass it directly */\n\n    if (acb->qiov->niov == 1) {\n\n        acb->buf = NULL;\n\n        data.data = acb->qiov->iov[0].iov_base;\n\n    } else {\n\n        acb->buf = g_malloc(data.size);\n\n        qemu_iovec_to_buf(acb->qiov, 0, acb->buf, data.size);\n\n        data.data = acb->buf;\n\n    }\n\n\n\n    acb->task = malloc(sizeof(struct scsi_task));\n\n    if (acb->task == NULL) {\n\n        error_report(\"iSCSI: Failed to allocate task for scsi WRITE16 \"\n\n                     \"command. %s\", iscsi_get_error(iscsi));\n\n        qemu_aio_release(acb);\n\n        return NULL;\n\n    }\n\n    memset(acb->task, 0, sizeof(struct scsi_task));\n\n\n\n    acb->task->xfer_dir = SCSI_XFER_WRITE;\n\n    acb->task->cdb_size = 16;\n\n    acb->task->cdb[0] = 0x8a;\n\n    lba = sector_qemu2lun(sector_num, iscsilun);\n\n    *(uint32_t *)&acb->task->cdb[2]  = htonl(lba >> 32);\n\n    *(uint32_t *)&acb->task->cdb[6]  = htonl(lba & 0xffffffff);\n\n    num_sectors = size / iscsilun->block_size;\n\n    *(uint32_t *)&acb->task->cdb[10] = htonl(num_sectors);\n\n    acb->task->expxferlen = size;\n\n\n\n    if (iscsi_scsi_command_async(iscsi, iscsilun->lun, acb->task,\n\n                                 iscsi_aio_write16_cb,\n\n                                 &data,\n\n                                 acb) != 0) {\n\n        scsi_free_scsi_task(acb->task);\n\n        g_free(acb->buf);\n\n        qemu_aio_release(acb);\n\n        return NULL;\n\n    }\n\n\n\n    iscsi_set_events(iscsilun);\n\n\n\n    return &acb->common;\n\n}\n", "idx": 13605, "_split": "valid", "_hash": "3c203f572e410e8f2d943637f9b1770c"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_buffer(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint8_t *v = pv;\n\n    qemu_get_buffer(f, v, size);\n\n    return 0;\n\n}\n", "idx": 13660, "_split": "valid", "_hash": "535eb7b10b0b02c070c3376b026916dd"}
{"project": "qemu", "commit_id": "94d81ae896810beafa60c85b88e991daa986e1fc", "target": 1, "func": "static void quit_handler(int sig)\n{\n    /* if we're frozen, don't exit unless we're absolutely forced to,\n     * because it's basically impossible for graceful exit to complete\n     * unless all log/pid files are on unfreezable filesystems. there's\n     * also a very likely chance killing the agent before unfreezing\n     * the filesystems is a mistake (or will be viewed as one later).\n     */\n    if (ga_is_frozen(ga_state)) {\n        return;\n    g_debug(\"received signal num %d, quitting\", sig);\n    if (g_main_loop_is_running(ga_state->main_loop)) {\n        g_main_loop_quit(ga_state->main_loop);", "idx": 13713, "_split": "valid", "_hash": "bab439c7729d1cb23c2b1d22abcffb24"}
{"project": "qemu", "commit_id": "61a5872fd66be718ad022102bf813d7e4e9324c5", "target": 1, "func": "static int tcp_close(MigrationState *s)\n\n{\n\n    DPRINTF(\"tcp_close\\n\");\n\n    if (s->fd != -1) {\n\n        close(s->fd);\n\n        s->fd = -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 13714, "_split": "valid", "_hash": "7eb19ad5c132ea60f2dc4a6cdb64764a"}
{"project": "qemu", "commit_id": "81584fd50deb3c324cafc854a946dbb6b83c2fc6", "target": 1, "func": "int spapr_populate_pci_devices(sPAPRPHBState *phb,\n\n                               uint32_t xics_phandle,\n\n                               void *fdt)\n\n{\n\n    PCIBus *bus = phb->host_state.bus;\n\n    int bus_off, node_off = 0, devid, fn, i, n, devices;\n\n    DeviceState *qdev;\n\n    char nodename[256];\n\n    struct {\n\n        uint32_t hi;\n\n        uint64_t addr;\n\n        uint64_t size;\n\n    } __attribute__((packed)) reg[PCI_NUM_REGIONS + 1],\n\n          assigned_addresses[PCI_NUM_REGIONS];\n\n    uint32_t bus_range[] = { cpu_to_be32(0), cpu_to_be32(0xff) };\n\n    struct {\n\n        uint32_t hi;\n\n        uint64_t child;\n\n        uint64_t parent;\n\n        uint64_t size;\n\n    } __attribute__((packed)) ranges[] = {\n\n        {\n\n            cpu_to_be32(b_ss(1)), cpu_to_be64(0),\n\n            cpu_to_be64(phb->io_win_addr),\n\n            cpu_to_be64(memory_region_size(&phb->iospace)),\n\n        },\n\n        {\n\n            cpu_to_be32(b_ss(2)), cpu_to_be64(SPAPR_PCI_MEM_WIN_BUS_OFFSET),\n\n            cpu_to_be64(phb->mem_win_addr),\n\n            cpu_to_be64(memory_region_size(&phb->memwindow)),\n\n        },\n\n    };\n\n    uint64_t bus_reg[] = { cpu_to_be64(phb->buid), 0 };\n\n    uint32_t interrupt_map_mask[] = {\n\n        cpu_to_be32(b_ddddd(-1)|b_fff(-1)), 0x0, 0x0, 0x0};\n\n    uint32_t interrupt_map[bus->nirq][7];\n\n\n\n    /* Start populating the FDT */\n\n    sprintf(nodename, \"pci@%\" PRIx64, phb->buid);\n\n    bus_off = fdt_add_subnode(fdt, 0, nodename);\n\n    if (bus_off < 0) {\n\n        return bus_off;\n\n    }\n\n\n\n#define _FDT(exp) \\\n\n    do { \\\n\n        int ret = (exp);                                           \\\n\n        if (ret < 0) {                                             \\\n\n            return ret;                                            \\\n\n        }                                                          \\\n\n    } while (0)\n\n\n\n    /* Write PHB properties */\n\n    _FDT(fdt_setprop_string(fdt, bus_off, \"device_type\", \"pci\"));\n\n    _FDT(fdt_setprop_string(fdt, bus_off, \"compatible\", \"IBM,Logical_PHB\"));\n\n    _FDT(fdt_setprop_cell(fdt, bus_off, \"#address-cells\", 0x3));\n\n    _FDT(fdt_setprop_cell(fdt, bus_off, \"#size-cells\", 0x2));\n\n    _FDT(fdt_setprop_cell(fdt, bus_off, \"#interrupt-cells\", 0x1));\n\n    _FDT(fdt_setprop(fdt, bus_off, \"used-by-rtas\", NULL, 0));\n\n    _FDT(fdt_setprop(fdt, bus_off, \"bus-range\", &bus_range, sizeof(bus_range)));\n\n    _FDT(fdt_setprop(fdt, bus_off, \"ranges\", &ranges, sizeof(ranges)));\n\n    _FDT(fdt_setprop(fdt, bus_off, \"reg\", &bus_reg, sizeof(bus_reg)));\n\n    _FDT(fdt_setprop(fdt, bus_off, \"interrupt-map-mask\",\n\n                     &interrupt_map_mask, sizeof(interrupt_map_mask)));\n\n\n\n    /* Populate PCI devices and allocate IRQs */\n\n    devices = 0;\n\n    QTAILQ_FOREACH(qdev, &bus->qbus.children, sibling) {\n\n        PCIDevice *dev = DO_UPCAST(PCIDevice, qdev, qdev);\n\n        int irq_index = pci_spapr_map_irq(dev, 0);\n\n        uint32_t *irqmap = interrupt_map[devices];\n\n        uint8_t *config = dev->config;\n\n\n\n        devid = dev->devfn >> 3;\n\n        fn = dev->devfn & 7;\n\n\n\n        sprintf(nodename, \"pci@%u,%u\", devid, fn);\n\n\n\n        /* Allocate interrupt from the map */\n\n        if (devid > bus->nirq)  {\n\n            printf(\"Unexpected behaviour in spapr_populate_pci_devices,\"\n\n                    \"wrong devid %u\\n\", devid);\n\n            exit(-1);\n\n        }\n\n        irqmap[0] = cpu_to_be32(b_ddddd(devid)|b_fff(fn));\n\n        irqmap[1] = 0;\n\n        irqmap[2] = 0;\n\n        irqmap[3] = 0;\n\n        irqmap[4] = cpu_to_be32(xics_phandle);\n\n        irqmap[5] = cpu_to_be32(phb->lsi_table[irq_index].dt_irq);\n\n        irqmap[6] = cpu_to_be32(0x8);\n\n\n\n        /* Add node to FDT */\n\n        node_off = fdt_add_subnode(fdt, bus_off, nodename);\n\n        if (node_off < 0) {\n\n            return node_off;\n\n        }\n\n\n\n        _FDT(fdt_setprop_cell(fdt, node_off, \"vendor-id\",\n\n                              pci_get_word(&config[PCI_VENDOR_ID])));\n\n        _FDT(fdt_setprop_cell(fdt, node_off, \"device-id\",\n\n                              pci_get_word(&config[PCI_DEVICE_ID])));\n\n        _FDT(fdt_setprop_cell(fdt, node_off, \"revision-id\",\n\n                              pci_get_byte(&config[PCI_REVISION_ID])));\n\n        _FDT(fdt_setprop_cell(fdt, node_off, \"class-code\",\n\n                              pci_get_long(&config[PCI_CLASS_REVISION]) >> 8));\n\n        _FDT(fdt_setprop_cell(fdt, node_off, \"subsystem-id\",\n\n                              pci_get_word(&config[PCI_SUBSYSTEM_ID])));\n\n        _FDT(fdt_setprop_cell(fdt, node_off, \"subsystem-vendor-id\",\n\n                              pci_get_word(&config[PCI_SUBSYSTEM_VENDOR_ID])));\n\n\n\n        /* Config space region comes first */\n\n        reg[0].hi = cpu_to_be32(\n\n            b_n(0) |\n\n            b_p(0) |\n\n            b_t(0) |\n\n            b_ss(0/*config*/) |\n\n            b_bbbbbbbb(0) |\n\n            b_ddddd(devid) |\n\n            b_fff(fn));\n\n        reg[0].addr = 0;\n\n        reg[0].size = 0;\n\n\n\n        n = 0;\n\n        for (i = 0; i < PCI_NUM_REGIONS; ++i) {\n\n            if (0 == dev->io_regions[i].size) {\n\n                continue;\n\n            }\n\n\n\n            reg[n+1].hi = cpu_to_be32(\n\n                b_n(0) |\n\n                b_p(0) |\n\n                b_t(0) |\n\n                b_ss(regtype_to_ss(dev->io_regions[i].type)) |\n\n                b_bbbbbbbb(0) |\n\n                b_ddddd(devid) |\n\n                b_fff(fn) |\n\n                b_rrrrrrrr(bars[i]));\n\n            reg[n+1].addr = 0;\n\n            reg[n+1].size = cpu_to_be64(dev->io_regions[i].size);\n\n\n\n            assigned_addresses[n].hi = cpu_to_be32(\n\n                b_n(1) |\n\n                b_p(0) |\n\n                b_t(0) |\n\n                b_ss(regtype_to_ss(dev->io_regions[i].type)) |\n\n                b_bbbbbbbb(0) |\n\n                b_ddddd(devid) |\n\n                b_fff(fn) |\n\n                b_rrrrrrrr(bars[i]));\n\n\n\n            /*\n\n             * Writing zeroes to assigned_addresses causes the guest kernel to\n\n             * reassign BARs\n\n             */\n\n            assigned_addresses[n].addr = cpu_to_be64(dev->io_regions[i].addr);\n\n            assigned_addresses[n].size = reg[n+1].size;\n\n\n\n            ++n;\n\n        }\n\n        _FDT(fdt_setprop(fdt, node_off, \"reg\", reg, sizeof(reg[0])*(n+1)));\n\n        _FDT(fdt_setprop(fdt, node_off, \"assigned-addresses\",\n\n                         assigned_addresses,\n\n                         sizeof(assigned_addresses[0])*(n)));\n\n        _FDT(fdt_setprop_cell(fdt, node_off, \"interrupts\",\n\n                              pci_get_byte(&config[PCI_INTERRUPT_PIN])));\n\n\n\n        ++devices;\n\n    }\n\n\n\n    /* Write interrupt map */\n\n    _FDT(fdt_setprop(fdt, bus_off, \"interrupt-map\", &interrupt_map,\n\n                     devices * sizeof(interrupt_map[0])));\n\n\n\n    return 0;\n\n}\n", "idx": 13738, "_split": "valid", "_hash": "bdafd686cf37bc8c578246e9989d9d9d"}
{"project": "qemu", "commit_id": "bdf211f884113426e1f8226b69731593efa003ea", "target": 1, "func": "static abi_long do_ioctl_rt(const IOCTLEntry *ie, uint8_t *buf_temp,\n\n                                int fd, int cmd, abi_long arg)\n\n{\n\n    const argtype *arg_type = ie->arg_type;\n\n    const StructEntry *se;\n\n    const argtype *field_types;\n\n    const int *dst_offsets, *src_offsets;\n\n    int target_size;\n\n    void *argptr;\n\n    abi_ulong *target_rt_dev_ptr;\n\n    unsigned long *host_rt_dev_ptr;\n\n    abi_long ret;\n\n    int i;\n\n\n\n    assert(ie->access == IOC_W);\n\n    assert(*arg_type == TYPE_PTR);\n\n    arg_type++;\n\n    assert(*arg_type == TYPE_STRUCT);\n\n    target_size = thunk_type_size(arg_type, 0);\n\n    argptr = lock_user(VERIFY_READ, arg, target_size, 1);\n\n    if (!argptr) {\n\n        return -TARGET_EFAULT;\n\n    }\n\n    arg_type++;\n\n    assert(*arg_type == (int)STRUCT_rtentry);\n\n    se = struct_entries + *arg_type++;\n\n    assert(se->convert[0] == NULL);\n\n    /* convert struct here to be able to catch rt_dev string */\n\n    field_types = se->field_types;\n\n    dst_offsets = se->field_offsets[THUNK_HOST];\n\n    src_offsets = se->field_offsets[THUNK_TARGET];\n\n    for (i = 0; i < se->nb_fields; i++) {\n\n        if (dst_offsets[i] == offsetof(struct rtentry, rt_dev)) {\n\n            assert(*field_types == TYPE_PTRVOID);\n\n            target_rt_dev_ptr = (abi_ulong *)(argptr + src_offsets[i]);\n\n            host_rt_dev_ptr = (unsigned long *)(buf_temp + dst_offsets[i]);\n\n            if (*target_rt_dev_ptr != 0) {\n\n                *host_rt_dev_ptr = (unsigned long)lock_user_string(\n\n                                                  tswapal(*target_rt_dev_ptr));\n\n                if (!*host_rt_dev_ptr) {\n\n                    unlock_user(argptr, arg, 0);\n\n                    return -TARGET_EFAULT;\n\n                }\n\n            } else {\n\n                *host_rt_dev_ptr = 0;\n\n            }\n\n            field_types++;\n\n            continue;\n\n        }\n\n        field_types = thunk_convert(buf_temp + dst_offsets[i],\n\n                                    argptr + src_offsets[i],\n\n                                    field_types, THUNK_HOST);\n\n    }\n\n    unlock_user(argptr, arg, 0);\n\n    assert(host_rt_dev_ptr);\n\n\n\n    ret = get_errno(safe_ioctl(fd, ie->host_cmd, buf_temp));\n\n    if (*host_rt_dev_ptr != 0) {\n\n        unlock_user((void *)*host_rt_dev_ptr,\n\n                    *target_rt_dev_ptr, 0);\n\n    }\n\n    return ret;\n\n}\n", "idx": 13743, "_split": "valid", "_hash": "e5e8c1d806ba7bcc3df1aa558647565d"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void cpu_breakpoint_remove_by_ref(CPUState *env, CPUBreakpoint *breakpoint)\n\n{\n\n#if defined(TARGET_HAS_ICE)\n\n    TAILQ_REMOVE(&env->breakpoints, breakpoint, entry);\n\n\n\n    breakpoint_invalidate(env, breakpoint->pc);\n\n\n\n    qemu_free(breakpoint);\n\n#endif\n\n}\n", "idx": 13753, "_split": "valid", "_hash": "1405665da57df4b8ef625a0b65b1212c"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_conditional_store(DisasContext *ctx, TCGv EA,\n\n                                  int reg, int size)\n\n{\n\n    int l1;\n\n\n\n    tcg_gen_trunc_tl_i32(cpu_crf[0], cpu_so);\n\n    l1 = gen_new_label();\n\n    tcg_gen_brcond_tl(TCG_COND_NE, EA, cpu_reserve, l1);\n\n    tcg_gen_ori_i32(cpu_crf[0], cpu_crf[0], 1 << CRF_EQ);\n\n#if defined(TARGET_PPC64)\n\n    if (size == 8) {\n\n        gen_qemu_st64(ctx, cpu_gpr[reg], EA);\n\n    } else\n\n#endif\n\n    if (size == 4) {\n\n        gen_qemu_st32(ctx, cpu_gpr[reg], EA);\n\n    } else if (size == 2) {\n\n        gen_qemu_st16(ctx, cpu_gpr[reg], EA);\n\n#if defined(TARGET_PPC64)\n\n    } else if (size == 16) {\n\n        TCGv gpr1, gpr2 , EA8;\n\n        if (unlikely(ctx->le_mode)) {\n\n            gpr1 = cpu_gpr[reg+1];\n\n            gpr2 = cpu_gpr[reg];\n\n        } else {\n\n            gpr1 = cpu_gpr[reg];\n\n            gpr2 = cpu_gpr[reg+1];\n\n        }\n\n        gen_qemu_st64(ctx, gpr1, EA);\n\n        EA8 = tcg_temp_local_new();\n\n        gen_addr_add(ctx, EA8, EA, 8);\n\n        gen_qemu_st64(ctx, gpr2, EA8);\n\n        tcg_temp_free(EA8);\n\n#endif\n\n    } else {\n\n        gen_qemu_st8(ctx, cpu_gpr[reg], EA);\n\n    }\n\n    gen_set_label(l1);\n\n    tcg_gen_movi_tl(cpu_reserve, -1);\n\n}\n", "idx": 13758, "_split": "valid", "_hash": "3827c114123d36d75e444d58eaf26d4a"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t cirrus_linear_bitblt_read(void *opaque,\n\n                                          target_phys_addr_t addr,\n\n                                          unsigned size)\n\n{\n\n    CirrusVGAState *s = opaque;\n\n    uint32_t ret;\n\n\n\n    /* XXX handle bitblt */\n\n    (void)s;\n\n    ret = 0xff;\n\n    return ret;\n\n}\n", "idx": 13773, "_split": "valid", "_hash": "d9316f32cf80d603e41cd6c3ba45afd5"}
{"project": "qemu", "commit_id": "a03ef88f77af045a2eb9629b5ce774a3fb973c5e", "target": 0, "func": "bochs_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,\n\n                QEMUIOVector *qiov, int flags)\n\n{\n\n    BDRVBochsState *s = bs->opaque;\n\n    uint64_t sector_num = offset >> BDRV_SECTOR_BITS;\n\n    int nb_sectors = bytes >> BDRV_SECTOR_BITS;\n\n    uint64_t bytes_done = 0;\n\n    QEMUIOVector local_qiov;\n\n    int ret;\n\n\n\n    assert((offset & (BDRV_SECTOR_SIZE - 1)) == 0);\n\n    assert((bytes & (BDRV_SECTOR_SIZE - 1)) == 0);\n\n\n\n    qemu_iovec_init(&local_qiov, qiov->niov);\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (nb_sectors > 0) {\n\n        int64_t block_offset = seek_to_sector(bs, sector_num);\n\n        if (block_offset < 0) {\n\n            ret = block_offset;\n\n            goto fail;\n\n        }\n\n\n\n        qemu_iovec_reset(&local_qiov);\n\n        qemu_iovec_concat(&local_qiov, qiov, bytes_done, 512);\n\n\n\n        if (block_offset > 0) {\n\n            ret = bdrv_co_preadv(bs->file->bs, block_offset, 512,\n\n                                 &local_qiov, 0);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n        } else {\n\n            qemu_iovec_memset(&local_qiov, 0, 0, 512);\n\n        }\n\n        nb_sectors--;\n\n        sector_num++;\n\n        bytes_done += 512;\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    qemu_iovec_destroy(&local_qiov);\n\n\n\n    return ret;\n\n}\n", "idx": 13802, "_split": "valid", "_hash": "b1c6d8f4dd4a1b1a5ca84f90f210ec1d"}
{"project": "qemu", "commit_id": "64c2a8f6d3facc2f758907c3b95686fe9e999590", "target": 0, "func": "static void parse_numa_node(NumaNodeOptions *node, QemuOpts *opts, Error **errp)\n\n{\n\n    uint16_t nodenr;\n\n    uint16List *cpus = NULL;\n\n\n\n    if (node->has_nodeid) {\n\n        nodenr = node->nodeid;\n\n    } else {\n\n        nodenr = nb_numa_nodes;\n\n    }\n\n\n\n    if (nodenr >= MAX_NODES) {\n\n        error_setg(errp, \"Max number of NUMA nodes reached: %\"\n\n                   PRIu16 \"\", nodenr);\n\n        return;\n\n    }\n\n\n\n    if (numa_info[nodenr].present) {\n\n        error_setg(errp, \"Duplicate NUMA nodeid: %\" PRIu16, nodenr);\n\n        return;\n\n    }\n\n\n\n    for (cpus = node->cpus; cpus; cpus = cpus->next) {\n\n        if (cpus->value >= max_cpus) {\n\n            error_setg(errp,\n\n                       \"CPU index (%\" PRIu16 \")\"\n\n                       \" should be smaller than maxcpus (%d)\",\n\n                       cpus->value, max_cpus);\n\n            return;\n\n        }\n\n        bitmap_set(numa_info[nodenr].node_cpu, cpus->value, 1);\n\n    }\n\n\n\n    if (node->has_mem && node->has_memdev) {\n\n        error_setg(errp, \"qemu: cannot specify both mem= and memdev=\");\n\n        return;\n\n    }\n\n\n\n    if (have_memdevs == -1) {\n\n        have_memdevs = node->has_memdev;\n\n    }\n\n    if (node->has_memdev != have_memdevs) {\n\n        error_setg(errp, \"qemu: memdev option must be specified for either \"\n\n                   \"all or no nodes\");\n\n        return;\n\n    }\n\n\n\n    if (node->has_mem) {\n\n        uint64_t mem_size = node->mem;\n\n        const char *mem_str = qemu_opt_get(opts, \"mem\");\n\n        /* Fix up legacy suffix-less format */\n\n        if (g_ascii_isdigit(mem_str[strlen(mem_str) - 1])) {\n\n            mem_size <<= 20;\n\n        }\n\n        numa_info[nodenr].node_mem = mem_size;\n\n    }\n\n    if (node->has_memdev) {\n\n        Object *o;\n\n        o = object_resolve_path_type(node->memdev, TYPE_MEMORY_BACKEND, NULL);\n\n        if (!o) {\n\n            error_setg(errp, \"memdev=%s is ambiguous\", node->memdev);\n\n            return;\n\n        }\n\n\n\n        object_ref(o);\n\n        numa_info[nodenr].node_mem = object_property_get_int(o, \"size\", NULL);\n\n        numa_info[nodenr].node_memdev = MEMORY_BACKEND(o);\n\n    }\n\n    numa_info[nodenr].present = true;\n\n    max_numa_nodeid = MAX(max_numa_nodeid, nodenr + 1);\n\n}\n", "idx": 13812, "_split": "valid", "_hash": "99859904ca9cca4350eb17aed173bcdf"}
{"project": "qemu", "commit_id": "b6fcf32d9b851a83dedcb609091236b97cc4a985", "target": 0, "func": "static void nested_struct_cleanup(UserDefNested *udnp)\n\n{\n\n    qapi_free_UserDefNested(udnp);\n\n}\n", "idx": 13820, "_split": "valid", "_hash": "9d1196113edb25f477712745e193cf64"}
{"project": "qemu", "commit_id": "f94b3f64e6572c8cec73a538588f7cd754bcfa88", "target": 1, "func": "static void test_qga_fsfreeze_and_thaw(gconstpointer fix)\n\n{\n\n    const TestFixture *fixture = fix;\n\n    QDict *ret;\n\n    const gchar *status;\n\n\n\n    ret = qmp_fd(fixture->fd, \"{'execute': 'guest-fsfreeze-freeze'}\");\n\n    g_assert_nonnull(ret);\n\n    qmp_assert_no_error(ret);\n\n    QDECREF(ret);\n\n\n\n    ret = qmp_fd(fixture->fd, \"{'execute': 'guest-fsfreeze-status'}\");\n\n    g_assert_nonnull(ret);\n\n    qmp_assert_no_error(ret);\n\n    status = qdict_get_try_str(ret, \"return\");\n\n    g_assert_cmpstr(status, ==, \"frozen\");\n\n    QDECREF(ret);\n\n\n\n    ret = qmp_fd(fixture->fd, \"{'execute': 'guest-fsfreeze-thaw'}\");\n\n    g_assert_nonnull(ret);\n\n    qmp_assert_no_error(ret);\n\n    QDECREF(ret);\n\n}\n", "idx": 13886, "_split": "valid", "_hash": "f93b595e268e327355c547ca2479061b"}
{"project": "qemu", "commit_id": "6687b79d636cd60ed9adb1177d0d946b58fa7717", "target": 1, "func": "int net_init_slirp(QemuOpts *opts, const char *name, VLANState *vlan)\n\n{\n\n    struct slirp_config_str *config;\n\n    const char *vhost;\n\n    const char *vhostname;\n\n    const char *vdhcp_start;\n\n    const char *vnamesrv;\n\n    const char *tftp_export;\n\n    const char *bootfile;\n\n    const char *smb_export;\n\n    const char *vsmbsrv;\n\n    const char *restrict_opt;\n\n    char *vnet = NULL;\n\n    int restricted = 0;\n\n    int ret;\n\n\n\n    vhost       = qemu_opt_get(opts, \"host\");\n\n    vhostname   = qemu_opt_get(opts, \"hostname\");\n\n    vdhcp_start = qemu_opt_get(opts, \"dhcpstart\");\n\n    vnamesrv    = qemu_opt_get(opts, \"dns\");\n\n    tftp_export = qemu_opt_get(opts, \"tftp\");\n\n    bootfile    = qemu_opt_get(opts, \"bootfile\");\n\n    smb_export  = qemu_opt_get(opts, \"smb\");\n\n    vsmbsrv     = qemu_opt_get(opts, \"smbserver\");\n\n\n\n    restrict_opt = qemu_opt_get(opts, \"restrict\");\n\n    if (restrict_opt) {\n\n        if (!strcmp(restrict_opt, \"on\") ||\n\n            !strcmp(restrict_opt, \"yes\") || !strcmp(restrict_opt, \"y\")) {\n\n            restricted = 1;\n\n        } else if (strcmp(restrict_opt, \"off\") &&\n\n            strcmp(restrict_opt, \"no\") && strcmp(restrict_opt, \"n\")) {\n\n            error_report(\"invalid option: 'restrict=%s'\", restrict_opt);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"ip\")) {\n\n        const char *ip = qemu_opt_get(opts, \"ip\");\n\n        int l = strlen(ip) + strlen(\"/24\") + 1;\n\n\n\n        vnet = g_malloc(l);\n\n\n\n        /* emulate legacy ip= parameter */\n\n        pstrcpy(vnet, l, ip);\n\n        pstrcat(vnet, l, \"/24\");\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"net\")) {\n\n        if (vnet) {\n\n            g_free(vnet);\n\n        }\n\n        vnet = g_strdup(qemu_opt_get(opts, \"net\"));\n\n    }\n\n\n\n    qemu_opt_foreach(opts, net_init_slirp_configs, NULL, 0);\n\n\n\n    ret = net_slirp_init(vlan, \"user\", name, restricted, vnet, vhost,\n\n                         vhostname, tftp_export, bootfile, vdhcp_start,\n\n                         vnamesrv, smb_export, vsmbsrv);\n\n\n\n    while (slirp_configs) {\n\n        config = slirp_configs;\n\n        slirp_configs = config->next;\n\n        g_free(config);\n\n    }\n\n\n\n    g_free(vnet);\n\n\n\n    return ret;\n\n}\n", "idx": 13896, "_split": "valid", "_hash": "586b730b2e906c2c24e407e65642ee25"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int stdio_pclose(void *opaque)\n\n{\n\n    QEMUFileStdio *s = opaque;\n\n    int ret;\n\n    ret = pclose(s->stdio_file);\n\n    if (ret == -1) {\n\n        ret = -errno;\n\n    } else if (!WIFEXITED(ret) || WEXITSTATUS(ret) != 0) {\n\n        /* close succeeded, but non-zero exit code: */\n\n        ret = -EIO; /* fake errno value */\n\n    }\n\n    g_free(s);\n\n    return ret;\n\n}\n", "idx": 14027, "_split": "valid", "_hash": "288d47459187fe163f42b4a15153333d"}
{"project": "qemu", "commit_id": "bd16430777cc3d25930e479fdbe290d92cec0888", "target": 1, "func": "static void ahci_irq_lower(AHCIState *s, AHCIDevice *dev)\n\n{\n\n    AHCIPCIState *d = container_of(s, AHCIPCIState, ahci);\n\n\n\n    DPRINTF(0, \"lower irq\\n\");\n\n\n\n    if (!msi_enabled(PCI_DEVICE(d))) {\n\n        qemu_irq_lower(s->irq);\n\n    }\n\n}\n", "idx": 14034, "_split": "valid", "_hash": "84eb8289e9c5dd3ff14c3e0736ef6bb1"}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static void adb_mouse_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    MouseState *s = ADB_MOUSE(dev);\n\n    ADBMouseClass *amc = ADB_MOUSE_GET_CLASS(dev);\n\n\n\n    amc->parent_realize(dev, errp);\n\n\n\n    qemu_add_mouse_event_handler(adb_mouse_event, s, 0, \"QEMU ADB Mouse\");\n\n}\n", "idx": 14044, "_split": "valid", "_hash": "68812c028708d04af5c999c7501cadad"}
{"project": "qemu", "commit_id": "b2f56462d51a49c28d2a7b214b3ae8e8d3329f1f", "target": 0, "func": "static int coroutine_fn backup_do_cow(BlockDriverState *bs,\n\n                                      int64_t sector_num, int nb_sectors,\n\n                                      bool *error_is_read,\n\n                                      bool is_write_notifier)\n\n{\n\n    BackupBlockJob *job = (BackupBlockJob *)bs->job;\n\n    CowRequest cow_request;\n\n    struct iovec iov;\n\n    QEMUIOVector bounce_qiov;\n\n    void *bounce_buffer = NULL;\n\n    int ret = 0;\n\n    int64_t sectors_per_cluster = cluster_size_sectors(job);\n\n    int64_t start, end;\n\n    int n;\n\n\n\n    qemu_co_rwlock_rdlock(&job->flush_rwlock);\n\n\n\n    start = sector_num / sectors_per_cluster;\n\n    end = DIV_ROUND_UP(sector_num + nb_sectors, sectors_per_cluster);\n\n\n\n    trace_backup_do_cow_enter(job, start, sector_num, nb_sectors);\n\n\n\n    wait_for_overlapping_requests(job, start, end);\n\n    cow_request_begin(&cow_request, job, start, end);\n\n\n\n    for (; start < end; start++) {\n\n        if (hbitmap_get(job->bitmap, start)) {\n\n            trace_backup_do_cow_skip(job, start);\n\n            continue; /* already copied */\n\n        }\n\n\n\n        trace_backup_do_cow_process(job, start);\n\n\n\n        n = MIN(sectors_per_cluster,\n\n                job->common.len / BDRV_SECTOR_SIZE -\n\n                start * sectors_per_cluster);\n\n\n\n        if (!bounce_buffer) {\n\n            bounce_buffer = qemu_blockalign(bs, job->cluster_size);\n\n        }\n\n        iov.iov_base = bounce_buffer;\n\n        iov.iov_len = n * BDRV_SECTOR_SIZE;\n\n        qemu_iovec_init_external(&bounce_qiov, &iov, 1);\n\n\n\n        if (is_write_notifier) {\n\n            ret = bdrv_co_readv_no_serialising(bs,\n\n                                           start * sectors_per_cluster,\n\n                                           n, &bounce_qiov);\n\n        } else {\n\n            ret = bdrv_co_readv(bs, start * sectors_per_cluster, n,\n\n                                &bounce_qiov);\n\n        }\n\n        if (ret < 0) {\n\n            trace_backup_do_cow_read_fail(job, start, ret);\n\n            if (error_is_read) {\n\n                *error_is_read = true;\n\n            }\n\n            goto out;\n\n        }\n\n\n\n        if (buffer_is_zero(iov.iov_base, iov.iov_len)) {\n\n            ret = bdrv_co_write_zeroes(job->target,\n\n                                       start * sectors_per_cluster,\n\n                                       n, BDRV_REQ_MAY_UNMAP);\n\n        } else {\n\n            ret = bdrv_co_writev(job->target,\n\n                                 start * sectors_per_cluster, n,\n\n                                 &bounce_qiov);\n\n        }\n\n        if (ret < 0) {\n\n            trace_backup_do_cow_write_fail(job, start, ret);\n\n            if (error_is_read) {\n\n                *error_is_read = false;\n\n            }\n\n            goto out;\n\n        }\n\n\n\n        hbitmap_set(job->bitmap, start, 1);\n\n\n\n        /* Publish progress, guest I/O counts as progress too.  Note that the\n\n         * offset field is an opaque progress value, it is not a disk offset.\n\n         */\n\n        job->sectors_read += n;\n\n        job->common.offset += n * BDRV_SECTOR_SIZE;\n\n    }\n\n\n\nout:\n\n    if (bounce_buffer) {\n\n        qemu_vfree(bounce_buffer);\n\n    }\n\n\n\n    cow_request_end(&cow_request);\n\n\n\n    trace_backup_do_cow_return(job, sector_num, nb_sectors, ret);\n\n\n\n    qemu_co_rwlock_unlock(&job->flush_rwlock);\n\n\n\n    return ret;\n\n}\n", "idx": 14088, "_split": "valid", "_hash": "e86c88b71f84465cfbf19acd8a494298"}
{"project": "qemu", "commit_id": "c9f82d013be0d8d9c5d9f51bb76e337a0a5a5cac", "target": 1, "func": "static void gen_dcbz(DisasContext *ctx)\n\n{\n\n    TCGv tcgv_addr;\n\n    TCGv_i32 tcgv_is_dcbzl;\n\n    int is_dcbzl = ctx->opcode & 0x00200000 ? 1 : 0;\n\n\n\n    gen_set_access_type(ctx, ACCESS_CACHE);\n\n    tcgv_addr = tcg_temp_new();\n\n    tcgv_is_dcbzl = tcg_const_i32(is_dcbzl);\n\n\n\n    gen_addr_reg_index(ctx, tcgv_addr);\n\n    gen_helper_dcbz(cpu_env, tcgv_addr, tcgv_is_dcbzl);\n\n\n\n    tcg_temp_free(tcgv_addr);\n\n    tcg_temp_free_i32(tcgv_is_dcbzl);\n\n}\n", "idx": 14099, "_split": "valid", "_hash": "ee1d2676f30eda80da4537663a95b513"}
{"project": "qemu", "commit_id": "a83000f5e3fac30a7f213af1ba6a8f827622854d", "target": 0, "func": "static void spapr_vio_quiesce_one(VIOsPAPRDevice *dev)\n\n{\n\n    if (dev->tcet) {\n\n        spapr_tce_reset(dev->tcet);\n\n    }\n\n    free_crq(dev);\n\n}\n", "idx": 14118, "_split": "valid", "_hash": "d92e1223e20a0db3253cae4f63a001d4"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "PXA2xxMMCIState *pxa2xx_mmci_init(MemoryRegion *sysmem,\n\n                hwaddr base,\n\n                BlockDriverState *bd, qemu_irq irq,\n\n                qemu_irq rx_dma, qemu_irq tx_dma)\n\n{\n\n    PXA2xxMMCIState *s;\n\n\n\n    s = (PXA2xxMMCIState *) g_malloc0(sizeof(PXA2xxMMCIState));\n\n    s->irq = irq;\n\n    s->rx_dma = rx_dma;\n\n    s->tx_dma = tx_dma;\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &pxa2xx_mmci_ops, s,\n\n                          \"pxa2xx-mmci\", 0x00100000);\n\n    memory_region_add_subregion(sysmem, base, &s->iomem);\n\n\n\n    /* Instantiate the actual storage */\n\n    s->card = sd_init(bd, false);\n\n    if (s->card == NULL) {\n\n        exit(1);\n\n    }\n\n\n\n    register_savevm(NULL, \"pxa2xx_mmci\", 0, 0,\n\n                    pxa2xx_mmci_save, pxa2xx_mmci_load, s);\n\n\n\n    return s;\n\n}\n", "idx": 14121, "_split": "valid", "_hash": "9773a180c46f40e1140c16cabf31f6d1"}
{"project": "qemu", "commit_id": "978f2205c791de0e02c8802a645bea657408abfd", "target": 0, "func": "int64_t timerlist_deadline_ns(QEMUTimerList *timer_list)\n\n{\n\n    int64_t delta;\n\n\n\n    if (!timer_list->clock->enabled || !timer_list->active_timers) {\n\n        return -1;\n\n    }\n\n\n\n    delta = timer_list->active_timers->expire_time -\n\n        qemu_clock_get_ns(timer_list->clock->type);\n\n\n\n    if (delta <= 0) {\n\n        return 0;\n\n    }\n\n\n\n    return delta;\n\n}\n", "idx": 14130, "_split": "valid", "_hash": "1f5ae028842f804ea4580de3957df057"}
{"project": "qemu", "commit_id": "17e2377abf16c3951d7d34521ceade4d7dc31d01", "target": 0, "func": "void *qemu_mallocz(size_t size)\n\n{\n\n    void *ptr;\n\n    ptr = qemu_malloc(size);\n\n    if (!ptr)\n\n        return NULL;\n\n    memset(ptr, 0, size);\n\n    return ptr;\n\n}\n", "idx": 14132, "_split": "valid", "_hash": "b8de100d542080d4651208af35112c0b"}
{"project": "qemu", "commit_id": "0b466065eba289c437e3edc2e97144fc5cd6a889", "target": 0, "func": "sosendoob(struct socket *so)\n\n{\n\n\tstruct sbuf *sb = &so->so_rcv;\n\n\tchar buff[2048]; /* XXX Shouldn't be sending more oob data than this */\n\n\n\n\tint n, len;\n\n\n\n\tDEBUG_CALL(\"sosendoob\");\n\n\tDEBUG_ARG(\"so = %p\", so);\n\n\tDEBUG_ARG(\"sb->sb_cc = %d\", sb->sb_cc);\n\n\n\n\tif (so->so_urgc > 2048)\n\n\t   so->so_urgc = 2048; /* XXXX */\n\n\n\n\tif (sb->sb_rptr < sb->sb_wptr) {\n\n\t\t/* We can send it directly */\n\n\t\tn = slirp_send(so, sb->sb_rptr, so->so_urgc, (MSG_OOB)); /* |MSG_DONTWAIT)); */\n\n\t\tso->so_urgc -= n;\n\n\n\n\t\tDEBUG_MISC((dfd, \" --- sent %d bytes urgent data, %d urgent bytes left\\n\", n, so->so_urgc));\n\n\t} else {\n\n\t\t/*\n\n\t\t * Since there's no sendv or sendtov like writev,\n\n\t\t * we must copy all data to a linear buffer then\n\n\t\t * send it all\n\n\t\t */\n\n\t\tlen = (sb->sb_data + sb->sb_datalen) - sb->sb_rptr;\n\n\t\tif (len > so->so_urgc) len = so->so_urgc;\n\n\t\tmemcpy(buff, sb->sb_rptr, len);\n\n\t\tso->so_urgc -= len;\n\n\t\tif (so->so_urgc) {\n\n\t\t\tn = sb->sb_wptr - sb->sb_data;\n\n\t\t\tif (n > so->so_urgc) n = so->so_urgc;\n\n\t\t\tmemcpy((buff + len), sb->sb_data, n);\n\n\t\t\tso->so_urgc -= n;\n\n\t\t\tlen += n;\n\n\t\t}\n\n\t\tn = slirp_send(so, buff, len, (MSG_OOB)); /* |MSG_DONTWAIT)); */\n\n#ifdef DEBUG\n\n\t\tif (n != len)\n\n\t\t   DEBUG_ERROR((dfd, \"Didn't send all data urgently XXXXX\\n\"));\n\n#endif\n\n\t\tDEBUG_MISC((dfd, \" ---2 sent %d bytes urgent data, %d urgent bytes left\\n\", n, so->so_urgc));\n\n\t}\n\n\n\n\tsb->sb_cc -= n;\n\n\tsb->sb_rptr += n;\n\n\tif (sb->sb_rptr >= (sb->sb_data + sb->sb_datalen))\n\n\t\tsb->sb_rptr -= sb->sb_datalen;\n\n\n\n\treturn n;\n\n}\n", "idx": 14133, "_split": "valid", "_hash": "3a877490476802516a9e7d5326fd4a12"}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_tlbiel(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_helper_tlbie(cpu_env, cpu_gpr[rB(ctx->opcode)]);\n\n#endif\n\n}\n", "idx": 14147, "_split": "valid", "_hash": "032d4f77a48a5505812e251c7ce63098"}
{"project": "qemu", "commit_id": "f9aef99b3e6df88036436b0d3dc3d504b9346c8c", "target": 1, "func": "static void local_mapped_file_attr(FsContext *ctx, const char *path,\n\n                                   struct stat *stbuf)\n\n{\n\n    FILE *fp;\n\n    char buf[ATTR_MAX];\n\n    char *attr_path;\n\n\n\n    attr_path = local_mapped_attr_path(ctx, path);\n\n    fp = local_fopen(attr_path, \"r\");\n\n    g_free(attr_path);\n\n    if (!fp) {\n\n        return;\n\n    }\n\n    memset(buf, 0, ATTR_MAX);\n\n    while (fgets(buf, ATTR_MAX, fp)) {\n\n        if (!strncmp(buf, \"virtfs.uid\", 10)) {\n\n            stbuf->st_uid = atoi(buf+11);\n\n        } else if (!strncmp(buf, \"virtfs.gid\", 10)) {\n\n            stbuf->st_gid = atoi(buf+11);\n\n        } else if (!strncmp(buf, \"virtfs.mode\", 11)) {\n\n            stbuf->st_mode = atoi(buf+12);\n\n        } else if (!strncmp(buf, \"virtfs.rdev\", 11)) {\n\n            stbuf->st_rdev = atoi(buf+12);\n\n        }\n\n        memset(buf, 0, ATTR_MAX);\n\n    }\n\n    fclose(fp);\n\n}\n", "idx": 14176, "_split": "valid", "_hash": "0d647d28822f511f73792b2a5b675ae3"}
{"project": "qemu", "commit_id": "6fc76aa9adc1c8896a97059f12a1e5e6c1820c64", "target": 0, "func": "static int ppc_hash32_get_bat(CPUPPCState *env, struct mmu_ctx_hash32 *ctx,\n\n                              target_ulong virtual, int rwx)\n\n{\n\n    target_ulong *BATlt, *BATut;\n\n    target_ulong BEPIl, BEPIu, bl;\n\n    int i, valid, prot;\n\n    int ret = -1;\n\n\n\n    LOG_BATS(\"%s: %cBAT v \" TARGET_FMT_lx \"\\n\", __func__,\n\n             rwx == 2 ? 'I' : 'D', virtual);\n\n    if (rwx == 2) {\n\n        BATlt = env->IBAT[1];\n\n        BATut = env->IBAT[0];\n\n    } else {\n\n        BATlt = env->DBAT[1];\n\n        BATut = env->DBAT[0];\n\n    }\n\n    for (i = 0; i < env->nb_BATs; i++) {\n\n        target_ulong batu = BATut[i];\n\n        target_ulong batl = BATlt[i];\n\n\n\n        BEPIu = batu & BATU32_BEPIU;\n\n        BEPIl = batu & BATU32_BEPIL;\n\n        if (unlikely(env->mmu_model == POWERPC_MMU_601)) {\n\n            hash32_bat_601_size(env, &bl, &valid, batu, batl);\n\n            prot = hash32_bat_601_prot(env, batu, batl);\n\n        } else {\n\n            hash32_bat_size(env, &bl, &valid, batu, batl);\n\n            prot = hash32_bat_prot(env, batu, batl);\n\n        }\n\n        LOG_BATS(\"%s: %cBAT%d v \" TARGET_FMT_lx \" BATu \" TARGET_FMT_lx\n\n                 \" BATl \" TARGET_FMT_lx \"\\n\", __func__,\n\n                 type == ACCESS_CODE ? 'I' : 'D', i, virtual, batu, batl);\n\n        if ((virtual & BATU32_BEPIU) == BEPIu &&\n\n            ((virtual & BATU32_BEPIL) & ~bl) == BEPIl) {\n\n            /* BAT matches */\n\n            if (valid != 0) {\n\n                /* Get physical address */\n\n                ctx->raddr = (batl & BATL32_BRPNU) |\n\n                    ((virtual & BATU32_BEPIL & bl) | (batl & BATL32_BRPNL)) |\n\n                    (virtual & 0x0001F000);\n\n                /* Compute access rights */\n\n                ctx->prot = prot;\n\n                ret = ppc_hash32_check_prot(ctx->prot, rwx);\n\n                if (ret == 0) {\n\n                    LOG_BATS(\"BAT %d match: r \" TARGET_FMT_plx \" prot=%c%c\\n\",\n\n                             i, ctx->raddr, ctx->prot & PAGE_READ ? 'R' : '-',\n\n                             ctx->prot & PAGE_WRITE ? 'W' : '-');\n\n                }\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    if (ret < 0) {\n\n#if defined(DEBUG_BATS)\n\n        if (qemu_log_enabled()) {\n\n            LOG_BATS(\"no BAT match for \" TARGET_FMT_lx \":\\n\", virtual);\n\n            for (i = 0; i < 4; i++) {\n\n                BATu = &BATut[i];\n\n                BATl = &BATlt[i];\n\n                BEPIu = *BATu & BATU32_BEPIU;\n\n                BEPIl = *BATu & BATU32_BEPIL;\n\n                bl = (*BATu & 0x00001FFC) << 15;\n\n                LOG_BATS(\"%s: %cBAT%d v \" TARGET_FMT_lx \" BATu \" TARGET_FMT_lx\n\n                         \" BATl \" TARGET_FMT_lx \"\\n\\t\" TARGET_FMT_lx \" \"\n\n                         TARGET_FMT_lx \" \" TARGET_FMT_lx \"\\n\",\n\n                         __func__, type == ACCESS_CODE ? 'I' : 'D', i, virtual,\n\n                         *BATu, *BATl, BEPIu, BEPIl, bl);\n\n            }\n\n        }\n\n#endif\n\n    }\n\n    /* No hit */\n\n    return ret;\n\n}\n", "idx": 14214, "_split": "valid", "_hash": "e3a03ca59cc0e888c74f2d4de41478d5"}
{"project": "qemu", "commit_id": "30ca440eec9fe1d7eec5a48addac656438778278", "target": 0, "func": "static QOSState *qvirtio_scsi_start(const char *extra_opts)\n\n{\n\n    const char *cmd = \"-drive id=drv0,if=none,file=/dev/null,format=raw \"\n\n                      \"-device virtio-scsi-pci,id=vs0 \"\n\n                      \"-device scsi-hd,bus=vs0.0,drive=drv0 %s\";\n\n\n\n    return qtest_pc_boot(cmd, extra_opts ? : \"\");\n\n}\n", "idx": 14231, "_split": "valid", "_hash": "95ca0cc6641b2d7f20a10e832574f521"}
{"project": "qemu", "commit_id": "45a50b1668822c23afc2a89f724654e176518bc4", "target": 0, "func": "int fread_targphys_ok(target_phys_addr_t dst_addr, size_t nbytes, FILE *f)\n\n{\n\n    return fread_targphys(dst_addr, nbytes, f) == nbytes;\n\n}\n", "idx": 14236, "_split": "valid", "_hash": "7599604a2e8726302cba5a9bdd892180"}
{"project": "qemu", "commit_id": "71200fb9664c2967a1cdd22b68b0da3a8b2b3eb7", "target": 1, "func": "static CharDriverState *qemu_chr_open_stdio(const char *id,\n\n                                            ChardevBackend *backend,\n\n                                            ChardevReturn *ret,\n\n                                            Error **errp)\n\n{\n\n    ChardevStdio *opts = backend->u.stdio.data;\n\n    CharDriverState *chr;\n\n    struct sigaction act;\n\n    ChardevCommon *common = qapi_ChardevStdio_base(opts);\n\n\n\n    if (is_daemonized()) {\n\n        error_setg(errp, \"cannot use stdio with -daemonize\");\n\n\n\n\n\n    if (stdio_in_use) {\n\n        error_setg(errp, \"cannot use stdio by multiple character devices\");\n\n\n\n\n\n    stdio_in_use = true;\n\n    old_fd0_flags = fcntl(0, F_GETFL);\n\n    tcgetattr(0, &oldtty);\n\n    qemu_set_nonblock(0);\n\n    atexit(term_exit);\n\n\n\n    memset(&act, 0, sizeof(act));\n\n    act.sa_handler = term_stdio_handler;\n\n    sigaction(SIGCONT, &act, NULL);\n\n\n\n    chr = qemu_chr_open_fd(0, 1, common, errp);\n\n\n\n\n    chr->chr_close = qemu_chr_close_stdio;\n\n    chr->chr_set_echo = qemu_chr_set_echo_stdio;\n\n    if (opts->has_signal) {\n\n        stdio_allow_signal = opts->signal;\n\n\n    qemu_chr_fe_set_echo(chr, false);\n\n\n\n    return chr;\n", "idx": 14244, "_split": "valid", "_hash": "60e0a01a1b5412fdf2d0e56570cf1cf2"}
{"project": "qemu", "commit_id": "cf7c0ff521b0710079aa28f21937fb7dbb3f5224", "target": 0, "func": "static GSList *nvdimm_get_plugged_device_list(void)\n\n{\n\n    GSList *list = NULL;\n\n\n\n    object_child_foreach(qdev_get_machine(), nvdimm_plugged_device_list,\n\n                         &list);\n\n    return list;\n\n}\n", "idx": 14267, "_split": "valid", "_hash": "0c61cf369951537ff78b2842f0c4932c"}
{"project": "qemu", "commit_id": "38d8dfa193e9a45f0f08b06aab2ba2a94f40a041", "target": 0, "func": "void ide_dma_cancel(BMDMAState *bm)\n\n{\n\n    if (bm->status & BM_STATUS_DMAING) {\n\n        bm->status &= ~BM_STATUS_DMAING;\n\n        /* cancel DMA request */\n\n        bm->unit = -1;\n\n        bm->dma_cb = NULL;\n\n        if (bm->aiocb) {\n\n#ifdef DEBUG_AIO\n\n            printf(\"aio_cancel\\n\");\n\n#endif\n\n            bdrv_aio_cancel(bm->aiocb);\n\n            bm->aiocb = NULL;\n\n        }\n\n    }\n\n}\n", "idx": 14271, "_split": "valid", "_hash": "7477003c5bf6b1ad93ff1faf6655a197"}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fre(CPUPPCState *env, uint64_t arg)\n\n{\n\n    CPU_DoubleU farg;\n\n\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN reciprocal */\n\n        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n    }\n\n    farg.d = float64_div(float64_one, farg.d, &env->fp_status);\n\n    return farg.d;\n\n}\n", "idx": 14272, "_split": "valid", "_hash": "58855e5cae8823f36cfff48d74e03237"}
{"project": "qemu", "commit_id": "398489018183d613306ab022653552247d93919f", "target": 1, "func": "PCIBus *i440fx_init(PCII440FXState **pi440fx_state,\n\n                    int *piix3_devfn,\n\n                    ISABus **isa_bus, qemu_irq *pic,\n\n                    MemoryRegion *address_space_mem,\n\n                    MemoryRegion *address_space_io,\n\n                    ram_addr_t ram_size,\n\n                    hwaddr pci_hole_start,\n\n                    hwaddr pci_hole_size,\n\n                    hwaddr pci_hole64_start,\n\n                    hwaddr pci_hole64_size,\n\n                    MemoryRegion *pci_address_space,\n\n                    MemoryRegion *ram_memory)\n\n{\n\n    DeviceState *dev;\n\n    PCIBus *b;\n\n    PCIDevice *d;\n\n    PCIHostState *s;\n\n    PIIX3State *piix3;\n\n    PCII440FXState *f;\n\n    unsigned i;\n\n\n\n    dev = qdev_create(NULL, TYPE_I440FX_PCI_HOST_BRIDGE);\n\n    s = PCI_HOST_BRIDGE(dev);\n\n    b = pci_bus_new(dev, NULL, pci_address_space,\n\n                    address_space_io, 0, TYPE_PCI_BUS);\n\n    s->bus = b;\n\n    object_property_add_child(qdev_get_machine(), \"i440fx\", OBJECT(dev), NULL);\n\n    qdev_init_nofail(dev);\n\n\n\n    d = pci_create_simple(b, 0, TYPE_I440FX_PCI_DEVICE);\n\n    *pi440fx_state = I440FX_PCI_DEVICE(d);\n\n    f = *pi440fx_state;\n\n    f->system_memory = address_space_mem;\n\n    f->pci_address_space = pci_address_space;\n\n    f->ram_memory = ram_memory;\n\n    memory_region_init_alias(&f->pci_hole, OBJECT(d), \"pci-hole\", f->pci_address_space,\n\n                             pci_hole_start, pci_hole_size);\n\n    memory_region_add_subregion(f->system_memory, pci_hole_start, &f->pci_hole);\n\n    memory_region_init_alias(&f->pci_hole_64bit, OBJECT(d), \"pci-hole64\",\n\n                             f->pci_address_space,\n\n                             pci_hole64_start, pci_hole64_size);\n\n    if (pci_hole64_size) {\n\n        memory_region_add_subregion(f->system_memory, pci_hole64_start,\n\n                                    &f->pci_hole_64bit);\n\n    }\n\n    memory_region_init_alias(&f->smram_region, OBJECT(d), \"smram-region\",\n\n                             f->pci_address_space, 0xa0000, 0x20000);\n\n    memory_region_add_subregion_overlap(f->system_memory, 0xa0000,\n\n                                        &f->smram_region, 1);\n\n    memory_region_set_enabled(&f->smram_region, false);\n\n    init_pam(dev, f->ram_memory, f->system_memory, f->pci_address_space,\n\n             &f->pam_regions[0], PAM_BIOS_BASE, PAM_BIOS_SIZE);\n\n    for (i = 0; i < 12; ++i) {\n\n        init_pam(dev, f->ram_memory, f->system_memory, f->pci_address_space,\n\n                 &f->pam_regions[i+1], PAM_EXPAN_BASE + i * PAM_EXPAN_SIZE,\n\n                 PAM_EXPAN_SIZE);\n\n    }\n\n\n\n    /* Xen supports additional interrupt routes from the PCI devices to\n\n     * the IOAPIC: the four pins of each PCI device on the bus are also\n\n     * connected to the IOAPIC directly.\n\n     * These additional routes can be discovered through ACPI. */\n\n    if (xen_enabled()) {\n\n        piix3 = DO_UPCAST(PIIX3State, dev,\n\n                pci_create_simple_multifunction(b, -1, true, \"PIIX3-xen\"));\n\n        pci_bus_irqs(b, xen_piix3_set_irq, xen_pci_slot_get_pirq,\n\n                piix3, XEN_PIIX_NUM_PIRQS);\n\n    } else {\n\n        piix3 = DO_UPCAST(PIIX3State, dev,\n\n                pci_create_simple_multifunction(b, -1, true, \"PIIX3\"));\n\n        pci_bus_irqs(b, piix3_set_irq, pci_slot_get_pirq, piix3,\n\n                PIIX_NUM_PIRQS);\n\n        pci_bus_set_route_irq_fn(b, piix3_route_intx_pin_to_irq);\n\n    }\n\n    piix3->pic = pic;\n\n    *isa_bus = ISA_BUS(qdev_get_child_bus(DEVICE(piix3), \"isa.0\"));\n\n\n\n    *piix3_devfn = piix3->dev.devfn;\n\n\n\n    ram_size = ram_size / 8 / 1024 / 1024;\n\n    if (ram_size > 255) {\n\n        ram_size = 255;\n\n    }\n\n    d->config[0x57] = ram_size;\n\n\n\n    i440fx_update_memory_mappings(f);\n\n\n\n    return b;\n\n}\n", "idx": 14304, "_split": "valid", "_hash": "6052631f8862a9050b56c47a9c63799a"}
{"project": "qemu", "commit_id": "7bb6edb0e3dd78d74e0ac980cf6c0a07307f61bf", "target": 1, "func": "static int virtio_rng_device_exit(DeviceState *qdev)\n\n{\n\n    VirtIORNG *vrng = VIRTIO_RNG(qdev);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);\n\n\n\n    timer_del(vrng->rate_limit_timer);\n\n    timer_free(vrng->rate_limit_timer);\n\n    unregister_savevm(qdev, \"virtio-rng\", vrng);\n\n    virtio_cleanup(vdev);\n\n    return 0;\n\n}\n", "idx": 14312, "_split": "valid", "_hash": "9ca2cbdcf9db3102d7a0f5f2a0d51317"}
{"project": "qemu", "commit_id": "bc5008a832f95aae86efce844382e64d54da2146", "target": 1, "func": "static struct pathelem *add_entry(struct pathelem *root, const char *name,\n\n                                  unsigned type)\n\n{\n\n    struct pathelem **e;\n\n\n\n    root->num_entries++;\n\n\n\n    root = realloc(root, sizeof(*root)\n\n                   + sizeof(root->entries[0])*root->num_entries);\n\n    e = &root->entries[root->num_entries-1];\n\n\n\n    *e = new_entry(root->pathname, root, name);\n\n    if (is_dir_maybe(type)) {\n\n        *e = add_dir_maybe(*e);\n\n    }\n\n\n\n    return root;\n\n}\n", "idx": 14354, "_split": "valid", "_hash": "c039be18893271294d008154c7cf3871"}
{"project": "qemu", "commit_id": "baa61b9870dd7e0bb07e0ae61c6ec805db13f699", "target": 1, "func": "static void virtio_balloon_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n\n    dc->exit = virtio_balloon_device_exit;\n\n    dc->props = virtio_balloon_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    vdc->init = virtio_balloon_device_init;\n\n    vdc->get_config = virtio_balloon_get_config;\n\n    vdc->set_config = virtio_balloon_set_config;\n\n    vdc->get_features = virtio_balloon_get_features;\n\n}\n", "idx": 14360, "_split": "valid", "_hash": "1ebc1bc24338f6ecefb3f87058b1a462"}
{"project": "qemu", "commit_id": "1d5b8d770d1215b41ae32c881984b1d048b2f932", "target": 1, "func": "static KeyValue *copy_key_value(KeyValue *src)\n\n{\n\n    KeyValue *dst = g_new(KeyValue, 1);\n\n    memcpy(dst, src, sizeof(*src));\n\n\n\n\n\n\n    return dst;\n", "idx": 14367, "_split": "valid", "_hash": "06c4676604592a87ea3b3a7d3270d4cf"}
{"project": "qemu", "commit_id": "85d604af5f96c32734af9974ec6ddb625b6716a2", "target": 1, "func": "target_ulong helper_sub_suov(CPUTriCoreState *env, target_ulong r1,\n\n                             target_ulong r2)\n\n{\n\n    int64_t t1 = extract64(r1, 0, 32);\n\n    int64_t t2 = extract64(r2, 0, 32);\n\n    int64_t result = t1 - t2;\n\n    return suov32(env, result);\n\n}\n", "idx": 14373, "_split": "valid", "_hash": "6da7330533a137f7d9c675a7f843d789"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t icp_pit_read(void *opaque, target_phys_addr_t offset,\n\n                             unsigned size)\n\n{\n\n    icp_pit_state *s = (icp_pit_state *)opaque;\n\n    int n;\n\n\n\n    /* ??? Don't know the PrimeCell ID for this device.  */\n\n    n = offset >> 8;\n\n    if (n > 2) {\n\n        hw_error(\"%s: Bad timer %d\\n\", __func__, n);\n\n    }\n\n\n\n    return arm_timer_read(s->timer[n], offset & 0xff);\n\n}\n", "idx": 14386, "_split": "valid", "_hash": "99d50ec07c686387efbb95a1bbeb1948"}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static void v9fs_synth_direntry(V9fsSynthNode *node,\n\n                                struct dirent *entry, off_t off)\n\n{\n\n    strcpy(entry->d_name, node->name);\n\n    entry->d_ino = node->attr->inode;\n\n    entry->d_off = off + 1;\n\n}\n", "idx": 14390, "_split": "valid", "_hash": "f315c648f57a65818e278f39a920e77c"}
{"project": "qemu", "commit_id": "2399d4e7cec22ecf1c51062d2ebfd45220dbaace", "target": 0, "func": "static void gen_nop_hint(DisasContext *s, int val)\n\n{\n\n    switch (val) {\n\n    case 1: /* yield */\n\n        if (!parallel_cpus) {\n\n            gen_set_pc_im(s, s->pc);\n\n            s->base.is_jmp = DISAS_YIELD;\n\n        }\n\n        break;\n\n    case 3: /* wfi */\n\n        gen_set_pc_im(s, s->pc);\n\n        s->base.is_jmp = DISAS_WFI;\n\n        break;\n\n    case 2: /* wfe */\n\n        if (!parallel_cpus) {\n\n            gen_set_pc_im(s, s->pc);\n\n            s->base.is_jmp = DISAS_WFE;\n\n        }\n\n        break;\n\n    case 4: /* sev */\n\n    case 5: /* sevl */\n\n        /* TODO: Implement SEV, SEVL and WFE.  May help SMP performance.  */\n\n    default: /* nop */\n\n        break;\n\n    }\n\n}\n", "idx": 14396, "_split": "valid", "_hash": "309f7e68172d22832daf9ef5f9a8a868"}
{"project": "qemu", "commit_id": "1d3323de5fe5656844ea57a16eb432f09a366140", "target": 0, "func": "static void vnc_dpy_setdata(DisplayState *ds)\n\n{\n\n    /* We don't have to do anything */\n\n}\n", "idx": 14402, "_split": "valid", "_hash": "7cf2cf6cb066d70d17d17b06763687e8"}
{"project": "qemu", "commit_id": "cf528b89580797050b8cf60fee6247f35531a675", "target": 0, "func": "struct vhost_net *vhost_net_init(NetClientState *backend, int devfd,\n\n                                 bool force)\n\n{\n\n    int r;\n\n    struct vhost_net *net = g_malloc(sizeof *net);\n\n    if (!backend) {\n\n        fprintf(stderr, \"vhost-net requires backend to be setup\\n\");\n\n        goto fail;\n\n    }\n\n    r = vhost_net_get_fd(backend);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n    net->nc = backend;\n\n    net->dev.backend_features = tap_has_vnet_hdr(backend) ? 0 :\n\n        (1 << VHOST_NET_F_VIRTIO_NET_HDR);\n\n    net->backend = r;\n\n\n\n    net->dev.nvqs = 2;\n\n    net->dev.vqs = net->vqs;\n\n\n\n    r = vhost_dev_init(&net->dev, devfd, \"/dev/vhost-net\", force);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n    if (!tap_has_vnet_hdr_len(backend,\n\n                              sizeof(struct virtio_net_hdr_mrg_rxbuf))) {\n\n        net->dev.features &= ~(1 << VIRTIO_NET_F_MRG_RXBUF);\n\n    }\n\n    if (~net->dev.features & net->dev.backend_features) {\n\n        fprintf(stderr, \"vhost lacks feature mask %\" PRIu64 \" for backend\\n\",\n\n                (uint64_t)(~net->dev.features & net->dev.backend_features));\n\n        vhost_dev_cleanup(&net->dev);\n\n        goto fail;\n\n    }\n\n\n\n    /* Set sane init value. Override when guest acks. */\n\n    vhost_net_ack_features(net, 0);\n\n    return net;\n\nfail:\n\n    g_free(net);\n\n    return NULL;\n\n}\n", "idx": 14410, "_split": "valid", "_hash": "ad075e00a9747dcff16adae77863fe8c"}
{"project": "qemu", "commit_id": "f965509c9ee8635c66dbf4342a9c67c222951bc3", "target": 0, "func": "static int qcow_create(const char *filename, int64_t total_size,\n\n                      const char *backing_file, int flags)\n\n{\n\n    int fd, header_size, backing_filename_len, l1_size, i, shift, l2_bits;\n\n    QCowHeader header;\n\n    uint64_t tmp, offset;\n\n    QCowCreateState s1, *s = &s1;\n\n\n\n    memset(s, 0, sizeof(*s));\n\n\n\n    fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0644);\n\n    if (fd < 0)\n\n        return -1;\n\n    memset(&header, 0, sizeof(header));\n\n    header.magic = cpu_to_be32(QCOW_MAGIC);\n\n    header.version = cpu_to_be32(QCOW_VERSION);\n\n    header.size = cpu_to_be64(total_size * 512);\n\n    header_size = sizeof(header);\n\n    backing_filename_len = 0;\n\n    if (backing_file) {\n\n        header.backing_file_offset = cpu_to_be64(header_size);\n\n        backing_filename_len = strlen(backing_file);\n\n        header.backing_file_size = cpu_to_be32(backing_filename_len);\n\n        header_size += backing_filename_len;\n\n    }\n\n    s->cluster_bits = 12;  /* 4 KB clusters */\n\n    s->cluster_size = 1 << s->cluster_bits;\n\n    header.cluster_bits = cpu_to_be32(s->cluster_bits);\n\n    header_size = (header_size + 7) & ~7;\n\n    if (flags & BLOCK_FLAG_ENCRYPT) {\n\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_AES);\n\n    } else {\n\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);\n\n    }\n\n    l2_bits = s->cluster_bits - 3;\n\n    shift = s->cluster_bits + l2_bits;\n\n    l1_size = (((total_size * 512) + (1LL << shift) - 1) >> shift);\n\n    offset = align_offset(header_size, s->cluster_size);\n\n    s->l1_table_offset = offset;\n\n    header.l1_table_offset = cpu_to_be64(s->l1_table_offset);\n\n    header.l1_size = cpu_to_be32(l1_size);\n\n    offset += align_offset(l1_size * sizeof(uint64_t), s->cluster_size);\n\n\n\n    s->refcount_table = qemu_mallocz(s->cluster_size);\n\n    s->refcount_block = qemu_mallocz(s->cluster_size);\n\n\n\n    s->refcount_table_offset = offset;\n\n    header.refcount_table_offset = cpu_to_be64(offset);\n\n    header.refcount_table_clusters = cpu_to_be32(1);\n\n    offset += s->cluster_size;\n\n\n\n    s->refcount_table[0] = cpu_to_be64(offset);\n\n    s->refcount_block_offset = offset;\n\n    offset += s->cluster_size;\n\n\n\n    /* update refcounts */\n\n    create_refcount_update(s, 0, header_size);\n\n    create_refcount_update(s, s->l1_table_offset, l1_size * sizeof(uint64_t));\n\n    create_refcount_update(s, s->refcount_table_offset, s->cluster_size);\n\n    create_refcount_update(s, s->refcount_block_offset, s->cluster_size);\n\n\n\n    /* write all the data */\n\n    write(fd, &header, sizeof(header));\n\n    if (backing_file) {\n\n        write(fd, backing_file, backing_filename_len);\n\n    }\n\n    lseek(fd, s->l1_table_offset, SEEK_SET);\n\n    tmp = 0;\n\n    for(i = 0;i < l1_size; i++) {\n\n        write(fd, &tmp, sizeof(tmp));\n\n    }\n\n    lseek(fd, s->refcount_table_offset, SEEK_SET);\n\n    write(fd, s->refcount_table, s->cluster_size);\n\n\n\n    lseek(fd, s->refcount_block_offset, SEEK_SET);\n\n    write(fd, s->refcount_block, s->cluster_size);\n\n\n\n    qemu_free(s->refcount_table);\n\n    qemu_free(s->refcount_block);\n\n    close(fd);\n\n    return 0;\n\n}\n", "idx": 14429, "_split": "valid", "_hash": "dcb1e6c1b6f36c147f1c16b9881d1925"}
{"project": "qemu", "commit_id": "a1f0cce2ac0243572ff72aa561da67fe3766a395", "target": 1, "func": "static void scsi_read_data(SCSIRequest *req)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    if (r->sector_count == (uint32_t)-1) {\n\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n\n        r->sector_count = 0;\n\n        scsi_req_data(&r->req, r->iov.iov_len);\n\n        return;\n\n    }\n\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n\n    if (r->sector_count == 0) {\n\n        scsi_command_complete(r, GOOD, NO_SENSE);\n\n        return;\n\n    }\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    n = r->sector_count;\n\n    if (n > SCSI_DMA_BUF_SIZE / 512)\n\n        n = SCSI_DMA_BUF_SIZE / 512;\n\n\n\n    r->iov.iov_len = n * 512;\n\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n\n                              scsi_read_complete, r);\n\n    if (r->req.aiocb == NULL) {\n\n        scsi_read_complete(r, -EIO);\n\n    }\n\n}\n", "idx": 14445, "_split": "valid", "_hash": "f05a020b5f9715ce01f494cbbf7c3af4"}
{"project": "qemu", "commit_id": "40365552c2fceacc9800ec9a87b9ead516a9a6ce", "target": 1, "func": "static void mirror_start_job(BlockDriverState *bs, BlockDriverState *target,\n                             const char *replaces,\n                             int64_t speed, uint32_t granularity,\n                             int64_t buf_size,\n                             BlockdevOnError on_source_error,\n                             BlockdevOnError on_target_error,\n                             bool unmap,\n                             BlockCompletionFunc *cb,\n                             void *opaque, Error **errp,\n                             const BlockJobDriver *driver,\n                             bool is_none_mode, BlockDriverState *base)\n{\n    MirrorBlockJob *s;\n    BlockDriverState *replaced_bs;\n    if (granularity == 0) {\n        granularity = bdrv_get_default_bitmap_granularity(target);\n    assert ((granularity & (granularity - 1)) == 0);\n    if ((on_source_error == BLOCKDEV_ON_ERROR_STOP ||\n         on_source_error == BLOCKDEV_ON_ERROR_ENOSPC) &&\n        (!bs->blk || !blk_iostatus_is_enabled(bs->blk))) {\n        error_setg(errp, QERR_INVALID_PARAMETER, \"on-source-error\");\n    if (buf_size < 0) {\n        error_setg(errp, \"Invalid parameter 'buf-size'\");\n    if (buf_size == 0) {\n        buf_size = DEFAULT_MIRROR_BUF_SIZE;\n    s = block_job_create(driver, bs, speed, cb, opaque, errp);\n    if (!s) {\n    s->replaces = g_strdup(replaces);\n    s->on_source_error = on_source_error;\n    s->on_target_error = on_target_error;\n    s->target = target;\n    s->is_none_mode = is_none_mode;\n    s->base = base;\n    s->granularity = granularity;\n    s->buf_size = ROUND_UP(buf_size, granularity);\n    s->unmap = unmap;\n    s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp);\n    if (!s->dirty_bitmap) {\n        g_free(s->replaces);\n        block_job_unref(&s->common);\n    bdrv_op_block_all(s->target, s->common.blocker);\n    bdrv_set_enable_write_cache(s->target, true);\n    if (s->target->blk) {\n        blk_set_on_error(s->target->blk, on_target_error, on_target_error);\n        blk_iostatus_enable(s->target->blk);\n    s->common.co = qemu_coroutine_create(mirror_run);\n    trace_mirror_start(bs, s, s->common.co, opaque);\n    qemu_coroutine_enter(s->common.co, s);", "idx": 14464, "_split": "valid", "_hash": "0aedbef0026e5fa080815a244fbd4cf1"}
{"project": "qemu", "commit_id": "1ecf47bf0a091700e45f1b7d1f5ad85abc0acd22", "target": 0, "func": "static void qemu_kvm_start_vcpu(CPUState *env)\n\n{\n\n    env->thread = g_malloc0(sizeof(QemuThread));\n\n    env->halt_cond = g_malloc0(sizeof(QemuCond));\n\n    qemu_cond_init(env->halt_cond);\n\n    qemu_thread_create(env->thread, qemu_kvm_cpu_thread_fn, env,\n\n                       QEMU_THREAD_DETACHED);\n\n    while (env->created == 0) {\n\n        qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);\n\n    }\n\n}\n", "idx": 14472, "_split": "valid", "_hash": "3220b05b97793236e47349f47d441a4d"}
{"project": "qemu", "commit_id": "04bf2526ce87f21b32c9acba1c5518708c243ad0", "target": 0, "func": "static MemTxResult address_space_write_continue(AddressSpace *as, hwaddr addr,\n\n                                                MemTxAttrs attrs,\n\n                                                const uint8_t *buf,\n\n                                                int len, hwaddr addr1,\n\n                                                hwaddr l, MemoryRegion *mr)\n\n{\n\n    uint8_t *ptr;\n\n    uint64_t val;\n\n    MemTxResult result = MEMTX_OK;\n\n    bool release_lock = false;\n\n\n\n    for (;;) {\n\n        if (!memory_access_is_direct(mr, true)) {\n\n            release_lock |= prepare_mmio_access(mr);\n\n            l = memory_access_size(mr, l, addr1);\n\n            /* XXX: could force current_cpu to NULL to avoid\n\n               potential bugs */\n\n            switch (l) {\n\n            case 8:\n\n                /* 64 bit write access */\n\n                val = ldq_p(buf);\n\n                result |= memory_region_dispatch_write(mr, addr1, val, 8,\n\n                                                       attrs);\n\n                break;\n\n            case 4:\n\n                /* 32 bit write access */\n\n                val = (uint32_t)ldl_p(buf);\n\n                result |= memory_region_dispatch_write(mr, addr1, val, 4,\n\n                                                       attrs);\n\n                break;\n\n            case 2:\n\n                /* 16 bit write access */\n\n                val = lduw_p(buf);\n\n                result |= memory_region_dispatch_write(mr, addr1, val, 2,\n\n                                                       attrs);\n\n                break;\n\n            case 1:\n\n                /* 8 bit write access */\n\n                val = ldub_p(buf);\n\n                result |= memory_region_dispatch_write(mr, addr1, val, 1,\n\n                                                       attrs);\n\n                break;\n\n            default:\n\n                abort();\n\n            }\n\n        } else {\n\n            /* RAM case */\n\n            ptr = qemu_map_ram_ptr(mr->ram_block, addr1);\n\n            memcpy(ptr, buf, l);\n\n            invalidate_and_set_dirty(mr, addr1, l);\n\n        }\n\n\n\n        if (release_lock) {\n\n            qemu_mutex_unlock_iothread();\n\n            release_lock = false;\n\n        }\n\n\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n\n\n        if (!len) {\n\n            break;\n\n        }\n\n\n\n        l = len;\n\n        mr = address_space_translate(as, addr, &addr1, &l, true);\n\n    }\n\n\n\n    return result;\n\n}\n", "idx": 14496, "_split": "valid", "_hash": "085d1aa0fff1189bf0e60303a883aba0"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t timerblock_read(void *opaque, target_phys_addr_t addr,\n\n                                unsigned size)\n\n{\n\n    timerblock *tb = (timerblock *)opaque;\n\n    int64_t val;\n\n    switch (addr) {\n\n    case 0: /* Load */\n\n        return tb->load;\n\n    case 4: /* Counter.  */\n\n        if (((tb->control & 1) == 0) || (tb->count == 0)) {\n\n            return 0;\n\n        }\n\n        /* Slow and ugly, but hopefully won't happen too often.  */\n\n        val = tb->tick - qemu_get_clock_ns(vm_clock);\n\n        val /= timerblock_scale(tb);\n\n        if (val < 0) {\n\n            val = 0;\n\n        }\n\n        return val;\n\n    case 8: /* Control.  */\n\n        return tb->control;\n\n    case 12: /* Interrupt status.  */\n\n        return tb->status;\n\n    default:\n\n        return 0;\n\n    }\n\n}\n", "idx": 14532, "_split": "valid", "_hash": "e17384dabaf287220f8a1dab7a11f73a"}
{"project": "qemu", "commit_id": "ae08792301c182bdec48656dee3dce38b3391a1a", "target": 0, "func": "setup_return(CPUARMState *env, struct target_sigaction *ka,\n\n\t     abi_ulong *rc, abi_ulong frame_addr, int usig, abi_ulong rc_addr)\n\n{\n\n\tabi_ulong handler = ka->_sa_handler;\n\n\tabi_ulong retcode;\n\n\tint thumb = handler & 1;\n\n\tuint32_t cpsr = cpsr_read(env);\n\n\n\n\tcpsr &= ~CPSR_IT;\n\n\tif (thumb) {\n\n\t\tcpsr |= CPSR_T;\n\n\t} else {\n\n\t\tcpsr &= ~CPSR_T;\n\n\t}\n\n\n\n\tif (ka->sa_flags & TARGET_SA_RESTORER) {\n\n\t\tretcode = ka->sa_restorer;\n\n\t} else {\n\n\t\tunsigned int idx = thumb;\n\n\n\n\t\tif (ka->sa_flags & TARGET_SA_SIGINFO)\n\n\t\t\tidx += 2;\n\n\n\n        __put_user(retcodes[idx], rc);\n\n\n\n\t\tretcode = rc_addr + thumb;\n\n\t}\n\n\n\n\tenv->regs[0] = usig;\n\n\tenv->regs[13] = frame_addr;\n\n\tenv->regs[14] = retcode;\n\n\tenv->regs[15] = handler & (thumb ? ~1 : ~3);\n\n        cpsr_write(env, cpsr, 0xffffffff, CPSRWriteByInstr);\n\n}\n", "idx": 14543, "_split": "valid", "_hash": "212333f52a194f9ef0a6e0741ac07c77"}
{"project": "qemu", "commit_id": "e76d1798faa6d29f54c0930a034b67f3ecdb947d", "target": 0, "func": "static void tcg_exec_all(void)\n\n{\n\n    int r;\n\n\n\n    /* Account partial waits to QEMU_CLOCK_VIRTUAL.  */\n\n    qemu_clock_warp(QEMU_CLOCK_VIRTUAL);\n\n\n\n    if (next_cpu == NULL) {\n\n        next_cpu = first_cpu;\n\n    }\n\n    for (; next_cpu != NULL && !exit_request; next_cpu = CPU_NEXT(next_cpu)) {\n\n        CPUState *cpu = next_cpu;\n\n\n\n        qemu_clock_enable(QEMU_CLOCK_VIRTUAL,\n\n                          (cpu->singlestep_enabled & SSTEP_NOTIMER) == 0);\n\n\n\n        if (cpu_can_run(cpu)) {\n\n            r = tcg_cpu_exec(cpu);\n\n            if (r == EXCP_DEBUG) {\n\n                cpu_handle_guest_debug(cpu);\n\n                break;\n\n            }\n\n        } else if (cpu->stop || cpu->stopped) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Pairs with smp_wmb in qemu_cpu_kick.  */\n\n    atomic_mb_set(&exit_request, 0);\n\n}\n", "idx": 14556, "_split": "valid", "_hash": "592e67714ca25b10e54379dc375405c8"}
{"project": "qemu", "commit_id": "1048c88f03545fa42bdebb077871a743a614d2ab", "target": 0, "func": "static int get_keycode(const char *key)\n\n{\n\n    const KeyDef *p;\n\n    char *endp;\n\n    int ret;\n\n\n\n    for(p = key_defs; p->name != NULL; p++) {\n\n        if (!strcmp(key, p->name))\n\n            return p->keycode;\n\n    }\n\n    if (strstart(key, \"0x\", NULL)) {\n\n        ret = strtoul(key, &endp, 0);\n\n        if (*endp == '\\0' && ret >= 0x01 && ret <= 0xff)\n\n            return ret;\n\n    }\n\n    return -1;\n\n}\n", "idx": 14563, "_split": "valid", "_hash": "7c1f37ecbfe52b2ef4f5bce198d8022c"}
{"project": "qemu", "commit_id": "8ef2b256b94696a3a4bd8aa69a2b0fd7bc246f07", "target": 0, "func": "static void tricore_testboard_init(MachineState *machine, int board_id)\n\n{\n\n    TriCoreCPU *cpu;\n\n    CPUTriCoreState *env;\n\n\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ext_cram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ext_dram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *int_cram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *int_dram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *pcp_data = g_new(MemoryRegion, 1);\n\n    MemoryRegion *pcp_text = g_new(MemoryRegion, 1);\n\n\n\n    if (!machine->cpu_model) {\n\n        machine->cpu_model = \"tc1796\";\n\n    }\n\n    cpu = cpu_tricore_init(machine->cpu_model);\n\n    env = &cpu->env;\n\n    if (!cpu) {\n\n        error_report(\"Unable to find CPU definition\");\n\n        exit(1);\n\n    }\n\n    memory_region_init_ram(ext_cram, NULL, \"powerlink_ext_c.ram\", 2*1024*1024, &error_abort);\n\n    vmstate_register_ram_global(ext_cram);\n\n    memory_region_init_ram(ext_dram, NULL, \"powerlink_ext_d.ram\", 4*1024*1024, &error_abort);\n\n    vmstate_register_ram_global(ext_dram);\n\n    memory_region_init_ram(int_cram, NULL, \"powerlink_int_c.ram\", 48*1024, &error_abort);\n\n    vmstate_register_ram_global(int_cram);\n\n    memory_region_init_ram(int_dram, NULL, \"powerlink_int_d.ram\", 48*1024, &error_abort);\n\n    vmstate_register_ram_global(int_dram);\n\n    memory_region_init_ram(pcp_data, NULL, \"powerlink_pcp_data.ram\", 16*1024, &error_abort);\n\n    vmstate_register_ram_global(pcp_data);\n\n    memory_region_init_ram(pcp_text, NULL, \"powerlink_pcp_text.ram\", 32*1024, &error_abort);\n\n    vmstate_register_ram_global(pcp_text);\n\n\n\n    memory_region_add_subregion(sysmem, 0x80000000, ext_cram);\n\n    memory_region_add_subregion(sysmem, 0xa1000000, ext_dram);\n\n    memory_region_add_subregion(sysmem, 0xd4000000, int_cram);\n\n    memory_region_add_subregion(sysmem, 0xd0000000, int_dram);\n\n    memory_region_add_subregion(sysmem, 0xf0050000, pcp_data);\n\n    memory_region_add_subregion(sysmem, 0xf0060000, pcp_text);\n\n\n\n    tricoretb_binfo.ram_size = machine->ram_size;\n\n    tricoretb_binfo.kernel_filename = machine->kernel_filename;\n\n\n\n    if (machine->kernel_filename) {\n\n        tricore_load_kernel(env);\n\n    }\n\n}\n", "idx": 14570, "_split": "valid", "_hash": "f451904de4442bbe0f391256298efcb1"}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static uint64_t pxa2xx_cm_read(void *opaque, hwaddr addr,\n\n                               unsigned size)\n\n{\n\n    PXA2xxState *s = (PXA2xxState *) opaque;\n\n\n\n    switch (addr) {\n\n    case CCCR:\n\n    case CKEN:\n\n    case OSCC:\n\n        return s->cm_regs[addr >> 2];\n\n\n\n    case CCSR:\n\n        return s->cm_regs[CCCR >> 2] | (3 << 28);\n\n\n\n    default:\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 14587, "_split": "valid", "_hash": "5f72e69b3259a499524ecd606964dbf5"}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(test_ctrz_true)\n\n{\n\n    T0 = (regs->ctr == 0 && (T0 & PARAM(1)) != 0);\n\n    RETURN();\n\n}\n", "idx": 14634, "_split": "valid", "_hash": "50f284ac640cec26a8bcb8e2a6f73f90"}
{"project": "qemu", "commit_id": "47116d1c90cdac94cb9da270320dcf0d5ce1cfe2", "target": 1, "func": "static void monitor_control_event(void *opaque, int event)\n\n{\n\n    if (event == CHR_EVENT_OPENED) {\n\n        QObject *data;\n\n        Monitor *mon = opaque;\n\n\n\n        mon->mc->command_mode = 0;\n\n        json_message_parser_init(&mon->mc->parser, handle_qmp_command);\n\n\n\n        data = get_qmp_greeting();\n\n        monitor_json_emitter(mon, data);\n\n        qobject_decref(data);\n\n    }\n\n}\n", "idx": 14643, "_split": "valid", "_hash": "67382be3f28a1ab139144c2da90569a3"}
{"project": "qemu", "commit_id": "6f2d8978728c48ca46f5c01835438508aace5c64", "target": 1, "func": "void cpu_ppc_reset (void *opaque)\n\n{\n\n    CPUPPCState *env;\n\n    target_ulong msr;\n\n\n\n    env = opaque;\n\n    msr = (target_ulong)0;\n\n#if defined(TARGET_PPC64)\n\n    msr |= (target_ulong)0 << MSR_HV; /* Should be 1... */\n\n#endif\n\n    msr |= (target_ulong)0 << MSR_AP; /* TO BE CHECKED */\n\n    msr |= (target_ulong)0 << MSR_SA; /* TO BE CHECKED */\n\n    msr |= (target_ulong)1 << MSR_EP;\n\n#if defined (DO_SINGLE_STEP) && 0\n\n    /* Single step trace mode */\n\n    msr |= (target_ulong)1 << MSR_SE;\n\n    msr |= (target_ulong)1 << MSR_BE;\n\n#endif\n\n#if defined(CONFIG_USER_ONLY)\n\n    msr |= (target_ulong)1 << MSR_FP; /* Allow floating point usage */\n\n    msr |= (target_ulong)1 << MSR_PR;\n\n#else\n\n    env->nip = env->hreset_vector | env->excp_prefix;\n\n    if (env->mmu_model != POWERPC_MMU_REAL_4xx)\n\n        ppc_tlb_invalidate_all(env);\n\n#endif\n\n    env->msr = msr;\n\n    hreg_compute_hflags(env);\n\n    env->reserve = -1;\n\n    /* Be sure no exception or interrupt is pending */\n\n    env->pending_interrupts = 0;\n\n    env->exception_index = POWERPC_EXCP_NONE;\n\n    env->error_code = 0;\n\n    /* Flush all TLBs */\n\n    tlb_flush(env, 1);\n\n}\n", "idx": 14652, "_split": "valid", "_hash": "a8e1f2cb061fa6dc228f0b50a98ccfd6"}
{"project": "qemu", "commit_id": "758ead31c7e17bf17a9ef2e0ca1c3e86ab296b43", "target": 1, "func": "void virtio_queue_set_align(VirtIODevice *vdev, int n, int align)\n\n{\n\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n\n\n    /* virtio-1 compliant devices cannot change the alignment */\n\n    if (virtio_vdev_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n\n        error_report(\"tried to modify queue alignment for virtio-1 device\");\n\n        return;\n\n    }\n\n    /* Check that the transport told us it was going to do this\n\n     * (so a buggy transport will immediately assert rather than\n\n     * silently failing to migrate this state)\n\n     */\n\n    assert(k->has_variable_vring_alignment);\n\n\n\n    vdev->vq[n].vring.align = align;\n\n    virtio_queue_update_rings(vdev, n);\n\n}\n", "idx": 14661, "_split": "valid", "_hash": "0190aa5fd6f680bdfadeeae0e82dc1aa"}
{"project": "qemu", "commit_id": "010ec6293409f10b88631c36145944b9c3277ce1", "target": 1, "func": "static void action_command(EEPRO100State *s)\n\n{\n\n    for (;;) {\n\n        bool bit_el;\n\n        bool bit_s;\n\n        bool bit_i;\n\n        bool bit_nc;\n\n        uint16_t ok_status = STATUS_OK;\n\n        s->cb_address = s->cu_base + s->cu_offset;\n\n        read_cb(s);\n\n        bit_el = ((s->tx.command & COMMAND_EL) != 0);\n\n        bit_s = ((s->tx.command & COMMAND_S) != 0);\n\n        bit_i = ((s->tx.command & COMMAND_I) != 0);\n\n        bit_nc = ((s->tx.command & COMMAND_NC) != 0);\n\n#if 0\n\n        bool bit_sf = ((s->tx.command & COMMAND_SF) != 0);\n\n#endif\n\n        s->cu_offset = s->tx.link;\n\n        TRACE(OTHER,\n\n              logout(\"val=(cu start), status=0x%04x, command=0x%04x, link=0x%08x\\n\",\n\n                     s->tx.status, s->tx.command, s->tx.link));\n\n        switch (s->tx.command & COMMAND_CMD) {\n\n        case CmdNOp:\n\n            /* Do nothing. */\n\n            break;\n\n        case CmdIASetup:\n\n            cpu_physical_memory_read(s->cb_address + 8, &s->conf.macaddr.a[0], 6);\n\n            TRACE(OTHER, logout(\"macaddr: %s\\n\", nic_dump(&s->conf.macaddr.a[0], 6)));\n\n            break;\n\n        case CmdConfigure:\n\n            cpu_physical_memory_read(s->cb_address + 8, &s->configuration[0],\n\n                                     sizeof(s->configuration));\n\n            TRACE(OTHER, logout(\"configuration: %s\\n\", nic_dump(&s->configuration[0], 16)));\n\n            break;\n\n        case CmdMulticastList:\n\n            set_multicast_list(s);\n\n            break;\n\n        case CmdTx:\n\n            if (bit_nc) {\n\n                missing(\"CmdTx: NC = 0\");\n\n                ok_status = 0;\n\n                break;\n\n            }\n\n            tx_command(s);\n\n            break;\n\n        case CmdTDR:\n\n            TRACE(OTHER, logout(\"load microcode\\n\"));\n\n            /* Starting with offset 8, the command contains\n\n             * 64 dwords microcode which we just ignore here. */\n\n            break;\n\n        case CmdDiagnose:\n\n            TRACE(OTHER, logout(\"diagnose\\n\"));\n\n            /* Make sure error flag is not set. */\n\n            s->tx.status = 0;\n\n            break;\n\n        default:\n\n            missing(\"undefined command\");\n\n            ok_status = 0;\n\n            break;\n\n        }\n\n        /* Write new status. */\n\n        stw_phys(s->cb_address, s->tx.status | ok_status | STATUS_C);\n\n        if (bit_i) {\n\n            /* CU completed action. */\n\n            eepro100_cx_interrupt(s);\n\n        }\n\n        if (bit_el) {\n\n            /* CU becomes idle. Terminate command loop. */\n\n            set_cu_state(s, cu_idle);\n\n            eepro100_cna_interrupt(s);\n\n            break;\n\n        } else if (bit_s) {\n\n            /* CU becomes suspended. Terminate command loop. */\n\n            set_cu_state(s, cu_suspended);\n\n            eepro100_cna_interrupt(s);\n\n            break;\n\n        } else {\n\n            /* More entries in list. */\n\n            TRACE(OTHER, logout(\"CU list with at least one more entry\\n\"));\n\n        }\n\n    }\n\n    TRACE(OTHER, logout(\"CU list empty\\n\"));\n\n    /* List is empty. Now CU is idle or suspended. */\n\n}\n", "idx": 14675, "_split": "valid", "_hash": "a6282e5fc2ebb33b5600773147070ad7"}
{"project": "qemu", "commit_id": "91cda45b69e45a089f9989979a65db3f710c9925", "target": 0, "func": "int ppc_hash64_handle_mmu_fault(CPUPPCState *env, target_ulong address, int rw,\n\n                                int mmu_idx)\n\n{\n\n    struct mmu_ctx_hash64 ctx;\n\n    int access_type;\n\n    int ret = 0;\n\n\n\n    if (rw == 2) {\n\n        /* code access */\n\n        rw = 0;\n\n        access_type = ACCESS_CODE;\n\n    } else {\n\n        /* data access */\n\n        access_type = env->access_type;\n\n    }\n\n    ret = ppc_hash64_get_physical_address(env, &ctx, address, rw, access_type);\n\n    if (ret == 0) {\n\n        tlb_set_page(env, address & TARGET_PAGE_MASK,\n\n                     ctx.raddr & TARGET_PAGE_MASK, ctx.prot,\n\n                     mmu_idx, TARGET_PAGE_SIZE);\n\n        ret = 0;\n\n    } else if (ret < 0) {\n\n        LOG_MMU_STATE(env);\n\n        if (access_type == ACCESS_CODE) {\n\n            switch (ret) {\n\n            case -1:\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x40000000;\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x08000000;\n\n                break;\n\n            case -3:\n\n                /* No execute protection violation */\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x10000000;\n\n                break;\n\n            case -5:\n\n                /* No match in segment table */\n\n                env->exception_index = POWERPC_EXCP_ISEG;\n\n                env->error_code = 0;\n\n                break;\n\n            }\n\n        } else {\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables or TLB */\n\n                env->exception_index = POWERPC_EXCP_DSI;\n\n                env->error_code = 0;\n\n                env->spr[SPR_DAR] = address;\n\n                if (rw == 1) {\n\n                    env->spr[SPR_DSISR] = 0x42000000;\n\n                } else {\n\n                    env->spr[SPR_DSISR] = 0x40000000;\n\n                }\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                env->exception_index = POWERPC_EXCP_DSI;\n\n                env->error_code = 0;\n\n                env->spr[SPR_DAR] = address;\n\n                if (rw == 1) {\n\n                    env->spr[SPR_DSISR] = 0x0A000000;\n\n                } else {\n\n                    env->spr[SPR_DSISR] = 0x08000000;\n\n                }\n\n                break;\n\n            case -5:\n\n                /* No match in segment table */\n\n                env->exception_index = POWERPC_EXCP_DSEG;\n\n                env->error_code = 0;\n\n                env->spr[SPR_DAR] = address;\n\n                break;\n\n            }\n\n        }\n\n#if 0\n\n        printf(\"%s: set exception to %d %02x\\n\", __func__,\n\n               env->exception, env->error_code);\n\n#endif\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 14706, "_split": "valid", "_hash": "47c098d29d53aed564f747577f021018"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void isa_mmio_writew(void *opaque, target_phys_addr_t addr,\n\n                               uint32_t val)\n\n{\n\n    cpu_outw(addr & IOPORTS_MASK, val);\n\n}\n", "idx": 14713, "_split": "valid", "_hash": "0537907de4c24a2edabc6016be3c5ac6"}
{"project": "qemu", "commit_id": "31ce5e0c49821d92fb30cce2f3055ef33613b287", "target": 1, "func": "int kvm_on_sigbus(int code, void *addr)\n\n{\n\n#if defined(KVM_CAP_MCE)\n\n    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {\n\n        uint64_t status;\n\n        void *vaddr;\n\n        ram_addr_t ram_addr;\n\n        target_phys_addr_t paddr;\n\n\n\n        /* Hope we are lucky for AO MCE */\n\n        vaddr = addr;\n\n        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||\n\n            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr, &paddr)) {\n\n            fprintf(stderr, \"Hardware memory error for memory used by \"\n\n                    \"QEMU itself instead of guest system!: %p\\n\", addr);\n\n            return 0;\n\n        }\n\n        status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN\n\n            | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S\n\n            | 0xc0;\n\n        kvm_inject_x86_mce(first_cpu, 9, status,\n\n                           MCG_STATUS_MCIP | MCG_STATUS_RIPV, paddr,\n\n                           (MCM_ADDR_PHYS << 6) | 0xc, 1);\n\n        kvm_mce_broadcast_rest(first_cpu);\n\n    } else\n\n#endif\n\n    {\n\n        if (code == BUS_MCEERR_AO) {\n\n            return 0;\n\n        } else if (code == BUS_MCEERR_AR) {\n\n            hardware_memory_error();\n\n        } else {\n\n            return 1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 14770, "_split": "valid", "_hash": "92ecd5461b805b4ad3cef8f1b0a85613"}
{"project": "qemu", "commit_id": "3d002df33eb034757d98e1ae529318f57df78f91", "target": 0, "func": "static size_t buffered_set_rate_limit(void *opaque, size_t new_rate)\n\n{\n\n    QEMUFileBuffered *s = opaque;\n\n\n\n    if (s->has_error)\n\n        goto out;\n\n\n\n    s->xfer_limit = new_rate / 10;\n\n    \n\nout:\n\n    return s->xfer_limit;\n\n}\n", "idx": 14781, "_split": "valid", "_hash": "b1ea606da37ed088769fbe4b30d4c6f2"}
{"project": "qemu", "commit_id": "d2eae20790e825656b205dbe347826ff991fb3d8", "target": 0, "func": "static void ccw_init(MachineState *machine)\n\n{\n\n    int ret;\n\n    VirtualCssBus *css_bus;\n\n    DeviceState *dev;\n\n\n\n    s390_sclp_init();\n\n    s390_memory_init(machine->ram_size);\n\n\n\n    /* get a BUS */\n\n    css_bus = virtual_css_bus_init();\n\n    s390_init_ipl_dev(machine->kernel_filename, machine->kernel_cmdline,\n\n                      machine->initrd_filename, \"s390-ccw.img\", true);\n\n    s390_flic_init();\n\n\n\n    dev = qdev_create(NULL, TYPE_S390_PCI_HOST_BRIDGE);\n\n    object_property_add_child(qdev_get_machine(), TYPE_S390_PCI_HOST_BRIDGE,\n\n                              OBJECT(dev), NULL);\n\n    qdev_init_nofail(dev);\n\n\n\n    /* register hypercalls */\n\n    virtio_ccw_register_hcalls();\n\n\n\n    /* init CPUs */\n\n    s390_init_cpus(machine->cpu_model);\n\n\n\n    if (kvm_enabled()) {\n\n        kvm_s390_enable_css_support(s390_cpu_addr2state(0));\n\n    }\n\n    /*\n\n     * Create virtual css and set it as default so that non mcss-e\n\n     * enabled guests only see virtio devices.\n\n     */\n\n    ret = css_create_css_image(VIRTUAL_CSSID, true);\n\n    assert(ret == 0);\n\n\n\n    /* Create VirtIO network adapters */\n\n    s390_create_virtio_net(BUS(css_bus), \"virtio-net-ccw\");\n\n\n\n    /* Register savevm handler for guest TOD clock */\n\n    register_savevm(NULL, \"todclock\", 0, 1,\n\n                    gtod_save, gtod_load, kvm_state);\n\n}\n", "idx": 14788, "_split": "valid", "_hash": "9af901720a8f86f7e4fd223ec1dba437"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_load_vmstate(BlockDriverState *bs, uint8_t *buf,\n\n                      int64_t pos, int size)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n    if (drv->bdrv_load_vmstate)\n\n        return drv->bdrv_load_vmstate(bs, buf, pos, size);\n\n    if (bs->file)\n\n        return bdrv_load_vmstate(bs->file, buf, pos, size);\n\n    return -ENOTSUP;\n\n}\n", "idx": 14789, "_split": "valid", "_hash": "61e561bc660824a4347a105b186cfc44"}
{"project": "qemu", "commit_id": "0ae18ceeaaa2c1749e742c4b112f6c3bf0896408", "target": 0, "func": "static void versatile_init(ram_addr_t ram_size, int vga_ram_size,\n\n                     const char *boot_device, DisplayState *ds,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename, const char *cpu_model,\n\n                     int board_id)\n\n{\n\n    CPUState *env;\n\n    qemu_irq *pic;\n\n    qemu_irq *sic;\n\n    void *scsi_hba;\n\n    PCIBus *pci_bus;\n\n    NICInfo *nd;\n\n    int n;\n\n    int done_smc = 0;\n\n    int index;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"arm926\";\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    /* ??? RAM should repeat to fill physical memory space.  */\n\n    /* SDRAM at address zero.  */\n\n    cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);\n\n\n\n    arm_sysctl_init(0x10000000, 0x41007004);\n\n    pic = arm_pic_init_cpu(env);\n\n    pic = pl190_init(0x10140000, pic[0], pic[1]);\n\n    sic = vpb_sic_init(0x10003000, pic, 31);\n\n    pl050_init(0x10006000, sic[3], 0);\n\n    pl050_init(0x10007000, sic[4], 1);\n\n\n\n    pci_bus = pci_vpb_init(sic, 27, 0);\n\n    /* The Versatile PCI bridge does not provide access to PCI IO space,\n\n       so many of the qemu PCI devices are not useable.  */\n\n    for(n = 0; n < nb_nics; n++) {\n\n        nd = &nd_table[n];\n\n        if (!nd->model)\n\n            nd->model = done_smc ? \"rtl8139\" : \"smc91c111\";\n\n        if (strcmp(nd->model, \"smc91c111\") == 0) {\n\n            smc91c111_init(nd, 0x10010000, sic[25]);\n\n        } else {\n\n            pci_nic_init(pci_bus, nd, -1);\n\n        }\n\n    }\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, 3, -1);\n\n    }\n\n    if (drive_get_max_bus(IF_SCSI) > 0) {\n\n        fprintf(stderr, \"qemu: too many SCSI bus\\n\");\n\n        exit(1);\n\n    }\n\n    scsi_hba = lsi_scsi_init(pci_bus, -1);\n\n    for (n = 0; n < LSI_MAX_DEVS; n++) {\n\n        index = drive_get_index(IF_SCSI, 0, n);\n\n        if (index == -1)\n\n            continue;\n\n        lsi_scsi_attach(scsi_hba, drives_table[index].bdrv, n);\n\n    }\n\n\n\n    pl011_init(0x101f1000, pic[12], serial_hds[0], PL011_ARM);\n\n    pl011_init(0x101f2000, pic[13], serial_hds[1], PL011_ARM);\n\n    pl011_init(0x101f3000, pic[14], serial_hds[2], PL011_ARM);\n\n    pl011_init(0x10009000, sic[6], serial_hds[3], PL011_ARM);\n\n\n\n    pl080_init(0x10130000, pic[17], 8);\n\n    sp804_init(0x101e2000, pic[4]);\n\n    sp804_init(0x101e3000, pic[5]);\n\n\n\n    /* The versatile/PB actually has a modified Color LCD controller\n\n       that includes hardware cursor support from the PL111.  */\n\n    pl110_init(ds, 0x10120000, pic[16], 1);\n\n\n\n    index = drive_get_index(IF_SD, 0, 0);\n\n    if (index == -1) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital card\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    pl181_init(0x10005000, drives_table[index].bdrv, sic[22], sic[1]);\n\n#if 0\n\n    /* Disabled because there's no way of specifying a block device.  */\n\n    pl181_init(0x1000b000, NULL, sic, 23, 2);\n\n#endif\n\n\n\n    /* Add PL031 Real Time Clock. */\n\n    pl031_init(0x101e8000,pic[10]);\n\n\n\n    /* Memory map for Versatile/PB:  */\n\n    /* 0x10000000 System registers.  */\n\n    /* 0x10001000 PCI controller config registers.  */\n\n    /* 0x10002000 Serial bus interface.  */\n\n    /*  0x10003000 Secondary interrupt controller.  */\n\n    /* 0x10004000 AACI (audio).  */\n\n    /*  0x10005000 MMCI0.  */\n\n    /*  0x10006000 KMI0 (keyboard).  */\n\n    /*  0x10007000 KMI1 (mouse).  */\n\n    /* 0x10008000 Character LCD Interface.  */\n\n    /*  0x10009000 UART3.  */\n\n    /* 0x1000a000 Smart card 1.  */\n\n    /*  0x1000b000 MMCI1.  */\n\n    /*  0x10010000 Ethernet.  */\n\n    /* 0x10020000 USB.  */\n\n    /* 0x10100000 SSMC.  */\n\n    /* 0x10110000 MPMC.  */\n\n    /*  0x10120000 CLCD Controller.  */\n\n    /*  0x10130000 DMA Controller.  */\n\n    /*  0x10140000 Vectored interrupt controller.  */\n\n    /* 0x101d0000 AHB Monitor Interface.  */\n\n    /* 0x101e0000 System Controller.  */\n\n    /* 0x101e1000 Watchdog Interface.  */\n\n    /* 0x101e2000 Timer 0/1.  */\n\n    /* 0x101e3000 Timer 2/3.  */\n\n    /* 0x101e4000 GPIO port 0.  */\n\n    /* 0x101e5000 GPIO port 1.  */\n\n    /* 0x101e6000 GPIO port 2.  */\n\n    /* 0x101e7000 GPIO port 3.  */\n\n    /* 0x101e8000 RTC.  */\n\n    /* 0x101f0000 Smart card 0.  */\n\n    /*  0x101f1000 UART0.  */\n\n    /*  0x101f2000 UART1.  */\n\n    /*  0x101f3000 UART2.  */\n\n    /* 0x101f4000 SSPI.  */\n\n\n\n    versatile_binfo.ram_size = ram_size;\n\n    versatile_binfo.kernel_filename = kernel_filename;\n\n    versatile_binfo.kernel_cmdline = kernel_cmdline;\n\n    versatile_binfo.initrd_filename = initrd_filename;\n\n    versatile_binfo.board_id = board_id;\n\n    arm_load_kernel(env, &versatile_binfo);\n\n}\n", "idx": 14801, "_split": "valid", "_hash": "b38b6757e727c0ab8ba4412d4d9deacf"}
{"project": "qemu", "commit_id": "318347234d7069b62d38391dd27e269a3107d668", "target": 0, "func": "static void detach(sPAPRDRConnector *drc, DeviceState *d,\n\n                   spapr_drc_detach_cb *detach_cb,\n\n                   void *detach_cb_opaque, Error **errp)\n\n{\n\n    trace_spapr_drc_detach(get_index(drc));\n\n\n\n    drc->detach_cb = detach_cb;\n\n    drc->detach_cb_opaque = detach_cb_opaque;\n\n\n\n    /* if we've signalled device presence to the guest, or if the guest\n\n     * has gone ahead and configured the device (via manually-executed\n\n     * device add via drmgr in guest, namely), we need to wait\n\n     * for the guest to quiesce the device before completing detach.\n\n     * Otherwise, we can assume the guest hasn't seen it and complete the\n\n     * detach immediately. Note that there is a small race window\n\n     * just before, or during, configuration, which is this context\n\n     * refers mainly to fetching the device tree via RTAS.\n\n     * During this window the device access will be arbitrated by\n\n     * associated DRC, which will simply fail the RTAS calls as invalid.\n\n     * This is recoverable within guest and current implementations of\n\n     * drmgr should be able to cope.\n\n     */\n\n    if (!drc->signalled && !drc->configured) {\n\n        /* if the guest hasn't seen the device we can't rely on it to\n\n         * set it back to an isolated state via RTAS, so do it here manually\n\n         */\n\n        drc->isolation_state = SPAPR_DR_ISOLATION_STATE_ISOLATED;\n\n    }\n\n\n\n    if (drc->isolation_state != SPAPR_DR_ISOLATION_STATE_ISOLATED) {\n\n        trace_spapr_drc_awaiting_isolated(get_index(drc));\n\n        drc->awaiting_release = true;\n\n        return;\n\n    }\n\n\n\n    if (drc->type != SPAPR_DR_CONNECTOR_TYPE_PCI &&\n\n        drc->allocation_state != SPAPR_DR_ALLOCATION_STATE_UNUSABLE) {\n\n        trace_spapr_drc_awaiting_unusable(get_index(drc));\n\n        drc->awaiting_release = true;\n\n        return;\n\n    }\n\n\n\n    if (drc->awaiting_allocation) {\n\n        if (!drc->awaiting_allocation_skippable) {\n\n            drc->awaiting_release = true;\n\n            trace_spapr_drc_awaiting_allocation(get_index(drc));\n\n            return;\n\n        }\n\n    }\n\n\n\n    drc->indicator_state = SPAPR_DR_INDICATOR_STATE_INACTIVE;\n\n\n\n    if (drc->detach_cb) {\n\n        drc->detach_cb(drc->dev, drc->detach_cb_opaque);\n\n    }\n\n\n\n    drc->awaiting_release = false;\n\n    drc->awaiting_allocation_skippable = false;\n\n    g_free(drc->fdt);\n\n    drc->fdt = NULL;\n\n    drc->fdt_start_offset = 0;\n\n    object_property_del(OBJECT(drc), \"device\", NULL);\n\n    drc->dev = NULL;\n\n    drc->detach_cb = NULL;\n\n    drc->detach_cb_opaque = NULL;\n\n}\n", "idx": 14808, "_split": "valid", "_hash": "4d6d5fe9024d07a5f6e36fca10cc7b1c"}
{"project": "qemu", "commit_id": "47e8dd8fe9d83e8b51d40c2b87d7983bd0a78206", "target": 1, "func": "char **breakline(char *input, int *count)\n\n{\n\n    int c = 0;\n\n    char *p;\n\n    char **rval = calloc(sizeof(char *), 1);\n\n\n\n    while (rval && (p = qemu_strsep(&input, \" \")) != NULL) {\n\n        if (!*p) {\n\n            continue;\n\n        }\n\n        c++;\n\n        rval = realloc(rval, sizeof(*rval) * (c + 1));\n\n        if (!rval) {\n\n            c = 0;\n\n            break;\n\n        }\n\n        rval[c - 1] = p;\n\n        rval[c] = NULL;\n\n    }\n\n    *count = c;\n\n    return rval;\n\n}\n", "idx": 14818, "_split": "valid", "_hash": "28be3be862a9feffda00889b4d869cc4"}
{"project": "qemu", "commit_id": "089f26bb735fb414b79f5fa3753910d5339d2a1d", "target": 1, "func": "static gsize calc_float_string_storage(double value)\n\n{\n\n    int whole_value = value;\n\n    gsize i = 0;\n\n    do {\n\n        i++;\n\n    } while (whole_value /= 10);\n\n    return i + 2 + FLOAT_STRING_PRECISION;\n\n}\n", "idx": 14829, "_split": "valid", "_hash": "141287701bae58295f8151abb8a775fe"}
{"project": "qemu", "commit_id": "7f9744812291853425b614f68668f48d49882a1f", "target": 0, "func": "static void virtio_net_vmstate_change(void *opaque, int running, int reason)\n\n{\n\n    VirtIONet *n = opaque;\n\n    if (!running) {\n\n        return;\n\n    }\n\n    /* This is called when vm is started, it will start vhost backend if\n\n     * appropriate e.g. after migration. */\n\n    virtio_net_set_status(&n->vdev, n->vdev.status);\n\n}\n", "idx": 14850, "_split": "valid", "_hash": "4598e3a6f0779d24a6f1ee18d277edad"}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static int coroutine_fn raw_co_pdiscard(BlockDriverState *bs,\n\n                                        int64_t offset, int count)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    if (offset > UINT64_MAX - s->offset) {\n\n        return -EINVAL;\n\n    }\n\n    offset += s->offset;\n\n    return bdrv_co_pdiscard(bs->file->bs, offset, count);\n\n}\n", "idx": 14854, "_split": "valid", "_hash": "361f86b6a61720fdc3ccbc7e3f914c62"}
{"project": "qemu", "commit_id": "6fa2c95f279dda62aa7e3292cc424ff3fab6a602", "target": 0, "func": "static int scsi_write_data(SCSIDevice *d, uint32_t tag)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n\n    SCSIDiskReq *r;\n\n\n\n    DPRINTF(\"Write data tag=0x%x\\n\", tag);\n\n    r = scsi_find_request(s, tag);\n\n    if (!r) {\n\n        BADF(\"Bad write tag 0x%x\\n\", tag);\n\n        scsi_command_complete(r, CHECK_CONDITION, HARDWARE_ERROR);\n\n        return 1;\n\n    }\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    scsi_write_request(r);\n\n\n\n    return 0;\n\n}\n", "idx": 14887, "_split": "valid", "_hash": "8c11379fb8e029a29103694bc9ea432d"}
{"project": "qemu", "commit_id": "f186d64d8fda4bb22c15beb8e45b7814fbd8b51e", "target": 0, "func": "void replay_account_executed_instructions(void)\n\n{\n\n    if (replay_mode == REPLAY_MODE_PLAY) {\n\n        replay_mutex_lock();\n\n        if (replay_state.instructions_count > 0) {\n\n            int count = (int)(replay_get_current_step()\n\n                              - replay_state.current_step);\n\n            replay_state.instructions_count -= count;\n\n            replay_state.current_step += count;\n\n            if (replay_state.instructions_count == 0) {\n\n                assert(replay_data_kind == EVENT_INSTRUCTION);\n\n                replay_finish_event();\n\n                /* Wake up iothread. This is required because\n\n                   timers will not expire until clock counters\n\n                   will be read from the log. */\n\n                qemu_notify_event();\n\n            }\n\n        }\n\n        replay_mutex_unlock();\n\n    }\n\n}\n", "idx": 14890, "_split": "valid", "_hash": "26b74a49269709c8f99dac249e9f416d"}
{"project": "qemu", "commit_id": "e8ee5e4c476d5b0654d8f1271a2b7c065acc486e", "target": 0, "func": "void qemu_co_rwlock_unlock(CoRwlock *lock)\n\n{\n\n    assert(qemu_in_coroutine());\n\n    if (lock->writer) {\n\n        lock->writer = false;\n\n        while (!qemu_co_queue_empty(&lock->queue)) {\n\n            /*\n\n             * Wakeup every body. This will include some\n\n             * writers too.\n\n             */\n\n            qemu_co_queue_next(&lock->queue);\n\n        }\n\n    } else {\n\n        lock->reader--;\n\n        assert(lock->reader >= 0);\n\n        /* Wakeup only one waiting writer */\n\n        if (!lock->reader) {\n\n            qemu_co_queue_next(&lock->queue);\n\n        }\n\n    }\n\n}\n", "idx": 14902, "_split": "valid", "_hash": "0a9fe887ff0de21aad0db4fbe01d1593"}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float32 HELPER(ucf64_sf2si)(float32 x, CPUUniCore32State *env)\n\n{\n\n    return ucf64_itos(float32_to_int32(x, &env->ucf64.fp_status));\n\n}\n", "idx": 14918, "_split": "valid", "_hash": "b5a2a591ae33631a803f0f257e2430a8"}
{"project": "qemu", "commit_id": "a35faa94c8e8d851a1d07e17c98f4ab2202b8a38", "target": 0, "func": "static int pl061_init(SysBusDevice *dev, const unsigned char *id)\n\n{\n\n    int iomemtype;\n\n    pl061_state *s = FROM_SYSBUS(pl061_state, dev);\n\n    s->id = id;\n\n    iomemtype = cpu_register_io_memory(pl061_readfn,\n\n                                       pl061_writefn, s,\n\n                                       DEVICE_NATIVE_ENDIAN);\n\n    sysbus_init_mmio(dev, 0x1000, iomemtype);\n\n    sysbus_init_irq(dev, &s->irq);\n\n    qdev_init_gpio_in(&dev->qdev, pl061_set_irq, 8);\n\n    qdev_init_gpio_out(&dev->qdev, s->out, 8);\n\n    pl061_reset(s);\n\n    register_savevm(&dev->qdev, \"pl061_gpio\", -1, 1, pl061_save, pl061_load, s);\n\n    return 0;\n\n}\n", "idx": 14933, "_split": "valid", "_hash": "d89cbc9ee1f7cbec32b14c32cc12fe54"}
{"project": "qemu", "commit_id": "69795d6769910eaee4416470744e65ae066aeb54", "target": 0, "func": "void qemu_chr_reset(CharDriverState *s)\n\n{\n\n    if (s->bh == NULL && initial_reset_issued) {\n\n\ts->bh = qemu_bh_new(qemu_chr_reset_bh, s);\n\n\tqemu_bh_schedule(s->bh);\n\n    }\n\n}\n", "idx": 14939, "_split": "valid", "_hash": "fac29c69aa4c002090e2d580ae023994"}
{"project": "qemu", "commit_id": "d0bce760e04b1658a3b4ac95be2839ae20fd86db", "target": 1, "func": "static void omap_i2c_set_slave_addr(OMAPI2C *s, uint8_t addr)\n\n{\n\n    uint16_t data = addr;\n\n\n\n    memwrite(s->addr + OMAP_I2C_SA, &data, 2);\n\n    memread(s->addr + OMAP_I2C_SA, &data, 2);\n\n    g_assert_cmphex(data, ==, addr);\n\n}\n", "idx": 14943, "_split": "valid", "_hash": "c146e35eeb981014215597386efba33a"}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static int coroutine_fn qed_aio_write_cow(QEDAIOCB *acb)\n\n{\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n    uint64_t start, len, offset;\n\n    int ret;\n\n\n\n    /* Populate front untouched region of new data cluster */\n\n    start = qed_start_of_cluster(s, acb->cur_pos);\n\n    len = qed_offset_into_cluster(s, acb->cur_pos);\n\n\n\n    trace_qed_aio_write_prefill(s, acb, start, len, acb->cur_cluster);\n\n    ret = qed_copy_from_backing_file(s, start, len, acb->cur_cluster);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Populate back untouched region of new data cluster */\n\n    start = acb->cur_pos + acb->cur_qiov.size;\n\n    len = qed_start_of_cluster(s, start + s->header.cluster_size - 1) - start;\n\n    offset = acb->cur_cluster +\n\n             qed_offset_into_cluster(s, acb->cur_pos) +\n\n             acb->cur_qiov.size;\n\n\n\n    trace_qed_aio_write_postfill(s, acb, start, len, offset);\n\n    ret = qed_copy_from_backing_file(s, start, len, offset);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    ret = qed_aio_write_main(acb);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (s->bs->backing) {\n\n        /*\n\n         * Flush new data clusters before updating the L2 table\n\n         *\n\n         * This flush is necessary when a backing file is in use.  A crash\n\n         * during an allocating write could result in empty clusters in the\n\n         * image.  If the write only touched a subregion of the cluster,\n\n         * then backing image sectors have been lost in the untouched\n\n         * region.  The solution is to flush after writing a new data\n\n         * cluster and before updating the L2 table.\n\n         */\n\n        ret = bdrv_co_flush(s->bs->file->bs);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14958, "_split": "valid", "_hash": "dbef7b60a8fe2baa233cca4959b53d0a"}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "static void end_list(Visitor *v)\n\n{\n\n    StringInputVisitor *siv = to_siv(v);\n\n    siv->head = true;\n\n}\n", "idx": 14962, "_split": "valid", "_hash": "0b80e5f341ed32a8f58ba481ca6f0623"}
{"project": "qemu", "commit_id": "c0f4ce7751f0b9a9a7815f931a09a6c3de127cee", "target": 0, "func": "static void do_cont(void)\n\n{\n\n    vm_start();\n\n}\n", "idx": 14965, "_split": "valid", "_hash": "4b530c9ea387ee75553a6a91700f5339"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void AUD_remove_card (QEMUSoundCard *card)\n\n{\n\n    LIST_REMOVE (card, entries);\n\n    qemu_free (card->name);\n\n}\n", "idx": 14968, "_split": "valid", "_hash": "8baabc0a30429edd7c43976ebc584bd2"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void phys_page_set_level(PhysPageEntry *lp, target_phys_addr_t *index,\n\n                                target_phys_addr_t *nb, uint16_t leaf,\n\n                                int level)\n\n{\n\n    PhysPageEntry *p;\n\n    int i;\n\n    target_phys_addr_t step = (target_phys_addr_t)1 << (level * L2_BITS);\n\n\n\n    if (!lp->is_leaf && lp->ptr == PHYS_MAP_NODE_NIL) {\n\n        lp->ptr = phys_map_node_alloc();\n\n        p = phys_map_nodes[lp->ptr];\n\n        if (level == 0) {\n\n            for (i = 0; i < L2_SIZE; i++) {\n\n                p[i].is_leaf = 1;\n\n                p[i].ptr = phys_section_unassigned;\n\n            }\n\n        }\n\n    } else {\n\n        p = phys_map_nodes[lp->ptr];\n\n    }\n\n    lp = &p[(*index >> (level * L2_BITS)) & (L2_SIZE - 1)];\n\n\n\n    while (*nb && lp < &p[L2_SIZE]) {\n\n        if ((*index & (step - 1)) == 0 && *nb >= step) {\n\n            lp->is_leaf = true;\n\n            lp->ptr = leaf;\n\n            *index += step;\n\n            *nb -= step;\n\n        } else {\n\n            phys_page_set_level(lp, index, nb, leaf, level - 1);\n\n        }\n\n        ++lp;\n\n    }\n\n}\n", "idx": 14971, "_split": "valid", "_hash": "5d2544a391ca70971b878c49b6af2970"}
{"project": "qemu", "commit_id": "2c62f08ddbf3fa80dc7202eb9a2ea60ae44e2cc5", "target": 0, "func": "static void tcx24_screen_dump(void *opaque, const char *filename, bool cswitch,\n\n                              Error **errp)\n\n{\n\n    TCXState *s = opaque;\n\n    FILE *f;\n\n    uint8_t *d, *d1, v;\n\n    uint32_t *s24, *cptr, dval;\n\n    int ret, y, x;\n\n\n\n    f = fopen(filename, \"wb\");\n\n    if (!f) {\n\n        error_setg(errp, \"failed to open file '%s': %s\", filename,\n\n                   strerror(errno));\n\n        return;\n\n    }\n\n    ret = fprintf(f, \"P6\\n%d %d\\n%d\\n\", s->width, s->height, 255);\n\n    if (ret < 0) {\n\n        goto write_err;\n\n    }\n\n    d1 = s->vram;\n\n    s24 = s->vram24;\n\n    cptr = s->cplane;\n\n    for(y = 0; y < s->height; y++) {\n\n        d = d1;\n\n        for(x = 0; x < s->width; x++, d++, s24++) {\n\n            if ((*cptr++ & 0xff000000) == 0x03000000) { // 24-bit direct\n\n                dval = *s24 & 0x00ffffff;\n\n                ret = fputc((dval >> 16) & 0xff, f);\n\n                if (ret == EOF) {\n\n                    goto write_err;\n\n                }\n\n                ret = fputc((dval >> 8) & 0xff, f);\n\n                if (ret == EOF) {\n\n                    goto write_err;\n\n                }\n\n                ret = fputc(dval & 0xff, f);\n\n                if (ret == EOF) {\n\n                    goto write_err;\n\n                }\n\n            } else {\n\n                v = *d;\n\n                ret = fputc(s->r[v], f);\n\n                if (ret == EOF) {\n\n                    goto write_err;\n\n                }\n\n                ret = fputc(s->g[v], f);\n\n                if (ret == EOF) {\n\n                    goto write_err;\n\n                }\n\n                ret = fputc(s->b[v], f);\n\n                if (ret == EOF) {\n\n                    goto write_err;\n\n                }\n\n            }\n\n        }\n\n        d1 += MAXX;\n\n    }\n\n\n\nout:\n\n    fclose(f);\n\n    return;\n\n\n\nwrite_err:\n\n    error_setg(errp, \"failed to write to file '%s': %s\", filename,\n\n               strerror(errno));\n\n    unlink(filename);\n\n    goto out;\n\n}\n", "idx": 14976, "_split": "valid", "_hash": "e694f99c337aff76cef47bd19bdda1f5"}
{"project": "qemu", "commit_id": "acbe59829e448aa63bdccc6ee484b7e1ac605e25", "target": 0, "func": "static int qcow2_open(BlockDriverState *bs, int flags)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int len, i, ret = 0;\n\n    QCowHeader header;\n\n    uint64_t ext_end;\n\n\n\n    ret = bdrv_pread(bs->file, 0, &header, sizeof(header));\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    be32_to_cpus(&header.magic);\n\n    be32_to_cpus(&header.version);\n\n    be64_to_cpus(&header.backing_file_offset);\n\n    be32_to_cpus(&header.backing_file_size);\n\n    be64_to_cpus(&header.size);\n\n    be32_to_cpus(&header.cluster_bits);\n\n    be32_to_cpus(&header.crypt_method);\n\n    be64_to_cpus(&header.l1_table_offset);\n\n    be32_to_cpus(&header.l1_size);\n\n    be64_to_cpus(&header.refcount_table_offset);\n\n    be32_to_cpus(&header.refcount_table_clusters);\n\n    be64_to_cpus(&header.snapshots_offset);\n\n    be32_to_cpus(&header.nb_snapshots);\n\n\n\n    if (header.magic != QCOW_MAGIC) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    if (header.version < 2 || header.version > 3) {\n\n        report_unsupported(bs, \"QCOW version %d\", header.version);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    s->qcow_version = header.version;\n\n\n\n    /* Initialise version 3 header fields */\n\n    if (header.version == 2) {\n\n        header.incompatible_features    = 0;\n\n        header.compatible_features      = 0;\n\n        header.autoclear_features       = 0;\n\n        header.refcount_order           = 4;\n\n        header.header_length            = 72;\n\n    } else {\n\n        be64_to_cpus(&header.incompatible_features);\n\n        be64_to_cpus(&header.compatible_features);\n\n        be64_to_cpus(&header.autoclear_features);\n\n        be32_to_cpus(&header.refcount_order);\n\n        be32_to_cpus(&header.header_length);\n\n    }\n\n\n\n    if (header.header_length > sizeof(header)) {\n\n        s->unknown_header_fields_size = header.header_length - sizeof(header);\n\n        s->unknown_header_fields = g_malloc(s->unknown_header_fields_size);\n\n        ret = bdrv_pread(bs->file, sizeof(header), s->unknown_header_fields,\n\n                         s->unknown_header_fields_size);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    if (header.backing_file_offset) {\n\n        ext_end = header.backing_file_offset;\n\n    } else {\n\n        ext_end = 1 << header.cluster_bits;\n\n    }\n\n\n\n    /* Handle feature bits */\n\n    s->incompatible_features    = header.incompatible_features;\n\n    s->compatible_features      = header.compatible_features;\n\n    s->autoclear_features       = header.autoclear_features;\n\n\n\n    if (s->incompatible_features & ~QCOW2_INCOMPAT_MASK) {\n\n        void *feature_table = NULL;\n\n        qcow2_read_extensions(bs, header.header_length, ext_end,\n\n                              &feature_table);\n\n        report_unsupported_feature(bs, feature_table,\n\n                                   s->incompatible_features &\n\n                                   ~QCOW2_INCOMPAT_MASK);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    /* Check support for various header values */\n\n    if (header.refcount_order != 4) {\n\n        report_unsupported(bs, \"%d bit reference counts\",\n\n                           1 << header.refcount_order);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    if (header.cluster_bits < MIN_CLUSTER_BITS ||\n\n        header.cluster_bits > MAX_CLUSTER_BITS) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    if (header.crypt_method > QCOW_CRYPT_AES) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    s->crypt_method_header = header.crypt_method;\n\n    if (s->crypt_method_header) {\n\n        bs->encrypted = 1;\n\n    }\n\n    s->cluster_bits = header.cluster_bits;\n\n    s->cluster_size = 1 << s->cluster_bits;\n\n    s->cluster_sectors = 1 << (s->cluster_bits - 9);\n\n    s->l2_bits = s->cluster_bits - 3; /* L2 is always one cluster */\n\n    s->l2_size = 1 << s->l2_bits;\n\n    bs->total_sectors = header.size / 512;\n\n    s->csize_shift = (62 - (s->cluster_bits - 8));\n\n    s->csize_mask = (1 << (s->cluster_bits - 8)) - 1;\n\n    s->cluster_offset_mask = (1LL << s->csize_shift) - 1;\n\n    s->refcount_table_offset = header.refcount_table_offset;\n\n    s->refcount_table_size =\n\n        header.refcount_table_clusters << (s->cluster_bits - 3);\n\n\n\n    s->snapshots_offset = header.snapshots_offset;\n\n    s->nb_snapshots = header.nb_snapshots;\n\n\n\n    /* read the level 1 table */\n\n    s->l1_size = header.l1_size;\n\n    s->l1_vm_state_index = size_to_l1(s, header.size);\n\n    /* the L1 table must contain at least enough entries to put\n\n       header.size bytes */\n\n    if (s->l1_size < s->l1_vm_state_index) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    s->l1_table_offset = header.l1_table_offset;\n\n    if (s->l1_size > 0) {\n\n        s->l1_table = g_malloc0(\n\n            align_offset(s->l1_size * sizeof(uint64_t), 512));\n\n        ret = bdrv_pread(bs->file, s->l1_table_offset, s->l1_table,\n\n                         s->l1_size * sizeof(uint64_t));\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        for(i = 0;i < s->l1_size; i++) {\n\n            be64_to_cpus(&s->l1_table[i]);\n\n        }\n\n    }\n\n\n\n    /* alloc L2 table/refcount block cache */\n\n    s->l2_table_cache = qcow2_cache_create(bs, L2_CACHE_SIZE);\n\n    s->refcount_block_cache = qcow2_cache_create(bs, REFCOUNT_CACHE_SIZE);\n\n\n\n    s->cluster_cache = g_malloc(s->cluster_size);\n\n    /* one more sector for decompressed data alignment */\n\n    s->cluster_data = qemu_blockalign(bs, QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size\n\n                                  + 512);\n\n    s->cluster_cache_offset = -1;\n\n    s->flags = flags;\n\n\n\n    ret = qcow2_refcount_init(bs);\n\n    if (ret != 0) {\n\n        goto fail;\n\n    }\n\n\n\n    QLIST_INIT(&s->cluster_allocs);\n\n\n\n    /* read qcow2 extensions */\n\n    if (qcow2_read_extensions(bs, header.header_length, ext_end, NULL)) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    /* read the backing file name */\n\n    if (header.backing_file_offset != 0) {\n\n        len = header.backing_file_size;\n\n        if (len > 1023) {\n\n            len = 1023;\n\n        }\n\n        ret = bdrv_pread(bs->file, header.backing_file_offset,\n\n                         bs->backing_file, len);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        bs->backing_file[len] = '\\0';\n\n    }\n\n\n\n    ret = qcow2_read_snapshots(bs);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Clear unknown autoclear feature bits */\n\n    if (!bs->read_only && s->autoclear_features != 0) {\n\n        s->autoclear_features = 0;\n\n        ret = qcow2_update_header(bs);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* Initialise locks */\n\n    qemu_co_mutex_init(&s->lock);\n\n\n\n    /* Repair image if dirty */\n\n    if ((s->incompatible_features & QCOW2_INCOMPAT_DIRTY) &&\n\n        !bs->read_only) {\n\n        BdrvCheckResult result = {0};\n\n\n\n        ret = qcow2_check_refcounts(bs, &result, BDRV_FIX_ERRORS);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        ret = qcow2_mark_clean(bs);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n#ifdef DEBUG_ALLOC\n\n    {\n\n        BdrvCheckResult result = {0};\n\n        qcow2_check_refcounts(bs, &result, 0);\n\n    }\n\n#endif\n\n    return ret;\n\n\n\n fail:\n\n    g_free(s->unknown_header_fields);\n\n    cleanup_unknown_header_ext(bs);\n\n    qcow2_free_snapshots(bs);\n\n    qcow2_refcount_close(bs);\n\n    g_free(s->l1_table);\n\n    if (s->l2_table_cache) {\n\n        qcow2_cache_destroy(bs, s->l2_table_cache);\n\n    }\n\n    g_free(s->cluster_cache);\n\n    qemu_vfree(s->cluster_data);\n\n    return ret;\n\n}\n", "idx": 14980, "_split": "valid", "_hash": "fdec48a39ea2bb6b9e841c5ab8b3bd0e"}
{"project": "qemu", "commit_id": "82a41186941c419afde977f477f19c545b40c1c5", "target": 1, "func": "AioContext *aio_context_new(Error **errp)\n\n{\n\n    int ret;\n\n    AioContext *ctx;\n\n\n\n    ctx = (AioContext *) g_source_new(&aio_source_funcs, sizeof(AioContext));\n\n    aio_context_setup(ctx);\n\n\n\n    ret = event_notifier_init(&ctx->notifier, false);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Failed to initialize event notifier\");\n\n        goto fail;\n\n    }\n\n    g_source_set_can_recurse(&ctx->source, true);\n\n    aio_set_event_notifier(ctx, &ctx->notifier,\n\n                           false,\n\n                           (EventNotifierHandler *)\n\n                           event_notifier_dummy_cb,\n\n                           event_notifier_poll);\n\n#ifdef CONFIG_LINUX_AIO\n\n    ctx->linux_aio = NULL;\n\n#endif\n\n    ctx->thread_pool = NULL;\n\n    qemu_mutex_init(&ctx->bh_lock);\n\n    qemu_rec_mutex_init(&ctx->lock);\n\n    timerlistgroup_init(&ctx->tlg, aio_timerlist_notify, ctx);\n\n\n\n\n    ctx->poll_max_ns = 0;\n\n\n\n\n\n    return ctx;\n\nfail:\n\n    g_source_destroy(&ctx->source);\n\n    return NULL;\n\n}", "idx": 15000, "_split": "valid", "_hash": "09350e6f3d2882e7ac736970f9439c5d"}
{"project": "qemu", "commit_id": "17ec9921a7e40d47c05effcf2c254f162bd63aad", "target": 0, "func": "static void chr_event(void *opaque, int event)\n\n{\n\n    Terminal3270 *t = opaque;\n\n    CcwDevice *ccw_dev = CCW_DEVICE(t);\n\n    SubchDev *sch = ccw_dev->sch;\n\n\n\n    /* Ensure the initial status correct, always reset them. */\n\n    t->in_len = 0;\n\n    t->out_len = 0;\n\n    t->handshake_done = false;\n\n    if (t->timer_tag) {\n\n        g_source_remove(t->timer_tag);\n\n        t->timer_tag = 0;\n\n    }\n\n\n\n    switch (event) {\n\n    case CHR_EVENT_OPENED:\n\n        /*\n\n         * 3270 does handshake firstly by the negotiate options in\n\n         * char-socket.c. Once qemu receives the terminal-type of the\n\n         * client, mark handshake done and trigger everything rolling again.\n\n         */\n\n        t->timer_tag = g_timeout_add_seconds(600, send_timing_mark_cb, t);\n\n        break;\n\n    case CHR_EVENT_CLOSED:\n\n        sch->curr_status.scsw.dstat = SCSW_DSTAT_DEVICE_END;\n\n        css_conditional_io_interrupt(sch);\n\n        break;\n\n    }\n\n}\n", "idx": 15023, "_split": "valid", "_hash": "e7cfdc935ca31b6eb164508ca13feef9"}
{"project": "qemu", "commit_id": "b2c98d9d392c87c9b9e975d30f79924719d9cbbe", "target": 0, "func": "static void tgen_ext8u(TCGContext *s, TCGType type, TCGReg dest, TCGReg src)\n\n{\n\n    if (facilities & FACILITY_EXT_IMM) {\n\n        tcg_out_insn(s, RRE, LLGCR, dest, src);\n\n        return;\n\n    }\n\n\n\n    if (dest == src) {\n\n        tcg_out_movi(s, type, TCG_TMP0, 0xff);\n\n        src = TCG_TMP0;\n\n    } else {\n\n        tcg_out_movi(s, type, dest, 0xff);\n\n    }\n\n    if (type == TCG_TYPE_I32) {\n\n        tcg_out_insn(s, RR, NR, dest, src);\n\n    } else {\n\n        tcg_out_insn(s, RRE, NGR, dest, src);\n\n    }\n\n}\n", "idx": 15026, "_split": "valid", "_hash": "01930e89da369b4a12bc27cc971d6567"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static bool esp_mem_accepts(void *opaque, target_phys_addr_t addr,\n\n                            unsigned size, bool is_write)\n\n{\n\n    return (size == 1) || (is_write && size == 4);\n\n}\n", "idx": 15027, "_split": "valid", "_hash": "8f565977aadd769fe17e92aa9985a5c3"}
{"project": "qemu", "commit_id": "16b781aaef69c90d5f4f5456615f0c26a4f45740", "target": 0, "func": "SDState *sd_init(BlockBackend *blk, bool is_spi)\n\n{\n\n    SDState *sd;\n\n\n\n    if (blk && blk_is_read_only(blk)) {\n\n        fprintf(stderr, \"sd_init: Cannot use read-only drive\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    sd = (SDState *) g_malloc0(sizeof(SDState));\n\n    sd->buf = blk_blockalign(blk, 512);\n\n    sd->spi = is_spi;\n\n    sd->enable = true;\n\n    sd_reset(sd, blk);\n\n    if (sd->blk) {\n\n        blk_attach_dev_nofail(sd->blk, sd);\n\n        blk_set_dev_ops(sd->blk, &sd_block_ops, sd);\n\n    }\n\n    vmstate_register(NULL, -1, &sd_vmstate, sd);\n\n    return sd;\n\n}\n", "idx": 15041, "_split": "valid", "_hash": "ee5f21eb46ab839d51f44f97bb143776"}
{"project": "qemu", "commit_id": "49d741b5041b79214db58f364cebe2f367517711", "target": 0, "func": "static uint64_t *store_bitmap_data(BlockDriverState *bs,\n\n                                   BdrvDirtyBitmap *bitmap,\n\n                                   uint32_t *bitmap_table_size, Error **errp)\n\n{\n\n    int ret;\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t sector;\n\n    uint64_t limit, sbc;\n\n    uint64_t bm_size = bdrv_dirty_bitmap_size(bitmap);\n\n    uint64_t bm_sectors = DIV_ROUND_UP(bm_size, BDRV_SECTOR_SIZE);\n\n    const char *bm_name = bdrv_dirty_bitmap_name(bitmap);\n\n    uint8_t *buf = NULL;\n\n    BdrvDirtyBitmapIter *dbi;\n\n    uint64_t *tb;\n\n    uint64_t tb_size =\n\n            size_to_clusters(s,\n\n                bdrv_dirty_bitmap_serialization_size(bitmap, 0, bm_size));\n\n\n\n    if (tb_size > BME_MAX_TABLE_SIZE ||\n\n        tb_size * s->cluster_size > BME_MAX_PHYS_SIZE)\n\n    {\n\n        error_setg(errp, \"Bitmap '%s' is too big\", bm_name);\n\n        return NULL;\n\n    }\n\n\n\n    tb = g_try_new0(uint64_t, tb_size);\n\n    if (tb == NULL) {\n\n        error_setg(errp, \"No memory\");\n\n        return NULL;\n\n    }\n\n\n\n    dbi = bdrv_dirty_iter_new(bitmap);\n\n    buf = g_malloc(s->cluster_size);\n\n    limit = bytes_covered_by_bitmap_cluster(s, bitmap);\n\n    sbc = limit >> BDRV_SECTOR_BITS;\n\n    assert(DIV_ROUND_UP(bm_size, limit) == tb_size);\n\n\n\n    while ((sector = bdrv_dirty_iter_next(dbi) >> BDRV_SECTOR_BITS) >= 0) {\n\n        uint64_t cluster = sector / sbc;\n\n        uint64_t end, write_size;\n\n        int64_t off;\n\n\n\n        sector = cluster * sbc;\n\n        end = MIN(bm_sectors, sector + sbc);\n\n        write_size = bdrv_dirty_bitmap_serialization_size(bitmap,\n\n            sector * BDRV_SECTOR_SIZE, (end - sector) * BDRV_SECTOR_SIZE);\n\n        assert(write_size <= s->cluster_size);\n\n\n\n        off = qcow2_alloc_clusters(bs, s->cluster_size);\n\n        if (off < 0) {\n\n            error_setg_errno(errp, -off,\n\n                             \"Failed to allocate clusters for bitmap '%s'\",\n\n                             bm_name);\n\n            goto fail;\n\n        }\n\n        tb[cluster] = off;\n\n\n\n        bdrv_dirty_bitmap_serialize_part(bitmap, buf,\n\n                                         sector * BDRV_SECTOR_SIZE,\n\n                                         (end - sector) * BDRV_SECTOR_SIZE);\n\n        if (write_size < s->cluster_size) {\n\n            memset(buf + write_size, 0, s->cluster_size - write_size);\n\n        }\n\n\n\n        ret = qcow2_pre_write_overlap_check(bs, 0, off, s->cluster_size);\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"Qcow2 overlap check failed\");\n\n            goto fail;\n\n        }\n\n\n\n        ret = bdrv_pwrite(bs->file, off, buf, s->cluster_size);\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"Failed to write bitmap '%s' to file\",\n\n                             bm_name);\n\n            goto fail;\n\n        }\n\n\n\n        if (end >= bm_sectors) {\n\n            break;\n\n        }\n\n\n\n        bdrv_set_dirty_iter(dbi, end * BDRV_SECTOR_SIZE);\n\n    }\n\n\n\n    *bitmap_table_size = tb_size;\n\n    g_free(buf);\n\n    bdrv_dirty_iter_free(dbi);\n\n\n\n    return tb;\n\n\n\nfail:\n\n    clear_bitmap_table(bs, tb, tb_size);\n\n    g_free(buf);\n\n    bdrv_dirty_iter_free(dbi);\n\n    g_free(tb);\n\n\n\n    return NULL;\n\n}\n", "idx": 15059, "_split": "valid", "_hash": "2ac2796014ea0744d091c8a527608bca"}
{"project": "qemu", "commit_id": "f0d2a4d4d63dd2f0f3ecb2d591b979b0e7f24a22", "target": 0, "func": "iscsi_synccache10_cb(struct iscsi_context *iscsi, int status,\n\n                     void *command_data, void *opaque)\n\n{\n\n    IscsiAIOCB *acb = opaque;\n\n\n\n    if (acb->canceled != 0) {\n\n        return;\n\n    }\n\n\n\n    acb->status = 0;\n\n    if (status != 0) {\n\n        if (status == SCSI_STATUS_CHECK_CONDITION\n\n            && acb->task->sense.key == SCSI_SENSE_UNIT_ATTENTION\n\n            && acb->retries-- > 0) {\n\n            if (acb->task != NULL) {\n\n                scsi_free_scsi_task(acb->task);\n\n                acb->task = NULL;\n\n            }\n\n            if (iscsi_aio_flush_acb(acb) == 0) {\n\n                iscsi_set_events(acb->iscsilun);\n\n                return;\n\n            }\n\n        }\n\n        error_report(\"Failed to sync10 data on iSCSI lun. %s\",\n\n                     iscsi_get_error(iscsi));\n\n        acb->status = -EIO;\n\n    }\n\n\n\n    iscsi_schedule_bh(acb);\n\n}\n", "idx": 15069, "_split": "valid", "_hash": "1983723dddb6df19a7bbe87e91fc58b0"}
{"project": "qemu", "commit_id": "ef546f1275f6563e8934dd5e338d29d9f9909ca6", "target": 0, "func": "static void virtio_net_set_config(VirtIODevice *vdev, const uint8_t *config)\n\n{\n\n    VirtIONet *n = VIRTIO_NET(vdev);\n\n    struct virtio_net_config netcfg = {};\n\n\n\n    memcpy(&netcfg, config, n->config_size);\n\n\n\n    if (!(vdev->guest_features >> VIRTIO_NET_F_CTRL_MAC_ADDR & 1) &&\n\n        memcmp(netcfg.mac, n->mac, ETH_ALEN)) {\n\n        memcpy(n->mac, netcfg.mac, ETH_ALEN);\n\n        qemu_format_nic_info_str(qemu_get_queue(n->nic), n->mac);\n\n    }\n\n}\n", "idx": 15086, "_split": "valid", "_hash": "3a60357cf0d2fec4ad0436bcd98fbf89"}
{"project": "qemu", "commit_id": "2bfe11c8fac96db4f94abbe818fbc964a6744130", "target": 1, "func": "void trace_init_vcpu_events(void)\n\n{\n\n    TraceEvent *ev = NULL;\n\n    while ((ev = trace_event_pattern(\"*\", ev)) != NULL) {\n\n        if (trace_event_is_vcpu(ev) &&\n\n            trace_event_get_state_static(ev) &&\n\n            trace_event_get_state_dynamic(ev)) {\n\n            TraceEventID id = trace_event_get_id(ev);\n\n            /* check preconditions */\n\n            assert(trace_events_dstate[id] == 1);\n\n            /* disable early-init state ... */\n\n            trace_events_dstate[id] = 0;\n\n            trace_events_enabled_count--;\n\n            /* ... and properly re-enable */\n\n            trace_event_set_state_dynamic(ev, true);\n\n        }\n\n    }\n\n}\n", "idx": 15130, "_split": "valid", "_hash": "a57962503f51d054811196f9686c79a8"}
{"project": "qemu", "commit_id": "95b5edcd92d64c7b8fe9f2e3e0725fdf84be0dfa", "target": 0, "func": "static int scsi_disk_initfn(SCSIDevice *dev)\n\n{\n\n    SCSIDriveKind kind;\n\n\n\n    if (!dev->conf.bs) {\n\n        kind = SCSI_HD;         /* will die in scsi_initfn() */\n\n    } else {\n\n        kind = bdrv_get_type_hint(dev->conf.bs) == BDRV_TYPE_CDROM\n\n            ? SCSI_CD : SCSI_HD;\n\n    }\n\n\n\n    return scsi_initfn(dev, kind);\n\n}\n", "idx": 15172, "_split": "valid", "_hash": "c6947350027e8af151af334d14a88d76"}
{"project": "qemu", "commit_id": "fc3959e4669a1c2149b91ccb05101cfc7ae1fc05", "target": 0, "func": "static int coroutine_fn bdrv_co_do_pwritev(BlockDriverState *bs,\n\n    int64_t offset, unsigned int bytes, QEMUIOVector *qiov,\n\n    BdrvRequestFlags flags)\n\n{\n\n    BdrvTrackedRequest req;\n\n    /* TODO Lift BDRV_SECTOR_SIZE restriction in BlockDriver interface */\n\n    uint64_t align = MAX(BDRV_SECTOR_SIZE, bs->request_alignment);\n\n    uint8_t *head_buf = NULL;\n\n    uint8_t *tail_buf = NULL;\n\n    QEMUIOVector local_qiov;\n\n    bool use_local_qiov = false;\n\n    int ret;\n\n\n\n    if (!bs->drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n    if (bs->read_only) {\n\n        return -EACCES;\n\n    }\n\n\n\n    ret = bdrv_check_byte_request(bs, offset, bytes);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* throttling disk I/O */\n\n    if (bs->io_limits_enabled) {\n\n        bdrv_io_limits_intercept(bs, bytes, true);\n\n    }\n\n\n\n    /*\n\n     * Align write if necessary by performing a read-modify-write cycle.\n\n     * Pad qiov with the read parts and be sure to have a tracked request not\n\n     * only for bdrv_aligned_pwritev, but also for the reads of the RMW cycle.\n\n     */\n\n    tracked_request_begin(&req, bs, offset, bytes, true);\n\n\n\n    if (offset & (align - 1)) {\n\n        QEMUIOVector head_qiov;\n\n        struct iovec head_iov;\n\n\n\n        mark_request_serialising(&req, align);\n\n        wait_serialising_requests(&req);\n\n\n\n        head_buf = qemu_blockalign(bs, align);\n\n        head_iov = (struct iovec) {\n\n            .iov_base   = head_buf,\n\n            .iov_len    = align,\n\n        };\n\n        qemu_iovec_init_external(&head_qiov, &head_iov, 1);\n\n\n\n        BLKDBG_EVENT(bs, BLKDBG_PWRITEV_RMW_HEAD);\n\n        ret = bdrv_aligned_preadv(bs, &req, offset & ~(align - 1), align,\n\n                                  align, &head_qiov, 0);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        BLKDBG_EVENT(bs, BLKDBG_PWRITEV_RMW_AFTER_HEAD);\n\n\n\n        qemu_iovec_init(&local_qiov, qiov->niov + 2);\n\n        qemu_iovec_add(&local_qiov, head_buf, offset & (align - 1));\n\n        qemu_iovec_concat(&local_qiov, qiov, 0, qiov->size);\n\n        use_local_qiov = true;\n\n\n\n        bytes += offset & (align - 1);\n\n        offset = offset & ~(align - 1);\n\n    }\n\n\n\n    if ((offset + bytes) & (align - 1)) {\n\n        QEMUIOVector tail_qiov;\n\n        struct iovec tail_iov;\n\n        size_t tail_bytes;\n\n        bool waited;\n\n\n\n        mark_request_serialising(&req, align);\n\n        waited = wait_serialising_requests(&req);\n\n        assert(!waited || !use_local_qiov);\n\n\n\n        tail_buf = qemu_blockalign(bs, align);\n\n        tail_iov = (struct iovec) {\n\n            .iov_base   = tail_buf,\n\n            .iov_len    = align,\n\n        };\n\n        qemu_iovec_init_external(&tail_qiov, &tail_iov, 1);\n\n\n\n        BLKDBG_EVENT(bs, BLKDBG_PWRITEV_RMW_TAIL);\n\n        ret = bdrv_aligned_preadv(bs, &req, (offset + bytes) & ~(align - 1), align,\n\n                                  align, &tail_qiov, 0);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        BLKDBG_EVENT(bs, BLKDBG_PWRITEV_RMW_AFTER_TAIL);\n\n\n\n        if (!use_local_qiov) {\n\n            qemu_iovec_init(&local_qiov, qiov->niov + 1);\n\n            qemu_iovec_concat(&local_qiov, qiov, 0, qiov->size);\n\n            use_local_qiov = true;\n\n        }\n\n\n\n        tail_bytes = (offset + bytes) & (align - 1);\n\n        qemu_iovec_add(&local_qiov, tail_buf + tail_bytes, align - tail_bytes);\n\n\n\n        bytes = ROUND_UP(bytes, align);\n\n    }\n\n\n\n    ret = bdrv_aligned_pwritev(bs, &req, offset, bytes,\n\n                               use_local_qiov ? &local_qiov : qiov,\n\n                               flags);\n\n\n\nfail:\n\n    tracked_request_end(&req);\n\n\n\n    if (use_local_qiov) {\n\n        qemu_iovec_destroy(&local_qiov);\n\n    }\n\n    qemu_vfree(head_buf);\n\n    qemu_vfree(tail_buf);\n\n\n\n    return ret;\n\n}\n", "idx": 15176, "_split": "valid", "_hash": "37cef340fe9b89a5835eb7d5eb4bc1e7"}
{"project": "qemu", "commit_id": "5cd230819ec26caf199bf73d38cf2407344e4443", "target": 0, "func": "static int cloop_read(BlockDriverState *bs, int64_t sector_num,\n\n                    uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVCloopState *s = bs->opaque;\n\n    int i;\n\n\n\n    for (i = 0; i < nb_sectors; i++) {\n\n        uint32_t sector_offset_in_block =\n\n            ((sector_num + i) % s->sectors_per_block),\n\n            block_num = (sector_num + i) / s->sectors_per_block;\n\n        if (cloop_read_block(bs, block_num) != 0) {\n\n            return -1;\n\n        }\n\n        memcpy(buf + i * 512,\n\n            s->uncompressed_block + sector_offset_in_block * 512, 512);\n\n    }\n\n    return 0;\n\n}\n", "idx": 15179, "_split": "valid", "_hash": "a26b9519ffab0a23ee8e4cf712f51979"}
{"project": "qemu", "commit_id": "b6dcbe086c77ec683f5ff0b693593cda1d61f3a1", "target": 0, "func": "ram_addr_t ppc4xx_sdram_adjust(ram_addr_t ram_size, int nr_banks,\n\n                               target_phys_addr_t ram_bases[],\n\n                               target_phys_addr_t ram_sizes[],\n\n                               const unsigned int sdram_bank_sizes[])\n\n{\n\n    ram_addr_t size_left = ram_size;\n\n    int i;\n\n    int j;\n\n\n\n    for (i = 0; i < nr_banks; i++) {\n\n        for (j = 0; sdram_bank_sizes[j] != 0; j++) {\n\n            unsigned int bank_size = sdram_bank_sizes[j];\n\n\n\n            if (bank_size <= size_left) {\n\n                char name[32];\n\n                snprintf(name, sizeof(name), \"ppc4xx.sdram%d\", i);\n\n                ram_bases[i] = qemu_ram_alloc(NULL, name, bank_size);\n\n                ram_sizes[i] = bank_size;\n\n                size_left -= bank_size;\n\n                break;\n\n            }\n\n        }\n\n\n\n        if (!size_left) {\n\n            /* No need to use the remaining banks. */\n\n            break;\n\n        }\n\n    }\n\n\n\n    ram_size -= size_left;\n\n    if (size_left)\n\n        printf(\"Truncating memory to %d MiB to fit SDRAM controller limits.\\n\",\n\n               (int)(ram_size >> 20));\n\n\n\n    return ram_size;\n\n}\n", "idx": 15183, "_split": "valid", "_hash": "d7eab8c4c1441d64a1897fe6b980cbc6"}
{"project": "qemu", "commit_id": "57e49b40745ceb6c198cc58274b705afb5f20493", "target": 0, "func": "static inline int check_fit(tcg_target_long val, unsigned int bits)\n\n{\n\n    return ((val << ((sizeof(tcg_target_long) * 8 - bits))\n\n             >> (sizeof(tcg_target_long) * 8 - bits)) == val);\n\n}\n", "idx": 15187, "_split": "valid", "_hash": "acccce51b6488cec1d0d8d5b4cab2828"}
{"project": "qemu", "commit_id": "d644f8beaa268a4e36b473f283f0b5a5ff66d8c2", "target": 0, "func": "void *qemu_memalign(size_t alignment, size_t size)\n\n{\n\n    return VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);\n\n}\n", "idx": 15191, "_split": "valid", "_hash": "c404c2d73f10b11a73d444463727cf3e"}
{"project": "qemu", "commit_id": "661e32fb3cb71c7e019daee375be4bb487b9917c", "target": 1, "func": "static void virtio_scsi_handle_ctrl_req(VirtIOSCSI *s, VirtIOSCSIReq *req)\n\n{\n\n    VirtIODevice *vdev = (VirtIODevice *)s;\n\n    uint32_t type;\n\n    int r = 0;\n\n\n\n    if (iov_to_buf(req->elem.out_sg, req->elem.out_num, 0,\n\n                &type, sizeof(type)) < sizeof(type)) {\n\n        virtio_scsi_bad_req();\n\n        return;\n\n    }\n\n\n\n    virtio_tswap32s(vdev, &type);\n\n    if (type == VIRTIO_SCSI_T_TMF) {\n\n        if (virtio_scsi_parse_req(req, sizeof(VirtIOSCSICtrlTMFReq),\n\n                    sizeof(VirtIOSCSICtrlTMFResp)) < 0) {\n\n            virtio_scsi_bad_req();\n\n        } else {\n\n            r = virtio_scsi_do_tmf(s, req);\n\n        }\n\n\n\n    } else if (type == VIRTIO_SCSI_T_AN_QUERY ||\n\n               type == VIRTIO_SCSI_T_AN_SUBSCRIBE) {\n\n        if (virtio_scsi_parse_req(req, sizeof(VirtIOSCSICtrlANReq),\n\n                    sizeof(VirtIOSCSICtrlANResp)) < 0) {\n\n            virtio_scsi_bad_req();\n\n        } else {\n\n            req->resp.an.event_actual = 0;\n\n            req->resp.an.response = VIRTIO_SCSI_S_OK;\n\n        }\n\n    }\n\n    if (r == 0) {\n\n        virtio_scsi_complete_req(req);\n\n    } else {\n\n        assert(r == -EINPROGRESS);\n\n    }\n\n}\n", "idx": 15198, "_split": "valid", "_hash": "f590de8c828e5230a96654b505006ed1"}
{"project": "qemu", "commit_id": "20c334a797bf46a4ee59a6e42be6d5e7c3cda585", "target": 1, "func": "static inline uint32_t mipsdsp_sub32(int32_t a, int32_t b, CPUMIPSState *env)\n\n{\n\n    int32_t temp;\n\n\n\n    temp = a - b;\n\n    if (MIPSDSP_OVERFLOW(a, -b, temp, 0x80000000)) {\n\n        set_DSPControl_overflow_flag(1, 20, env);\n\n    }\n\n\n\n    return temp;\n\n}\n", "idx": 15204, "_split": "valid", "_hash": "a7d77bf99dd83ea7ebeb202b4c4d81ab"}
{"project": "qemu", "commit_id": "c7e35da348e2e4df072e6979c48fa5283e07d1db", "target": 1, "func": "static inline abi_long host_to_target_timespec(abi_ulong target_addr,\n\n                                               struct timespec *host_ts)\n\n{\n\n    struct target_timespec *target_ts;\n\n\n\n    if (!lock_user_struct(VERIFY_WRITE, target_ts, target_addr, 0))\n\n        return -TARGET_EFAULT;\n\n    target_ts->tv_sec = tswapal(host_ts->tv_sec);\n\n    target_ts->tv_nsec = tswapal(host_ts->tv_nsec);\n\n    unlock_user_struct(target_ts, target_addr, 1);\n\n    return 0;\n\n}\n", "idx": 15217, "_split": "valid", "_hash": "a75d326915e77ef5e2e6a6bb86235d62"}
{"project": "qemu", "commit_id": "dac23a6c05e543590508b48b8ed31d89b0c99c61", "target": 1, "func": "static bool load_asl(GArray *sdts, AcpiSdtTable *sdt)\n\n{\n\n    AcpiSdtTable *temp;\n\n    GError *error = NULL;\n\n    GString *command_line = g_string_new(iasl);\n\n    gint fd;\n\n    gchar *out, *out_err;\n\n    gboolean ret;\n\n    int i;\n\n\n\n    fd = g_file_open_tmp(\"asl-XXXXXX.dsl\", &sdt->asl_file, &error);\n\n    g_assert_no_error(error);\n\n    close(fd);\n\n\n\n    /* build command line */\n\n    g_string_append_printf(command_line, \" -p %s \", sdt->asl_file);\n\n    if (compare_signature(sdt, \"DSDT\") ||\n\n        compare_signature(sdt, \"SSDT\")) {\n\n        for (i = 0; i < sdts->len; ++i) {\n\n            temp = &g_array_index(sdts, AcpiSdtTable, i);\n\n            if (compare_signature(temp, \"DSDT\") ||\n\n                compare_signature(temp, \"SSDT\")) {\n\n                g_string_append_printf(command_line, \"-e %s \", temp->aml_file);\n\n            }\n\n        }\n\n    }\n\n    g_string_append_printf(command_line, \"-d %s\", sdt->aml_file);\n\n\n\n    /* pass 'out' and 'out_err' in order to be redirected */\n\n    ret = g_spawn_command_line_sync(command_line->str, &out, &out_err, NULL, &error);\n\n    g_assert_no_error(error);\n\n\n\n    if (ret) {\n\n        ret = g_file_get_contents(sdt->asl_file, (gchar **)&sdt->asl,\n\n                                  &sdt->asl_len, &error);\n\n        g_assert(ret);\n\n        g_assert_no_error(error);\n\n        g_assert(sdt->asl_len);\n\n    }\n\n\n\n    g_free(out);\n\n    g_free(out_err);\n\n    g_string_free(command_line, true);\n\n\n\n    return !ret;\n\n}\n", "idx": 15226, "_split": "valid", "_hash": "f151afa184af4bfc9349da42573b2dc9"}
{"project": "qemu", "commit_id": "949868633f0454715af1781c0f377413b6ab000e", "target": 1, "func": "int ppc_hash64_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr,\n\n                                int rwx, int mmu_idx)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUPPCState *env = &cpu->env;\n\n    ppc_slb_t *slb;\n\n    unsigned apshift;\n\n    hwaddr pte_offset;\n\n    ppc_hash_pte64_t pte;\n\n    int pp_prot, amr_prot, prot;\n\n    uint64_t new_pte1, dsisr;\n\n    const int need_prot[] = {PAGE_READ, PAGE_WRITE, PAGE_EXEC};\n\n    hwaddr raddr;\n\n\n\n    assert((rwx == 0) || (rwx == 1) || (rwx == 2));\n\n\n\n    /* 1. Handle real mode accesses */\n\n    if (((rwx == 2) && (msr_ir == 0)) || ((rwx != 2) && (msr_dr == 0))) {\n\n        /* Translation is off */\n\n        /* In real mode the top 4 effective address bits are ignored */\n\n        raddr = eaddr & 0x0FFFFFFFFFFFFFFFULL;\n\n        tlb_set_page(cs, eaddr & TARGET_PAGE_MASK, raddr & TARGET_PAGE_MASK,\n\n                     PAGE_READ | PAGE_WRITE | PAGE_EXEC, mmu_idx,\n\n                     TARGET_PAGE_SIZE);\n\n        return 0;\n\n    }\n\n\n\n    /* 2. Translation is on, so look up the SLB */\n\n    slb = slb_lookup(cpu, eaddr);\n\n\n\n    if (!slb) {\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISEG;\n\n            env->error_code = 0;\n\n        } else {\n\n            cs->exception_index = POWERPC_EXCP_DSEG;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n        }\n\n        return 1;\n\n    }\n\n\n\n    /* 3. Check for segment level no-execute violation */\n\n    if ((rwx == 2) && (slb->vsid & SLB_VSID_N)) {\n\n        ppc_hash64_set_isi(cs, env, 0x10000000);\n\n        return 1;\n\n    }\n\n\n\n    /* 4. Locate the PTE in the hash table */\n\n    pte_offset = ppc_hash64_htab_lookup(cpu, slb, eaddr, &pte);\n\n    if (pte_offset == -1) {\n\n        dsisr = 0x40000000;\n\n        if (rwx == 2) {\n\n            ppc_hash64_set_isi(cs, env, dsisr);\n\n        } else {\n\n            if (rwx == 1) {\n\n                dsisr |= 0x02000000;\n\n            }\n\n            ppc_hash64_set_dsi(cs, env, eaddr, dsisr);\n\n        }\n\n        return 1;\n\n    }\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n                \"found PTE at offset %08\" HWADDR_PRIx \"\\n\", pte_offset);\n\n\n\n    /* Validate page size encoding */\n\n    apshift = hpte_page_shift(slb->sps, pte.pte0, pte.pte1);\n\n    if (!apshift) {\n\n        error_report(\"Bad page size encoding in HPTE 0x%\"PRIx64\" - 0x%\"PRIx64\n\n                     \" @ 0x%\"HWADDR_PRIx, pte.pte0, pte.pte1, pte_offset);\n\n        /* Not entirely sure what the right action here, but machine\n\n         * check seems reasonable */\n\n        cs->exception_index = POWERPC_EXCP_MCHECK;\n\n        env->error_code = 0;\n\n        return 1;\n\n    }\n\n\n\n    /* 5. Check access permissions */\n\n\n\n    pp_prot = ppc_hash64_pte_prot(cpu, slb, pte);\n\n    amr_prot = ppc_hash64_amr_prot(cpu, pte);\n\n    prot = pp_prot & amr_prot;\n\n\n\n    if ((need_prot[rwx] & ~prot) != 0) {\n\n        /* Access right violation */\n\n        qemu_log_mask(CPU_LOG_MMU, \"PTE access rejected\\n\");\n\n        if (rwx == 2) {\n\n            ppc_hash64_set_isi(cs, env, 0x08000000);\n\n        } else {\n\n            dsisr = 0;\n\n            if (need_prot[rwx] & ~pp_prot) {\n\n                dsisr |= 0x08000000;\n\n            }\n\n            if (rwx == 1) {\n\n                dsisr |= 0x02000000;\n\n            }\n\n            if (need_prot[rwx] & ~amr_prot) {\n\n                dsisr |= 0x00200000;\n\n            }\n\n            ppc_hash64_set_dsi(cs, env, eaddr, dsisr);\n\n        }\n\n        return 1;\n\n    }\n\n\n\n    qemu_log_mask(CPU_LOG_MMU, \"PTE access granted !\\n\");\n\n\n\n    /* 6. Update PTE referenced and changed bits if necessary */\n\n\n\n    new_pte1 = pte.pte1 | HPTE64_R_R; /* set referenced bit */\n\n    if (rwx == 1) {\n\n        new_pte1 |= HPTE64_R_C; /* set changed (dirty) bit */\n\n    } else {\n\n        /* Treat the page as read-only for now, so that a later write\n\n         * will pass through this function again to set the C bit */\n\n        prot &= ~PAGE_WRITE;\n\n    }\n\n\n\n    if (new_pte1 != pte.pte1) {\n\n        ppc_hash64_store_hpte(cpu, pte_offset / HASH_PTE_SIZE_64,\n\n                              pte.pte0, new_pte1);\n\n    }\n\n\n\n    /* 7. Determine the real address from the PTE */\n\n\n\n    raddr = deposit64(pte.pte1 & HPTE64_R_RPN, 0, apshift, eaddr);\n\n\n\n    tlb_set_page(cs, eaddr & TARGET_PAGE_MASK, raddr & TARGET_PAGE_MASK,\n\n                 prot, mmu_idx, 1ULL << apshift);\n\n\n\n    return 0;\n\n}\n", "idx": 15227, "_split": "valid", "_hash": "b5b4ecd55a2a0b6cd9b4c49c015eee2e"}
{"project": "qemu", "commit_id": "8786db7cb96f8ce5c75c6e1e074319c9dca8d356", "target": 1, "func": "MemoryRegionSection memory_region_find(MemoryRegion *address_space,\n\n                                       target_phys_addr_t addr, uint64_t size)\n\n{\n\n    AddressSpace *as = memory_region_to_address_space(address_space);\n\n    AddrRange range = addrrange_make(int128_make64(addr),\n\n                                     int128_make64(size));\n\n    FlatRange *fr = address_space_lookup(as, range);\n\n    MemoryRegionSection ret = { .mr = NULL, .size = 0 };\n\n\n\n    if (!fr) {\n\n        return ret;\n\n    }\n\n\n\n    while (fr > as->current_map.ranges\n\n           && addrrange_intersects(fr[-1].addr, range)) {\n\n        --fr;\n\n    }\n\n\n\n    ret.mr = fr->mr;\n\n    range = addrrange_intersection(range, fr->addr);\n\n    ret.offset_within_region = fr->offset_in_region;\n\n    ret.offset_within_region += int128_get64(int128_sub(range.start,\n\n                                                        fr->addr.start));\n\n    ret.size = int128_get64(range.size);\n\n    ret.offset_within_address_space = int128_get64(range.start);\n\n    ret.readonly = fr->readonly;\n\n    return ret;\n\n}\n", "idx": 15245, "_split": "valid", "_hash": "af513286339a7d706211539feb1f46a5"}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "uint64_t qpci_io_readq(QPCIDevice *dev, void *data)\n\n{\n\n    uintptr_t addr = (uintptr_t)data;\n\n\n\n    if (addr < QPCI_PIO_LIMIT) {\n\n        return dev->bus->pio_readq(dev->bus, addr);\n\n    } else {\n\n        uint64_t val;\n\n        dev->bus->memread(dev->bus, addr, &val, sizeof(val));\n\n        return le64_to_cpu(val);\n\n    }\n\n}\n", "idx": 15264, "_split": "valid", "_hash": "0b8a760e8f1b4eb6e75d3ae70944e5fe"}
{"project": "qemu", "commit_id": "12de9a396acbc95e25c5d60ed097cc55777eaaed", "target": 1, "func": "static int get_segment (CPUState *env, mmu_ctx_t *ctx,\n\n                        target_ulong eaddr, int rw, int type)\n\n{\n\n    target_phys_addr_t sdr, hash, mask, sdr_mask;\n\n    target_ulong sr, vsid, vsid_mask, pgidx, page_mask;\n\n#if defined(TARGET_PPC64)\n\n    int attr;\n\n#endif\n\n    int ds, nx, vsid_sh, sdr_sh;\n\n    int ret, ret2;\n\n\n\n#if defined(TARGET_PPC64)\n\n    if (env->mmu_model == POWERPC_MMU_64B ||\n\n        env->mmu_model == POWERPC_MMU_64BRIDGE) {\n\n        ret = slb_lookup(env, eaddr, &vsid, &page_mask, &attr);\n\n        if (ret < 0)\n\n            return ret;\n\n        ctx->key = ((attr & 0x40) && msr_pr == 1) ||\n\n            ((attr & 0x80) && msr_pr == 0) ? 1 : 0;\n\n        ds = 0;\n\n        nx = attr & 0x20 ? 1 : 0;\n\n        vsid_mask = 0x00003FFFFFFFFF80ULL;\n\n        vsid_sh = 7;\n\n        sdr_sh = 18;\n\n        sdr_mask = 0x3FF80;\n\n    } else\n\n#endif /* defined(TARGET_PPC64) */\n\n    {\n\n        sr = env->sr[eaddr >> 28];\n\n        page_mask = 0x0FFFFFFF;\n\n        ctx->key = (((sr & 0x20000000) && msr_pr == 1) ||\n\n                    ((sr & 0x40000000) && msr_pr == 0)) ? 1 : 0;\n\n        ds = sr & 0x80000000 ? 1 : 0;\n\n        nx = sr & 0x10000000 ? 1 : 0;\n\n        vsid = sr & 0x00FFFFFF;\n\n        vsid_mask = 0x01FFFFC0;\n\n        vsid_sh = 6;\n\n        sdr_sh = 16;\n\n        sdr_mask = 0xFFC0;\n\n#if defined (DEBUG_MMU)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"Check segment v=0x\" ADDRX \" %d 0x\" ADDRX\n\n                    \" nip=0x\" ADDRX \" lr=0x\" ADDRX\n\n                    \" ir=%d dr=%d pr=%d %d t=%d\\n\",\n\n                    eaddr, (int)(eaddr >> 28), sr, env->nip,\n\n                    env->lr, msr_ir, msr_dr, msr_pr, rw, type);\n\n        }\n\n        if (!ds && loglevel != 0) {\n\n            fprintf(logfile, \"pte segment: key=%d n=0x\" ADDRX \"\\n\",\n\n                    ctx->key, sr & 0x10000000);\n\n        }\n\n#endif\n\n    }\n\n    ret = -1;\n\n    if (!ds) {\n\n        /* Check if instruction fetch is allowed, if needed */\n\n        if (type != ACCESS_CODE || nx == 0) {\n\n            /* Page address translation */\n\n            pgidx = (eaddr & page_mask) >> TARGET_PAGE_BITS;\n\n            hash = ((vsid ^ pgidx) << vsid_sh) & vsid_mask;\n\n            /* Primary table address */\n\n            sdr = env->sdr1;\n\n            mask = ((sdr & 0x000001FF) << sdr_sh) | sdr_mask;\n\n            ctx->pg_addr[0] = get_pgaddr(sdr, sdr_sh, hash, mask);\n\n            /* Secondary table address */\n\n            hash = (~hash) & vsid_mask;\n\n            ctx->pg_addr[1] = get_pgaddr(sdr, sdr_sh, hash, mask);\n\n#if defined(TARGET_PPC64)\n\n            if (env->mmu_model == POWERPC_MMU_64B ||\n\n                env->mmu_model == POWERPC_MMU_64BRIDGE) {\n\n                /* Only 5 bits of the page index are used in the AVPN */\n\n                ctx->ptem = (vsid << 12) | ((pgidx >> 4) & 0x0F80);\n\n            } else\n\n#endif\n\n            {\n\n                ctx->ptem = (vsid << 7) | (pgidx >> 10);\n\n            }\n\n            /* Initialize real address with an invalid value */\n\n            ctx->raddr = (target_ulong)-1;\n\n            if (unlikely(env->mmu_model == POWERPC_MMU_SOFT_6xx ||\n\n                         env->mmu_model == POWERPC_MMU_SOFT_74xx)) {\n\n                /* Software TLB search */\n\n                ret = ppc6xx_tlb_check(env, ctx, eaddr, rw, type);\n\n            } else {\n\n#if defined (DEBUG_MMU)\n\n                if (loglevel != 0) {\n\n                    fprintf(logfile, \"0 sdr1=0x\" PADDRX \" vsid=0x%06x \"\n\n                            \"api=0x%04x hash=0x%07x pg_addr=0x\" PADDRX \"\\n\",\n\n                            sdr, (uint32_t)vsid, (uint32_t)pgidx,\n\n                            (uint32_t)hash, ctx->pg_addr[0]);\n\n                }\n\n#endif\n\n                /* Primary table lookup */\n\n                ret = find_pte(env, ctx, 0, rw);\n\n                if (ret < 0) {\n\n                    /* Secondary table lookup */\n\n#if defined (DEBUG_MMU)\n\n                    if (eaddr != 0xEFFFFFFF && loglevel != 0) {\n\n                        fprintf(logfile,\n\n                                \"1 sdr1=0x\" PADDRX \" vsid=0x%06x api=0x%04x \"\n\n                                \"hash=0x%05x pg_addr=0x\" PADDRX \"\\n\",\n\n                                sdr, (uint32_t)vsid, (uint32_t)pgidx,\n\n                                (uint32_t)hash, ctx->pg_addr[1]);\n\n                    }\n\n#endif\n\n                    ret2 = find_pte(env, ctx, 1, rw);\n\n                    if (ret2 != -1)\n\n                        ret = ret2;\n\n                }\n\n            }\n\n        } else {\n\n#if defined (DEBUG_MMU)\n\n            if (loglevel != 0)\n\n                fprintf(logfile, \"No access allowed\\n\");\n\n#endif\n\n            ret = -3;\n\n        }\n\n    } else {\n\n#if defined (DEBUG_MMU)\n\n        if (loglevel != 0)\n\n            fprintf(logfile, \"direct store...\\n\");\n\n#endif\n\n        /* Direct-store segment : absolutely *BUGGY* for now */\n\n        switch (type) {\n\n        case ACCESS_INT:\n\n            /* Integer load/store : only access allowed */\n\n            break;\n\n        case ACCESS_CODE:\n\n            /* No code fetch is allowed in direct-store areas */\n\n            return -4;\n\n        case ACCESS_FLOAT:\n\n            /* Floating point load/store */\n\n            return -4;\n\n        case ACCESS_RES:\n\n            /* lwarx, ldarx or srwcx. */\n\n            return -4;\n\n        case ACCESS_CACHE:\n\n            /* dcba, dcbt, dcbtst, dcbf, dcbi, dcbst, dcbz, or icbi */\n\n            /* Should make the instruction do no-op.\n\n             * As it already do no-op, it's quite easy :-)\n\n             */\n\n            ctx->raddr = eaddr;\n\n            return 0;\n\n        case ACCESS_EXT:\n\n            /* eciwx or ecowx */\n\n            return -4;\n\n        default:\n\n            if (logfile) {\n\n                fprintf(logfile, \"ERROR: instruction should not need \"\n\n                        \"address translation\\n\");\n\n            }\n\n            return -4;\n\n        }\n\n        if ((rw == 1 || ctx->key != 1) && (rw == 0 || ctx->key != 0)) {\n\n            ctx->raddr = eaddr;\n\n            ret = 2;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 15311, "_split": "valid", "_hash": "d4927f0fb3f22718feba6b632310fb35"}
{"project": "qemu", "commit_id": "6c1fef6b59563cc415f21e03f81539ed4b33ad90", "target": 1, "func": "static void handle_satn_stop(ESPState *s)\n\n{\n\n    if (s->dma && !s->dma_enabled) {\n\n        s->dma_cb = handle_satn_stop;\n\n        return;\n\n    }\n\n    s->cmdlen = get_cmd(s, s->cmdbuf);\n\n    if (s->cmdlen) {\n\n        trace_esp_handle_satn_stop(s->cmdlen);\n\n        s->do_cmd = 1;\n\n        s->rregs[ESP_RSTAT] = STAT_TC | STAT_CD;\n\n        s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n\n        esp_raise_irq(s);\n\n    }\n\n}\n", "idx": 15312, "_split": "valid", "_hash": "71e8c98cd024de2b8f5f592795e18aeb"}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "static void vt82c686b_write_config(PCIDevice * d, uint32_t address,\n\n                                   uint32_t val, int len)\n\n{\n\n    VT82C686BState *vt686 = DO_UPCAST(VT82C686BState, dev, d);\n\n\n\n    DPRINTF(\"vt82c686b_write_config  address 0x%x  val 0x%x len 0x%x \\n\",\n\n           address, val, len);\n\n\n\n    pci_default_write_config(d, address, val, len);\n\n    if (address == 0x85) {  /* enable or disable super IO configure */\n\n        if (val & 0x2) {\n\n            /* floppy also uses 0x3f0 and 0x3f1.\n\n             * But we do not emulate flopy,so just set it here. */\n\n            isa_unassign_ioport(0x3f0, 2);\n\n            register_ioport_read(0x3f0, 2, 1, superio_ioport_readb,\n\n                                 &vt686->superio_conf);\n\n            register_ioport_write(0x3f0, 2, 1, superio_ioport_writeb,\n\n                                  &vt686->superio_conf);\n\n        } else {\n\n            isa_unassign_ioport(0x3f0, 2);\n\n        }\n\n    }\n\n}\n", "idx": 15337, "_split": "valid", "_hash": "9be02bee6ee02a1efe00b37513cb67ac"}
{"project": "qemu", "commit_id": "b0b900070c7cb29bbefb732ec00397abe5de6d73", "target": 0, "func": "e1000_receive(VLANClientState *nc, const uint8_t *buf, size_t size)\n\n{\n\n    E1000State *s = DO_UPCAST(NICState, nc, nc)->opaque;\n\n    struct e1000_rx_desc desc;\n\n    target_phys_addr_t base;\n\n    unsigned int n, rdt;\n\n    uint32_t rdh_start;\n\n    uint16_t vlan_special = 0;\n\n    uint8_t vlan_status = 0, vlan_offset = 0;\n\n\n\n    if (!(s->mac_reg[RCTL] & E1000_RCTL_EN))\n\n        return -1;\n\n\n\n    if (size > s->rxbuf_size) {\n\n        DBGOUT(RX, \"packet too large for buffers (%lu > %d)\\n\",\n\n               (unsigned long)size, s->rxbuf_size);\n\n        return -1;\n\n    }\n\n\n\n    if (!receive_filter(s, buf, size))\n\n        return size;\n\n\n\n    if (vlan_enabled(s) && is_vlan_packet(s, buf)) {\n\n        vlan_special = cpu_to_le16(be16_to_cpup((uint16_t *)(buf + 14)));\n\n        memmove((uint8_t *)buf + 4, buf, 12);\n\n        vlan_status = E1000_RXD_STAT_VP;\n\n        vlan_offset = 4;\n\n        size -= 4;\n\n    }\n\n\n\n    rdh_start = s->mac_reg[RDH];\n\n    size += 4; // for the header\n\n    do {\n\n        if (s->mac_reg[RDH] == s->mac_reg[RDT] && s->check_rxov) {\n\n            set_ics(s, 0, E1000_ICS_RXO);\n\n            return -1;\n\n        }\n\n        base = ((uint64_t)s->mac_reg[RDBAH] << 32) + s->mac_reg[RDBAL] +\n\n               sizeof(desc) * s->mac_reg[RDH];\n\n        cpu_physical_memory_read(base, (void *)&desc, sizeof(desc));\n\n        desc.special = vlan_special;\n\n        desc.status |= (vlan_status | E1000_RXD_STAT_DD);\n\n        if (desc.buffer_addr) {\n\n            cpu_physical_memory_write(le64_to_cpu(desc.buffer_addr),\n\n                                      (void *)(buf + vlan_offset), size);\n\n            desc.length = cpu_to_le16(size);\n\n            desc.status |= E1000_RXD_STAT_EOP|E1000_RXD_STAT_IXSM;\n\n        } else // as per intel docs; skip descriptors with null buf addr\n\n            DBGOUT(RX, \"Null RX descriptor!!\\n\");\n\n        cpu_physical_memory_write(base, (void *)&desc, sizeof(desc));\n\n\n\n        if (++s->mac_reg[RDH] * sizeof(desc) >= s->mac_reg[RDLEN])\n\n            s->mac_reg[RDH] = 0;\n\n        s->check_rxov = 1;\n\n        /* see comment in start_xmit; same here */\n\n        if (s->mac_reg[RDH] == rdh_start) {\n\n            DBGOUT(RXERR, \"RDH wraparound @%x, RDT %x, RDLEN %x\\n\",\n\n                   rdh_start, s->mac_reg[RDT], s->mac_reg[RDLEN]);\n\n            set_ics(s, 0, E1000_ICS_RXO);\n\n            return -1;\n\n        }\n\n    } while (desc.buffer_addr == 0);\n\n\n\n    s->mac_reg[GPRC]++;\n\n    s->mac_reg[TPR]++;\n\n    n = s->mac_reg[TORL];\n\n    if ((s->mac_reg[TORL] += size) < n)\n\n        s->mac_reg[TORH]++;\n\n\n\n    n = E1000_ICS_RXT0;\n\n    if ((rdt = s->mac_reg[RDT]) < s->mac_reg[RDH])\n\n        rdt += s->mac_reg[RDLEN] / sizeof(desc);\n\n    if (((rdt - s->mac_reg[RDH]) * sizeof(desc)) <= s->mac_reg[RDLEN] >>\n\n        s->rxbuf_min_shift)\n\n        n |= E1000_ICS_RXDMT0;\n\n\n\n    set_ics(s, 0, n);\n\n\n\n    return size;\n\n}\n", "idx": 15356, "_split": "valid", "_hash": "ce2f905b728c3bb55217a2281cd958f6"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void stl_le_phys(target_phys_addr_t addr, uint32_t val)\n\n{\n\n    stl_phys_internal(addr, val, DEVICE_LITTLE_ENDIAN);\n\n}\n", "idx": 15358, "_split": "valid", "_hash": "5b772006e374ed2f885a8b832e6e5e8b"}
{"project": "qemu", "commit_id": "31ce5e0c49821d92fb30cce2f3055ef33613b287", "target": 1, "func": "static void kvm_mce_broadcast_rest(CPUState *env)\n\n{\n\n    CPUState *cenv;\n\n    int family, model, cpuver = env->cpuid_version;\n\n\n\n    family = (cpuver >> 8) & 0xf;\n\n    model = ((cpuver >> 12) & 0xf0) + ((cpuver >> 4) & 0xf);\n\n\n\n    /* Broadcast MCA signal for processor version 06H_EH and above */\n\n    if ((family == 6 && model >= 14) || family > 6) {\n\n        for (cenv = first_cpu; cenv != NULL; cenv = cenv->next_cpu) {\n\n            if (cenv == env) {\n\n                continue;\n\n            }\n\n            kvm_inject_x86_mce(cenv, 1, MCI_STATUS_VAL | MCI_STATUS_UC,\n\n                               MCG_STATUS_MCIP | MCG_STATUS_RIPV, 0, 0, 1);\n\n        }\n\n    }\n\n}\n", "idx": 15397, "_split": "valid", "_hash": "60b3e8573ab413851bf04eccc6c1cde0"}
{"project": "qemu", "commit_id": "9db1c0f7a94c6382e2b3e1365566a9a8b8ae74c1", "target": 0, "func": "void bdrv_guess_geometry(BlockDriverState *bs, int *pcyls, int *pheads, int *psecs)\n\n{\n\n    int translation, lba_detected = 0;\n\n    int cylinders, heads, secs;\n\n    uint64_t nb_sectors;\n\n\n\n    /* if a geometry hint is available, use it */\n\n    bdrv_get_geometry(bs, &nb_sectors);\n\n    bdrv_get_geometry_hint(bs, &cylinders, &heads, &secs);\n\n    translation = bdrv_get_translation_hint(bs);\n\n    if (cylinders != 0) {\n\n        *pcyls = cylinders;\n\n        *pheads = heads;\n\n        *psecs = secs;\n\n    } else {\n\n        if (guess_disk_lchs(bs, &cylinders, &heads, &secs) == 0) {\n\n            if (heads > 16) {\n\n                /* if heads > 16, it means that a BIOS LBA\n\n                   translation was active, so the default\n\n                   hardware geometry is OK */\n\n                lba_detected = 1;\n\n                goto default_geometry;\n\n            } else {\n\n                *pcyls = cylinders;\n\n                *pheads = heads;\n\n                *psecs = secs;\n\n                /* disable any translation to be in sync with\n\n                   the logical geometry */\n\n                if (translation == BIOS_ATA_TRANSLATION_AUTO) {\n\n                    bdrv_set_translation_hint(bs,\n\n                                              BIOS_ATA_TRANSLATION_NONE);\n\n                }\n\n            }\n\n        } else {\n\n        default_geometry:\n\n            /* if no geometry, use a standard physical disk geometry */\n\n            cylinders = nb_sectors / (16 * 63);\n\n\n\n            if (cylinders > 16383)\n\n                cylinders = 16383;\n\n            else if (cylinders < 2)\n\n                cylinders = 2;\n\n            *pcyls = cylinders;\n\n            *pheads = 16;\n\n            *psecs = 63;\n\n            if ((lba_detected == 1) && (translation == BIOS_ATA_TRANSLATION_AUTO)) {\n\n                if ((*pcyls * *pheads) <= 131072) {\n\n                    bdrv_set_translation_hint(bs,\n\n                                              BIOS_ATA_TRANSLATION_LARGE);\n\n                } else {\n\n                    bdrv_set_translation_hint(bs,\n\n                                              BIOS_ATA_TRANSLATION_LBA);\n\n                }\n\n            }\n\n        }\n\n        bdrv_set_geometry_hint(bs, *pcyls, *pheads, *psecs);\n\n    }\n\n}\n", "idx": 15421, "_split": "valid", "_hash": "18f77778138d80468ed6193f97d91b60"}
{"project": "qemu", "commit_id": "7b595f35d89d73bc69c35bf3980a89c420e8a44b", "target": 0, "func": "static void glib_pollfds_fill(uint32_t *cur_timeout)\n\n{\n\n    GMainContext *context = g_main_context_default();\n\n    int timeout = 0;\n\n    int n;\n\n\n\n    g_main_context_prepare(context, &max_priority);\n\n\n\n    glib_pollfds_idx = gpollfds->len;\n\n    n = glib_n_poll_fds;\n\n    do {\n\n        GPollFD *pfds;\n\n        glib_n_poll_fds = n;\n\n        g_array_set_size(gpollfds, glib_pollfds_idx + glib_n_poll_fds);\n\n        pfds = &g_array_index(gpollfds, GPollFD, glib_pollfds_idx);\n\n        n = g_main_context_query(context, max_priority, &timeout, pfds,\n\n                                 glib_n_poll_fds);\n\n    } while (n != glib_n_poll_fds);\n\n\n\n    if (timeout >= 0 && timeout < *cur_timeout) {\n\n        *cur_timeout = timeout;\n\n    }\n\n}\n", "idx": 15445, "_split": "valid", "_hash": "19fe278adf4536e1f86ecfcf9e3e8a12"}
{"project": "qemu", "commit_id": "1c275925bfbbc2de84a8f0e09d1dd70bbefb6da3", "target": 0, "func": "long do_sigreturn(CPUMBState *env)\n\n{\n\n    struct target_signal_frame *frame;\n\n    abi_ulong frame_addr;\n\n    target_sigset_t target_set;\n\n    sigset_t set;\n\n    int i;\n\n\n\n    frame_addr = env->regs[R_SP];\n\n    /* Make sure the guest isn't playing games.  */\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))\n\n        goto badframe;\n\n\n\n    /* Restore blocked signals */\n\n    if (__get_user(target_set.sig[0], &frame->uc.tuc_mcontext.oldmask))\n\n        goto badframe;\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))\n\n            goto badframe;\n\n    }\n\n    target_to_host_sigset_internal(&set, &target_set);\n\n    sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n    restore_sigcontext(&frame->uc.tuc_mcontext, env);\n\n    /* We got here through a sigreturn syscall, our path back is via an\n\n       rtb insn so setup r14 for that.  */\n\n    env->regs[14] = env->sregs[SR_PC];\n\n \n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return env->regs[10];\n\n  badframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 15458, "_split": "valid", "_hash": "b6c67734a8911df713e1258a2f81d7ab"}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static void scsi_device_destroy(SCSIDevice *s)\n\n{\n\n    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);\n\n    if (sc->destroy) {\n\n        sc->destroy(s);\n\n    }\n\n}\n", "idx": 15472, "_split": "valid", "_hash": "179547161295fd14349a594c9915eb6e"}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "void net_tx_pkt_setup_vlan_header(struct NetTxPkt *pkt, uint16_t vlan)\n\n{\n\n    bool is_new;\n\n    assert(pkt);\n\n\n\n    eth_setup_vlan_headers(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,\n\n        vlan, &is_new);\n\n\n\n    /* update l2hdrlen */\n\n    if (is_new) {\n\n        pkt->hdr_len += sizeof(struct vlan_header);\n\n        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len +=\n\n            sizeof(struct vlan_header);\n\n    }\n\n}\n", "idx": 15489, "_split": "valid", "_hash": "daa0d09ddeaeeb0cc99f008e9207e1fb"}
{"project": "qemu", "commit_id": "4c3b22459d3589cf84d1ccadc6b09e586497820d", "target": 1, "func": "int pcnet_common_init(DeviceState *dev, PCNetState *s, NetClientInfo *info)\n\n{\n\n    int i;\n\n    uint16_t checksum;\n\n\n\n    s->poll_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, pcnet_poll_timer, s);\n\n\n\n    qemu_macaddr_default_if_unset(&s->conf.macaddr);\n\n    s->nic = qemu_new_nic(info, &s->conf, object_get_typename(OBJECT(dev)), dev->id, s);\n\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n\n\n\n    /* Initialize the PROM */\n\n\n\n    /*\n\n      Datasheet: http://pdfdata.datasheetsite.com/web/24528/AM79C970A.pdf\n\n      page 95\n\n    */\n\n    memcpy(s->prom, s->conf.macaddr.a, 6);\n\n    /* Reserved Location: must be 00h */\n\n    s->prom[6] = s->prom[7] = 0x00;\n\n    /* Reserved Location: must be 00h */\n\n    s->prom[8] = 0x00;\n\n    /* Hardware ID: must be 11h if compatibility to AMD drivers is desired */\n\n    s->prom[9] = 0x11;\n\n    /* User programmable space, init with 0 */\n\n    s->prom[10] = s->prom[11] = 0x00;\n\n    /* LSByte of two-byte checksum, which is the sum of bytes 00h-0Bh\n\n       and bytes 0Eh and 0Fh, must therefore be initialized with 0! */\n\n    s->prom[12] = s->prom[13] = 0x00;\n\n    /* Must be ASCII W (57h) if compatibility to AMD\n\n       driver software is desired */\n\n    s->prom[14] = s->prom[15] = 0x57;\n\n\n\n    for (i = 0, checksum = 0; i < 16; i++) {\n\n        checksum += s->prom[i];\n\n    }\n\n    *(uint16_t *)&s->prom[12] = cpu_to_le16(checksum);\n\n\n\n    s->lnkst = 0x40; /* initial link state: up */\n\n\n\n    return 0;\n\n}\n", "idx": 15499, "_split": "valid", "_hash": "a108be23a6b55f719712a5c1d26dd589"}
{"project": "qemu", "commit_id": "b0e90181e4d7244a9466447703acdb2cdd7abdaa", "target": 1, "func": "static int query_memdev(Object *obj, void *opaque)\n\n{\n\n    MemdevList **list = opaque;\n\n    Error *err = NULL;\n\n\n\n    if (object_dynamic_cast(obj, TYPE_MEMORY_BACKEND)) {\n\n        MemdevList *m = g_malloc0(sizeof(*m));\n\n\n\n        m->value = g_malloc0(sizeof(*m->value));\n\n\n\n        m->value->size = object_property_get_int(obj, \"size\",\n\n                                                 &err);\n\n        if (err) {\n\n            goto error;\n\n        }\n\n\n\n        m->value->merge = object_property_get_bool(obj, \"merge\",\n\n                                                   &err);\n\n        if (err) {\n\n            goto error;\n\n        }\n\n\n\n        m->value->dump = object_property_get_bool(obj, \"dump\",\n\n                                                  &err);\n\n        if (err) {\n\n            goto error;\n\n        }\n\n\n\n        m->value->prealloc = object_property_get_bool(obj,\n\n                                                      \"prealloc\", &err);\n\n        if (err) {\n\n            goto error;\n\n        }\n\n\n\n        m->value->policy = object_property_get_enum(obj,\n\n                                                    \"policy\",\n\n                                                    HostMemPolicy_lookup,\n\n                                                    &err);\n\n        if (err) {\n\n            goto error;\n\n        }\n\n\n\n        object_property_get_uint16List(obj, \"host-nodes\",\n\n                                       &m->value->host_nodes, &err);\n\n        if (err) {\n\n            goto error;\n\n        }\n\n\n\n        m->next = *list;\n\n        *list = m;\n\n    }\n\n\n\n    return 0;\n\nerror:\n\n    return -1;\n\n}\n", "idx": 15501, "_split": "valid", "_hash": "077f6ab094abb2a4ab5cb997e9e6d0ca"}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fres(CPUPPCState *env, uint64_t arg)\n\n{\n\n    CPU_DoubleU farg;\n\n    float32 f32;\n\n\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN reciprocal */\n\n        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n    }\n\n    farg.d = float64_div(float64_one, farg.d, &env->fp_status);\n\n    f32 = float64_to_float32(farg.d, &env->fp_status);\n\n    farg.d = float32_to_float64(f32, &env->fp_status);\n\n\n\n    return farg.ll;\n\n}\n", "idx": 15523, "_split": "valid", "_hash": "b3b4fe37e21743c27be2de94fad97f99"}
{"project": "qemu", "commit_id": "3d0be8a5c135dadcfbd68ed354007a8cece98849", "target": 0, "func": "void HELPER(wsr_lend)(uint32_t v)\n\n{\n\n    if (env->sregs[LEND] != v) {\n\n        tb_invalidate_phys_page_range(\n\n                env->sregs[LEND] - 1, env->sregs[LEND], 0);\n\n        env->sregs[LEND] = v;\n\n        tb_invalidate_phys_page_range(\n\n                env->sregs[LEND] - 1, env->sregs[LEND], 0);\n\n    }\n\n}\n", "idx": 15526, "_split": "valid", "_hash": "abfe476cb8407ec049ebeb0fc5e07833"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static int aio_epoll(AioContext *ctx, GPollFD *pfds,\n\n                     unsigned npfd, int64_t timeout)\n\n{\n\n    assert(false);\n\n}\n", "idx": 15550, "_split": "valid", "_hash": "7d8e7e87e925e995db90115539bc0cfc"}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int onenand_initfn(SysBusDevice *sbd)\n\n{\n\n    DeviceState *dev = DEVICE(sbd);\n\n    OneNANDState *s = ONE_NAND(dev);\n\n    uint32_t size = 1 << (24 + ((s->id.dev >> 4) & 7));\n\n    void *ram;\n\n\n\n    s->base = (hwaddr)-1;\n\n    s->rdy = NULL;\n\n    s->blocks = size >> BLOCK_SHIFT;\n\n    s->secs = size >> 9;\n\n    s->blockwp = g_malloc(s->blocks);\n\n    s->density_mask = (s->id.dev & 0x08)\n\n        ? (1 << (6 + ((s->id.dev >> 4) & 7))) : 0;\n\n    memory_region_init_io(&s->iomem, OBJECT(s), &onenand_ops, s, \"onenand\",\n\n                          0x10000 << s->shift);\n\n    if (!s->blk) {\n\n        s->image = memset(g_malloc(size + (size >> 5)),\n\n                          0xff, size + (size >> 5));\n\n    } else {\n\n        if (blk_is_read_only(s->blk)) {\n\n            error_report(\"Can't use a read-only drive\");\n\n            return -1;\n\n        }\n\n        s->blk_cur = s->blk;\n\n    }\n\n    s->otp = memset(g_malloc((64 + 2) << PAGE_SHIFT),\n\n                    0xff, (64 + 2) << PAGE_SHIFT);\n\n    memory_region_init_ram(&s->ram, OBJECT(s), \"onenand.ram\",\n\n                           0xc000 << s->shift, &error_abort);\n\n    vmstate_register_ram_global(&s->ram);\n\n    ram = memory_region_get_ram_ptr(&s->ram);\n\n    s->boot[0] = ram + (0x0000 << s->shift);\n\n    s->boot[1] = ram + (0x8000 << s->shift);\n\n    s->data[0][0] = ram + ((0x0200 + (0 << (PAGE_SHIFT - 1))) << s->shift);\n\n    s->data[0][1] = ram + ((0x8010 + (0 << (PAGE_SHIFT - 6))) << s->shift);\n\n    s->data[1][0] = ram + ((0x0200 + (1 << (PAGE_SHIFT - 1))) << s->shift);\n\n    s->data[1][1] = ram + ((0x8010 + (1 << (PAGE_SHIFT - 6))) << s->shift);\n\n    onenand_mem_setup(s);\n\n    sysbus_init_irq(sbd, &s->intr);\n\n    sysbus_init_mmio(sbd, &s->container);\n\n    vmstate_register(dev,\n\n                     ((s->shift & 0x7f) << 24)\n\n                     | ((s->id.man & 0xff) << 16)\n\n                     | ((s->id.dev & 0xff) << 8)\n\n                     | (s->id.ver & 0xff),\n\n                     &vmstate_onenand, s);\n\n    return 0;\n\n}\n", "idx": 15583, "_split": "valid", "_hash": "b60e7bdc8f063be713e1613262fcd923"}
{"project": "qemu", "commit_id": "413bfb7cfc4e7f886ad35d610056ad8da8deab8a", "target": 0, "func": "static void sdl_resize(DisplayState *ds)\n\n{\n\n    int flags;\n\n\n\n    //    printf(\"resizing to %d %d\\n\", w, h);\n\n\n\n    flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;\n\n    if (gui_fullscreen)\n\n        flags |= SDL_FULLSCREEN;\n\n    if (gui_noframe)\n\n        flags |= SDL_NOFRAME;\n\n\n\n again:\n\n    real_screen = SDL_SetVideoMode(ds_get_width(ds), ds_get_height(ds), 0, flags);\n\n    if (!real_screen) {\n\n        fprintf(stderr, \"Could not open SDL display\\n\");\n\n        exit(1);\n\n    }\n\n    if (!real_screen->pixels && (flags & SDL_HWSURFACE) && (flags & SDL_FULLSCREEN)) {\n\n        flags &= ~SDL_HWSURFACE;\n\n        goto again;\n\n    }\n\n\n\n    if (!real_screen->pixels) {\n\n        fprintf(stderr, \"Could not open SDL display\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    sdl_setdata(ds);\n\n}\n", "idx": 15612, "_split": "valid", "_hash": "f5665a155a4b97286d36b77cbe8d63c0"}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_subfeo (void)\n\n{\n\n    T2 = T0;\n\n    T0 = T1 + ~T0 + xer_ca;\n\n    if (likely(!((~T2 ^ T1 ^ (-1)) & (~T2 ^ T0) & (1 << 31)))) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n    }\n\n    if (likely(T0 >= T1 && (xer_ca == 0 || T0 != T1))) {\n\n        xer_ca = 0;\n\n    } else {\n\n        xer_ca = 1;\n\n    }\n\n}\n", "idx": 15622, "_split": "valid", "_hash": "115e56e65e3577b771aeadcfa93d45fb"}
{"project": "qemu", "commit_id": "acc4af3fec335bb0778456f72bfb2c3591c11da4", "target": 0, "func": "static bool object_is_type(Object *obj, const char *typename)\n\n{\n\n    TypeImpl *target_type = type_get_by_name(typename);\n\n    TypeImpl *type = obj->class->type;\n\n    GSList *i;\n\n\n\n    /* Check if typename is a direct ancestor of type */\n\n    while (type) {\n\n        if (type == target_type) {\n\n            return true;\n\n        }\n\n\n\n        type = type_get_parent(type);\n\n    }\n\n\n\n    /* Check if obj has an interface of typename */\n\n    for (i = obj->interfaces; i; i = i->next) {\n\n        Interface *iface = i->data;\n\n\n\n        if (object_is_type(OBJECT(iface), typename)) {\n\n            return true;\n\n        }\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 15628, "_split": "valid", "_hash": "d7b4c01296c6f78ce1b300c31944165d"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t dchip_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    /* Skip this.  It's all related to DRAM timing and setup.  */\n\n    return 0;\n\n}\n", "idx": 15660, "_split": "valid", "_hash": "1eda3e3fd94c95c7bea440a4f2f65a21"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_prcm_write(void *opaque, target_phys_addr_t addr,\n\n                            uint64_t value, unsigned size)\n\n{\n\n    struct omap_prcm_s *s = (struct omap_prcm_s *) opaque;\n\n\n\n    if (size != 4) {\n\n        return omap_badwidth_write32(opaque, addr, value);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x000:\t/* PRCM_REVISION */\n\n    case 0x054:\t/* PRCM_VOLTST */\n\n    case 0x084:\t/* PRCM_CLKCFG_STATUS */\n\n    case 0x1e4:\t/* PM_PWSTST_MPU */\n\n    case 0x220:\t/* CM_IDLEST1_CORE */\n\n    case 0x224:\t/* CM_IDLEST2_CORE */\n\n    case 0x22c:\t/* CM_IDLEST4_CORE */\n\n    case 0x2c8:\t/* PM_WKDEP_CORE */\n\n    case 0x2e4:\t/* PM_PWSTST_CORE */\n\n    case 0x320:\t/* CM_IDLEST_GFX */\n\n    case 0x3e4:\t/* PM_PWSTST_GFX */\n\n    case 0x420:\t/* CM_IDLEST_WKUP */\n\n    case 0x520:\t/* CM_IDLEST_CKGEN */\n\n    case 0x820:\t/* CM_IDLEST_DSP */\n\n    case 0x8e4:\t/* PM_PWSTST_DSP */\n\n        OMAP_RO_REG(addr);\n\n        return;\n\n\n\n    case 0x010:\t/* PRCM_SYSCONFIG */\n\n        s->sysconfig = value & 1;\n\n        break;\n\n\n\n    case 0x018:\t/* PRCM_IRQSTATUS_MPU */\n\n        s->irqst[0] &= ~value;\n\n        omap_prcm_int_update(s, 0);\n\n        break;\n\n    case 0x01c:\t/* PRCM_IRQENABLE_MPU */\n\n        s->irqen[0] = value & 0x3f;\n\n        omap_prcm_int_update(s, 0);\n\n        break;\n\n\n\n    case 0x050:\t/* PRCM_VOLTCTRL */\n\n        s->voltctrl = value & 0xf1c3;\n\n        break;\n\n\n\n    case 0x060:\t/* PRCM_CLKSRC_CTRL */\n\n        s->clksrc[0] = value & 0xdb;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x070:\t/* PRCM_CLKOUT_CTRL */\n\n        s->clkout[0] = value & 0xbbbb;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x078:\t/* PRCM_CLKEMUL_CTRL */\n\n        s->clkemul[0] = value & 1;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x080:\t/* PRCM_CLKCFG_CTRL */\n\n        break;\n\n\n\n    case 0x090:\t/* PRCM_VOLTSETUP */\n\n        s->setuptime[0] = value & 0xffff;\n\n        break;\n\n    case 0x094:\t/* PRCM_CLKSSETUP */\n\n        s->setuptime[1] = value & 0xffff;\n\n        break;\n\n\n\n    case 0x098:\t/* PRCM_POLCTRL */\n\n        s->clkpol[0] = value & 0x701;\n\n        break;\n\n\n\n    case 0x0b0:\t/* GENERAL_PURPOSE1 */\n\n    case 0x0b4:\t/* GENERAL_PURPOSE2 */\n\n    case 0x0b8:\t/* GENERAL_PURPOSE3 */\n\n    case 0x0bc:\t/* GENERAL_PURPOSE4 */\n\n    case 0x0c0:\t/* GENERAL_PURPOSE5 */\n\n    case 0x0c4:\t/* GENERAL_PURPOSE6 */\n\n    case 0x0c8:\t/* GENERAL_PURPOSE7 */\n\n    case 0x0cc:\t/* GENERAL_PURPOSE8 */\n\n    case 0x0d0:\t/* GENERAL_PURPOSE9 */\n\n    case 0x0d4:\t/* GENERAL_PURPOSE10 */\n\n    case 0x0d8:\t/* GENERAL_PURPOSE11 */\n\n    case 0x0dc:\t/* GENERAL_PURPOSE12 */\n\n    case 0x0e0:\t/* GENERAL_PURPOSE13 */\n\n    case 0x0e4:\t/* GENERAL_PURPOSE14 */\n\n    case 0x0e8:\t/* GENERAL_PURPOSE15 */\n\n    case 0x0ec:\t/* GENERAL_PURPOSE16 */\n\n    case 0x0f0:\t/* GENERAL_PURPOSE17 */\n\n    case 0x0f4:\t/* GENERAL_PURPOSE18 */\n\n    case 0x0f8:\t/* GENERAL_PURPOSE19 */\n\n    case 0x0fc:\t/* GENERAL_PURPOSE20 */\n\n        s->scratch[(addr - 0xb0) >> 2] = value;\n\n        break;\n\n\n\n    case 0x140:\t/* CM_CLKSEL_MPU */\n\n        s->clksel[0] = value & 0x1f;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x148:\t/* CM_CLKSTCTRL_MPU */\n\n        s->clkctrl[0] = value & 0x1f;\n\n        break;\n\n\n\n    case 0x158:\t/* RM_RSTST_MPU */\n\n        s->rst[0] &= ~value;\n\n        break;\n\n    case 0x1c8:\t/* PM_WKDEP_MPU */\n\n        s->wkup[0] = value & 0x15;\n\n        break;\n\n\n\n    case 0x1d4:\t/* PM_EVGENCTRL_MPU */\n\n        s->ev = value & 0x1f;\n\n        break;\n\n    case 0x1d8:\t/* PM_EVEGENONTIM_MPU */\n\n        s->evtime[0] = value;\n\n        break;\n\n    case 0x1dc:\t/* PM_EVEGENOFFTIM_MPU */\n\n        s->evtime[1] = value;\n\n        break;\n\n\n\n    case 0x1e0:\t/* PM_PWSTCTRL_MPU */\n\n        s->power[0] = value & 0xc0f;\n\n        break;\n\n\n\n    case 0x200:\t/* CM_FCLKEN1_CORE */\n\n        s->clken[0] = value & 0xbfffffff;\n\n        /* TODO update clocks */\n\n        /* The EN_EAC bit only gets/puts func_96m_clk.  */\n\n        break;\n\n    case 0x204:\t/* CM_FCLKEN2_CORE */\n\n        s->clken[1] = value & 0x00000007;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x210:\t/* CM_ICLKEN1_CORE */\n\n        s->clken[2] = value & 0xfffffff9;\n\n        /* TODO update clocks */\n\n        /* The EN_EAC bit only gets/puts core_l4_iclk.  */\n\n        break;\n\n    case 0x214:\t/* CM_ICLKEN2_CORE */\n\n        s->clken[3] = value & 0x00000007;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x21c:\t/* CM_ICLKEN4_CORE */\n\n        s->clken[4] = value & 0x0000001f;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x230:\t/* CM_AUTOIDLE1_CORE */\n\n        s->clkidle[0] = value & 0xfffffff9;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x234:\t/* CM_AUTOIDLE2_CORE */\n\n        s->clkidle[1] = value & 0x00000007;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x238:\t/* CM_AUTOIDLE3_CORE */\n\n        s->clkidle[2] = value & 0x00000007;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x23c:\t/* CM_AUTOIDLE4_CORE */\n\n        s->clkidle[3] = value & 0x0000001f;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x240:\t/* CM_CLKSEL1_CORE */\n\n        s->clksel[1] = value & 0x0fffbf7f;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x244:\t/* CM_CLKSEL2_CORE */\n\n        s->clksel[2] = value & 0x00fffffc;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x248:\t/* CM_CLKSTCTRL_CORE */\n\n        s->clkctrl[1] = value & 0x7;\n\n        break;\n\n\n\n    case 0x2a0:\t/* PM_WKEN1_CORE */\n\n        s->wken[0] = value & 0x04667ff8;\n\n        break;\n\n    case 0x2a4:\t/* PM_WKEN2_CORE */\n\n        s->wken[1] = value & 0x00000005;\n\n        break;\n\n\n\n    case 0x2b0:\t/* PM_WKST1_CORE */\n\n        s->wkst[0] &= ~value;\n\n        break;\n\n    case 0x2b4:\t/* PM_WKST2_CORE */\n\n        s->wkst[1] &= ~value;\n\n        break;\n\n\n\n    case 0x2e0:\t/* PM_PWSTCTRL_CORE */\n\n        s->power[1] = (value & 0x00fc3f) | (1 << 2);\n\n        break;\n\n\n\n    case 0x300:\t/* CM_FCLKEN_GFX */\n\n        s->clken[5] = value & 6;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x310:\t/* CM_ICLKEN_GFX */\n\n        s->clken[6] = value & 1;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x340:\t/* CM_CLKSEL_GFX */\n\n        s->clksel[3] = value & 7;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x348:\t/* CM_CLKSTCTRL_GFX */\n\n        s->clkctrl[2] = value & 1;\n\n        break;\n\n    case 0x350:\t/* RM_RSTCTRL_GFX */\n\n        s->rstctrl[0] = value & 1;\n\n        /* TODO: reset */\n\n        break;\n\n    case 0x358:\t/* RM_RSTST_GFX */\n\n        s->rst[1] &= ~value;\n\n        break;\n\n    case 0x3c8:\t/* PM_WKDEP_GFX */\n\n        s->wkup[1] = value & 0x13;\n\n        break;\n\n    case 0x3e0:\t/* PM_PWSTCTRL_GFX */\n\n        s->power[2] = (value & 0x00c0f) | (3 << 2);\n\n        break;\n\n\n\n    case 0x400:\t/* CM_FCLKEN_WKUP */\n\n        s->clken[7] = value & 0xd;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x410:\t/* CM_ICLKEN_WKUP */\n\n        s->clken[8] = value & 0x3f;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x430:\t/* CM_AUTOIDLE_WKUP */\n\n        s->clkidle[4] = value & 0x0000003f;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x440:\t/* CM_CLKSEL_WKUP */\n\n        s->clksel[4] = value & 3;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x450:\t/* RM_RSTCTRL_WKUP */\n\n        /* TODO: reset */\n\n        if (value & 2)\n\n            qemu_system_reset_request();\n\n        break;\n\n    case 0x454:\t/* RM_RSTTIME_WKUP */\n\n        s->rsttime_wkup = value & 0x1fff;\n\n        break;\n\n    case 0x458:\t/* RM_RSTST_WKUP */\n\n        s->rst[2] &= ~value;\n\n        break;\n\n    case 0x4a0:\t/* PM_WKEN_WKUP */\n\n        s->wken[2] = value & 0x00000005;\n\n        break;\n\n    case 0x4b0:\t/* PM_WKST_WKUP */\n\n        s->wkst[2] &= ~value;\n\n        break;\n\n\n\n    case 0x500:\t/* CM_CLKEN_PLL */\n\n        if (value & 0xffffff30)\n\n            fprintf(stderr, \"%s: write 0s in CM_CLKEN_PLL for \"\n\n                            \"future compatibility\\n\", __FUNCTION__);\n\n        if ((s->clken[9] ^ value) & 0xcc) {\n\n            s->clken[9] &= ~0xcc;\n\n            s->clken[9] |= value & 0xcc;\n\n            omap_prcm_apll_update(s);\n\n        }\n\n        if ((s->clken[9] ^ value) & 3) {\n\n            s->clken[9] &= ~3;\n\n            s->clken[9] |= value & 3;\n\n            omap_prcm_dpll_update(s);\n\n        }\n\n        break;\n\n    case 0x530:\t/* CM_AUTOIDLE_PLL */\n\n        s->clkidle[5] = value & 0x000000cf;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x540:\t/* CM_CLKSEL1_PLL */\n\n        if (value & 0xfc4000d7)\n\n            fprintf(stderr, \"%s: write 0s in CM_CLKSEL1_PLL for \"\n\n                            \"future compatibility\\n\", __FUNCTION__);\n\n        if ((s->clksel[5] ^ value) & 0x003fff00) {\n\n            s->clksel[5] = value & 0x03bfff28;\n\n            omap_prcm_dpll_update(s);\n\n        }\n\n        /* TODO update the other clocks */\n\n\n\n        s->clksel[5] = value & 0x03bfff28;\n\n        break;\n\n    case 0x544:\t/* CM_CLKSEL2_PLL */\n\n        if (value & ~3)\n\n            fprintf(stderr, \"%s: write 0s in CM_CLKSEL2_PLL[31:2] for \"\n\n                            \"future compatibility\\n\", __FUNCTION__);\n\n        if (s->clksel[6] != (value & 3)) {\n\n            s->clksel[6] = value & 3;\n\n            omap_prcm_dpll_update(s);\n\n        }\n\n        break;\n\n\n\n    case 0x800:\t/* CM_FCLKEN_DSP */\n\n        s->clken[10] = value & 0x501;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x810:\t/* CM_ICLKEN_DSP */\n\n        s->clken[11] = value & 0x2;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x830:\t/* CM_AUTOIDLE_DSP */\n\n        s->clkidle[6] = value & 0x2;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x840:\t/* CM_CLKSEL_DSP */\n\n        s->clksel[7] = value & 0x3fff;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x848:\t/* CM_CLKSTCTRL_DSP */\n\n        s->clkctrl[3] = value & 0x101;\n\n        break;\n\n    case 0x850:\t/* RM_RSTCTRL_DSP */\n\n        /* TODO: reset */\n\n        break;\n\n    case 0x858:\t/* RM_RSTST_DSP */\n\n        s->rst[3] &= ~value;\n\n        break;\n\n    case 0x8c8:\t/* PM_WKDEP_DSP */\n\n        s->wkup[2] = value & 0x13;\n\n        break;\n\n    case 0x8e0:\t/* PM_PWSTCTRL_DSP */\n\n        s->power[3] = (value & 0x03017) | (3 << 2);\n\n        break;\n\n\n\n    case 0x8f0:\t/* PRCM_IRQSTATUS_DSP */\n\n        s->irqst[1] &= ~value;\n\n        omap_prcm_int_update(s, 1);\n\n        break;\n\n    case 0x8f4:\t/* PRCM_IRQENABLE_DSP */\n\n        s->irqen[1] = value & 0x7;\n\n        omap_prcm_int_update(s, 1);\n\n        break;\n\n\n\n    case 0x8f8:\t/* PRCM_IRQSTATUS_IVA */\n\n        s->irqst[2] &= ~value;\n\n        omap_prcm_int_update(s, 2);\n\n        break;\n\n    case 0x8fc:\t/* PRCM_IRQENABLE_IVA */\n\n        s->irqen[2] = value & 0x7;\n\n        omap_prcm_int_update(s, 2);\n\n        break;\n\n\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n        return;\n\n    }\n\n}\n", "idx": 15661, "_split": "valid", "_hash": "849abfbf2ffcfce542023714a968346e"}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void init_proc_755 (CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_7xx(env);\n\n    gen_spr_G2_755(env);\n\n    /* Time base */\n\n    gen_tbl(env);\n\n    /* L2 cache control */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_L2CR, \"L2CR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, NULL,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_L2PMCR, \"L2PMCR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Thermal management */\n\n    gen_spr_thrm(env);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Memory management */\n\n    gen_low_BATs(env);\n\n    gen_high_BATs(env);\n\n    gen_6xx_7xx_soft_tlb(env, 64, 2);\n\n    init_excp_7x5(env);\n\n    env->dcache_line_size = 32;\n\n    env->icache_line_size = 32;\n\n    /* Allocate hardware IRQ controller */\n\n    ppc6xx_irq_init(env);\n\n}\n", "idx": 15686, "_split": "valid", "_hash": "dc7c806cedf2f81f500f739bc1e005a7"}
{"project": "qemu", "commit_id": "88b062c2036cfd05b5111147736a08ba05ea05a9", "target": 0, "func": "static int bdrv_prwv_co(BdrvChild *child, int64_t offset,\n\n                        QEMUIOVector *qiov, bool is_write,\n\n                        BdrvRequestFlags flags)\n\n{\n\n    Coroutine *co;\n\n    RwCo rwco = {\n\n        .child = child,\n\n        .offset = offset,\n\n        .qiov = qiov,\n\n        .is_write = is_write,\n\n        .ret = NOT_DONE,\n\n        .flags = flags,\n\n    };\n\n\n\n    if (qemu_in_coroutine()) {\n\n        /* Fast-path if already in coroutine context */\n\n        bdrv_rw_co_entry(&rwco);\n\n    } else {\n\n        AioContext *aio_context = bdrv_get_aio_context(child->bs);\n\n\n\n        co = qemu_coroutine_create(bdrv_rw_co_entry, &rwco);\n\n        qemu_coroutine_enter(co);\n\n        while (rwco.ret == NOT_DONE) {\n\n            aio_poll(aio_context, true);\n\n        }\n\n    }\n\n    return rwco.ret;\n\n}\n", "idx": 15719, "_split": "valid", "_hash": "54c71ba873356f598801416100bc133c"}
{"project": "qemu", "commit_id": "5f456073aa9ba54e421aa82dd38e4d40d0a0af85", "target": 0, "func": "static uint64_t virtio_pci_common_read(void *opaque, hwaddr addr,\n\n                                       unsigned size)\n\n{\n\n    VirtIOPCIProxy *proxy = opaque;\n\n    VirtIODevice *vdev = virtio_bus_get_device(&proxy->bus);\n\n    uint32_t val = 0;\n\n    int i;\n\n\n\n    switch (addr) {\n\n    case VIRTIO_PCI_COMMON_DFSELECT:\n\n        val = proxy->dfselect;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_DF:\n\n        if (proxy->dfselect <= 1) {\n\n            val = vdev->host_features >> (32 * proxy->dfselect);\n\n        }\n\n        break;\n\n    case VIRTIO_PCI_COMMON_GFSELECT:\n\n        val = proxy->gfselect;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_GF:\n\n        if (proxy->gfselect < ARRAY_SIZE(proxy->guest_features)) {\n\n            val = proxy->guest_features[proxy->gfselect];\n\n        }\n\n        break;\n\n    case VIRTIO_PCI_COMMON_MSIX:\n\n        val = vdev->config_vector;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_NUMQ:\n\n        for (i = 0; i < VIRTIO_QUEUE_MAX; ++i) {\n\n            if (virtio_queue_get_num(vdev, i)) {\n\n                val = i + 1;\n\n            }\n\n        }\n\n        break;\n\n    case VIRTIO_PCI_COMMON_STATUS:\n\n        val = vdev->status;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_CFGGENERATION:\n\n        val = vdev->generation;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_SELECT:\n\n        val = vdev->queue_sel;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_SIZE:\n\n        val = virtio_queue_get_num(vdev, vdev->queue_sel);\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_MSIX:\n\n        val = virtio_queue_vector(vdev, vdev->queue_sel);\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_ENABLE:\n\n        val = proxy->vqs[vdev->queue_sel].enabled;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_NOFF:\n\n        /* Simply map queues in order */\n\n        val = vdev->queue_sel;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_DESCLO:\n\n        val = proxy->vqs[vdev->queue_sel].desc[0];\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_DESCHI:\n\n        val = proxy->vqs[vdev->queue_sel].desc[1];\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_AVAILLO:\n\n        val = proxy->vqs[vdev->queue_sel].avail[0];\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_AVAILHI:\n\n        val = proxy->vqs[vdev->queue_sel].avail[1];\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_USEDLO:\n\n        val = proxy->vqs[vdev->queue_sel].used[0];\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_USEDHI:\n\n        val = proxy->vqs[vdev->queue_sel].used[1];\n\n        break;\n\n    default:\n\n        val = 0;\n\n    }\n\n\n\n    return val;\n\n}\n", "idx": 15731, "_split": "valid", "_hash": "efb33db10f0c55c6452a9eda637072b1"}
{"project": "qemu", "commit_id": "a9859c90a5db200fd4f63ab2cdc973343348b9ef", "target": 1, "func": "static void xilinx_axidma_realize(DeviceState *dev, Error **errp)\n\n{\n\n    XilinxAXIDMA *s = XILINX_AXI_DMA(dev);\n\n    XilinxAXIDMAStreamSlave *ds = XILINX_AXI_DMA_DATA_STREAM(&s->rx_data_dev);\n\n    XilinxAXIDMAStreamSlave *cs = XILINX_AXI_DMA_CONTROL_STREAM(\n\n                                                            &s->rx_control_dev);\n\n    Error *local_err = NULL;\n\n\n\n    object_property_add_link(OBJECT(ds), \"dma\", TYPE_XILINX_AXI_DMA,\n\n                             (Object **)&ds->dma,\n\n                             object_property_allow_set_link,\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE,\n\n                             &local_err);\n\n    object_property_add_link(OBJECT(cs), \"dma\", TYPE_XILINX_AXI_DMA,\n\n                             (Object **)&cs->dma,\n\n                             object_property_allow_set_link,\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE,\n\n                             &local_err);\n\n    if (local_err) {\n\n        goto xilinx_axidma_realize_fail;\n\n    }\n\n    object_property_set_link(OBJECT(ds), OBJECT(s), \"dma\", &local_err);\n\n    object_property_set_link(OBJECT(cs), OBJECT(s), \"dma\", &local_err);\n\n    if (local_err) {\n\n        goto xilinx_axidma_realize_fail;\n\n    }\n\n\n\n    int i;\n\n\n\n    for (i = 0; i < 2; i++) {\n\n        struct Stream *st = &s->streams[i];\n\n\n\n        st->nr = i;\n\n        st->bh = qemu_bh_new(timer_hit, st);\n\n        st->ptimer = ptimer_init(st->bh, PTIMER_POLICY_DEFAULT);\n\n        ptimer_set_freq(st->ptimer, s->freqhz);\n\n    }\n\n    return;\n\n\n\nxilinx_axidma_realize_fail:\n\n    if (!*errp) {\n\n        *errp = local_err;\n\n    }\n\n}\n", "idx": 15768, "_split": "valid", "_hash": "d7908b50cf5e6a574b673c71e603455e"}
{"project": "qemu", "commit_id": "d5e6f437c5508614803d11e59ee16a758dde09ef", "target": 0, "func": "BdrvChild *bdrv_attach_child(BlockDriverState *parent_bs,\n\n                             BlockDriverState *child_bs,\n\n                             const char *child_name,\n\n                             const BdrvChildRole *child_role,\n\n                             Error **errp)\n\n{\n\n    BdrvChild *child = bdrv_root_attach_child(child_bs, child_name, child_role,\n\n                                              parent_bs);\n\n    QLIST_INSERT_HEAD(&parent_bs->children, child, next);\n\n    return child;\n\n}\n", "idx": 15778, "_split": "valid", "_hash": "f5858f004f4155a6fe3a864cdd3b540d"}
{"project": "qemu", "commit_id": "3f66f764ee25f10d3e1144ebc057a949421b7728", "target": 0, "func": "static void test_visitor_in_native_list_number(TestInputVisitorData *data,\n\n                                               const void *unused)\n\n{\n\n    UserDefNativeListUnion *cvalue = NULL;\n\n    numberList *elem = NULL;\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n    GString *gstr_list = g_string_new(\"\");\n\n    GString *gstr_union = g_string_new(\"\");\n\n    int i;\n\n\n\n    for (i = 0; i < 32; i++) {\n\n        g_string_append_printf(gstr_list, \"%f\", (double)i / 3);\n\n        if (i != 31) {\n\n            g_string_append(gstr_list, \", \");\n\n        }\n\n    }\n\n    g_string_append_printf(gstr_union,  \"{ 'type': 'number', 'data': [ %s ] }\",\n\n                           gstr_list->str);\n\n    v = visitor_input_test_init_raw(data,  gstr_union->str);\n\n\n\n    visit_type_UserDefNativeListUnion(v, &cvalue, NULL, &err);\n\n    g_assert(err == NULL);\n\n    g_assert(cvalue != NULL);\n\n    g_assert_cmpint(cvalue->type, ==, USER_DEF_NATIVE_LIST_UNION_KIND_NUMBER);\n\n\n\n    for (i = 0, elem = cvalue->u.number; elem; elem = elem->next, i++) {\n\n        GString *double_expected = g_string_new(\"\");\n\n        GString *double_actual = g_string_new(\"\");\n\n\n\n        g_string_printf(double_expected, \"%.6f\", (double)i / 3);\n\n        g_string_printf(double_actual, \"%.6f\", elem->value);\n\n        g_assert_cmpstr(double_expected->str, ==, double_actual->str);\n\n\n\n        g_string_free(double_expected, true);\n\n        g_string_free(double_actual, true);\n\n    }\n\n\n\n    g_string_free(gstr_union, true);\n\n    g_string_free(gstr_list, true);\n\n    qapi_free_UserDefNativeListUnion(cvalue);\n\n}\n", "idx": 15815, "_split": "valid", "_hash": "dd93663ed514f7532dd0aa563ce7bb45"}
{"project": "qemu", "commit_id": "a3fa1d78cbae2259491b17689812edcb643a3b30", "target": 0, "func": "static void migrate_fd_cleanup(MigrationState *s)\n\n{\n\n    int ret = 0;\n\n\n\n    if (s->file) {\n\n        DPRINTF(\"closing file\\n\");\n\n        ret = qemu_fclose(s->file);\n\n        s->file = NULL;\n\n    }\n\n\n\n    assert(s->fd == -1);\n\n    if (ret < 0 && s->state == MIG_STATE_ACTIVE) {\n\n        s->state = MIG_STATE_ERROR;\n\n    }\n\n\n\n    if (s->state != MIG_STATE_ACTIVE) {\n\n        qemu_savevm_state_cancel();\n\n    }\n\n}\n", "idx": 15835, "_split": "valid", "_hash": "d723d2f71ff48aee2cb22f8b25ae0ab6"}
{"project": "qemu", "commit_id": "806d102141b99d4f1e55a97d68b7ea8c8ba3129f", "target": 1, "func": "unsigned long init_guest_space(unsigned long host_start,\n\n                               unsigned long host_size,\n\n                               unsigned long guest_start,\n\n                               bool fixed)\n\n{\n\n    unsigned long current_start, real_start;\n\n    int flags;\n\n\n\n    assert(host_start || host_size);\n\n\n\n    /* If just a starting address is given, then just verify that\n\n     * address.  */\n\n    if (host_start && !host_size) {\n\n        if (guest_validate_base(host_start)) {\n\n            return host_start;\n\n        } else {\n\n            return (unsigned long)-1;\n\n        }\n\n    }\n\n\n\n    /* Setup the initial flags and start address.  */\n\n    current_start = host_start & qemu_host_page_mask;\n\n    flags = MAP_ANONYMOUS | MAP_PRIVATE | MAP_NORESERVE;\n\n    if (fixed) {\n\n        flags |= MAP_FIXED;\n\n    }\n\n\n\n    /* Otherwise, a non-zero size region of memory needs to be mapped\n\n     * and validated.  */\n\n    while (1) {\n\n        /* Do not use mmap_find_vma here because that is limited to the\n\n         * guest address space.  We are going to make the\n\n         * guest address space fit whatever we're given.\n\n         */\n\n        real_start = (unsigned long)\n\n            mmap((void *)current_start, host_size, PROT_NONE, flags, -1, 0);\n\n        if (real_start == (unsigned long)-1) {\n\n            return (unsigned long)-1;\n\n        }\n\n\n\n        if ((real_start == current_start)\n\n            && guest_validate_base(real_start - guest_start)) {\n\n            break;\n\n        }\n\n\n\n        /* That address didn't work.  Unmap and try a different one.\n\n         * The address the host picked because is typically right at\n\n         * the top of the host address space and leaves the guest with\n\n         * no usable address space.  Resort to a linear search.  We\n\n         * already compensated for mmap_min_addr, so this should not\n\n         * happen often.  Probably means we got unlucky and host\n\n         * address space randomization put a shared library somewhere\n\n         * inconvenient.\n\n         */\n\n        munmap((void *)real_start, host_size);\n\n        current_start += qemu_host_page_size;\n\n        if (host_start == current_start) {\n\n            /* Theoretically possible if host doesn't have any suitably\n\n             * aligned areas.  Normally the first mmap will fail.\n\n             */\n\n            return (unsigned long)-1;\n\n        }\n\n    }\n\n\n\n    return real_start;\n\n}\n", "idx": 15844, "_split": "valid", "_hash": "49b36ca82ad8a8e9535a82dbac377956"}
{"project": "qemu", "commit_id": "e58d695e6c3a5cfa0aa2fc91b87ade017ef28b05", "target": 1, "func": "static void qmp_input_start_struct(Visitor *v, const char *name, void **obj,\n\n                                   size_t size, Error **errp)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qmp_input_get_object(qiv, name, true);\n\n    Error *err = NULL;\n\n\n\n\n\n\n    if (!qobj || qobject_type(qobj) != QTYPE_QDICT) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"QDict\");\n\n        return;\n\n\n\n\n    qmp_input_push(qiv, qobj, &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n\n\n\n\n        *obj = g_malloc0(size);\n\n", "idx": 15852, "_split": "valid", "_hash": "99299029b08d3e11365f54951c1b53f0"}
{"project": "qemu", "commit_id": "c7020c974073ba9c0110d45361720a29ff6b2f59", "target": 1, "func": "static void ehci_advance_state(EHCIState *ehci,\n\n                               int async)\n\n{\n\n    EHCIQueue *q = NULL;\n\n    int again;\n\n    int iter = 0;\n\n\n\n    do {\n\n        if (ehci_get_state(ehci, async) == EST_FETCHQH) {\n\n            iter++;\n\n            /* if we are roaming a lot of QH without executing a qTD\n\n             * something is wrong with the linked list. TO-DO: why is\n\n             * this hack needed?\n\n             */\n\n            assert(iter < MAX_ITERATIONS);\n\n#if 0\n\n            if (iter > MAX_ITERATIONS) {\n\n                DPRINTF(\"\\n*** advance_state: bailing on MAX ITERATIONS***\\n\");\n\n                ehci_set_state(ehci, async, EST_ACTIVE);\n\n                break;\n\n            }\n\n#endif\n\n        }\n\n        switch(ehci_get_state(ehci, async)) {\n\n        case EST_WAITLISTHEAD:\n\n            again = ehci_state_waitlisthead(ehci, async);\n\n            break;\n\n\n\n        case EST_FETCHENTRY:\n\n            again = ehci_state_fetchentry(ehci, async);\n\n            break;\n\n\n\n        case EST_FETCHQH:\n\n            q = ehci_state_fetchqh(ehci, async);\n\n            again = q ? 1 : 0;\n\n            break;\n\n\n\n        case EST_FETCHITD:\n\n            again = ehci_state_fetchitd(ehci, async);\n\n            break;\n\n\n\n        case EST_FETCHSITD:\n\n            again = ehci_state_fetchsitd(ehci, async);\n\n            break;\n\n\n\n        case EST_ADVANCEQUEUE:\n\n            again = ehci_state_advqueue(q, async);\n\n            break;\n\n\n\n        case EST_FETCHQTD:\n\n            again = ehci_state_fetchqtd(q, async);\n\n            break;\n\n\n\n        case EST_HORIZONTALQH:\n\n            again = ehci_state_horizqh(q, async);\n\n            break;\n\n\n\n        case EST_EXECUTE:\n\n            iter = 0;\n\n            again = ehci_state_execute(q, async);\n\n            break;\n\n\n\n        case EST_EXECUTING:\n\n            assert(q != NULL);\n\n            again = ehci_state_executing(q, async);\n\n            break;\n\n\n\n        case EST_WRITEBACK:\n\n            assert(q != NULL);\n\n            again = ehci_state_writeback(q, async);\n\n            break;\n\n\n\n        default:\n\n            fprintf(stderr, \"Bad state!\\n\");\n\n            again = -1;\n\n            assert(0);\n\n            break;\n\n        }\n\n\n\n        if (again < 0) {\n\n            fprintf(stderr, \"processing error - resetting ehci HC\\n\");\n\n            ehci_reset(ehci);\n\n            again = 0;\n\n            assert(0);\n\n        }\n\n    }\n\n    while (again);\n\n\n\n    ehci_commit_interrupt(ehci);\n\n}\n", "idx": 15855, "_split": "valid", "_hash": "c2bc156c16a3c6aed1544194283c1831"}
{"project": "qemu", "commit_id": "868270f23d8db2cce83e4f082fe75e8625a5fbf9", "target": 1, "func": "void acpi_build(PcGuestInfo *guest_info, AcpiBuildTables *tables)\n\n{\n\n    GArray *table_offsets;\n\n    unsigned facs, ssdt, dsdt, rsdt;\n\n    AcpiCpuInfo cpu;\n\n    AcpiPmInfo pm;\n\n    AcpiMiscInfo misc;\n\n    AcpiMcfgInfo mcfg;\n\n    PcPciInfo pci;\n\n    uint8_t *u;\n\n    size_t aml_len = 0;\n\n\n\n    acpi_get_cpu_info(&cpu);\n\n    acpi_get_pm_info(&pm);\n\n    acpi_get_dsdt(&misc);\n\n    acpi_get_misc_info(&misc);\n\n    acpi_get_pci_info(&pci);\n\n\n\n    table_offsets = g_array_new(false, true /* clear */,\n\n                                        sizeof(uint32_t));\n\n    ACPI_BUILD_DPRINTF(3, \"init ACPI tables\\n\");\n\n\n\n    bios_linker_loader_alloc(tables->linker, ACPI_BUILD_TABLE_FILE,\n\n                             64 /* Ensure FACS is aligned */,\n\n                             false /* high memory */);\n\n\n\n    /*\n\n     * FACS is pointed to by FADT.\n\n     * We place it first since it's the only table that has alignment\n\n     * requirements.\n\n     */\n\n    facs = tables->table_data->len;\n\n    build_facs(tables->table_data, tables->linker, guest_info);\n\n\n\n    /* DSDT is pointed to by FADT */\n\n    dsdt = tables->table_data->len;\n\n    build_dsdt(tables->table_data, tables->linker, &misc);\n\n\n\n    /* Count the size of the DSDT and SSDT, we will need it for legacy\n\n     * sizing of ACPI tables.\n\n     */\n\n    aml_len += tables->table_data->len - dsdt;\n\n\n\n    /* ACPI tables pointed to by RSDT */\n\n    acpi_add_table(table_offsets, tables->table_data);\n\n    build_fadt(tables->table_data, tables->linker, &pm, facs, dsdt);\n\n\n\n    ssdt = tables->table_data->len;\n\n    acpi_add_table(table_offsets, tables->table_data);\n\n    build_ssdt(tables->table_data, tables->linker, &cpu, &pm, &misc, &pci,\n\n               guest_info);\n\n    aml_len += tables->table_data->len - ssdt;\n\n\n\n    acpi_add_table(table_offsets, tables->table_data);\n\n    build_madt(tables->table_data, tables->linker, &cpu, guest_info);\n\n\n\n    if (misc.has_hpet) {\n\n        acpi_add_table(table_offsets, tables->table_data);\n\n        build_hpet(tables->table_data, tables->linker);\n\n    }\n\n    if (guest_info->numa_nodes) {\n\n        acpi_add_table(table_offsets, tables->table_data);\n\n        build_srat(tables->table_data, tables->linker, &cpu, guest_info);\n\n    }\n\n    if (acpi_get_mcfg(&mcfg)) {\n\n        acpi_add_table(table_offsets, tables->table_data);\n\n        build_mcfg_q35(tables->table_data, tables->linker, &mcfg);\n\n    }\n\n\n\n    /* Add tables supplied by user (if any) */\n\n    for (u = acpi_table_first(); u; u = acpi_table_next(u)) {\n\n        unsigned len = acpi_table_len(u);\n\n\n\n        acpi_add_table(table_offsets, tables->table_data);\n\n        g_array_append_vals(tables->table_data, u, len);\n\n    }\n\n\n\n    /* RSDT is pointed to by RSDP */\n\n    rsdt = tables->table_data->len;\n\n    build_rsdt(tables->table_data, tables->linker, table_offsets);\n\n\n\n    /* RSDP is in FSEG memory, so allocate it separately */\n\n    build_rsdp(tables->rsdp, tables->linker, rsdt);\n\n\n\n    /* We'll expose it all to Guest so we want to reduce\n\n     * chance of size changes.\n\n     * RSDP is small so it's easy to keep it immutable, no need to\n\n     * bother with alignment.\n\n     *\n\n     * We used to align the tables to 4k, but of course this would\n\n     * too simple to be enough.  4k turned out to be too small an\n\n     * alignment very soon, and in fact it is almost impossible to\n\n     * keep the table size stable for all (max_cpus, max_memory_slots)\n\n     * combinations.  So the table size is always 64k for pc-i440fx-2.1\n\n     * and we give an error if the table grows beyond that limit.\n\n     *\n\n     * We still have the problem of migrating from \"-M pc-i440fx-2.0\".  For\n\n     * that, we exploit the fact that QEMU 2.1 generates _smaller_ tables\n\n     * than 2.0 and we can always pad the smaller tables with zeros.  We can\n\n     * then use the exact size of the 2.0 tables.\n\n     *\n\n     * All this is for PIIX4, since QEMU 2.0 didn't support Q35 migration.\n\n     */\n\n    if (guest_info->legacy_acpi_table_size) {\n\n        /* Subtracting aml_len gives the size of fixed tables.  Then add the\n\n         * size of the PIIX4 DSDT/SSDT in QEMU 2.0.\n\n         */\n\n        int legacy_aml_len =\n\n            guest_info->legacy_acpi_table_size +\n\n            ACPI_BUILD_LEGACY_CPU_AML_SIZE * max_cpus;\n\n        int legacy_table_size =\n\n            ROUND_UP(tables->table_data->len - aml_len + legacy_aml_len,\n\n                     ACPI_BUILD_ALIGN_SIZE);\n\n        if (tables->table_data->len > legacy_table_size) {\n\n            /* Should happen only with PCI bridges and -M pc-i440fx-2.0.  */\n\n            error_report(\"Warning: migration to QEMU 2.0 may not work.\");\n\n        }\n\n        g_array_set_size(tables->table_data, legacy_table_size);\n\n    } else {\n\n        if (tables->table_data->len > ACPI_BUILD_TABLE_SIZE) {\n\n            /* As of QEMU 2.1, this fires with 160 VCPUs and 255 memory slots.  */\n\n            error_report(\"ACPI tables are larger than 64k.  Please remove\");\n\n            error_report(\"CPUs, NUMA nodes, memory slots or PCI bridges.\");\n\n            exit(1);\n\n        }\n\n        g_array_set_size(tables->table_data, ACPI_BUILD_TABLE_SIZE);\n\n    }\n\n\n\n    acpi_align_size(tables->linker, ACPI_BUILD_ALIGN_SIZE);\n\n\n\n    /* Cleanup memory that's no longer used. */\n\n    g_array_free(table_offsets, true);\n\n}\n", "idx": 15857, "_split": "valid", "_hash": "f7df2905a300edd7e42b393bef8c7899"}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "int l4_register_io_memory(CPUReadMemoryFunc * const *mem_read,\n\n                CPUWriteMemoryFunc * const *mem_write, void *opaque)\n\n{\n\n    omap_l4_io_entry[omap_l4_io_entries].mem_read = mem_read;\n\n    omap_l4_io_entry[omap_l4_io_entries].mem_write = mem_write;\n\n    omap_l4_io_entry[omap_l4_io_entries].opaque = opaque;\n\n\n\n    return omap_l4_io_entries ++;\n\n}\n", "idx": 15869, "_split": "valid", "_hash": "394c46d8969ab72ed94a793fa9d7ca81"}
{"project": "qemu", "commit_id": "db1e80ee2ed6fc9eb6b203873b39752144f5577f", "target": 0, "func": "static int vhdx_create_new_headers(BlockDriverState *bs, uint64_t image_size,\n\n                                   uint32_t log_size)\n\n{\n\n    int ret = 0;\n\n    VHDXHeader *hdr = NULL;\n\n\n\n    hdr = g_new0(VHDXHeader, 1);\n\n\n\n    hdr->signature       = VHDX_HEADER_SIGNATURE;\n\n    hdr->sequence_number = g_random_int();\n\n    hdr->log_version     = 0;\n\n    hdr->version         = 1;\n\n    hdr->log_length      = log_size;\n\n    hdr->log_offset      = VHDX_HEADER_SECTION_END;\n\n    vhdx_guid_generate(&hdr->file_write_guid);\n\n    vhdx_guid_generate(&hdr->data_write_guid);\n\n\n\n    ret = vhdx_write_header(bs, hdr, VHDX_HEADER1_OFFSET, false);\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n    hdr->sequence_number++;\n\n    ret = vhdx_write_header(bs, hdr, VHDX_HEADER2_OFFSET, false);\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\nexit:\n\n    g_free(hdr);\n\n    return ret;\n\n}\n", "idx": 15877, "_split": "valid", "_hash": "1214c723be85be7c4541b9a751322da7"}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int usb_net_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    USBNetState *s = (USBNetState *) dev;\n\n    int ret = 0;\n\n\n\n    switch(p->pid) {\n\n    case USB_TOKEN_IN:\n\n        switch (p->devep) {\n\n        case 1:\n\n            ret = usb_net_handle_statusin(s, p);\n\n            break;\n\n\n\n        case 2:\n\n            ret = usb_net_handle_datain(s, p);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    case USB_TOKEN_OUT:\n\n        switch (p->devep) {\n\n        case 2:\n\n            ret = usb_net_handle_dataout(s, p);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n    if (ret == USB_RET_STALL)\n\n        fprintf(stderr, \"usbnet: failed data transaction: \"\n\n                        \"pid 0x%x ep 0x%x len 0x%zx\\n\",\n\n                        p->pid, p->devep, p->iov.size);\n\n    return ret;\n\n}\n", "idx": 15902, "_split": "valid", "_hash": "1c6e490a9ba839e8d5eb505355fc9d7a"}
{"project": "qemu", "commit_id": "e1c37d0e94048502f9874e6356ce7136d4b05bdb", "target": 0, "func": "static void migrate_fd_monitor_suspend(MigrationState *s, Monitor *mon)\n\n{\n\n    if (monitor_suspend(mon) == 0) {\n\n        DPRINTF(\"suspending monitor\\n\");\n\n    } else {\n\n        monitor_printf(mon, \"terminal does not allow synchronous \"\n\n                       \"migration, continuing detached\\n\");\n\n    }\n\n}\n", "idx": 15918, "_split": "valid", "_hash": "dbb154e29624cca7ce2680fd0ff3edb4"}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_update_rect(struct vmsvga_state_s *s,\n\n                int x, int y, int w, int h)\n\n{\n\n    int line;\n\n    int bypl;\n\n    int width;\n\n    int start;\n\n    uint8_t *src;\n\n    uint8_t *dst;\n\n\n\n    if (x + w > s->width) {\n\n        fprintf(stderr, \"%s: update width too large x: %d, w: %d\\n\",\n\n                        __FUNCTION__, x, w);\n\n        x = MIN(x, s->width);\n\n        w = s->width - x;\n\n    }\n\n\n\n    if (y + h > s->height) {\n\n        fprintf(stderr, \"%s: update height too large y: %d, h: %d\\n\",\n\n                        __FUNCTION__, y, h);\n\n        y = MIN(y, s->height);\n\n        h = s->height - y;\n\n    }\n\n\n\n    line = h;\n\n    bypl = s->bypp * s->width;\n\n    width = s->bypp * w;\n\n    start = s->bypp * x + bypl * y;\n\n    src = s->vga.vram_ptr + start;\n\n    dst = ds_get_data(s->vga.ds) + start;\n\n\n\n    for (; line > 0; line --, src += bypl, dst += bypl)\n\n        memcpy(dst, src, width);\n\n\n\n    dpy_gfx_update(s->vga.ds, x, y, w, h);\n\n}\n", "idx": 15922, "_split": "valid", "_hash": "635b9e3ca1eacac0a08cf162be0c0065"}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "static void qemu_tcg_init_vcpu(void *_env)\n\n{\n\n    CPUState *env = _env;\n\n    /* share a single thread for all cpus with TCG */\n\n    if (!tcg_cpu_thread) {\n\n        env->thread = qemu_mallocz(sizeof(QemuThread));\n\n        env->halt_cond = qemu_mallocz(sizeof(QemuCond));\n\n        qemu_cond_init(env->halt_cond);\n\n        qemu_thread_create(env->thread, qemu_tcg_cpu_thread_fn, env);\n\n        while (env->created == 0)\n\n            qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);\n\n        tcg_cpu_thread = env->thread;\n\n        tcg_halt_cond = env->halt_cond;\n\n    } else {\n\n        env->thread = tcg_cpu_thread;\n\n        env->halt_cond = tcg_halt_cond;\n\n    }\n\n}\n", "idx": 15928, "_split": "valid", "_hash": "f211644d2c852f0abb8c22a5217bc6e9"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qdict_del(QDict *qdict, const char *key)\n\n{\n\n    QDictEntry *entry;\n\n\n\n    entry = qdict_find(qdict, key, tdb_hash(key) % QDICT_HASH_SIZE);\n\n    if (entry) {\n\n        LIST_REMOVE(entry, next);\n\n        qentry_destroy(entry);\n\n        qdict->size--;\n\n    }\n\n}\n", "idx": 15952, "_split": "valid", "_hash": "7331d09ef457ce46de3c0d30ad03487e"}
{"project": "qemu", "commit_id": "2ff64038a59e8de2baa485806be0838f49f70b79", "target": 0, "func": "static void migration_bitmap_sync_range(ram_addr_t start, ram_addr_t length)\n\n{\n\n    migration_dirty_pages +=\n\n        cpu_physical_memory_sync_dirty_bitmap(migration_bitmap, start, length);\n\n}\n", "idx": 15954, "_split": "valid", "_hash": "6a9134b6d7cdd4b88b490acac9547f2e"}
{"project": "qemu", "commit_id": "dad5b9ea0895c227bc9d48b7f0a6fa51eaaa8661", "target": 0, "func": "static void xhci_port_write(void *ptr, hwaddr reg,\n\n                            uint64_t val, unsigned size)\n\n{\n\n    XHCIPort *port = ptr;\n\n    uint32_t portsc, notify;\n\n\n\n    trace_usb_xhci_port_write(port->portnr, reg, val);\n\n\n\n    switch (reg) {\n\n    case 0x00: /* PORTSC */\n\n        /* write-1-to-start bits */\n\n        if (val & PORTSC_PR) {\n\n            xhci_port_reset(port);\n\n            break;\n\n        }\n\n\n\n        portsc = port->portsc;\n\n        notify = 0;\n\n        /* write-1-to-clear bits*/\n\n        portsc &= ~(val & (PORTSC_CSC|PORTSC_PEC|PORTSC_WRC|PORTSC_OCC|\n\n                           PORTSC_PRC|PORTSC_PLC|PORTSC_CEC));\n\n        if (val & PORTSC_LWS) {\n\n            /* overwrite PLS only when LWS=1 */\n\n            uint32_t old_pls = get_field(port->portsc, PORTSC_PLS);\n\n            uint32_t new_pls = get_field(val, PORTSC_PLS);\n\n            switch (new_pls) {\n\n            case PLS_U0:\n\n                if (old_pls != PLS_U0) {\n\n                    set_field(&portsc, new_pls, PORTSC_PLS);\n\n                    trace_usb_xhci_port_link(port->portnr, new_pls);\n\n                    notify = PORTSC_PLC;\n\n                }\n\n                break;\n\n            case PLS_U3:\n\n                if (old_pls < PLS_U3) {\n\n                    set_field(&portsc, new_pls, PORTSC_PLS);\n\n                    trace_usb_xhci_port_link(port->portnr, new_pls);\n\n                }\n\n                break;\n\n            case PLS_RESUME:\n\n                /* windows does this for some reason, don't spam stderr */\n\n                break;\n\n            default:\n\n                fprintf(stderr, \"%s: ignore pls write (old %d, new %d)\\n\",\n\n                        __func__, old_pls, new_pls);\n\n                break;\n\n            }\n\n        }\n\n        /* read/write bits */\n\n        portsc &= ~(PORTSC_PP|PORTSC_WCE|PORTSC_WDE|PORTSC_WOE);\n\n        portsc |= (val & (PORTSC_PP|PORTSC_WCE|PORTSC_WDE|PORTSC_WOE));\n\n        port->portsc = portsc;\n\n        if (notify) {\n\n            xhci_port_notify(port, notify);\n\n        }\n\n        break;\n\n    case 0x04: /* PORTPMSC */\n\n    case 0x08: /* PORTLI */\n\n    default:\n\n        trace_usb_xhci_unimplemented(\"port write\", reg);\n\n    }\n\n}\n", "idx": 15966, "_split": "valid", "_hash": "076d7372eafe5d9ffaec0223b921d7f3"}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static int pci_unin_map_irq(PCIDevice *pci_dev, int irq_num)\n\n{\n\n    int retval;\n\n    int devfn = pci_dev->devfn & 0x00FFFFFF;\n\n\n\n    retval = (((devfn >> 11) & 0x1F) + irq_num) & 3;\n\n\n\n    return retval;\n\n}\n", "idx": 15973, "_split": "valid", "_hash": "f15122cf1edbeb1ec9e28b7110c8e61e"}
{"project": "qemu", "commit_id": "fdfab37dfeffefbd4533b4158055c9b82d7c3e69", "target": 0, "func": "static int check_refcounts_l2(BlockDriverState *bs, BdrvCheckResult *res,\n\n                              void **refcount_table,\n\n                              int64_t *refcount_table_size, int64_t l2_offset,\n\n                              int flags)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t *l2_table, l2_entry;\n\n    uint64_t next_contiguous_offset = 0;\n\n    int i, l2_size, nb_csectors, ret;\n\n\n\n    /* Read L2 table from disk */\n\n    l2_size = s->l2_size * sizeof(uint64_t);\n\n    l2_table = g_malloc(l2_size);\n\n\n\n    ret = bdrv_pread(bs->file, l2_offset, l2_table, l2_size);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR: I/O error in check_refcounts_l2\\n\");\n\n        res->check_errors++;\n\n        goto fail;\n\n    }\n\n\n\n    /* Do the actual checks */\n\n    for(i = 0; i < s->l2_size; i++) {\n\n        l2_entry = be64_to_cpu(l2_table[i]);\n\n\n\n        switch (qcow2_get_cluster_type(l2_entry)) {\n\n        case QCOW2_CLUSTER_COMPRESSED:\n\n            /* Compressed clusters don't have QCOW_OFLAG_COPIED */\n\n            if (l2_entry & QCOW_OFLAG_COPIED) {\n\n                fprintf(stderr, \"ERROR: cluster %\" PRId64 \": \"\n\n                    \"copied flag must never be set for compressed \"\n\n                    \"clusters\\n\", l2_entry >> s->cluster_bits);\n\n                l2_entry &= ~QCOW_OFLAG_COPIED;\n\n                res->corruptions++;\n\n            }\n\n\n\n            /* Mark cluster as used */\n\n            nb_csectors = ((l2_entry >> s->csize_shift) &\n\n                           s->csize_mask) + 1;\n\n            l2_entry &= s->cluster_offset_mask;\n\n            ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                                l2_entry & ~511, nb_csectors * 512);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            if (flags & CHECK_FRAG_INFO) {\n\n                res->bfi.allocated_clusters++;\n\n                res->bfi.compressed_clusters++;\n\n\n\n                /* Compressed clusters are fragmented by nature.  Since they\n\n                 * take up sub-sector space but we only have sector granularity\n\n                 * I/O we need to re-read the same sectors even for adjacent\n\n                 * compressed clusters.\n\n                 */\n\n                res->bfi.fragmented_clusters++;\n\n            }\n\n            break;\n\n\n\n        case QCOW2_CLUSTER_ZERO:\n\n            if ((l2_entry & L2E_OFFSET_MASK) == 0) {\n\n                break;\n\n            }\n\n            /* fall through */\n\n\n\n        case QCOW2_CLUSTER_NORMAL:\n\n        {\n\n            uint64_t offset = l2_entry & L2E_OFFSET_MASK;\n\n\n\n            if (flags & CHECK_FRAG_INFO) {\n\n                res->bfi.allocated_clusters++;\n\n                if (next_contiguous_offset &&\n\n                    offset != next_contiguous_offset) {\n\n                    res->bfi.fragmented_clusters++;\n\n                }\n\n                next_contiguous_offset = offset + s->cluster_size;\n\n            }\n\n\n\n            /* Mark cluster as used */\n\n            ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                                offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            /* Correct offsets are cluster aligned */\n\n            if (offset_into_cluster(s, offset)) {\n\n                fprintf(stderr, \"ERROR offset=%\" PRIx64 \": Cluster is not \"\n\n                    \"properly aligned; L2 entry corrupted.\\n\", offset);\n\n                res->corruptions++;\n\n            }\n\n            break;\n\n        }\n\n\n\n        case QCOW2_CLUSTER_UNALLOCATED:\n\n            break;\n\n\n\n        default:\n\n            abort();\n\n        }\n\n    }\n\n\n\n    g_free(l2_table);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(l2_table);\n\n    return ret;\n\n}\n", "idx": 15976, "_split": "valid", "_hash": "15e43b7d3d7ef64368a6728de34c29fa"}
{"project": "qemu", "commit_id": "3750dabc69d76f0938cc726a64a70e4ae2fe21df", "target": 1, "func": "static void virtio_pci_common_write(void *opaque, hwaddr addr,\n\n                                    uint64_t val, unsigned size)\n\n{\n\n    VirtIOPCIProxy *proxy = opaque;\n\n    VirtIODevice *vdev = virtio_bus_get_device(&proxy->bus);\n\n\n\n    switch (addr) {\n\n    case VIRTIO_PCI_COMMON_DFSELECT:\n\n        proxy->dfselect = val;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_GFSELECT:\n\n        proxy->gfselect = val;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_GF:\n\n        if (proxy->gfselect <= ARRAY_SIZE(proxy->guest_features)) {\n\n            proxy->guest_features[proxy->gfselect] = val;\n\n            virtio_set_features(vdev,\n\n                                (((uint64_t)proxy->guest_features[1]) << 32) |\n\n                                proxy->guest_features[0]);\n\n        }\n\n        break;\n\n    case VIRTIO_PCI_COMMON_MSIX:\n\n        msix_vector_unuse(&proxy->pci_dev, vdev->config_vector);\n\n        /* Make it possible for guest to discover an error took place. */\n\n        if (msix_vector_use(&proxy->pci_dev, val) < 0) {\n\n            val = VIRTIO_NO_VECTOR;\n\n        }\n\n        vdev->config_vector = val;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_STATUS:\n\n        if (!(val & VIRTIO_CONFIG_S_DRIVER_OK)) {\n\n            virtio_pci_stop_ioeventfd(proxy);\n\n        }\n\n\n\n        virtio_set_status(vdev, val & 0xFF);\n\n\n\n        if (val & VIRTIO_CONFIG_S_DRIVER_OK) {\n\n            virtio_pci_start_ioeventfd(proxy);\n\n        }\n\n\n\n        if (vdev->status == 0) {\n\n            virtio_reset(vdev);\n\n            msix_unuse_all_vectors(&proxy->pci_dev);\n\n        }\n\n\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_SELECT:\n\n        if (val < VIRTIO_QUEUE_MAX) {\n\n            vdev->queue_sel = val;\n\n        }\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_SIZE:\n\n        proxy->vqs[vdev->queue_sel].num = val;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_MSIX:\n\n        msix_vector_unuse(&proxy->pci_dev,\n\n                          virtio_queue_vector(vdev, vdev->queue_sel));\n\n        /* Make it possible for guest to discover an error took place. */\n\n        if (msix_vector_use(&proxy->pci_dev, val) < 0) {\n\n            val = VIRTIO_NO_VECTOR;\n\n        }\n\n        virtio_queue_set_vector(vdev, vdev->queue_sel, val);\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_ENABLE:\n\n        /* TODO: need a way to put num back on reset. */\n\n        virtio_queue_set_num(vdev, vdev->queue_sel,\n\n                             proxy->vqs[vdev->queue_sel].num);\n\n        virtio_queue_set_rings(vdev, vdev->queue_sel,\n\n                       ((uint64_t)proxy->vqs[vdev->queue_sel].desc[1]) << 32 |\n\n                       proxy->vqs[vdev->queue_sel].desc[0],\n\n                       ((uint64_t)proxy->vqs[vdev->queue_sel].avail[1]) << 32 |\n\n                       proxy->vqs[vdev->queue_sel].avail[0],\n\n                       ((uint64_t)proxy->vqs[vdev->queue_sel].used[1]) << 32 |\n\n                       proxy->vqs[vdev->queue_sel].used[0]);\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_DESCLO:\n\n        proxy->vqs[vdev->queue_sel].desc[0] = val;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_DESCHI:\n\n        proxy->vqs[vdev->queue_sel].desc[1] = val;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_AVAILLO:\n\n        proxy->vqs[vdev->queue_sel].avail[0] = val;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_AVAILHI:\n\n        proxy->vqs[vdev->queue_sel].avail[1] = val;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_USEDLO:\n\n        proxy->vqs[vdev->queue_sel].used[0] = val;\n\n        break;\n\n    case VIRTIO_PCI_COMMON_Q_USEDHI:\n\n        proxy->vqs[vdev->queue_sel].used[1] = val;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 16003, "_split": "valid", "_hash": "9576b0409f90bfacdf320bf321468507"}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "void tcp_start_outgoing_migration(MigrationState *s,\n\n                                  const char *host_port,\n\n                                  Error **errp)\n\n{\n\n    Error *err = NULL;\n\n    SocketAddress *saddr = tcp_build_address(host_port, &err);\n\n    if (!err) {\n\n        socket_start_outgoing_migration(s, saddr, &err);\n\n    }\n\n    error_propagate(errp, err);\n\n}\n", "idx": 16032, "_split": "valid", "_hash": "a9baa3f23e204028d3e329da69346284"}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "static int ast2400_rambits(AspeedSDMCState *s)\n\n{\n\n    switch (s->ram_size >> 20) {\n\n    case 64:\n\n        return ASPEED_SDMC_DRAM_64MB;\n\n    case 128:\n\n        return ASPEED_SDMC_DRAM_128MB;\n\n    case 256:\n\n        return ASPEED_SDMC_DRAM_256MB;\n\n    case 512:\n\n        return ASPEED_SDMC_DRAM_512MB;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* use a common default */\n\n    error_report(\"warning: Invalid RAM size 0x%\" PRIx64\n\n                 \". Using default 256M\", s->ram_size);\n\n    s->ram_size = 256 << 20;\n\n    return ASPEED_SDMC_DRAM_256MB;\n\n}\n", "idx": 16036, "_split": "valid", "_hash": "1a239f1cf2cc3967c1ca195c6cca5411"}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static ssize_t proxy_readlink(FsContext *fs_ctx, V9fsPath *fs_path,\n\n                              char *buf, size_t bufsz)\n\n{\n\n    int retval;\n\n    retval = v9fs_request(fs_ctx->private, T_READLINK, buf, \"sd\",\n\n                          fs_path, bufsz);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n        return -1;\n\n    }\n\n    return strlen(buf);\n\n}\n", "idx": 16076, "_split": "valid", "_hash": "d28e62c88f1beccf8219890d4628aee1"}
{"project": "qemu", "commit_id": "1931e26054fdf2b1b84091f0b9662979eb6931ec", "target": 0, "func": "static void gt64120_writel (void *opaque, target_phys_addr_t addr,\n\n                            uint32_t val)\n\n{\n\n    GT64120State *s = opaque;\n\n    uint32_t saddr;\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    val = bswap32(val);\n\n#endif\n\n\n\n    saddr = (addr & 0xfff) >> 2;\n\n    switch (saddr) {\n\n\n\n    /* CPU Configuration */\n\n    case GT_CPU:\n\n        s->regs[GT_CPU] = val;\n\n        break;\n\n    case GT_MULTI:\n\n\t/* Read-only register as only one GT64xxx is present on the CPU bus */\n\n        break;\n\n\n\n    /* CPU Address Decode */\n\n    case GT_PCI0IOLD:\n\n        s->regs[GT_PCI0IOLD]    = val & 0x00007fff;\n\n        s->regs[GT_PCI0IOREMAP] = val & 0x000007ff;\n\n        gt64120_pci_mapping(s);\n\n        break;\n\n    case GT_PCI0M0LD:\n\n        s->regs[GT_PCI0M0LD]    = val & 0x00007fff;\n\n        s->regs[GT_PCI0M0REMAP] = val & 0x000007ff;\n\n        break;\n\n    case GT_PCI0M1LD:\n\n        s->regs[GT_PCI0M1LD]    = val & 0x00007fff;\n\n        s->regs[GT_PCI0M1REMAP] = val & 0x000007ff;\n\n        break;\n\n    case GT_PCI1IOLD:\n\n        s->regs[GT_PCI1IOLD]    = val & 0x00007fff;\n\n        s->regs[GT_PCI1IOREMAP] = val & 0x000007ff;\n\n        break;\n\n    case GT_PCI1M0LD:\n\n        s->regs[GT_PCI1M0LD]    = val & 0x00007fff;\n\n        s->regs[GT_PCI1M0REMAP] = val & 0x000007ff;\n\n        break;\n\n    case GT_PCI1M1LD:\n\n        s->regs[GT_PCI1M1LD]    = val & 0x00007fff;\n\n        s->regs[GT_PCI1M1REMAP] = val & 0x000007ff;\n\n        break;\n\n    case GT_PCI0IOHD:\n\n        s->regs[saddr] = val & 0x0000007f;\n\n        gt64120_pci_mapping(s);\n\n        break;\n\n    case GT_PCI0M0HD:\n\n    case GT_PCI0M1HD:\n\n    case GT_PCI1IOHD:\n\n    case GT_PCI1M0HD:\n\n    case GT_PCI1M1HD:\n\n        s->regs[saddr] = val & 0x0000007f;\n\n        break;\n\n    case GT_ISD:\n\n        s->regs[saddr] = val & 0x00007fff;\n\n        gt64120_isd_mapping(s);\n\n        break;\n\n\n\n    case GT_PCI0IOREMAP:\n\n    case GT_PCI0M0REMAP:\n\n    case GT_PCI0M1REMAP:\n\n    case GT_PCI1IOREMAP:\n\n    case GT_PCI1M0REMAP:\n\n    case GT_PCI1M1REMAP:\n\n        s->regs[saddr] = val & 0x000007ff;\n\n        break;\n\n\n\n    /* CPU Error Report */\n\n    case GT_CPUERR_ADDRLO:\n\n    case GT_CPUERR_ADDRHI:\n\n    case GT_CPUERR_DATALO:\n\n    case GT_CPUERR_DATAHI:\n\n    case GT_CPUERR_PARITY:\n\n\t/* Read-only registers, do nothing */\n\n        break;\n\n\n\n    /* CPU Sync Barrier */\n\n    case GT_PCI0SYNC:\n\n    case GT_PCI1SYNC:\n\n\t/* Read-only registers, do nothing */\n\n        break;\n\n\n\n    /* SDRAM and Device Address Decode */\n\n    case GT_SCS0LD:\n\n    case GT_SCS0HD:\n\n    case GT_SCS1LD:\n\n    case GT_SCS1HD:\n\n    case GT_SCS2LD:\n\n    case GT_SCS2HD:\n\n    case GT_SCS3LD:\n\n    case GT_SCS3HD:\n\n    case GT_CS0LD:\n\n    case GT_CS0HD:\n\n    case GT_CS1LD:\n\n    case GT_CS1HD:\n\n    case GT_CS2LD:\n\n    case GT_CS2HD:\n\n    case GT_CS3LD:\n\n    case GT_CS3HD:\n\n    case GT_BOOTLD:\n\n    case GT_BOOTHD:\n\n    case GT_ADERR:\n\n    /* SDRAM Configuration */\n\n    case GT_SDRAM_CFG:\n\n    case GT_SDRAM_OPMODE:\n\n    case GT_SDRAM_BM:\n\n    case GT_SDRAM_ADDRDECODE:\n\n        /* Accept and ignore SDRAM interleave configuration */\n\n        s->regs[saddr] = val;\n\n        break;\n\n\n\n    /* Device Parameters */\n\n    case GT_DEV_B0:\n\n    case GT_DEV_B1:\n\n    case GT_DEV_B2:\n\n    case GT_DEV_B3:\n\n    case GT_DEV_BOOT:\n\n        /* Not implemented */\n\n        dprintf (\"Unimplemented device register offset 0x%x\\n\", saddr << 2);\n\n        break;\n\n\n\n    /* ECC */\n\n    case GT_ECC_ERRDATALO:\n\n    case GT_ECC_ERRDATAHI:\n\n    case GT_ECC_MEM:\n\n    case GT_ECC_CALC:\n\n    case GT_ECC_ERRADDR:\n\n        /* Read-only registers, do nothing */\n\n        break;\n\n\n\n    /* DMA Record */\n\n    case GT_DMA0_CNT:\n\n    case GT_DMA1_CNT:\n\n    case GT_DMA2_CNT:\n\n    case GT_DMA3_CNT:\n\n    case GT_DMA0_SA:\n\n    case GT_DMA1_SA:\n\n    case GT_DMA2_SA:\n\n    case GT_DMA3_SA:\n\n    case GT_DMA0_DA:\n\n    case GT_DMA1_DA:\n\n    case GT_DMA2_DA:\n\n    case GT_DMA3_DA:\n\n    case GT_DMA0_NEXT:\n\n    case GT_DMA1_NEXT:\n\n    case GT_DMA2_NEXT:\n\n    case GT_DMA3_NEXT:\n\n    case GT_DMA0_CUR:\n\n    case GT_DMA1_CUR:\n\n    case GT_DMA2_CUR:\n\n    case GT_DMA3_CUR:\n\n        /* Not implemented */\n\n        dprintf (\"Unimplemented DMA register offset 0x%x\\n\", saddr << 2);\n\n        break;\n\n\n\n    /* DMA Channel Control */\n\n    case GT_DMA0_CTRL:\n\n    case GT_DMA1_CTRL:\n\n    case GT_DMA2_CTRL:\n\n    case GT_DMA3_CTRL:\n\n        /* Not implemented */\n\n        dprintf (\"Unimplemented DMA register offset 0x%x\\n\", saddr << 2);\n\n        break;\n\n\n\n    /* DMA Arbiter */\n\n    case GT_DMA_ARB:\n\n        /* Not implemented */\n\n        dprintf (\"Unimplemented DMA register offset 0x%x\\n\", saddr << 2);\n\n        break;\n\n\n\n    /* Timer/Counter */\n\n    case GT_TC0:\n\n    case GT_TC1:\n\n    case GT_TC2:\n\n    case GT_TC3:\n\n    case GT_TC_CONTROL:\n\n        /* Not implemented */\n\n        dprintf (\"Unimplemented timer register offset 0x%x\\n\", saddr << 2);\n\n        break;\n\n\n\n    /* PCI Internal */\n\n    case GT_PCI0_CMD:\n\n    case GT_PCI1_CMD:\n\n        s->regs[saddr] = val & 0x0401fc0f;\n\n        break;\n\n    case GT_PCI0_TOR:\n\n    case GT_PCI0_BS_SCS10:\n\n    case GT_PCI0_BS_SCS32:\n\n    case GT_PCI0_BS_CS20:\n\n    case GT_PCI0_BS_CS3BT:\n\n    case GT_PCI1_IACK:\n\n    case GT_PCI0_IACK:\n\n    case GT_PCI0_BARE:\n\n    case GT_PCI0_PREFMBR:\n\n    case GT_PCI0_SCS10_BAR:\n\n    case GT_PCI0_SCS32_BAR:\n\n    case GT_PCI0_CS20_BAR:\n\n    case GT_PCI0_CS3BT_BAR:\n\n    case GT_PCI0_SSCS10_BAR:\n\n    case GT_PCI0_SSCS32_BAR:\n\n    case GT_PCI0_SCS3BT_BAR:\n\n    case GT_PCI1_TOR:\n\n    case GT_PCI1_BS_SCS10:\n\n    case GT_PCI1_BS_SCS32:\n\n    case GT_PCI1_BS_CS20:\n\n    case GT_PCI1_BS_CS3BT:\n\n    case GT_PCI1_BARE:\n\n    case GT_PCI1_PREFMBR:\n\n    case GT_PCI1_SCS10_BAR:\n\n    case GT_PCI1_SCS32_BAR:\n\n    case GT_PCI1_CS20_BAR:\n\n    case GT_PCI1_CS3BT_BAR:\n\n    case GT_PCI1_SSCS10_BAR:\n\n    case GT_PCI1_SSCS32_BAR:\n\n    case GT_PCI1_SCS3BT_BAR:\n\n    case GT_PCI1_CFGADDR:\n\n    case GT_PCI1_CFGDATA:\n\n        /* not implemented */\n\n        break;\n\n    case GT_PCI0_CFGADDR:\n\n        s->pci->config_reg = val & 0x80fffffc;\n\n        break;\n\n    case GT_PCI0_CFGDATA:\n\n        if (s->pci->config_reg & (1u << 31))\n\n            pci_host_data_writel(s->pci, 0, val);\n\n        break;\n\n\n\n    /* Interrupts */\n\n    case GT_INTRCAUSE:\n\n        /* not really implemented */\n\n        s->regs[saddr] = ~(~(s->regs[saddr]) | ~(val & 0xfffffffe));\n\n        s->regs[saddr] |= !!(s->regs[saddr] & 0xfffffffe);\n\n        dprintf(\"INTRCAUSE %x\\n\", val);\n\n        break;\n\n    case GT_INTRMASK:\n\n        s->regs[saddr] = val & 0x3c3ffffe;\n\n        dprintf(\"INTRMASK %x\\n\", val);\n\n        break;\n\n    case GT_PCI0_ICMASK:\n\n        s->regs[saddr] = val & 0x03fffffe;\n\n        dprintf(\"ICMASK %x\\n\", val);\n\n        break;\n\n    case GT_PCI0_SERR0MASK:\n\n        s->regs[saddr] = val & 0x0000003f;\n\n        dprintf(\"SERR0MASK %x\\n\", val);\n\n        break;\n\n\n\n    /* Reserved when only PCI_0 is configured. */\n\n    case GT_HINTRCAUSE:\n\n    case GT_CPU_INTSEL:\n\n    case GT_PCI0_INTSEL:\n\n    case GT_HINTRMASK:\n\n    case GT_PCI0_HICMASK:\n\n    case GT_PCI1_SERR1MASK:\n\n        /* not implemented */\n\n        break;\n\n\n\n    /* SDRAM Parameters */\n\n    case GT_SDRAM_B0:\n\n    case GT_SDRAM_B1:\n\n    case GT_SDRAM_B2:\n\n    case GT_SDRAM_B3:\n\n        /* We don't simulate electrical parameters of the SDRAM.\n\n           Accept, but ignore the values. */\n\n        s->regs[saddr] = val;\n\n        break;\n\n\n\n    default:\n\n        dprintf (\"Bad register offset 0x%x\\n\", (int)addr);\n\n        break;\n\n    }\n\n}\n", "idx": 16086, "_split": "valid", "_hash": "b6458a9877c71ac363a008cc32be53ca"}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "static void buffer_reset(Buffer *buffer)\n\n{\n\n\tbuffer->offset = 0;\n\n}\n", "idx": 16109, "_split": "valid", "_hash": "1cf394a41d3d5a91bdc060434ff0ef11"}
{"project": "qemu", "commit_id": "8c0a6dc96cd14c48da4a61fe35431f36d6e6e467", "target": 1, "func": "static void test_hash_speed(const void *opaque)\n\n{\n\n    size_t chunk_size = (size_t)opaque;\n\n    uint8_t *in = NULL, *out = NULL;\n\n    size_t out_len = 0;\n\n    double total = 0.0;\n\n    struct iovec iov;\n\n    int ret;\n\n\n\n    in = g_new0(uint8_t, chunk_size);\n\n    memset(in, g_test_rand_int(), chunk_size);\n\n\n\n    iov.iov_base = (char *)in;\n\n    iov.iov_len = chunk_size;\n\n\n\n    g_test_timer_start();\n\n    do {\n\n        ret = qcrypto_hash_bytesv(QCRYPTO_HASH_ALG_SHA256,\n\n                                  &iov, 1, &out, &out_len,\n\n                                  NULL);\n\n        g_assert(ret == 0);\n\n\n\n        total += chunk_size;\n\n    } while (g_test_timer_elapsed() < 5.0);\n\n\n\n    total /= 1024 * 1024; /* to MB */\n\n    g_print(\"sha256: \");\n\n    g_print(\"Testing chunk_size %ld bytes \", chunk_size);\n\n    g_print(\"done: %.2f MB in %.2f secs: \", total, g_test_timer_last());\n\n    g_print(\"%.2f MB/sec\\n\", total / g_test_timer_last());\n\n\n\n    g_free(out);\n\n    g_free(in);\n\n}\n", "idx": 16124, "_split": "valid", "_hash": "e239448283e04fd08ca8e14baf0c5575"}
{"project": "qemu", "commit_id": "08b9e0ba623c4468fe94026a9bdd086526ef62f0", "target": 1, "func": "static int vhost_kernel_memslots_limit(struct vhost_dev *dev)\n\n{\n\n    int limit = 64;\n\n    char *s;\n\n\n\n    if (g_file_get_contents(\"/sys/module/vhost/parameters/max_mem_regions\",\n\n                            &s, NULL, NULL)) {\n\n        uint64_t val = g_ascii_strtoull(s, NULL, 10);\n\n        if (!((val == G_MAXUINT64 || !val) && errno)) {\n\n\n            return val;\n\n        }\n\n        error_report(\"ignoring invalid max_mem_regions value in vhost module:\"\n\n                     \" %s\", s);\n\n    }\n\n\n    return limit;\n\n}", "idx": 16126, "_split": "valid", "_hash": "f474b88d575b8b559a1afc6d01dfd7b6"}
{"project": "qemu", "commit_id": "ae0bfb79aa0ac411a433433af4d74f1f08255608", "target": 0, "func": "static inline void powerpc_excp(CPUState *env, int excp_model, int excp)\n\n{\n\n    target_ulong msr, new_msr, vector;\n\n    int srr0, srr1, asrr0, asrr1;\n\n    int lpes0, lpes1, lev;\n\n\n\n    if (0) {\n\n        /* XXX: find a suitable condition to enable the hypervisor mode */\n\n        lpes0 = (env->spr[SPR_LPCR] >> 1) & 1;\n\n        lpes1 = (env->spr[SPR_LPCR] >> 2) & 1;\n\n    } else {\n\n        /* Those values ensure we won't enter the hypervisor mode */\n\n        lpes0 = 0;\n\n        lpes1 = 1;\n\n    }\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"Raise exception at \" TARGET_FMT_lx\n\n                  \" => %08x (%02x)\\n\", env->nip, excp, env->error_code);\n\n\n\n    /* new srr1 value excluding must-be-zero bits */\n\n    msr = env->msr & ~0x783f0000ULL;\n\n\n\n    /* new interrupt handler msr */\n\n    new_msr = env->msr & ((target_ulong)1 << MSR_ME);\n\n\n\n    /* target registers */\n\n    srr0 = SPR_SRR0;\n\n    srr1 = SPR_SRR1;\n\n    asrr0 = -1;\n\n    asrr1 = -1;\n\n\n\n    switch (excp) {\n\n    case POWERPC_EXCP_NONE:\n\n        /* Should never happen */\n\n        return;\n\n    case POWERPC_EXCP_CRITICAL:    /* Critical input                         */\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_40x:\n\n            srr0 = SPR_40x_SRR2;\n\n            srr1 = SPR_40x_SRR3;\n\n            break;\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_CSRR0;\n\n            srr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        case POWERPC_EXCP_G2:\n\n            break;\n\n        default:\n\n            goto excp_invalid;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_MCHECK:    /* Machine check exception                  */\n\n        if (msr_me == 0) {\n\n            /* Machine check exception is not enabled.\n\n             * Enter checkstop state.\n\n             */\n\n            if (qemu_log_enabled()) {\n\n                qemu_log(\"Machine check while not allowed. \"\n\n                        \"Entering checkstop state\\n\");\n\n            } else {\n\n                fprintf(stderr, \"Machine check while not allowed. \"\n\n                        \"Entering checkstop state\\n\");\n\n            }\n\n            env->halted = 1;\n\n            env->interrupt_request |= CPU_INTERRUPT_EXITTB;\n\n        }\n\n        if (0) {\n\n            /* XXX: find a suitable condition to enable the hypervisor mode */\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n\n\n        /* machine check exceptions don't have ME set */\n\n        new_msr &= ~((target_ulong)1 << MSR_ME);\n\n\n\n        /* XXX: should also have something loaded in DAR / DSISR */\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_40x:\n\n            srr0 = SPR_40x_SRR2;\n\n            srr1 = SPR_40x_SRR3;\n\n            break;\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_MCSRR0;\n\n            srr1 = SPR_BOOKE_MCSRR1;\n\n            asrr0 = SPR_BOOKE_CSRR0;\n\n            asrr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_DSI:       /* Data storage exception                   */\n\n        LOG_EXCP(\"DSI exception: DSISR=\" TARGET_FMT_lx\" DAR=\" TARGET_FMT_lx\n\n                 \"\\n\", env->spr[SPR_DSISR], env->spr[SPR_DAR]);\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_ISI:       /* Instruction storage exception            */\n\n        LOG_EXCP(\"ISI exception: msr=\" TARGET_FMT_lx \", nip=\" TARGET_FMT_lx\n\n                 \"\\n\", msr, env->nip);\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        msr |= env->error_code;\n\n        goto store_next;\n\n    case POWERPC_EXCP_EXTERNAL:  /* External input                           */\n\n        if (lpes0 == 1)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_ALIGN:     /* Alignment exception                      */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        /* XXX: this is false */\n\n        /* Get rS/rD and rA from faulting opcode */\n\n        env->spr[SPR_DSISR] |= (ldl_code((env->nip - 4)) & 0x03FF0000) >> 16;\n\n        goto store_current;\n\n    case POWERPC_EXCP_PROGRAM:   /* Program exception                        */\n\n        switch (env->error_code & ~0xF) {\n\n        case POWERPC_EXCP_FP:\n\n            if ((msr_fe0 == 0 && msr_fe1 == 0) || msr_fp == 0) {\n\n                LOG_EXCP(\"Ignore floating point exception\\n\");\n\n                env->exception_index = POWERPC_EXCP_NONE;\n\n                env->error_code = 0;\n\n                return;\n\n            }\n\n            if (lpes1 == 0)\n\n                new_msr |= (target_ulong)MSR_HVB;\n\n            msr |= 0x00100000;\n\n            if (msr_fe0 == msr_fe1)\n\n                goto store_next;\n\n            msr |= 0x00010000;\n\n            break;\n\n        case POWERPC_EXCP_INVAL:\n\n            LOG_EXCP(\"Invalid instruction at \" TARGET_FMT_lx \"\\n\", env->nip);\n\n            if (lpes1 == 0)\n\n                new_msr |= (target_ulong)MSR_HVB;\n\n            msr |= 0x00080000;\n\n            break;\n\n        case POWERPC_EXCP_PRIV:\n\n            if (lpes1 == 0)\n\n                new_msr |= (target_ulong)MSR_HVB;\n\n            msr |= 0x00040000;\n\n            break;\n\n        case POWERPC_EXCP_TRAP:\n\n            if (lpes1 == 0)\n\n                new_msr |= (target_ulong)MSR_HVB;\n\n            msr |= 0x00020000;\n\n            break;\n\n        default:\n\n            /* Should never occur */\n\n            cpu_abort(env, \"Invalid program exception %d. Aborting\\n\",\n\n                      env->error_code);\n\n            break;\n\n        }\n\n        goto store_current;\n\n    case POWERPC_EXCP_FPU:       /* Floating-point unavailable exception     */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_current;\n\n    case POWERPC_EXCP_SYSCALL:   /* System call exception                    */\n\n        /* NOTE: this is a temporary hack to support graphics OSI\n\n           calls from the MOL driver */\n\n        /* XXX: To be removed */\n\n        if (env->gpr[3] == 0x113724fa && env->gpr[4] == 0x77810f9b &&\n\n            env->osi_call) {\n\n            if (env->osi_call(env) != 0) {\n\n                env->exception_index = POWERPC_EXCP_NONE;\n\n                env->error_code = 0;\n\n                return;\n\n            }\n\n        }\n\n        dump_syscall(env);\n\n        lev = env->error_code;\n\n        if (lev == 1 || (lpes0 == 0 && lpes1 == 0))\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_APU:       /* Auxiliary processor unavailable          */\n\n        goto store_current;\n\n    case POWERPC_EXCP_DECR:      /* Decrementer exception                    */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_FIT:       /* Fixed-interval timer interrupt           */\n\n        /* FIT on 4xx */\n\n        LOG_EXCP(\"FIT exception\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_WDT:       /* Watchdog timer interrupt                 */\n\n        LOG_EXCP(\"WDT exception\\n\");\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_CSRR0;\n\n            srr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_DTLB:      /* Data TLB error                           */\n\n        goto store_next;\n\n    case POWERPC_EXCP_ITLB:      /* Instruction TLB error                    */\n\n        goto store_next;\n\n    case POWERPC_EXCP_DEBUG:     /* Debug interrupt                          */\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_DSRR0;\n\n            srr1 = SPR_BOOKE_DSRR1;\n\n            asrr0 = SPR_BOOKE_CSRR0;\n\n            asrr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Debug exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_SPEU:      /* SPE/embedded floating-point unavailable  */\n\n        goto store_current;\n\n    case POWERPC_EXCP_EFPDI:     /* Embedded floating-point data interrupt   */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Embedded floating point data exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_EFPRI:     /* Embedded floating-point round interrupt  */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Embedded floating point round exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_EPERFM:    /* Embedded performance monitor interrupt   */\n\n        /* XXX: TODO */\n\n        cpu_abort(env,\n\n                  \"Performance counter exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_DOORI:     /* Embedded doorbell interrupt              */\n\n        /* XXX: TODO */\n\n        cpu_abort(env,\n\n                  \"Embedded doorbell interrupt is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_DOORCI:    /* Embedded doorbell critical interrupt     */\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_CSRR0;\n\n            srr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Embedded doorbell critical interrupt \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_RESET:     /* System reset exception                   */\n\n        if (msr_pow) {\n\n            /* indicate that we resumed from power save mode */\n\n            msr |= 0x10000;\n\n        } else {\n\n            new_msr &= ~((target_ulong)1 << MSR_ME);\n\n        }\n\n\n\n        if (0) {\n\n            /* XXX: find a suitable condition to enable the hypervisor mode */\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_DSEG:      /* Data segment exception                   */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_ISEG:      /* Instruction segment exception            */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_HDECR:     /* Hypervisor decrementer exception         */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)MSR_HVB;\n\n        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);\n\n        goto store_next;\n\n    case POWERPC_EXCP_TRACE:     /* Trace exception                          */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_HDSI:      /* Hypervisor data storage exception        */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)MSR_HVB;\n\n        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);\n\n        goto store_next;\n\n    case POWERPC_EXCP_HISI:      /* Hypervisor instruction storage exception */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)MSR_HVB;\n\n        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);\n\n        goto store_next;\n\n    case POWERPC_EXCP_HDSEG:     /* Hypervisor data segment exception        */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)MSR_HVB;\n\n        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);\n\n        goto store_next;\n\n    case POWERPC_EXCP_HISEG:     /* Hypervisor instruction segment exception */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)MSR_HVB;\n\n        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);\n\n        goto store_next;\n\n    case POWERPC_EXCP_VPU:       /* Vector unavailable exception             */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_current;\n\n    case POWERPC_EXCP_PIT:       /* Programmable interval timer interrupt    */\n\n        LOG_EXCP(\"PIT exception\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_IO:        /* IO error exception                       */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"601 IO error exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_RUNM:      /* Run mode exception                       */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"601 run mode exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_EMUL:      /* Emulation trap exception                 */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"602 emulation trap exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_IFTLB:     /* Instruction fetch TLB error              */\n\n        if (lpes1 == 0) /* XXX: check this */\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_602:\n\n        case POWERPC_EXCP_603:\n\n        case POWERPC_EXCP_603E:\n\n        case POWERPC_EXCP_G2:\n\n            goto tlb_miss_tgpr;\n\n        case POWERPC_EXCP_7x5:\n\n            goto tlb_miss;\n\n        case POWERPC_EXCP_74xx:\n\n            goto tlb_miss_74xx;\n\n        default:\n\n            cpu_abort(env, \"Invalid instruction TLB miss exception\\n\");\n\n            break;\n\n        }\n\n        break;\n\n    case POWERPC_EXCP_DLTLB:     /* Data load TLB miss                       */\n\n        if (lpes1 == 0) /* XXX: check this */\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_602:\n\n        case POWERPC_EXCP_603:\n\n        case POWERPC_EXCP_603E:\n\n        case POWERPC_EXCP_G2:\n\n            goto tlb_miss_tgpr;\n\n        case POWERPC_EXCP_7x5:\n\n            goto tlb_miss;\n\n        case POWERPC_EXCP_74xx:\n\n            goto tlb_miss_74xx;\n\n        default:\n\n            cpu_abort(env, \"Invalid data load TLB miss exception\\n\");\n\n            break;\n\n        }\n\n        break;\n\n    case POWERPC_EXCP_DSTLB:     /* Data store TLB miss                      */\n\n        if (lpes1 == 0) /* XXX: check this */\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_602:\n\n        case POWERPC_EXCP_603:\n\n        case POWERPC_EXCP_603E:\n\n        case POWERPC_EXCP_G2:\n\n        tlb_miss_tgpr:\n\n            /* Swap temporary saved registers with GPRs */\n\n            if (!(new_msr & ((target_ulong)1 << MSR_TGPR))) {\n\n                new_msr |= (target_ulong)1 << MSR_TGPR;\n\n                hreg_swap_gpr_tgpr(env);\n\n            }\n\n            goto tlb_miss;\n\n        case POWERPC_EXCP_7x5:\n\n        tlb_miss:\n\n#if defined (DEBUG_SOFTWARE_TLB)\n\n            if (qemu_log_enabled()) {\n\n                const char *es;\n\n                target_ulong *miss, *cmp;\n\n                int en;\n\n                if (excp == POWERPC_EXCP_IFTLB) {\n\n                    es = \"I\";\n\n                    en = 'I';\n\n                    miss = &env->spr[SPR_IMISS];\n\n                    cmp = &env->spr[SPR_ICMP];\n\n                } else {\n\n                    if (excp == POWERPC_EXCP_DLTLB)\n\n                        es = \"DL\";\n\n                    else\n\n                        es = \"DS\";\n\n                    en = 'D';\n\n                    miss = &env->spr[SPR_DMISS];\n\n                    cmp = &env->spr[SPR_DCMP];\n\n                }\n\n                qemu_log(\"6xx %sTLB miss: %cM \" TARGET_FMT_lx \" %cC \"\n\n                         TARGET_FMT_lx \" H1 \" TARGET_FMT_lx \" H2 \"\n\n                         TARGET_FMT_lx \" %08x\\n\", es, en, *miss, en, *cmp,\n\n                         env->spr[SPR_HASH1], env->spr[SPR_HASH2],\n\n                         env->error_code);\n\n            }\n\n#endif\n\n            msr |= env->crf[0] << 28;\n\n            msr |= env->error_code; /* key, D/I, S/L bits */\n\n            /* Set way using a LRU mechanism */\n\n            msr |= ((env->last_way + 1) & (env->nb_ways - 1)) << 17;\n\n            break;\n\n        case POWERPC_EXCP_74xx:\n\n        tlb_miss_74xx:\n\n#if defined (DEBUG_SOFTWARE_TLB)\n\n            if (qemu_log_enabled()) {\n\n                const char *es;\n\n                target_ulong *miss, *cmp;\n\n                int en;\n\n                if (excp == POWERPC_EXCP_IFTLB) {\n\n                    es = \"I\";\n\n                    en = 'I';\n\n                    miss = &env->spr[SPR_TLBMISS];\n\n                    cmp = &env->spr[SPR_PTEHI];\n\n                } else {\n\n                    if (excp == POWERPC_EXCP_DLTLB)\n\n                        es = \"DL\";\n\n                    else\n\n                        es = \"DS\";\n\n                    en = 'D';\n\n                    miss = &env->spr[SPR_TLBMISS];\n\n                    cmp = &env->spr[SPR_PTEHI];\n\n                }\n\n                qemu_log(\"74xx %sTLB miss: %cM \" TARGET_FMT_lx \" %cC \"\n\n                         TARGET_FMT_lx \" %08x\\n\", es, en, *miss, en, *cmp,\n\n                         env->error_code);\n\n            }\n\n#endif\n\n            msr |= env->error_code; /* key bit */\n\n            break;\n\n        default:\n\n            cpu_abort(env, \"Invalid data store TLB miss exception\\n\");\n\n            break;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_FPA:       /* Floating-point assist exception          */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Floating point assist exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_DABR:      /* Data address breakpoint                  */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"DABR exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_IABR:      /* Instruction address breakpoint           */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"IABR exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_SMI:       /* System management interrupt              */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"SMI exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_THERM:     /* Thermal interrupt                        */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Thermal management exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_PERFM:     /* Embedded performance monitor interrupt   */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        /* XXX: TODO */\n\n        cpu_abort(env,\n\n                  \"Performance counter exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_VPUA:      /* Vector assist exception                  */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"VPU assist exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_SOFTP:     /* Soft patch exception                     */\n\n        /* XXX: TODO */\n\n        cpu_abort(env,\n\n                  \"970 soft-patch exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_MAINT:     /* Maintenance exception                    */\n\n        /* XXX: TODO */\n\n        cpu_abort(env,\n\n                  \"970 maintenance exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_MEXTBR:    /* Maskable external breakpoint             */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Maskable external exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_NMEXTBR:   /* Non maskable external breakpoint         */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Non maskable external exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    default:\n\n    excp_invalid:\n\n        cpu_abort(env, \"Invalid PowerPC exception %d. Aborting\\n\", excp);\n\n        break;\n\n    store_current:\n\n        /* save current instruction location */\n\n        env->spr[srr0] = env->nip - 4;\n\n        break;\n\n    store_next:\n\n        /* save next instruction location */\n\n        env->spr[srr0] = env->nip;\n\n        break;\n\n    }\n\n    /* Save MSR */\n\n    env->spr[srr1] = msr;\n\n    /* If any alternate SRR register are defined, duplicate saved values */\n\n    if (asrr0 != -1)\n\n        env->spr[asrr0] = env->spr[srr0];\n\n    if (asrr1 != -1)\n\n        env->spr[asrr1] = env->spr[srr1];\n\n    /* If we disactivated any translation, flush TLBs */\n\n    if (new_msr & ((1 << MSR_IR) | (1 << MSR_DR)))\n\n        tlb_flush(env, 1);\n\n\n\n    if (msr_ile) {\n\n        new_msr |= (target_ulong)1 << MSR_LE;\n\n    }\n\n\n\n    /* Jump to handler */\n\n    vector = env->excp_vectors[excp];\n\n    if (vector == (target_ulong)-1ULL) {\n\n        cpu_abort(env, \"Raised an exception without defined vector %d\\n\",\n\n                  excp);\n\n    }\n\n    vector |= env->excp_prefix;\n\n#if defined(TARGET_PPC64)\n\n    if (excp_model == POWERPC_EXCP_BOOKE) {\n\n        if (!msr_icm) {\n\n            vector = (uint32_t)vector;\n\n        } else {\n\n            new_msr |= (target_ulong)1 << MSR_CM;\n\n        }\n\n    } else {\n\n        if (!msr_isf && !(env->mmu_model & POWERPC_MMU_64)) {\n\n            vector = (uint32_t)vector;\n\n        } else {\n\n            new_msr |= (target_ulong)1 << MSR_SF;\n\n        }\n\n    }\n\n#endif\n\n    /* XXX: we don't use hreg_store_msr here as already have treated\n\n     *      any special case that could occur. Just store MSR and update hflags\n\n     */\n\n    env->msr = new_msr & env->msr_mask;\n\n    hreg_compute_hflags(env);\n\n    env->nip = vector;\n\n    /* Reset exception state */\n\n    env->exception_index = POWERPC_EXCP_NONE;\n\n    env->error_code = 0;\n\n\n\n    if (env->mmu_model == POWERPC_MMU_BOOKE) {\n\n        /* XXX: The BookE changes address space when switching modes,\n\n                we should probably implement that as different MMU indexes,\n\n                but for the moment we do it the slow way and flush all.  */\n\n        tlb_flush(env, 1);\n\n    }\n\n}\n", "idx": 16138, "_split": "valid", "_hash": "07989cdbd0c23fc8302f608479f7fb9a"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static bool coroutine_fn wait_serialising_requests(BdrvTrackedRequest *self)\n\n{\n\n    BlockDriverState *bs = self->bs;\n\n    BdrvTrackedRequest *req;\n\n    bool retry;\n\n    bool waited = false;\n\n\n\n    if (!bs->serialising_in_flight) {\n\n        return false;\n\n    }\n\n\n\n    do {\n\n        retry = false;\n\n        QLIST_FOREACH(req, &bs->tracked_requests, list) {\n\n            if (req == self || (!req->serialising && !self->serialising)) {\n\n                continue;\n\n            }\n\n            if (tracked_request_overlaps(req, self->overlap_offset,\n\n                                         self->overlap_bytes))\n\n            {\n\n                /* Hitting this means there was a reentrant request, for\n\n                 * example, a block driver issuing nested requests.  This must\n\n                 * never happen since it means deadlock.\n\n                 */\n\n                assert(qemu_coroutine_self() != req->co);\n\n\n\n                /* If the request is already (indirectly) waiting for us, or\n\n                 * will wait for us as soon as it wakes up, then just go on\n\n                 * (instead of producing a deadlock in the former case). */\n\n                if (!req->waiting_for) {\n\n                    self->waiting_for = req;\n\n                    qemu_co_queue_wait(&req->wait_queue);\n\n                    self->waiting_for = NULL;\n\n                    retry = true;\n\n                    waited = true;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n    } while (retry);\n\n\n\n    return waited;\n\n}\n", "idx": 16140, "_split": "valid", "_hash": "9306bd143e386e673a47f92875b5855a"}
{"project": "qemu", "commit_id": "7d553f27fce284805d7f94603932045ee3bbb979", "target": 0, "func": "static int usb_device_init(USBDevice *dev)\n\n{\n\n    USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);\n\n    if (klass->init) {\n\n        return klass->init(dev);\n\n    }\n\n    return 0;\n\n}\n", "idx": 16168, "_split": "valid", "_hash": "6fc13f18b8809a52a71ce716261b4b43"}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "int bdrv_ioctl(BlockDriverState *bs, unsigned long int req, void *buf)\n\n{\n\n    BdrvIoctlCoData data = {\n\n        .bs = bs,\n\n        .req = req,\n\n        .buf = buf,\n\n        .ret = -EINPROGRESS,\n\n    };\n\n\n\n    if (qemu_in_coroutine()) {\n\n        /* Fast-path if already in coroutine context */\n\n        bdrv_co_ioctl_entry(&data);\n\n    } else {\n\n        Coroutine *co = qemu_coroutine_create(bdrv_co_ioctl_entry);\n\n\n\n        qemu_coroutine_enter(co, &data);\n\n        while (data.ret == -EINPROGRESS) {\n\n            aio_poll(bdrv_get_aio_context(bs), true);\n\n        }\n\n    }\n\n    return data.ret;\n\n}\n", "idx": 16214, "_split": "valid", "_hash": "76464dc898cb90b07765aaccf705d810"}
{"project": "qemu", "commit_id": "4ff927cc62ea79092e21827f17d19a3d85973e84", "target": 0, "func": "static void pxa2xx_timer_write(void *opaque, target_phys_addr_t offset,\n\n                uint32_t value)\n\n{\n\n    int i, tm = 0;\n\n    PXA2xxTimerInfo *s = (PXA2xxTimerInfo *) opaque;\n\n\n\n    switch (offset) {\n\n    case OSMR3:  tm ++;\n\n    case OSMR2:  tm ++;\n\n    case OSMR1:  tm ++;\n\n    case OSMR0:\n\n        s->timer[tm].value = value;\n\n        pxa2xx_timer_update(s, qemu_get_clock(vm_clock));\n\n        break;\n\n    case OSMR11: tm ++;\n\n    case OSMR10: tm ++;\n\n    case OSMR9:  tm ++;\n\n    case OSMR8:  tm ++;\n\n    case OSMR7:  tm ++;\n\n    case OSMR6:  tm ++;\n\n    case OSMR5:  tm ++;\n\n    case OSMR4:\n\n        if (!pxa2xx_timer_has_tm4(s))\n\n            goto badreg;\n\n        s->tm4[tm].tm.value = value;\n\n        pxa2xx_timer_update4(s, qemu_get_clock(vm_clock), tm);\n\n        break;\n\n    case OSCR:\n\n        s->oldclock = s->clock;\n\n        s->lastload = qemu_get_clock(vm_clock);\n\n        s->clock = value;\n\n        pxa2xx_timer_update(s, s->lastload);\n\n        break;\n\n    case OSCR11: tm ++;\n\n    case OSCR10: tm ++;\n\n    case OSCR9:  tm ++;\n\n    case OSCR8:  tm ++;\n\n    case OSCR7:  tm ++;\n\n    case OSCR6:  tm ++;\n\n    case OSCR5:  tm ++;\n\n    case OSCR4:\n\n        if (!pxa2xx_timer_has_tm4(s))\n\n            goto badreg;\n\n        s->tm4[tm].oldclock = s->tm4[tm].clock;\n\n        s->tm4[tm].lastload = qemu_get_clock(vm_clock);\n\n        s->tm4[tm].clock = value;\n\n        pxa2xx_timer_update4(s, s->tm4[tm].lastload, tm);\n\n        break;\n\n    case OIER:\n\n        s->irq_enabled = value & 0xfff;\n\n        break;\n\n    case OSSR:\t/* Status register */\n\n        s->events &= ~value;\n\n        for (i = 0; i < 4; i ++, value >>= 1) {\n\n            if (s->timer[i].level && (value & 1)) {\n\n                s->timer[i].level = 0;\n\n                qemu_irq_lower(s->timer[i].irq);\n\n            }\n\n        }\n\n        if (pxa2xx_timer_has_tm4(s)) {\n\n            for (i = 0; i < 8; i ++, value >>= 1)\n\n                if (s->tm4[i].tm.level && (value & 1))\n\n                    s->tm4[i].tm.level = 0;\n\n            if (!(s->events & 0xff0))\n\n                qemu_irq_lower(s->tm4->tm.irq);\n\n        }\n\n        break;\n\n    case OWER:\t/* XXX: Reset on OSMR3 match? */\n\n        s->reset3 = value;\n\n        break;\n\n    case OMCR7:  tm ++;\n\n    case OMCR6:  tm ++;\n\n    case OMCR5:  tm ++;\n\n    case OMCR4:\n\n        if (!pxa2xx_timer_has_tm4(s))\n\n            goto badreg;\n\n        s->tm4[tm].control = value & 0x0ff;\n\n        /* XXX Stop if running (shouldn't happen) */\n\n        if ((value & (1 << 7)) || tm == 0)\n\n            s->tm4[tm].freq = pxa2xx_timer4_freq[value & 7];\n\n        else {\n\n            s->tm4[tm].freq = 0;\n\n            pxa2xx_timer_update4(s, qemu_get_clock(vm_clock), tm);\n\n        }\n\n        break;\n\n    case OMCR11: tm ++;\n\n    case OMCR10: tm ++;\n\n    case OMCR9:  tm ++;\n\n    case OMCR8:  tm += 4;\n\n        if (!pxa2xx_timer_has_tm4(s))\n\n            goto badreg;\n\n        s->tm4[tm].control = value & 0x3ff;\n\n        /* XXX Stop if running (shouldn't happen) */\n\n        if ((value & (1 << 7)) || !(tm & 1))\n\n            s->tm4[tm].freq =\n\n                    pxa2xx_timer4_freq[(value & (1 << 8)) ?  0 : (value & 7)];\n\n        else {\n\n            s->tm4[tm].freq = 0;\n\n            pxa2xx_timer_update4(s, qemu_get_clock(vm_clock), tm);\n\n        }\n\n        break;\n\n    default:\n\n    badreg:\n\n        hw_error(\"pxa2xx_timer_write: Bad offset \" REG_FMT \"\\n\", offset);\n\n    }\n\n}\n", "idx": 16235, "_split": "valid", "_hash": "35e1ea0bbb48b47acb1bdfded98b2988"}
{"project": "qemu", "commit_id": "d88d3a093898bd1dc0898c7c87b0d3f555a24a6e", "target": 0, "func": "static void mipsnet_ioport_write(void *opaque, hwaddr addr,\n\n                                 uint64_t val, unsigned int size)\n\n{\n\n    MIPSnetState *s = opaque;\n\n\n\n    addr &= 0x3f;\n\n    trace_mipsnet_write(addr, val);\n\n    switch (addr) {\n\n    case MIPSNET_TX_DATA_COUNT:\n\n\ts->tx_count = (val <= MAX_ETH_FRAME_SIZE) ? val : 0;\n\n        s->tx_written = 0;\n\n        break;\n\n    case MIPSNET_INT_CTL:\n\n        if (val & MIPSNET_INTCTL_TXDONE) {\n\n            s->intctl &= ~MIPSNET_INTCTL_TXDONE;\n\n        } else if (val & MIPSNET_INTCTL_RXDONE) {\n\n            s->intctl &= ~MIPSNET_INTCTL_RXDONE;\n\n        } else if (val & MIPSNET_INTCTL_TESTBIT) {\n\n            mipsnet_reset(s);\n\n            s->intctl |= MIPSNET_INTCTL_TESTBIT;\n\n        } else if (!val) {\n\n            /* ACK testbit interrupt, flag was cleared on read. */\n\n        }\n\n        s->busy = !!s->intctl;\n\n        mipsnet_update_irq(s);\n\n        if (mipsnet_can_receive(s->nic->ncs)) {\n\n            qemu_flush_queued_packets(qemu_get_queue(s->nic));\n\n        }\n\n        break;\n\n    case MIPSNET_TX_DATA_BUFFER:\n\n        s->tx_buffer[s->tx_written++] = val;\n\n        if (s->tx_written == s->tx_count) {\n\n            /* Send buffer. */\n\n            trace_mipsnet_send(s->tx_count);\n\n            qemu_send_packet(qemu_get_queue(s->nic), s->tx_buffer, s->tx_count);\n\n            s->tx_count = s->tx_written = 0;\n\n            s->intctl |= MIPSNET_INTCTL_TXDONE;\n\n            s->busy = 1;\n\n            mipsnet_update_irq(s);\n\n        }\n\n        break;\n\n    /* Read-only registers */\n\n    case MIPSNET_DEV_ID:\n\n    case MIPSNET_BUSY:\n\n    case MIPSNET_RX_DATA_COUNT:\n\n    case MIPSNET_INTERRUPT_INFO:\n\n    case MIPSNET_RX_DATA_BUFFER:\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 16243, "_split": "valid", "_hash": "58b5d96075cd9e548a1f6fe6be57991c"}
{"project": "qemu", "commit_id": "98ee9bedc734e18287902f39e3a3a8adb399386a", "target": 0, "func": "void ioinst_handle_stcrw(S390CPU *cpu, uint32_t ipb, uintptr_t ra)\n\n{\n\n    CRW crw;\n\n    uint64_t addr;\n\n    int cc;\n\n    CPUS390XState *env = &cpu->env;\n\n    uint8_t ar;\n\n\n\n    addr = decode_basedisp_s(env, ipb, &ar);\n\n    if (addr & 3) {\n\n        s390_program_interrupt(env, PGM_SPECIFICATION, 4, ra);\n\n        return;\n\n    }\n\n\n\n    cc = css_do_stcrw(&crw);\n\n    /* 0 - crw stored, 1 - zeroes stored */\n\n\n\n    if (s390_cpu_virt_mem_write(cpu, addr, ar, &crw, sizeof(crw)) == 0) {\n\n        setcc(cpu, cc);\n\n    } else if (cc == 0) {\n\n        /* Write failed: requeue CRW since STCRW is a suppressing instruction */\n\n        css_undo_stcrw(&crw);\n\n    }\n\n}\n", "idx": 16247, "_split": "valid", "_hash": "d8fb6663a20d58a80ef255552d17b2a0"}
{"project": "qemu", "commit_id": "ba14414174b72fa231997243a9650feaa520d054", "target": 0, "func": "static void migrate_put_status(QDict *qdict, const char *name,\n\n                               uint64_t trans, uint64_t rem, uint64_t total)\n\n{\n\n    QObject *obj;\n\n\n\n    obj = qobject_from_jsonf(\"{ 'transferred': %\" PRId64 \", \"\n\n                               \"'remaining': %\" PRId64 \", \"\n\n                               \"'total': %\" PRId64 \" }\", trans, rem, total);\n\n    assert(obj != NULL);\n\n\n\n    qdict_put_obj(qdict, name, obj);\n\n}\n", "idx": 16252, "_split": "valid", "_hash": "eb3c47a6ae621c8b7d6654d60b94158c"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "PCIBus *pci_apb_init(target_phys_addr_t special_base,\n\n                     target_phys_addr_t mem_base,\n\n                     qemu_irq *ivec_irqs, PCIBus **bus2, PCIBus **bus3,\n\n                     qemu_irq **pbm_irqs)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    APBState *d;\n\n    PCIDevice *pci_dev;\n\n    PCIBridge *br;\n\n\n\n    /* Ultrasparc PBM main bus */\n\n    dev = qdev_create(NULL, \"pbm\");\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    /* apb_config */\n\n    sysbus_mmio_map(s, 0, special_base);\n\n    /* PCI configuration space */\n\n    sysbus_mmio_map(s, 1, special_base + 0x1000000ULL);\n\n    /* pci_ioport */\n\n    sysbus_mmio_map(s, 2, special_base + 0x2000000ULL);\n\n    d = FROM_SYSBUS(APBState, s);\n\n\n\n    memory_region_init(&d->pci_mmio, \"pci-mmio\", 0x100000000ULL);\n\n    memory_region_add_subregion(get_system_memory(), mem_base, &d->pci_mmio);\n\n\n\n    d->bus = pci_register_bus(&d->busdev.qdev, \"pci\",\n\n                              pci_apb_set_irq, pci_pbm_map_irq, d,\n\n                              &d->pci_mmio,\n\n                              get_system_io(),\n\n                              0, 32);\n\n\n\n    *pbm_irqs = d->pbm_irqs;\n\n    d->ivec_irqs = ivec_irqs;\n\n\n\n    pci_create_simple(d->bus, 0, \"pbm-pci\");\n\n\n\n    /* APB secondary busses */\n\n    pci_dev = pci_create_multifunction(d->bus, PCI_DEVFN(1, 0), true,\n\n                                   \"pbm-bridge\");\n\n    br = DO_UPCAST(PCIBridge, dev, pci_dev);\n\n    pci_bridge_map_irq(br, \"Advanced PCI Bus secondary bridge 1\",\n\n                       pci_apb_map_irq);\n\n    qdev_init_nofail(&pci_dev->qdev);\n\n    *bus2 = pci_bridge_get_sec_bus(br);\n\n\n\n    pci_dev = pci_create_multifunction(d->bus, PCI_DEVFN(1, 1), true,\n\n                                   \"pbm-bridge\");\n\n    br = DO_UPCAST(PCIBridge, dev, pci_dev);\n\n    pci_bridge_map_irq(br, \"Advanced PCI Bus secondary bridge 2\",\n\n                       pci_apb_map_irq);\n\n    qdev_init_nofail(&pci_dev->qdev);\n\n    *bus3 = pci_bridge_get_sec_bus(br);\n\n\n\n    return d->bus;\n\n}\n", "idx": 16262, "_split": "valid", "_hash": "e8d8089055098f12184bfb1b630422c7"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static int coroutine_fn bdrv_co_do_copy_on_readv(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    /* Perform I/O through a temporary buffer so that users who scribble over\n\n     * their read buffer while the operation is in progress do not end up\n\n     * modifying the image file.  This is critical for zero-copy guest I/O\n\n     * where anything might happen inside guest memory.\n\n     */\n\n    void *bounce_buffer;\n\n\n\n    BlockDriver *drv = bs->drv;\n\n    struct iovec iov;\n\n    QEMUIOVector bounce_qiov;\n\n    int64_t cluster_sector_num;\n\n    int cluster_nb_sectors;\n\n    size_t skip_bytes;\n\n    int ret;\n\n\n\n    /* Cover entire cluster so no additional backing file I/O is required when\n\n     * allocating cluster in the image file.\n\n     */\n\n    bdrv_round_to_clusters(bs, sector_num, nb_sectors,\n\n                           &cluster_sector_num, &cluster_nb_sectors);\n\n\n\n    trace_bdrv_co_do_copy_on_readv(bs, sector_num, nb_sectors,\n\n                                   cluster_sector_num, cluster_nb_sectors);\n\n\n\n    iov.iov_len = cluster_nb_sectors * BDRV_SECTOR_SIZE;\n\n    iov.iov_base = bounce_buffer = qemu_try_blockalign(bs, iov.iov_len);\n\n    if (bounce_buffer == NULL) {\n\n        ret = -ENOMEM;\n\n        goto err;\n\n    }\n\n\n\n    qemu_iovec_init_external(&bounce_qiov, &iov, 1);\n\n\n\n    ret = drv->bdrv_co_readv(bs, cluster_sector_num, cluster_nb_sectors,\n\n                             &bounce_qiov);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    if (drv->bdrv_co_write_zeroes &&\n\n        buffer_is_zero(bounce_buffer, iov.iov_len)) {\n\n        ret = bdrv_co_do_write_zeroes(bs, cluster_sector_num,\n\n                                      cluster_nb_sectors, 0);\n\n    } else {\n\n        /* This does not change the data on the disk, it is not necessary\n\n         * to flush even in cache=writethrough mode.\n\n         */\n\n        ret = drv->bdrv_co_writev(bs, cluster_sector_num, cluster_nb_sectors,\n\n                                  &bounce_qiov);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        /* It might be okay to ignore write errors for guest requests.  If this\n\n         * is a deliberate copy-on-read then we don't want to ignore the error.\n\n         * Simply report it in all cases.\n\n         */\n\n        goto err;\n\n    }\n\n\n\n    skip_bytes = (sector_num - cluster_sector_num) * BDRV_SECTOR_SIZE;\n\n    qemu_iovec_from_buf(qiov, 0, bounce_buffer + skip_bytes,\n\n                        nb_sectors * BDRV_SECTOR_SIZE);\n\n\n\nerr:\n\n    qemu_vfree(bounce_buffer);\n\n    return ret;\n\n}\n", "idx": 16270, "_split": "valid", "_hash": "71d739af11594d0064eb34576bf08ed5"}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_input_stack_object_free(StackObject *tos)\n\n{\n\n    if (tos->h) {\n\n        g_hash_table_unref(tos->h);\n\n    }\n\n\n\n    g_free(tos);\n\n}\n", "idx": 16277, "_split": "valid", "_hash": "e239e8130bbe201a1ed9715420dfc8e3"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "bool timer_expired(QEMUTimer *timer_head, int64_t current_time)\n\n{\n\n    return timer_expired_ns(timer_head, current_time * timer_head->scale);\n\n}\n", "idx": 16279, "_split": "valid", "_hash": "8cf0872836e07f3334402a42ee2efd0a"}
{"project": "qemu", "commit_id": "ee25595f0126de0f83da86cc29ba2365be7a50d2", "target": 1, "func": "static void check_cmd(AHCIState *s, int port)\n\n{\n\n    AHCIPortRegs *pr = &s->dev[port].port_regs;\n\n    int slot;\n\n\n\n    if ((pr->cmd & PORT_CMD_START) && pr->cmd_issue) {\n\n        for (slot = 0; (slot < 32) && pr->cmd_issue; slot++) {\n\n            if ((pr->cmd_issue & (1 << slot)) &&\n\n                !handle_cmd(s, port, slot)) {\n\n                pr->cmd_issue &= ~(1 << slot);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 16283, "_split": "valid", "_hash": "978b010a3e34610b16f457019a7d7110"}
{"project": "qemu", "commit_id": "b11e20fb6c658bc13b2e4dfc1b86c2eb8731e374", "target": 1, "func": "static void cleanup_infolist(CommandLineParameterInfoList *head)\n\n{\n\n    CommandLineParameterInfoList *pre_entry, *cur, *del_entry;\n\n\n\n    cur = head;\n\n    while (cur->next) {\n\n        pre_entry = head;\n\n        while (pre_entry != cur->next) {\n\n            if (!strcmp(pre_entry->value->name, cur->next->value->name)) {\n\n                del_entry = cur->next;\n\n                cur->next = cur->next->next;\n\n                g_free(del_entry);\n\n                break;\n\n            }\n\n            pre_entry = pre_entry->next;\n\n        }\n\n        cur = cur->next;\n\n    }\n\n}\n", "idx": 16294, "_split": "valid", "_hash": "05939a54d965dce30116cd8f2e41f3fc"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static inline void gen_check_align(DisasContext *ctx, TCGv EA, int mask)\n\n{\n\n    int l1 = gen_new_label();\n\n    TCGv t0 = tcg_temp_new();\n\n    TCGv_i32 t1, t2;\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    tcg_gen_andi_tl(t0, EA, mask);\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);\n\n    t1 = tcg_const_i32(POWERPC_EXCP_ALIGN);\n\n    t2 = tcg_const_i32(0);\n\n    gen_helper_raise_exception_err(cpu_env, t1, t2);\n\n    tcg_temp_free_i32(t1);\n\n    tcg_temp_free_i32(t2);\n\n    gen_set_label(l1);\n\n    tcg_temp_free(t0);\n\n}\n", "idx": 16305, "_split": "valid", "_hash": "76ed924f55d30ad53b9e8bc671693b16"}
{"project": "qemu", "commit_id": "0c866a7ed47bc8a2df320e59bc669e4784d8ad2f", "target": 0, "func": "_syscall3(int,sys_faccessat,int,dirfd,const char *,pathname,int,mode)\n\n#endif\n\n#if defined(TARGET_NR_fchmodat) && defined(__NR_fchmodat)\n\n_syscall3(int,sys_fchmodat,int,dirfd,const char *,pathname, mode_t,mode)\n\n#endif\n\n#if defined(TARGET_NR_fchownat) && defined(__NR_fchownat) && defined(USE_UID16)\n\n_syscall5(int,sys_fchownat,int,dirfd,const char *,pathname,\n\n          uid_t,owner,gid_t,group,int,flags)\n\n#endif\n\n#if (defined(TARGET_NR_fstatat64) || defined(TARGET_NR_newfstatat)) && \\\n\n        defined(__NR_fstatat64)\n\n_syscall4(int,sys_fstatat64,int,dirfd,const char *,pathname,\n\n          struct stat *,buf,int,flags)\n\n#endif\n\n#if defined(TARGET_NR_futimesat) && defined(__NR_futimesat)\n\n_syscall3(int,sys_futimesat,int,dirfd,const char *,pathname,\n\n         const struct timeval *,times)\n\n#endif\n\n#if (defined(TARGET_NR_newfstatat) || defined(TARGET_NR_fstatat64) ) && \\\n\n        defined(__NR_newfstatat)\n\n_syscall4(int,sys_newfstatat,int,dirfd,const char *,pathname,\n\n          struct stat *,buf,int,flags)\n\n#endif\n\n#if defined(TARGET_NR_linkat) && defined(__NR_linkat)\n\n_syscall5(int,sys_linkat,int,olddirfd,const char *,oldpath,\n\n      int,newdirfd,const char *,newpath,int,flags)\n\n#endif\n\n#if defined(TARGET_NR_mkdirat) && defined(__NR_mkdirat)\n\n_syscall3(int,sys_mkdirat,int,dirfd,const char *,pathname,mode_t,mode)\n\n#endif\n\n#if defined(TARGET_NR_mknodat) && defined(__NR_mknodat)\n\n_syscall4(int,sys_mknodat,int,dirfd,const char *,pathname,\n\n          mode_t,mode,dev_t,dev)\n\n#endif\n\n#if defined(TARGET_NR_openat) && defined(__NR_openat)\n\n_syscall4(int,sys_openat,int,dirfd,const char *,pathname,int,flags,mode_t,mode)\n\n#endif\n\n#if defined(TARGET_NR_readlinkat) && defined(__NR_readlinkat)\n\n_syscall4(int,sys_readlinkat,int,dirfd,const char *,pathname,\n\n          char *,buf,size_t,bufsize)\n\n#endif\n\n#if defined(TARGET_NR_renameat) && defined(__NR_renameat)\n\n_syscall4(int,sys_renameat,int,olddirfd,const char *,oldpath,\n\n          int,newdirfd,const char *,newpath)\n\n#endif\n\n#if defined(TARGET_NR_symlinkat) && defined(__NR_symlinkat)\n\n_syscall3(int,sys_symlinkat,const char *,oldpath,\n\n          int,newdirfd,const char *,newpath)\n\n#endif\n\n#if defined(TARGET_NR_unlinkat) && defined(__NR_unlinkat)\n\n_syscall3(int,sys_unlinkat,int,dirfd,const char *,pathname,int,flags)\n\n#endif\n\n\n\n#endif /* CONFIG_ATFILE */\n\n\n\n#ifdef CONFIG_UTIMENSAT\n\nstatic int sys_utimensat(int dirfd, const char *pathname,\n\n    const struct timespec times[2], int flags)\n\n{\n\n    if (pathname == NULL)\n\n        return futimens(dirfd, times);\n\n    else\n\n        return utimensat(dirfd, pathname, times, flags);\n\n}\n", "idx": 16307, "_split": "valid", "_hash": "ec2ee7a9e9a11dd191d56174fb6591fa"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int64_t bdrv_nb_sectors(BlockDriverState *bs)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n\n\n    if (drv->has_variable_length) {\n\n        int ret = refresh_total_sectors(bs, bs->total_sectors);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    return bs->total_sectors;\n\n}\n", "idx": 16319, "_split": "valid", "_hash": "c4a2c76797c0926ea63b55af74fca899"}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void udp_chr_update_read_handler(CharDriverState *chr)\n\n{\n\n    NetCharDriver *s = chr->opaque;\n\n\n\n    if (s->tag) {\n\n        g_source_remove(s->tag);\n\n        s->tag = 0;\n\n    }\n\n\n\n    if (s->chan) {\n\n        s->tag = io_add_watch_poll(s->chan, udp_chr_read_poll, udp_chr_read, chr);\n\n    }\n\n}\n", "idx": 16339, "_split": "valid", "_hash": "899d40019dff9a980df7287fc0aea114"}
{"project": "qemu", "commit_id": "f47291b7a7ffa8854300283d4773ed17d5d581c1", "target": 1, "func": "void qemu_system_guest_panicked(GuestPanicInformation *info)\n{\n    if (current_cpu) {\n        current_cpu->crash_occurred = true;\n    }\n    qapi_event_send_guest_panicked(GUEST_PANIC_ACTION_PAUSE,\n                                   !!info, info, &error_abort);\n    vm_stop(RUN_STATE_GUEST_PANICKED);\n    if (!no_shutdown) {\n        qapi_event_send_guest_panicked(GUEST_PANIC_ACTION_POWEROFF,\n                                       !!info, info, &error_abort);\n        qemu_system_shutdown_request();\n    }\n    if (info) {\n        if (info->type == GUEST_PANIC_INFORMATION_KIND_HYPER_V) {\n            qemu_log_mask(LOG_GUEST_ERROR, \"HV crash parameters: (%#\"PRIx64\n                          \" %#\"PRIx64\" %#\"PRIx64\" %#\"PRIx64\" %#\"PRIx64\")\\n\",\n                          info->u.hyper_v.data->arg1,\n                          info->u.hyper_v.data->arg2,\n                          info->u.hyper_v.data->arg3,\n                          info->u.hyper_v.data->arg4,\n                          info->u.hyper_v.data->arg5);\n        }\n        qapi_free_GuestPanicInformation(info);\n    }\n}", "idx": 16348, "_split": "valid", "_hash": "c12f2eb49d1a057f69c8ecdc23adfc41"}
{"project": "qemu", "commit_id": "7102fa7073b2cefb33ab4012a11f15fbf297a74b", "target": 0, "func": "static void pc_compat_0_13(MachineState *machine)\n\n{\n\n    pc_compat_1_2(machine);\n\n    kvmclock_enabled = false;\n\n}\n", "idx": 16396, "_split": "valid", "_hash": "2d92974eb6015faf011ed5d9550a6ead"}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_gdbserver(int argc, const char **argv)\n\n{\n\n    int port;\n\n\n\n    port = DEFAULT_GDBSTUB_PORT;\n\n    if (argc >= 2)\n\n        port = atoi(argv[1]);\n\n    if (gdbserver_start(port) < 0) {\n\n        qemu_printf(\"Could not open gdbserver socket on port %d\\n\", port);\n\n    } else {\n\n        qemu_printf(\"Waiting gdb connection on port %d\\n\", port);\n\n    }\n\n}\n", "idx": 16408, "_split": "valid", "_hash": "c0f5dcf88d7a48cb2d624cd61ce056e2"}
{"project": "qemu", "commit_id": "8917c3bdba37d6fe4393db0fad3fabbde9530d6b", "target": 0, "func": "sofcantsendmore(struct socket *so)\n\n{\n\n\tif ((so->so_state & SS_NOFDREF) == 0) {\n\n            shutdown(so->s,1);           /* send FIN to fhost */\n\n            if (global_readfds) {\n\n                FD_CLR(so->s,global_readfds);\n\n            }\n\n            if (global_xfds) {\n\n                FD_CLR(so->s,global_xfds);\n\n            }\n\n\t}\n\n\tso->so_state &= ~(SS_ISFCONNECTING);\n\n\tif (so->so_state & SS_FCANTRCVMORE) {\n\n\t   so->so_state &= SS_PERSISTENT_MASK;\n\n\t   so->so_state |= SS_NOFDREF; /* as above */\n\n\t} else {\n\n\t   so->so_state |= SS_FCANTSENDMORE;\n\n\t}\n\n}\n", "idx": 16409, "_split": "valid", "_hash": "a4bcfb0c77f2758c81e153b8754e3063"}
{"project": "qemu", "commit_id": "7385ac0ba2456159a52b9b2cbb5f6c71921d0c23", "target": 0, "func": "static void gen_mtc0 (CPUState *env, DisasContext *ctx, int reg, int sel)\n\n{\n\n    const char *rn = \"invalid\";\n\n\n\n    if (sel != 0)\n\n        check_insn(env, ctx, ISA_MIPS32);\n\n\n\n    switch (reg) {\n\n    case 0:\n\n        switch (sel) {\n\n        case 0:\n\n           gen_op_mtc0_index();\n\n            rn = \"Index\";\n\n            break;\n\n        case 1:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_mvpcontrol();\n\n            rn = \"MVPControl\";\n\n            break;\n\n        case 2:\n\n            check_mips_mt(env, ctx);\n\n            /* ignored */\n\n            rn = \"MVPConf0\";\n\n            break;\n\n        case 3:\n\n            check_mips_mt(env, ctx);\n\n            /* ignored */\n\n            rn = \"MVPConf1\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 1:\n\n        switch (sel) {\n\n        case 0:\n\n            /* ignored */\n\n            rn = \"Random\";\n\n            break;\n\n        case 1:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_vpecontrol();\n\n            rn = \"VPEControl\";\n\n            break;\n\n        case 2:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_vpeconf0();\n\n            rn = \"VPEConf0\";\n\n            break;\n\n        case 3:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_vpeconf1();\n\n            rn = \"VPEConf1\";\n\n            break;\n\n        case 4:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_yqmask();\n\n            rn = \"YQMask\";\n\n            break;\n\n        case 5:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_vpeschedule();\n\n            rn = \"VPESchedule\";\n\n            break;\n\n        case 6:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_vpeschefback();\n\n            rn = \"VPEScheFBack\";\n\n            break;\n\n        case 7:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_vpeopt();\n\n            rn = \"VPEOpt\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 2:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_entrylo0();\n\n            rn = \"EntryLo0\";\n\n            break;\n\n        case 1:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_tcstatus();\n\n            rn = \"TCStatus\";\n\n            break;\n\n        case 2:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_tcbind();\n\n            rn = \"TCBind\";\n\n            break;\n\n        case 3:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_tcrestart();\n\n            rn = \"TCRestart\";\n\n            break;\n\n        case 4:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_tchalt();\n\n            rn = \"TCHalt\";\n\n            break;\n\n        case 5:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_tccontext();\n\n            rn = \"TCContext\";\n\n            break;\n\n        case 6:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_tcschedule();\n\n            rn = \"TCSchedule\";\n\n            break;\n\n        case 7:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_tcschefback();\n\n            rn = \"TCScheFBack\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 3:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_entrylo1();\n\n            rn = \"EntryLo1\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 4:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_context();\n\n            rn = \"Context\";\n\n            break;\n\n        case 1:\n\n//            gen_op_mtc0_contextconfig(); /* SmartMIPS ASE */\n\n            rn = \"ContextConfig\";\n\n//            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 5:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_pagemask();\n\n            rn = \"PageMask\";\n\n            break;\n\n        case 1:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_pagegrain();\n\n            rn = \"PageGrain\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 6:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_wired();\n\n            rn = \"Wired\";\n\n            break;\n\n        case 1:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_srsconf0();\n\n            rn = \"SRSConf0\";\n\n            break;\n\n        case 2:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_srsconf1();\n\n            rn = \"SRSConf1\";\n\n            break;\n\n        case 3:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_srsconf2();\n\n            rn = \"SRSConf2\";\n\n            break;\n\n        case 4:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_srsconf3();\n\n            rn = \"SRSConf3\";\n\n            break;\n\n        case 5:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_srsconf4();\n\n            rn = \"SRSConf4\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 7:\n\n        switch (sel) {\n\n        case 0:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_hwrena();\n\n            rn = \"HWREna\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 8:\n\n        /* ignored */\n\n        rn = \"BadVaddr\";\n\n        break;\n\n    case 9:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_count();\n\n            rn = \"Count\";\n\n            break;\n\n        /* 6,7 are implementation dependent */\n\n        default:\n\n            goto die;\n\n        }\n\n        /* Stop translation as we may have switched the execution mode */\n\n        ctx->bstate = BS_STOP;\n\n        break;\n\n    case 10:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_entryhi();\n\n            rn = \"EntryHi\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 11:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_compare();\n\n            rn = \"Compare\";\n\n            break;\n\n        /* 6,7 are implementation dependent */\n\n        default:\n\n            goto die;\n\n        }\n\n        /* Stop translation as we may have switched the execution mode */\n\n        ctx->bstate = BS_STOP;\n\n        break;\n\n    case 12:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_status();\n\n            /* BS_STOP isn't good enough here, hflags may have changed. */\n\n            gen_save_pc(ctx->pc + 4);\n\n            ctx->bstate = BS_EXCP;\n\n            rn = \"Status\";\n\n            break;\n\n        case 1:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_intctl();\n\n            /* Stop translation as we may have switched the execution mode */\n\n            ctx->bstate = BS_STOP;\n\n            rn = \"IntCtl\";\n\n            break;\n\n        case 2:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_srsctl();\n\n            /* Stop translation as we may have switched the execution mode */\n\n            ctx->bstate = BS_STOP;\n\n            rn = \"SRSCtl\";\n\n            break;\n\n        case 3:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_srsmap();\n\n            /* Stop translation as we may have switched the execution mode */\n\n            ctx->bstate = BS_STOP;\n\n            rn = \"SRSMap\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 13:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_cause();\n\n            rn = \"Cause\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        /* Stop translation as we may have switched the execution mode */\n\n        ctx->bstate = BS_STOP;\n\n        break;\n\n    case 14:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_epc();\n\n            rn = \"EPC\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 15:\n\n        switch (sel) {\n\n        case 0:\n\n            /* ignored */\n\n            rn = \"PRid\";\n\n            break;\n\n        case 1:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_ebase();\n\n            rn = \"EBase\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 16:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_config0();\n\n            rn = \"Config\";\n\n            /* Stop translation as we may have switched the execution mode */\n\n            ctx->bstate = BS_STOP;\n\n            break;\n\n        case 1:\n\n            /* ignored, read only */\n\n            rn = \"Config1\";\n\n            break;\n\n        case 2:\n\n            gen_op_mtc0_config2();\n\n            rn = \"Config2\";\n\n            /* Stop translation as we may have switched the execution mode */\n\n            ctx->bstate = BS_STOP;\n\n            break;\n\n        case 3:\n\n            /* ignored, read only */\n\n            rn = \"Config3\";\n\n            break;\n\n        /* 4,5 are reserved */\n\n        /* 6,7 are implementation dependent */\n\n        case 6:\n\n            /* ignored */\n\n            rn = \"Config6\";\n\n            break;\n\n        case 7:\n\n            /* ignored */\n\n            rn = \"Config7\";\n\n            break;\n\n        default:\n\n            rn = \"Invalid config selector\";\n\n            goto die;\n\n        }\n\n        break;\n\n    case 17:\n\n        switch (sel) {\n\n        case 0:\n\n            /* ignored */\n\n            rn = \"LLAddr\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 18:\n\n        switch (sel) {\n\n        case 0 ... 7:\n\n            gen_op_mtc0_watchlo(sel);\n\n            rn = \"WatchLo\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 19:\n\n        switch (sel) {\n\n        case 0 ... 7:\n\n            gen_op_mtc0_watchhi(sel);\n\n            rn = \"WatchHi\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 20:\n\n        switch (sel) {\n\n        case 0:\n\n#if defined(TARGET_MIPSN32) || defined(TARGET_MIPS64)\n\n            check_insn(env, ctx, ISA_MIPS3);\n\n            gen_op_mtc0_xcontext();\n\n            rn = \"XContext\";\n\n            break;\n\n#endif\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 21:\n\n       /* Officially reserved, but sel 0 is used for R1x000 framemask */\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_framemask();\n\n            rn = \"Framemask\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 22:\n\n        /* ignored */\n\n        rn = \"Diagnostic\"; /* implementation dependent */\n\n        break;\n\n    case 23:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_debug(); /* EJTAG support */\n\n            /* BS_STOP isn't good enough here, hflags may have changed. */\n\n            gen_save_pc(ctx->pc + 4);\n\n            ctx->bstate = BS_EXCP;\n\n            rn = \"Debug\";\n\n            break;\n\n        case 1:\n\n//            gen_op_mtc0_tracecontrol(); /* PDtrace support */\n\n            rn = \"TraceControl\";\n\n            /* Stop translation as we may have switched the execution mode */\n\n            ctx->bstate = BS_STOP;\n\n//            break;\n\n        case 2:\n\n//            gen_op_mtc0_tracecontrol2(); /* PDtrace support */\n\n            rn = \"TraceControl2\";\n\n            /* Stop translation as we may have switched the execution mode */\n\n            ctx->bstate = BS_STOP;\n\n//            break;\n\n        case 3:\n\n            /* Stop translation as we may have switched the execution mode */\n\n            ctx->bstate = BS_STOP;\n\n//            gen_op_mtc0_usertracedata(); /* PDtrace support */\n\n            rn = \"UserTraceData\";\n\n            /* Stop translation as we may have switched the execution mode */\n\n            ctx->bstate = BS_STOP;\n\n//            break;\n\n        case 4:\n\n//            gen_op_mtc0_debug(); /* PDtrace support */\n\n            /* Stop translation as we may have switched the execution mode */\n\n            ctx->bstate = BS_STOP;\n\n            rn = \"TraceBPC\";\n\n//            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 24:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_depc(); /* EJTAG support */\n\n            rn = \"DEPC\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 25:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_performance0();\n\n            rn = \"Performance0\";\n\n            break;\n\n        case 1:\n\n//            gen_op_mtc0_performance1();\n\n            rn = \"Performance1\";\n\n//            break;\n\n        case 2:\n\n//            gen_op_mtc0_performance2();\n\n            rn = \"Performance2\";\n\n//            break;\n\n        case 3:\n\n//            gen_op_mtc0_performance3();\n\n            rn = \"Performance3\";\n\n//            break;\n\n        case 4:\n\n//            gen_op_mtc0_performance4();\n\n            rn = \"Performance4\";\n\n//            break;\n\n        case 5:\n\n//            gen_op_mtc0_performance5();\n\n            rn = \"Performance5\";\n\n//            break;\n\n        case 6:\n\n//            gen_op_mtc0_performance6();\n\n            rn = \"Performance6\";\n\n//            break;\n\n        case 7:\n\n//            gen_op_mtc0_performance7();\n\n            rn = \"Performance7\";\n\n//            break;\n\n        default:\n\n            goto die;\n\n        }\n\n       break;\n\n    case 26:\n\n        /* ignored */\n\n        rn = \"ECC\";\n\n        break;\n\n    case 27:\n\n        switch (sel) {\n\n        case 0 ... 3:\n\n            /* ignored */\n\n            rn = \"CacheErr\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n       break;\n\n    case 28:\n\n        switch (sel) {\n\n        case 0:\n\n        case 2:\n\n        case 4:\n\n        case 6:\n\n            gen_op_mtc0_taglo();\n\n            rn = \"TagLo\";\n\n            break;\n\n        case 1:\n\n        case 3:\n\n        case 5:\n\n        case 7:\n\n            gen_op_mtc0_datalo();\n\n            rn = \"DataLo\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 29:\n\n        switch (sel) {\n\n        case 0:\n\n        case 2:\n\n        case 4:\n\n        case 6:\n\n            gen_op_mtc0_taghi();\n\n            rn = \"TagHi\";\n\n            break;\n\n        case 1:\n\n        case 3:\n\n        case 5:\n\n        case 7:\n\n            gen_op_mtc0_datahi();\n\n            rn = \"DataHi\";\n\n            break;\n\n        default:\n\n            rn = \"invalid sel\";\n\n            goto die;\n\n        }\n\n       break;\n\n    case 30:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_errorepc();\n\n            rn = \"ErrorEPC\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 31:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_desave(); /* EJTAG support */\n\n            rn = \"DESAVE\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        /* Stop translation as we may have switched the execution mode */\n\n        ctx->bstate = BS_STOP;\n\n        break;\n\n    default:\n\n       goto die;\n\n    }\n\n#if defined MIPS_DEBUG_DISAS\n\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n        fprintf(logfile, \"mtc0 %s (reg %d sel %d)\\n\",\n\n                rn, reg, sel);\n\n    }\n\n#endif\n\n    return;\n\n\n\ndie:\n\n#if defined MIPS_DEBUG_DISAS\n\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n        fprintf(logfile, \"mtc0 %s (reg %d sel %d)\\n\",\n\n                rn, reg, sel);\n\n    }\n\n#endif\n\n    generate_exception(ctx, EXCP_RI);\n\n}\n", "idx": 16411, "_split": "valid", "_hash": "26bf8c6e3b044ab924ccf01e4c7c1ec8"}
{"project": "qemu", "commit_id": "c4d9d19645a484298a67e9021060bc7c2b081d0f", "target": 0, "func": "static void thread_pool_init(void)\n\n{\n\n    thread_pool_init_one(&global_pool, NULL);\n\n}\n", "idx": 16414, "_split": "valid", "_hash": "11865f3c6b0fd39087d43358f603c8e5"}
{"project": "qemu", "commit_id": "f897bf751fbd95e4015b95d202c706548586813a", "target": 1, "func": "static void handle_notify(EventNotifier *e)\n\n{\n\n    VirtIOBlockDataPlane *s = container_of(e, VirtIOBlockDataPlane,\n\n                                           host_notifier);\n\n\n\n    VirtQueueElement *elem;\n\n    VirtIOBlockReq *req;\n\n    int ret;\n\n    MultiReqBuffer mrb = {\n\n        .num_writes = 0,\n\n    };\n\n\n\n    event_notifier_test_and_clear(&s->host_notifier);\n\n    bdrv_io_plug(s->blk->conf.bs);\n\n    for (;;) {\n\n        /* Disable guest->host notifies to avoid unnecessary vmexits */\n\n        vring_disable_notification(s->vdev, &s->vring);\n\n\n\n        for (;;) {\n\n            ret = vring_pop(s->vdev, &s->vring, &elem);\n\n            if (ret < 0) {\n\n                assert(elem == NULL);\n\n                break; /* no more requests */\n\n            }\n\n\n\n            trace_virtio_blk_data_plane_process_request(s, elem->out_num,\n\n                                                        elem->in_num, elem->index);\n\n\n\n            req = g_slice_new(VirtIOBlockReq);\n\n            req->dev = VIRTIO_BLK(s->vdev);\n\n            req->elem = elem;\n\n            virtio_blk_handle_request(req, &mrb);\n\n        }\n\n\n\n        virtio_submit_multiwrite(s->blk->conf.bs, &mrb);\n\n\n\n        if (likely(ret == -EAGAIN)) { /* vring emptied */\n\n            /* Re-enable guest->host notifies and stop processing the vring.\n\n             * But if the guest has snuck in more descriptors, keep processing.\n\n             */\n\n            if (vring_enable_notification(s->vdev, &s->vring)) {\n\n                break;\n\n            }\n\n        } else { /* fatal error */\n\n            break;\n\n        }\n\n    }\n\n    bdrv_io_unplug(s->blk->conf.bs);\n\n}\n", "idx": 16425, "_split": "valid", "_hash": "5dcc391146cee4a23c797d1d40e9dd9b"}
{"project": "qemu", "commit_id": "d2164ad35c411d97abd2aa5c6f160283d215e214", "target": 1, "func": "static int get_int32_equal(QEMUFile *f, void *pv, size_t size,\n\n                           VMStateField *field)\n\n{\n\n    int32_t *v = pv;\n\n    int32_t v2;\n\n    qemu_get_sbe32s(f, &v2);\n\n\n\n    if (*v == v2) {\n\n        return 0;\n\n\n    error_report(\"%\" PRIx32 \" != %\" PRIx32, *v, v2);\n\n\n\n\n    return -EINVAL;\n", "idx": 16427, "_split": "valid", "_hash": "60e7667ef1669a1b0ccf6d547dc1fbdb"}
{"project": "qemu", "commit_id": "eca1bdf415c454093dfc7eb983cd49287c043967", "target": 1, "func": "static void cpu_sh4_reset(CPUSH4State * env)\n{\n#if defined(CONFIG_USER_ONLY)\n    env->sr = 0;\n#else\n    env->sr = SR_MD | SR_RB | SR_BL | SR_I3 | SR_I2 | SR_I1 | SR_I0;\n#endif\n    env->vbr = 0;\n    env->pc = 0xA0000000;\n#if defined(CONFIG_USER_ONLY)\n    env->fpscr = FPSCR_PR; /* value for userspace according to the kernel */\n    set_float_rounding_mode(float_round_nearest_even, &env->fp_status); /* ?! */\n#else\n    env->fpscr = 0x00040001; /* CPU reset value according to SH4 manual */\n    set_float_rounding_mode(float_round_to_zero, &env->fp_status);\n#endif\n    env->mmucr = 0;", "idx": 16468, "_split": "valid", "_hash": "00b302b0b498d0ac5d50e1a42df2b10d"}
{"project": "qemu", "commit_id": "57407ea44cc0a3d630b9b89a2be011f1955ce5c1", "target": 0, "func": "static void spapr_vlan_cleanup(NetClientState *nc)\n\n{\n\n    VIOsPAPRVLANDevice *dev = qemu_get_nic_opaque(nc);\n\n\n\n    dev->nic = NULL;\n\n}\n", "idx": 16484, "_split": "valid", "_hash": "29f06a21d5b015be6cded94f8f53b403"}
{"project": "qemu", "commit_id": "cee40d2d2dda87fd9705ed4b85e2c0cf0e5c2ac4", "target": 0, "func": "BlockDriverAIOCB *win32_aio_submit(BlockDriverState *bs,\n\n        QEMUWin32AIOState *aio, HANDLE hfile,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque, int type)\n\n{\n\n    struct QEMUWin32AIOCB *waiocb;\n\n    uint64_t offset = sector_num * 512;\n\n    DWORD rc;\n\n\n\n    waiocb = qemu_aio_get(&win32_aio_pool, bs, cb, opaque);\n\n    waiocb->nbytes = nb_sectors * 512;\n\n    waiocb->qiov = qiov;\n\n    waiocb->is_read = (type == QEMU_AIO_READ);\n\n\n\n    if (qiov->niov > 1) {\n\n        waiocb->buf = qemu_blockalign(bs, qiov->size);\n\n        if (type & QEMU_AIO_WRITE) {\n\n            char *p = waiocb->buf;\n\n            int i;\n\n\n\n            for (i = 0; i < qiov->niov; ++i) {\n\n                memcpy(p, qiov->iov[i].iov_base, qiov->iov[i].iov_len);\n\n                p += qiov->iov[i].iov_len;\n\n            }\n\n        }\n\n        waiocb->is_linear = false;\n\n    } else {\n\n        waiocb->buf = qiov->iov[0].iov_base;\n\n        waiocb->is_linear = true;\n\n    }\n\n\n\n    waiocb->ov = (OVERLAPPED) {\n\n        .Offset = (DWORD) offset,\n\n        .OffsetHigh = (DWORD) (offset >> 32),\n\n        .hEvent = event_notifier_get_handle(&aio->e)\n\n    };\n\n    aio->count++;\n\n\n\n    if (type & QEMU_AIO_READ) {\n\n        rc = ReadFile(hfile, waiocb->buf, waiocb->nbytes, NULL, &waiocb->ov);\n\n    } else {\n\n        rc = WriteFile(hfile, waiocb->buf, waiocb->nbytes, NULL, &waiocb->ov);\n\n    }\n\n    if(rc == 0 && GetLastError() != ERROR_IO_PENDING) {\n\n        goto out_dec_count;\n\n    }\n\n    return &waiocb->common;\n\n\n\nout_dec_count:\n\n    aio->count--;\n\n    qemu_aio_release(waiocb);\n\n    return NULL;\n\n}\n", "idx": 16487, "_split": "valid", "_hash": "6fa02a665db573ff0563a367faee9de5"}
{"project": "qemu", "commit_id": "031380d8770d2df6c386e4aeabd412007d3ebd54", "target": 0, "func": "static int blkdebug_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    int ret;\n\n    char *config, *c;\n\n\n\n    /* Parse the blkdebug: prefix */\n\n    if (strncmp(filename, \"blkdebug:\", strlen(\"blkdebug:\"))) {\n\n        return -EINVAL;\n\n    }\n\n    filename += strlen(\"blkdebug:\");\n\n\n\n    /* Read rules from config file */\n\n    c = strchr(filename, ':');\n\n    if (c == NULL) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    config = strdup(filename);\n\n    config[c - filename] = '\\0';\n\n    ret = read_config(s, config);\n\n    free(config);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    filename = c + 1;\n\n\n\n    /* Set initial state */\n\n    s->vars.state = 1;\n\n\n\n    /* Open the backing file */\n\n    ret = bdrv_file_open(&bs->file, filename, flags);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 16500, "_split": "valid", "_hash": "287c9253697a5e8883a9f3b859fa610b"}
{"project": "qemu", "commit_id": "b172c56a6d849554f7e43adc95983a9d6c042689", "target": 0, "func": "void cpu_loop(CPUPPCState *env)\n\n{\n\n    target_siginfo_t info;\n\n    int trapnr;\n\n    uint32_t ret;\n\n\n\n    for(;;) {\n\n        trapnr = cpu_ppc_exec(env);\n\n        switch(trapnr) {\n\n        case POWERPC_EXCP_NONE:\n\n            /* Just go on */\n\n            break;\n\n        case POWERPC_EXCP_CRITICAL: /* Critical input                        */\n\n            cpu_abort(env, \"Critical interrupt while in user mode. \"\n\n                      \"Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_MCHECK:   /* Machine check exception               */\n\n            cpu_abort(env, \"Machine check exception while in user mode. \"\n\n                      \"Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_DSI:      /* Data storage exception                */\n\n            EXCP_DUMP(env, \"Invalid data memory access: 0x\" ADDRX \"\\n\",\n\n                      env->spr[SPR_DAR]);\n\n            /* XXX: check this. Seems bugged */\n\n            switch (env->error_code & 0xFF000000) {\n\n            case 0x40000000:\n\n                info.si_signo = TARGET_SIGSEGV;\n\n                info.si_errno = 0;\n\n                info.si_code = TARGET_SEGV_MAPERR;\n\n                break;\n\n            case 0x04000000:\n\n                info.si_signo = TARGET_SIGILL;\n\n                info.si_errno = 0;\n\n                info.si_code = TARGET_ILL_ILLADR;\n\n                break;\n\n            case 0x08000000:\n\n                info.si_signo = TARGET_SIGSEGV;\n\n                info.si_errno = 0;\n\n                info.si_code = TARGET_SEGV_ACCERR;\n\n                break;\n\n            default:\n\n                /* Let's send a regular segfault... */\n\n                EXCP_DUMP(env, \"Invalid segfault errno (%02x)\\n\",\n\n                          env->error_code);\n\n                info.si_signo = TARGET_SIGSEGV;\n\n                info.si_errno = 0;\n\n                info.si_code = TARGET_SEGV_MAPERR;\n\n                break;\n\n            }\n\n            info._sifields._sigfault._addr = env->nip;\n\n            queue_signal(info.si_signo, &info);\n\n            break;\n\n        case POWERPC_EXCP_ISI:      /* Instruction storage exception         */\n\n            EXCP_DUMP(env, \"Invalid instruction fetch: 0x\\n\" ADDRX \"\\n\",\n\n                      env->spr[SPR_SRR0]);\n\n            /* XXX: check this */\n\n            switch (env->error_code & 0xFF000000) {\n\n            case 0x40000000:\n\n                info.si_signo = TARGET_SIGSEGV;\n\n            info.si_errno = 0;\n\n                info.si_code = TARGET_SEGV_MAPERR;\n\n                break;\n\n            case 0x10000000:\n\n            case 0x08000000:\n\n                info.si_signo = TARGET_SIGSEGV;\n\n                info.si_errno = 0;\n\n                info.si_code = TARGET_SEGV_ACCERR;\n\n                break;\n\n            default:\n\n                /* Let's send a regular segfault... */\n\n                EXCP_DUMP(env, \"Invalid segfault errno (%02x)\\n\",\n\n                          env->error_code);\n\n                info.si_signo = TARGET_SIGSEGV;\n\n                info.si_errno = 0;\n\n                info.si_code = TARGET_SEGV_MAPERR;\n\n                break;\n\n            }\n\n            info._sifields._sigfault._addr = env->nip - 4;\n\n            queue_signal(info.si_signo, &info);\n\n            break;\n\n        case POWERPC_EXCP_EXTERNAL: /* External input                        */\n\n            cpu_abort(env, \"External interrupt while in user mode. \"\n\n                      \"Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_ALIGN:    /* Alignment exception                   */\n\n            EXCP_DUMP(env, \"Unaligned memory access\\n\");\n\n            /* XXX: check this */\n\n            info.si_signo = TARGET_SIGBUS;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_BUS_ADRALN;\n\n            info._sifields._sigfault._addr = env->nip - 4;\n\n            queue_signal(info.si_signo, &info);\n\n            break;\n\n        case POWERPC_EXCP_PROGRAM:  /* Program exception                     */\n\n            /* XXX: check this */\n\n            switch (env->error_code & ~0xF) {\n\n            case POWERPC_EXCP_FP:\n\n                EXCP_DUMP(env, \"Floating point program exception\\n\");\n\n                info.si_signo = TARGET_SIGFPE;\n\n                info.si_errno = 0;\n\n                switch (env->error_code & 0xF) {\n\n                case POWERPC_EXCP_FP_OX:\n\n                    info.si_code = TARGET_FPE_FLTOVF;\n\n                    break;\n\n                case POWERPC_EXCP_FP_UX:\n\n                    info.si_code = TARGET_FPE_FLTUND;\n\n                    break;\n\n                case POWERPC_EXCP_FP_ZX:\n\n                case POWERPC_EXCP_FP_VXZDZ:\n\n                    info.si_code = TARGET_FPE_FLTDIV;\n\n                    break;\n\n                case POWERPC_EXCP_FP_XX:\n\n                    info.si_code = TARGET_FPE_FLTRES;\n\n                    break;\n\n                case POWERPC_EXCP_FP_VXSOFT:\n\n                    info.si_code = TARGET_FPE_FLTINV;\n\n                    break;\n\n                case POWERPC_EXCP_FP_VXSNAN:\n\n                case POWERPC_EXCP_FP_VXISI:\n\n                case POWERPC_EXCP_FP_VXIDI:\n\n                case POWERPC_EXCP_FP_VXIMZ:\n\n                case POWERPC_EXCP_FP_VXVC:\n\n                case POWERPC_EXCP_FP_VXSQRT:\n\n                case POWERPC_EXCP_FP_VXCVI:\n\n                    info.si_code = TARGET_FPE_FLTSUB;\n\n                    break;\n\n                default:\n\n                    EXCP_DUMP(env, \"Unknown floating point exception (%02x)\\n\",\n\n                              env->error_code);\n\n                    break;\n\n                }\n\n                break;\n\n            case POWERPC_EXCP_INVAL:\n\n                EXCP_DUMP(env, \"Invalid instruction\\n\");\n\n                info.si_signo = TARGET_SIGILL;\n\n                info.si_errno = 0;\n\n                switch (env->error_code & 0xF) {\n\n                case POWERPC_EXCP_INVAL_INVAL:\n\n                    info.si_code = TARGET_ILL_ILLOPC;\n\n                    break;\n\n                case POWERPC_EXCP_INVAL_LSWX:\n\n                    info.si_code = TARGET_ILL_ILLOPN;\n\n                    break;\n\n                case POWERPC_EXCP_INVAL_SPR:\n\n                    info.si_code = TARGET_ILL_PRVREG;\n\n                    break;\n\n                case POWERPC_EXCP_INVAL_FP:\n\n                    info.si_code = TARGET_ILL_COPROC;\n\n                    break;\n\n                default:\n\n                    EXCP_DUMP(env, \"Unknown invalid operation (%02x)\\n\",\n\n                              env->error_code & 0xF);\n\n                    info.si_code = TARGET_ILL_ILLADR;\n\n                    break;\n\n                }\n\n                break;\n\n            case POWERPC_EXCP_PRIV:\n\n                EXCP_DUMP(env, \"Privilege violation\\n\");\n\n                info.si_signo = TARGET_SIGILL;\n\n                info.si_errno = 0;\n\n                switch (env->error_code & 0xF) {\n\n                case POWERPC_EXCP_PRIV_OPC:\n\n                    info.si_code = TARGET_ILL_PRVOPC;\n\n                    break;\n\n                case POWERPC_EXCP_PRIV_REG:\n\n                    info.si_code = TARGET_ILL_PRVREG;\n\n                    break;\n\n                default:\n\n                    EXCP_DUMP(env, \"Unknown privilege violation (%02x)\\n\",\n\n                              env->error_code & 0xF);\n\n                    info.si_code = TARGET_ILL_PRVOPC;\n\n                    break;\n\n                }\n\n                break;\n\n            case POWERPC_EXCP_TRAP:\n\n                cpu_abort(env, \"Tried to call a TRAP\\n\");\n\n                break;\n\n            default:\n\n                /* Should not happen ! */\n\n                cpu_abort(env, \"Unknown program exception (%02x)\\n\",\n\n                          env->error_code);\n\n                break;\n\n            }\n\n            info._sifields._sigfault._addr = env->nip - 4;\n\n            queue_signal(info.si_signo, &info);\n\n            break;\n\n        case POWERPC_EXCP_FPU:      /* Floating-point unavailable exception  */\n\n            EXCP_DUMP(env, \"No floating point allowed\\n\");\n\n            info.si_signo = TARGET_SIGILL;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_ILL_COPROC;\n\n            info._sifields._sigfault._addr = env->nip - 4;\n\n            queue_signal(info.si_signo, &info);\n\n            break;\n\n        case POWERPC_EXCP_SYSCALL:  /* System call exception                 */\n\n            cpu_abort(env, \"Syscall exception while in user mode. \"\n\n                      \"Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_APU:      /* Auxiliary processor unavailable       */\n\n            EXCP_DUMP(env, \"No APU instruction allowed\\n\");\n\n            info.si_signo = TARGET_SIGILL;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_ILL_COPROC;\n\n            info._sifields._sigfault._addr = env->nip - 4;\n\n            queue_signal(info.si_signo, &info);\n\n            break;\n\n        case POWERPC_EXCP_DECR:     /* Decrementer exception                 */\n\n            cpu_abort(env, \"Decrementer interrupt while in user mode. \"\n\n                      \"Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_FIT:      /* Fixed-interval timer interrupt        */\n\n            cpu_abort(env, \"Fix interval timer interrupt while in user mode. \"\n\n                      \"Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_WDT:      /* Watchdog timer interrupt              */\n\n            cpu_abort(env, \"Watchdog timer interrupt while in user mode. \"\n\n                      \"Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_DTLB:     /* Data TLB error                        */\n\n            cpu_abort(env, \"Data TLB exception while in user mode. \"\n\n                      \"Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_ITLB:     /* Instruction TLB error                 */\n\n            cpu_abort(env, \"Instruction TLB exception while in user mode. \"\n\n                      \"Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_DEBUG:    /* Debug interrupt                       */\n\n            /* XXX: check this */\n\n            {\n\n                int sig;\n\n\n\n                sig = gdb_handlesig(env, TARGET_SIGTRAP);\n\n                if (sig) {\n\n                    info.si_signo = sig;\n\n                    info.si_errno = 0;\n\n                    info.si_code = TARGET_TRAP_BRKPT;\n\n                    queue_signal(info.si_signo, &info);\n\n                  }\n\n            }\n\n            break;\n\n        case POWERPC_EXCP_SPEU:     /* SPE/embedded floating-point unavail.  */\n\n            EXCP_DUMP(env, \"No SPE/floating-point instruction allowed\\n\");\n\n            info.si_signo = TARGET_SIGILL;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_ILL_COPROC;\n\n            info._sifields._sigfault._addr = env->nip - 4;\n\n            queue_signal(info.si_signo, &info);\n\n            break;\n\n        case POWERPC_EXCP_EFPDI:    /* Embedded floating-point data IRQ      */\n\n            cpu_abort(env, \"Embedded floating-point data IRQ not handled\\n\");\n\n            break;\n\n        case POWERPC_EXCP_EFPRI:    /* Embedded floating-point round IRQ     */\n\n            cpu_abort(env, \"Embedded floating-point round IRQ not handled\\n\");\n\n            break;\n\n        case POWERPC_EXCP_EPERFM:   /* Embedded performance monitor IRQ      */\n\n            cpu_abort(env, \"Performance monitor exception not handled\\n\");\n\n            break;\n\n        case POWERPC_EXCP_DOORI:    /* Embedded doorbell interrupt           */\n\n            cpu_abort(env, \"Doorbell interrupt while in user mode. \"\n\n                       \"Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_DOORCI:   /* Embedded doorbell critical interrupt  */\n\n            cpu_abort(env, \"Doorbell critical interrupt while in user mode. \"\n\n                      \"Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_RESET:    /* System reset exception                */\n\n            cpu_abort(env, \"Reset interrupt while in user mode. \"\n\n                      \"Aborting\\n\");\n\n            break;\n\n#if defined(TARGET_PPC64) && !defined(TARGET_ABI32) /* PowerPC 64 */\n\n        case POWERPC_EXCP_DSEG:     /* Data segment exception                */\n\n            cpu_abort(env, \"Data segment exception while in user mode. \"\n\n                      \"Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_ISEG:     /* Instruction segment exception         */\n\n            cpu_abort(env, \"Instruction segment exception \"\n\n                      \"while in user mode. Aborting\\n\");\n\n            break;\n\n#endif /* defined(TARGET_PPC64) && !defined(TARGET_ABI32) */\n\n#if defined(TARGET_PPC64H) && !defined(TARGET_ABI32)\n\n        /* PowerPC 64 with hypervisor mode support */\n\n        case POWERPC_EXCP_HDECR:    /* Hypervisor decrementer exception      */\n\n            cpu_abort(env, \"Hypervisor decrementer interrupt \"\n\n                      \"while in user mode. Aborting\\n\");\n\n            break;\n\n#endif /* defined(TARGET_PPC64H) && !defined(TARGET_ABI32) */\n\n        case POWERPC_EXCP_TRACE:    /* Trace exception                       */\n\n            /* Nothing to do:\n\n             * we use this exception to emulate step-by-step execution mode.\n\n             */\n\n            break;\n\n#if defined(TARGET_PPC64H) && !defined(TARGET_ABI32)\n\n        /* PowerPC 64 with hypervisor mode support */\n\n        case POWERPC_EXCP_HDSI:     /* Hypervisor data storage exception     */\n\n            cpu_abort(env, \"Hypervisor data storage exception \"\n\n                      \"while in user mode. Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_HISI:     /* Hypervisor instruction storage excp   */\n\n            cpu_abort(env, \"Hypervisor instruction storage exception \"\n\n                      \"while in user mode. Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_HDSEG:    /* Hypervisor data segment exception     */\n\n            cpu_abort(env, \"Hypervisor data segment exception \"\n\n                      \"while in user mode. Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_HISEG:    /* Hypervisor instruction segment excp   */\n\n            cpu_abort(env, \"Hypervisor instruction segment exception \"\n\n                      \"while in user mode. Aborting\\n\");\n\n            break;\n\n#endif /* defined(TARGET_PPC64H) && !defined(TARGET_ABI32) */\n\n        case POWERPC_EXCP_VPU:      /* Vector unavailable exception          */\n\n            EXCP_DUMP(env, \"No Altivec instructions allowed\\n\");\n\n            info.si_signo = TARGET_SIGILL;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_ILL_COPROC;\n\n            info._sifields._sigfault._addr = env->nip - 4;\n\n            queue_signal(info.si_signo, &info);\n\n            break;\n\n        case POWERPC_EXCP_PIT:      /* Programmable interval timer IRQ       */\n\n            cpu_abort(env, \"Programable interval timer interrupt \"\n\n                      \"while in user mode. Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_IO:       /* IO error exception                    */\n\n            cpu_abort(env, \"IO error exception while in user mode. \"\n\n                      \"Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_RUNM:     /* Run mode exception                    */\n\n            cpu_abort(env, \"Run mode exception while in user mode. \"\n\n                      \"Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_EMUL:     /* Emulation trap exception              */\n\n            cpu_abort(env, \"Emulation trap exception not handled\\n\");\n\n            break;\n\n        case POWERPC_EXCP_IFTLB:    /* Instruction fetch TLB error           */\n\n            cpu_abort(env, \"Instruction fetch TLB exception \"\n\n                      \"while in user-mode. Aborting\");\n\n            break;\n\n        case POWERPC_EXCP_DLTLB:    /* Data load TLB miss                    */\n\n            cpu_abort(env, \"Data load TLB exception while in user-mode. \"\n\n                      \"Aborting\");\n\n            break;\n\n        case POWERPC_EXCP_DSTLB:    /* Data store TLB miss                   */\n\n            cpu_abort(env, \"Data store TLB exception while in user-mode. \"\n\n                      \"Aborting\");\n\n            break;\n\n        case POWERPC_EXCP_FPA:      /* Floating-point assist exception       */\n\n            cpu_abort(env, \"Floating-point assist exception not handled\\n\");\n\n            break;\n\n        case POWERPC_EXCP_IABR:     /* Instruction address breakpoint        */\n\n            cpu_abort(env, \"Instruction address breakpoint exception \"\n\n                      \"not handled\\n\");\n\n            break;\n\n        case POWERPC_EXCP_SMI:      /* System management interrupt           */\n\n            cpu_abort(env, \"System management interrupt while in user mode. \"\n\n                      \"Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_THERM:    /* Thermal interrupt                     */\n\n            cpu_abort(env, \"Thermal interrupt interrupt while in user mode. \"\n\n                      \"Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_PERFM:   /* Embedded performance monitor IRQ      */\n\n            cpu_abort(env, \"Performance monitor exception not handled\\n\");\n\n            break;\n\n        case POWERPC_EXCP_VPUA:     /* Vector assist exception               */\n\n            cpu_abort(env, \"Vector assist exception not handled\\n\");\n\n            break;\n\n        case POWERPC_EXCP_SOFTP:    /* Soft patch exception                  */\n\n            cpu_abort(env, \"Soft patch exception not handled\\n\");\n\n            break;\n\n        case POWERPC_EXCP_MAINT:    /* Maintenance exception                 */\n\n            cpu_abort(env, \"Maintenance exception while in user mode. \"\n\n                      \"Aborting\\n\");\n\n            break;\n\n        case POWERPC_EXCP_STOP:     /* stop translation                      */\n\n            /* We did invalidate the instruction cache. Go on */\n\n            break;\n\n        case POWERPC_EXCP_BRANCH:   /* branch instruction:                   */\n\n            /* We just stopped because of a branch. Go on */\n\n            break;\n\n        case POWERPC_EXCP_SYSCALL_USER:\n\n            /* system call in user-mode emulation */\n\n            /* WARNING:\n\n             * PPC ABI uses overflow flag in cr0 to signal an error\n\n             * in syscalls.\n\n             */\n\n#if 0\n\n            printf(\"syscall %d 0x%08x 0x%08x 0x%08x 0x%08x\\n\", env->gpr[0],\n\n                   env->gpr[3], env->gpr[4], env->gpr[5], env->gpr[6]);\n\n#endif\n\n            env->crf[0] &= ~0x1;\n\n            ret = do_syscall(env, env->gpr[0], env->gpr[3], env->gpr[4],\n\n                             env->gpr[5], env->gpr[6], env->gpr[7],\n\n                             env->gpr[8]);\n\n            if (ret > (uint32_t)(-515)) {\n\n                env->crf[0] |= 0x1;\n\n                ret = -ret;\n\n            }\n\n            env->gpr[3] = ret;\n\n#if 0\n\n            printf(\"syscall returned 0x%08x (%d)\\n\", ret, ret);\n\n#endif\n\n            break;\n\n        case EXCP_INTERRUPT:\n\n            /* just indicate that signals should be handled asap */\n\n            break;\n\n        default:\n\n            cpu_abort(env, \"Unknown exception 0x%d. Aborting\\n\", trapnr);\n\n            break;\n\n        }\n\n        process_pending_signals(env);\n\n    }\n\n}\n", "idx": 16508, "_split": "valid", "_hash": "b182db5bc6ca65b1a3851b37041e76dd"}
{"project": "qemu", "commit_id": "ecbe1576b3287e7907b524901063a8117f544e61", "target": 0, "func": "static inline int seek_to_sector(BlockDriverState *bs, int64_t sector_num)\n\n{\n\n    BDRVBochsState *s = bs->opaque;\n\n    int64_t offset = sector_num * 512;\n\n    int64_t extent_index, extent_offset, bitmap_offset, block_offset;\n\n    char bitmap_entry;\n\n\n\n    // seek to sector\n\n    extent_index = offset / s->extent_size;\n\n    extent_offset = (offset % s->extent_size) / 512;\n\n\n\n    if (s->catalog_bitmap[extent_index] == 0xffffffff)\n\n    {\n\n//\tfprintf(stderr, \"page not allocated [%x - %x:%x]\\n\",\n\n//\t    sector_num, extent_index, extent_offset);\n\n\treturn -1; // not allocated\n\n    }\n\n\n\n    bitmap_offset = s->data_offset + (512 * s->catalog_bitmap[extent_index] *\n\n\t(s->extent_blocks + s->bitmap_blocks));\n\n    block_offset = bitmap_offset + (512 * (s->bitmap_blocks + extent_offset));\n\n\n\n//    fprintf(stderr, \"sect: %x [ext i: %x o: %x] -> %x bitmap: %x block: %x\\n\",\n\n//\tsector_num, extent_index, extent_offset,\n\n//\tle32_to_cpu(s->catalog_bitmap[extent_index]),\n\n//\tbitmap_offset, block_offset);\n\n\n\n    // read in bitmap for current extent\n\n    lseek(s->fd, bitmap_offset + (extent_offset / 8), SEEK_SET);\n\n\n\n    if (read(s->fd, &bitmap_entry, 1) != 1)\n\n        return -1;\n\n\n\n    if (!((bitmap_entry >> (extent_offset % 8)) & 1))\n\n    {\n\n//\tfprintf(stderr, \"sector (%x) in bitmap not allocated\\n\",\n\n//\t    sector_num);\n\n\treturn -1; // not allocated\n\n    }\n\n\n\n    lseek(s->fd, block_offset, SEEK_SET);\n\n\n\n    return 0;\n\n}\n", "idx": 16510, "_split": "valid", "_hash": "e30c2807f9df79a2ee5701100261907a"}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static void vnc_handshake_io(void *opaque) {\n\n    struct VncState *vs = (struct VncState *)opaque;\n\n\n\n    VNC_DEBUG(\"Handshake IO continue\\n\");\n\n    vnc_continue_handshake(vs);\n\n}\n", "idx": 16511, "_split": "valid", "_hash": "675527ec5a04dda28a0e0a295a1cfcc9"}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_remove(FsContext *ctx, const char *path)\n\n{\n\n    int err;\n\n    struct stat stbuf;\n\n    char buffer[PATH_MAX];\n\n\n\n    if (ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        err =  lstat(rpath(ctx, path, buffer), &stbuf);\n\n        if (err) {\n\n            goto err_out;\n\n        }\n\n        /*\n\n         * If directory remove .virtfs_metadata contained in the\n\n         * directory\n\n         */\n\n        if (S_ISDIR(stbuf.st_mode)) {\n\n            snprintf(buffer, ARRAY_SIZE(buffer), \"%s/%s/%s\",\n\n                     ctx->fs_root, path, VIRTFS_META_DIR);\n\n            err = remove(buffer);\n\n            if (err < 0 && errno != ENOENT) {\n\n                /*\n\n                 * We didn't had the .virtfs_metadata file. May be file created\n\n                 * in non-mapped mode ?. Ignore ENOENT.\n\n                 */\n\n                goto err_out;\n\n            }\n\n        }\n\n        /*\n\n         * Now remove the name from parent directory\n\n         * .virtfs_metadata directory\n\n         */\n\n        err = remove(local_mapped_attr_path(ctx, path, buffer));\n\n        if (err < 0 && errno != ENOENT) {\n\n            /*\n\n             * We didn't had the .virtfs_metadata file. May be file created\n\n             * in non-mapped mode ?. Ignore ENOENT.\n\n             */\n\n            goto err_out;\n\n        }\n\n    }\n\n    return remove(rpath(ctx, path, buffer));\n\nerr_out:\n\n    return err;\n\n}\n", "idx": 16515, "_split": "valid", "_hash": "a9434bdba63b560f310a2bb9efbbc067"}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static void qed_unplug_allocating_write_reqs(BDRVQEDState *s)\n\n{\n\n    assert(s->allocating_write_reqs_plugged);\n\n\n\n    s->allocating_write_reqs_plugged = false;\n\n    qemu_co_enter_next(&s->allocating_write_reqs);\n\n}\n", "idx": 16527, "_split": "valid", "_hash": "3b0d69a71e5dd019633b99b4e30bcf0f"}
{"project": "qemu", "commit_id": "d4cd45028898a37afb45fb449954115b4960d4e9", "target": 0, "func": "static int xen_pt_bar_reg_init(XenPCIPassthroughState *s, XenPTRegInfo *reg,\n\n                               uint32_t real_offset, uint32_t *data)\n\n{\n\n    uint32_t reg_field = 0;\n\n    int index;\n\n\n\n    index = xen_pt_bar_offset_to_index(reg->offset);\n\n    if (index < 0 || index >= PCI_NUM_REGIONS) {\n\n        XEN_PT_ERR(&s->dev, \"Internal error: Invalid BAR index [%d].\\n\", index);\n\n        return -1;\n\n    }\n\n\n\n    /* set BAR flag */\n\n    s->bases[index].bar_flag = xen_pt_bar_reg_parse(s, reg);\n\n    if (s->bases[index].bar_flag == XEN_PT_BAR_FLAG_UNUSED) {\n\n        reg_field = XEN_PT_INVALID_REG;\n\n    }\n\n\n\n    *data = reg_field;\n\n    return 0;\n\n}\n", "idx": 16533, "_split": "valid", "_hash": "7f6e5e8e21c52f8d3cb635c409d5f189"}
{"project": "qemu", "commit_id": "f020ed36fef7780e81a94543ae6388d8dc144ab6", "target": 0, "func": "static void ehci_frame_timer(void *opaque)\n\n{\n\n    EHCIState *ehci = opaque;\n\n    int schedules = 0;\n\n    int64_t expire_time, t_now;\n\n    uint64_t ns_elapsed;\n\n    int frames;\n\n    int i;\n\n    int skipped_frames = 0;\n\n\n\n    t_now = qemu_get_clock_ns(vm_clock);\n\n    ns_elapsed = t_now - ehci->last_run_ns;\n\n    frames = ns_elapsed / FRAME_TIMER_NS;\n\n\n\n    if (ehci_periodic_enabled(ehci) || ehci->pstate != EST_INACTIVE) {\n\n        schedules++;\n\n        expire_time = t_now + (get_ticks_per_sec() / FRAME_TIMER_FREQ);\n\n\n\n        for (i = 0; i < frames; i++) {\n\n            ehci_update_frindex(ehci, 1);\n\n\n\n            if (frames - i > ehci->maxframes) {\n\n                skipped_frames++;\n\n            } else {\n\n                ehci_advance_periodic_state(ehci);\n\n            }\n\n\n\n            ehci->last_run_ns += FRAME_TIMER_NS;\n\n        }\n\n    } else {\n\n        if (ehci->async_stepdown < ehci->maxframes / 2) {\n\n            ehci->async_stepdown++;\n\n        }\n\n        expire_time = t_now + (get_ticks_per_sec()\n\n                               * ehci->async_stepdown / FRAME_TIMER_FREQ);\n\n        ehci_update_frindex(ehci, frames);\n\n        ehci->last_run_ns += FRAME_TIMER_NS * frames;\n\n    }\n\n\n\n#if 0\n\n    if (skipped_frames) {\n\n        DPRINTF(\"WARNING - EHCI skipped %d frames\\n\", skipped_frames);\n\n    }\n\n#endif\n\n\n\n    /*  Async is not inside loop since it executes everything it can once\n\n     *  called\n\n     */\n\n    if (ehci_async_enabled(ehci) || ehci->astate != EST_INACTIVE) {\n\n        schedules++;\n\n        qemu_bh_schedule(ehci->async_bh);\n\n    }\n\n\n\n    if (schedules) {\n\n        qemu_mod_timer(ehci->frame_timer, expire_time);\n\n    }\n\n}\n", "idx": 16541, "_split": "valid", "_hash": "4ba24ce2d8aeee171dea81888d0c48e9"}
{"project": "qemu", "commit_id": "a57d23e4f7e7e81c839a7b53a973ac71eefe91da", "target": 0, "func": "void cpu_physical_memory_reset_dirty(ram_addr_t start, ram_addr_t end,\n\n                                     int dirty_flags)\n\n{\n\n    CPUState *env;\n\n    unsigned long length, start1;\n\n    int i;\n\n\n\n    start &= TARGET_PAGE_MASK;\n\n    end = TARGET_PAGE_ALIGN(end);\n\n\n\n    length = end - start;\n\n    if (length == 0)\n\n        return;\n\n    cpu_physical_memory_mask_dirty_range(start, length, dirty_flags);\n\n\n\n    /* we modify the TLB cache so that the dirty bit will be set again\n\n       when accessing the range */\n\n    start1 = (unsigned long)qemu_safe_ram_ptr(start);\n\n    /* Chek that we don't span multiple blocks - this breaks the\n\n       address comparisons below.  */\n\n    if ((unsigned long)qemu_safe_ram_ptr(end - 1) - start1\n\n            != (end - 1) - start) {\n\n        abort();\n\n    }\n\n\n\n    for(env = first_cpu; env != NULL; env = env->next_cpu) {\n\n        int mmu_idx;\n\n        for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {\n\n            for(i = 0; i < CPU_TLB_SIZE; i++)\n\n                tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i],\n\n                                      start1, length);\n\n        }\n\n    }\n\n}\n", "idx": 16558, "_split": "valid", "_hash": "84170fd07faee30e71a92c61b1ea651a"}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "static void phys_page_set(target_phys_addr_t index, target_phys_addr_t nb,\n\n                          uint16_t leaf)\n\n{\n\n    /* Wildly overreserve - it doesn't matter much. */\n\n    phys_map_node_reserve(3 * P_L2_LEVELS);\n\n\n\n    phys_page_set_level(&phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);\n\n}\n", "idx": 16569, "_split": "valid", "_hash": "9ddf7c3fdf6a80819e858d7bdea238d8"}
{"project": "qemu", "commit_id": "90f998f5f4267a0c22e983f533d19b9de1849283", "target": 0, "func": "void qemu_chr_fe_printf(CharDriverState *s, const char *fmt, ...)\n\n{\n\n    char buf[READ_BUF_LEN];\n\n    va_list ap;\n\n    va_start(ap, fmt);\n\n    vsnprintf(buf, sizeof(buf), fmt, ap);\n\n    qemu_chr_fe_write(s, (uint8_t *)buf, strlen(buf));\n\n    va_end(ap);\n\n}\n", "idx": 16570, "_split": "valid", "_hash": "e267237e80bf9253c8bf9f29da9ff4fe"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int megasas_dcmd_cfg_read(MegasasState *s, MegasasCmd *cmd)\n\n{\n\n    uint8_t data[4096];\n\n    struct mfi_config_data *info;\n\n    int num_pd_disks = 0, array_offset, ld_offset;\n\n    BusChild *kid;\n\n\n\n    if (cmd->iov_size > 4096) {\n\n        return MFI_STAT_INVALID_PARAMETER;\n\n    }\n\n\n\n    QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {\n\n        num_pd_disks++;\n\n    }\n\n    info = (struct mfi_config_data *)&data;\n\n    /*\n\n     * Array mapping:\n\n     * - One array per SCSI device\n\n     * - One logical drive per SCSI device\n\n     *   spanning the entire device\n\n     */\n\n    info->array_count = num_pd_disks;\n\n    info->array_size = sizeof(struct mfi_array) * num_pd_disks;\n\n    info->log_drv_count = num_pd_disks;\n\n    info->log_drv_size = sizeof(struct mfi_ld_config) * num_pd_disks;\n\n    info->spares_count = 0;\n\n    info->spares_size = sizeof(struct mfi_spare);\n\n    info->size = sizeof(struct mfi_config_data) + info->array_size +\n\n        info->log_drv_size;\n\n    if (info->size > 4096) {\n\n        return MFI_STAT_INVALID_PARAMETER;\n\n    }\n\n\n\n    array_offset = sizeof(struct mfi_config_data);\n\n    ld_offset = array_offset + sizeof(struct mfi_array) * num_pd_disks;\n\n\n\n    QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {\n\n        SCSIDevice *sdev = DO_UPCAST(SCSIDevice, qdev, kid->child);\n\n        BlockConf *conf = &sdev->conf;\n\n        uint16_t sdev_id = ((sdev->id & 0xFF) >> 8) | (sdev->lun & 0xFF);\n\n        struct mfi_array *array;\n\n        struct mfi_ld_config *ld;\n\n        uint64_t pd_size;\n\n        int i;\n\n\n\n        array = (struct mfi_array *)(data + array_offset);\n\n        bdrv_get_geometry(conf->bs, &pd_size);\n\n        array->size = cpu_to_le64(pd_size);\n\n        array->num_drives = 1;\n\n        array->array_ref = cpu_to_le16(sdev_id);\n\n        array->pd[0].ref.v.device_id = cpu_to_le16(sdev_id);\n\n        array->pd[0].ref.v.seq_num = 0;\n\n        array->pd[0].fw_state = MFI_PD_STATE_ONLINE;\n\n        array->pd[0].encl.pd = 0xFF;\n\n        array->pd[0].encl.slot = (sdev->id & 0xFF);\n\n        for (i = 1; i < MFI_MAX_ROW_SIZE; i++) {\n\n            array->pd[i].ref.v.device_id = 0xFFFF;\n\n            array->pd[i].ref.v.seq_num = 0;\n\n            array->pd[i].fw_state = MFI_PD_STATE_UNCONFIGURED_GOOD;\n\n            array->pd[i].encl.pd = 0xFF;\n\n            array->pd[i].encl.slot = 0xFF;\n\n        }\n\n        array_offset += sizeof(struct mfi_array);\n\n        ld = (struct mfi_ld_config *)(data + ld_offset);\n\n        memset(ld, 0, sizeof(struct mfi_ld_config));\n\n        ld->properties.ld.v.target_id = (sdev->id & 0xFF);\n\n        ld->properties.default_cache_policy = MR_LD_CACHE_READ_AHEAD |\n\n            MR_LD_CACHE_READ_ADAPTIVE;\n\n        ld->properties.current_cache_policy = MR_LD_CACHE_READ_AHEAD |\n\n            MR_LD_CACHE_READ_ADAPTIVE;\n\n        ld->params.state = MFI_LD_STATE_OPTIMAL;\n\n        ld->params.stripe_size = 3;\n\n        ld->params.num_drives = 1;\n\n        ld->params.span_depth = 1;\n\n        ld->params.is_consistent = 1;\n\n        ld->span[0].start_block = 0;\n\n        ld->span[0].num_blocks = cpu_to_le64(pd_size);\n\n        ld->span[0].array_ref = cpu_to_le16(sdev_id);\n\n        ld_offset += sizeof(struct mfi_ld_config);\n\n    }\n\n\n\n    cmd->iov_size -= dma_buf_read((uint8_t *)data, info->size, &cmd->qsg);\n\n    return MFI_STAT_OK;\n\n}\n", "idx": 16578, "_split": "valid", "_hash": "4dcb774f49692be97624c10cfbc7c4f8"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "timer_read(void *opaque, target_phys_addr_t addr, unsigned int size)\n\n{\n\n    struct etrax_timer *t = opaque;\n\n    uint32_t r = 0;\n\n\n\n    switch (addr) {\n\n    case R_TMR0_DATA:\n\n        r = ptimer_get_count(t->ptimer_t0);\n\n        break;\n\n    case R_TMR1_DATA:\n\n        r = ptimer_get_count(t->ptimer_t1);\n\n        break;\n\n    case R_TIME:\n\n        r = qemu_get_clock_ns(vm_clock) / 10;\n\n        break;\n\n    case RW_INTR_MASK:\n\n        r = t->rw_intr_mask;\n\n        break;\n\n    case R_MASKED_INTR:\n\n        r = t->r_intr & t->rw_intr_mask;\n\n        break;\n\n    default:\n\n        D(printf (\"%s %x\\n\", __func__, addr));\n\n        break;\n\n    }\n\n    return r;\n\n}\n", "idx": 16582, "_split": "valid", "_hash": "807546307a420dd9eee17a100f673960"}
{"project": "qemu", "commit_id": "b92ad3949bc9cacd1652b4e07e7f6003b9e512af", "target": 0, "func": "static void virt_class_init(ObjectClass *oc, void *data)\n\n{\n\n    MachineClass *mc = MACHINE_CLASS(oc);\n\n\n\n    mc->desc = \"ARM Virtual Machine\",\n\n    mc->init = machvirt_init;\n\n    mc->max_cpus = 8;\n\n    mc->has_dynamic_sysbus = true;\n\n    mc->block_default_type = IF_VIRTIO;\n\n    mc->no_cdrom = 1;\n\n}\n", "idx": 16584, "_split": "valid", "_hash": "29d818ca8a42e403889fc22aa4e95de2"}
{"project": "qemu", "commit_id": "cf7c0ff521b0710079aa28f21937fb7dbb3f5224", "target": 0, "func": "static GArray *nvdimm_build_device_structure(void)\n\n{\n\n    GSList *device_list = nvdimm_get_plugged_device_list();\n\n    GArray *structures = g_array_new(false, true /* clear */, 1);\n\n\n\n    for (; device_list; device_list = device_list->next) {\n\n        DeviceState *dev = device_list->data;\n\n\n\n        /* build System Physical Address Range Structure. */\n\n        nvdimm_build_structure_spa(structures, dev);\n\n\n\n        /*\n\n         * build Memory Device to System Physical Address Range Mapping\n\n         * Structure.\n\n         */\n\n        nvdimm_build_structure_memdev(structures, dev);\n\n\n\n        /* build NVDIMM Control Region Structure. */\n\n        nvdimm_build_structure_dcr(structures, dev);\n\n    }\n\n    g_slist_free(device_list);\n\n\n\n    return structures;\n\n}\n", "idx": 16596, "_split": "valid", "_hash": "fea90c028ccea2abee0c8280ac29a79d"}
{"project": "qemu", "commit_id": "5d79b80b335c5f65f148d1bb1672d9d534ace73b", "target": 0, "func": "static void pflash_timer (void *opaque)\n\n{\n\n    pflash_t *pfl = opaque;\n\n\n\n    DPRINTF(\"%s: command %02x done\\n\", __func__, pfl->cmd);\n\n    /* Reset flash */\n\n    pfl->status ^= 0x80;\n\n    if (pfl->bypass) {\n\n        pfl->wcycle = 2;\n\n    } else {\n\n        memory_region_rom_device_set_readable(&pfl->mem, true);\n\n        pfl->wcycle = 0;\n\n    }\n\n    pfl->cmd = 0;\n\n}\n", "idx": 16597, "_split": "valid", "_hash": "79a5af216373bcffb331bdd5685382cc"}
{"project": "qemu", "commit_id": "a8cf66bb393ff420d40ae172a4c817bf2752918a", "target": 0, "func": "void  helper_evaluate_flags_mcp(void)\n\n{\n\n\tuint32_t src;\n\n\tuint32_t dst;\n\n\tuint32_t res;\n\n\tuint32_t flags = 0;\n\n\n\n\tsrc = env->cc_src;\n\n\tdst = env->cc_dest;\n\n\tres = env->cc_result;\n\n\n\n\tif ((res & 0x80000000L) != 0L)\n\n\t{\n\n\t\tflags |= N_FLAG;\n\n\t\tif (((src & 0x80000000L) == 0L)\n\n\t\t    && ((dst & 0x80000000L) == 0L))\n\n\t\t{\n\n\t\t\tflags |= V_FLAG;\n\n\t\t}\n\n\t\telse if (((src & 0x80000000L) != 0L) &&\n\n\t\t\t ((dst & 0x80000000L) != 0L))\n\n\t\t{\n\n\t\t\tflags |= R_FLAG;\n\n\t\t}\n\n\t}\n\n\telse\n\n\t{\n\n\t\tif (res == 0L)\n\n\t\t\tflags |= Z_FLAG;\n\n\t\tif (((src & 0x80000000L) != 0L)\n\n\t\t    && ((dst & 0x80000000L) != 0L))\n\n\t\t\tflags |= V_FLAG;\n\n\t\tif ((dst & 0x80000000L) != 0L\n\n\t\t    || (src & 0x80000000L) != 0L)\n\n\t\t\tflags |= R_FLAG;\n\n\t}\n\n\n\n\tevaluate_flags_writeback(flags);\n\n}\n", "idx": 16624, "_split": "valid", "_hash": "dafd7e7a972a48ded4ee85a7e162e4be"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_store_exclusive(DisasContext *s, int rd, int rt, int rt2,\n\n                                TCGv_i64 inaddr, int size, int is_pair)\n\n{\n\n    /* if (env->exclusive_addr == addr && env->exclusive_val == [addr]\n\n     *     && (!is_pair || env->exclusive_high == [addr + datasize])) {\n\n     *     [addr] = {Rt};\n\n     *     if (is_pair) {\n\n     *         [addr + datasize] = {Rt2};\n\n     *     }\n\n     *     {Rd} = 0;\n\n     * } else {\n\n     *     {Rd} = 1;\n\n     * }\n\n     * env->exclusive_addr = -1;\n\n     */\n\n    int fail_label = gen_new_label();\n\n    int done_label = gen_new_label();\n\n    TCGv_i64 addr = tcg_temp_local_new_i64();\n\n    TCGv_i64 tmp;\n\n\n\n    /* Copy input into a local temp so it is not trashed when the\n\n     * basic block ends at the branch insn.\n\n     */\n\n    tcg_gen_mov_i64(addr, inaddr);\n\n    tcg_gen_brcond_i64(TCG_COND_NE, addr, cpu_exclusive_addr, fail_label);\n\n\n\n    tmp = tcg_temp_new_i64();\n\n    tcg_gen_qemu_ld_i64(tmp, addr, get_mem_index(s), MO_TE + size);\n\n    tcg_gen_brcond_i64(TCG_COND_NE, tmp, cpu_exclusive_val, fail_label);\n\n    tcg_temp_free_i64(tmp);\n\n\n\n    if (is_pair) {\n\n        TCGv_i64 addrhi = tcg_temp_new_i64();\n\n        TCGv_i64 tmphi = tcg_temp_new_i64();\n\n\n\n        tcg_gen_addi_i64(addrhi, addr, 1 << size);\n\n        tcg_gen_qemu_ld_i64(tmphi, addrhi, get_mem_index(s), MO_TE + size);\n\n        tcg_gen_brcond_i64(TCG_COND_NE, tmphi, cpu_exclusive_high, fail_label);\n\n\n\n        tcg_temp_free_i64(tmphi);\n\n        tcg_temp_free_i64(addrhi);\n\n    }\n\n\n\n    /* We seem to still have the exclusive monitor, so do the store */\n\n    tcg_gen_qemu_st_i64(cpu_reg(s, rt), addr, get_mem_index(s), MO_TE + size);\n\n    if (is_pair) {\n\n        TCGv_i64 addrhi = tcg_temp_new_i64();\n\n\n\n        tcg_gen_addi_i64(addrhi, addr, 1 << size);\n\n        tcg_gen_qemu_st_i64(cpu_reg(s, rt2), addrhi,\n\n                            get_mem_index(s), MO_TE + size);\n\n        tcg_temp_free_i64(addrhi);\n\n    }\n\n\n\n    tcg_temp_free_i64(addr);\n\n\n\n    tcg_gen_movi_i64(cpu_reg(s, rd), 0);\n\n    tcg_gen_br(done_label);\n\n    gen_set_label(fail_label);\n\n    tcg_gen_movi_i64(cpu_reg(s, rd), 1);\n\n    gen_set_label(done_label);\n\n    tcg_gen_movi_i64(cpu_exclusive_addr, -1);\n\n\n\n}\n", "idx": 16633, "_split": "valid", "_hash": "a84801cbcc047031f6da23e213c17379"}
{"project": "qemu", "commit_id": "2a74440547ea0a15195224fa2b7784b267cbfe15", "target": 0, "func": "QError *qerror_new(void)\n\n{\n\n    QError *qerr;\n\n\n\n    qerr = g_malloc0(sizeof(*qerr));\n\n    QOBJECT_INIT(qerr, &qerror_type);\n\n\n\n    return qerr;\n\n}\n", "idx": 16648, "_split": "valid", "_hash": "9bae725c7e83f7b067f76f9473d5304f"}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "int bdrv_write(BlockDriverState *bs, int64_t sector_num,\n               const uint8_t *buf, int nb_sectors)\n{\n    BlockDriver *drv = bs->drv;\n    if (!bs->drv)\n        return -ENOMEDIUM;\n    if (bs->read_only)\n        return -EACCES;\n    if (drv->bdrv_pwrite) {\n        int ret, len, count = 0;\n        len = nb_sectors * 512;\n        do {\n            ret = drv->bdrv_pwrite(bs, sector_num * 512, buf, len - count);\n            if (ret < 0) {\n                printf(\"bdrv_write ret=%d\\n\", ret);\n                return ret;\n            }\n            count += ret;\n            buf += ret;\n        } while (count != len);\n        bs->wr_bytes += (unsigned) len;\n        bs->wr_ops ++;\n        return 0;\n    }\n    return drv->bdrv_write(bs, sector_num, buf, nb_sectors);\n}", "idx": 16685, "_split": "valid", "_hash": "48327c7991c6097932aab2a186b5b6a5"}
{"project": "qemu", "commit_id": "967b75230b9720ea2b3ae49f38f8287026125f9f", "target": 1, "func": "static void pnv_chip_power8nvl_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PnvChipClass *k = PNV_CHIP_CLASS(klass);\n\n\n\n    k->cpu_model = \"POWER8NVL\";\n\n    k->chip_type = PNV_CHIP_POWER8NVL;\n\n    k->chip_cfam_id = 0x120d304980000000ull;  /* P8 Naples DD1.0 */\n\n    k->cores_mask = POWER8_CORE_MASK;\n\n    k->core_pir = pnv_chip_core_pir_p8;\n\n\n    dc->desc = \"PowerNV Chip POWER8NVL\";\n\n}", "idx": 16698, "_split": "valid", "_hash": "7fbdfbc240f4419924185634d6025cc4"}
{"project": "qemu", "commit_id": "1a01716a307387e5cf1336f61a96f772dddadc90", "target": 1, "func": "static void gd_menu_switch_vc(GtkMenuItem *item, void *opaque)\n{\n    GtkDisplayState *s = opaque;\n    VirtualConsole *vc = gd_vc_find_by_menu(s);\n    GtkNotebook *nb = GTK_NOTEBOOK(s->notebook);\n    gint page;\n    gtk_release_modifiers(s);\n    if (vc) {\n        page = gtk_notebook_page_num(nb, vc->tab_item);\n        gtk_notebook_set_current_page(nb, page);\n        gtk_widget_grab_focus(vc->focus);\n    }\n}", "idx": 16721, "_split": "valid", "_hash": "46039ef8843862b040e3a65f79dac98e"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void blockdev_mark_auto_del(BlockDriverState *bs)\n\n{\n\n    BlockBackend *blk = bs->blk;\n\n    DriveInfo *dinfo = blk_legacy_dinfo(blk);\n\n\n\n    if (dinfo && !dinfo->enable_auto_del) {\n\n        return;\n\n    }\n\n\n\n    if (bs->job) {\n\n        block_job_cancel(bs->job);\n\n    }\n\n    if (dinfo) {\n\n        dinfo->auto_del = 1;\n\n    }\n\n}\n", "idx": 16731, "_split": "valid", "_hash": "f6f6ae7a6c69e35ededb3226709ef275"}
{"project": "qemu", "commit_id": "b92ad3949bc9cacd1652b4e07e7f6003b9e512af", "target": 0, "func": "static void create_gic(VirtBoardInfo *vbi, qemu_irq *pic, bool secure)\n\n{\n\n    /* We create a standalone GIC v2 */\n\n    DeviceState *gicdev;\n\n    SysBusDevice *gicbusdev;\n\n    const char *gictype;\n\n    int i;\n\n\n\n    gictype = gic_class_name();\n\n\n\n    gicdev = qdev_create(NULL, gictype);\n\n    qdev_prop_set_uint32(gicdev, \"revision\", 2);\n\n    qdev_prop_set_uint32(gicdev, \"num-cpu\", smp_cpus);\n\n    /* Note that the num-irq property counts both internal and external\n\n     * interrupts; there are always 32 of the former (mandated by GIC spec).\n\n     */\n\n    qdev_prop_set_uint32(gicdev, \"num-irq\", NUM_IRQS + 32);\n\n    if (!kvm_irqchip_in_kernel()) {\n\n        qdev_prop_set_bit(gicdev, \"has-security-extensions\", secure);\n\n    }\n\n    qdev_init_nofail(gicdev);\n\n    gicbusdev = SYS_BUS_DEVICE(gicdev);\n\n    sysbus_mmio_map(gicbusdev, 0, vbi->memmap[VIRT_GIC_DIST].base);\n\n    sysbus_mmio_map(gicbusdev, 1, vbi->memmap[VIRT_GIC_CPU].base);\n\n\n\n    /* Wire the outputs from each CPU's generic timer to the\n\n     * appropriate GIC PPI inputs, and the GIC's IRQ output to\n\n     * the CPU's IRQ input.\n\n     */\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        DeviceState *cpudev = DEVICE(qemu_get_cpu(i));\n\n        int ppibase = NUM_IRQS + i * GIC_INTERNAL + GIC_NR_SGIS;\n\n        int irq;\n\n        /* Mapping from the output timer irq lines from the CPU to the\n\n         * GIC PPI inputs we use for the virt board.\n\n         */\n\n        const int timer_irq[] = {\n\n            [GTIMER_PHYS] = ARCH_TIMER_NS_EL1_IRQ,\n\n            [GTIMER_VIRT] = ARCH_TIMER_VIRT_IRQ,\n\n            [GTIMER_HYP]  = ARCH_TIMER_NS_EL2_IRQ,\n\n            [GTIMER_SEC]  = ARCH_TIMER_S_EL1_IRQ,\n\n        };\n\n\n\n        for (irq = 0; irq < ARRAY_SIZE(timer_irq); irq++) {\n\n            qdev_connect_gpio_out(cpudev, irq,\n\n                                  qdev_get_gpio_in(gicdev,\n\n                                                   ppibase + timer_irq[irq]));\n\n        }\n\n\n\n        sysbus_connect_irq(gicbusdev, i, qdev_get_gpio_in(cpudev, ARM_CPU_IRQ));\n\n        sysbus_connect_irq(gicbusdev, i + smp_cpus,\n\n                           qdev_get_gpio_in(cpudev, ARM_CPU_FIQ));\n\n    }\n\n\n\n    for (i = 0; i < NUM_IRQS; i++) {\n\n        pic[i] = qdev_get_gpio_in(gicdev, i);\n\n    }\n\n\n\n    fdt_add_gic_node(vbi);\n\n\n\n    create_v2m(vbi, pic);\n\n}\n", "idx": 16737, "_split": "valid", "_hash": "e6d4f1d508a19486dd9cfde512e907e1"}
{"project": "qemu", "commit_id": "9dbbc748d671c70599101836cd1c2719d92f3017", "target": 0, "func": "static int disas_neon_ls_insn(DisasContext *s, uint32_t insn)\n\n{\n\n    int rd, rn, rm;\n\n    int op;\n\n    int nregs;\n\n    int interleave;\n\n    int spacing;\n\n    int stride;\n\n    int size;\n\n    int reg;\n\n    int pass;\n\n    int load;\n\n    int shift;\n\n    int n;\n\n    TCGv_i32 addr;\n\n    TCGv_i32 tmp;\n\n    TCGv_i32 tmp2;\n\n    TCGv_i64 tmp64;\n\n\n\n    /* FIXME: this access check should not take precedence over UNDEF\n\n     * for invalid encodings; we will generate incorrect syndrome information\n\n     * for attempts to execute invalid vfp/neon encodings with FP disabled.\n\n     */\n\n    if (!s->cpacr_fpen) {\n\n        gen_exception_insn(s, 4, EXCP_UDEF,\n\n                           syn_fp_access_trap(1, 0xe, s->thumb),\n\n                           default_exception_el(s));\n\n        return 0;\n\n    }\n\n\n\n    if (!s->vfp_enabled)\n\n      return 1;\n\n    VFP_DREG_D(rd, insn);\n\n    rn = (insn >> 16) & 0xf;\n\n    rm = insn & 0xf;\n\n    load = (insn & (1 << 21)) != 0;\n\n    if ((insn & (1 << 23)) == 0) {\n\n        /* Load store all elements.  */\n\n        op = (insn >> 8) & 0xf;\n\n        size = (insn >> 6) & 3;\n\n        if (op > 10)\n\n            return 1;\n\n        /* Catch UNDEF cases for bad values of align field */\n\n        switch (op & 0xc) {\n\n        case 4:\n\n            if (((insn >> 5) & 1) == 1) {\n\n                return 1;\n\n            }\n\n            break;\n\n        case 8:\n\n            if (((insn >> 4) & 3) == 3) {\n\n                return 1;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        nregs = neon_ls_element_type[op].nregs;\n\n        interleave = neon_ls_element_type[op].interleave;\n\n        spacing = neon_ls_element_type[op].spacing;\n\n        if (size == 3 && (interleave | spacing) != 1)\n\n            return 1;\n\n        addr = tcg_temp_new_i32();\n\n        load_reg_var(s, addr, rn);\n\n        stride = (1 << size) * interleave;\n\n        for (reg = 0; reg < nregs; reg++) {\n\n            if (interleave > 2 || (interleave == 2 && nregs == 2)) {\n\n                load_reg_var(s, addr, rn);\n\n                tcg_gen_addi_i32(addr, addr, (1 << size) * reg);\n\n            } else if (interleave == 2 && nregs == 4 && reg == 2) {\n\n                load_reg_var(s, addr, rn);\n\n                tcg_gen_addi_i32(addr, addr, 1 << size);\n\n            }\n\n            if (size == 3) {\n\n                tmp64 = tcg_temp_new_i64();\n\n                if (load) {\n\n                    gen_aa32_ld64(tmp64, addr, get_mem_index(s));\n\n                    neon_store_reg64(tmp64, rd);\n\n                } else {\n\n                    neon_load_reg64(tmp64, rd);\n\n                    gen_aa32_st64(tmp64, addr, get_mem_index(s));\n\n                }\n\n                tcg_temp_free_i64(tmp64);\n\n                tcg_gen_addi_i32(addr, addr, stride);\n\n            } else {\n\n                for (pass = 0; pass < 2; pass++) {\n\n                    if (size == 2) {\n\n                        if (load) {\n\n                            tmp = tcg_temp_new_i32();\n\n                            gen_aa32_ld32u(tmp, addr, get_mem_index(s));\n\n                            neon_store_reg(rd, pass, tmp);\n\n                        } else {\n\n                            tmp = neon_load_reg(rd, pass);\n\n                            gen_aa32_st32(tmp, addr, get_mem_index(s));\n\n                            tcg_temp_free_i32(tmp);\n\n                        }\n\n                        tcg_gen_addi_i32(addr, addr, stride);\n\n                    } else if (size == 1) {\n\n                        if (load) {\n\n                            tmp = tcg_temp_new_i32();\n\n                            gen_aa32_ld16u(tmp, addr, get_mem_index(s));\n\n                            tcg_gen_addi_i32(addr, addr, stride);\n\n                            tmp2 = tcg_temp_new_i32();\n\n                            gen_aa32_ld16u(tmp2, addr, get_mem_index(s));\n\n                            tcg_gen_addi_i32(addr, addr, stride);\n\n                            tcg_gen_shli_i32(tmp2, tmp2, 16);\n\n                            tcg_gen_or_i32(tmp, tmp, tmp2);\n\n                            tcg_temp_free_i32(tmp2);\n\n                            neon_store_reg(rd, pass, tmp);\n\n                        } else {\n\n                            tmp = neon_load_reg(rd, pass);\n\n                            tmp2 = tcg_temp_new_i32();\n\n                            tcg_gen_shri_i32(tmp2, tmp, 16);\n\n                            gen_aa32_st16(tmp, addr, get_mem_index(s));\n\n                            tcg_temp_free_i32(tmp);\n\n                            tcg_gen_addi_i32(addr, addr, stride);\n\n                            gen_aa32_st16(tmp2, addr, get_mem_index(s));\n\n                            tcg_temp_free_i32(tmp2);\n\n                            tcg_gen_addi_i32(addr, addr, stride);\n\n                        }\n\n                    } else /* size == 0 */ {\n\n                        if (load) {\n\n                            TCGV_UNUSED_I32(tmp2);\n\n                            for (n = 0; n < 4; n++) {\n\n                                tmp = tcg_temp_new_i32();\n\n                                gen_aa32_ld8u(tmp, addr, get_mem_index(s));\n\n                                tcg_gen_addi_i32(addr, addr, stride);\n\n                                if (n == 0) {\n\n                                    tmp2 = tmp;\n\n                                } else {\n\n                                    tcg_gen_shli_i32(tmp, tmp, n * 8);\n\n                                    tcg_gen_or_i32(tmp2, tmp2, tmp);\n\n                                    tcg_temp_free_i32(tmp);\n\n                                }\n\n                            }\n\n                            neon_store_reg(rd, pass, tmp2);\n\n                        } else {\n\n                            tmp2 = neon_load_reg(rd, pass);\n\n                            for (n = 0; n < 4; n++) {\n\n                                tmp = tcg_temp_new_i32();\n\n                                if (n == 0) {\n\n                                    tcg_gen_mov_i32(tmp, tmp2);\n\n                                } else {\n\n                                    tcg_gen_shri_i32(tmp, tmp2, n * 8);\n\n                                }\n\n                                gen_aa32_st8(tmp, addr, get_mem_index(s));\n\n                                tcg_temp_free_i32(tmp);\n\n                                tcg_gen_addi_i32(addr, addr, stride);\n\n                            }\n\n                            tcg_temp_free_i32(tmp2);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            rd += spacing;\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        stride = nregs * 8;\n\n    } else {\n\n        size = (insn >> 10) & 3;\n\n        if (size == 3) {\n\n            /* Load single element to all lanes.  */\n\n            int a = (insn >> 4) & 1;\n\n            if (!load) {\n\n                return 1;\n\n            }\n\n            size = (insn >> 6) & 3;\n\n            nregs = ((insn >> 8) & 3) + 1;\n\n\n\n            if (size == 3) {\n\n                if (nregs != 4 || a == 0) {\n\n                    return 1;\n\n                }\n\n                /* For VLD4 size==3 a == 1 means 32 bits at 16 byte alignment */\n\n                size = 2;\n\n            }\n\n            if (nregs == 1 && a == 1 && size == 0) {\n\n                return 1;\n\n            }\n\n            if (nregs == 3 && a == 1) {\n\n                return 1;\n\n            }\n\n            addr = tcg_temp_new_i32();\n\n            load_reg_var(s, addr, rn);\n\n            if (nregs == 1) {\n\n                /* VLD1 to all lanes: bit 5 indicates how many Dregs to write */\n\n                tmp = gen_load_and_replicate(s, addr, size);\n\n                tcg_gen_st_i32(tmp, cpu_env, neon_reg_offset(rd, 0));\n\n                tcg_gen_st_i32(tmp, cpu_env, neon_reg_offset(rd, 1));\n\n                if (insn & (1 << 5)) {\n\n                    tcg_gen_st_i32(tmp, cpu_env, neon_reg_offset(rd + 1, 0));\n\n                    tcg_gen_st_i32(tmp, cpu_env, neon_reg_offset(rd + 1, 1));\n\n                }\n\n                tcg_temp_free_i32(tmp);\n\n            } else {\n\n                /* VLD2/3/4 to all lanes: bit 5 indicates register stride */\n\n                stride = (insn & (1 << 5)) ? 2 : 1;\n\n                for (reg = 0; reg < nregs; reg++) {\n\n                    tmp = gen_load_and_replicate(s, addr, size);\n\n                    tcg_gen_st_i32(tmp, cpu_env, neon_reg_offset(rd, 0));\n\n                    tcg_gen_st_i32(tmp, cpu_env, neon_reg_offset(rd, 1));\n\n                    tcg_temp_free_i32(tmp);\n\n                    tcg_gen_addi_i32(addr, addr, 1 << size);\n\n                    rd += stride;\n\n                }\n\n            }\n\n            tcg_temp_free_i32(addr);\n\n            stride = (1 << size) * nregs;\n\n        } else {\n\n            /* Single element.  */\n\n            int idx = (insn >> 4) & 0xf;\n\n            pass = (insn >> 7) & 1;\n\n            switch (size) {\n\n            case 0:\n\n                shift = ((insn >> 5) & 3) * 8;\n\n                stride = 1;\n\n                break;\n\n            case 1:\n\n                shift = ((insn >> 6) & 1) * 16;\n\n                stride = (insn & (1 << 5)) ? 2 : 1;\n\n                break;\n\n            case 2:\n\n                shift = 0;\n\n                stride = (insn & (1 << 6)) ? 2 : 1;\n\n                break;\n\n            default:\n\n                abort();\n\n            }\n\n            nregs = ((insn >> 8) & 3) + 1;\n\n            /* Catch the UNDEF cases. This is unavoidably a bit messy. */\n\n            switch (nregs) {\n\n            case 1:\n\n                if (((idx & (1 << size)) != 0) ||\n\n                    (size == 2 && ((idx & 3) == 1 || (idx & 3) == 2))) {\n\n                    return 1;\n\n                }\n\n                break;\n\n            case 3:\n\n                if ((idx & 1) != 0) {\n\n                    return 1;\n\n                }\n\n                /* fall through */\n\n            case 2:\n\n                if (size == 2 && (idx & 2) != 0) {\n\n                    return 1;\n\n                }\n\n                break;\n\n            case 4:\n\n                if ((size == 2) && ((idx & 3) == 3)) {\n\n                    return 1;\n\n                }\n\n                break;\n\n            default:\n\n                abort();\n\n            }\n\n            if ((rd + stride * (nregs - 1)) > 31) {\n\n                /* Attempts to write off the end of the register file\n\n                 * are UNPREDICTABLE; we choose to UNDEF because otherwise\n\n                 * the neon_load_reg() would write off the end of the array.\n\n                 */\n\n                return 1;\n\n            }\n\n            addr = tcg_temp_new_i32();\n\n            load_reg_var(s, addr, rn);\n\n            for (reg = 0; reg < nregs; reg++) {\n\n                if (load) {\n\n                    tmp = tcg_temp_new_i32();\n\n                    switch (size) {\n\n                    case 0:\n\n                        gen_aa32_ld8u(tmp, addr, get_mem_index(s));\n\n                        break;\n\n                    case 1:\n\n                        gen_aa32_ld16u(tmp, addr, get_mem_index(s));\n\n                        break;\n\n                    case 2:\n\n                        gen_aa32_ld32u(tmp, addr, get_mem_index(s));\n\n                        break;\n\n                    default: /* Avoid compiler warnings.  */\n\n                        abort();\n\n                    }\n\n                    if (size != 2) {\n\n                        tmp2 = neon_load_reg(rd, pass);\n\n                        tcg_gen_deposit_i32(tmp, tmp2, tmp,\n\n                                            shift, size ? 16 : 8);\n\n                        tcg_temp_free_i32(tmp2);\n\n                    }\n\n                    neon_store_reg(rd, pass, tmp);\n\n                } else { /* Store */\n\n                    tmp = neon_load_reg(rd, pass);\n\n                    if (shift)\n\n                        tcg_gen_shri_i32(tmp, tmp, shift);\n\n                    switch (size) {\n\n                    case 0:\n\n                        gen_aa32_st8(tmp, addr, get_mem_index(s));\n\n                        break;\n\n                    case 1:\n\n                        gen_aa32_st16(tmp, addr, get_mem_index(s));\n\n                        break;\n\n                    case 2:\n\n                        gen_aa32_st32(tmp, addr, get_mem_index(s));\n\n                        break;\n\n                    }\n\n                    tcg_temp_free_i32(tmp);\n\n                }\n\n                rd += stride;\n\n                tcg_gen_addi_i32(addr, addr, 1 << size);\n\n            }\n\n            tcg_temp_free_i32(addr);\n\n            stride = nregs * (1 << size);\n\n        }\n\n    }\n\n    if (rm != 15) {\n\n        TCGv_i32 base;\n\n\n\n        base = load_reg(s, rn);\n\n        if (rm == 13) {\n\n            tcg_gen_addi_i32(base, base, stride);\n\n        } else {\n\n            TCGv_i32 index;\n\n            index = load_reg(s, rm);\n\n            tcg_gen_add_i32(base, base, index);\n\n            tcg_temp_free_i32(index);\n\n        }\n\n        store_reg(s, rn, base);\n\n    }\n\n    return 0;\n\n}\n", "idx": 16744, "_split": "valid", "_hash": "3a45ea3325bb263143f955100e974cbb"}
{"project": "qemu", "commit_id": "ddcb73b7782cb6104479503faea04cc224f982b5", "target": 1, "func": "e1000_can_receive(NetClientState *nc)\n\n{\n\n    E1000State *s = qemu_get_nic_opaque(nc);\n\n\n\n    return (s->mac_reg[RCTL] & E1000_RCTL_EN) && e1000_has_rxbufs(s, 1);\n\n}\n", "idx": 16753, "_split": "valid", "_hash": "840af54b2c6a91d4c8dfbf29258fb5fd"}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static void rtce_init(VIOsPAPRDevice *dev)\n\n{\n\n    size_t size = (dev->rtce_window_size >> SPAPR_VIO_TCE_PAGE_SHIFT)\n\n        * sizeof(VIOsPAPR_RTCE);\n\n\n\n    if (size) {\n\n        dev->rtce_table = kvmppc_create_spapr_tce(dev->reg,\n\n                                                  dev->rtce_window_size,\n\n                                                  &dev->kvmtce_fd);\n\n\n\n        if (!dev->rtce_table) {\n\n            dev->rtce_table = g_malloc0(size);\n\n        }\n\n    }\n\n}\n", "idx": 16758, "_split": "valid", "_hash": "c5b5dcf31512e61bb5eeb3116c58df97"}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static void vnc_desktop_resize(VncState *vs)\n\n{\n\n    DisplaySurface *ds = vs->vd->ds;\n\n\n\n    if (vs->csock == -1 || !vnc_has_feature(vs, VNC_FEATURE_RESIZE)) {\n\n        return;\n\n    }\n\n    if (vs->client_width == surface_width(ds) &&\n\n        vs->client_height == surface_height(ds)) {\n\n        return;\n\n    }\n\n    vs->client_width = surface_width(ds);\n\n    vs->client_height = surface_height(ds);\n\n    vnc_lock_output(vs);\n\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n\n    vnc_write_u8(vs, 0);\n\n    vnc_write_u16(vs, 1); /* number of rects */\n\n    vnc_framebuffer_update(vs, 0, 0, vs->client_width, vs->client_height,\n\n                           VNC_ENCODING_DESKTOPRESIZE);\n\n    vnc_unlock_output(vs);\n\n    vnc_flush(vs);\n\n}\n", "idx": 16759, "_split": "valid", "_hash": "256bb0cd17c72dc6c05cffe86a52d201"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void stl_be_phys(target_phys_addr_t addr, uint32_t val)\n\n{\n\n    stl_phys_internal(addr, val, DEVICE_BIG_ENDIAN);\n\n}\n", "idx": 16776, "_split": "valid", "_hash": "b2932510be5f91975c67413de7b4106d"}
{"project": "qemu", "commit_id": "bf937a7965c1d1a6dce4f615d0ead2e2ab505004", "target": 0, "func": "static uint8_t *l2cap_bframe_out(struct bt_l2cap_conn_params_s *parm, int len)\n\n{\n\n    struct l2cap_chan_s *chan = (struct l2cap_chan_s *) parm;\n\n\n\n    if (len > chan->params.remote_mtu) {\n\n        fprintf(stderr, \"%s: B-Frame for CID %04x longer than %i octets.\\n\",\n\n                        __func__,\n\n                        chan->remote_cid, chan->params.remote_mtu);\n\n        exit(-1);\n\n    }\n\n\n\n    return l2cap_pdu_out(chan->l2cap, chan->remote_cid, len);\n\n}\n", "idx": 16777, "_split": "valid", "_hash": "368bfbde1212ca72f844d6260081751e"}
{"project": "qemu", "commit_id": "bf18bee547d19fde314e7b6b81f21f68b46c8a92", "target": 0, "func": "static int do_open_tray(const char *device, bool force, Error **errp)\n\n{\n\n    BlockBackend *blk;\n\n    bool locked;\n\n\n\n    blk = blk_by_name(device);\n\n    if (!blk) {\n\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n\n                  \"Device '%s' not found\", device);\n\n        return -ENODEV;\n\n    }\n\n\n\n    if (!blk_dev_has_removable_media(blk)) {\n\n        error_setg(errp, \"Device '%s' is not removable\", device);\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    if (!blk_dev_has_tray(blk)) {\n\n        /* Ignore this command on tray-less devices */\n\n        return ENOSYS;\n\n    }\n\n\n\n    if (blk_dev_is_tray_open(blk)) {\n\n        return 0;\n\n    }\n\n\n\n    locked = blk_dev_is_medium_locked(blk);\n\n    if (locked) {\n\n        blk_dev_eject_request(blk, force);\n\n    }\n\n\n\n    if (!locked || force) {\n\n        blk_dev_change_media_cb(blk, false);\n\n    }\n\n\n\n    if (locked && !force) {\n\n        return EINPROGRESS;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 16804, "_split": "valid", "_hash": "83e4e59fee60cb5b7860fcd0022b28b9"}
{"project": "qemu", "commit_id": "e5766d6ec7524345f4c0fa284c065b68c5e93049", "target": 0, "func": "static int read_config(BDRVBlkdebugState *s, const char *filename,\n\n                       QDict *options, Error **errp)\n\n{\n\n    FILE *f = NULL;\n\n    int ret;\n\n    struct add_rule_data d;\n\n    Error *local_err = NULL;\n\n\n\n    if (filename) {\n\n        f = fopen(filename, \"r\");\n\n        if (f == NULL) {\n\n            error_setg_errno(errp, errno, \"Could not read blkdebug config file\");\n\n            return -errno;\n\n        }\n\n\n\n        ret = qemu_config_parse(f, config_groups, filename);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Could not parse blkdebug config file\");\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    qemu_config_parse_qdict(options, config_groups, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    d.s = s;\n\n    d.action = ACTION_INJECT_ERROR;\n\n    qemu_opts_foreach(&inject_error_opts, add_rule, &d, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    d.action = ACTION_SET_STATE;\n\n    qemu_opts_foreach(&set_state_opts, add_rule, &d, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n    qemu_opts_reset(&inject_error_opts);\n\n    qemu_opts_reset(&set_state_opts);\n\n    if (f) {\n\n        fclose(f);\n\n    }\n\n    return ret;\n\n}\n", "idx": 16816, "_split": "valid", "_hash": "0b125e54d782ac1a037a7d2887066488"}
{"project": "qemu", "commit_id": "b2dfd71c4843a762f2befe702adb249cf55baf66", "target": 0, "func": "static void kvm_log_start(MemoryListener *listener,\n\n                          MemoryRegionSection *section)\n\n{\n\n    int r;\n\n\n\n    r = kvm_dirty_pages_log_change(section->offset_within_address_space,\n\n                                   int128_get64(section->size), true);\n\n    if (r < 0) {\n\n        abort();\n\n    }\n\n}\n", "idx": 16817, "_split": "valid", "_hash": "fdfe07a6f1305be4849fadb48421d29f"}
{"project": "qemu", "commit_id": "02a08fef079469c005d48fe2d181f0e0eb5752ae", "target": 0, "func": "int tcp_socket_outgoing_spec(const char *address_and_port)\n\n{\n\n    return inet_connect(address_and_port, true, NULL);\n\n}\n", "idx": 16821, "_split": "valid", "_hash": "d2ce6174ccbff50d766b8815f6fe477f"}
{"project": "qemu", "commit_id": "4837a1a51638ef1719bf8149591a57e7207db41a", "target": 1, "func": "static int blk_get_request(struct XenBlkDev *blkdev, struct ioreq *ioreq, RING_IDX rc)\n\n{\n\n    switch (blkdev->protocol) {\n\n    case BLKIF_PROTOCOL_NATIVE:\n\n        memcpy(&ioreq->req, RING_GET_REQUEST(&blkdev->rings.native, rc),\n\n               sizeof(ioreq->req));\n\n        break;\n\n    case BLKIF_PROTOCOL_X86_32:\n\n        blkif_get_x86_32_req(&ioreq->req,\n\n                             RING_GET_REQUEST(&blkdev->rings.x86_32_part, rc));\n\n        break;\n\n    case BLKIF_PROTOCOL_X86_64:\n\n        blkif_get_x86_64_req(&ioreq->req,\n\n                             RING_GET_REQUEST(&blkdev->rings.x86_64_part, rc));\n\n        break;\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 16850, "_split": "valid", "_hash": "d433bef2deabc6c93387176ec8d4e2bf"}
{"project": "qemu", "commit_id": "1f0c461b82d5ec2664ca0cfc9548f80da87a8f8a", "target": 0, "func": "void blk_remove_bs(BlockBackend *blk)\n\n{\n\n    assert(blk->root->bs->blk == blk);\n\n\n\n    notifier_list_notify(&blk->remove_bs_notifiers, blk);\n\n    if (blk->public.throttle_state) {\n\n        throttle_timers_detach_aio_context(&blk->public.throttle_timers);\n\n    }\n\n\n\n    blk_update_root_state(blk);\n\n\n\n    blk->root->bs->blk = NULL;\n\n    bdrv_root_unref_child(blk->root);\n\n    blk->root = NULL;\n\n}\n", "idx": 16868, "_split": "valid", "_hash": "1a75d0cf0e6457e3af08f4d1cd199b6a"}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static int vnc_display_get_addresses(QemuOpts *opts,\n\n                                     bool reverse,\n\n                                     SocketAddressLegacy ***retsaddr,\n\n                                     size_t *retnsaddr,\n\n                                     SocketAddressLegacy ***retwsaddr,\n\n                                     size_t *retnwsaddr,\n\n                                     Error **errp)\n\n{\n\n    SocketAddressLegacy *saddr = NULL;\n\n    SocketAddressLegacy *wsaddr = NULL;\n\n    QemuOptsIter addriter;\n\n    const char *addr;\n\n    int to = qemu_opt_get_number(opts, \"to\", 0);\n\n    bool has_ipv4 = qemu_opt_get(opts, \"ipv4\");\n\n    bool has_ipv6 = qemu_opt_get(opts, \"ipv6\");\n\n    bool ipv4 = qemu_opt_get_bool(opts, \"ipv4\", false);\n\n    bool ipv6 = qemu_opt_get_bool(opts, \"ipv6\", false);\n\n    size_t i;\n\n    int displaynum = -1;\n\n    int ret = -1;\n\n\n\n    *retsaddr = NULL;\n\n    *retnsaddr = 0;\n\n    *retwsaddr = NULL;\n\n    *retnwsaddr = 0;\n\n\n\n    addr = qemu_opt_get(opts, \"vnc\");\n\n    if (addr == NULL || g_str_equal(addr, \"none\")) {\n\n        ret = 0;\n\n        goto cleanup;\n\n    }\n\n    if (qemu_opt_get(opts, \"websocket\") &&\n\n        !qcrypto_hash_supports(QCRYPTO_HASH_ALG_SHA1)) {\n\n        error_setg(errp,\n\n                   \"SHA1 hash support is required for websockets\");\n\n        goto cleanup;\n\n    }\n\n\n\n    qemu_opt_iter_init(&addriter, opts, \"vnc\");\n\n    while ((addr = qemu_opt_iter_next(&addriter)) != NULL) {\n\n        int rv;\n\n        rv = vnc_display_get_address(addr, false, reverse, 0, to,\n\n                                     has_ipv4, has_ipv6,\n\n                                     ipv4, ipv6,\n\n                                     &saddr, errp);\n\n        if (rv < 0) {\n\n            goto cleanup;\n\n        }\n\n        /* Historical compat - first listen address can be used\n\n         * to set the default websocket port\n\n         */\n\n        if (displaynum == -1) {\n\n            displaynum = rv;\n\n        }\n\n        *retsaddr = g_renew(SocketAddressLegacy *, *retsaddr, *retnsaddr + 1);\n\n        (*retsaddr)[(*retnsaddr)++] = saddr;\n\n    }\n\n\n\n    /* If we had multiple primary displays, we don't do defaults\n\n     * for websocket, and require explicit config instead. */\n\n    if (*retnsaddr > 1) {\n\n        displaynum = -1;\n\n    }\n\n\n\n    qemu_opt_iter_init(&addriter, opts, \"websocket\");\n\n    while ((addr = qemu_opt_iter_next(&addriter)) != NULL) {\n\n        if (vnc_display_get_address(addr, true, reverse, displaynum, to,\n\n                                    has_ipv4, has_ipv6,\n\n                                    ipv4, ipv6,\n\n                                    &wsaddr, errp) < 0) {\n\n            goto cleanup;\n\n        }\n\n\n\n        /* Historical compat - if only a single listen address was\n\n         * provided, then this is used to set the default listen\n\n         * address for websocket too\n\n         */\n\n        if (*retnsaddr == 1 &&\n\n            (*retsaddr)[0]->type == SOCKET_ADDRESS_LEGACY_KIND_INET &&\n\n            wsaddr->type == SOCKET_ADDRESS_LEGACY_KIND_INET &&\n\n            g_str_equal(wsaddr->u.inet.data->host, \"\") &&\n\n            !g_str_equal((*retsaddr)[0]->u.inet.data->host, \"\")) {\n\n            g_free(wsaddr->u.inet.data->host);\n\n            wsaddr->u.inet.data->host =\n\n                g_strdup((*retsaddr)[0]->u.inet.data->host);\n\n        }\n\n\n\n        *retwsaddr = g_renew(SocketAddressLegacy *, *retwsaddr, *retnwsaddr + 1);\n\n        (*retwsaddr)[(*retnwsaddr)++] = wsaddr;\n\n    }\n\n\n\n    ret = 0;\n\n cleanup:\n\n    if (ret < 0) {\n\n        for (i = 0; i < *retnsaddr; i++) {\n\n            qapi_free_SocketAddressLegacy((*retsaddr)[i]);\n\n        }\n\n        g_free(*retsaddr);\n\n        for (i = 0; i < *retnwsaddr; i++) {\n\n            qapi_free_SocketAddressLegacy((*retwsaddr)[i]);\n\n        }\n\n        g_free(*retwsaddr);\n\n        *retsaddr = *retwsaddr = NULL;\n\n        *retnsaddr = *retnwsaddr = 0;\n\n    }\n\n    return ret;\n\n}\n", "idx": 16891, "_split": "valid", "_hash": "81b780a6f000888d3a9481671e0bd799"}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_logicq_cc(TCGv val)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    gen_helper_logicq_cc(tmp, val);\n\n    gen_logic_CC(tmp);\n\n    dead_tmp(tmp);\n\n}\n", "idx": 16894, "_split": "valid", "_hash": "3b6f8a8df7ce7c57ef8e13dfdb16596d"}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "static int64_t nfs_client_open(NFSClient *client, QDict *options,\n\n                               int flags, int open_flags, Error **errp)\n\n{\n\n    int ret = -EINVAL;\n\n    QemuOpts *opts = NULL;\n\n    Error *local_err = NULL;\n\n    struct stat st;\n\n    char *file = NULL, *strp = NULL;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    client->path = g_strdup(qemu_opt_get(opts, \"path\"));\n\n    if (!client->path) {\n\n        ret = -EINVAL;\n\n        error_setg(errp, \"No path was specified\");\n\n        goto fail;\n\n    }\n\n\n\n    strp = strrchr(client->path, '/');\n\n    if (strp == NULL) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    file = g_strdup(strp);\n\n    *strp = 0;\n\n\n\n    /* Pop the config into our state object, Exit if invalid */\n\n    client->server = nfs_config(options, errp);\n\n    if (!client->server) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    client->context = nfs_init_context();\n\n    if (client->context == NULL) {\n\n        error_setg(errp, \"Failed to init NFS context\");\n\n        goto fail;\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"user\")) {\n\n        client->uid = qemu_opt_get_number(opts, \"user\", 0);\n\n        nfs_set_uid(client->context, client->uid);\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"group\")) {\n\n        client->gid = qemu_opt_get_number(opts, \"group\", 0);\n\n        nfs_set_gid(client->context, client->gid);\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"tcp-syn-count\")) {\n\n        client->tcp_syncnt = qemu_opt_get_number(opts, \"tcp-syn-count\", 0);\n\n        nfs_set_tcp_syncnt(client->context, client->tcp_syncnt);\n\n    }\n\n\n\n#ifdef LIBNFS_FEATURE_READAHEAD\n\n    if (qemu_opt_get(opts, \"readahead-size\")) {\n\n        if (open_flags & BDRV_O_NOCACHE) {\n\n            error_setg(errp, \"Cannot enable NFS readahead \"\n\n                             \"if cache.direct = on\");\n\n            goto fail;\n\n        }\n\n        client->readahead = qemu_opt_get_number(opts, \"readahead-size\", 0);\n\n        if (client->readahead > QEMU_NFS_MAX_READAHEAD_SIZE) {\n\n            error_report(\"NFS Warning: Truncating NFS readahead \"\n\n                         \"size to %d\", QEMU_NFS_MAX_READAHEAD_SIZE);\n\n            client->readahead = QEMU_NFS_MAX_READAHEAD_SIZE;\n\n        }\n\n        nfs_set_readahead(client->context, client->readahead);\n\n#ifdef LIBNFS_FEATURE_PAGECACHE\n\n        nfs_set_pagecache_ttl(client->context, 0);\n\n#endif\n\n        client->cache_used = true;\n\n    }\n\n#endif\n\n\n\n#ifdef LIBNFS_FEATURE_PAGECACHE\n\n    if (qemu_opt_get(opts, \"page-cache-size\")) {\n\n        if (open_flags & BDRV_O_NOCACHE) {\n\n            error_setg(errp, \"Cannot enable NFS pagecache \"\n\n                             \"if cache.direct = on\");\n\n            goto fail;\n\n        }\n\n        client->pagecache = qemu_opt_get_number(opts, \"page-cache-size\", 0);\n\n        if (client->pagecache > QEMU_NFS_MAX_PAGECACHE_SIZE) {\n\n            error_report(\"NFS Warning: Truncating NFS pagecache \"\n\n                         \"size to %d pages\", QEMU_NFS_MAX_PAGECACHE_SIZE);\n\n            client->pagecache = QEMU_NFS_MAX_PAGECACHE_SIZE;\n\n        }\n\n        nfs_set_pagecache(client->context, client->pagecache);\n\n        nfs_set_pagecache_ttl(client->context, 0);\n\n        client->cache_used = true;\n\n    }\n\n#endif\n\n\n\n#ifdef LIBNFS_FEATURE_DEBUG\n\n    if (qemu_opt_get(opts, \"debug\")) {\n\n        client->debug = qemu_opt_get_number(opts, \"debug\", 0);\n\n        /* limit the maximum debug level to avoid potential flooding\n\n         * of our log files. */\n\n        if (client->debug > QEMU_NFS_MAX_DEBUG_LEVEL) {\n\n            error_report(\"NFS Warning: Limiting NFS debug level \"\n\n                         \"to %d\", QEMU_NFS_MAX_DEBUG_LEVEL);\n\n            client->debug = QEMU_NFS_MAX_DEBUG_LEVEL;\n\n        }\n\n        nfs_set_debug(client->context, client->debug);\n\n    }\n\n#endif\n\n\n\n    ret = nfs_mount(client->context, client->server->host, client->path);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to mount nfs share: %s\",\n\n                   nfs_get_error(client->context));\n\n        goto fail;\n\n    }\n\n\n\n    if (flags & O_CREAT) {\n\n        ret = nfs_creat(client->context, file, 0600, &client->fh);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to create file: %s\",\n\n                       nfs_get_error(client->context));\n\n            goto fail;\n\n        }\n\n    } else {\n\n        ret = nfs_open(client->context, file, flags, &client->fh);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to open file : %s\",\n\n                       nfs_get_error(client->context));\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = nfs_fstat(client->context, client->fh, &st);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to fstat file: %s\",\n\n                   nfs_get_error(client->context));\n\n        goto fail;\n\n    }\n\n\n\n    ret = DIV_ROUND_UP(st.st_size, BDRV_SECTOR_SIZE);\n\n    client->st_blocks = st.st_blocks;\n\n    client->has_zero_init = S_ISREG(st.st_mode);\n\n    *strp = '/';\n\n    goto out;\n\n\n\nfail:\n\n    nfs_client_close(client);\n\nout:\n\n    qemu_opts_del(opts);\n\n    g_free(file);\n\n    return ret;\n\n}\n", "idx": 16895, "_split": "valid", "_hash": "4628bbca0902ddece72dd9f544440851"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "BlockAIOCB *dma_bdrv_io(\n\n    BlockDriverState *bs, QEMUSGList *sg, uint64_t sector_num,\n\n    DMAIOFunc *io_func, BlockCompletionFunc *cb,\n\n    void *opaque, DMADirection dir)\n\n{\n\n    DMAAIOCB *dbs = qemu_aio_get(&dma_aiocb_info, bs, cb, opaque);\n\n\n\n    trace_dma_bdrv_io(dbs, bs, sector_num, (dir == DMA_DIRECTION_TO_DEVICE));\n\n\n\n    dbs->acb = NULL;\n\n    dbs->bs = bs;\n\n    dbs->sg = sg;\n\n    dbs->sector_num = sector_num;\n\n    dbs->sg_cur_index = 0;\n\n    dbs->sg_cur_byte = 0;\n\n    dbs->dir = dir;\n\n    dbs->io_func = io_func;\n\n    dbs->bh = NULL;\n\n    qemu_iovec_init(&dbs->iov, sg->nsg);\n\n    dma_bdrv_cb(dbs, 0);\n\n    return &dbs->common;\n\n}\n", "idx": 16898, "_split": "valid", "_hash": "8871a88ee2f8c644113f8b463eb45b82"}
{"project": "qemu", "commit_id": "2374e73edafff0586cbfb67c333c5a7588f81fd5", "target": 0, "func": "void helper_ldl_l_raw(uint64_t t0, uint64_t t1)\n\n{\n\n    env->lock = t1;\n\n    ldl_raw(t1, t0);\n\n}\n", "idx": 16909, "_split": "valid", "_hash": "da45808c6d4162e438282f9dae4847c1"}
{"project": "qemu", "commit_id": "b02ef3d92b19ad304a84433d3817f0903296ebc7", "target": 0, "func": "static void assign_storage(SCLPDevice *sclp, SCCB *sccb)\n\n{\n\n    MemoryRegion *mr = NULL;\n\n    uint64_t this_subregion_size;\n\n    AssignStorage *assign_info = (AssignStorage *) sccb;\n\n    sclpMemoryHotplugDev *mhd = get_sclp_memory_hotplug_dev();\n\n    assert(mhd);\n\n    ram_addr_t assign_addr = (assign_info->rn - 1) * mhd->rzm;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n\n\n    if ((assign_addr % MEM_SECTION_SIZE == 0) &&\n\n        (assign_addr >= mhd->padded_ram_size)) {\n\n        /* Re-use existing memory region if found */\n\n        mr = memory_region_find(sysmem, assign_addr, 1).mr;\n\n        memory_region_unref(mr);\n\n        if (!mr) {\n\n\n\n            MemoryRegion *standby_ram = g_new(MemoryRegion, 1);\n\n\n\n            /* offset to align to standby_subregion_size for allocation */\n\n            ram_addr_t offset = assign_addr -\n\n                                (assign_addr - mhd->padded_ram_size)\n\n                                % mhd->standby_subregion_size;\n\n\n\n            /* strlen(\"standby.ram\") + 4 (Max of KVM_MEMORY_SLOTS) +  NULL */\n\n            char id[16];\n\n            snprintf(id, 16, \"standby.ram%d\",\n\n                     (int)((offset - mhd->padded_ram_size) /\n\n                     mhd->standby_subregion_size) + 1);\n\n\n\n            /* Allocate a subregion of the calculated standby_subregion_size */\n\n            if (offset + mhd->standby_subregion_size >\n\n                mhd->padded_ram_size + mhd->standby_mem_size) {\n\n                this_subregion_size = mhd->padded_ram_size +\n\n                  mhd->standby_mem_size - offset;\n\n            } else {\n\n                this_subregion_size = mhd->standby_subregion_size;\n\n            }\n\n\n\n            memory_region_init_ram(standby_ram, NULL, id, this_subregion_size, &error_abort);\n\n            /* This is a hack to make memory hotunplug work again. Once we have\n\n             * subdevices, we have to unparent them when unassigning memory,\n\n             * instead of doing it via the ref count of the MemoryRegion. */\n\n            object_ref(OBJECT(standby_ram));\n\n            object_unparent(OBJECT(standby_ram));\n\n            vmstate_register_ram_global(standby_ram);\n\n            memory_region_add_subregion(sysmem, offset, standby_ram);\n\n        }\n\n        /* The specified subregion is no longer in standby */\n\n        mhd->standby_state_map[(assign_addr - mhd->padded_ram_size)\n\n                               / MEM_SECTION_SIZE] = 1;\n\n    }\n\n    sccb->h.response_code = cpu_to_be16(SCLP_RC_NORMAL_COMPLETION);\n\n}\n", "idx": 16916, "_split": "valid", "_hash": "8297595b31e10fe8a3c463fe471257bd"}
{"project": "qemu", "commit_id": "4500bc98a6aab1734d865afaeade3509eb65b560", "target": 0, "func": "static void dump_aml_files(test_data *data)\n\n{\n\n    AcpiSdtTable *sdt;\n\n    GError *error = NULL;\n\n    gint fd;\n\n    ssize_t ret;\n\n    int i;\n\n\n\n    for (i = 0; i < data->ssdt_tables->len; ++i) {\n\n        sdt = &g_array_index(data->ssdt_tables, AcpiSdtTable, i);\n\n        g_assert(sdt->aml);\n\n\n\n        fd = g_file_open_tmp(\"aml-XXXXXX\", &sdt->aml_file, &error);\n\n        g_assert_no_error(error);\n\n\n\n        ret = qemu_write_full(fd, sdt, sizeof(AcpiTableHeader));\n\n        g_assert(ret == sizeof(AcpiTableHeader));\n\n        ret = qemu_write_full(fd, sdt->aml, sdt->aml_len);\n\n        g_assert(ret == sdt->aml_len);\n\n\n\n        close(fd);\n\n    }\n\n}\n", "idx": 16917, "_split": "valid", "_hash": "c9401acf2429181a1ba2699f5b7cebec"}
{"project": "qemu", "commit_id": "a9c0183059d6a4e4d940cd86ac0f9402b0655d24", "target": 0, "func": "static void sd_erase(SDState *sd)\n\n{\n\n    int i, start, end;\n\n    if (!sd->erase_start || !sd->erase_end) {\n\n        sd->card_status |= ERASE_SEQ_ERROR;\n\n        return;\n\n    }\n\n\n\n    start = sd->erase_start >>\n\n            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT);\n\n    end = sd->erase_end >>\n\n            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT);\n\n    sd->erase_start = 0;\n\n    sd->erase_end = 0;\n\n    sd->csd[14] |= 0x40;\n\n\n\n    for (i = start; i <= end; i ++)\n\n        if (sd->wp_groups[i])\n\n            sd->card_status |= WP_ERASE_SKIP;\n\n}\n", "idx": 16947, "_split": "valid", "_hash": "7a2cdab690ac42b16a9be5c181e55591"}
{"project": "qemu", "commit_id": "7e97cd88148876bad36ee7c66d526dcaed328d0d", "target": 0, "func": "static void tcg_init_vcpu(void *_env)\n\n{\n\n    CPUState *env = _env;\n\n    /* share a single thread for all cpus with TCG */\n\n    if (!tcg_cpu_thread) {\n\n        env->thread = qemu_mallocz(sizeof(QemuThread));\n\n        env->halt_cond = qemu_mallocz(sizeof(QemuCond));\n\n        qemu_cond_init(env->halt_cond);\n\n        qemu_thread_create(env->thread, tcg_cpu_thread_fn, env);\n\n        while (env->created == 0)\n\n            qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);\n\n        tcg_cpu_thread = env->thread;\n\n        tcg_halt_cond = env->halt_cond;\n\n    } else {\n\n        env->thread = tcg_cpu_thread;\n\n        env->halt_cond = tcg_halt_cond;\n\n    }\n\n}\n", "idx": 16948, "_split": "valid", "_hash": "46b5a05ffcecdf421f4f1645a9f149fa"}
{"project": "qemu", "commit_id": "e68c35cfb8088a11300371751e3987f67cac15b1", "target": 0, "func": "static int nbd_negotiate_handle_list(NBDClient *client, uint32_t length,\n\n                                     Error **errp)\n\n{\n\n    NBDExport *exp;\n\n\n\n    if (length) {\n\n        if (nbd_drop(client->ioc, length, errp) < 0) {\n\n            return -EIO;\n\n        }\n\n        return nbd_negotiate_send_rep_err(client->ioc,\n\n                                          NBD_REP_ERR_INVALID, NBD_OPT_LIST,\n\n                                          errp,\n\n                                          \"OPT_LIST should not have length\");\n\n    }\n\n\n\n    /* For each export, send a NBD_REP_SERVER reply. */\n\n    QTAILQ_FOREACH(exp, &exports, next) {\n\n        if (nbd_negotiate_send_rep_list(client->ioc, exp, errp)) {\n\n            return -EINVAL;\n\n        }\n\n    }\n\n    /* Finish with a NBD_REP_ACK. */\n\n    return nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, NBD_OPT_LIST, errp);\n\n}\n", "idx": 16966, "_split": "valid", "_hash": "8708e6b3cd2b0814003064df06518145"}
{"project": "qemu", "commit_id": "082c6681b6c4af0035d9dad34a4a784be8c21dbe", "target": 0, "func": "static void init_excp_620 (CPUPPCState *env)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;\n\n    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;\n\n    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;\n\n    env->excp_vectors[POWERPC_EXCP_DSEG]     = 0x00000380;\n\n    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;\n\n    env->excp_vectors[POWERPC_EXCP_ISEG]     = 0x00000480;\n\n    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;\n\n    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;\n\n    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;\n\n    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;\n\n    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;\n\n    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;\n\n    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;\n\n    env->excp_vectors[POWERPC_EXCP_FPA]      = 0x00000E00;\n\n    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;\n\n    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;\n\n    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;\n\n    env->excp_prefix = 0xFFF00000UL;\n\n    /* Hardware reset vector */\n\n    env->hreset_vector = 0x0000000000000100ULL;\n\n#endif\n\n}\n", "idx": 16967, "_split": "valid", "_hash": "612c9e45c98e22752a166b637a1f8b82"}
{"project": "qemu", "commit_id": "2bc22a58e16f0650e56dccfac9495e5aef58e2ef", "target": 1, "func": "void qemu_macaddr_default_if_unset(MACAddr *macaddr)\n\n{\n\n    static int index = 0;\n\n    static const MACAddr zero = { .a = { 0,0,0,0,0,0 } };\n\n\n\n    if (memcmp(macaddr, &zero, sizeof(zero)) != 0)\n\n        return;\n\n    macaddr->a[0] = 0x52;\n\n    macaddr->a[1] = 0x54;\n\n    macaddr->a[2] = 0x00;\n\n    macaddr->a[3] = 0x12;\n\n    macaddr->a[4] = 0x34;\n\n    macaddr->a[5] = 0x56 + index++;\n\n}\n", "idx": 16977, "_split": "valid", "_hash": "941467639fec493b033c00e9ff5bc025"}
{"project": "qemu", "commit_id": "0e9b9edae7bebfd31fdbead4ccbbce03876a7edd", "target": 0, "func": "void acpi_setup(void)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(qdev_get_machine());\n\n    PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(pcms);\n\n    AcpiBuildTables tables;\n\n    AcpiBuildState *build_state;\n\n\n\n    if (!pcms->fw_cfg) {\n\n        ACPI_BUILD_DPRINTF(\"No fw cfg. Bailing out.\\n\");\n\n        return;\n\n    }\n\n\n\n    if (!pcmc->has_acpi_build) {\n\n        ACPI_BUILD_DPRINTF(\"ACPI build disabled. Bailing out.\\n\");\n\n        return;\n\n    }\n\n\n\n    if (!acpi_enabled) {\n\n        ACPI_BUILD_DPRINTF(\"ACPI disabled. Bailing out.\\n\");\n\n        return;\n\n    }\n\n\n\n    build_state = g_malloc0(sizeof *build_state);\n\n\n\n    acpi_set_pci_info();\n\n\n\n    acpi_build_tables_init(&tables);\n\n    acpi_build(&tables, MACHINE(pcms));\n\n\n\n    /* Now expose it all to Guest */\n\n    build_state->table_mr = acpi_add_rom_blob(build_state, tables.table_data,\n\n                                               ACPI_BUILD_TABLE_FILE,\n\n                                               ACPI_BUILD_TABLE_MAX_SIZE);\n\n    assert(build_state->table_mr != NULL);\n\n\n\n    build_state->linker_mr =\n\n        acpi_add_rom_blob(build_state, tables.linker, \"etc/table-loader\", 0);\n\n\n\n    fw_cfg_add_file(pcms->fw_cfg, ACPI_BUILD_TPMLOG_FILE,\n\n                    tables.tcpalog->data, acpi_data_len(tables.tcpalog));\n\n\n\n    if (!pcmc->rsdp_in_ram) {\n\n        /*\n\n         * Keep for compatibility with old machine types.\n\n         * Though RSDP is small, its contents isn't immutable, so\n\n         * we'll update it along with the rest of tables on guest access.\n\n         */\n\n        uint32_t rsdp_size = acpi_data_len(tables.rsdp);\n\n\n\n        build_state->rsdp = g_memdup(tables.rsdp->data, rsdp_size);\n\n        fw_cfg_add_file_callback(pcms->fw_cfg, ACPI_BUILD_RSDP_FILE,\n\n                                 acpi_build_update, build_state,\n\n                                 build_state->rsdp, rsdp_size);\n\n        build_state->rsdp_mr = NULL;\n\n    } else {\n\n        build_state->rsdp = NULL;\n\n        build_state->rsdp_mr = acpi_add_rom_blob(build_state, tables.rsdp,\n\n                                                  ACPI_BUILD_RSDP_FILE, 0);\n\n    }\n\n\n\n    qemu_register_reset(acpi_build_reset, build_state);\n\n    acpi_build_reset(build_state);\n\n    vmstate_register(NULL, 0, &vmstate_acpi_build, build_state);\n\n\n\n    /* Cleanup tables but don't free the memory: we track it\n\n     * in build_state.\n\n     */\n\n    acpi_build_tables_cleanup(&tables, false);\n\n}\n", "idx": 17006, "_split": "valid", "_hash": "13b402fb31ac48b7df7aa2edde18ffd3"}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "static void axidma_write(void *opaque, hwaddr addr,\n\n                         uint64_t value, unsigned size)\n\n{\n\n    XilinxAXIDMA *d = opaque;\n\n    struct Stream *s;\n\n    int sid;\n\n\n\n    sid = streamid_from_addr(addr);\n\n    s = &d->streams[sid];\n\n\n\n    addr = addr % 0x30;\n\n    addr >>= 2;\n\n    switch (addr) {\n\n        case R_DMACR:\n\n            /* Tailptr mode is always on.  */\n\n            value |= DMACR_TAILPTR_MODE;\n\n            /* Remember our previous reset state.  */\n\n            value |= (s->regs[addr] & DMACR_RESET);\n\n            s->regs[addr] = value;\n\n\n\n            if (value & DMACR_RESET) {\n\n                stream_reset(s);\n\n            }\n\n\n\n            if ((value & 1) && !stream_resetting(s)) {\n\n                /* Start processing.  */\n\n                s->regs[R_DMASR] &= ~(DMASR_HALTED | DMASR_IDLE);\n\n            }\n\n            stream_reload_complete_cnt(s);\n\n            break;\n\n\n\n        case R_DMASR:\n\n            /* Mask away write to clear irq lines.  */\n\n            value &= ~(value & DMASR_IRQ_MASK);\n\n            s->regs[addr] = value;\n\n            break;\n\n\n\n        case R_TAILDESC:\n\n            s->regs[addr] = value;\n\n            s->regs[R_DMASR] &= ~DMASR_IDLE; /* Not idle.  */\n\n            if (!sid) {\n\n                stream_process_mem2s(s, d->tx_dev);\n\n            }\n\n            break;\n\n        default:\n\n            D(qemu_log(\"%s: ch=%d addr=\" TARGET_FMT_plx \" v=%x\\n\",\n\n                  __func__, sid, addr * 4, (unsigned)value));\n\n            s->regs[addr] = value;\n\n            break;\n\n    }\n\n    if (sid == 1 && d->notify) {\n\n        d->notify(d->notify_opaque);\n\n        d->notify = NULL;\n\n    }\n\n    stream_update_irq(s);\n\n}\n", "idx": 17024, "_split": "valid", "_hash": "5d65cc730cc4ad37d89bfb2242475829"}
{"project": "qemu", "commit_id": "70ae65f5d91462e1905a53236179fde21cda3a2f", "target": 0, "func": "static uint32_t bmdma_readb(void *opaque, uint32_t addr)\n\n{\n\n    BMDMAState *bm = opaque;\n\n    PCIIDEState *pci_dev = pci_from_bm(bm);\n\n    uint32_t val;\n\n\n\n    switch(addr & 3) {\n\n    case 0:\n\n        val = bm->cmd;\n\n        break;\n\n    case 1:\n\n        val = pci_dev->dev.config[MRDMODE];\n\n        break;\n\n    case 2:\n\n        val = bm->status;\n\n        break;\n\n    case 3:\n\n        if (bm->unit == 0) {\n\n            val = pci_dev->dev.config[UDIDETCR0];\n\n        } else {\n\n            val = pci_dev->dev.config[UDIDETCR1];\n\n        }\n\n        break;\n\n    default:\n\n        val = 0xff;\n\n        break;\n\n    }\n\n#ifdef DEBUG_IDE\n\n    printf(\"bmdma: readb 0x%02x : 0x%02x\\n\", addr, val);\n\n#endif\n\n    return val;\n\n}\n", "idx": 17028, "_split": "valid", "_hash": "083a4c7f737a752a91405ad170e01c03"}
{"project": "qemu", "commit_id": "7f303adc4f0aaa71b196d9f983150f3ec3367b46", "target": 0, "func": "query_params_append (struct QueryParams *ps,\n\n               const char *name, const char *value)\n\n{\n\n    if (ps->n >= ps->alloc) {\n\n        ps->p = g_renew(QueryParam, ps->p, ps->alloc * 2);\n\n        ps->alloc *= 2;\n\n    }\n\n\n\n    ps->p[ps->n].name = g_strdup(name);\n\n    ps->p[ps->n].value = value ? g_strdup(value) : NULL;\n\n    ps->p[ps->n].ignore = 0;\n\n    ps->n++;\n\n\n\n    return 0;\n\n}\n", "idx": 17033, "_split": "valid", "_hash": "57515ee1f4fce2b020ba84205c967508"}
{"project": "qemu", "commit_id": "9445673ea67c272616b9f718396e267caa6446b7", "target": 0, "func": "static void nbd_parse_filename(const char *filename, QDict *options,\n\n                               Error **errp)\n\n{\n\n    char *file;\n\n    char *export_name;\n\n    const char *host_spec;\n\n    const char *unixpath;\n\n\n\n    if (nbd_has_filename_options_conflict(options, errp)) {\n\n        return;\n\n    }\n\n\n\n    if (strstr(filename, \"://\")) {\n\n        int ret = nbd_parse_uri(filename, options);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"No valid URL specified\");\n\n        }\n\n        return;\n\n    }\n\n\n\n    file = g_strdup(filename);\n\n\n\n    export_name = strstr(file, EN_OPTSTR);\n\n    if (export_name) {\n\n        if (export_name[strlen(EN_OPTSTR)] == 0) {\n\n            goto out;\n\n        }\n\n        export_name[0] = 0; /* truncate 'file' */\n\n        export_name += strlen(EN_OPTSTR);\n\n\n\n        qdict_put(options, \"export\", qstring_from_str(export_name));\n\n    }\n\n\n\n    /* extract the host_spec - fail if it's not nbd:... */\n\n    if (!strstart(file, \"nbd:\", &host_spec)) {\n\n        error_setg(errp, \"File name string for NBD must start with 'nbd:'\");\n\n        goto out;\n\n    }\n\n\n\n    if (!*host_spec) {\n\n        goto out;\n\n    }\n\n\n\n    /* are we a UNIX or TCP socket? */\n\n    if (strstart(host_spec, \"unix:\", &unixpath)) {\n\n        qdict_put(options, \"server.type\", qstring_from_str(\"unix\"));\n\n        qdict_put(options, \"server.data.path\", qstring_from_str(unixpath));\n\n    } else {\n\n        InetSocketAddress *addr = NULL;\n\n\n\n        addr = inet_parse(host_spec, errp);\n\n        if (!addr) {\n\n            goto out;\n\n        }\n\n\n\n        qdict_put(options, \"server.type\", qstring_from_str(\"inet\"));\n\n        qdict_put(options, \"server.data.host\", qstring_from_str(addr->host));\n\n        qdict_put(options, \"server.data.port\", qstring_from_str(addr->port));\n\n        qapi_free_InetSocketAddress(addr);\n\n    }\n\n\n\nout:\n\n    g_free(file);\n\n}\n", "idx": 17036, "_split": "valid", "_hash": "be0c596895a907146f2300b7d6960b19"}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static TCGv new_tmp(void)\n\n{\n\n    TCGv tmp;\n\n    if (num_temps == MAX_TEMPS)\n\n        abort();\n\n\n\n    if (GET_TCGV(temps[num_temps]))\n\n      return temps[num_temps++];\n\n\n\n    tmp = tcg_temp_new(TCG_TYPE_I32);\n\n    temps[num_temps++] = tmp;\n\n    return tmp;\n\n}\n", "idx": 17088, "_split": "valid", "_hash": "19147ec6b74c0d104574a4d758d5b428"}
{"project": "qemu", "commit_id": "9658e4c342e6ae0d775101f8f6bb6efb16789af1", "target": 0, "func": "void cpu_mips_store_status(CPUMIPSState *env, target_ulong val)\n\n{\n\n    uint32_t mask = env->CP0_Status_rw_bitmask;\n\n    target_ulong old = env->CP0_Status;\n\n\n\n    if (env->insn_flags & ISA_MIPS32R6) {\n\n        bool has_supervisor = extract32(mask, CP0St_KSU, 2) == 0x3;\n\n#if defined(TARGET_MIPS64)\n\n        uint32_t ksux = (1 << CP0St_KX) & val;\n\n        ksux |= (ksux >> 1) & val; /* KX = 0 forces SX to be 0 */\n\n        ksux |= (ksux >> 1) & val; /* SX = 0 forces UX to be 0 */\n\n        val = (val & ~(7 << CP0St_UX)) | ksux;\n\n#endif\n\n        if (has_supervisor && extract32(val, CP0St_KSU, 2) == 0x3) {\n\n            mask &= ~(3 << CP0St_KSU);\n\n        }\n\n        mask &= ~(((1 << CP0St_SR) | (1 << CP0St_NMI)) & val);\n\n    }\n\n\n\n    env->CP0_Status = (old & ~mask) | (val & mask);\n\n#if defined(TARGET_MIPS64)\n\n    if ((env->CP0_Status ^ old) & (old & (7 << CP0St_UX))) {\n\n        /* Access to at least one of the 64-bit segments has been disabled */\n\n        cpu_mips_tlb_flush(env);\n\n    }\n\n#endif\n\n    if (env->CP0_Config3 & (1 << CP0C3_MT)) {\n\n        sync_c0_status(env, env, env->current_tc);\n\n    } else {\n\n        compute_hflags(env);\n\n    }\n\n}\n", "idx": 17091, "_split": "valid", "_hash": "7694479d92cced92f0bd1cd31d5dbfab"}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static SocketAddress *nbd_config(BDRVNBDState *s, QDict *options, char **export,\n\n                                 Error **errp)\n\n{\n\n    SocketAddress *saddr;\n\n\n\n    if (qdict_haskey(options, \"path\") == qdict_haskey(options, \"host\")) {\n\n        if (qdict_haskey(options, \"path\")) {\n\n            error_setg(errp, \"path and host may not be used at the same time.\");\n\n        } else {\n\n            error_setg(errp, \"one of path and host must be specified.\");\n\n        }\n\n        return NULL;\n\n    }\n\n\n\n    saddr = g_new0(SocketAddress, 1);\n\n\n\n    if (qdict_haskey(options, \"path\")) {\n\n        UnixSocketAddress *q_unix;\n\n        saddr->type = SOCKET_ADDRESS_KIND_UNIX;\n\n        q_unix = saddr->u.q_unix = g_new0(UnixSocketAddress, 1);\n\n        q_unix->path = g_strdup(qdict_get_str(options, \"path\"));\n\n        qdict_del(options, \"path\");\n\n    } else {\n\n        InetSocketAddress *inet;\n\n        saddr->type = SOCKET_ADDRESS_KIND_INET;\n\n        inet = saddr->u.inet = g_new0(InetSocketAddress, 1);\n\n        inet->host = g_strdup(qdict_get_str(options, \"host\"));\n\n        if (!qdict_get_try_str(options, \"port\")) {\n\n            inet->port = g_strdup_printf(\"%d\", NBD_DEFAULT_PORT);\n\n        } else {\n\n            inet->port = g_strdup(qdict_get_str(options, \"port\"));\n\n        }\n\n        qdict_del(options, \"host\");\n\n        qdict_del(options, \"port\");\n\n    }\n\n\n\n    s->client.is_unix = saddr->type == SOCKET_ADDRESS_KIND_UNIX;\n\n\n\n    *export = g_strdup(qdict_get_try_str(options, \"export\"));\n\n    if (*export) {\n\n        qdict_del(options, \"export\");\n\n    }\n\n\n\n    return saddr;\n\n}\n", "idx": 17140, "_split": "valid", "_hash": "14505834f7a85bf179d1ae065f178f12"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_jmpcc(DisasContext *s, int cond, int l1)\n\n{\n\n    TCGv tmp;\n\n\n\n    /* TODO: Optimize compare/branch pairs rather than always flushing\n\n       flag state to CC_OP_FLAGS.  */\n\n    gen_flush_flags(s);\n\n    switch (cond) {\n\n    case 0: /* T */\n\n        tcg_gen_br(l1);\n\n        break;\n\n    case 1: /* F */\n\n        break;\n\n    case 2: /* HI (!C && !Z) */\n\n        tmp = tcg_temp_new();\n\n        tcg_gen_andi_i32(tmp, QREG_CC_DEST, CCF_C | CCF_Z);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, l1);\n\n        break;\n\n    case 3: /* LS (C || Z) */\n\n        tmp = tcg_temp_new();\n\n        tcg_gen_andi_i32(tmp, QREG_CC_DEST, CCF_C | CCF_Z);\n\n        tcg_gen_brcondi_i32(TCG_COND_NE, tmp, 0, l1);\n\n        break;\n\n    case 4: /* CC (!C) */\n\n        tmp = tcg_temp_new();\n\n        tcg_gen_andi_i32(tmp, QREG_CC_DEST, CCF_C);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, l1);\n\n        break;\n\n    case 5: /* CS (C) */\n\n        tmp = tcg_temp_new();\n\n        tcg_gen_andi_i32(tmp, QREG_CC_DEST, CCF_C);\n\n        tcg_gen_brcondi_i32(TCG_COND_NE, tmp, 0, l1);\n\n        break;\n\n    case 6: /* NE (!Z) */\n\n        tmp = tcg_temp_new();\n\n        tcg_gen_andi_i32(tmp, QREG_CC_DEST, CCF_Z);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, l1);\n\n        break;\n\n    case 7: /* EQ (Z) */\n\n        tmp = tcg_temp_new();\n\n        tcg_gen_andi_i32(tmp, QREG_CC_DEST, CCF_Z);\n\n        tcg_gen_brcondi_i32(TCG_COND_NE, tmp, 0, l1);\n\n        break;\n\n    case 8: /* VC (!V) */\n\n        tmp = tcg_temp_new();\n\n        tcg_gen_andi_i32(tmp, QREG_CC_DEST, CCF_V);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, l1);\n\n        break;\n\n    case 9: /* VS (V) */\n\n        tmp = tcg_temp_new();\n\n        tcg_gen_andi_i32(tmp, QREG_CC_DEST, CCF_V);\n\n        tcg_gen_brcondi_i32(TCG_COND_NE, tmp, 0, l1);\n\n        break;\n\n    case 10: /* PL (!N) */\n\n        tmp = tcg_temp_new();\n\n        tcg_gen_andi_i32(tmp, QREG_CC_DEST, CCF_N);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, l1);\n\n        break;\n\n    case 11: /* MI (N) */\n\n        tmp = tcg_temp_new();\n\n        tcg_gen_andi_i32(tmp, QREG_CC_DEST, CCF_N);\n\n        tcg_gen_brcondi_i32(TCG_COND_NE, tmp, 0, l1);\n\n        break;\n\n    case 12: /* GE (!(N ^ V)) */\n\n        tmp = tcg_temp_new();\n\n        assert(CCF_V == (CCF_N >> 2));\n\n        tcg_gen_shri_i32(tmp, QREG_CC_DEST, 2);\n\n        tcg_gen_xor_i32(tmp, tmp, QREG_CC_DEST);\n\n        tcg_gen_andi_i32(tmp, tmp, CCF_V);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, l1);\n\n        break;\n\n    case 13: /* LT (N ^ V) */\n\n        tmp = tcg_temp_new();\n\n        assert(CCF_V == (CCF_N >> 2));\n\n        tcg_gen_shri_i32(tmp, QREG_CC_DEST, 2);\n\n        tcg_gen_xor_i32(tmp, tmp, QREG_CC_DEST);\n\n        tcg_gen_andi_i32(tmp, tmp, CCF_V);\n\n        tcg_gen_brcondi_i32(TCG_COND_NE, tmp, 0, l1);\n\n        break;\n\n    case 14: /* GT (!(Z || (N ^ V))) */\n\n        tmp = tcg_temp_new();\n\n        assert(CCF_V == (CCF_N >> 2));\n\n        tcg_gen_andi_i32(tmp, QREG_CC_DEST, CCF_N);\n\n        tcg_gen_shri_i32(tmp, tmp, 2);\n\n        tcg_gen_xor_i32(tmp, tmp, QREG_CC_DEST);\n\n        tcg_gen_andi_i32(tmp, tmp, CCF_V | CCF_Z);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, l1);\n\n        break;\n\n    case 15: /* LE (Z || (N ^ V)) */\n\n        tmp = tcg_temp_new();\n\n        assert(CCF_V == (CCF_N >> 2));\n\n        tcg_gen_andi_i32(tmp, QREG_CC_DEST, CCF_N);\n\n        tcg_gen_shri_i32(tmp, tmp, 2);\n\n        tcg_gen_xor_i32(tmp, tmp, QREG_CC_DEST);\n\n        tcg_gen_andi_i32(tmp, tmp, CCF_V | CCF_Z);\n\n        tcg_gen_brcondi_i32(TCG_COND_NE, tmp, 0, l1);\n\n        break;\n\n    default:\n\n        /* Should ever happen.  */\n\n        abort();\n\n    }\n\n}\n", "idx": 17144, "_split": "valid", "_hash": "52482fa92193bfd96f28702dd63a4a98"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void add_pollfd(AioHandler *node)\n\n{\n\n    if (npfd == nalloc) {\n\n        if (nalloc == 0) {\n\n            pollfds_cleanup_notifier.notify = pollfds_cleanup;\n\n            qemu_thread_atexit_add(&pollfds_cleanup_notifier);\n\n            nalloc = 8;\n\n        } else {\n\n            g_assert(nalloc <= INT_MAX);\n\n            nalloc *= 2;\n\n        }\n\n        pollfds = g_renew(GPollFD, pollfds, nalloc);\n\n        nodes = g_renew(AioHandler *, nodes, nalloc);\n\n    }\n\n    nodes[npfd] = node;\n\n    pollfds[npfd] = (GPollFD) {\n\n        .fd = node->pfd.fd,\n\n        .events = node->pfd.events,\n\n    };\n\n    npfd++;\n\n}\n", "idx": 17157, "_split": "valid", "_hash": "952ef7e8e56c71fe7089782603d35a74"}
{"project": "qemu", "commit_id": "7ea11bf376aea4bf8340eb363de9777c7f93e556", "target": 1, "func": "static void xenfb_handle_events(struct XenFB *xenfb)\n\n{\n\n    uint32_t prod, cons;\n\n    struct xenfb_page *page = xenfb->c.page;\n\n\n\n    prod = page->out_prod;\n\n    if (prod == page->out_cons)\n\n\treturn;\n\n    xen_rmb();\t\t/* ensure we see ring contents up to prod */\n\n    for (cons = page->out_cons; cons != prod; cons++) {\n\n\tunion xenfb_out_event *event = &XENFB_OUT_RING_REF(page, cons);\n\n\tint x, y, w, h;\n\n\n\n\tswitch (event->type) {\n\n\tcase XENFB_TYPE_UPDATE:\n\n\t    if (xenfb->up_count == UP_QUEUE)\n\n\t\txenfb->up_fullscreen = 1;\n\n\t    if (xenfb->up_fullscreen)\n\n\t\tbreak;\n\n\t    x = MAX(event->update.x, 0);\n\n\t    y = MAX(event->update.y, 0);\n\n\t    w = MIN(event->update.width, xenfb->width - x);\n\n\t    h = MIN(event->update.height, xenfb->height - y);\n\n\t    if (w < 0 || h < 0) {\n\n                xen_be_printf(&xenfb->c.xendev, 1, \"bogus update ignored\\n\");\n\n\t\tbreak;\n\n\t    }\n\n\t    if (x != event->update.x ||\n\n                y != event->update.y ||\n\n\t\tw != event->update.width ||\n\n\t\th != event->update.height) {\n\n                xen_be_printf(&xenfb->c.xendev, 1, \"bogus update clipped\\n\");\n\n\t    }\n\n\t    if (w == xenfb->width && h > xenfb->height / 2) {\n\n\t\t/* scroll detector: updated more than 50% of the lines,\n\n\t\t * don't bother keeping track of the rectangles then */\n\n\t\txenfb->up_fullscreen = 1;\n\n\t    } else {\n\n\t\txenfb->up_rects[xenfb->up_count].x = x;\n\n\t\txenfb->up_rects[xenfb->up_count].y = y;\n\n\t\txenfb->up_rects[xenfb->up_count].w = w;\n\n\t\txenfb->up_rects[xenfb->up_count].h = h;\n\n\t\txenfb->up_count++;\n\n\t    }\n\n\t    break;\n\n#ifdef XENFB_TYPE_RESIZE\n\n\tcase XENFB_TYPE_RESIZE:\n\n\t    if (xenfb_configure_fb(xenfb, xenfb->fb_len,\n\n\t\t\t\t   event->resize.width,\n\n\t\t\t\t   event->resize.height,\n\n\t\t\t\t   event->resize.depth,\n\n\t\t\t\t   xenfb->fb_len,\n\n\t\t\t\t   event->resize.offset,\n\n\t\t\t\t   event->resize.stride) < 0)\n\n\t\tbreak;\n\n\t    xenfb_invalidate(xenfb);\n\n\t    break;\n\n#endif\n\n\t}\n\n    }\n\n    xen_mb();\t\t/* ensure we're done with ring contents */\n\n    page->out_cons = cons;\n\n}\n", "idx": 17195, "_split": "valid", "_hash": "17417b074f816b4d2520558103bd1c3e"}
{"project": "qemu", "commit_id": "6e9ea0c0629fe25723494a19498bedf4b781cbfa", "target": 0, "func": "static void calculate_geometry(int64_t total_sectors, uint16_t* cyls,\n\n    uint8_t* heads, uint8_t* secs_per_cyl)\n\n{\n\n    uint32_t cyls_times_heads;\n\n\n\n    if (total_sectors > 65535 * 16 * 255)\n\n        total_sectors = 65535 * 16 * 255;\n\n\n\n    if (total_sectors > 65535 * 16 * 63) {\n\n        *secs_per_cyl = 255;\n\n        *heads = 16;\n\n        cyls_times_heads = total_sectors / *secs_per_cyl;\n\n    } else {\n\n        *secs_per_cyl = 17;\n\n        cyls_times_heads = total_sectors / *secs_per_cyl;\n\n        *heads = (cyls_times_heads + 1023) / 1024;\n\n\n\n        if (*heads < 4)\n\n            *heads = 4;\n\n\n\n        if (cyls_times_heads >= (*heads * 1024) || *heads > 16) {\n\n            *secs_per_cyl = 31;\n\n            *heads = 16;\n\n            cyls_times_heads = total_sectors / *secs_per_cyl;\n\n        }\n\n\n\n        if (cyls_times_heads >= (*heads * 1024)) {\n\n            *secs_per_cyl = 63;\n\n            *heads = 16;\n\n            cyls_times_heads = total_sectors / *secs_per_cyl;\n\n        }\n\n    }\n\n\n\n    // Note: Rounding up deviates from the Virtual PC behaviour\n\n    // However, we need this to avoid truncating images in qemu-img convert\n\n    *cyls = (cyls_times_heads + *heads - 1) / *heads;\n\n}\n", "idx": 17245, "_split": "valid", "_hash": "a4d955ff100974872f8f4ecbae03c533"}
{"project": "qemu", "commit_id": "6a2a5aae02b9a0b53807b9ad91f15cd4988781f9", "target": 0, "func": "static int within_hwc_y_range(SM501State *state, int y, int crt)\n\n{\n\n    int hwc_y = get_hwc_y(state, crt);\n\n    return (hwc_y <= y && y < hwc_y + SM501_HWC_HEIGHT);\n\n}\n", "idx": 17249, "_split": "valid", "_hash": "e5221ce872ace5e1f186a6d24f261d31"}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_evmwumi(DisasContext *ctx)\n\n{\n\n    TCGv_i64 t0, t1;\n\n\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n\n\n    t0 = tcg_temp_new_i64();\n\n    t1 = tcg_temp_new_i64();\n\n\n\n    /* t0 := rA; t1 := rB */\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_ext32u_tl(t0, cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_ext32u_tl(t1, cpu_gpr[rB(ctx->opcode)]);\n\n#else\n\n    tcg_gen_extu_tl_i64(t0, cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_extu_tl_i64(t1, cpu_gpr[rB(ctx->opcode)]);\n\n#endif\n\n\n\n    tcg_gen_mul_i64(t0, t0, t1);  /* t0 := rA * rB */\n\n\n\n    gen_store_gpr64(rD(ctx->opcode), t0); /* rD := t0 */\n\n\n\n    tcg_temp_free_i64(t0);\n\n    tcg_temp_free_i64(t1);\n\n}\n", "idx": 17251, "_split": "valid", "_hash": "e8ee19f89e6a75517f59e67d37e52aef"}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static int v9fs_xattr_read(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp,\n\n                           uint64_t off, uint32_t max_count)\n\n{\n\n    ssize_t err;\n\n    size_t offset = 7;\n\n    int read_count;\n\n    int64_t xattr_len;\n\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n\n    VirtQueueElement *elem = &v->elems[pdu->idx];\n\n\n\n    xattr_len = fidp->fs.xattr.len;\n\n    read_count = xattr_len - off;\n\n    if (read_count > max_count) {\n\n        read_count = max_count;\n\n    } else if (read_count < 0) {\n\n        /*\n\n         * read beyond XATTR value\n\n         */\n\n        read_count = 0;\n\n    }\n\n    err = pdu_marshal(pdu, offset, \"d\", read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n\n\n    err = v9fs_pack(elem->in_sg, elem->in_num, offset,\n\n                    ((char *)fidp->fs.xattr.value) + off,\n\n                    read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n    return offset;\n\n}\n", "idx": 17299, "_split": "valid", "_hash": "74346819a9f213ddeea145ffed6e4f86"}
{"project": "qemu", "commit_id": "213189ab65d83ecd9072f27c80a15dcb91b6bdbf", "target": 0, "func": "static void virtio_blk_dma_restart_cb(void *opaque, int running, int reason)\n\n{\n\n    VirtIOBlock *s = opaque;\n\n    VirtIOBlockReq *req = s->rq;\n\n\n\n    if (!running)\n\n        return;\n\n\n\n    s->rq = NULL;\n\n\n\n    while (req) {\n\n        virtio_blk_handle_write(req);\n\n        req = req->next;\n\n    }\n\n}\n", "idx": 17305, "_split": "valid", "_hash": "cbf57416f652ffa3dd87579ccd483fe7"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void pic_ioport_write(void *opaque, target_phys_addr_t addr64,\n\n                             uint64_t val64, unsigned size)\n\n{\n\n    PICCommonState *s = opaque;\n\n    uint32_t addr = addr64;\n\n    uint32_t val = val64;\n\n    int priority, cmd, irq;\n\n\n\n    DPRINTF(\"write: addr=0x%02x val=0x%02x\\n\", addr, val);\n\n    if (addr == 0) {\n\n        if (val & 0x10) {\n\n            pic_init_reset(s);\n\n            s->init_state = 1;\n\n            s->init4 = val & 1;\n\n            s->single_mode = val & 2;\n\n            if (val & 0x08) {\n\n                hw_error(\"level sensitive irq not supported\");\n\n            }\n\n        } else if (val & 0x08) {\n\n            if (val & 0x04) {\n\n                s->poll = 1;\n\n            }\n\n            if (val & 0x02) {\n\n                s->read_reg_select = val & 1;\n\n            }\n\n            if (val & 0x40) {\n\n                s->special_mask = (val >> 5) & 1;\n\n            }\n\n        } else {\n\n            cmd = val >> 5;\n\n            switch (cmd) {\n\n            case 0:\n\n            case 4:\n\n                s->rotate_on_auto_eoi = cmd >> 2;\n\n                break;\n\n            case 1: /* end of interrupt */\n\n            case 5:\n\n                priority = get_priority(s, s->isr);\n\n                if (priority != 8) {\n\n                    irq = (priority + s->priority_add) & 7;\n\n                    s->isr &= ~(1 << irq);\n\n                    if (cmd == 5) {\n\n                        s->priority_add = (irq + 1) & 7;\n\n                    }\n\n                    pic_update_irq(s);\n\n                }\n\n                break;\n\n            case 3:\n\n                irq = val & 7;\n\n                s->isr &= ~(1 << irq);\n\n                pic_update_irq(s);\n\n                break;\n\n            case 6:\n\n                s->priority_add = (val + 1) & 7;\n\n                pic_update_irq(s);\n\n                break;\n\n            case 7:\n\n                irq = val & 7;\n\n                s->isr &= ~(1 << irq);\n\n                s->priority_add = (irq + 1) & 7;\n\n                pic_update_irq(s);\n\n                break;\n\n            default:\n\n                /* no operation */\n\n                break;\n\n            }\n\n        }\n\n    } else {\n\n        switch (s->init_state) {\n\n        case 0:\n\n            /* normal mode */\n\n            s->imr = val;\n\n            pic_update_irq(s);\n\n            break;\n\n        case 1:\n\n            s->irq_base = val & 0xf8;\n\n            s->init_state = s->single_mode ? (s->init4 ? 3 : 0) : 2;\n\n            break;\n\n        case 2:\n\n            if (s->init4) {\n\n                s->init_state = 3;\n\n            } else {\n\n                s->init_state = 0;\n\n            }\n\n            break;\n\n        case 3:\n\n            s->special_fully_nested_mode = (val >> 4) & 1;\n\n            s->auto_eoi = (val >> 1) & 1;\n\n            s->init_state = 0;\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 17323, "_split": "valid", "_hash": "74bf9bcd65700d68b2ab286e88e2d647"}
{"project": "qemu", "commit_id": "3211215e741f6e4824ddfc4919428e8d1b82a3c2", "target": 1, "func": "static abi_long do_ioctl_dm(const IOCTLEntry *ie, uint8_t *buf_temp, int fd,\n                            int cmd, abi_long arg)\n{\n    void *argptr;\n    struct dm_ioctl *host_dm;\n    abi_long guest_data;\n    uint32_t guest_data_size;\n    int target_size;\n    const argtype *arg_type = ie->arg_type;\n    abi_long ret;\n    void *big_buf = NULL;\n    char *host_data;\n    arg_type++;\n    target_size = thunk_type_size(arg_type, 0);\n    argptr = lock_user(VERIFY_READ, arg, target_size, 1);\n    thunk_convert(buf_temp, argptr, arg_type, THUNK_HOST);\n    unlock_user(argptr, arg, 0);\n    /* buf_temp is too small, so fetch things into a bigger buffer */\n    big_buf = g_malloc0(((struct dm_ioctl*)buf_temp)->data_size * 2);\n    memcpy(big_buf, buf_temp, target_size);\n    buf_temp = big_buf;\n    host_dm = big_buf;\n    guest_data = arg + host_dm->data_start;\n    if ((guest_data - arg) < 0) {\n        ret = -EINVAL;\n    guest_data_size = host_dm->data_size - host_dm->data_start;\n    host_data = (char*)host_dm + host_dm->data_start;\n    argptr = lock_user(VERIFY_READ, guest_data, guest_data_size, 1);\n    switch (ie->host_cmd) {\n    case DM_REMOVE_ALL:\n    case DM_LIST_DEVICES:\n    case DM_DEV_CREATE:\n    case DM_DEV_REMOVE:\n    case DM_DEV_SUSPEND:\n    case DM_DEV_STATUS:\n    case DM_DEV_WAIT:\n    case DM_TABLE_STATUS:\n    case DM_TABLE_CLEAR:\n    case DM_TABLE_DEPS:\n    case DM_LIST_VERSIONS:\n        /* no input data */\n        break;\n    case DM_DEV_RENAME:\n    case DM_DEV_SET_GEOMETRY:\n        /* data contains only strings */\n        memcpy(host_data, argptr, guest_data_size);\n        break;\n    case DM_TARGET_MSG:\n        memcpy(host_data, argptr, guest_data_size);\n        *(uint64_t*)host_data = tswap64(*(uint64_t*)argptr);\n        break;\n    case DM_TABLE_LOAD:\n    {\n        void *gspec = argptr;\n        void *cur_data = host_data;\n        const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) };\n        int spec_size = thunk_type_size(arg_type, 0);\n        int i;\n        for (i = 0; i < host_dm->target_count; i++) {\n            struct dm_target_spec *spec = cur_data;\n            uint32_t next;\n            int slen;\n            thunk_convert(spec, gspec, arg_type, THUNK_HOST);\n            slen = strlen((char*)gspec + spec_size) + 1;\n            next = spec->next;\n            spec->next = sizeof(*spec) + slen;\n            strcpy((char*)&spec[1], gspec + spec_size);\n            gspec += next;\n            cur_data += spec->next;\n        break;\n    default:\n        ret = -TARGET_EINVAL;\n        unlock_user(argptr, guest_data, 0);\n    unlock_user(argptr, guest_data, 0);\n    ret = get_errno(safe_ioctl(fd, ie->host_cmd, buf_temp));\n    if (!is_error(ret)) {\n        guest_data = arg + host_dm->data_start;\n        guest_data_size = host_dm->data_size - host_dm->data_start;\n        argptr = lock_user(VERIFY_WRITE, guest_data, guest_data_size, 0);\n        switch (ie->host_cmd) {\n        case DM_REMOVE_ALL:\n        case DM_DEV_CREATE:\n        case DM_DEV_REMOVE:\n        case DM_DEV_RENAME:\n        case DM_DEV_SUSPEND:\n        case DM_DEV_STATUS:\n        case DM_TABLE_LOAD:\n        case DM_TABLE_CLEAR:\n        case DM_TARGET_MSG:\n        case DM_DEV_SET_GEOMETRY:\n            /* no return data */\n            break;\n        case DM_LIST_DEVICES:\n        {\n            struct dm_name_list *nl = (void*)host_dm + host_dm->data_start;\n            uint32_t remaining_data = guest_data_size;\n            void *cur_data = argptr;\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_name_list) };\n            int nl_size = 12; /* can't use thunk_size due to alignment */\n            while (1) {\n                uint32_t next = nl->next;\n                if (next) {\n                    nl->next = nl_size + (strlen(nl->name) + 1);\n                if (remaining_data < nl->next) {\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n                    break;\n                thunk_convert(cur_data, nl, arg_type, THUNK_TARGET);\n                strcpy(cur_data + nl_size, nl->name);\n                cur_data += nl->next;\n                remaining_data -= nl->next;\n                if (!next) {\n                    break;\n                nl = (void*)nl + next;\n            break;\n        case DM_DEV_WAIT:\n        case DM_TABLE_STATUS:\n        {\n            struct dm_target_spec *spec = (void*)host_dm + host_dm->data_start;\n            void *cur_data = argptr;\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) };\n            int spec_size = thunk_type_size(arg_type, 0);\n            int i;\n            for (i = 0; i < host_dm->target_count; i++) {\n                uint32_t next = spec->next;\n                int slen = strlen((char*)&spec[1]) + 1;\n                spec->next = (cur_data - argptr) + spec_size + slen;\n                if (guest_data_size < spec->next) {\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n                    break;\n                thunk_convert(cur_data, spec, arg_type, THUNK_TARGET);\n                strcpy(cur_data + spec_size, (char*)&spec[1]);\n                cur_data = argptr + spec->next;\n                spec = (void*)host_dm + host_dm->data_start + next;\n            break;\n        case DM_TABLE_DEPS:\n        {\n            void *hdata = (void*)host_dm + host_dm->data_start;\n            int count = *(uint32_t*)hdata;\n            uint64_t *hdev = hdata + 8;\n            uint64_t *gdev = argptr + 8;\n            int i;\n            *(uint32_t*)argptr = tswap32(count);\n            for (i = 0; i < count; i++) {\n                *gdev = tswap64(*hdev);\n                gdev++;\n                hdev++;\n            break;\n        case DM_LIST_VERSIONS:\n        {\n            struct dm_target_versions *vers = (void*)host_dm + host_dm->data_start;\n            uint32_t remaining_data = guest_data_size;\n            void *cur_data = argptr;\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_versions) };\n            int vers_size = thunk_type_size(arg_type, 0);\n            while (1) {\n                uint32_t next = vers->next;\n                if (next) {\n                    vers->next = vers_size + (strlen(vers->name) + 1);\n                if (remaining_data < vers->next) {\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n                    break;\n                thunk_convert(cur_data, vers, arg_type, THUNK_TARGET);\n                strcpy(cur_data + vers_size, vers->name);\n                cur_data += vers->next;\n                remaining_data -= vers->next;\n                if (!next) {\n                    break;\n                vers = (void*)vers + next;\n            break;\n        default:\n            unlock_user(argptr, guest_data, 0);\n            ret = -TARGET_EINVAL;\n        unlock_user(argptr, guest_data, guest_data_size);\n        argptr = lock_user(VERIFY_WRITE, arg, target_size, 0);\n        thunk_convert(argptr, buf_temp, arg_type, THUNK_TARGET);\n        unlock_user(argptr, arg, target_size);\nout:\n    g_free(big_buf);\n    return ret;", "idx": 17338, "_split": "valid", "_hash": "cc07f053826c06578b4b5e9ab465000f"}
{"project": "qemu", "commit_id": "c99a55d38dd5b5131f3fcbbaf41828a09ee62544", "target": 1, "func": "static void arm1026_initfn(Object *obj)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(obj);\n\n\n\n    cpu->dtb_compatible = \"arm,arm1026\";\n\n    set_feature(&cpu->env, ARM_FEATURE_V5);\n\n    set_feature(&cpu->env, ARM_FEATURE_VFP);\n\n    set_feature(&cpu->env, ARM_FEATURE_AUXCR);\n\n    set_feature(&cpu->env, ARM_FEATURE_DUMMY_C15_REGS);\n\n    set_feature(&cpu->env, ARM_FEATURE_CACHE_TEST_CLEAN);\n\n\n    cpu->midr = 0x4106a262;\n\n    cpu->reset_fpsid = 0x410110a0;\n\n    cpu->ctr = 0x1dd20d2;\n\n    cpu->reset_sctlr = 0x00090078;\n\n    cpu->reset_auxcr = 1;\n\n    {\n\n        /* The 1026 had an IFAR at c6,c0,0,1 rather than the ARMv6 c6,c0,0,2 */\n\n        ARMCPRegInfo ifar = {\n\n            .name = \"IFAR\", .cp = 15, .crn = 6, .crm = 0, .opc1 = 0, .opc2 = 1,\n\n            .access = PL1_RW,\n\n            .fieldoffset = offsetof(CPUARMState, cp15.ifar_ns),\n\n            .resetvalue = 0\n\n        };\n\n        define_one_arm_cp_reg(cpu, &ifar);\n\n    }\n\n}", "idx": 17355, "_split": "valid", "_hash": "d1ba9a1bf89df8bcafdf0ed049c8cc27"}
{"project": "qemu", "commit_id": "903a41d3415960240cb3b9f1d66f3707b27010d6", "target": 1, "func": "static void acpi_memory_hotplug_write(void *opaque, hwaddr addr, uint64_t data,\n\n                                      unsigned int size)\n\n{\n\n    MemHotplugState *mem_st = opaque;\n\n    MemStatus *mdev;\n\n    ACPIOSTInfo *info;\n\n    DeviceState *dev = NULL;\n\n    HotplugHandler *hotplug_ctrl = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    if (!mem_st->dev_count) {\n\n        return;\n\n    }\n\n\n\n    if (addr) {\n\n        if (mem_st->selector >= mem_st->dev_count) {\n\n            trace_mhp_acpi_invalid_slot_selected(mem_st->selector);\n\n            return;\n\n        }\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x0: /* DIMM slot selector */\n\n        mem_st->selector = data;\n\n        trace_mhp_acpi_write_slot(mem_st->selector);\n\n        break;\n\n    case 0x4: /* _OST event  */\n\n        mdev = &mem_st->devs[mem_st->selector];\n\n        if (data == 1) {\n\n            /* TODO: handle device insert OST event */\n\n        } else if (data == 3) {\n\n            /* TODO: handle device remove OST event */\n\n        }\n\n        mdev->ost_event = data;\n\n        trace_mhp_acpi_write_ost_ev(mem_st->selector, mdev->ost_event);\n\n        break;\n\n    case 0x8: /* _OST status */\n\n        mdev = &mem_st->devs[mem_st->selector];\n\n        mdev->ost_status = data;\n\n        trace_mhp_acpi_write_ost_status(mem_st->selector, mdev->ost_status);\n\n        /* TODO: implement memory removal on guest signal */\n\n\n\n        info = acpi_memory_device_status(mem_st->selector, mdev);\n\n        qapi_event_send_acpi_device_ost(info, &error_abort);\n\n        qapi_free_ACPIOSTInfo(info);\n\n        break;\n\n    case 0x14: /* set is_* fields  */\n\n        mdev = &mem_st->devs[mem_st->selector];\n\n        if (data & 2) { /* clear insert event */\n\n            mdev->is_inserting  = false;\n\n            trace_mhp_acpi_clear_insert_evt(mem_st->selector);\n\n        } else if (data & 4) {\n\n            mdev->is_removing = false;\n\n            trace_mhp_acpi_clear_remove_evt(mem_st->selector);\n\n        } else if (data & 8) {\n\n            if (!mdev->is_enabled) {\n\n                trace_mhp_acpi_ejecting_invalid_slot(mem_st->selector);\n\n                break;\n\n            }\n\n\n\n            dev = DEVICE(mdev->dimm);\n\n            hotplug_ctrl = qdev_get_hotplug_handler(dev);\n\n            /* call pc-dimm unplug cb */\n\n            hotplug_handler_unplug(hotplug_ctrl, dev, &local_err);\n\n            if (local_err) {\n\n                trace_mhp_acpi_pc_dimm_delete_failed(mem_st->selector);\n\n                qapi_event_send_mem_unplug_error(dev->id,\n\n                                                 error_get_pretty(local_err),\n\n                                                 &error_abort);\n\n\n                break;\n\n            }\n\n            trace_mhp_acpi_pc_dimm_deleted(mem_st->selector);\n\n        }\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n}", "idx": 17367, "_split": "valid", "_hash": "39e48830cf44552b020b2836840dd7bc"}
{"project": "qemu", "commit_id": "0b1bcb00fb2baf5f3227dd9cd849fa69bf50d7a8", "target": 1, "func": "long do_rt_sigreturn(CPUState *env)\n\n{\n\n    fprintf(stderr, \"do_rt_sigreturn: not implemented\\n\");\n\n    return -TARGET_ENOSYS;\n\n}\n", "idx": 17375, "_split": "valid", "_hash": "65756af2a07f7786d04e93fe47295d6e"}
{"project": "qemu", "commit_id": "f81bdefb63243e82d16ce49332f7cf74d10b8f27", "target": 1, "func": "void vga_hw_screen_dump(const char *filename)\n\n{\n\n    TextConsole *previous_active_console;\n\n\n\n    previous_active_console = active_console;\n\n    active_console = consoles[0];\n\n    /* There is currently no way of specifying which screen we want to dump,\n\n       so always dump the first one.  */\n\n    if (consoles[0] && consoles[0]->hw_screen_dump)\n\n        consoles[0]->hw_screen_dump(consoles[0]->hw, filename);\n\n    active_console = previous_active_console;\n\n}\n", "idx": 17376, "_split": "valid", "_hash": "b89bf704a91b8e969477798a3ddf68de"}
{"project": "qemu", "commit_id": "0f8c289ad539feb5135c545bea947b310a893f4b", "target": 1, "func": "static int net_socket_udp_init(NetClientState *peer,\n\n                                 const char *model,\n\n                                 const char *name,\n\n                                 const char *rhost,\n\n                                 const char *lhost)\n\n{\n\n    NetSocketState *s;\n\n    int fd, ret;\n\n    struct sockaddr_in laddr, raddr;\n\n\n\n    if (parse_host_port(&laddr, lhost) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (parse_host_port(&raddr, rhost) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    fd = qemu_socket(PF_INET, SOCK_DGRAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket(PF_INET, SOCK_DGRAM)\");\n\n        return -1;\n\n    }\n\n\n\n    ret = socket_set_fast_reuse(fd);\n\n    if (ret < 0) {\n\n        closesocket(fd);\n\n        return -1;\n\n    }\n\n    ret = bind(fd, (struct sockaddr *)&laddr, sizeof(laddr));\n\n    if (ret < 0) {\n\n        perror(\"bind\");\n\n        closesocket(fd);\n\n        return -1;\n\n    }\n\n    qemu_set_nonblock(fd);\n\n\n\n    s = net_socket_fd_init(peer, model, name, fd, 0);\n\n    if (!s) {\n\n        return -1;\n\n    }\n\n\n\n    s->dgram_dst = raddr;\n\n\n\n    snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n             \"socket: udp=%s:%d\",\n\n             inet_ntoa(raddr.sin_addr), ntohs(raddr.sin_port));\n\n    return 0;\n\n}\n", "idx": 17378, "_split": "valid", "_hash": "3f6ee83b076e1cb69c748788fe948d5a"}
{"project": "qemu", "commit_id": "0d9acba8fddbf970c7353083e6a60b47017ce3e4", "target": 1, "func": "static void audio_init (PCIBus *pci_bus)\n\n{\n\n    struct soundhw *c;\n\n    int audio_enabled = 0;\n\n\n\n    for (c = soundhw; !audio_enabled && c->name; ++c) {\n\n        audio_enabled = c->enabled;\n\n    }\n\n\n\n    if (audio_enabled) {\n\n        AudioState *s;\n\n\n\n        s = AUD_init ();\n\n        if (s) {\n\n            for (c = soundhw; c->name; ++c) {\n\n                if (c->enabled)\n\n                    c->init.init_pci (pci_bus, s);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 17386, "_split": "valid", "_hash": "4a597eff85773f0f89dd7ce8f5995773"}
{"project": "qemu", "commit_id": "3b39d734141a71296d08af3d4c32f872fafd782e", "target": 1, "func": "static bool get_phys_addr_lpae(CPUARMState *env, target_ulong address,\n\n                               MMUAccessType access_type, ARMMMUIdx mmu_idx,\n\n                               hwaddr *phys_ptr, MemTxAttrs *txattrs, int *prot,\n\n                               target_ulong *page_size_ptr,\n\n                               ARMMMUFaultInfo *fi, ARMCacheAttrs *cacheattrs)\n\n{\n\n    ARMCPU *cpu = arm_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    /* Read an LPAE long-descriptor translation table. */\n\n    ARMFaultType fault_type = ARMFault_Translation;\n\n    uint32_t level;\n\n    uint32_t epd = 0;\n\n    int32_t t0sz, t1sz;\n\n    uint32_t tg;\n\n    uint64_t ttbr;\n\n    int ttbr_select;\n\n    hwaddr descaddr, indexmask, indexmask_grainsize;\n\n    uint32_t tableattrs;\n\n    target_ulong page_size;\n\n    uint32_t attrs;\n\n    int32_t stride = 9;\n\n    int32_t addrsize;\n\n    int inputsize;\n\n    int32_t tbi = 0;\n\n    TCR *tcr = regime_tcr(env, mmu_idx);\n\n    int ap, ns, xn, pxn;\n\n    uint32_t el = regime_el(env, mmu_idx);\n\n    bool ttbr1_valid = true;\n\n    uint64_t descaddrmask;\n\n    bool aarch64 = arm_el_is_aa64(env, el);\n\n\n\n    /* TODO:\n\n     * This code does not handle the different format TCR for VTCR_EL2.\n\n     * This code also does not support shareability levels.\n\n     * Attribute and permission bit handling should also be checked when adding\n\n     * support for those page table walks.\n\n     */\n\n    if (aarch64) {\n\n        level = 0;\n\n        addrsize = 64;\n\n        if (el > 1) {\n\n            if (mmu_idx != ARMMMUIdx_S2NS) {\n\n                tbi = extract64(tcr->raw_tcr, 20, 1);\n\n            }\n\n        } else {\n\n            if (extract64(address, 55, 1)) {\n\n                tbi = extract64(tcr->raw_tcr, 38, 1);\n\n            } else {\n\n                tbi = extract64(tcr->raw_tcr, 37, 1);\n\n            }\n\n        }\n\n        tbi *= 8;\n\n\n\n        /* If we are in 64-bit EL2 or EL3 then there is no TTBR1, so mark it\n\n         * invalid.\n\n         */\n\n        if (el > 1) {\n\n            ttbr1_valid = false;\n\n        }\n\n    } else {\n\n        level = 1;\n\n        addrsize = 32;\n\n        /* There is no TTBR1 for EL2 */\n\n        if (el == 2) {\n\n            ttbr1_valid = false;\n\n        }\n\n    }\n\n\n\n    /* Determine whether this address is in the region controlled by\n\n     * TTBR0 or TTBR1 (or if it is in neither region and should fault).\n\n     * This is a Non-secure PL0/1 stage 1 translation, so controlled by\n\n     * TTBCR/TTBR0/TTBR1 in accordance with ARM ARM DDI0406C table B-32:\n\n     */\n\n    if (aarch64) {\n\n        /* AArch64 translation.  */\n\n        t0sz = extract32(tcr->raw_tcr, 0, 6);\n\n        t0sz = MIN(t0sz, 39);\n\n        t0sz = MAX(t0sz, 16);\n\n    } else if (mmu_idx != ARMMMUIdx_S2NS) {\n\n        /* AArch32 stage 1 translation.  */\n\n        t0sz = extract32(tcr->raw_tcr, 0, 3);\n\n    } else {\n\n        /* AArch32 stage 2 translation.  */\n\n        bool sext = extract32(tcr->raw_tcr, 4, 1);\n\n        bool sign = extract32(tcr->raw_tcr, 3, 1);\n\n        /* Address size is 40-bit for a stage 2 translation,\n\n         * and t0sz can be negative (from -8 to 7),\n\n         * so we need to adjust it to use the TTBR selecting logic below.\n\n         */\n\n        addrsize = 40;\n\n        t0sz = sextract32(tcr->raw_tcr, 0, 4) + 8;\n\n\n\n        /* If the sign-extend bit is not the same as t0sz[3], the result\n\n         * is unpredictable. Flag this as a guest error.  */\n\n        if (sign != sext) {\n\n            qemu_log_mask(LOG_GUEST_ERROR,\n\n                          \"AArch32: VTCR.S / VTCR.T0SZ[3] mismatch\\n\");\n\n        }\n\n    }\n\n    t1sz = extract32(tcr->raw_tcr, 16, 6);\n\n    if (aarch64) {\n\n        t1sz = MIN(t1sz, 39);\n\n        t1sz = MAX(t1sz, 16);\n\n    }\n\n    if (t0sz && !extract64(address, addrsize - t0sz, t0sz - tbi)) {\n\n        /* there is a ttbr0 region and we are in it (high bits all zero) */\n\n        ttbr_select = 0;\n\n    } else if (ttbr1_valid && t1sz &&\n\n               !extract64(~address, addrsize - t1sz, t1sz - tbi)) {\n\n        /* there is a ttbr1 region and we are in it (high bits all one) */\n\n        ttbr_select = 1;\n\n    } else if (!t0sz) {\n\n        /* ttbr0 region is \"everything not in the ttbr1 region\" */\n\n        ttbr_select = 0;\n\n    } else if (!t1sz && ttbr1_valid) {\n\n        /* ttbr1 region is \"everything not in the ttbr0 region\" */\n\n        ttbr_select = 1;\n\n    } else {\n\n        /* in the gap between the two regions, this is a Translation fault */\n\n        fault_type = ARMFault_Translation;\n\n        goto do_fault;\n\n    }\n\n\n\n    /* Note that QEMU ignores shareability and cacheability attributes,\n\n     * so we don't need to do anything with the SH, ORGN, IRGN fields\n\n     * in the TTBCR.  Similarly, TTBCR:A1 selects whether we get the\n\n     * ASID from TTBR0 or TTBR1, but QEMU's TLB doesn't currently\n\n     * implement any ASID-like capability so we can ignore it (instead\n\n     * we will always flush the TLB any time the ASID is changed).\n\n     */\n\n    if (ttbr_select == 0) {\n\n        ttbr = regime_ttbr(env, mmu_idx, 0);\n\n        if (el < 2) {\n\n            epd = extract32(tcr->raw_tcr, 7, 1);\n\n        }\n\n        inputsize = addrsize - t0sz;\n\n\n\n        tg = extract32(tcr->raw_tcr, 14, 2);\n\n        if (tg == 1) { /* 64KB pages */\n\n            stride = 13;\n\n        }\n\n        if (tg == 2) { /* 16KB pages */\n\n            stride = 11;\n\n        }\n\n    } else {\n\n        /* We should only be here if TTBR1 is valid */\n\n        assert(ttbr1_valid);\n\n\n\n        ttbr = regime_ttbr(env, mmu_idx, 1);\n\n        epd = extract32(tcr->raw_tcr, 23, 1);\n\n        inputsize = addrsize - t1sz;\n\n\n\n        tg = extract32(tcr->raw_tcr, 30, 2);\n\n        if (tg == 3)  { /* 64KB pages */\n\n            stride = 13;\n\n        }\n\n        if (tg == 1) { /* 16KB pages */\n\n            stride = 11;\n\n        }\n\n    }\n\n\n\n    /* Here we should have set up all the parameters for the translation:\n\n     * inputsize, ttbr, epd, stride, tbi\n\n     */\n\n\n\n    if (epd) {\n\n        /* Translation table walk disabled => Translation fault on TLB miss\n\n         * Note: This is always 0 on 64-bit EL2 and EL3.\n\n         */\n\n        goto do_fault;\n\n    }\n\n\n\n    if (mmu_idx != ARMMMUIdx_S2NS) {\n\n        /* The starting level depends on the virtual address size (which can\n\n         * be up to 48 bits) and the translation granule size. It indicates\n\n         * the number of strides (stride bits at a time) needed to\n\n         * consume the bits of the input address. In the pseudocode this is:\n\n         *  level = 4 - RoundUp((inputsize - grainsize) / stride)\n\n         * where their 'inputsize' is our 'inputsize', 'grainsize' is\n\n         * our 'stride + 3' and 'stride' is our 'stride'.\n\n         * Applying the usual \"rounded up m/n is (m+n-1)/n\" and simplifying:\n\n         * = 4 - (inputsize - stride - 3 + stride - 1) / stride\n\n         * = 4 - (inputsize - 4) / stride;\n\n         */\n\n        level = 4 - (inputsize - 4) / stride;\n\n    } else {\n\n        /* For stage 2 translations the starting level is specified by the\n\n         * VTCR_EL2.SL0 field (whose interpretation depends on the page size)\n\n         */\n\n        uint32_t sl0 = extract32(tcr->raw_tcr, 6, 2);\n\n        uint32_t startlevel;\n\n        bool ok;\n\n\n\n        if (!aarch64 || stride == 9) {\n\n            /* AArch32 or 4KB pages */\n\n            startlevel = 2 - sl0;\n\n        } else {\n\n            /* 16KB or 64KB pages */\n\n            startlevel = 3 - sl0;\n\n        }\n\n\n\n        /* Check that the starting level is valid. */\n\n        ok = check_s2_mmu_setup(cpu, aarch64, startlevel,\n\n                                inputsize, stride);\n\n        if (!ok) {\n\n            fault_type = ARMFault_Translation;\n\n            goto do_fault;\n\n        }\n\n        level = startlevel;\n\n    }\n\n\n\n    indexmask_grainsize = (1ULL << (stride + 3)) - 1;\n\n    indexmask = (1ULL << (inputsize - (stride * (4 - level)))) - 1;\n\n\n\n    /* Now we can extract the actual base address from the TTBR */\n\n    descaddr = extract64(ttbr, 0, 48);\n\n    descaddr &= ~indexmask;\n\n\n\n    /* The address field in the descriptor goes up to bit 39 for ARMv7\n\n     * but up to bit 47 for ARMv8, but we use the descaddrmask\n\n     * up to bit 39 for AArch32, because we don't need other bits in that case\n\n     * to construct next descriptor address (anyway they should be all zeroes).\n\n     */\n\n    descaddrmask = ((1ull << (aarch64 ? 48 : 40)) - 1) &\n\n                   ~indexmask_grainsize;\n\n\n\n    /* Secure accesses start with the page table in secure memory and\n\n     * can be downgraded to non-secure at any step. Non-secure accesses\n\n     * remain non-secure. We implement this by just ORing in the NSTable/NS\n\n     * bits at each step.\n\n     */\n\n    tableattrs = regime_is_secure(env, mmu_idx) ? 0 : (1 << 4);\n\n    for (;;) {\n\n        uint64_t descriptor;\n\n        bool nstable;\n\n\n\n        descaddr |= (address >> (stride * (4 - level))) & indexmask;\n\n        descaddr &= ~7ULL;\n\n        nstable = extract32(tableattrs, 4, 1);\n\n        descriptor = arm_ldq_ptw(cs, descaddr, !nstable, mmu_idx, fi);\n\n        if (fi->s1ptw) {\n\n            goto do_fault;\n\n        }\n\n\n\n        if (!(descriptor & 1) ||\n\n            (!(descriptor & 2) && (level == 3))) {\n\n            /* Invalid, or the Reserved level 3 encoding */\n\n            goto do_fault;\n\n        }\n\n        descaddr = descriptor & descaddrmask;\n\n\n\n        if ((descriptor & 2) && (level < 3)) {\n\n            /* Table entry. The top five bits are attributes which  may\n\n             * propagate down through lower levels of the table (and\n\n             * which are all arranged so that 0 means \"no effect\", so\n\n             * we can gather them up by ORing in the bits at each level).\n\n             */\n\n            tableattrs |= extract64(descriptor, 59, 5);\n\n            level++;\n\n            indexmask = indexmask_grainsize;\n\n            continue;\n\n        }\n\n        /* Block entry at level 1 or 2, or page entry at level 3.\n\n         * These are basically the same thing, although the number\n\n         * of bits we pull in from the vaddr varies.\n\n         */\n\n        page_size = (1ULL << ((stride * (4 - level)) + 3));\n\n        descaddr |= (address & (page_size - 1));\n\n        /* Extract attributes from the descriptor */\n\n        attrs = extract64(descriptor, 2, 10)\n\n            | (extract64(descriptor, 52, 12) << 10);\n\n\n\n        if (mmu_idx == ARMMMUIdx_S2NS) {\n\n            /* Stage 2 table descriptors do not include any attribute fields */\n\n            break;\n\n        }\n\n        /* Merge in attributes from table descriptors */\n\n        attrs |= extract32(tableattrs, 0, 2) << 11; /* XN, PXN */\n\n        attrs |= extract32(tableattrs, 3, 1) << 5; /* APTable[1] => AP[2] */\n\n        /* The sense of AP[1] vs APTable[0] is reversed, as APTable[0] == 1\n\n         * means \"force PL1 access only\", which means forcing AP[1] to 0.\n\n         */\n\n        if (extract32(tableattrs, 2, 1)) {\n\n            attrs &= ~(1 << 4);\n\n        }\n\n        attrs |= nstable << 3; /* NS */\n\n        break;\n\n    }\n\n    /* Here descaddr is the final physical address, and attributes\n\n     * are all in attrs.\n\n     */\n\n    fault_type = ARMFault_AccessFlag;\n\n    if ((attrs & (1 << 8)) == 0) {\n\n        /* Access flag */\n\n        goto do_fault;\n\n    }\n\n\n\n    ap = extract32(attrs, 4, 2);\n\n    xn = extract32(attrs, 12, 1);\n\n\n\n    if (mmu_idx == ARMMMUIdx_S2NS) {\n\n        ns = true;\n\n        *prot = get_S2prot(env, ap, xn);\n\n    } else {\n\n        ns = extract32(attrs, 3, 1);\n\n        pxn = extract32(attrs, 11, 1);\n\n        *prot = get_S1prot(env, mmu_idx, aarch64, ap, ns, xn, pxn);\n\n    }\n\n\n\n    fault_type = ARMFault_Permission;\n\n    if (!(*prot & (1 << access_type))) {\n\n        goto do_fault;\n\n    }\n\n\n\n    if (ns) {\n\n        /* The NS bit will (as required by the architecture) have no effect if\n\n         * the CPU doesn't support TZ or this is a non-secure translation\n\n         * regime, because the attribute will already be non-secure.\n\n         */\n\n        txattrs->secure = false;\n\n    }\n\n\n\n    if (cacheattrs != NULL) {\n\n        if (mmu_idx == ARMMMUIdx_S2NS) {\n\n            cacheattrs->attrs = convert_stage2_attrs(env,\n\n                                                     extract32(attrs, 0, 4));\n\n        } else {\n\n            /* Index into MAIR registers for cache attributes */\n\n            uint8_t attrindx = extract32(attrs, 0, 3);\n\n            uint64_t mair = env->cp15.mair_el[regime_el(env, mmu_idx)];\n\n            assert(attrindx <= 7);\n\n            cacheattrs->attrs = extract64(mair, attrindx * 8, 8);\n\n        }\n\n        cacheattrs->shareability = extract32(attrs, 6, 2);\n\n    }\n\n\n\n    *phys_ptr = descaddr;\n\n    *page_size_ptr = page_size;\n\n    return false;\n\n\n\ndo_fault:\n\n    fi->type = fault_type;\n\n    fi->level = level;\n\n    /* Tag the error as S2 for failed S1 PTW at S2 or ordinary S2.  */\n\n    fi->stage2 = fi->s1ptw || (mmu_idx == ARMMMUIdx_S2NS);\n\n    return true;\n\n}\n", "idx": 17402, "_split": "valid", "_hash": "d291a5cde70a38a6151bc708d86aa052"}
{"project": "qemu", "commit_id": "9c554c1c0b01642c39232489cef8301a7858824d", "target": 1, "func": "void cuda_init (int *cuda_mem_index, qemu_irq irq)\n\n{\n\n    struct tm tm;\n\n    CUDAState *s = &cuda_state;\n\n\n\n    s->irq = irq;\n\n\n\n    s->timers[0].index = 0;\n\n    s->timers[0].timer = qemu_new_timer(vm_clock, cuda_timer1, s);\n\n\n\n    s->timers[1].index = 1;\n\n\n\n    qemu_get_timedate(&tm, RTC_OFFSET);\n\n    s->tick_offset = mktimegm(&tm);\n\n\n\n    s->adb_poll_timer = qemu_new_timer(vm_clock, cuda_adb_poll, s);\n\n    *cuda_mem_index = cpu_register_io_memory(0, cuda_read, cuda_write, s);\n\n    register_savevm(\"cuda\", -1, 1, cuda_save, cuda_load, s);\n\n    qemu_register_reset(cuda_reset, s);\n\n    cuda_reset(s);\n\n}\n", "idx": 17407, "_split": "valid", "_hash": "35d52da204fad5bd63847e3591423cce"}
{"project": "qemu", "commit_id": "a68931ea5f87ee3cc3144348596077de87f94c93", "target": 1, "func": "static void qdict_crumple_test_recursive(void)\n\n{\n\n    QDict *src, *dst, *rule, *vnc, *acl, *listen;\n\n    QObject *res;\n\n    QList *rules;\n\n\n\n    src = qdict_new();\n\n    qdict_put(src, \"vnc.listen.addr\", qstring_from_str(\"127.0.0.1\"));\n\n    qdict_put(src, \"vnc.listen.port\", qstring_from_str(\"5901\"));\n\n    qdict_put(src, \"vnc.acl.rules.0.match\", qstring_from_str(\"fred\"));\n\n    qdict_put(src, \"vnc.acl.rules.0.policy\", qstring_from_str(\"allow\"));\n\n    qdict_put(src, \"vnc.acl.rules.1.match\", qstring_from_str(\"bob\"));\n\n    qdict_put(src, \"vnc.acl.rules.1.policy\", qstring_from_str(\"deny\"));\n\n    qdict_put(src, \"vnc.acl.default\", qstring_from_str(\"deny\"));\n\n    qdict_put(src, \"vnc.acl..name\", qstring_from_str(\"acl0\"));\n\n    qdict_put(src, \"vnc.acl.rule..name\", qstring_from_str(\"acl0\"));\n\n\n\n    res = qdict_crumple(src, &error_abort);\n\n\n\n    g_assert_cmpint(qobject_type(res), ==, QTYPE_QDICT);\n\n\n\n    dst = qobject_to_qdict(res);\n\n\n\n    g_assert_cmpint(qdict_size(dst), ==, 1);\n\n\n\n    vnc = qdict_get_qdict(dst, \"vnc\");\n\n    g_assert(vnc);\n\n\n\n\n    listen = qdict_get_qdict(vnc, \"listen\");\n\n    g_assert(listen);\n\n\n    g_assert_cmpstr(\"127.0.0.1\", ==, qdict_get_str(listen, \"addr\"));\n\n    g_assert_cmpstr(\"5901\", ==, qdict_get_str(listen, \"port\"));\n\n\n\n    acl = qdict_get_qdict(vnc, \"acl\");\n\n    g_assert(acl);\n\n\n\n\n    rules = qdict_get_qlist(acl, \"rules\");\n\n    g_assert(rules);\n\n    g_assert_cmpint(qlist_size(rules), ==, 2);\n\n\n\n    rule = qobject_to_qdict(qlist_pop(rules));\n\n\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n\n    g_assert_cmpstr(\"fred\", ==, qdict_get_str(rule, \"match\"));\n\n    g_assert_cmpstr(\"allow\", ==, qdict_get_str(rule, \"policy\"));\n\n    QDECREF(rule);\n\n\n\n    rule = qobject_to_qdict(qlist_pop(rules));\n\n\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n\n    g_assert_cmpstr(\"bob\", ==, qdict_get_str(rule, \"match\"));\n\n    g_assert_cmpstr(\"deny\", ==, qdict_get_str(rule, \"policy\"));\n\n    QDECREF(rule);\n\n\n\n    /* With recursive crumpling, we should see all names unescaped */\n\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(vnc, \"acl.name\"));\n\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(acl, \"rule.name\"));\n\n\n\n    QDECREF(src);\n\n    QDECREF(dst);\n\n}", "idx": 17447, "_split": "valid", "_hash": "ddaf7077e252c07eb08d52faafddbfe8"}
{"project": "qemu", "commit_id": "94ef4f337fb614f18b765a8e0e878a4c23cdedcd", "target": 1, "func": "void vga_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    VGACommonState *s = opaque;\n\n    int index;\n\n\n\n    /* check port range access depending on color/monochrome mode */\n\n    if (vga_ioport_invalid(s, addr)) {\n\n        return;\n\n    }\n\n#ifdef DEBUG_VGA\n\n    printf(\"VGA: write addr=0x%04x data=0x%02x\\n\", addr, val);\n\n#endif\n\n\n\n    switch(addr) {\n\n    case VGA_ATT_W:\n\n        if (s->ar_flip_flop == 0) {\n\n            val &= 0x3f;\n\n            s->ar_index = val;\n\n        } else {\n\n            index = s->ar_index & 0x1f;\n\n            switch(index) {\n\n            case VGA_ATC_PALETTE0 ... VGA_ATC_PALETTEF:\n\n                s->ar[index] = val & 0x3f;\n\n                break;\n\n            case VGA_ATC_MODE:\n\n                s->ar[index] = val & ~0x10;\n\n                break;\n\n            case VGA_ATC_OVERSCAN:\n\n                s->ar[index] = val;\n\n                break;\n\n            case VGA_ATC_PLANE_ENABLE:\n\n                s->ar[index] = val & ~0xc0;\n\n                break;\n\n            case VGA_ATC_PEL:\n\n                s->ar[index] = val & ~0xf0;\n\n                break;\n\n            case VGA_ATC_COLOR_PAGE:\n\n                s->ar[index] = val & ~0xf0;\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n        }\n\n        s->ar_flip_flop ^= 1;\n\n        break;\n\n    case VGA_MIS_W:\n\n        s->msr = val & ~0x10;\n\n        s->update_retrace_info(s);\n\n        break;\n\n    case VGA_SEQ_I:\n\n        s->sr_index = val & 7;\n\n        break;\n\n    case VGA_SEQ_D:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write SR%x = 0x%02x\\n\", s->sr_index, val);\n\n#endif\n\n        s->sr[s->sr_index] = val & sr_mask[s->sr_index];\n\n        vbe_update_vgaregs(s);\n\n        if (s->sr_index == VGA_SEQ_CLOCK_MODE) {\n\n            s->update_retrace_info(s);\n\n        }\n\n        vga_update_memory_access(s);\n\n        break;\n\n    case VGA_PEL_IR:\n\n        s->dac_read_index = val;\n\n        s->dac_sub_index = 0;\n\n        s->dac_state = 3;\n\n        break;\n\n    case VGA_PEL_IW:\n\n        s->dac_write_index = val;\n\n        s->dac_sub_index = 0;\n\n        s->dac_state = 0;\n\n        break;\n\n    case VGA_PEL_D:\n\n        s->dac_cache[s->dac_sub_index] = val;\n\n        if (++s->dac_sub_index == 3) {\n\n            memcpy(&s->palette[s->dac_write_index * 3], s->dac_cache, 3);\n\n            s->dac_sub_index = 0;\n\n            s->dac_write_index++;\n\n        }\n\n        break;\n\n    case VGA_GFX_I:\n\n        s->gr_index = val & 0x0f;\n\n        break;\n\n    case VGA_GFX_D:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write GR%x = 0x%02x\\n\", s->gr_index, val);\n\n#endif\n\n        s->gr[s->gr_index] = val & gr_mask[s->gr_index];\n\n        vbe_update_vgaregs(s);\n\n        vga_update_memory_access(s);\n\n        break;\n\n    case VGA_CRT_IM:\n\n    case VGA_CRT_IC:\n\n        s->cr_index = val;\n\n        break;\n\n    case VGA_CRT_DM:\n\n    case VGA_CRT_DC:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write CR%x = 0x%02x\\n\", s->cr_index, val);\n\n#endif\n\n        /* handle CR0-7 protection */\n\n        if ((s->cr[VGA_CRTC_V_SYNC_END] & VGA_CR11_LOCK_CR0_CR7) &&\n\n            s->cr_index <= VGA_CRTC_OVERFLOW) {\n\n            /* can always write bit 4 of CR7 */\n\n            if (s->cr_index == VGA_CRTC_OVERFLOW) {\n\n                s->cr[VGA_CRTC_OVERFLOW] = (s->cr[VGA_CRTC_OVERFLOW] & ~0x10) |\n\n                    (val & 0x10);\n\n                vbe_update_vgaregs(s);\n\n            }\n\n            return;\n\n        }\n\n        s->cr[s->cr_index] = val;\n\n        vbe_update_vgaregs(s);\n\n\n\n        switch(s->cr_index) {\n\n        case VGA_CRTC_H_TOTAL:\n\n        case VGA_CRTC_H_SYNC_START:\n\n        case VGA_CRTC_H_SYNC_END:\n\n        case VGA_CRTC_V_TOTAL:\n\n        case VGA_CRTC_OVERFLOW:\n\n        case VGA_CRTC_V_SYNC_END:\n\n        case VGA_CRTC_MODE:\n\n            s->update_retrace_info(s);\n\n            break;\n\n        }\n\n        break;\n\n    case VGA_IS1_RM:\n\n    case VGA_IS1_RC:\n\n        s->fcr = val & 0x10;\n\n        break;\n\n    }\n\n}\n", "idx": 17448, "_split": "valid", "_hash": "2c2f00fc8ac3f068892dc55b51e1ea27"}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void raven_pcihost_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);\n\n    dc->realize = raven_pcihost_realizefn;\n\n    dc->fw_name = \"pci\";\n\n    dc->no_user = 1;\n\n}\n", "idx": 17463, "_split": "valid", "_hash": "891d61a03ba34a6f1f6f8424b81278cd"}
{"project": "qemu", "commit_id": "760794f784f66e262a9ca32821ba202cdf3a3e4b", "target": 1, "func": "static int chr_can_read(void *opaque)\n\n{\n\n    int can_read;\n\n    SCLPConsole *scon = opaque;\n\n\n\n    can_read = SIZE_BUFFER_VT220 - scon->iov_data_len;\n\n\n\n    return can_read;\n\n}\n", "idx": 17478, "_split": "valid", "_hash": "5823d35a44b75f8eec756347c36392b3"}
{"project": "qemu", "commit_id": "a7c36ee4920ea3acc227a0248dd161693f207357", "target": 1, "func": "int net_client_init(Monitor *mon, QemuOpts *opts, int is_netdev)\n\n{\n\n    const char *name;\n\n    const char *type;\n\n    int i;\n\n\n\n    type = qemu_opt_get(opts, \"type\");\n\n    if (!type) {\n\n        qerror_report(QERR_MISSING_PARAMETER, \"type\");\n\n        return -1;\n\n    }\n\n\n\n    if (is_netdev) {\n\n        if (strcmp(type, \"tap\") != 0 &&\n\n#ifdef CONFIG_SLIRP\n\n            strcmp(type, \"user\") != 0 &&\n\n#endif\n\n#ifdef CONFIG_VDE\n\n            strcmp(type, \"vde\") != 0 &&\n\n#endif\n\n            strcmp(type, \"socket\") != 0) {\n\n            qerror_report(QERR_INVALID_PARAMETER_VALUE, \"type\",\n\n                          \"a netdev backend type\");\n\n            return -1;\n\n        }\n\n\n\n        if (qemu_opt_get(opts, \"vlan\")) {\n\n            qerror_report(QERR_INVALID_PARAMETER, \"vlan\");\n\n            return -1;\n\n        }\n\n        if (qemu_opt_get(opts, \"name\")) {\n\n            qerror_report(QERR_INVALID_PARAMETER, \"name\");\n\n            return -1;\n\n        }\n\n        if (!qemu_opts_id(opts)) {\n\n            qerror_report(QERR_MISSING_PARAMETER, \"id\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    name = qemu_opts_id(opts);\n\n    if (!name) {\n\n        name = qemu_opt_get(opts, \"name\");\n\n    }\n\n\n\n    for (i = 0; i < NET_CLIENT_TYPE_MAX; i++) {\n\n        if (net_client_types[i].type != NULL &&\n\n            !strcmp(net_client_types[i].type, type)) {\n\n            VLANState *vlan = NULL;\n\n            int ret;\n\n\n\n            if (qemu_opts_validate(opts, &net_client_types[i].desc[0]) == -1) {\n\n                return -1;\n\n            }\n\n\n\n            /* Do not add to a vlan if it's a -netdev or a nic with a\n\n             * netdev= parameter. */\n\n            if (!(is_netdev ||\n\n                  (strcmp(type, \"nic\") == 0 && qemu_opt_get(opts, \"netdev\")))) {\n\n                vlan = qemu_find_vlan(qemu_opt_get_number(opts, \"vlan\", 0), 1);\n\n            }\n\n\n\n            ret = 0;\n\n            if (net_client_types[i].init) {\n\n                ret = net_client_types[i].init(opts, mon, name, vlan);\n\n                if (ret < 0) {\n\n                    /* TODO push error reporting into init() methods */\n\n                    qerror_report(QERR_DEVICE_INIT_FAILED, type);\n\n                    return -1;\n\n                }\n\n            }\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    qerror_report(QERR_INVALID_PARAMETER_VALUE, \"type\",\n\n                  \"a network client type\");\n\n    return -1;\n\n}\n", "idx": 17525, "_split": "valid", "_hash": "863af78b9da7b954db8cb1f4b0be70a3"}
{"project": "qemu", "commit_id": "6273d1136af913aaf4badc4545ccf942557c747b", "target": 1, "func": "static void qdict_do_flatten(QDict *qdict, QDict *target, const char *prefix)\n\n{\n\n    QObject *value;\n\n    const QDictEntry *entry, *next;\n\n    const char *new_key;\n\n    bool delete;\n\n\n\n    entry = qdict_first(qdict);\n\n\n\n    while (entry != NULL) {\n\n\n\n        next = qdict_next(qdict, entry);\n\n        value = qdict_entry_value(entry);\n\n        new_key = NULL;\n\n        delete = false;\n\n\n\n        if (prefix) {\n\n            qobject_incref(value);\n\n            new_key = g_strdup_printf(\"%s.%s\", prefix, entry->key);\n\n            qdict_put_obj(target, new_key, value);\n\n            delete = true;\n\n        }\n\n\n\n        if (qobject_type(value) == QTYPE_QDICT) {\n\n            qdict_do_flatten(qobject_to_qdict(value), target,\n\n                             new_key ? new_key : entry->key);\n\n            delete = true;\n\n        }\n\n\n\n        if (delete) {\n\n            qdict_del(qdict, entry->key);\n\n\n\n            /* Restart loop after modifying the iterated QDict */\n\n            entry = qdict_first(qdict);\n\n            continue;\n\n        }\n\n\n\n        entry = next;\n\n    }\n\n}\n", "idx": 17558, "_split": "valid", "_hash": "ac77ebdfa7db3cced76ea46474bca078"}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float64 HELPER(ucf64_divd)(float64 a, float64 b, CPUUniCore32State *env)\n\n{\n\n    return float64_div(a, b, &env->ucf64.fp_status);\n\n}\n", "idx": 17571, "_split": "valid", "_hash": "ee4c66cf82b4fd97f761cd19cee79ac6"}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_eval_fbuge(TCGv dst, TCGv src,\n\n                                    unsigned int fcc_offset)\n\n{\n\n    gen_mov_reg_FCC0(dst, src, fcc_offset);\n\n    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);\n\n    tcg_gen_xori_tl(cpu_tmp0, cpu_tmp0, 0x1);\n\n    tcg_gen_and_tl(dst, dst, cpu_tmp0);\n\n    tcg_gen_xori_tl(dst, dst, 0x1);\n\n}\n", "idx": 17588, "_split": "valid", "_hash": "3c8daf24b7d140198cabce619c220f7b"}
{"project": "qemu", "commit_id": "dbecebddfa4932d1c83915bcb9b5ba5984eb91be", "target": 0, "func": "int bdrv_open_backing_file(BlockDriverState *bs, QDict *options, Error **errp)\n\n{\n\n    char backing_filename[PATH_MAX];\n\n    int back_flags, ret;\n\n    BlockDriver *back_drv = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    if (bs->backing_hd != NULL) {\n\n        QDECREF(options);\n\n        return 0;\n\n    }\n\n\n\n    /* NULL means an empty set of options */\n\n    if (options == NULL) {\n\n        options = qdict_new();\n\n    }\n\n\n\n    bs->open_flags &= ~BDRV_O_NO_BACKING;\n\n    if (qdict_haskey(options, \"file.filename\")) {\n\n        backing_filename[0] = '\\0';\n\n    } else if (bs->backing_file[0] == '\\0' && qdict_size(options) == 0) {\n\n        QDECREF(options);\n\n        return 0;\n\n    }\n\n\n\n    bs->backing_hd = bdrv_new(\"\");\n\n    bdrv_get_full_backing_filename(bs, backing_filename,\n\n                                   sizeof(backing_filename));\n\n\n\n    if (bs->backing_format[0] != '\\0') {\n\n        back_drv = bdrv_find_format(bs->backing_format);\n\n    }\n\n\n\n    /* backing files always opened read-only */\n\n    back_flags = bs->open_flags & ~(BDRV_O_RDWR | BDRV_O_SNAPSHOT);\n\n\n\n    ret = bdrv_open(bs->backing_hd,\n\n                    *backing_filename ? backing_filename : NULL, options,\n\n                    back_flags, back_drv, &local_err);\n\n    if (ret < 0) {\n\n        bdrv_unref(bs->backing_hd);\n\n        bs->backing_hd = NULL;\n\n        bs->open_flags |= BDRV_O_NO_BACKING;\n\n        error_propagate(errp, local_err);\n\n        return ret;\n\n    }\n\n    return 0;\n\n}\n", "idx": 17594, "_split": "valid", "_hash": "0e56a66a1c38303fd9fbb36597555017"}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static OSStatus audioDeviceIOProc(\n\n    AudioDeviceID inDevice,\n\n    const AudioTimeStamp* inNow,\n\n    const AudioBufferList* inInputData,\n\n    const AudioTimeStamp* inInputTime,\n\n    AudioBufferList* outOutputData,\n\n    const AudioTimeStamp* inOutputTime,\n\n    void* hwptr)\n\n{\n\n    UInt32 frame, frameCount;\n\n    float *out = outOutputData->mBuffers[0].mData;\n\n    HWVoiceOut *hw = hwptr;\n\n    coreaudioVoiceOut *core = (coreaudioVoiceOut *) hwptr;\n\n    int rpos, live;\n\n    st_sample_t *src;\n\n#ifndef FLOAT_MIXENG\n\n#ifdef RECIPROCAL\n\n    const float scale = 1.f / UINT_MAX;\n\n#else\n\n    const float scale = UINT_MAX;\n\n#endif\n\n#endif\n\n\n\n    if (coreaudio_lock (core, \"audioDeviceIOProc\")) {\n\n        inInputTime = 0;\n\n        return 0;\n\n    }\n\n\n\n    frameCount = core->audioDevicePropertyBufferFrameSize;\n\n    live = core->live;\n\n\n\n    /* if there are not enough samples, set signal and return */\n\n    if (live < frameCount) {\n\n        inInputTime = 0;\n\n        coreaudio_unlock (core, \"audioDeviceIOProc(empty)\");\n\n        return 0;\n\n    }\n\n\n\n    rpos = core->rpos;\n\n    src = hw->mix_buf + rpos;\n\n\n\n    /* fill buffer */\n\n    for (frame = 0; frame < frameCount; frame++) {\n\n#ifdef FLOAT_MIXENG\n\n        *out++ = src[frame].l; /* left channel */\n\n        *out++ = src[frame].r; /* right channel */\n\n#else\n\n#ifdef RECIPROCAL\n\n        *out++ = src[frame].l * scale; /* left channel */\n\n        *out++ = src[frame].r * scale; /* right channel */\n\n#else\n\n        *out++ = src[frame].l / scale; /* left channel */\n\n        *out++ = src[frame].r / scale; /* right channel */\n\n#endif\n\n#endif\n\n    }\n\n\n\n    rpos = (rpos + frameCount) % hw->samples;\n\n    core->decr += frameCount;\n\n    core->rpos = rpos;\n\n\n\n    coreaudio_unlock (core, \"audioDeviceIOProc\");\n\n    return 0;\n\n}\n", "idx": 17600, "_split": "valid", "_hash": "62efe53110bb0506c42483a8bdcea943"}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void m68k_cpu_initfn(Object *obj)\n\n{\n\n    CPUState *cs = CPU(obj);\n\n    M68kCPU *cpu = M68K_CPU(obj);\n\n    CPUM68KState *env = &cpu->env;\n\n    static bool inited;\n\n\n\n    cs->env_ptr = env;\n\n    cpu_exec_init(cs, &error_abort);\n\n\n\n    if (tcg_enabled() && !inited) {\n\n        inited = true;\n\n        m68k_tcg_init();\n\n    }\n\n}\n", "idx": 17604, "_split": "valid", "_hash": "bd2c5ba4f1ab6d2a8934a8a6fdc9f26d"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static bool bdrv_drain_one(BlockDriverState *bs)\n\n{\n\n    bool bs_busy;\n\n\n\n    bdrv_flush_io_queue(bs);\n\n    bdrv_start_throttled_reqs(bs);\n\n    bs_busy = bdrv_requests_pending(bs);\n\n    bs_busy |= aio_poll(bdrv_get_aio_context(bs), bs_busy);\n\n    return bs_busy;\n\n}\n", "idx": 17623, "_split": "valid", "_hash": "7ff4f4551a526243e761696296214dad"}
{"project": "qemu", "commit_id": "2174f12bdeb3974141784e14bbb7ad8c53178cd9", "target": 0, "func": "static BlockAIOCB *raw_aio_readv(BlockDriverState *bs,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockCompletionFunc *cb, void *opaque)\n\n{\n\n    return raw_aio_submit(bs, sector_num, qiov, nb_sectors,\n\n                          cb, opaque, QEMU_AIO_READ);\n\n}\n", "idx": 17636, "_split": "valid", "_hash": "1937387b9876536c4f466f51b9d33898"}
{"project": "qemu", "commit_id": "4618e658e6dadd1ba53585157984eac71cb706c6", "target": 0, "func": "static int authenticate(BDRVSSHState *s, const char *user)\n\n{\n\n    int r, ret;\n\n    const char *userauthlist;\n\n    LIBSSH2_AGENT *agent = NULL;\n\n    struct libssh2_agent_publickey *identity;\n\n    struct libssh2_agent_publickey *prev_identity = NULL;\n\n\n\n    userauthlist = libssh2_userauth_list(s->session, user, strlen(user));\n\n    if (strstr(userauthlist, \"publickey\") == NULL) {\n\n        ret = -EPERM;\n\n        error_report(\"remote server does not support \\\"publickey\\\" authentication\");\n\n        goto out;\n\n    }\n\n\n\n    /* Connect to ssh-agent and try each identity in turn. */\n\n    agent = libssh2_agent_init(s->session);\n\n    if (!agent) {\n\n        ret = -EINVAL;\n\n        session_error_report(s, \"failed to initialize ssh-agent support\");\n\n        goto out;\n\n    }\n\n    if (libssh2_agent_connect(agent)) {\n\n        ret = -ECONNREFUSED;\n\n        session_error_report(s, \"failed to connect to ssh-agent\");\n\n        goto out;\n\n    }\n\n    if (libssh2_agent_list_identities(agent)) {\n\n        ret = -EINVAL;\n\n        session_error_report(s, \"failed requesting identities from ssh-agent\");\n\n        goto out;\n\n    }\n\n\n\n    for(;;) {\n\n        r = libssh2_agent_get_identity(agent, &identity, prev_identity);\n\n        if (r == 1) {           /* end of list */\n\n            break;\n\n        }\n\n        if (r < 0) {\n\n            ret = -EINVAL;\n\n            session_error_report(s, \"failed to obtain identity from ssh-agent\");\n\n            goto out;\n\n        }\n\n        r = libssh2_agent_userauth(agent, user, identity);\n\n        if (r == 0) {\n\n            /* Authenticated! */\n\n            ret = 0;\n\n            goto out;\n\n        }\n\n        /* Failed to authenticate with this identity, try the next one. */\n\n        prev_identity = identity;\n\n    }\n\n\n\n    ret = -EPERM;\n\n    error_report(\"failed to authenticate using publickey authentication \"\n\n                 \"and the identities held by your ssh-agent\");\n\n\n\n out:\n\n    if (agent != NULL) {\n\n        /* Note: libssh2 implementation implicitly calls\n\n         * libssh2_agent_disconnect if necessary.\n\n         */\n\n        libssh2_agent_free(agent);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 17637, "_split": "valid", "_hash": "45bc0f5146aae1e0659d33db66b7ee8c"}
{"project": "qemu", "commit_id": "f5bebbbb28dc7a149a891f0f1e112fb50bb72664", "target": 0, "func": "static bool bdrv_is_valid_name(const char *name)\n\n{\n\n    return qemu_opts_id_wellformed(name);\n\n}\n", "idx": 17639, "_split": "valid", "_hash": "9db17e8f66df427aec71c1cc395f3c73"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void cirrus_vga_mem_write(void *opaque,\n\n                                 target_phys_addr_t addr,\n\n                                 uint64_t mem_value,\n\n                                 uint32_t size)\n\n{\n\n    CirrusVGAState *s = opaque;\n\n    unsigned bank_index;\n\n    unsigned bank_offset;\n\n    unsigned mode;\n\n\n\n    if ((s->vga.sr[0x07] & 0x01) == 0) {\n\n        vga_mem_writeb(&s->vga, addr, mem_value);\n\n        return;\n\n    }\n\n\n\n    if (addr < 0x10000) {\n\n\tif (s->cirrus_srcptr != s->cirrus_srcptr_end) {\n\n\t    /* bitblt */\n\n\t    *s->cirrus_srcptr++ = (uint8_t) mem_value;\n\n\t    if (s->cirrus_srcptr >= s->cirrus_srcptr_end) {\n\n\t\tcirrus_bitblt_cputovideo_next(s);\n\n\t    }\n\n\t} else {\n\n\t    /* video memory */\n\n\t    bank_index = addr >> 15;\n\n\t    bank_offset = addr & 0x7fff;\n\n\t    if (bank_offset < s->cirrus_bank_limit[bank_index]) {\n\n\t\tbank_offset += s->cirrus_bank_base[bank_index];\n\n\t\tif ((s->vga.gr[0x0B] & 0x14) == 0x14) {\n\n\t\t    bank_offset <<= 4;\n\n\t\t} else if (s->vga.gr[0x0B] & 0x02) {\n\n\t\t    bank_offset <<= 3;\n\n\t\t}\n\n\t\tbank_offset &= s->cirrus_addr_mask;\n\n\t\tmode = s->vga.gr[0x05] & 0x7;\n\n\t\tif (mode < 4 || mode > 5 || ((s->vga.gr[0x0B] & 0x4) == 0)) {\n\n\t\t    *(s->vga.vram_ptr + bank_offset) = mem_value;\n\n                    memory_region_set_dirty(&s->vga.vram, bank_offset,\n\n                                            sizeof(mem_value));\n\n\t\t} else {\n\n\t\t    if ((s->vga.gr[0x0B] & 0x14) != 0x14) {\n\n\t\t\tcirrus_mem_writeb_mode4and5_8bpp(s, mode,\n\n\t\t\t\t\t\t\t bank_offset,\n\n\t\t\t\t\t\t\t mem_value);\n\n\t\t    } else {\n\n\t\t\tcirrus_mem_writeb_mode4and5_16bpp(s, mode,\n\n\t\t\t\t\t\t\t  bank_offset,\n\n\t\t\t\t\t\t\t  mem_value);\n\n\t\t    }\n\n\t\t}\n\n\t    }\n\n\t}\n\n    } else if (addr >= 0x18000 && addr < 0x18100) {\n\n\t/* memory-mapped I/O */\n\n\tif ((s->vga.sr[0x17] & 0x44) == 0x04) {\n\n\t    cirrus_mmio_blt_write(s, addr & 0xff, mem_value);\n\n\t}\n\n    } else {\n\n#ifdef DEBUG_CIRRUS\n\n        printf(\"cirrus: mem_writeb \" TARGET_FMT_plx \" value %02x\\n\", addr,\n\n               mem_value);\n\n#endif\n\n    }\n\n}\n", "idx": 17645, "_split": "valid", "_hash": "d8faee937c2093210b5832df3f645556"}
{"project": "qemu", "commit_id": "494cb81741f867319f11ecfa0949168baf9f01d7", "target": 0, "func": "static void vnc_tls_handshake_io(void *opaque) {\n\n    struct VncState *vs = (struct VncState *)opaque;\n\n\n\n    VNC_DEBUG(\"Handshake IO continue\\n\");\n\n    vnc_start_vencrypt_handshake(vs);\n\n}\n", "idx": 17647, "_split": "valid", "_hash": "61858ca0b12aa02d8074ea792891bf18"}
{"project": "qemu", "commit_id": "a0fa2cb8ccf0b73cfd3ac01d557401a2303c0de4", "target": 0, "func": "int sclp_service_call(uint32_t sccb, uint64_t code)\n\n{\n\n    int r = 0;\n\n    SCCB work_sccb;\n\n\n\n    hwaddr sccb_len = sizeof(SCCB);\n\n\n\n    /* first some basic checks on program checks */\n\n    if (cpu_physical_memory_is_io(sccb)) {\n\n        r = -PGM_ADDRESSING;\n\n        goto out;\n\n    }\n\n    if (sccb & ~0x7ffffff8ul) {\n\n        r = -PGM_SPECIFICATION;\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * we want to work on a private copy of the sccb, to prevent guests\n\n     * from playing dirty tricks by modifying the memory content after\n\n     * the host has checked the values\n\n     */\n\n    cpu_physical_memory_read(sccb, &work_sccb, sccb_len);\n\n\n\n    /* Valid sccb sizes */\n\n    if (be16_to_cpu(work_sccb.h.length) < sizeof(SCCBHeader) ||\n\n        be16_to_cpu(work_sccb.h.length) > SCCB_SIZE) {\n\n        r = -PGM_SPECIFICATION;\n\n        goto out;\n\n    }\n\n\n\n    sclp_execute((SCCB *)&work_sccb, code);\n\n\n\n    cpu_physical_memory_write(sccb, &work_sccb,\n\n                              be16_to_cpu(work_sccb.h.length));\n\n\n\n    sclp_service_interrupt(sccb);\n\n\n\nout:\n\n    return r;\n\n}\n", "idx": 17654, "_split": "valid", "_hash": "b3fff3f8510a04dd2e203426c87a6c6d"}
{"project": "qemu", "commit_id": "e2a176dfda32f5cf80703c2921a19fe75850c38c", "target": 0, "func": "static void taihu_cpld_writeb (void *opaque,\n\n                               hwaddr addr, uint32_t value)\n\n{\n\n    taihu_cpld_t *cpld;\n\n\n\n    cpld = opaque;\n\n    switch (addr) {\n\n    case 0x0:\n\n        /* Read only */\n\n        break;\n\n    case 0x1:\n\n        cpld->reg1 = value;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 17663, "_split": "valid", "_hash": "2a3af3417284204ea59c3bd54160ca23"}
{"project": "qemu", "commit_id": "a980a065fb5e86d6dec337e6cb6ff432f1a143c9", "target": 0, "func": "static int usb_bt_handle_control(USBDevice *dev, int request, int value,\n\n                int index, int length, uint8_t *data)\n\n{\n\n    struct USBBtState *s = (struct USBBtState *) dev->opaque;\n\n    int ret;\n\n\n\n    ret = usb_desc_handle_control(dev, request, value, index, length, data);\n\n    if (ret >= 0) {\n\n        return ret;\n\n    }\n\n\n\n    ret = 0;\n\n    switch (request) {\n\n    case DeviceRequest | USB_REQ_GET_STATUS:\n\n    case InterfaceRequest | USB_REQ_GET_STATUS:\n\n    case EndpointRequest | USB_REQ_GET_STATUS:\n\n        data[0] = (1 << USB_DEVICE_SELF_POWERED) |\n\n            (dev->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP);\n\n        data[1] = 0x00;\n\n        ret = 2;\n\n        break;\n\n    case DeviceOutRequest | USB_REQ_CLEAR_FEATURE:\n\n    case InterfaceOutRequest | USB_REQ_CLEAR_FEATURE:\n\n    case EndpointOutRequest | USB_REQ_CLEAR_FEATURE:\n\n        if (value == USB_DEVICE_REMOTE_WAKEUP) {\n\n            dev->remote_wakeup = 0;\n\n        } else {\n\n            goto fail;\n\n        }\n\n        ret = 0;\n\n        break;\n\n    case DeviceOutRequest | USB_REQ_SET_FEATURE:\n\n    case InterfaceOutRequest | USB_REQ_SET_FEATURE:\n\n    case EndpointOutRequest | USB_REQ_SET_FEATURE:\n\n        if (value == USB_DEVICE_REMOTE_WAKEUP) {\n\n            dev->remote_wakeup = 1;\n\n        } else {\n\n            goto fail;\n\n        }\n\n        ret = 0;\n\n        break;\n\n    case DeviceRequest | USB_REQ_GET_CONFIGURATION:\n\n        data[0] = 1;\n\n        ret = 1;\n\n        s->config = 0;\n\n        break;\n\n    case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:\n\n        ret = 0;\n\n        if (value != 1 && value != 0) {\n\n            printf(\"%s: Wrong SET_CONFIGURATION request (%i)\\n\",\n\n                            __FUNCTION__, value);\n\n            goto fail;\n\n        }\n\n        s->config = 1;\n\n        usb_bt_fifo_reset(&s->evt);\n\n        usb_bt_fifo_reset(&s->acl);\n\n        usb_bt_fifo_reset(&s->sco);\n\n        break;\n\n    case InterfaceRequest | USB_REQ_GET_INTERFACE:\n\n        if (value != 0 || (index & ~1) || length != 1)\n\n            goto fail;\n\n        if (index == 1)\n\n            data[0] = s->altsetting;\n\n        else\n\n            data[0] = 0;\n\n        ret = 1;\n\n        break;\n\n    case InterfaceOutRequest | USB_REQ_SET_INTERFACE:\n\n        if ((index & ~1) || length != 0 ||\n\n                        (index == 1 && (value < 0 || value > 4)) ||\n\n                        (index == 0 && value != 0)) {\n\n            printf(\"%s: Wrong SET_INTERFACE request (%i, %i)\\n\",\n\n                            __FUNCTION__, index, value);\n\n            goto fail;\n\n        }\n\n        s->altsetting = value;\n\n        ret = 0;\n\n        break;\n\n    case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_DEVICE) << 8):\n\n        if (s->config)\n\n            usb_bt_fifo_out_enqueue(s, &s->outcmd, s->hci->cmd_send,\n\n                            usb_bt_hci_cmd_complete, data, length);\n\n        break;\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n    return ret;\n\n}\n", "idx": 17665, "_split": "valid", "_hash": "3f7de286047326d0ae8656195f771dd4"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void dp8393x_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    uint16_t old_val = dp8393x_readw(opaque, addr & ~0x1);\n\n\n\n    switch (addr & 3) {\n\n    case 0:\n\n        val = val | (old_val & 0xff00);\n\n        break;\n\n    case 1:\n\n        val = (val << 8) | (old_val & 0x00ff);\n\n        break;\n\n    }\n\n    dp8393x_writew(opaque, addr & ~0x1, val);\n\n}\n", "idx": 17688, "_split": "valid", "_hash": "a2331aaf9f0f25252e754aee590b58d9"}
{"project": "qemu", "commit_id": "d1fdf257d52822695f5ace6c586e059aa17d4b79", "target": 0, "func": "static ssize_t nbd_co_receive_request(NBDRequestData *req,\n\n                                      NBDRequest *request)\n\n{\n\n    NBDClient *client = req->client;\n\n    ssize_t rc;\n\n\n\n    g_assert(qemu_in_coroutine());\n\n    assert(client->recv_coroutine == qemu_coroutine_self());\n\n    rc = nbd_receive_request(client->ioc, request);\n\n    if (rc < 0) {\n\n        if (rc != -EAGAIN) {\n\n            rc = -EIO;\n\n        }\n\n        goto out;\n\n    }\n\n\n\n    TRACE(\"Decoding type\");\n\n\n\n    if (request->type != NBD_CMD_WRITE) {\n\n        /* No payload, we are ready to read the next request.  */\n\n        req->complete = true;\n\n    }\n\n\n\n    if (request->type == NBD_CMD_DISC) {\n\n        /* Special case: we're going to disconnect without a reply,\n\n         * whether or not flags, from, or len are bogus */\n\n        TRACE(\"Request type is DISCONNECT\");\n\n        rc = -EIO;\n\n        goto out;\n\n    }\n\n\n\n    /* Check for sanity in the parameters, part 1.  Defer as many\n\n     * checks as possible until after reading any NBD_CMD_WRITE\n\n     * payload, so we can try and keep the connection alive.  */\n\n    if ((request->from + request->len) < request->from) {\n\n        LOG(\"integer overflow detected, you're probably being attacked\");\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    if (request->type == NBD_CMD_READ || request->type == NBD_CMD_WRITE) {\n\n        if (request->len > NBD_MAX_BUFFER_SIZE) {\n\n            LOG(\"len (%\" PRIu32\" ) is larger than max len (%u)\",\n\n                request->len, NBD_MAX_BUFFER_SIZE);\n\n            rc = -EINVAL;\n\n            goto out;\n\n        }\n\n\n\n        req->data = blk_try_blockalign(client->exp->blk, request->len);\n\n        if (req->data == NULL) {\n\n            rc = -ENOMEM;\n\n            goto out;\n\n        }\n\n    }\n\n    if (request->type == NBD_CMD_WRITE) {\n\n        TRACE(\"Reading %\" PRIu32 \" byte(s)\", request->len);\n\n\n\n        if (read_sync(client->ioc, req->data, request->len, NULL) < 0) {\n\n            LOG(\"reading from socket failed\");\n\n            rc = -EIO;\n\n            goto out;\n\n        }\n\n        req->complete = true;\n\n    }\n\n\n\n    /* Sanity checks, part 2. */\n\n    if (request->from + request->len > client->exp->size) {\n\n        LOG(\"operation past EOF; From: %\" PRIu64 \", Len: %\" PRIu32\n\n            \", Size: %\" PRIu64, request->from, request->len,\n\n            (uint64_t)client->exp->size);\n\n        rc = request->type == NBD_CMD_WRITE ? -ENOSPC : -EINVAL;\n\n        goto out;\n\n    }\n\n    if (request->flags & ~(NBD_CMD_FLAG_FUA | NBD_CMD_FLAG_NO_HOLE)) {\n\n        LOG(\"unsupported flags (got 0x%x)\", request->flags);\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n    if (request->type != NBD_CMD_WRITE_ZEROES &&\n\n        (request->flags & NBD_CMD_FLAG_NO_HOLE)) {\n\n        LOG(\"unexpected flags (got 0x%x)\", request->flags);\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    rc = 0;\n\n\n\nout:\n\n    client->recv_coroutine = NULL;\n\n    nbd_client_receive_next_request(client);\n\n\n\n    return rc;\n\n}\n", "idx": 17692, "_split": "valid", "_hash": "878d91fb8b345f721b34865c43e99764"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static int pfpu_decode_insn(MilkymistPFPUState *s)\n\n{\n\n    uint32_t pc = s->regs[R_PC];\n\n    uint32_t insn = s->microcode[pc];\n\n    uint32_t reg_a = (insn >> 18) & 0x7f;\n\n    uint32_t reg_b = (insn >> 11) & 0x7f;\n\n    uint32_t op = (insn >> 7) & 0xf;\n\n    uint32_t reg_d = insn & 0x7f;\n\n    uint32_t r = 0;\n\n    int latency = 0;\n\n\n\n    switch (op) {\n\n    case OP_NOP:\n\n        break;\n\n    case OP_FADD:\n\n    {\n\n        float a = REINTERPRET_CAST(float, s->gp_regs[reg_a]);\n\n        float b = REINTERPRET_CAST(float, s->gp_regs[reg_b]);\n\n        float t = a + b;\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_FADD;\n\n        D_EXEC(qemu_log(\"ADD a=%f b=%f t=%f, r=%08x\\n\", a, b, t, r));\n\n    } break;\n\n    case OP_FSUB:\n\n    {\n\n        float a = REINTERPRET_CAST(float, s->gp_regs[reg_a]);\n\n        float b = REINTERPRET_CAST(float, s->gp_regs[reg_b]);\n\n        float t = a - b;\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_FSUB;\n\n        D_EXEC(qemu_log(\"SUB a=%f b=%f t=%f, r=%08x\\n\", a, b, t, r));\n\n    } break;\n\n    case OP_FMUL:\n\n    {\n\n        float a = REINTERPRET_CAST(float, s->gp_regs[reg_a]);\n\n        float b = REINTERPRET_CAST(float, s->gp_regs[reg_b]);\n\n        float t = a * b;\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_FMUL;\n\n        D_EXEC(qemu_log(\"MUL a=%f b=%f t=%f, r=%08x\\n\", a, b, t, r));\n\n    } break;\n\n    case OP_FABS:\n\n    {\n\n        float a = REINTERPRET_CAST(float, s->gp_regs[reg_a]);\n\n        float t = fabsf(a);\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_FABS;\n\n        D_EXEC(qemu_log(\"ABS a=%f t=%f, r=%08x\\n\", a, t, r));\n\n    } break;\n\n    case OP_F2I:\n\n    {\n\n        float a = REINTERPRET_CAST(float, s->gp_regs[reg_a]);\n\n        int32_t t = a;\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_F2I;\n\n        D_EXEC(qemu_log(\"F2I a=%f t=%d, r=%08x\\n\", a, t, r));\n\n    } break;\n\n    case OP_I2F:\n\n    {\n\n        int32_t a = REINTERPRET_CAST(int32_t, s->gp_regs[reg_a]);\n\n        float t = a;\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_I2F;\n\n        D_EXEC(qemu_log(\"I2F a=%08x t=%f, r=%08x\\n\", a, t, r));\n\n    } break;\n\n    case OP_VECTOUT:\n\n    {\n\n        uint32_t a = cpu_to_be32(s->gp_regs[reg_a]);\n\n        uint32_t b = cpu_to_be32(s->gp_regs[reg_b]);\n\n        target_phys_addr_t dma_ptr =\n\n            get_dma_address(s->regs[R_MESHBASE],\n\n                    s->gp_regs[GPR_X], s->gp_regs[GPR_Y]);\n\n        cpu_physical_memory_write(dma_ptr, (uint8_t *)&a, 4);\n\n        cpu_physical_memory_write(dma_ptr + 4, (uint8_t *)&b, 4);\n\n        s->regs[R_LASTDMA] = dma_ptr + 4;\n\n        D_EXEC(qemu_log(\"VECTOUT a=%08x b=%08x dma=%08x\\n\", a, b, dma_ptr));\n\n        trace_milkymist_pfpu_vectout(a, b, dma_ptr);\n\n    } break;\n\n    case OP_SIN:\n\n    {\n\n        int32_t a = REINTERPRET_CAST(int32_t, s->gp_regs[reg_a]);\n\n        float t = sinf(a * (1.0f / (M_PI * 4096.0f)));\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_SIN;\n\n        D_EXEC(qemu_log(\"SIN a=%d t=%f, r=%08x\\n\", a, t, r));\n\n    } break;\n\n    case OP_COS:\n\n    {\n\n        int32_t a = REINTERPRET_CAST(int32_t, s->gp_regs[reg_a]);\n\n        float t = cosf(a * (1.0f / (M_PI * 4096.0f)));\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_COS;\n\n        D_EXEC(qemu_log(\"COS a=%d t=%f, r=%08x\\n\", a, t, r));\n\n    } break;\n\n    case OP_ABOVE:\n\n    {\n\n        float a = REINTERPRET_CAST(float, s->gp_regs[reg_a]);\n\n        float b = REINTERPRET_CAST(float, s->gp_regs[reg_b]);\n\n        float t = (a > b) ? 1.0f : 0.0f;\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_ABOVE;\n\n        D_EXEC(qemu_log(\"ABOVE a=%f b=%f t=%f, r=%08x\\n\", a, b, t, r));\n\n    } break;\n\n    case OP_EQUAL:\n\n    {\n\n        float a = REINTERPRET_CAST(float, s->gp_regs[reg_a]);\n\n        float b = REINTERPRET_CAST(float, s->gp_regs[reg_b]);\n\n        float t = (a == b) ? 1.0f : 0.0f;\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_EQUAL;\n\n        D_EXEC(qemu_log(\"EQUAL a=%f b=%f t=%f, r=%08x\\n\", a, b, t, r));\n\n    } break;\n\n    case OP_COPY:\n\n    {\n\n        r = s->gp_regs[reg_a];\n\n        latency = LATENCY_COPY;\n\n        D_EXEC(qemu_log(\"COPY\"));\n\n    } break;\n\n    case OP_IF:\n\n    {\n\n        float a = REINTERPRET_CAST(float, s->gp_regs[reg_a]);\n\n        float b = REINTERPRET_CAST(float, s->gp_regs[reg_b]);\n\n        uint32_t f = s->gp_regs[GPR_FLAGS];\n\n        float t = (f != 0) ? a : b;\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_IF;\n\n        D_EXEC(qemu_log(\"IF f=%u a=%f b=%f t=%f, r=%08x\\n\", f, a, b, t, r));\n\n    } break;\n\n    case OP_TSIGN:\n\n    {\n\n        float a = REINTERPRET_CAST(float, s->gp_regs[reg_a]);\n\n        float b = REINTERPRET_CAST(float, s->gp_regs[reg_b]);\n\n        float t = (b < 0) ? -a : a;\n\n        r = REINTERPRET_CAST(uint32_t, t);\n\n        latency = LATENCY_TSIGN;\n\n        D_EXEC(qemu_log(\"TSIGN a=%f b=%f t=%f, r=%08x\\n\", a, b, t, r));\n\n    } break;\n\n    case OP_QUAKE:\n\n    {\n\n        uint32_t a = s->gp_regs[reg_a];\n\n        r = 0x5f3759df - (a >> 1);\n\n        latency = LATENCY_QUAKE;\n\n        D_EXEC(qemu_log(\"QUAKE a=%d r=%08x\\n\", a, r));\n\n    } break;\n\n\n\n    default:\n\n        error_report(\"milkymist_pfpu: unknown opcode %d\", op);\n\n        break;\n\n    }\n\n\n\n    if (!reg_d) {\n\n        D_EXEC(qemu_log(\"%04d %8s R%03d, R%03d <L=%d, E=%04d>\\n\",\n\n                    s->regs[R_PC], opcode_to_str[op], reg_a, reg_b, latency,\n\n                    s->regs[R_PC] + latency));\n\n    } else {\n\n        D_EXEC(qemu_log(\"%04d %8s R%03d, R%03d <L=%d, E=%04d> -> R%03d\\n\",\n\n                    s->regs[R_PC], opcode_to_str[op], reg_a, reg_b, latency,\n\n                    s->regs[R_PC] + latency, reg_d));\n\n    }\n\n\n\n    if (op == OP_VECTOUT) {\n\n        return 0;\n\n    }\n\n\n\n    /* store output for this cycle */\n\n    if (reg_d) {\n\n        uint32_t val = output_queue_remove(s);\n\n        D_EXEC(qemu_log(\"R%03d <- 0x%08x\\n\", reg_d, val));\n\n        s->gp_regs[reg_d] = val;\n\n    }\n\n\n\n    output_queue_advance(s);\n\n\n\n    /* store op output */\n\n    if (op != OP_NOP) {\n\n        output_queue_insert(s, r, latency-1);\n\n    }\n\n\n\n    /* advance PC */\n\n    s->regs[R_PC]++;\n\n\n\n    return 1;\n\n};\n", "idx": 17693, "_split": "valid", "_hash": "8d2016fede6095c235e2823a2b18db98"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void eepro100_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t data, unsigned size)\n\n{\n\n    EEPRO100State *s = opaque;\n\n\n\n    switch (size) {\n\n    case 1:\n\n        eepro100_write1(s, addr, data);\n\n        break;\n\n    case 2:\n\n        eepro100_write2(s, addr, data);\n\n        break;\n\n    case 4:\n\n        eepro100_write4(s, addr, data);\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n}\n", "idx": 17698, "_split": "valid", "_hash": "6f8067e17bee38b9e36abbb2a859adee"}
{"project": "qemu", "commit_id": "9167a69a816b8956d62da628b5b4dc87674647d6", "target": 0, "func": "static uint8_t lsi_reg_readb(LSIState *s, int offset)\n\n{\n\n    uint8_t tmp;\n\n#define CASE_GET_REG32(name, addr) \\\n\n    case addr: return s->name & 0xff; \\\n\n    case addr + 1: return (s->name >> 8) & 0xff; \\\n\n    case addr + 2: return (s->name >> 16) & 0xff; \\\n\n    case addr + 3: return (s->name >> 24) & 0xff;\n\n\n\n#ifdef DEBUG_LSI_REG\n\n    DPRINTF(\"Read reg %x\\n\", offset);\n\n#endif\n\n    switch (offset) {\n\n    case 0x00: /* SCNTL0 */\n\n        return s->scntl0;\n\n    case 0x01: /* SCNTL1 */\n\n        return s->scntl1;\n\n    case 0x02: /* SCNTL2 */\n\n        return s->scntl2;\n\n    case 0x03: /* SCNTL3 */\n\n        return s->scntl3;\n\n    case 0x04: /* SCID */\n\n        return s->scid;\n\n    case 0x05: /* SXFER */\n\n        return s->sxfer;\n\n    case 0x06: /* SDID */\n\n        return s->sdid;\n\n    case 0x07: /* GPREG0 */\n\n        return 0x7f;\n\n    case 0x08: /* Revision ID */\n\n        return 0x00;\n\n    case 0xa: /* SSID */\n\n        return s->ssid;\n\n    case 0xb: /* SBCL */\n\n        /* ??? This is not correct. However it's (hopefully) only\n\n           used for diagnostics, so should be ok.  */\n\n        return 0;\n\n    case 0xc: /* DSTAT */\n\n        tmp = s->dstat | 0x80;\n\n        if ((s->istat0 & LSI_ISTAT0_INTF) == 0)\n\n            s->dstat = 0;\n\n        lsi_update_irq(s);\n\n        return tmp;\n\n    case 0x0d: /* SSTAT0 */\n\n        return s->sstat0;\n\n    case 0x0e: /* SSTAT1 */\n\n        return s->sstat1;\n\n    case 0x0f: /* SSTAT2 */\n\n        return s->scntl1 & LSI_SCNTL1_CON ? 0 : 2;\n\n    CASE_GET_REG32(dsa, 0x10)\n\n    case 0x14: /* ISTAT0 */\n\n        return s->istat0;\n\n    case 0x16: /* MBOX0 */\n\n        return s->mbox0;\n\n    case 0x17: /* MBOX1 */\n\n        return s->mbox1;\n\n    case 0x18: /* CTEST0 */\n\n        return 0xff;\n\n    case 0x19: /* CTEST1 */\n\n        return 0;\n\n    case 0x1a: /* CTEST2 */\n\n        tmp = LSI_CTEST2_DACK | LSI_CTEST2_CM;\n\n        if (s->istat0 & LSI_ISTAT0_SIGP) {\n\n            s->istat0 &= ~LSI_ISTAT0_SIGP;\n\n            tmp |= LSI_CTEST2_SIGP;\n\n        }\n\n        return tmp;\n\n    case 0x1b: /* CTEST3 */\n\n        return s->ctest3;\n\n    CASE_GET_REG32(temp, 0x1c)\n\n    case 0x20: /* DFIFO */\n\n        return 0;\n\n    case 0x21: /* CTEST4 */\n\n        return s->ctest4;\n\n    case 0x22: /* CTEST5 */\n\n        return s->ctest5;\n\n    case 0x23: /* CTEST6 */\n\n         return 0;\n\n    case 0x24: /* DBC[0:7] */\n\n        return s->dbc & 0xff;\n\n    case 0x25: /* DBC[8:15] */\n\n        return (s->dbc >> 8) & 0xff;\n\n    case 0x26: /* DBC[16->23] */\n\n        return (s->dbc >> 16) & 0xff;\n\n    case 0x27: /* DCMD */\n\n        return s->dcmd;\n\n    CASE_GET_REG32(dsp, 0x2c)\n\n    CASE_GET_REG32(dsps, 0x30)\n\n    CASE_GET_REG32(scratch[0], 0x34)\n\n    case 0x38: /* DMODE */\n\n        return s->dmode;\n\n    case 0x39: /* DIEN */\n\n        return s->dien;\n\n    case 0x3b: /* DCNTL */\n\n        return s->dcntl;\n\n    case 0x40: /* SIEN0 */\n\n        return s->sien0;\n\n    case 0x41: /* SIEN1 */\n\n        return s->sien1;\n\n    case 0x42: /* SIST0 */\n\n        tmp = s->sist0;\n\n        s->sist0 = 0;\n\n        lsi_update_irq(s);\n\n        return tmp;\n\n    case 0x43: /* SIST1 */\n\n        tmp = s->sist1;\n\n        s->sist1 = 0;\n\n        lsi_update_irq(s);\n\n        return tmp;\n\n    case 0x47: /* GPCNTL0 */\n\n        return 0x0f;\n\n    case 0x48: /* STIME0 */\n\n        return s->stime0;\n\n    case 0x4a: /* RESPID0 */\n\n        return s->respid0;\n\n    case 0x4b: /* RESPID1 */\n\n        return s->respid1;\n\n    case 0x4d: /* STEST1 */\n\n        return s->stest1;\n\n    case 0x4e: /* STEST2 */\n\n        return s->stest2;\n\n    case 0x4f: /* STEST3 */\n\n        return s->stest3;\n\n    case 0x50: /* SIDL */\n\n        /* This is needed by the linux drivers.  We currently only update it\n\n           during the MSG IN phase.  */\n\n        return s->sidl;\n\n    case 0x52: /* STEST4 */\n\n        return 0xe0;\n\n    case 0x56: /* CCNTL0 */\n\n        return s->ccntl0;\n\n    case 0x57: /* CCNTL1 */\n\n        return s->ccntl1;\n\n    case 0x58: /* SBDL */\n\n        /* Some drivers peek at the data bus during the MSG IN phase.  */\n\n        if ((s->sstat1 & PHASE_MASK) == PHASE_MI)\n\n            return s->msg[0];\n\n        return 0;\n\n    case 0x59: /* SBDL high */\n\n        return 0;\n\n    CASE_GET_REG32(mmrs, 0xa0)\n\n    CASE_GET_REG32(mmws, 0xa4)\n\n    CASE_GET_REG32(sfs, 0xa8)\n\n    CASE_GET_REG32(drs, 0xac)\n\n    CASE_GET_REG32(sbms, 0xb0)\n\n    CASE_GET_REG32(dmbs, 0xb4)\n\n    CASE_GET_REG32(dnad64, 0xb8)\n\n    CASE_GET_REG32(pmjad1, 0xc0)\n\n    CASE_GET_REG32(pmjad2, 0xc4)\n\n    CASE_GET_REG32(rbc, 0xc8)\n\n    CASE_GET_REG32(ua, 0xcc)\n\n    CASE_GET_REG32(ia, 0xd4)\n\n    CASE_GET_REG32(sbc, 0xd8)\n\n    CASE_GET_REG32(csbc, 0xdc)\n\n    }\n\n    if (offset >= 0x5c && offset < 0xa0) {\n\n        int n;\n\n        int shift;\n\n        n = (offset - 0x58) >> 2;\n\n        shift = (offset & 3) * 8;\n\n        return (s->scratch[n] >> shift) & 0xff;\n\n    }\n\n    BADF(\"readb 0x%x\\n\", offset);\n\n    exit(1);\n\n#undef CASE_GET_REG32\n\n}\n", "idx": 17713, "_split": "valid", "_hash": "3074220e9154676931dd23f70f51cab7"}
{"project": "qemu", "commit_id": "93147a180c10b97bf9575a87e01c9a1c93e6c9ce", "target": 0, "func": "void HELPER(mtspr)(CPUOpenRISCState *env,\n\n                   target_ulong ra, target_ulong rb, target_ulong offset)\n\n{\n\n#ifndef CONFIG_USER_ONLY\n\n    int spr = (ra | offset);\n\n    int idx;\n\n\n\n    OpenRISCCPU *cpu = openrisc_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n\n\n    switch (spr) {\n\n    case TO_SPR(0, 0): /* VR */\n\n        env->vr = rb;\n\n        break;\n\n\n\n    case TO_SPR(0, 16): /* NPC */\n\n        env->npc = rb;\n\n        break;\n\n\n\n    case TO_SPR(0, 17): /* SR */\n\n        if ((env->sr & (SR_IME | SR_DME | SR_SM)) ^\n\n            (rb & (SR_IME | SR_DME | SR_SM))) {\n\n            tlb_flush(env, 1);\n\n        }\n\n        env->sr = rb;\n\n        env->sr |= SR_FO;      /* FO is const equal to 1 */\n\n        if (env->sr & SR_DME) {\n\n            env->tlb->cpu_openrisc_map_address_data =\n\n                &cpu_openrisc_get_phys_data;\n\n        } else {\n\n            env->tlb->cpu_openrisc_map_address_data =\n\n                &cpu_openrisc_get_phys_nommu;\n\n        }\n\n\n\n        if (env->sr & SR_IME) {\n\n            env->tlb->cpu_openrisc_map_address_code =\n\n                &cpu_openrisc_get_phys_code;\n\n        } else {\n\n            env->tlb->cpu_openrisc_map_address_code =\n\n                &cpu_openrisc_get_phys_nommu;\n\n        }\n\n        break;\n\n\n\n    case TO_SPR(0, 18): /* PPC */\n\n        env->ppc = rb;\n\n        break;\n\n\n\n    case TO_SPR(0, 32): /* EPCR */\n\n        env->epcr = rb;\n\n        break;\n\n\n\n    case TO_SPR(0, 48): /* EEAR */\n\n        env->eear = rb;\n\n        break;\n\n\n\n    case TO_SPR(0, 64): /* ESR */\n\n        env->esr = rb;\n\n        break;\n\n    case TO_SPR(1, 512) ... TO_SPR(1, 639): /* DTLBW0MR 0-127 */\n\n        idx = spr - TO_SPR(1, 512);\n\n        if (!(rb & 1)) {\n\n            tlb_flush_page(env, env->tlb->dtlb[0][idx].mr & TARGET_PAGE_MASK);\n\n        }\n\n        env->tlb->dtlb[0][idx].mr = rb;\n\n        break;\n\n\n\n    case TO_SPR(1, 640) ... TO_SPR(1, 767): /* DTLBW0TR 0-127 */\n\n        idx = spr - TO_SPR(1, 640);\n\n        env->tlb->dtlb[0][idx].tr = rb;\n\n        break;\n\n    case TO_SPR(1, 768) ... TO_SPR(1, 895):   /* DTLBW1MR 0-127 */\n\n    case TO_SPR(1, 896) ... TO_SPR(1, 1023):  /* DTLBW1TR 0-127 */\n\n    case TO_SPR(1, 1024) ... TO_SPR(1, 1151): /* DTLBW2MR 0-127 */\n\n    case TO_SPR(1, 1152) ... TO_SPR(1, 1279): /* DTLBW2TR 0-127 */\n\n    case TO_SPR(1, 1280) ... TO_SPR(1, 1407): /* DTLBW3MR 0-127 */\n\n    case TO_SPR(1, 1408) ... TO_SPR(1, 1535): /* DTLBW3TR 0-127 */\n\n        break;\n\n    case TO_SPR(2, 512) ... TO_SPR(2, 639):   /* ITLBW0MR 0-127 */\n\n        idx = spr - TO_SPR(2, 512);\n\n        if (!(rb & 1)) {\n\n            tlb_flush_page(env, env->tlb->itlb[0][idx].mr & TARGET_PAGE_MASK);\n\n        }\n\n        env->tlb->itlb[0][idx].mr = rb;\n\n        break;\n\n\n\n    case TO_SPR(2, 640) ... TO_SPR(2, 767): /* ITLBW0TR 0-127 */\n\n        idx = spr - TO_SPR(2, 640);\n\n        env->tlb->itlb[0][idx].tr = rb;\n\n        break;\n\n    case TO_SPR(2, 768) ... TO_SPR(2, 895):   /* ITLBW1MR 0-127 */\n\n    case TO_SPR(2, 896) ... TO_SPR(2, 1023):  /* ITLBW1TR 0-127 */\n\n    case TO_SPR(2, 1024) ... TO_SPR(2, 1151): /* ITLBW2MR 0-127 */\n\n    case TO_SPR(2, 1152) ... TO_SPR(2, 1279): /* ITLBW2TR 0-127 */\n\n    case TO_SPR(2, 1280) ... TO_SPR(2, 1407): /* ITLBW3MR 0-127 */\n\n    case TO_SPR(2, 1408) ... TO_SPR(2, 1535): /* ITLBW3TR 0-127 */\n\n        break;\n\n    case TO_SPR(9, 0):  /* PICMR */\n\n        env->picmr |= rb;\n\n        break;\n\n    case TO_SPR(9, 2):  /* PICSR */\n\n        env->picsr &= ~rb;\n\n        break;\n\n    case TO_SPR(10, 0): /* TTMR */\n\n        {\n\n            if ((env->ttmr & TTMR_M) ^ (rb & TTMR_M)) {\n\n                switch (rb & TTMR_M) {\n\n                case TIMER_NONE:\n\n                    cpu_openrisc_count_stop(cpu);\n\n                    break;\n\n                case TIMER_INTR:\n\n                case TIMER_SHOT:\n\n                case TIMER_CONT:\n\n                    cpu_openrisc_count_start(cpu);\n\n                    break;\n\n                default:\n\n                    break;\n\n                }\n\n            }\n\n\n\n            int ip = env->ttmr & TTMR_IP;\n\n\n\n            if (rb & TTMR_IP) {    /* Keep IP bit.  */\n\n                env->ttmr = (rb & ~TTMR_IP) | ip;\n\n            } else {    /* Clear IP bit.  */\n\n                env->ttmr = rb & ~TTMR_IP;\n\n                cs->interrupt_request &= ~CPU_INTERRUPT_TIMER;\n\n            }\n\n\n\n            cpu_openrisc_timer_update(cpu);\n\n        }\n\n        break;\n\n\n\n    case TO_SPR(10, 1): /* TTCR */\n\n        env->ttcr = rb;\n\n        if (env->ttmr & TIMER_NONE) {\n\n            return;\n\n        }\n\n        cpu_openrisc_timer_update(cpu);\n\n        break;\n\n    default:\n\n\n\n        break;\n\n    }\n\n#endif\n\n}\n", "idx": 17721, "_split": "valid", "_hash": "1b78b4bd13286ed50cf4bd3b018c9d32"}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline TCGv gen_ld8s(TCGv addr, int index)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_qemu_ld8s(tmp, addr, index);\n\n    return tmp;\n\n}\n", "idx": 17739, "_split": "valid", "_hash": "ee3c1829329ada7198076f53ef6d28d4"}
{"project": "qemu", "commit_id": "b2d1fe67d09d2b6c7da647fbcea6ca0148c206d3", "target": 1, "func": "static void usbredir_handle_bulk_data(USBRedirDevice *dev, USBPacket *p,\n\n                                      uint8_t ep)\n\n{\n\n    struct usb_redir_bulk_packet_header bulk_packet;\n\n    size_t size = (p->combined) ? p->combined->iov.size : p->iov.size;\n\n\n\n    DPRINTF(\"bulk-out ep %02X len %zd id %\"PRIu64\"\\n\", ep, size, p->id);\n\n\n\n    if (usbredir_already_in_flight(dev, p->id)) {\n\n        p->status = USB_RET_ASYNC;\n\n        return;\n\n    }\n\n\n\n    bulk_packet.endpoint  = ep;\n\n    bulk_packet.length    = size;\n\n    bulk_packet.stream_id = 0;\n\n    bulk_packet.length_high = size >> 16;\n\n    assert(bulk_packet.length_high == 0 ||\n\n           usbredirparser_peer_has_cap(dev->parser,\n\n                                       usb_redir_cap_32bits_bulk_length));\n\n\n\n    if (ep & USB_DIR_IN) {\n\n        usbredirparser_send_bulk_packet(dev->parser, p->id,\n\n                                        &bulk_packet, NULL, 0);\n\n    } else {\n\n        uint8_t buf[size];\n\n        if (p->combined) {\n\n            iov_to_buf(p->combined->iov.iov, p->combined->iov.niov,\n\n                       0, buf, size);\n\n        } else {\n\n            usb_packet_copy(p, buf, size);\n\n        }\n\n        usbredir_log_data(dev, \"bulk data out:\", buf, size);\n\n        usbredirparser_send_bulk_packet(dev->parser, p->id,\n\n                                        &bulk_packet, buf, size);\n\n    }\n\n    usbredirparser_do_write(dev->parser);\n\n    p->status = USB_RET_ASYNC;\n\n}\n", "idx": 17751, "_split": "valid", "_hash": "083ae3a723f5020b6e392bb2a5c5bff3"}
{"project": "qemu", "commit_id": "eff235eb2bcd7092901f4698a7907e742f3b7f2f", "target": 1, "func": "static ExitStatus trans_fop_dedd(DisasContext *ctx, uint32_t insn,\n\n                                 const DisasInsn *di)\n\n{\n\n    unsigned rt = extract32(insn, 0, 5);\n\n    unsigned rb = extract32(insn, 16, 5);\n\n    unsigned ra = extract32(insn, 21, 5);\n\n    return do_fop_dedd(ctx, rt, ra, rb, di->f_dedd);\n\n}\n", "idx": 17767, "_split": "valid", "_hash": "ebb90cfefdb526bfb4b8e8eb97422fb4"}
{"project": "qemu", "commit_id": "8c6c919e281231dc3c77191b5a8c3c427ff17be8", "target": 1, "func": "static int kvm_get_sregs(CPUState *env)\n\n{\n\n    struct kvm_sregs sregs;\n\n    uint32_t hflags;\n\n    int ret;\n\n\n\n    ret = kvm_vcpu_ioctl(env, KVM_GET_SREGS, &sregs);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    memcpy(env->interrupt_bitmap, \n\n           sregs.interrupt_bitmap,\n\n           sizeof(sregs.interrupt_bitmap));\n\n\n\n    get_seg(&env->segs[R_CS], &sregs.cs);\n\n    get_seg(&env->segs[R_DS], &sregs.ds);\n\n    get_seg(&env->segs[R_ES], &sregs.es);\n\n    get_seg(&env->segs[R_FS], &sregs.fs);\n\n    get_seg(&env->segs[R_GS], &sregs.gs);\n\n    get_seg(&env->segs[R_SS], &sregs.ss);\n\n\n\n    get_seg(&env->tr, &sregs.tr);\n\n    get_seg(&env->ldt, &sregs.ldt);\n\n\n\n    env->idt.limit = sregs.idt.limit;\n\n    env->idt.base = sregs.idt.base;\n\n    env->gdt.limit = sregs.gdt.limit;\n\n    env->gdt.base = sregs.gdt.base;\n\n\n\n    env->cr[0] = sregs.cr0;\n\n    env->cr[2] = sregs.cr2;\n\n    env->cr[3] = sregs.cr3;\n\n    env->cr[4] = sregs.cr4;\n\n\n\n    cpu_set_apic_base(env, sregs.apic_base);\n\n\n\n    env->efer = sregs.efer;\n\n    //cpu_set_apic_tpr(env, sregs.cr8);\n\n\n\n#define HFLAG_COPY_MASK ~( \\\n\n\t\t\tHF_CPL_MASK | HF_PE_MASK | HF_MP_MASK | HF_EM_MASK | \\\n\n\t\t\tHF_TS_MASK | HF_TF_MASK | HF_VM_MASK | HF_IOPL_MASK | \\\n\n\t\t\tHF_OSFXSR_MASK | HF_LMA_MASK | HF_CS32_MASK | \\\n\n\t\t\tHF_SS32_MASK | HF_CS64_MASK | HF_ADDSEG_MASK)\n\n\n\n\n\n\n\n    hflags = (env->segs[R_CS].flags >> DESC_DPL_SHIFT) & HF_CPL_MASK;\n\n    hflags |= (env->cr[0] & CR0_PE_MASK) << (HF_PE_SHIFT - CR0_PE_SHIFT);\n\n    hflags |= (env->cr[0] << (HF_MP_SHIFT - CR0_MP_SHIFT)) &\n\n\t    (HF_MP_MASK | HF_EM_MASK | HF_TS_MASK);\n\n    hflags |= (env->eflags & (HF_TF_MASK | HF_VM_MASK | HF_IOPL_MASK));\n\n    hflags |= (env->cr[4] & CR4_OSFXSR_MASK) <<\n\n\t    (HF_OSFXSR_SHIFT - CR4_OSFXSR_SHIFT);\n\n\n\n    if (env->efer & MSR_EFER_LMA) {\n\n        hflags |= HF_LMA_MASK;\n\n    }\n\n\n\n    if ((hflags & HF_LMA_MASK) && (env->segs[R_CS].flags & DESC_L_MASK)) {\n\n        hflags |= HF_CS32_MASK | HF_SS32_MASK | HF_CS64_MASK;\n\n    } else {\n\n        hflags |= (env->segs[R_CS].flags & DESC_B_MASK) >>\n\n\t\t(DESC_B_SHIFT - HF_CS32_SHIFT);\n\n        hflags |= (env->segs[R_SS].flags & DESC_B_MASK) >>\n\n\t\t(DESC_B_SHIFT - HF_SS32_SHIFT);\n\n        if (!(env->cr[0] & CR0_PE_MASK) ||\n\n                   (env->eflags & VM_MASK) ||\n\n                   !(hflags & HF_CS32_MASK)) {\n\n                hflags |= HF_ADDSEG_MASK;\n\n            } else {\n\n                hflags |= ((env->segs[R_DS].base |\n\n                                env->segs[R_ES].base |\n\n                                env->segs[R_SS].base) != 0) <<\n\n                    HF_ADDSEG_SHIFT;\n\n            }\n\n    }\n\n    env->hflags = (env->hflags & HFLAG_COPY_MASK) | hflags;\n\n    env->cc_src = env->eflags & (CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n    env->df = 1 - (2 * ((env->eflags >> 10) & 1));\n\n    env->cc_op = CC_OP_EFLAGS;\n\n    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n\n\n    return 0;\n\n}\n", "idx": 17779, "_split": "valid", "_hash": "3751a724bcef04c4ca0e31a4468d83dd"}
{"project": "qemu", "commit_id": "ad718d01ba0af531d10b0a8685cf5047edfd1891", "target": 1, "func": "int qemu_opt_set_bool(QemuOpts *opts, const char *name, bool val)\n\n{\n\n    QemuOpt *opt;\n\n    const QemuOptDesc *desc = opts->list->desc;\n\n    int i;\n\n\n\n    for (i = 0; desc[i].name != NULL; i++) {\n\n        if (strcmp(desc[i].name, name) == 0) {\n\n            break;\n\n        }\n\n    }\n\n    if (desc[i].name == NULL) {\n\n        if (i == 0) {\n\n            /* empty list -> allow any */;\n\n        } else {\n\n            qerror_report(QERR_INVALID_PARAMETER, name);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    opt = g_malloc0(sizeof(*opt));\n\n    opt->name = g_strdup(name);\n\n    opt->opts = opts;\n\n    QTAILQ_INSERT_TAIL(&opts->head, opt, next);\n\n    if (desc[i].name != NULL) {\n\n        opt->desc = desc+i;\n\n    }\n\n    opt->value.boolean = !!val;\n\n    return 0;\n\n}\n", "idx": 17783, "_split": "valid", "_hash": "46e82165fe5eea5ff35f8d1273de9844"}
{"project": "qemu", "commit_id": "2d528d45ecf5ee3c1a566a9f3d664464925ef830", "target": 1, "func": "static CharDriverState *qemu_chr_open_pp_fd(int fd)\n\n{\n\n    CharDriverState *chr;\n\n    ParallelCharDriver *drv;\n\n\n\n    if (ioctl(fd, PPCLAIM) < 0) {\n\n        close(fd);\n\n        return NULL;\n\n    }\n\n\n\n    drv = g_malloc0(sizeof(ParallelCharDriver));\n\n    drv->fd = fd;\n\n    drv->mode = IEEE1284_MODE_COMPAT;\n\n\n\n    chr = qemu_chr_alloc();\n\n    chr->chr_write = null_chr_write;\n\n    chr->chr_ioctl = pp_ioctl;\n\n    chr->chr_close = pp_close;\n\n    chr->opaque = drv;\n\n\n\n    return chr;\n\n}\n", "idx": 17818, "_split": "valid", "_hash": "015eda1f8b740f219e4300d11c4860cf"}
{"project": "qemu", "commit_id": "5eb6a3c50185e101f87382f41fb66eed5784e7ac", "target": 1, "func": "void qdev_prop_set_globals(DeviceState *dev)\n\n{\n\n    ObjectClass *class = object_get_class(OBJECT(dev));\n\n\n\n    do {\n\n        qdev_prop_set_globals_for_type(dev, object_class_get_name(class));\n\n        class = object_class_get_parent(class);\n\n    } while (class);\n\n}\n", "idx": 17842, "_split": "valid", "_hash": "a51bdb7037c3a61685470f9b13ca5616"}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "BlockDriverState *bdrv_new(const char *device_name, Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    int i;\n\n\n\n    if (bdrv_find(device_name)) {\n\n        error_setg(errp, \"Device with id '%s' already exists\",\n\n                   device_name);\n\n        return NULL;\n\n    }\n\n    if (bdrv_find_node(device_name)) {\n\n        error_setg(errp, \"Device with node-name '%s' already exists\",\n\n                   device_name);\n\n        return NULL;\n\n    }\n\n\n\n    bs = g_malloc0(sizeof(BlockDriverState));\n\n    QLIST_INIT(&bs->dirty_bitmaps);\n\n    pstrcpy(bs->device_name, sizeof(bs->device_name), device_name);\n\n    if (device_name[0] != '\\0') {\n\n        QTAILQ_INSERT_TAIL(&bdrv_states, bs, device_list);\n\n    }\n\n    for (i = 0; i < BLOCK_OP_TYPE_MAX; i++) {\n\n        QLIST_INIT(&bs->op_blockers[i]);\n\n    }\n\n    bdrv_iostatus_disable(bs);\n\n    notifier_list_init(&bs->close_notifiers);\n\n    notifier_with_return_list_init(&bs->before_write_notifiers);\n\n    qemu_co_queue_init(&bs->throttled_reqs[0]);\n\n    qemu_co_queue_init(&bs->throttled_reqs[1]);\n\n    bs->refcnt = 1;\n\n    bs->aio_context = qemu_get_aio_context();\n\n\n\n    return bs;\n\n}\n", "idx": 17858, "_split": "valid", "_hash": "306b11f7615524d62337366b746df154"}
{"project": "qemu", "commit_id": "651eb0f41b793021f7de672de78892def5819fb9", "target": 1, "func": "static int kvm_set_user_memory_region(KVMState *s, KVMSlot *slot)\n\n{\n\n    struct kvm_userspace_memory_region mem;\n\n\n\n    mem.slot = slot->slot;\n\n    mem.guest_phys_addr = slot->start_addr;\n\n    mem.userspace_addr = (unsigned long)slot->ram;\n\n    mem.flags = slot->flags;\n\n    if (s->migration_log) {\n\n        mem.flags |= KVM_MEM_LOG_DIRTY_PAGES;\n\n    }\n\n    if (mem.flags & KVM_MEM_READONLY) {\n\n        /* Set the slot size to 0 before setting the slot to the desired\n\n         * value. This is needed based on KVM commit 75d61fbc. */\n\n        mem.memory_size = 0;\n\n        kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &mem);\n\n    }\n\n    mem.memory_size = slot->memory_size;\n\n    return kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &mem);\n\n}\n", "idx": 17871, "_split": "valid", "_hash": "2f217b6002e2e3fdb1903cee3b52c39e"}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "void cpu_exec_init(CPUState *cpu, Error **errp)\n\n{\n\n    CPUClass *cc ATTRIBUTE_UNUSED = CPU_GET_CLASS(cpu);\n\n\n\n    cpu_list_add(cpu);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if (qdev_get_vmsd(DEVICE(cpu)) == NULL) {\n\n        vmstate_register(NULL, cpu->cpu_index, &vmstate_cpu_common, cpu);\n\n    }\n\n    if (cc->vmsd != NULL) {\n\n        vmstate_register(NULL, cpu->cpu_index, cc->vmsd, cpu);\n\n    }\n\n#endif\n\n}\n", "idx": 17889, "_split": "valid", "_hash": "28713317930bceada50ccd7ab2552500"}
{"project": "qemu", "commit_id": "164a101f28a53cd3db60ed874e7c3630e7988ed8", "target": 1, "func": "static bool aio_dispatch(AioContext *ctx)\n\n{\n\n    AioHandler *node;\n\n    bool progress = false;\n\n\n\n    /*\n\n     * We have to walk very carefully in case qemu_aio_set_fd_handler is\n\n     * called while we're walking.\n\n     */\n\n    node = QLIST_FIRST(&ctx->aio_handlers);\n\n    while (node) {\n\n        AioHandler *tmp;\n\n        int revents;\n\n\n\n        ctx->walking_handlers++;\n\n\n\n        revents = node->pfd.revents & node->pfd.events;\n\n        node->pfd.revents = 0;\n\n\n\n        if (!node->deleted &&\n\n            (revents & (G_IO_IN | G_IO_HUP | G_IO_ERR)) &&\n\n            node->io_read) {\n\n            node->io_read(node->opaque);\n\n            progress = true;\n\n        }\n\n        if (!node->deleted &&\n\n            (revents & (G_IO_OUT | G_IO_ERR)) &&\n\n            node->io_write) {\n\n            node->io_write(node->opaque);\n\n            progress = true;\n\n        }\n\n\n\n        tmp = node;\n\n        node = QLIST_NEXT(node, node);\n\n\n\n        ctx->walking_handlers--;\n\n\n\n        if (!ctx->walking_handlers && tmp->deleted) {\n\n            QLIST_REMOVE(tmp, node);\n\n            g_free(tmp);\n\n        }\n\n    }\n\n    return progress;\n\n}\n", "idx": 17933, "_split": "valid", "_hash": "d5064c6f9bc7f0dbf666c96c17e4ad44"}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void piix4_ide_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->no_hotplug = 1;\n\n    k->init = pci_piix_ide_initfn;\n\n    k->exit = pci_piix_ide_exitfn;\n\n    k->vendor_id = PCI_VENDOR_ID_INTEL;\n\n    k->device_id = PCI_DEVICE_ID_INTEL_82371AB;\n\n    k->class_id = PCI_CLASS_STORAGE_IDE;\n\n    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);\n\n    dc->no_user = 1;\n\n}\n", "idx": 17938, "_split": "valid", "_hash": "f5ca8333261cf924d89d6b64ef32547d"}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qdict_add_key(const char *key, QObject *obj, void *opaque)\n\n{\n\n    GHashTable *h = opaque;\n\n    g_hash_table_insert(h, (gpointer) key, NULL);\n\n}\n", "idx": 17958, "_split": "valid", "_hash": "9f87d6aa86bc66c347f5237c59a38796"}
{"project": "qemu", "commit_id": "3718d8ab65f68de2acccbe6a315907805f54e3cc", "target": 0, "func": "static void eject_device(BlockDriverState *bs, int force, Error **errp)\n\n{\n\n    if (bdrv_in_use(bs)) {\n\n        error_set(errp, QERR_DEVICE_IN_USE, bdrv_get_device_name(bs));\n\n        return;\n\n    }\n\n    if (!bdrv_dev_has_removable_media(bs)) {\n\n        error_setg(errp, \"Device '%s' is not removable\",\n\n                   bdrv_get_device_name(bs));\n\n        return;\n\n    }\n\n\n\n    if (bdrv_dev_is_medium_locked(bs) && !bdrv_dev_is_tray_open(bs)) {\n\n        bdrv_dev_eject_request(bs, force);\n\n        if (!force) {\n\n            error_setg(errp, \"Device '%s' is locked\",\n\n                       bdrv_get_device_name(bs));\n\n            return;\n\n        }\n\n    }\n\n\n\n    bdrv_close(bs);\n\n}\n", "idx": 17964, "_split": "valid", "_hash": "f2be7f2008b06c1541296248e3d77707"}
{"project": "qemu", "commit_id": "b53ccc30c40df52d192e469a86c188a8649c6df3", "target": 1, "func": "void qmp_dump_guest_memory(bool paging, const char *file, bool has_begin,\n\n                           int64_t begin, bool has_length, int64_t length,\n\n                           Error **errp)\n\n{\n\n    const char *p;\n\n    int fd = -1;\n\n    DumpState *s;\n\n    int ret;\n\n\n\n    if (has_begin && !has_length) {\n\n        error_set(errp, QERR_MISSING_PARAMETER, \"length\");\n\n        return;\n\n    }\n\n    if (!has_begin && has_length) {\n\n        error_set(errp, QERR_MISSING_PARAMETER, \"begin\");\n\n        return;\n\n    }\n\n\n\n#if !defined(WIN32)\n\n    if (strstart(file, \"fd:\", &p)) {\n\n        fd = monitor_get_fd(cur_mon, p, errp);\n\n        if (fd == -1) {\n\n            return;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if  (strstart(file, \"file:\", &p)) {\n\n        fd = qemu_open(p, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, S_IRUSR);\n\n        if (fd < 0) {\n\n            error_setg_file_open(errp, errno, p);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (fd == -1) {\n\n        error_set(errp, QERR_INVALID_PARAMETER, \"protocol\");\n\n        return;\n\n    }\n\n\n\n    s = g_malloc0(sizeof(DumpState));\n\n\n\n    ret = dump_init(s, fd, paging, has_begin, begin, length, errp);\n\n    if (ret < 0) {\n\n        g_free(s);\n\n        return;\n\n    }\n\n\n\n    if (create_vmcore(s) < 0 && !error_is_set(s->errp)) {\n\n        error_set(errp, QERR_IO_ERROR);\n\n    }\n\n\n\n    g_free(s);\n\n}\n", "idx": 17986, "_split": "valid", "_hash": "ad8d3cfa8b5d4000e720db5352f68bab"}
{"project": "qemu", "commit_id": "10f12e6450407b18b4d5a6b50d3852dcfd7fff75", "target": 1, "func": "static bool spapr_drc_needed(void *opaque)\n\n{\n\n    sPAPRDRConnector *drc = (sPAPRDRConnector *)opaque;\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n\n\n    /* If no dev is plugged in there is no need to migrate the DRC state */\n\n    if (!drc->dev) {\n\n        return false;\n\n    }\n\n\n\n    /*\n\n     * We need to migrate the state if it's not equal to the expected\n\n     * long-term state, which is the same as the coldplugged initial\n\n     * state */\n\n    return (drc->state != drck->ready_state);\n\n}\n", "idx": 17989, "_split": "valid", "_hash": "5864533a5b8c71b663a814a918ae0db5"}
{"project": "qemu", "commit_id": "39a611a3e035e148257af314a522a6cd169c2d0e", "target": 1, "func": "int qcow2_snapshot_delete(BlockDriverState *bs,\n\n                          const char *snapshot_id,\n\n                          const char *name,\n\n                          Error **errp)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowSnapshot sn;\n\n    int snapshot_index, ret;\n\n\n\n    /* Search the snapshot */\n\n    snapshot_index = find_snapshot_by_id_and_name(bs, snapshot_id, name);\n\n    if (snapshot_index < 0) {\n\n        error_setg(errp, \"Can't find the snapshot\");\n\n        return -ENOENT;\n\n    }\n\n    sn = s->snapshots[snapshot_index];\n\n\n\n    /* Remove it from the snapshot list */\n\n    memmove(s->snapshots + snapshot_index,\n\n            s->snapshots + snapshot_index + 1,\n\n            (s->nb_snapshots - snapshot_index - 1) * sizeof(sn));\n\n    s->nb_snapshots--;\n\n    ret = qcow2_write_snapshots(bs);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to remove snapshot from snapshot list\");\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * The snapshot is now unused, clean up. If we fail after this point, we\n\n     * won't recover but just leak clusters.\n\n     */\n\n    g_free(sn.id_str);\n\n    g_free(sn.name);\n\n\n\n    /*\n\n     * Now decrease the refcounts of clusters referenced by the snapshot and\n\n     * free the L1 table.\n\n     */\n\n    ret = qcow2_update_snapshot_refcount(bs, sn.l1_table_offset,\n\n                                         sn.l1_size, -1);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to free the cluster and L1 table\");\n\n        return ret;\n\n    }\n\n    qcow2_free_clusters(bs, sn.l1_table_offset, sn.l1_size * sizeof(uint64_t),\n\n                        QCOW2_DISCARD_SNAPSHOT);\n\n\n\n    /* must update the copied flag on the current cluster offsets */\n\n    ret = qcow2_update_snapshot_refcount(bs, s->l1_table_offset, s->l1_size, 0);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to update snapshot status in disk\");\n\n        return ret;\n\n    }\n\n\n\n#ifdef DEBUG_ALLOC\n\n    {\n\n        BdrvCheckResult result = {0};\n\n        qcow2_check_refcounts(bs, &result, 0);\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 17993, "_split": "valid", "_hash": "1ccc0ed2f6d569bc71728237f5976225"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void mcf_uart_mm_init(MemoryRegion *sysmem,\n\n                      target_phys_addr_t base,\n\n                      qemu_irq irq,\n\n                      CharDriverState *chr)\n\n{\n\n    mcf_uart_state *s;\n\n\n\n    s = mcf_uart_init(irq, chr);\n\n    memory_region_init_io(&s->iomem, &mcf_uart_ops, s, \"uart\", 0x40);\n\n    memory_region_add_subregion(sysmem, base, &s->iomem);\n\n}\n", "idx": 18003, "_split": "valid", "_hash": "70098731e927842a725d4e4ab7aa0225"}
{"project": "qemu", "commit_id": "277acfe8b38de35be8cb6e274678b5a7919c2d44", "target": 0, "func": "static void expr_error(Monitor *mon, const char *msg)\n\n{\n\n    monitor_printf(mon, \"%s\\n\", msg);\n\n    siglongjmp(expr_env, 1);\n\n}\n", "idx": 18005, "_split": "valid", "_hash": "b73dcdf0a2edd13cedb1f8f564f8b5f2"}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usb_msd_send_status(MSDState *s, USBPacket *p)\n\n{\n\n    struct usb_msd_csw csw;\n\n    int len;\n\n\n\n    csw.sig = cpu_to_le32(0x53425355);\n\n    csw.tag = cpu_to_le32(s->tag);\n\n    csw.residue = s->residue;\n\n    csw.status = s->result;\n\n\n\n    len = MIN(sizeof(csw), p->len);\n\n    memcpy(p->data, &csw, len);\n\n}\n", "idx": 18028, "_split": "valid", "_hash": "0ec4a1bac20811ba1e770e4e05821246"}
{"project": "qemu", "commit_id": "acedcfbf7a9a29c772f613bafac9f3430faa6347", "target": 0, "func": "static NetSocketState *net_socket_fd_init(VLANState *vlan,\n\n                                          const char *model, const char *name,\n\n                                          int fd, int is_connected)\n\n{\n\n    int so_type=-1, optlen=sizeof(so_type);\n\n\n\n    if(getsockopt(fd, SOL_SOCKET, SO_TYPE, (char *)&so_type,\n\n        (socklen_t *)&optlen)< 0) {\n\n\tfprintf(stderr, \"qemu: error: getsockopt(SO_TYPE) for fd=%d failed\\n\", fd);\n\n\treturn NULL;\n\n    }\n\n    switch(so_type) {\n\n    case SOCK_DGRAM:\n\n        return net_socket_fd_init_dgram(vlan, model, name, fd, is_connected);\n\n    case SOCK_STREAM:\n\n        return net_socket_fd_init_stream(vlan, model, name, fd, is_connected);\n\n    default:\n\n        /* who knows ... this could be a eg. a pty, do warn and continue as stream */\n\n        fprintf(stderr, \"qemu: warning: socket type=%d for fd=%d is not SOCK_DGRAM or SOCK_STREAM\\n\", so_type, fd);\n\n        return net_socket_fd_init_stream(vlan, model, name, fd, is_connected);\n\n    }\n\n    return NULL;\n\n}\n", "idx": 18045, "_split": "valid", "_hash": "4bd9afaec56cf20402078ac38f333041"}
{"project": "qemu", "commit_id": "6acbe4c6f18e7de00481ff30574262b58526de45", "target": 0, "func": "static void ich_ahci_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->init = pci_ich9_ahci_init;\n\n    k->exit = pci_ich9_uninit;\n\n    k->config_write = pci_ich9_write_config;\n\n    k->vendor_id = PCI_VENDOR_ID_INTEL;\n\n    k->device_id = PCI_DEVICE_ID_INTEL_82801IR;\n\n    k->revision = 0x02;\n\n    k->class_id = PCI_CLASS_STORAGE_SATA;\n\n    dc->alias = \"ahci\";\n\n    dc->vmsd = &vmstate_ahci;\n\n}\n", "idx": 18061, "_split": "valid", "_hash": "215c5199d5338a254bcee163aef356e8"}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_psr (const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return GET_PSR(env);\n\n}\n", "idx": 18078, "_split": "valid", "_hash": "1bec3fdc87634b7b4f70be1759715ebf"}
{"project": "qemu", "commit_id": "9cf2bab2edca1e651eef49f2417f8f67bdfe49bb", "target": 1, "func": "static int qemu_rdma_connect(RDMAContext *rdma, Error **errp)\n\n{\n\n    RDMACapabilities cap = {\n\n                                .version = RDMA_CONTROL_VERSION_CURRENT,\n\n                                .flags = 0,\n\n                           };\n\n    struct rdma_conn_param conn_param = { .initiator_depth = 2,\n\n                                          .retry_count = 5,\n\n                                          .private_data = &cap,\n\n                                          .private_data_len = sizeof(cap),\n\n                                        };\n\n    struct rdma_cm_event *cm_event;\n\n    int ret;\n\n\n\n    /*\n\n     * Only negotiate the capability with destination if the user\n\n     * on the source first requested the capability.\n\n     */\n\n    if (rdma->pin_all) {\n\n        trace_qemu_rdma_connect_pin_all_requested();\n\n        cap.flags |= RDMA_CAPABILITY_PIN_ALL;\n\n    }\n\n\n\n    caps_to_network(&cap);\n\n\n\n    ret = rdma_connect(rdma->cm_id, &conn_param);\n\n    if (ret) {\n\n        perror(\"rdma_connect\");\n\n        ERROR(errp, \"connecting to destination!\");\n\n        goto err_rdma_source_connect;\n\n    }\n\n\n\n    ret = rdma_get_cm_event(rdma->channel, &cm_event);\n\n    if (ret) {\n\n        perror(\"rdma_get_cm_event after rdma_connect\");\n\n        ERROR(errp, \"connecting to destination!\");\n\n        rdma_ack_cm_event(cm_event);\n\n        goto err_rdma_source_connect;\n\n    }\n\n\n\n    if (cm_event->event != RDMA_CM_EVENT_ESTABLISHED) {\n\n        perror(\"rdma_get_cm_event != EVENT_ESTABLISHED after rdma_connect\");\n\n        ERROR(errp, \"connecting to destination!\");\n\n        rdma_ack_cm_event(cm_event);\n\n        goto err_rdma_source_connect;\n\n    }\n\n    rdma->connected = true;\n\n\n\n    memcpy(&cap, cm_event->param.conn.private_data, sizeof(cap));\n\n    network_to_caps(&cap);\n\n\n\n    /*\n\n     * Verify that the *requested* capabilities are supported by the destination\n\n     * and disable them otherwise.\n\n     */\n\n    if (rdma->pin_all && !(cap.flags & RDMA_CAPABILITY_PIN_ALL)) {\n\n        ERROR(errp, \"Server cannot support pinning all memory. \"\n\n                        \"Will register memory dynamically.\");\n\n        rdma->pin_all = false;\n\n    }\n\n\n\n    trace_qemu_rdma_connect_pin_all_outcome(rdma->pin_all);\n\n\n\n    rdma_ack_cm_event(cm_event);\n\n\n\n    ret = qemu_rdma_post_recv_control(rdma, RDMA_WRID_READY);\n\n    if (ret) {\n\n        ERROR(errp, \"posting second control recv!\");\n\n        goto err_rdma_source_connect;\n\n    }\n\n\n\n    rdma->control_ready_expected = 1;\n\n    rdma->nb_sent = 0;\n\n    return 0;\n\n\n\nerr_rdma_source_connect:\n\n    qemu_rdma_cleanup(rdma);\n\n    return -1;\n\n}\n", "idx": 18081, "_split": "valid", "_hash": "a1e8411e4f4102ef2d144eba3cff0c84"}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "opts_start_list(Visitor *v, const char *name, Error **errp)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n\n\n    /* we can't traverse a list in a list */\n\n    assert(ov->list_mode == LM_NONE);\n\n    ov->repeated_opts = lookup_distinct(ov, name, errp);\n\n    if (ov->repeated_opts != NULL) {\n\n        ov->list_mode = LM_STARTED;\n\n    }\n\n}\n", "idx": 18102, "_split": "valid", "_hash": "e9b817eaea62f00d987ee76d0d1bf6d6"}
{"project": "qemu", "commit_id": "0fe282bb4b29ad51adefc2e500bcecfb3c499e10", "target": 0, "func": "void commit_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, BlockDriverState *top, int64_t speed,\n\n                  BlockdevOnError on_error, BlockCompletionFunc *cb,\n\n                  void *opaque, const char *backing_file_str, Error **errp)\n\n{\n\n    CommitBlockJob *s;\n\n    BlockReopenQueue *reopen_queue = NULL;\n\n    int orig_overlay_flags;\n\n    int orig_base_flags;\n\n    BlockDriverState *overlay_bs;\n\n    Error *local_err = NULL;\n\n\n\n    assert(top != bs);\n\n    if (top == base) {\n\n        error_setg(errp, \"Invalid files for merge: top and base are the same\");\n\n        return;\n\n    }\n\n\n\n    overlay_bs = bdrv_find_overlay(bs, top);\n\n\n\n    if (overlay_bs == NULL) {\n\n        error_setg(errp, \"Could not find overlay image for %s:\", top->filename);\n\n        return;\n\n    }\n\n\n\n    s = block_job_create(job_id, &commit_job_driver, bs, speed,\n\n                         cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    orig_base_flags    = bdrv_get_flags(base);\n\n    orig_overlay_flags = bdrv_get_flags(overlay_bs);\n\n\n\n    /* convert base & overlay_bs to r/w, if necessary */\n\n    if (!(orig_overlay_flags & BDRV_O_RDWR)) {\n\n        reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL,\n\n                                         orig_overlay_flags | BDRV_O_RDWR);\n\n    }\n\n    if (!(orig_base_flags & BDRV_O_RDWR)) {\n\n        reopen_queue = bdrv_reopen_queue(reopen_queue, base, NULL,\n\n                                         orig_base_flags | BDRV_O_RDWR);\n\n    }\n\n    if (reopen_queue) {\n\n        bdrv_reopen_multiple(reopen_queue, &local_err);\n\n        if (local_err != NULL) {\n\n            error_propagate(errp, local_err);\n\n            block_job_unref(&s->common);\n\n            return;\n\n        }\n\n    }\n\n\n\n\n\n    s->base = blk_new();\n\n    blk_insert_bs(s->base, base);\n\n\n\n    s->top = blk_new();\n\n    blk_insert_bs(s->top, top);\n\n\n\n    s->active = bs;\n\n\n\n    s->base_flags          = orig_base_flags;\n\n    s->orig_overlay_flags  = orig_overlay_flags;\n\n\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n\n\n    s->on_error = on_error;\n\n    s->common.co = qemu_coroutine_create(commit_run, s);\n\n\n\n    trace_commit_start(bs, base, top, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co);\n\n}\n", "idx": 18111, "_split": "valid", "_hash": "2529ea8cbb0d0ccefb86949a81db8579"}
{"project": "qemu", "commit_id": "88b062c2036cfd05b5111147736a08ba05ea05a9", "target": 0, "func": "static bool bdrv_drain_recurse(BlockDriverState *bs)\n\n{\n\n    BdrvChild *child;\n\n    bool waited;\n\n\n\n    waited = bdrv_drain_poll(bs);\n\n\n\n    if (bs->drv && bs->drv->bdrv_drain) {\n\n        bs->drv->bdrv_drain(bs);\n\n    }\n\n\n\n    QLIST_FOREACH(child, &bs->children, next) {\n\n        waited |= bdrv_drain_recurse(child->bs);\n\n    }\n\n\n\n    return waited;\n\n}\n", "idx": 18114, "_split": "valid", "_hash": "e92ebe3c0311a8c5fcfc1b57368d0327"}
{"project": "qemu", "commit_id": "9e41bade85ef338afd983c109368d1bbbe931f80", "target": 0, "func": "static void pxa2xx_i2c_slave_class_init(ObjectClass *klass, void *data)\n\n{\n\n    I2CSlaveClass *k = I2C_SLAVE_CLASS(klass);\n\n\n\n    k->init = pxa2xx_i2c_slave_init;\n\n    k->event = pxa2xx_i2c_event;\n\n    k->recv = pxa2xx_i2c_rx;\n\n    k->send = pxa2xx_i2c_tx;\n\n}\n", "idx": 18127, "_split": "valid", "_hash": "41939011433e43edb821698b73884f1c"}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "static inline int32_t efsctsi(uint32_t val)\n\n{\n\n    CPU_FloatU u;\n\n\n\n    u.l = val;\n\n    /* NaN are not treated the same way IEEE 754 does */\n\n    if (unlikely(float32_is_nan(u.f)))\n\n        return 0;\n\n\n\n    return float32_to_int32(u.f, &env->vec_status);\n\n}\n", "idx": 18129, "_split": "valid", "_hash": "7a28c1bac7fb9032b29a64688a340c4f"}
{"project": "qemu", "commit_id": "03d843ddf271e96b6f8b2cd8a58f7a2004fcfaf9", "target": 0, "func": "static inline int handle_cpu_signal(unsigned long pc,\n\n                                    unsigned long address,\n\n                                    int is_write,\n\n                                    sigset_t *old_set)\n\n{\n\n#if defined(DEBUG_SIGNAL)\n\n    printf(\"qemu: SIGSEGV pc=0x%08lx address=%08lx wr=%d oldset=0x%08lx\\n\", \n\n           pc, address, is_write, *(unsigned long *)old_set);\n\n#endif\n\n    /* XXX: locking issue */\n\n    if (is_write && page_unprotect(address)) {\n\n        sigprocmask(SIG_SETMASK, old_set, NULL);\n\n        return 1;\n\n    }\n\n    if (pc >= (unsigned long)code_gen_buffer &&\n\n        pc < (unsigned long)code_gen_buffer + CODE_GEN_BUFFER_SIZE) {\n\n        /* the PC is inside the translated code. It means that we have\n\n           a virtual CPU fault */\n\n        /* we restore the process signal mask as the sigreturn should\n\n           do it */\n\n        sigprocmask(SIG_SETMASK, old_set, NULL);\n\n        /* XXX: need to compute virtual pc position by retranslating\n\n           code. The rest of the CPU state should be correct. */\n\n        env->cr2 = address;\n\n        raise_exception_err(EXCP0E_PAGE, 4 | (is_write << 1));\n\n        /* never comes here */\n\n        return 1;\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n", "idx": 18130, "_split": "valid", "_hash": "abb08ceb182b2a2a9c946e2a2bcdd800"}
{"project": "qemu", "commit_id": "3098dba01c7daab60762b6f6624ea88c0d6cb65a", "target": 0, "func": "void DBDMA_schedule(void)\n\n{\n\n    CPUState *env = cpu_single_env;\n\n    if (env)\n\n        cpu_interrupt(env, CPU_INTERRUPT_EXIT);\n\n}\n", "idx": 18133, "_split": "valid", "_hash": "1fd1a54d878b017ab24f07b388e2d654"}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "void helper_fdmulq(CPUSPARCState *env, float64 src1, float64 src2)\n\n{\n\n    clear_float_exceptions(env);\n\n    QT0 = float128_mul(float64_to_float128(src1, &env->fp_status),\n\n                       float64_to_float128(src2, &env->fp_status),\n\n                       &env->fp_status);\n\n    check_ieee_exceptions(env);\n\n}\n", "idx": 18146, "_split": "valid", "_hash": "e5a0c52314731ac7639f244f3d801d0b"}
{"project": "qemu", "commit_id": "3b22c4707decb706b10ce023534f8b79413ff9fe", "target": 0, "func": "void helper_iret_real(int shift)\n\n{\n\n    uint32_t sp, new_cs, new_eip, new_eflags, new_esp;\n\n    uint8_t *ssp;\n\n    int eflags_mask;\n\n    \n\n    sp = env->regs[R_ESP] & 0xffff;\n\n    ssp = env->segs[R_SS].base + sp;\n\n    if (shift == 1) {\n\n        /* 32 bits */\n\n        new_eflags = ldl(ssp + 8);\n\n        new_cs = ldl(ssp + 4) & 0xffff;\n\n        new_eip = ldl(ssp) & 0xffff;\n\n    } else {\n\n        /* 16 bits */\n\n        new_eflags = lduw(ssp + 4);\n\n        new_cs = lduw(ssp + 2);\n\n        new_eip = lduw(ssp);\n\n    }\n\n    new_esp = sp + (6 << shift);\n\n    env->regs[R_ESP] = (env->regs[R_ESP] & 0xffff0000) | \n\n        (new_esp & 0xffff);\n\n    load_seg_vm(R_CS, new_cs);\n\n    env->eip = new_eip;\n\n    eflags_mask = FL_UPDATE_CPL0_MASK;\n\n    if (shift == 0)\n\n        eflags_mask &= 0xffff;\n\n    load_eflags(new_eflags, eflags_mask);\n\n}\n", "idx": 18149, "_split": "valid", "_hash": "e0bf23aad81bbae42062f9bae113956d"}
{"project": "qemu", "commit_id": "5839df7b71540a2af2580bb53ad1e2005bb175e6", "target": 1, "func": "static void process_ncq_command(AHCIState *s, int port, uint8_t *cmd_fis,\n\n                                uint8_t slot)\n\n{\n\n    AHCIDevice *ad = &s->dev[port];\n\n    IDEState *ide_state = &ad->port.ifs[0];\n\n    NCQFrame *ncq_fis = (NCQFrame*)cmd_fis;\n\n    uint8_t tag = ncq_fis->tag >> 3;\n\n    NCQTransferState *ncq_tfs = &ad->ncq_tfs[tag];\n\n    size_t size;\n\n\n\n    g_assert(is_ncq(ncq_fis->command));\n\n    if (ncq_tfs->used) {\n\n        /* error - already in use */\n\n        fprintf(stderr, \"%s: tag %d already used\\n\", __FUNCTION__, tag);\n\n        return;\n\n    }\n\n\n\n    ncq_tfs->used = 1;\n\n    ncq_tfs->drive = ad;\n\n    ncq_tfs->slot = slot;\n\n    ncq_tfs->cmdh = &((AHCICmdHdr *)ad->lst)[slot];\n\n    ncq_tfs->cmd = ncq_fis->command;\n\n    ncq_tfs->lba = ((uint64_t)ncq_fis->lba5 << 40) |\n\n                   ((uint64_t)ncq_fis->lba4 << 32) |\n\n                   ((uint64_t)ncq_fis->lba3 << 24) |\n\n                   ((uint64_t)ncq_fis->lba2 << 16) |\n\n                   ((uint64_t)ncq_fis->lba1 << 8) |\n\n                   (uint64_t)ncq_fis->lba0;\n\n    ncq_tfs->tag = tag;\n\n\n\n    /* Sanity-check the NCQ packet */\n\n    if (tag != slot) {\n\n        DPRINTF(port, \"Warn: NCQ slot (%d) did not match the given tag (%d)\\n\",\n\n                slot, tag);\n\n    }\n\n\n\n    if (ncq_fis->aux0 || ncq_fis->aux1 || ncq_fis->aux2 || ncq_fis->aux3) {\n\n        DPRINTF(port, \"Warn: Attempt to use NCQ auxiliary fields.\\n\");\n\n    }\n\n    if (ncq_fis->prio || ncq_fis->icc) {\n\n        DPRINTF(port, \"Warn: Unsupported attempt to use PRIO/ICC fields\\n\");\n\n    }\n\n    if (ncq_fis->fua & NCQ_FIS_FUA_MASK) {\n\n        DPRINTF(port, \"Warn: Unsupported attempt to use Force Unit Access\\n\");\n\n    }\n\n    if (ncq_fis->tag & NCQ_FIS_RARC_MASK) {\n\n        DPRINTF(port, \"Warn: Unsupported attempt to use Rebuild Assist\\n\");\n\n    }\n\n\n\n    ncq_tfs->sector_count = ((ncq_fis->sector_count_high << 8) |\n\n                             ncq_fis->sector_count_low);\n\n    if (!ncq_tfs->sector_count) {\n\n        ncq_tfs->sector_count = 0x10000;\n\n    }\n\n    size = ncq_tfs->sector_count * 512;\n\n    ahci_populate_sglist(ad, &ncq_tfs->sglist, ncq_tfs->cmdh, size, 0);\n\n\n\n    if (ncq_tfs->sglist.size < size) {\n\n        error_report(\"ahci: PRDT length for NCQ command (0x%zx) \"\n\n                     \"is smaller than the requested size (0x%zx)\",\n\n                     ncq_tfs->sglist.size, size);\n\n        qemu_sglist_destroy(&ncq_tfs->sglist);\n\n        ncq_err(ncq_tfs);\n\n        ahci_trigger_irq(ad->hba, ad, PORT_IRQ_OVERFLOW);\n\n        return;\n\n    } else if (ncq_tfs->sglist.size != size) {\n\n        DPRINTF(port, \"Warn: PRDTL (0x%zx)\"\n\n                \" does not match requested size (0x%zx)\",\n\n                ncq_tfs->sglist.size, size);\n\n    }\n\n\n\n    DPRINTF(port, \"NCQ transfer LBA from %\"PRId64\" to %\"PRId64\", \"\n\n            \"drive max %\"PRId64\"\\n\",\n\n            ncq_tfs->lba, ncq_tfs->lba + ncq_tfs->sector_count - 1,\n\n            ide_state->nb_sectors - 1);\n\n\n\n    execute_ncq_command(ncq_tfs);\n\n}\n", "idx": 18172, "_split": "valid", "_hash": "5d524ecfd9e43ac653d74567feebc29d"}
{"project": "qemu", "commit_id": "33e66b86d89040f0a9e99aa53deb74ce8936a649", "target": 1, "func": "USBDevice *usb_msd_init(const char *filename)\n\n{\n\n    static int nr=0;\n\n    char id[8];\n\n    QemuOpts *opts;\n\n    DriveInfo *dinfo;\n\n    USBDevice *dev;\n\n    int fatal_error;\n\n    const char *p1;\n\n    char fmt[32];\n\n\n\n    /* parse -usbdevice disk: syntax into drive opts */\n\n    snprintf(id, sizeof(id), \"usb%d\", nr++);\n\n    opts = qemu_opts_create(&qemu_drive_opts, id, 0);\n\n\n\n    p1 = strchr(filename, ':');\n\n    if (p1++) {\n\n        const char *p2;\n\n\n\n        if (strstart(filename, \"format=\", &p2)) {\n\n            int len = MIN(p1 - p2, sizeof(fmt));\n\n            pstrcpy(fmt, len, p2);\n\n            qemu_opt_set(opts, \"format\", fmt);\n\n        } else if (*filename != ':') {\n\n            printf(\"unrecognized USB mass-storage option %s\\n\", filename);\n\n            return NULL;\n\n        }\n\n        filename = p1;\n\n    }\n\n    if (!*filename) {\n\n        printf(\"block device specification needed\\n\");\n\n        return NULL;\n\n    }\n\n    qemu_opt_set(opts, \"file\", filename);\n\n    qemu_opt_set(opts, \"if\", \"none\");\n\n\n\n    /* create host drive */\n\n    dinfo = drive_init(opts, NULL, &fatal_error);\n\n    if (!dinfo) {\n\n        qemu_opts_del(opts);\n\n        return NULL;\n\n    }\n\n\n\n    /* create guest device */\n\n    dev = usb_create(NULL /* FIXME */, \"QEMU USB MSD\");\n\n    qdev_prop_set_drive(&dev->qdev, \"drive\", dinfo);\n\n    qdev_init(&dev->qdev);\n\n\n\n    return dev;\n\n}\n", "idx": 18179, "_split": "valid", "_hash": "8e65a4de3e91ed1949715f832dcddf72"}
{"project": "qemu", "commit_id": "66029f6a2f717873f2d170681f0250801a6d0d39", "target": 1, "func": "sowrite(so)\n\n\tstruct socket *so;\n\n{\n\n\tint  n,nn;\n\n\tstruct sbuf *sb = &so->so_rcv;\n\n\tint len = sb->sb_cc;\n\n\tstruct iovec iov[2];\n\n\n\n\tDEBUG_CALL(\"sowrite\");\n\n\tDEBUG_ARG(\"so = %lx\", (long)so);\n\n\n\n\tif (so->so_urgc) {\n\n\t\tsosendoob(so);\n\n\t\tif (sb->sb_cc == 0)\n\n\t\t\treturn 0;\n\n\t}\n\n\n\n\t/*\n\n\t * No need to check if there's something to write,\n\n\t * sowrite wouldn't have been called otherwise\n\n\t */\n\n\n\n        len = sb->sb_cc;\n\n\n\n\tiov[0].iov_base = sb->sb_rptr;\n\n\n\n\tif (sb->sb_rptr < sb->sb_wptr) {\n\n\t\tiov[0].iov_len = sb->sb_wptr - sb->sb_rptr;\n\n\t\t/* Should never succeed, but... */\n\n\t\tif (iov[0].iov_len > len) iov[0].iov_len = len;\n\n\t\tn = 1;\n\n\t} else {\n\n\t\tiov[0].iov_len = (sb->sb_data + sb->sb_datalen) - sb->sb_rptr;\n\n\t\tif (iov[0].iov_len > len) iov[0].iov_len = len;\n\n\t\tlen -= iov[0].iov_len;\n\n\t\tif (len) {\n\n\t\t\tiov[1].iov_base = sb->sb_data;\n\n\t\t\tiov[1].iov_len = sb->sb_wptr - sb->sb_data;\n\n\t\t\tif (iov[1].iov_len > len) iov[1].iov_len = len;\n\n\t\t\tn = 2;\n\n\t\t} else\n\n\t\t\tn = 1;\n\n\t}\n\n\t/* Check if there's urgent data to send, and if so, send it */\n\n\n\n#ifdef HAVE_READV\n\n\tnn = writev(so->s, (const struct iovec *)iov, n);\n\n\n\n\tDEBUG_MISC((dfd, \"  ... wrote nn = %d bytes\\n\", nn));\n\n#else\n\n\tnn = send(so->s, iov[0].iov_base, iov[0].iov_len,0);\n\n#endif\n\n\t/* This should never happen, but people tell me it does *shrug* */\n\n\tif (nn < 0 && (errno == EAGAIN || errno == EINTR))\n\n\t\treturn 0;\n\n\n\n\tif (nn <= 0) {\n\n\t\tDEBUG_MISC((dfd, \" --- sowrite disconnected, so->so_state = %x, errno = %d\\n\",\n\n\t\t\tso->so_state, errno));\n\n\t\tsofcantsendmore(so);\n\n\t\ttcp_sockclosed(sototcpcb(so));\n\n\t\treturn -1;\n\n\t}\n\n\n\n#ifndef HAVE_READV\n\n\tif (n == 2 && nn == iov[0].iov_len) {\n\n            int ret;\n\n            ret = send(so->s, iov[1].iov_base, iov[1].iov_len,0);\n\n            if (ret > 0)\n\n                nn += ret;\n\n        }\n\n        DEBUG_MISC((dfd, \"  ... wrote nn = %d bytes\\n\", nn));\n\n#endif\n\n\n\n\t/* Update sbuf */\n\n\tsb->sb_cc -= nn;\n\n\tsb->sb_rptr += nn;\n\n\tif (sb->sb_rptr >= (sb->sb_data + sb->sb_datalen))\n\n\t\tsb->sb_rptr -= sb->sb_datalen;\n\n\n\n\t/*\n\n\t * If in DRAIN mode, and there's no more data, set\n\n\t * it CANTSENDMORE\n\n\t */\n\n\tif ((so->so_state & SS_FWDRAIN) && sb->sb_cc == 0)\n\n\t\tsofcantsendmore(so);\n\n\n\n\treturn nn;\n\n}", "idx": 18183, "_split": "valid", "_hash": "79cc253811b37652a503b6a2464c7f6f"}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "static void rtc_get_date(Object *obj, Visitor *v, void *opaque,\n\n                         const char *name, Error **errp)\n\n{\n\n    Error *err = NULL;\n\n    RTCState *s = MC146818_RTC(obj);\n\n    struct tm current_tm;\n\n\n\n    rtc_update_time(s);\n\n    rtc_get_time(s, &current_tm);\n\n    visit_start_struct(v, NULL, \"struct tm\", name, 0, &err);\n\n    if (err) {\n\n        goto out;\n\n    }\n\n    visit_type_int32(v, &current_tm.tm_year, \"tm_year\", &err);\n\n    visit_type_int32(v, &current_tm.tm_mon, \"tm_mon\", &err);\n\n    visit_type_int32(v, &current_tm.tm_mday, \"tm_mday\", &err);\n\n    visit_type_int32(v, &current_tm.tm_hour, \"tm_hour\", &err);\n\n    visit_type_int32(v, &current_tm.tm_min, \"tm_min\", &err);\n\n    visit_type_int32(v, &current_tm.tm_sec, \"tm_sec\", &err);\n\n    visit_end_struct(v, &err);\n\n\n\nout:\n\n    error_propagate(errp, err);\n\n}\n", "idx": 18191, "_split": "valid", "_hash": "3c06dcb002074aa13eebf06a59962184"}
{"project": "qemu", "commit_id": "53cb28cbfea038f8ad50132dc8a684e638c7d48b", "target": 0, "func": "static uint16_t phys_section_add(MemoryRegionSection *section)\n\n{\n\n    /* The physical section number is ORed with a page-aligned\n\n     * pointer to produce the iotlb entries.  Thus it should\n\n     * never overflow into the page-aligned value.\n\n     */\n\n    assert(next_map.sections_nb < TARGET_PAGE_SIZE);\n\n\n\n    if (next_map.sections_nb == next_map.sections_nb_alloc) {\n\n        next_map.sections_nb_alloc = MAX(next_map.sections_nb_alloc * 2,\n\n                                         16);\n\n        next_map.sections = g_renew(MemoryRegionSection, next_map.sections,\n\n                                    next_map.sections_nb_alloc);\n\n    }\n\n    next_map.sections[next_map.sections_nb] = *section;\n\n    memory_region_ref(section->mr);\n\n    return next_map.sections_nb++;\n\n}\n", "idx": 18221, "_split": "valid", "_hash": "176ada0cddccb19f1c1ea33f77303969"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t intel_hda_mmio_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    return intel_hda_reg_read(d, reg, 0xff);\n\n}\n", "idx": 18232, "_split": "valid", "_hash": "7ffcd97f979a82f393460b0bb998aa57"}
{"project": "qemu", "commit_id": "3182664220571d11d4fe03ecdc10fcc1e842ed32", "target": 0, "func": "static bool is_zero(BlockDriverState *bs, int64_t offset, int64_t bytes)\n\n{\n\n    int nr;\n\n    int64_t res;\n\n    int64_t start;\n\n\n\n    /* TODO: Widening to sector boundaries should only be needed as\n\n     * long as we can't query finer granularity. */\n\n    start = QEMU_ALIGN_DOWN(offset, BDRV_SECTOR_SIZE);\n\n    bytes = QEMU_ALIGN_UP(offset + bytes, BDRV_SECTOR_SIZE) - start;\n\n\n\n    /* Clamp to image length, before checking status of underlying sectors */\n\n    if (start + bytes > bs->total_sectors * BDRV_SECTOR_SIZE) {\n\n        bytes = bs->total_sectors * BDRV_SECTOR_SIZE - start;\n\n    }\n\n\n\n    if (!bytes) {\n\n        return true;\n\n    }\n\n    res = bdrv_get_block_status_above(bs, NULL, start >> BDRV_SECTOR_BITS,\n\n                                      bytes >> BDRV_SECTOR_BITS, &nr, NULL);\n\n    return res >= 0 && (res & BDRV_BLOCK_ZERO) &&\n\n        nr * BDRV_SECTOR_SIZE == bytes;\n\n}\n", "idx": 18238, "_split": "valid", "_hash": "efa546f8201adb03bc13353d159b614d"}
{"project": "qemu", "commit_id": "fc1c4a5d32e15a4c40c47945da85ef9c1e0c1b54", "target": 0, "func": "void ram_handle_compressed(void *host, uint8_t ch, uint64_t size)\n\n{\n\n    if (ch != 0 || !is_zero_range(host, size)) {\n\n        memset(host, ch, size);\n\n#ifndef _WIN32\n\n        if (ch == 0 && (!kvm_enabled() || kvm_has_sync_mmu())) {\n\n            size = size & ~(getpagesize() - 1);\n\n            if (size > 0) {\n\n                qemu_madvise(host, size, QEMU_MADV_DONTNEED);\n\n            }\n\n        }\n\n#endif\n\n    }\n\n}\n", "idx": 18278, "_split": "valid", "_hash": "27aba45c9e7ecf2a6a0b4d8eae0340c9"}
{"project": "qemu", "commit_id": "c8057f951d64de93bfd01569c0a725baa9f94372", "target": 1, "func": "static QEMUMachine *machine_parse(const char *name)\n\n{\n\n    QEMUMachine *m, *machine = NULL;\n\n\n\n    if (name) {\n\n        machine = find_machine(name);\n\n    }\n\n    if (machine) {\n\n        return machine;\n\n    }\n\n    printf(\"Supported machines are:\\n\");\n\n    for (m = first_machine; m != NULL; m = m->next) {\n\n        if (m->alias) {\n\n            printf(\"%-20s %s (alias of %s)\\n\", m->alias, m->desc, m->name);\n\n        }\n\n        printf(\"%-20s %s%s\\n\", m->name, m->desc,\n\n               m->is_default ? \" (default)\" : \"\");\n\n    }\n\n    exit(!name || *name != '?');\n\n}\n", "idx": 18283, "_split": "valid", "_hash": "dd02c24b4643464b1ac232abd306d752"}
{"project": "qemu", "commit_id": "e53f27b9d9df73461308618151fa6e6392aebd85", "target": 1, "func": "static int do_getfd(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    const char *fdname = qdict_get_str(qdict, \"fdname\");\n\n    mon_fd_t *monfd;\n\n    int fd;\n\n\n\n    fd = qemu_chr_get_msgfd(mon->chr);\n\n    if (fd == -1) {\n\n        qerror_report(QERR_FD_NOT_SUPPLIED);\n\n        return -1;\n\n    }\n\n\n\n    if (qemu_isdigit(fdname[0])) {\n\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"fdname\",\n\n                      \"a name not starting with a digit\");\n\n        return -1;\n\n    }\n\n\n\n    fd = dup(fd);\n\n    if (fd == -1) {\n\n        if (errno == EMFILE)\n\n            qerror_report(QERR_TOO_MANY_FILES);\n\n        else\n\n            qerror_report(QERR_UNDEFINED_ERROR);\n\n        return -1;\n\n    }\n\n\n\n    QLIST_FOREACH(monfd, &mon->fds, next) {\n\n        if (strcmp(monfd->name, fdname) != 0) {\n\n            continue;\n\n        }\n\n\n\n        close(monfd->fd);\n\n        monfd->fd = fd;\n\n        return 0;\n\n    }\n\n\n\n    monfd = qemu_mallocz(sizeof(mon_fd_t));\n\n    monfd->name = qemu_strdup(fdname);\n\n    monfd->fd = fd;\n\n\n\n    QLIST_INSERT_HEAD(&mon->fds, monfd, next);\n\n    return 0;\n\n}\n", "idx": 18290, "_split": "valid", "_hash": "835c360624c258f6d7832e3605563298"}
{"project": "qemu", "commit_id": "8fd2a2f1a9048b9e37a898c2a5e9ef59d0c1a095", "target": 1, "func": "static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    VirtIONet *n = opaque;\n\n\n\n    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)\n\n        return -EINVAL;\n\n\n\n    virtio_load(&n->vdev, f);\n\n\n\n    qemu_get_buffer(f, n->mac, ETH_ALEN);\n\n    n->tx_timer_active = qemu_get_be32(f);\n\n    n->mergeable_rx_bufs = qemu_get_be32(f);\n\n\n\n    if (version_id >= 3)\n\n        n->status = qemu_get_be16(f);\n\n\n\n    if (version_id >= 4) {\n\n        if (version_id < 8) {\n\n            n->promisc = qemu_get_be32(f);\n\n            n->allmulti = qemu_get_be32(f);\n\n        } else {\n\n            n->promisc = qemu_get_byte(f);\n\n            n->allmulti = qemu_get_byte(f);\n\n        }\n\n    }\n\n\n\n    if (version_id >= 5) {\n\n        n->mac_table.in_use = qemu_get_be32(f);\n\n        /* MAC_TABLE_ENTRIES may be different from the saved image */\n\n        if (n->mac_table.in_use <= MAC_TABLE_ENTRIES) {\n\n            qemu_get_buffer(f, n->mac_table.macs,\n\n                            n->mac_table.in_use * ETH_ALEN);\n\n        } else if (n->mac_table.in_use) {\n\n            qemu_fseek(f, n->mac_table.in_use * ETH_ALEN, SEEK_CUR);\n\n            n->promisc = 1;\n\n            n->mac_table.in_use = 0;\n\n        }\n\n    }\n\n \n\n    if (version_id >= 6)\n\n        qemu_get_buffer(f, (uint8_t *)n->vlans, MAX_VLAN >> 3);\n\n\n\n    if (version_id >= 7 && qemu_get_be32(f)) {\n\n        fprintf(stderr,\n\n                \"virtio-net: saved image requires vnet header support\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    if (n->tx_timer_active) {\n\n        qemu_mod_timer(n->tx_timer,\n\n                       qemu_get_clock(vm_clock) + TX_TIMER_INTERVAL);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 18298, "_split": "valid", "_hash": "934a8e28877d925c830e2c90414ad391"}
{"project": "qemu", "commit_id": "8139626643cbe8dc07bd9acc88057effeedf8064", "target": 1, "func": "uint32_t lm4549_write_samples(lm4549_state *s, uint32_t left, uint32_t right)\n\n{\n\n    /* The left and right samples are in 20-bit resolution.\n\n       The LM4549 has 18-bit resolution and only uses the bits [19:2].\n\n       This model supports 16-bit playback.\n\n    */\n\n\n\n    if (s->buffer_level >= LM4549_BUFFER_SIZE) {\n\n        DPRINTF(\"write_sample Buffer full\\n\");\n\n        return 0;\n\n    }\n\n\n\n    /* Store 16-bit samples in the buffer */\n\n    s->buffer[s->buffer_level++] = (left >> 4);\n\n    s->buffer[s->buffer_level++] = (right >> 4);\n\n\n\n    if (s->buffer_level == LM4549_BUFFER_SIZE) {\n\n        /* Trigger the transfer of the buffer to the audio host */\n\n        lm4549_audio_transfer(s);\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 18300, "_split": "valid", "_hash": "2f44375c9862f81f52bbd0b90fba1b45"}
{"project": "qemu", "commit_id": "f293709c6af7a65a9bcec09cdba7a60183657a3e", "target": 1, "func": "static inline void code_gen_alloc(size_t tb_size)\n\n{\n\n    tcg_ctx.code_gen_buffer_size = size_code_gen_buffer(tb_size);\n\n    tcg_ctx.code_gen_buffer = alloc_code_gen_buffer();\n\n    if (tcg_ctx.code_gen_buffer == NULL) {\n\n        fprintf(stderr, \"Could not allocate dynamic translator buffer\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    qemu_madvise(tcg_ctx.code_gen_buffer, tcg_ctx.code_gen_buffer_size,\n\n                 QEMU_MADV_HUGEPAGE);\n\n\n\n    /* Estimate a good size for the number of TBs we can support.  We\n\n       still haven't deducted the prologue from the buffer size here,\n\n       but that's minimal and won't affect the estimate much.  */\n\n    tcg_ctx.code_gen_max_blocks\n\n        = tcg_ctx.code_gen_buffer_size / CODE_GEN_AVG_BLOCK_SIZE;\n\n    tcg_ctx.tb_ctx.tbs = g_new(TranslationBlock, tcg_ctx.code_gen_max_blocks);\n\n\n\n    qemu_mutex_init(&tcg_ctx.tb_ctx.tb_lock);\n\n}\n", "idx": 18320, "_split": "valid", "_hash": "4f5a3642c7c39f3df47e8bec41e72ea6"}
{"project": "qemu", "commit_id": "e5d1fca0f20babbe355957b9ba536fe6187691cc", "target": 1, "func": "int net_init_socket(QemuOpts *opts,\n\n                    Monitor *mon,\n\n                    const char *name,\n\n                    VLANState *vlan)\n\n{\n\n    if (qemu_opt_get(opts, \"fd\")) {\n\n        int fd;\n\n\n\n        if (qemu_opt_get(opts, \"listen\") ||\n\n            qemu_opt_get(opts, \"connect\") ||\n\n            qemu_opt_get(opts, \"mcast\") ||\n\n            qemu_opt_get(opts, \"localaddr\")) {\n\n            error_report(\"listen=, connect=, mcast= and localaddr= is invalid with fd=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = net_handle_fd_param(mon, qemu_opt_get(opts, \"fd\"));\n\n        if (fd == -1) {\n\n            return -1;\n\n        }\n\n\n\n        if (!net_socket_fd_init(vlan, \"socket\", name, fd, 1)) {\n\n            close(fd);\n\n            return -1;\n\n        }\n\n    } else if (qemu_opt_get(opts, \"listen\")) {\n\n        const char *listen;\n\n\n\n        if (qemu_opt_get(opts, \"fd\") ||\n\n            qemu_opt_get(opts, \"connect\") ||\n\n            qemu_opt_get(opts, \"mcast\") ||\n\n            qemu_opt_get(opts, \"localaddr\")) {\n\n            error_report(\"fd=, connect=, mcast= and localaddr= is invalid with listen=\");\n\n            return -1;\n\n        }\n\n\n\n        listen = qemu_opt_get(opts, \"listen\");\n\n\n\n        if (net_socket_listen_init(vlan, \"socket\", name, listen) == -1) {\n\n            return -1;\n\n        }\n\n    } else if (qemu_opt_get(opts, \"connect\")) {\n\n        const char *connect;\n\n\n\n        if (qemu_opt_get(opts, \"fd\") ||\n\n            qemu_opt_get(opts, \"listen\") ||\n\n            qemu_opt_get(opts, \"mcast\") ||\n\n            qemu_opt_get(opts, \"localaddr\")) {\n\n            error_report(\"fd=, listen=, mcast= and localaddr= is invalid with connect=\");\n\n            return -1;\n\n        }\n\n\n\n        connect = qemu_opt_get(opts, \"connect\");\n\n\n\n        if (net_socket_connect_init(vlan, \"socket\", name, connect) == -1) {\n\n            return -1;\n\n        }\n\n    } else if (qemu_opt_get(opts, \"mcast\")) {\n\n        const char *mcast, *localaddr;\n\n\n\n        if (qemu_opt_get(opts, \"fd\") ||\n\n            qemu_opt_get(opts, \"connect\") ||\n\n            qemu_opt_get(opts, \"listen\")) {\n\n            error_report(\"fd=, connect= and listen= is invalid with mcast=\");\n\n            return -1;\n\n        }\n\n\n\n        mcast = qemu_opt_get(opts, \"mcast\");\n\n        localaddr = qemu_opt_get(opts, \"localaddr\");\n\n\n\n        if (net_socket_mcast_init(vlan, \"socket\", name, mcast, localaddr) == -1) {\n\n            return -1;\n\n        }\n\n    } else {\n\n        error_report(\"-socket requires fd=, listen=, connect= or mcast=\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 18328, "_split": "valid", "_hash": "1a2934c06d43996260bb6e98c0e5a92c"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "QEMUTimerList *qemu_clock_get_main_loop_timerlist(QEMUClockType type)\n\n{\n\n    return main_loop_tlg.tl[type];\n\n}\n", "idx": 18342, "_split": "valid", "_hash": "6037c90b22f3bce80ce7bab6565572ab"}
{"project": "qemu", "commit_id": "1945dbc15f0f1ffdc9a10526448e9eba7c599d98", "target": 0, "func": "static void openpic_update_irq(openpic_t *opp, int n_IRQ)\n\n{\n\n    IRQ_src_t *src;\n\n    int i;\n\n\n\n    src = &opp->src[n_IRQ];\n\n\n\n    if (!src->pending) {\n\n        /* no irq pending */\n\n        DPRINTF(\"%s: IRQ %d is not pending\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (test_bit(&src->ipvp, IPVP_MASK)) {\n\n        /* Interrupt source is disabled */\n\n        DPRINTF(\"%s: IRQ %d is disabled\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (IPVP_PRIORITY(src->ipvp) == 0) {\n\n        /* Priority set to zero */\n\n        DPRINTF(\"%s: IRQ %d has 0 priority\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (test_bit(&src->ipvp, IPVP_ACTIVITY)) {\n\n        /* IRQ already active */\n\n        DPRINTF(\"%s: IRQ %d is already active\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ide == 0x00000000) {\n\n        /* No target */\n\n        DPRINTF(\"%s: IRQ %d has no target\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n\n\n    if (src->ide == (1 << src->last_cpu)) {\n\n        /* Only one CPU is allowed to receive this IRQ */\n\n        IRQ_local_pipe(opp, src->last_cpu, n_IRQ);\n\n    } else if (!test_bit(&src->ipvp, IPVP_MODE)) {\n\n        /* Directed delivery mode */\n\n        for (i = 0; i < opp->nb_cpus; i++) {\n\n            if (test_bit(&src->ide, i))\n\n                IRQ_local_pipe(opp, i, n_IRQ);\n\n        }\n\n    } else {\n\n        /* Distributed delivery mode */\n\n        for (i = src->last_cpu + 1; i != src->last_cpu; i++) {\n\n            if (i == opp->nb_cpus)\n\n                i = 0;\n\n            if (test_bit(&src->ide, i)) {\n\n                IRQ_local_pipe(opp, i, n_IRQ);\n\n                src->last_cpu = i;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 18347, "_split": "valid", "_hash": "63042dd012e0830c842f42c5da9e96f2"}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void kqemu_reset_modified_ram_pages(void)\n\n{\n\n    int i;\n\n    unsigned long page_index;\n\n\n\n    for(i = 0; i < nb_modified_ram_pages; i++) {\n\n        page_index = modified_ram_pages[i] >> TARGET_PAGE_BITS;\n\n        modified_ram_pages_table[page_index] = 0;\n\n    }\n\n    nb_modified_ram_pages = 0;\n\n}\n", "idx": 18349, "_split": "valid", "_hash": "c094bf7d4aaea2420261f7b7d26ada41"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void cirrus_mmio_write(void *opaque, target_phys_addr_t addr,\n\n                              uint64_t val, unsigned size)\n\n{\n\n    CirrusVGAState *s = opaque;\n\n\n\n    if (addr >= 0x100) {\n\n\tcirrus_mmio_blt_write(s, addr - 0x100, val);\n\n    } else {\n\n        cirrus_vga_ioport_write(s, addr + 0x3c0, val);\n\n    }\n\n}\n", "idx": 18353, "_split": "valid", "_hash": "ff8e61815d62a5634f33f4a6ff7ea59a"}
{"project": "qemu", "commit_id": "503006983a19be0b481946afac2cab0bdd21f124", "target": 0, "func": "void register_cp_regs_for_features(ARMCPU *cpu)\n\n{\n\n    /* Register all the coprocessor registers based on feature bits */\n\n    CPUARMState *env = &cpu->env;\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        /* M profile has no coprocessor registers */\n\n        return;\n\n    }\n\n\n\n    define_arm_cp_regs(cpu, cp_reginfo);\n\n    if (!arm_feature(env, ARM_FEATURE_V8)) {\n\n        /* Must go early as it is full of wildcards that may be\n\n         * overridden by later definitions.\n\n         */\n\n        define_arm_cp_regs(cpu, not_v8_cp_reginfo);\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_V6)) {\n\n        /* The ID registers all have impdef reset values */\n\n        ARMCPRegInfo v6_idregs[] = {\n\n            { .name = \"ID_PFR0\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_pfr0 },\n\n            { .name = \"ID_PFR1\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_pfr1 },\n\n            { .name = \"ID_DFR0\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 2,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_dfr0 },\n\n            { .name = \"ID_AFR0\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 3,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_afr0 },\n\n            { .name = \"ID_MMFR0\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 4,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_mmfr0 },\n\n            { .name = \"ID_MMFR1\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 5,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_mmfr1 },\n\n            { .name = \"ID_MMFR2\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 6,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_mmfr2 },\n\n            { .name = \"ID_MMFR3\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 7,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_mmfr3 },\n\n            { .name = \"ID_ISAR0\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_isar0 },\n\n            { .name = \"ID_ISAR1\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_isar1 },\n\n            { .name = \"ID_ISAR2\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 2,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_isar2 },\n\n            { .name = \"ID_ISAR3\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 3,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_isar3 },\n\n            { .name = \"ID_ISAR4\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 4,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_isar4 },\n\n            { .name = \"ID_ISAR5\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 5,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_isar5 },\n\n            /* 6..7 are as yet unallocated and must RAZ */\n\n            { .name = \"ID_ISAR6\", .cp = 15, .crn = 0, .crm = 2,\n\n              .opc1 = 0, .opc2 = 6, .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_ISAR7\", .cp = 15, .crn = 0, .crm = 2,\n\n              .opc1 = 0, .opc2 = 7, .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            REGINFO_SENTINEL\n\n        };\n\n        define_arm_cp_regs(cpu, v6_idregs);\n\n        define_arm_cp_regs(cpu, v6_cp_reginfo);\n\n    } else {\n\n        define_arm_cp_regs(cpu, not_v6_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V6K)) {\n\n        define_arm_cp_regs(cpu, v6k_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V7)) {\n\n        /* v7 performance monitor control register: same implementor\n\n         * field as main ID register, and we implement only the cycle\n\n         * count register.\n\n         */\n\n#ifndef CONFIG_USER_ONLY\n\n        ARMCPRegInfo pmcr = {\n\n            .name = \"PMCR\", .cp = 15, .crn = 9, .crm = 12, .opc1 = 0, .opc2 = 0,\n\n            .access = PL0_RW, .resetvalue = cpu->midr & 0xff000000,\n\n            .type = ARM_CP_IO,\n\n            .fieldoffset = offsetof(CPUARMState, cp15.c9_pmcr),\n\n            .accessfn = pmreg_access, .writefn = pmcr_write,\n\n            .raw_writefn = raw_write,\n\n        };\n\n        define_one_arm_cp_reg(cpu, &pmcr);\n\n#endif\n\n        ARMCPRegInfo clidr = {\n\n            .name = \"CLIDR\", .state = ARM_CP_STATE_BOTH,\n\n            .opc0 = 3, .crn = 0, .crm = 0, .opc1 = 1, .opc2 = 1,\n\n            .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = cpu->clidr\n\n        };\n\n        define_one_arm_cp_reg(cpu, &clidr);\n\n        define_arm_cp_regs(cpu, v7_cp_reginfo);\n\n    } else {\n\n        define_arm_cp_regs(cpu, not_v7_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V8)) {\n\n        /* AArch64 ID registers, which all have impdef reset values */\n\n        ARMCPRegInfo v8_idregs[] = {\n\n            { .name = \"ID_AA64PFR0_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 4, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64pfr0 },\n\n            { .name = \"ID_AA64PFR1_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 4, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64pfr1},\n\n            { .name = \"ID_AA64DFR0_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              /* We mask out the PMUVer field, because we don't currently\n\n               * implement the PMU. Not advertising it prevents the guest\n\n               * from trying to use it and getting UNDEFs on registers we\n\n               * don't implement.\n\n               */\n\n              .resetvalue = cpu->id_aa64dfr0 & ~0xf00 },\n\n            { .name = \"ID_AA64DFR1_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64dfr1 },\n\n            { .name = \"ID_AA64AFR0_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 4,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64afr0 },\n\n            { .name = \"ID_AA64AFR1_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 5,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64afr1 },\n\n            { .name = \"ID_AA64ISAR0_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 6, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64isar0 },\n\n            { .name = \"ID_AA64ISAR1_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 6, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64isar1 },\n\n            { .name = \"ID_AA64MMFR0_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64mmfr0 },\n\n            { .name = \"ID_AA64MMFR1_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64mmfr1 },\n\n            { .name = \"MVFR0_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->mvfr0 },\n\n            { .name = \"MVFR1_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->mvfr1 },\n\n            { .name = \"MVFR2_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 2,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->mvfr2 },\n\n            REGINFO_SENTINEL\n\n        };\n\n        ARMCPRegInfo rvbar = {\n\n            .name = \"RVBAR_EL1\", .state = ARM_CP_STATE_AA64,\n\n            .opc0 = 3, .opc1 = 0, .crn = 12, .crm = 0, .opc2 = 2,\n\n            .type = ARM_CP_CONST, .access = PL1_R, .resetvalue = cpu->rvbar\n\n        };\n\n        define_one_arm_cp_reg(cpu, &rvbar);\n\n        define_arm_cp_regs(cpu, v8_idregs);\n\n        define_arm_cp_regs(cpu, v8_cp_reginfo);\n\n        define_aarch64_debug_regs(cpu);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_EL2)) {\n\n        define_arm_cp_regs(cpu, v8_el2_cp_reginfo);\n\n    } else {\n\n        /* If EL2 is missing but higher ELs are enabled, we need to\n\n         * register the no_el2 reginfos.\n\n         */\n\n        if (arm_feature(env, ARM_FEATURE_EL3)) {\n\n            define_arm_cp_regs(cpu, v8_el3_no_el2_cp_reginfo);\n\n        }\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_EL3)) {\n\n        define_arm_cp_regs(cpu, v8_el3_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_MPU)) {\n\n        /* These are the MPU registers prior to PMSAv6. Any new\n\n         * PMSA core later than the ARM946 will require that we\n\n         * implement the PMSAv6 or PMSAv7 registers, which are\n\n         * completely different.\n\n         */\n\n        assert(!arm_feature(env, ARM_FEATURE_V6));\n\n        define_arm_cp_regs(cpu, pmsav5_cp_reginfo);\n\n    } else {\n\n        define_arm_cp_regs(cpu, vmsa_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_THUMB2EE)) {\n\n        define_arm_cp_regs(cpu, t2ee_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_GENERIC_TIMER)) {\n\n        define_arm_cp_regs(cpu, generic_timer_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_VAPA)) {\n\n        define_arm_cp_regs(cpu, vapa_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_CACHE_TEST_CLEAN)) {\n\n        define_arm_cp_regs(cpu, cache_test_clean_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_CACHE_DIRTY_REG)) {\n\n        define_arm_cp_regs(cpu, cache_dirty_status_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_CACHE_BLOCK_OPS)) {\n\n        define_arm_cp_regs(cpu, cache_block_ops_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_OMAPCP)) {\n\n        define_arm_cp_regs(cpu, omap_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_STRONGARM)) {\n\n        define_arm_cp_regs(cpu, strongarm_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_XSCALE)) {\n\n        define_arm_cp_regs(cpu, xscale_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_DUMMY_C15_REGS)) {\n\n        define_arm_cp_regs(cpu, dummy_c15_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_LPAE)) {\n\n        define_arm_cp_regs(cpu, lpae_cp_reginfo);\n\n    }\n\n    /* Slightly awkwardly, the OMAP and StrongARM cores need all of\n\n     * cp15 crn=0 to be writes-ignored, whereas for other cores they should\n\n     * be read-only (ie write causes UNDEF exception).\n\n     */\n\n    {\n\n        ARMCPRegInfo id_pre_v8_midr_cp_reginfo[] = {\n\n            /* Pre-v8 MIDR space.\n\n             * Note that the MIDR isn't a simple constant register because\n\n             * of the TI925 behaviour where writes to another register can\n\n             * cause the MIDR value to change.\n\n             *\n\n             * Unimplemented registers in the c15 0 0 0 space default to\n\n             * MIDR. Define MIDR first as this entire space, then CTR, TCMTR\n\n             * and friends override accordingly.\n\n             */\n\n            { .name = \"MIDR\",\n\n              .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = CP_ANY,\n\n              .access = PL1_R, .resetvalue = cpu->midr,\n\n              .writefn = arm_cp_write_ignore, .raw_writefn = raw_write,\n\n              .fieldoffset = offsetof(CPUARMState, cp15.c0_cpuid),\n\n              .type = ARM_CP_OVERRIDE },\n\n            /* crn = 0 op1 = 0 crm = 3..7 : currently unassigned; we RAZ. */\n\n            { .name = \"DUMMY\",\n\n              .cp = 15, .crn = 0, .crm = 3, .opc1 = 0, .opc2 = CP_ANY,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },\n\n            { .name = \"DUMMY\",\n\n              .cp = 15, .crn = 0, .crm = 4, .opc1 = 0, .opc2 = CP_ANY,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },\n\n            { .name = \"DUMMY\",\n\n              .cp = 15, .crn = 0, .crm = 5, .opc1 = 0, .opc2 = CP_ANY,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },\n\n            { .name = \"DUMMY\",\n\n              .cp = 15, .crn = 0, .crm = 6, .opc1 = 0, .opc2 = CP_ANY,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },\n\n            { .name = \"DUMMY\",\n\n              .cp = 15, .crn = 0, .crm = 7, .opc1 = 0, .opc2 = CP_ANY,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },\n\n            REGINFO_SENTINEL\n\n        };\n\n        ARMCPRegInfo id_v8_midr_cp_reginfo[] = {\n\n            /* v8 MIDR -- the wildcard isn't necessary, and nor is the\n\n             * variable-MIDR TI925 behaviour. Instead we have a single\n\n             * (strictly speaking IMPDEF) alias of the MIDR, REVIDR.\n\n             */\n\n            { .name = \"MIDR_EL1\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 0, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = cpu->midr },\n\n            { .name = \"REVIDR_EL1\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 0, .opc2 = 6,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = cpu->midr },\n\n            REGINFO_SENTINEL\n\n        };\n\n        ARMCPRegInfo id_cp_reginfo[] = {\n\n            /* These are common to v8 and pre-v8 */\n\n            { .name = \"CTR\",\n\n              .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = cpu->ctr },\n\n            { .name = \"CTR_EL0\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 3, .opc2 = 1, .crn = 0, .crm = 0,\n\n              .access = PL0_R, .accessfn = ctr_el0_access,\n\n              .type = ARM_CP_CONST, .resetvalue = cpu->ctr },\n\n            /* TCMTR and TLBTR exist in v8 but have no 64-bit versions */\n\n            { .name = \"TCMTR\",\n\n              .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 2,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },\n\n            { .name = \"TLBTR\",\n\n              .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 3,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },\n\n            REGINFO_SENTINEL\n\n        };\n\n        ARMCPRegInfo crn0_wi_reginfo = {\n\n            .name = \"CRN0_WI\", .cp = 15, .crn = 0, .crm = CP_ANY,\n\n            .opc1 = CP_ANY, .opc2 = CP_ANY, .access = PL1_W,\n\n            .type = ARM_CP_NOP | ARM_CP_OVERRIDE\n\n        };\n\n        if (arm_feature(env, ARM_FEATURE_OMAPCP) ||\n\n            arm_feature(env, ARM_FEATURE_STRONGARM)) {\n\n            ARMCPRegInfo *r;\n\n            /* Register the blanket \"writes ignored\" value first to cover the\n\n             * whole space. Then update the specific ID registers to allow write\n\n             * access, so that they ignore writes rather than causing them to\n\n             * UNDEF.\n\n             */\n\n            define_one_arm_cp_reg(cpu, &crn0_wi_reginfo);\n\n            for (r = id_pre_v8_midr_cp_reginfo;\n\n                 r->type != ARM_CP_SENTINEL; r++) {\n\n                r->access = PL1_RW;\n\n            }\n\n            for (r = id_cp_reginfo; r->type != ARM_CP_SENTINEL; r++) {\n\n                r->access = PL1_RW;\n\n            }\n\n        }\n\n        if (arm_feature(env, ARM_FEATURE_V8)) {\n\n            define_arm_cp_regs(cpu, id_v8_midr_cp_reginfo);\n\n        } else {\n\n            define_arm_cp_regs(cpu, id_pre_v8_midr_cp_reginfo);\n\n        }\n\n        define_arm_cp_regs(cpu, id_cp_reginfo);\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_MPIDR)) {\n\n        define_arm_cp_regs(cpu, mpidr_cp_reginfo);\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_AUXCR)) {\n\n        ARMCPRegInfo auxcr = {\n\n            .name = \"ACTLR_EL1\", .state = ARM_CP_STATE_BOTH,\n\n            .opc0 = 3, .opc1 = 0, .crn = 1, .crm = 0, .opc2 = 1,\n\n            .access = PL1_RW, .type = ARM_CP_CONST,\n\n            .resetvalue = cpu->reset_auxcr\n\n        };\n\n        define_one_arm_cp_reg(cpu, &auxcr);\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_CBAR)) {\n\n        if (arm_feature(env, ARM_FEATURE_AARCH64)) {\n\n            /* 32 bit view is [31:18] 0...0 [43:32]. */\n\n            uint32_t cbar32 = (extract64(cpu->reset_cbar, 18, 14) << 18)\n\n                | extract64(cpu->reset_cbar, 32, 12);\n\n            ARMCPRegInfo cbar_reginfo[] = {\n\n                { .name = \"CBAR\",\n\n                  .type = ARM_CP_CONST,\n\n                  .cp = 15, .crn = 15, .crm = 0, .opc1 = 4, .opc2 = 0,\n\n                  .access = PL1_R, .resetvalue = cpu->reset_cbar },\n\n                { .name = \"CBAR_EL1\", .state = ARM_CP_STATE_AA64,\n\n                  .type = ARM_CP_CONST,\n\n                  .opc0 = 3, .opc1 = 1, .crn = 15, .crm = 3, .opc2 = 0,\n\n                  .access = PL1_R, .resetvalue = cbar32 },\n\n                REGINFO_SENTINEL\n\n            };\n\n            /* We don't implement a r/w 64 bit CBAR currently */\n\n            assert(arm_feature(env, ARM_FEATURE_CBAR_RO));\n\n            define_arm_cp_regs(cpu, cbar_reginfo);\n\n        } else {\n\n            ARMCPRegInfo cbar = {\n\n                .name = \"CBAR\",\n\n                .cp = 15, .crn = 15, .crm = 0, .opc1 = 4, .opc2 = 0,\n\n                .access = PL1_R|PL3_W, .resetvalue = cpu->reset_cbar,\n\n                .fieldoffset = offsetof(CPUARMState,\n\n                                        cp15.c15_config_base_address)\n\n            };\n\n            if (arm_feature(env, ARM_FEATURE_CBAR_RO)) {\n\n                cbar.access = PL1_R;\n\n                cbar.fieldoffset = 0;\n\n                cbar.type = ARM_CP_CONST;\n\n            }\n\n            define_one_arm_cp_reg(cpu, &cbar);\n\n        }\n\n    }\n\n\n\n    /* Generic registers whose values depend on the implementation */\n\n    {\n\n        ARMCPRegInfo sctlr = {\n\n            .name = \"SCTLR\", .state = ARM_CP_STATE_BOTH,\n\n            .opc0 = 3, .crn = 1, .crm = 0, .opc1 = 0, .opc2 = 0,\n\n            .access = PL1_RW, .fieldoffset = offsetof(CPUARMState, cp15.c1_sys),\n\n            .writefn = sctlr_write, .resetvalue = cpu->reset_sctlr,\n\n            .raw_writefn = raw_write,\n\n        };\n\n        if (arm_feature(env, ARM_FEATURE_XSCALE)) {\n\n            /* Normally we would always end the TB on an SCTLR write, but Linux\n\n             * arch/arm/mach-pxa/sleep.S expects two instructions following\n\n             * an MMU enable to execute from cache.  Imitate this behaviour.\n\n             */\n\n            sctlr.type |= ARM_CP_SUPPRESS_TB_END;\n\n        }\n\n        define_one_arm_cp_reg(cpu, &sctlr);\n\n    }\n\n}\n", "idx": 18356, "_split": "valid", "_hash": "e2c64ef2741e3542f1840caec605645f"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int megasas_pd_get_info_submit(SCSIDevice *sdev, int lun,\n\n                                      MegasasCmd *cmd)\n\n{\n\n    struct mfi_pd_info *info = cmd->iov_buf;\n\n    size_t dcmd_size = sizeof(struct mfi_pd_info);\n\n    BlockConf *conf = &sdev->conf;\n\n    uint64_t pd_size;\n\n    uint16_t sdev_id = ((sdev->id & 0xFF) >> 8) | (lun & 0xFF);\n\n    uint8_t cmdbuf[6];\n\n    SCSIRequest *req;\n\n    size_t len, resid;\n\n\n\n    if (!cmd->iov_buf) {\n\n        cmd->iov_buf = g_malloc(dcmd_size);\n\n        memset(cmd->iov_buf, 0, dcmd_size);\n\n        info = cmd->iov_buf;\n\n        info->inquiry_data[0] = 0x7f; /* Force PQual 0x3, PType 0x1f */\n\n        info->vpd_page83[0] = 0x7f;\n\n        megasas_setup_inquiry(cmdbuf, 0, sizeof(info->inquiry_data));\n\n        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);\n\n        if (!req) {\n\n            trace_megasas_dcmd_req_alloc_failed(cmd->index,\n\n                                                \"PD get info std inquiry\");\n\n            g_free(cmd->iov_buf);\n\n            cmd->iov_buf = NULL;\n\n            return MFI_STAT_FLASH_ALLOC_FAIL;\n\n        }\n\n        trace_megasas_dcmd_internal_submit(cmd->index,\n\n                                           \"PD get info std inquiry\", lun);\n\n        len = scsi_req_enqueue(req);\n\n        if (len > 0) {\n\n            cmd->iov_size = len;\n\n            scsi_req_continue(req);\n\n        }\n\n        return MFI_STAT_INVALID_STATUS;\n\n    } else if (info->inquiry_data[0] != 0x7f && info->vpd_page83[0] == 0x7f) {\n\n        megasas_setup_inquiry(cmdbuf, 0x83, sizeof(info->vpd_page83));\n\n        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);\n\n        if (!req) {\n\n            trace_megasas_dcmd_req_alloc_failed(cmd->index,\n\n                                                \"PD get info vpd inquiry\");\n\n            return MFI_STAT_FLASH_ALLOC_FAIL;\n\n        }\n\n        trace_megasas_dcmd_internal_submit(cmd->index,\n\n                                           \"PD get info vpd inquiry\", lun);\n\n        len = scsi_req_enqueue(req);\n\n        if (len > 0) {\n\n            cmd->iov_size = len;\n\n            scsi_req_continue(req);\n\n        }\n\n        return MFI_STAT_INVALID_STATUS;\n\n    }\n\n    /* Finished, set FW state */\n\n    if ((info->inquiry_data[0] >> 5) == 0) {\n\n        if (megasas_is_jbod(cmd->state)) {\n\n            info->fw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM);\n\n        } else {\n\n            info->fw_state = cpu_to_le16(MFI_PD_STATE_ONLINE);\n\n        }\n\n    } else {\n\n        info->fw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE);\n\n    }\n\n\n\n    info->ref.v.device_id = cpu_to_le16(sdev_id);\n\n    info->state.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD|\n\n                                          MFI_PD_DDF_TYPE_INTF_SAS);\n\n    bdrv_get_geometry(conf->bs, &pd_size);\n\n    info->raw_size = cpu_to_le64(pd_size);\n\n    info->non_coerced_size = cpu_to_le64(pd_size);\n\n    info->coerced_size = cpu_to_le64(pd_size);\n\n    info->encl_device_id = 0xFFFF;\n\n    info->slot_number = (sdev->id & 0xFF);\n\n    info->path_info.count = 1;\n\n    info->path_info.sas_addr[0] =\n\n        cpu_to_le64(megasas_get_sata_addr(sdev_id));\n\n    info->connected_port_bitmap = 0x1;\n\n    info->device_speed = 1;\n\n    info->link_speed = 1;\n\n    resid = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg);\n\n    g_free(cmd->iov_buf);\n\n    cmd->iov_size = dcmd_size - resid;\n\n    cmd->iov_buf = NULL;\n\n    return MFI_STAT_OK;\n\n}\n", "idx": 18361, "_split": "valid", "_hash": "3b50f45b1b7c2c3f2826d01afb535df2"}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void tcp_chr_close(CharDriverState *chr)\n\n{\n\n    TCPCharDriver *s = chr->opaque;\n\n    if (s->fd >= 0) {\n\n        if (s->tag) {\n\n            g_source_remove(s->tag);\n\n            s->tag = 0;\n\n        }\n\n        if (s->chan) {\n\n            g_io_channel_unref(s->chan);\n\n        }\n\n        closesocket(s->fd);\n\n    }\n\n    if (s->listen_fd >= 0) {\n\n        if (s->listen_tag) {\n\n            g_source_remove(s->listen_tag);\n\n            s->listen_tag = 0;\n\n        }\n\n        if (s->listen_chan) {\n\n            g_io_channel_unref(s->listen_chan);\n\n        }\n\n        closesocket(s->listen_fd);\n\n    }\n\n    g_free(s);\n\n    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);\n\n}\n", "idx": 18390, "_split": "valid", "_hash": "23a51d30b785dfca1dfad3923933c207"}
{"project": "qemu", "commit_id": "7e680753cfa2986e0a8b3b222b6bf0b003c5eb69", "target": 1, "func": "static int kvm_put_vcpu_events(CPUState *env, int level)\n\n{\n\n    struct kvm_vcpu_events events;\n\n\n\n    if (!kvm_has_vcpu_events()) {\n\n        return 0;\n\n    }\n\n\n\n    events.exception.injected = (env->exception_injected >= 0);\n\n    events.exception.nr = env->exception_injected;\n\n    events.exception.has_error_code = env->has_error_code;\n\n    events.exception.error_code = env->error_code;\n\n\n\n\n    events.interrupt.injected = (env->interrupt_injected >= 0);\n\n    events.interrupt.nr = env->interrupt_injected;\n\n    events.interrupt.soft = env->soft_interrupt;\n\n\n\n    events.nmi.injected = env->nmi_injected;\n\n    events.nmi.pending = env->nmi_pending;\n\n    events.nmi.masked = !!(env->hflags2 & HF2_NMI_MASK);\n\n    events.nmi.pad = 0;\n\n\n\n    events.sipi_vector = env->sipi_vector;\n\n\n\n    events.flags = 0;\n\n    if (level >= KVM_PUT_RESET_STATE) {\n\n        events.flags |=\n\n            KVM_VCPUEVENT_VALID_NMI_PENDING | KVM_VCPUEVENT_VALID_SIPI_VECTOR;\n\n    }\n\n\n\n    return kvm_vcpu_ioctl(env, KVM_SET_VCPU_EVENTS, &events);\n\n}", "idx": 18402, "_split": "valid", "_hash": "482ee810bef56154e69bfc2471f59bc3"}
{"project": "qemu", "commit_id": "db50f280cf5f714e64ff2b134aae138908f07502", "target": 1, "func": "static target_ulong h_resize_hpt_prepare(PowerPCCPU *cpu,\n\n                                         sPAPRMachineState *spapr,\n\n                                         target_ulong opcode,\n\n                                         target_ulong *args)\n\n{\n\n    target_ulong flags = args[0];\n\n    int shift = args[1];\n\n    sPAPRPendingHPT *pending = spapr->pending_hpt;\n\n    uint64_t current_ram_size = MACHINE(spapr)->ram_size;\n\n    int rc;\n\n\n\n    if (spapr->resize_hpt == SPAPR_RESIZE_HPT_DISABLED) {\n\n        return H_AUTHORITY;\n\n    }\n\n\n\n    if (!spapr->htab_shift) {\n\n        /* Radix guest, no HPT */\n\n        return H_NOT_AVAILABLE;\n\n    }\n\n\n\n    trace_spapr_h_resize_hpt_prepare(flags, shift);\n\n\n\n    if (flags != 0) {\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    if (shift && ((shift < 18) || (shift > 46))) {\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    current_ram_size = pc_existing_dimms_capacity(&error_fatal);\n\n\n\n    /* We only allow the guest to allocate an HPT one order above what\n\n     * we'd normally give them (to stop a small guest claiming a huge\n\n     * chunk of resources in the HPT */\n\n    if (shift > (spapr_hpt_shift_for_ramsize(current_ram_size) + 1)) {\n\n        return H_RESOURCE;\n\n    }\n\n\n\n    rc = kvmppc_resize_hpt_prepare(cpu, flags, shift);\n\n    if (rc != -ENOSYS) {\n\n        return resize_hpt_convert_rc(rc);\n\n    }\n\n\n\n    if (pending) {\n\n        /* something already in progress */\n\n        if (pending->shift == shift) {\n\n            /* and it's suitable */\n\n            if (pending->complete) {\n\n                return pending->ret;\n\n            } else {\n\n                return H_LONG_BUSY_ORDER_100_MSEC;\n\n            }\n\n        }\n\n\n\n        /* not suitable, cancel and replace */\n\n        cancel_hpt_prepare(spapr);\n\n    }\n\n\n\n    if (!shift) {\n\n        /* nothing to do */\n\n        return H_SUCCESS;\n\n    }\n\n\n\n    /* start new prepare */\n\n\n\n    pending = g_new0(sPAPRPendingHPT, 1);\n\n    pending->shift = shift;\n\n    pending->ret = H_HARDWARE;\n\n\n\n    qemu_thread_create(&pending->thread, \"sPAPR HPT prepare\",\n\n                       hpt_prepare_thread, pending, QEMU_THREAD_DETACHED);\n\n\n\n    spapr->pending_hpt = pending;\n\n\n\n    /* In theory we could estimate the time more accurately based on\n\n     * the new size, but there's not much point */\n\n    return H_LONG_BUSY_ORDER_100_MSEC;\n\n}\n", "idx": 18411, "_split": "valid", "_hash": "38156bcc7efe25d057ba619116b82874"}
{"project": "qemu", "commit_id": "12f8def0e02232d7c6416ad9b66640f973c531d1", "target": 1, "func": "void qemu_cond_signal(QemuCond *cond)\n\n{\n\n    DWORD result;\n\n\n\n    /*\n\n     * Signal only when there are waiters.  cond->waiters is\n\n     * incremented by pthread_cond_wait under the external lock,\n\n     * so we are safe about that.\n\n     */\n\n    if (cond->waiters == 0) {\n\n        return;\n\n    }\n\n\n\n    /*\n\n     * Waiting threads decrement it outside the external lock, but\n\n     * only if another thread is executing pthread_cond_broadcast and\n\n     * has the mutex.  So, it also cannot be decremented concurrently\n\n     * with this particular access.\n\n     */\n\n    cond->target = cond->waiters - 1;\n\n    result = SignalObjectAndWait(cond->sema, cond->continue_event,\n\n                                 INFINITE, FALSE);\n\n    if (result == WAIT_ABANDONED || result == WAIT_FAILED) {\n\n        error_exit(GetLastError(), __func__);\n\n    }\n\n}\n", "idx": 18413, "_split": "valid", "_hash": "d9b15674216773f1d5cef0617389f0d5"}
{"project": "qemu", "commit_id": "fd8cec932c2ddc687e2da954978954b46a926f90", "target": 1, "func": "int64_t xbzrle_cache_resize(int64_t new_size)\n\n{\n\n    if (new_size < TARGET_PAGE_SIZE) {\n\n        return -1;\n\n    }\n\n\n\n    if (XBZRLE.cache != NULL) {\n\n        return cache_resize(XBZRLE.cache, new_size / TARGET_PAGE_SIZE) *\n\n            TARGET_PAGE_SIZE;\n\n    }\n\n    return pow2floor(new_size);\n\n}\n", "idx": 18425, "_split": "valid", "_hash": "52ca6a3ca1fcd6fe1f860766a1fb52da"}
{"project": "qemu", "commit_id": "848696bf353750899832c51005f1bd3540da5c29", "target": 1, "func": "static void i82374_isa_realize(DeviceState *dev, Error **errp)\n\n{\n\n    ISAi82374State *isa = I82374(dev);\n\n    I82374State *s = &isa->state;\n\n    PortioList *port_list = g_new(PortioList, 1);\n\n\n\n    portio_list_init(port_list, OBJECT(isa), i82374_portio_list, s, \"i82374\");\n\n    portio_list_add(port_list, isa_address_space_io(&isa->parent_obj),\n\n                    isa->iobase);\n\n\n\n    i82374_realize(s, errp);\n\n\n\n    qdev_init_gpio_out(dev, &s->out, 1);\n\n}\n", "idx": 18481, "_split": "valid", "_hash": "0c197d08d24654a961c0290aea27ef4a"}
{"project": "qemu", "commit_id": "b5d3b039221f056befb3715471fee1f68214815c", "target": 1, "func": "uint64_t pc_dimm_get_free_addr(uint64_t address_space_start,\n\n                               uint64_t address_space_size,\n\n                               uint64_t *hint, uint64_t align, uint64_t size,\n\n                               Error **errp)\n\n{\n\n    GSList *list = NULL, *item;\n\n    uint64_t new_addr, ret = 0;\n\n    uint64_t address_space_end = address_space_start + address_space_size;\n\n\n\n    g_assert(QEMU_ALIGN_UP(address_space_start, align) == address_space_start);\n\n    g_assert(QEMU_ALIGN_UP(address_space_size, align) == address_space_size);\n\n\n\n    if (!address_space_size) {\n\n        error_setg(errp, \"memory hotplug is not enabled, \"\n\n                         \"please add maxmem option\");\n\n        goto out;\n\n    }\n\n\n\n    if (hint && QEMU_ALIGN_UP(*hint, align) != *hint) {\n\n        error_setg(errp, \"address must be aligned to 0x%\" PRIx64 \" bytes\",\n\n                   align);\n\n        goto out;\n\n    }\n\n\n\n    if (QEMU_ALIGN_UP(size, align) != size) {\n\n        error_setg(errp, \"backend memory size must be multiple of 0x%\"\n\n                   PRIx64, align);\n\n        goto out;\n\n    }\n\n\n\n    assert(address_space_end > address_space_start);\n\n    object_child_foreach(qdev_get_machine(), pc_dimm_built_list, &list);\n\n\n\n    if (hint) {\n\n        new_addr = *hint;\n\n    } else {\n\n        new_addr = address_space_start;\n\n    }\n\n\n\n    /* find address range that will fit new DIMM */\n\n    for (item = list; item; item = g_slist_next(item)) {\n\n        PCDIMMDevice *dimm = item->data;\n\n        uint64_t dimm_size = object_property_get_int(OBJECT(dimm),\n\n                                                     PC_DIMM_SIZE_PROP,\n\n                                                     errp);\n\n        if (errp && *errp) {\n\n            goto out;\n\n        }\n\n\n\n        if (ranges_overlap(dimm->addr, dimm_size, new_addr, size)) {\n\n            if (hint) {\n\n                DeviceState *d = DEVICE(dimm);\n\n                error_setg(errp, \"address range conflicts with '%s'\", d->id);\n\n                goto out;\n\n            }\n\n            new_addr = QEMU_ALIGN_UP(dimm->addr + dimm_size, align);\n\n        }\n\n    }\n\n    ret = new_addr;\n\n\n\n    if (new_addr < address_space_start) {\n\n        error_setg(errp, \"can't add memory [0x%\" PRIx64 \":0x%\" PRIx64\n\n                   \"] at 0x%\" PRIx64, new_addr, size, address_space_start);\n\n    } else if ((new_addr + size) > address_space_end) {\n\n        error_setg(errp, \"can't add memory [0x%\" PRIx64 \":0x%\" PRIx64\n\n                   \"] beyond 0x%\" PRIx64, new_addr, size, address_space_end);\n\n    }\n\n\n\nout:\n\n    g_slist_free(list);\n\n    return ret;\n\n}\n", "idx": 18488, "_split": "valid", "_hash": "a339bd09f495b97031c34ca12afe6259"}
{"project": "qemu", "commit_id": "326b9e98a391d542cc33c4c91782ff4ba51edfc5", "target": 1, "func": "floatx80 floatx80_scalbn( floatx80 a, int n STATUS_PARAM )\n\n{\n\n    flag aSign;\n\n    int16 aExp;\n\n    uint64_t aSig;\n\n\n\n    aSig = extractFloatx80Frac( a );\n\n    aExp = extractFloatx80Exp( a );\n\n    aSign = extractFloatx80Sign( a );\n\n\n\n    if ( aExp == 0x7FF ) {\n\n        return a;\n\n    }\n\n    if (aExp == 0 && aSig == 0)\n\n        return a;\n\n\n\n    aExp += n;\n\n    return normalizeRoundAndPackFloatx80( STATUS(floatx80_rounding_precision),\n\n                                          aSign, aExp, aSig, 0 STATUS_VAR );\n\n}\n", "idx": 18497, "_split": "valid", "_hash": "f65ab9c28ddf94622bee595684bb8e58"}
{"project": "qemu", "commit_id": "8827b0fb66cab9f7978c4e66dad4cf3c0989a72e", "target": 1, "func": "static void pl181_send_command(pl181_state *s)\n\n{\n\n    SDRequest request;\n\n    uint8_t response[16];\n\n    int rlen;\n\n\n\n    request.cmd = s->cmd & PL181_CMD_INDEX;\n\n    request.arg = s->cmdarg;\n\n    DPRINTF(\"Command %d %08x\\n\", request.cmd, request.arg);\n\n    rlen = sd_do_command(s->card, &request, response);\n\n    if (rlen < 0)\n\n        goto error;\n\n    if (s->cmd & PL181_CMD_RESPONSE) {\n\n#define RWORD(n) ((response[n] << 24) | (response[n + 1] << 16) \\\n\n                  | (response[n + 2] << 8) | response[n + 3])\n\n        if (rlen == 0 || (rlen == 4 && (s->cmd & PL181_CMD_LONGRESP)))\n\n            goto error;\n\n        if (rlen != 4 && rlen != 16)\n\n            goto error;\n\n        s->response[0] = RWORD(0);\n\n        if (rlen == 4) {\n\n            s->response[1] = s->response[2] = s->response[3] = 0;\n\n        } else {\n\n            s->response[1] = RWORD(4);\n\n            s->response[2] = RWORD(8);\n\n            s->response[3] = RWORD(12) & ~1;\n\n        }\n\n        DPRINTF(\"Response received\\n\");\n\n        s->status |= PL181_STATUS_CMDRESPEND;\n\n#undef RWORD\n\n    } else {\n\n        DPRINTF(\"Command sent\\n\");\n\n        s->status |= PL181_STATUS_CMDSENT;\n\n    }\n\n    return;\n\n\n\nerror:\n\n    DPRINTF(\"Timeout\\n\");\n\n    s->status |= PL181_STATUS_CMDTIMEOUT;\n\n}\n", "idx": 18528, "_split": "valid", "_hash": "f4ad13b30c6a9fe397f38423fe692423"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void ram_control_load_hook(QEMUFile *f, uint64_t flags)\n\n{\n\n    int ret = -EINVAL;\n\n\n\n    if (f->ops->hook_ram_load) {\n\n        ret = f->ops->hook_ram_load(f, f->opaque, flags);\n\n        if (ret < 0) {\n\n            qemu_file_set_error(f, ret);\n\n        }\n\n    } else {\n\n        qemu_file_set_error(f, ret);\n\n    }\n\n}\n", "idx": 18557, "_split": "valid", "_hash": "30c17d974c53085a2506909c1e130b37"}
{"project": "qemu", "commit_id": "dd63169766abd2b8dc33f4451dac5e778458a47c", "target": 1, "func": "static void migration_bitmap_sync(void)\n\n{\n\n    RAMBlock *block;\n\n    uint64_t num_dirty_pages_init = migration_dirty_pages;\n\n    MigrationState *s = migrate_get_current();\n\n    int64_t end_time;\n\n    int64_t bytes_xfer_now;\n\n\n\n    bitmap_sync_count++;\n\n\n\n    if (!bytes_xfer_prev) {\n\n        bytes_xfer_prev = ram_bytes_transferred();\n\n    }\n\n\n\n    if (!start_time) {\n\n        start_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n    }\n\n\n\n    trace_migration_bitmap_sync_start();\n\n    address_space_sync_dirty_bitmap(&address_space_memory);\n\n\n\n\n    rcu_read_lock();\n\n    QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n\n        migration_bitmap_sync_range(block->mr->ram_addr, block->used_length);\n\n    }\n\n    rcu_read_unlock();\n\n\n\n\n    trace_migration_bitmap_sync_end(migration_dirty_pages\n\n                                    - num_dirty_pages_init);\n\n    num_dirty_pages_period += migration_dirty_pages - num_dirty_pages_init;\n\n    end_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n\n\n    /* more than 1 second = 1000 millisecons */\n\n    if (end_time > start_time + 1000) {\n\n        if (migrate_auto_converge()) {\n\n            /* The following detection logic can be refined later. For now:\n\n               Check to see if the dirtied bytes is 50% more than the approx.\n\n               amount of bytes that just got transferred since the last time we\n\n               were in this routine. If that happens >N times (for now N==4)\n\n               we turn on the throttle down logic */\n\n            bytes_xfer_now = ram_bytes_transferred();\n\n            if (s->dirty_pages_rate &&\n\n               (num_dirty_pages_period * TARGET_PAGE_SIZE >\n\n                   (bytes_xfer_now - bytes_xfer_prev)/2) &&\n\n               (dirty_rate_high_cnt++ > 4)) {\n\n                    trace_migration_throttle();\n\n                    mig_throttle_on = true;\n\n                    dirty_rate_high_cnt = 0;\n\n             }\n\n             bytes_xfer_prev = bytes_xfer_now;\n\n        } else {\n\n             mig_throttle_on = false;\n\n        }\n\n        if (migrate_use_xbzrle()) {\n\n            if (iterations_prev != acct_info.iterations) {\n\n                acct_info.xbzrle_cache_miss_rate =\n\n                   (double)(acct_info.xbzrle_cache_miss -\n\n                            xbzrle_cache_miss_prev) /\n\n                   (acct_info.iterations - iterations_prev);\n\n            }\n\n            iterations_prev = acct_info.iterations;\n\n            xbzrle_cache_miss_prev = acct_info.xbzrle_cache_miss;\n\n        }\n\n        s->dirty_pages_rate = num_dirty_pages_period * 1000\n\n            / (end_time - start_time);\n\n        s->dirty_bytes_rate = s->dirty_pages_rate * TARGET_PAGE_SIZE;\n\n        start_time = end_time;\n\n        num_dirty_pages_period = 0;\n\n    }\n\n    s->dirty_sync_count = bitmap_sync_count;\n\n}", "idx": 18561, "_split": "valid", "_hash": "f5af0edfd45fa92dd1e54761b67885bf"}
{"project": "qemu", "commit_id": "97e89ee914411384dcda771d38bf89f13726d71e", "target": 1, "func": "static void gen_window_check3(DisasContext *dc, unsigned r1, unsigned r2,\n\n        unsigned r3)\n\n{\n\n    gen_window_check2(dc, r1, r2 > r3 ? r2 : r3);\n\n}\n", "idx": 18571, "_split": "valid", "_hash": "cbdd429e6c18f86758dc423667235abc"}
{"project": "qemu", "commit_id": "a980a065fb5e86d6dec337e6cb6ff432f1a143c9", "target": 0, "func": "int usb_desc_handle_control(USBDevice *dev, int request, int value,\n\n                            int index, int length, uint8_t *data)\n\n{\n\n    const USBDesc *desc = dev->info->usb_desc;\n\n    int ret = -1;\n\n\n\n    assert(desc != NULL);\n\n    switch(request) {\n\n    case DeviceOutRequest | USB_REQ_SET_ADDRESS:\n\n        dev->addr = value;\n\n        trace_usb_set_addr(dev->addr);\n\n        ret = 0;\n\n        break;\n\n\n\n    case DeviceRequest | USB_REQ_GET_DESCRIPTOR:\n\n        ret = usb_desc_get_descriptor(dev, value, data, length);\n\n        break;\n\n    }\n\n    return ret;\n\n}\n", "idx": 18603, "_split": "valid", "_hash": "c625e9763eac975e64b953b265c3661c"}
{"project": "qemu", "commit_id": "e3e09d87c6e69c2da684d5aacabe3124ebcb6f8e", "target": 0, "func": "static void trigger_prot_fault(CPUS390XState *env, target_ulong vaddr,\n\n                               uint64_t mode)\n\n{\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    int ilen = ILEN_LATER_INC;\n\n    int bits = trans_bits(env, mode) | 4;\n\n\n\n    DPRINTF(\"%s: vaddr=%016\" PRIx64 \" bits=%d\\n\", __func__, vaddr, bits);\n\n\n\n    stq_phys(cs->as,\n\n             env->psa + offsetof(LowCore, trans_exc_code), vaddr | bits);\n\n    trigger_pgm_exception(env, PGM_PROTECTION, ilen);\n\n}\n", "idx": 18613, "_split": "valid", "_hash": "778d2f6802ed56638310b4c7d408c7c5"}
{"project": "qemu", "commit_id": "e7ca56562990991bc614a43b9351ee0737f3045d", "target": 0, "func": "void string_output_visitor_cleanup(StringOutputVisitor *sov)\n\n{\n\n    if (sov->string) {\n\n        g_string_free(sov->string, true);\n\n    }\n\n\n\n    g_list_foreach(sov->ranges, free_range, NULL);\n\n    g_list_free(sov->ranges);\n\n    g_free(sov);\n\n}\n", "idx": 18621, "_split": "valid", "_hash": "d92318c9f5bc3fdd254dbdd8f17e6362"}
{"project": "qemu", "commit_id": "0462faee67eb9ee39e51f764891fb6b767602eed", "target": 1, "func": "void memory_region_allocate_system_memory(MemoryRegion *mr, Object *owner,\n                                          const char *name,\n                                          uint64_t ram_size)\n{\n    uint64_t addr = 0;\n    int i;\n    if (nb_numa_nodes == 0 || !have_memdevs) {\n        allocate_system_memory_nonnuma(mr, owner, name, ram_size);\n        return;\n    memory_region_init(mr, owner, name, ram_size);\n    for (i = 0; i < MAX_NODES; i++) {\n        Error *local_err = NULL;\n        uint64_t size = numa_info[i].node_mem;\n        HostMemoryBackend *backend = numa_info[i].node_memdev;\n        if (!backend) {\n            continue;\n        MemoryRegion *seg = host_memory_backend_get_memory(backend, &local_err);\n        if (local_err) {\n            qerror_report_err(local_err);\n        memory_region_add_subregion(mr, addr, seg);\n        vmstate_register_ram_global(seg);\n        addr += size;", "idx": 18627, "_split": "valid", "_hash": "56b3652319eb112436ab3eb0d28ab912"}
{"project": "qemu", "commit_id": "ccfcdd09bf91aabe039d2dae0b5ec3a05f083e59", "target": 0, "func": "static inline void gen_jcc(DisasContext *s, int b,\n\n                           target_ulong val, target_ulong next_eip)\n\n{\n\n    int l1, l2;\n\n\n\n    gen_update_cc_op(s);\n\n    if (s->jmp_opt) {\n\n        l1 = gen_new_label();\n\n        gen_jcc1(s, b, l1);\n\n        set_cc_op(s, CC_OP_DYNAMIC);\n\n        \n\n        gen_goto_tb(s, 0, next_eip);\n\n\n\n        gen_set_label(l1);\n\n        gen_goto_tb(s, 1, val);\n\n        s->is_jmp = DISAS_TB_JUMP;\n\n    } else {\n\n\n\n        l1 = gen_new_label();\n\n        l2 = gen_new_label();\n\n        gen_jcc1(s, b, l1);\n\n        set_cc_op(s, CC_OP_DYNAMIC);\n\n\n\n        gen_jmp_im(next_eip);\n\n        tcg_gen_br(l2);\n\n\n\n        gen_set_label(l1);\n\n        gen_jmp_im(val);\n\n        gen_set_label(l2);\n\n        gen_eob(s);\n\n    }\n\n}\n", "idx": 18660, "_split": "valid", "_hash": "2c9a7c9ae2b3818b50af672d97921c86"}
{"project": "qemu", "commit_id": "5edbdbcdf882e4220adc7dbf433351077cd1fbbc", "target": 1, "func": "static int check_shm_size(IVShmemState *s, int fd) {\n\n    /* check that the guest isn't going to try and map more memory than the\n\n     * the object has allocated return -1 to indicate error */\n\n\n\n    struct stat buf;\n\n\n\n    fstat(fd, &buf);\n\n\n\n    if (s->ivshmem_size > buf.st_size) {\n\n        fprintf(stderr,\n\n                \"IVSHMEM ERROR: Requested memory size greater\"\n\n                \" than shared object size (%\" PRIu64 \" > %\" PRIu64\")\\n\",\n\n                s->ivshmem_size, (uint64_t)buf.st_size);\n\n        return -1;\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n", "idx": 18702, "_split": "valid", "_hash": "6b85c6ffb508421c7748c42b5db1bff6"}
{"project": "qemu", "commit_id": "defbaec16007bdf26e44c5add27e686f74dc94e5", "target": 1, "func": "e1000e_rss_get_hash_type(E1000ECore *core, struct NetRxPkt *pkt)\n\n{\n\n    bool isip4, isip6, isudp, istcp;\n\n\n\n    assert(e1000e_rss_enabled(core));\n\n\n\n    net_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);\n\n\n\n    if (isip4) {\n\n        bool fragment = net_rx_pkt_get_ip4_info(pkt)->fragment;\n\n\n\n        trace_e1000e_rx_rss_ip4(fragment, istcp, core->mac[MRQC],\n\n                                E1000_MRQC_EN_TCPIPV4(core->mac[MRQC]),\n\n                                E1000_MRQC_EN_IPV4(core->mac[MRQC]));\n\n\n\n        if (!fragment && istcp && E1000_MRQC_EN_TCPIPV4(core->mac[MRQC])) {\n\n            return E1000_MRQ_RSS_TYPE_IPV4TCP;\n\n        }\n\n\n\n        if (E1000_MRQC_EN_IPV4(core->mac[MRQC])) {\n\n            return E1000_MRQ_RSS_TYPE_IPV4;\n\n        }\n\n    } else if (isip6) {\n\n        eth_ip6_hdr_info *ip6info = net_rx_pkt_get_ip6_info(pkt);\n\n\n\n        bool ex_dis = core->mac[RFCTL] & E1000_RFCTL_IPV6_EX_DIS;\n\n        bool new_ex_dis = core->mac[RFCTL] & E1000_RFCTL_NEW_IPV6_EXT_DIS;\n\n\n\n        trace_e1000e_rx_rss_ip6(core->mac[RFCTL],\n\n                                ex_dis, new_ex_dis, istcp,\n\n                                ip6info->has_ext_hdrs,\n\n                                ip6info->rss_ex_dst_valid,\n\n                                ip6info->rss_ex_src_valid,\n\n                                core->mac[MRQC],\n\n                                E1000_MRQC_EN_TCPIPV6(core->mac[MRQC]),\n\n                                E1000_MRQC_EN_IPV6EX(core->mac[MRQC]),\n\n                                E1000_MRQC_EN_IPV6(core->mac[MRQC]));\n\n\n\n        if ((!ex_dis || !ip6info->has_ext_hdrs) &&\n\n            (!new_ex_dis || !(ip6info->rss_ex_dst_valid ||\n\n                              ip6info->rss_ex_src_valid))) {\n\n\n\n            if (istcp && !ip6info->fragment &&\n\n                E1000_MRQC_EN_TCPIPV6(core->mac[MRQC])) {\n\n                return E1000_MRQ_RSS_TYPE_IPV6TCP;\n\n            }\n\n\n\n            if (E1000_MRQC_EN_IPV6EX(core->mac[MRQC])) {\n\n                return E1000_MRQ_RSS_TYPE_IPV6EX;\n\n            }\n\n\n\n        }\n\n\n\n        if (E1000_MRQC_EN_IPV6(core->mac[MRQC])) {\n\n            return E1000_MRQ_RSS_TYPE_IPV6;\n\n        }\n\n\n\n    }\n\n\n\n    return E1000_MRQ_RSS_TYPE_NONE;\n\n}\n", "idx": 18706, "_split": "valid", "_hash": "07b0c33f06982d583a733a395b657fa7"}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "static inline uint32_t lduw_phys_internal(target_phys_addr_t addr,\n\n                                          enum device_endian endian)\n\n{\n\n    uint8_t *ptr;\n\n    uint64_t val;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!(memory_region_is_ram(section->mr) ||\n\n          memory_region_is_romd(section->mr))) {\n\n        /* I/O case */\n\n        addr = memory_region_section_addr(section, addr);\n\n        val = io_mem_read(section->mr, addr, 2);\n\n#if defined(TARGET_WORDS_BIGENDIAN)\n\n        if (endian == DEVICE_LITTLE_ENDIAN) {\n\n            val = bswap16(val);\n\n        }\n\n#else\n\n        if (endian == DEVICE_BIG_ENDIAN) {\n\n            val = bswap16(val);\n\n        }\n\n#endif\n\n    } else {\n\n        /* RAM case */\n\n        ptr = qemu_get_ram_ptr((memory_region_get_ram_addr(section->mr)\n\n                                & TARGET_PAGE_MASK)\n\n                               + memory_region_section_addr(section, addr));\n\n        switch (endian) {\n\n        case DEVICE_LITTLE_ENDIAN:\n\n            val = lduw_le_p(ptr);\n\n            break;\n\n        case DEVICE_BIG_ENDIAN:\n\n            val = lduw_be_p(ptr);\n\n            break;\n\n        default:\n\n            val = lduw_p(ptr);\n\n            break;\n\n        }\n\n    }\n\n    return val;\n\n}\n", "idx": 18736, "_split": "valid", "_hash": "9f975cbcfc16aa6cc6aaa5e7e8333507"}
{"project": "qemu", "commit_id": "0e8b3cdfbc167f4bb7790ef744eaa1ac0e6959f9", "target": 1, "func": "void *postcopy_get_tmp_page(MigrationIncomingState *mis)\n\n{\n\n    if (!mis->postcopy_tmp_page) {\n\n        mis->postcopy_tmp_page = mmap(NULL, getpagesize(),\n\n                             PROT_READ | PROT_WRITE, MAP_PRIVATE |\n\n                             MAP_ANONYMOUS, -1, 0);\n\n        if (!mis->postcopy_tmp_page) {\n\n            error_report(\"%s: %s\", __func__, strerror(errno));\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    return mis->postcopy_tmp_page;\n\n}\n", "idx": 18776, "_split": "valid", "_hash": "8841e8716482cc826cf4a6ee825361a6"}
{"project": "qemu", "commit_id": "ab431c283e7055bcd6fb622f212bb29e84a6a134", "target": 0, "func": "static int pci_slot_get_pirq(PCIDevice *pci_dev, int irq_num)\n\n{\n\n    int slot_addend;\n\n    slot_addend = (pci_dev->devfn >> 3) - 1;\n\n    return (irq_num + slot_addend) & 3;\n\n}\n", "idx": 18795, "_split": "valid", "_hash": "297cea369d0a21fd4cf8d98ddfa94dcb"}
{"project": "qemu", "commit_id": "4c315c27661502a0813b129e41c0bf640c34a8d6", "target": 1, "func": "DevicePropertyInfoList *qmp_device_list_properties(const char *typename,\n                                                   Error **errp)\n{\n    ObjectClass *klass;\n    Object *obj;\n    ObjectProperty *prop;\n    DevicePropertyInfoList *prop_list = NULL;\n    klass = object_class_by_name(typename);\n    if (klass == NULL) {\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n                  \"Device '%s' not found\", typename);\n    klass = object_class_dynamic_cast(klass, TYPE_DEVICE);\n    if (klass == NULL) {\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"name\", TYPE_DEVICE);\n    if (object_class_is_abstract(klass)) {\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"name\",\n                   \"non-abstract device type\");\n    obj = object_new(typename);\n    QTAILQ_FOREACH(prop, &obj->properties, node) {\n        DevicePropertyInfo *info;\n        DevicePropertyInfoList *entry;\n        /* Skip Object and DeviceState properties */\n        if (strcmp(prop->name, \"type\") == 0 ||\n            strcmp(prop->name, \"realized\") == 0 ||\n            strcmp(prop->name, \"hotpluggable\") == 0 ||\n            strcmp(prop->name, \"hotplugged\") == 0 ||\n            strcmp(prop->name, \"parent_bus\") == 0) {\n            continue;\n        /* Skip legacy properties since they are just string versions of\n         * properties that we already list.\n         */\n        if (strstart(prop->name, \"legacy-\", NULL)) {\n            continue;\n        info = make_device_property_info(klass, prop->name, prop->type,\n                                         prop->description);\n        if (!info) {\n            continue;\n        entry = g_malloc0(sizeof(*entry));\n        entry->value = info;\n        entry->next = prop_list;\n        prop_list = entry;\n    object_unref(obj);\n    return prop_list;", "idx": 18814, "_split": "valid", "_hash": "824cceecf42b98899d44cefd79e64128"}
{"project": "qemu", "commit_id": "b7fcff01790d25f48d81ef6c8c3399577096a555", "target": 1, "func": "static void test_bmdma_setup(void)\n\n{\n\n    ide_test_start(\n\n        \"-vnc none \"\n\n        \"-drive file=%s,if=ide,serial=%s,cache=writeback \"\n\n        \"-global ide-hd.ver=%s\",\n\n        tmp_path, \"testdisk\", \"version\");\n\n}\n", "idx": 18834, "_split": "valid", "_hash": "c32de19e59bd867d29370680ee54e94b"}
{"project": "qemu", "commit_id": "336c1c12551ff0a6e1a2af226d6cbdbadd2e02b5", "target": 0, "func": "int bdrv_has_zero_init(BlockDriverState *bs)\n\n{\n\n    assert(bs->drv);\n\n\n\n    if (bs->drv->no_zero_init) {\n\n        return 0;\n\n    } else if (bs->file) {\n\n        return bdrv_has_zero_init(bs->file);\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 18872, "_split": "valid", "_hash": "899ec3f7fd68fe1f5d91626bb50eb70b"}
{"project": "qemu", "commit_id": "0e9b9edae7bebfd31fdbead4ccbbce03876a7edd", "target": 0, "func": "build_madt(GArray *table_data, GArray *linker, PCMachineState *pcms)\n\n{\n\n    MachineClass *mc = MACHINE_GET_CLASS(pcms);\n\n    CPUArchIdList *apic_ids = mc->possible_cpu_arch_ids(MACHINE(pcms));\n\n    int madt_start = table_data->len;\n\n\n\n    AcpiMultipleApicTable *madt;\n\n    AcpiMadtIoApic *io_apic;\n\n    AcpiMadtIntsrcovr *intsrcovr;\n\n    AcpiMadtLocalNmi *local_nmi;\n\n    int i;\n\n\n\n    madt = acpi_data_push(table_data, sizeof *madt);\n\n    madt->local_apic_address = cpu_to_le32(APIC_DEFAULT_ADDRESS);\n\n    madt->flags = cpu_to_le32(1);\n\n\n\n    for (i = 0; i < apic_ids->len; i++) {\n\n        AcpiMadtProcessorApic *apic = acpi_data_push(table_data, sizeof *apic);\n\n        int apic_id = apic_ids->cpus[i].arch_id;\n\n\n\n        apic->type = ACPI_APIC_PROCESSOR;\n\n        apic->length = sizeof(*apic);\n\n        apic->processor_id = i;\n\n        apic->local_apic_id = apic_id;\n\n        if (apic_ids->cpus[i].cpu != NULL) {\n\n            apic->flags = cpu_to_le32(1);\n\n        } else {\n\n            /* ACPI spec says that LAPIC entry for non present\n\n             * CPU may be omitted from MADT or it must be marked\n\n             * as disabled. However omitting non present CPU from\n\n             * MADT breaks hotplug on linux. So possible CPUs\n\n             * should be put in MADT but kept disabled.\n\n             */\n\n            apic->flags = cpu_to_le32(0);\n\n        }\n\n    }\n\n    g_free(apic_ids);\n\n\n\n    io_apic = acpi_data_push(table_data, sizeof *io_apic);\n\n    io_apic->type = ACPI_APIC_IO;\n\n    io_apic->length = sizeof(*io_apic);\n\n#define ACPI_BUILD_IOAPIC_ID 0x0\n\n    io_apic->io_apic_id = ACPI_BUILD_IOAPIC_ID;\n\n    io_apic->address = cpu_to_le32(IO_APIC_DEFAULT_ADDRESS);\n\n    io_apic->interrupt = cpu_to_le32(0);\n\n\n\n    if (pcms->apic_xrupt_override) {\n\n        intsrcovr = acpi_data_push(table_data, sizeof *intsrcovr);\n\n        intsrcovr->type   = ACPI_APIC_XRUPT_OVERRIDE;\n\n        intsrcovr->length = sizeof(*intsrcovr);\n\n        intsrcovr->source = 0;\n\n        intsrcovr->gsi    = cpu_to_le32(2);\n\n        intsrcovr->flags  = cpu_to_le16(0); /* conforms to bus specifications */\n\n    }\n\n    for (i = 1; i < 16; i++) {\n\n#define ACPI_BUILD_PCI_IRQS ((1<<5) | (1<<9) | (1<<10) | (1<<11))\n\n        if (!(ACPI_BUILD_PCI_IRQS & (1 << i))) {\n\n            /* No need for a INT source override structure. */\n\n            continue;\n\n        }\n\n        intsrcovr = acpi_data_push(table_data, sizeof *intsrcovr);\n\n        intsrcovr->type   = ACPI_APIC_XRUPT_OVERRIDE;\n\n        intsrcovr->length = sizeof(*intsrcovr);\n\n        intsrcovr->source = i;\n\n        intsrcovr->gsi    = cpu_to_le32(i);\n\n        intsrcovr->flags  = cpu_to_le16(0xd); /* active high, level triggered */\n\n    }\n\n\n\n    local_nmi = acpi_data_push(table_data, sizeof *local_nmi);\n\n    local_nmi->type         = ACPI_APIC_LOCAL_NMI;\n\n    local_nmi->length       = sizeof(*local_nmi);\n\n    local_nmi->processor_id = 0xff; /* all processors */\n\n    local_nmi->flags        = cpu_to_le16(0);\n\n    local_nmi->lint         = 1; /* ACPI_LINT1 */\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)(table_data->data + madt_start), \"APIC\",\n\n                 table_data->len - madt_start, 1, NULL, NULL);\n\n}\n", "idx": 18891, "_split": "valid", "_hash": "eeb4e98c5ed547838e992dee0dda2925"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void integratorcm_write(void *opaque, target_phys_addr_t offset,\n\n                               uint64_t value, unsigned size)\n\n{\n\n    integratorcm_state *s = (integratorcm_state *)opaque;\n\n    switch (offset >> 2) {\n\n    case 2: /* CM_OSC */\n\n        if (s->cm_lock == 0xa05f)\n\n            s->cm_osc = value;\n\n        break;\n\n    case 3: /* CM_CTRL */\n\n        integratorcm_set_ctrl(s, value);\n\n        break;\n\n    case 5: /* CM_LOCK */\n\n        s->cm_lock = value & 0xffff;\n\n        break;\n\n    case 7: /* CM_AUXOSC */\n\n        if (s->cm_lock == 0xa05f)\n\n            s->cm_auxosc = value;\n\n        break;\n\n    case 8: /* CM_SDRAM */\n\n        s->cm_sdram = value;\n\n        break;\n\n    case 9: /* CM_INIT */\n\n        /* ??? This can change the memory bus frequency.  */\n\n        s->cm_init = value;\n\n        break;\n\n    case 12: /* CM_FLAGSS */\n\n        s->cm_flags |= value;\n\n        break;\n\n    case 13: /* CM_FLAGSC */\n\n        s->cm_flags &= ~value;\n\n        break;\n\n    case 14: /* CM_NVFLAGSS */\n\n        s->cm_nvflags |= value;\n\n        break;\n\n    case 15: /* CM_NVFLAGSS */\n\n        s->cm_nvflags &= ~value;\n\n        break;\n\n    case 18: /* CM_IRQ_ENSET */\n\n        s->irq_enabled |= value;\n\n        integratorcm_update(s);\n\n        break;\n\n    case 19: /* CM_IRQ_ENCLR */\n\n        s->irq_enabled &= ~value;\n\n        integratorcm_update(s);\n\n        break;\n\n    case 20: /* CM_SOFT_INTSET */\n\n        s->int_level |= (value & 1);\n\n        integratorcm_update(s);\n\n        break;\n\n    case 21: /* CM_SOFT_INTCLR */\n\n        s->int_level &= ~(value & 1);\n\n        integratorcm_update(s);\n\n        break;\n\n    case 26: /* CM_FIQ_ENSET */\n\n        s->fiq_enabled |= value;\n\n        integratorcm_update(s);\n\n        break;\n\n    case 27: /* CM_FIQ_ENCLR */\n\n        s->fiq_enabled &= ~value;\n\n        integratorcm_update(s);\n\n        break;\n\n    case 32: /* CM_VOLTAGE_CTL0 */\n\n    case 33: /* CM_VOLTAGE_CTL1 */\n\n    case 34: /* CM_VOLTAGE_CTL2 */\n\n    case 35: /* CM_VOLTAGE_CTL3 */\n\n        /* ??? Voltage control unimplemented.  */\n\n        break;\n\n    default:\n\n        hw_error(\"integratorcm_write: Unimplemented offset 0x%x\\n\",\n\n                 (int)offset);\n\n        break;\n\n    }\n\n}\n", "idx": 18905, "_split": "valid", "_hash": "4f457eb63d139b7e6dd9c3c19d52dc45"}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static int pci_vpb_map_irq(PCIDevice *d, int irq_num)\n\n{\n\n    PCIVPBState *s = container_of(d->bus, PCIVPBState, pci_bus);\n\n\n\n    if (s->irq_mapping == PCI_VPB_IRQMAP_BROKEN) {\n\n        /* Legacy broken IRQ mapping for compatibility with old and\n\n         * buggy Linux guests\n\n         */\n\n        return irq_num;\n\n    }\n\n\n\n    /* Slot to IRQ mapping for RealView Platform Baseboard 926 backplane\n\n     *      name    slot    IntA    IntB    IntC    IntD\n\n     *      A       31      IRQ28   IRQ29   IRQ30   IRQ27\n\n     *      B       30      IRQ27   IRQ28   IRQ29   IRQ30\n\n     *      C       29      IRQ30   IRQ27   IRQ28   IRQ29\n\n     * Slot C is for the host bridge; A and B the peripherals.\n\n     * Our output irqs 0..3 correspond to the baseboard's 27..30.\n\n     *\n\n     * This mapping function takes account of an oddity in the PB926\n\n     * board wiring, where the FPGA's P_nINTA input is connected to\n\n     * the INTB connection on the board PCI edge connector, P_nINTB\n\n     * is connected to INTC, and so on, so everything is one number\n\n     * further round from where you might expect.\n\n     */\n\n    return pci_swizzle_map_irq_fn(d, irq_num + 2);\n\n}\n", "idx": 18916, "_split": "valid", "_hash": "088428ed04c4f342773dcb1041c5b45c"}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "static uint32_t omap_l4_io_readh(void *opaque, target_phys_addr_t addr)\n\n{\n\n    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;\n\n\n\n    return omap_l4_io_readh_fn[i](omap_l4_io_opaque[i], addr);\n\n}\n", "idx": 18930, "_split": "valid", "_hash": "b5c201139f50fda69ca8b020fa0c5f89"}
{"project": "qemu", "commit_id": "b2cd5b925c529d91fae5fe8373490714e1a8fe6c", "target": 1, "func": "static void test_keyval_parse_list(void)\n\n{\n\n    Error *err = NULL;\n\n    QDict *qdict, *sub_qdict;\n\n\n\n    /* Root can't be a list */\n\n    qdict = keyval_parse(\"0=1\", NULL, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!qdict);\n\n\n\n    /* List elements need not be in order */\n\n    qdict = keyval_parse(\"list.0=null,list.2=zwei,list.1=eins\",\n\n                         NULL, &error_abort);\n\n    g_assert_cmpint(qdict_size(qdict), ==, 1);\n\n    check_list012(qdict_get_qlist(qdict, \"list\"));\n\n    QDECREF(qdict);\n\n\n\n    /* Multiple indexes, last one wins */\n\n    qdict = keyval_parse(\"list.1=goner,list.0=null,list.1=eins,list.2=zwei\",\n\n                         NULL, &error_abort);\n\n    g_assert_cmpint(qdict_size(qdict), ==, 1);\n\n    check_list012(qdict_get_qlist(qdict, \"list\"));\n\n    QDECREF(qdict);\n\n\n\n    /* List at deeper nesting */\n\n    qdict = keyval_parse(\"a.list.1=eins,a.list.0=null,a.list.2=zwei\",\n\n                         NULL, &error_abort);\n\n    g_assert_cmpint(qdict_size(qdict), ==, 1);\n\n    sub_qdict = qdict_get_qdict(qdict, \"a\");\n\n    g_assert_cmpint(qdict_size(sub_qdict), ==, 1);\n\n    check_list012(qdict_get_qlist(sub_qdict, \"list\"));\n\n    QDECREF(qdict);\n\n\n\n    /* Inconsistent dotted keys: both list and dictionary */\n\n    qdict = keyval_parse(\"a.b.c=1,a.b.0=2\", NULL, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!qdict);\n\n    qdict = keyval_parse(\"a.0.c=1,a.b.c=2\", NULL, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!qdict);\n\n\n\n    /* Missing list indexes */\n\n    qdict = keyval_parse(\"list.2=lonely\", NULL, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!qdict);\n\n    qdict = keyval_parse(\"list.0=null,list.2=eins,list.02=zwei\", NULL, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!qdict);\n\n}\n", "idx": 18943, "_split": "valid", "_hash": "d50d50dbac78ddae3bdf23dad9973445"}
{"project": "qemu", "commit_id": "ba4906a9b64e165a958e12f6208ca834dc7a36dc", "target": 1, "func": "static int ds1338_recv(I2CSlave *i2c)\n\n{\n\n    DS1338State *s = FROM_I2C_SLAVE(DS1338State, i2c);\n\n    uint8_t res;\n\n\n\n    res  = s->nvram[s->ptr];\n\n    s->ptr = (s->ptr + 1) & 0xff;\n\n    return res;\n\n}\n", "idx": 18946, "_split": "valid", "_hash": "eeab3360a36e5cc52627779a1e9b02d2"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "size_t qsb_get_length(const QEMUSizedBuffer *qsb)\n\n{\n\n    return qsb->used;\n\n}\n", "idx": 18955, "_split": "valid", "_hash": "bee644a2bebf2602140e4610b9b6d8a4"}
{"project": "qemu", "commit_id": "ad96090a01d848df67d70c5259ed8aa321fa8716", "target": 0, "func": "static int ram_save_live(Monitor *mon, QEMUFile *f, int stage, void *opaque)\n\n{\n\n    ram_addr_t addr;\n\n    uint64_t bytes_transferred_last;\n\n    double bwidth = 0;\n\n    uint64_t expected_time = 0;\n\n\n\n    if (stage < 0) {\n\n        cpu_physical_memory_set_dirty_tracking(0);\n\n        return 0;\n\n    }\n\n\n\n    if (cpu_physical_sync_dirty_bitmap(0, TARGET_PHYS_ADDR_MAX) != 0) {\n\n        qemu_file_set_error(f);\n\n        return 0;\n\n    }\n\n\n\n    if (stage == 1) {\n\n        bytes_transferred = 0;\n\n\n\n        /* Make sure all dirty bits are set */\n\n        for (addr = 0; addr < last_ram_offset; addr += TARGET_PAGE_SIZE) {\n\n            if (!cpu_physical_memory_get_dirty(addr, MIGRATION_DIRTY_FLAG))\n\n                cpu_physical_memory_set_dirty(addr);\n\n        }\n\n\n\n        /* Enable dirty memory tracking */\n\n        cpu_physical_memory_set_dirty_tracking(1);\n\n\n\n        qemu_put_be64(f, last_ram_offset | RAM_SAVE_FLAG_MEM_SIZE);\n\n    }\n\n\n\n    bytes_transferred_last = bytes_transferred;\n\n    bwidth = qemu_get_clock_ns(rt_clock);\n\n\n\n    while (!qemu_file_rate_limit(f)) {\n\n        int ret;\n\n\n\n        ret = ram_save_block(f);\n\n        bytes_transferred += ret * TARGET_PAGE_SIZE;\n\n        if (ret == 0) /* no more blocks */\n\n            break;\n\n    }\n\n\n\n    bwidth = qemu_get_clock_ns(rt_clock) - bwidth;\n\n    bwidth = (bytes_transferred - bytes_transferred_last) / bwidth;\n\n\n\n    /* if we haven't transferred anything this round, force expected_time to a\n\n     * a very high value, but without crashing */\n\n    if (bwidth == 0)\n\n        bwidth = 0.000001;\n\n\n\n    /* try transferring iterative blocks of memory */\n\n    if (stage == 3) {\n\n        /* flush all remaining blocks regardless of rate limiting */\n\n        while (ram_save_block(f) != 0) {\n\n            bytes_transferred += TARGET_PAGE_SIZE;\n\n        }\n\n        cpu_physical_memory_set_dirty_tracking(0);\n\n    }\n\n\n\n    qemu_put_be64(f, RAM_SAVE_FLAG_EOS);\n\n\n\n    expected_time = ram_save_remaining() * TARGET_PAGE_SIZE / bwidth;\n\n\n\n    return (stage == 2) && (expected_time <= migrate_max_downtime());\n\n}\n", "idx": 18990, "_split": "valid", "_hash": "c63771847b26339bcbeea9bb4f9f63de"}
{"project": "qemu", "commit_id": "2c62f08ddbf3fa80dc7202eb9a2ea60ae44e2cc5", "target": 0, "func": "static void g364fb_screen_dump(void *opaque, const char *filename, bool cswitch,\n\n                               Error **errp)\n\n{\n\n    G364State *s = opaque;\n\n    int ret, y, x;\n\n    uint8_t index;\n\n    uint8_t *data_buffer;\n\n    FILE *f;\n\n\n\n    qemu_flush_coalesced_mmio_buffer();\n\n\n\n    if (s->depth != 8) {\n\n        error_setg(errp, \"g364: unknown guest depth %d\", s->depth);\n\n        return;\n\n    }\n\n\n\n    f = fopen(filename, \"wb\");\n\n    if (!f) {\n\n        error_setg(errp, \"failed to open file '%s': %s\", filename,\n\n                   strerror(errno));\n\n        return;\n\n    }\n\n\n\n    if (s->ctla & CTLA_FORCE_BLANK) {\n\n        /* blank screen */\n\n        ret = fprintf(f, \"P4\\n%d %d\\n\", s->width, s->height);\n\n        if (ret < 0) {\n\n            goto write_err;\n\n        }\n\n        for (y = 0; y < s->height; y++)\n\n            for (x = 0; x < s->width; x++) {\n\n                ret = fputc(0, f);\n\n                if (ret == EOF) {\n\n                    goto write_err;\n\n                }\n\n            }\n\n    } else {\n\n        data_buffer = s->vram + s->top_of_screen;\n\n        ret = fprintf(f, \"P6\\n%d %d\\n%d\\n\", s->width, s->height, 255);\n\n        if (ret < 0) {\n\n            goto write_err;\n\n        }\n\n        for (y = 0; y < s->height; y++)\n\n            for (x = 0; x < s->width; x++, data_buffer++) {\n\n                index = *data_buffer;\n\n                ret = fputc(s->color_palette[index][0], f);\n\n                if (ret == EOF) {\n\n                    goto write_err;\n\n                }\n\n                ret = fputc(s->color_palette[index][1], f);\n\n                if (ret == EOF) {\n\n                    goto write_err;\n\n                }\n\n                ret = fputc(s->color_palette[index][2], f);\n\n                if (ret == EOF) {\n\n                    goto write_err;\n\n                }\n\n        }\n\n    }\n\n\n\nout:\n\n    fclose(f);\n\n    return;\n\n\n\nwrite_err:\n\n    error_setg(errp, \"failed to write to file '%s': %s\", filename,\n\n               strerror(errno));\n\n    unlink(filename);\n\n    goto out;\n\n}\n", "idx": 18997, "_split": "valid", "_hash": "7b9bed4b0f9b48a1389ad401d7c615e9"}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "float64 helper_fsmuld(CPUSPARCState *env, float32 src1, float32 src2)\n\n{\n\n    float64 ret;\n\n    clear_float_exceptions(env);\n\n    ret = float64_mul(float32_to_float64(src1, &env->fp_status),\n\n                      float32_to_float64(src2, &env->fp_status),\n\n                      &env->fp_status);\n\n    check_ieee_exceptions(env);\n\n    return ret;\n\n}\n", "idx": 18999, "_split": "valid", "_hash": "ee3514516e3a0c9b16444d93706a1f83"}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "target_phys_addr_t omap_l4_attach(struct omap_target_agent_s *ta, int region,\n\n                int iotype)\n\n{\n\n    target_phys_addr_t base;\n\n    ssize_t size;\n\n#ifdef L4_MUX_HACK\n\n    int i;\n\n#endif\n\n\n\n    if (region < 0 || region >= ta->regions) {\n\n        fprintf(stderr, \"%s: bad io region (%i)\\n\", __FUNCTION__, region);\n\n        exit(-1);\n\n    }\n\n\n\n    base = ta->bus->base + ta->start[region].offset;\n\n    size = ta->start[region].size;\n\n    if (iotype) {\n\n#ifndef L4_MUX_HACK\n\n        cpu_register_physical_memory(base, size, iotype);\n\n#else\n\n        cpu_register_physical_memory(base, size, omap_cpu_io_entry);\n\n        i = (base - ta->bus->base) / TARGET_PAGE_SIZE;\n\n        for (; size > 0; size -= TARGET_PAGE_SIZE, i ++) {\n\n            omap_l4_io_readb_fn[i] = omap_l4_io_entry[iotype].mem_read[0];\n\n            omap_l4_io_readh_fn[i] = omap_l4_io_entry[iotype].mem_read[1];\n\n            omap_l4_io_readw_fn[i] = omap_l4_io_entry[iotype].mem_read[2];\n\n            omap_l4_io_writeb_fn[i] = omap_l4_io_entry[iotype].mem_write[0];\n\n            omap_l4_io_writeh_fn[i] = omap_l4_io_entry[iotype].mem_write[1];\n\n            omap_l4_io_writew_fn[i] = omap_l4_io_entry[iotype].mem_write[2];\n\n            omap_l4_io_opaque[i] = omap_l4_io_entry[iotype].opaque;\n\n        }\n\n#endif\n\n    }\n\n\n\n    return base;\n\n}\n", "idx": 19002, "_split": "valid", "_hash": "25abeee0f117796999238df9717f8177"}
{"project": "qemu", "commit_id": "0188fadb7fe460d8c4c743372b1f7b25773e183e", "target": 1, "func": "static void setup_frame(int sig, struct target_sigaction * ka,\n\n                        target_sigset_t *set, CPUMIPSState *regs)\n\n{\n\n    struct sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    int i;\n\n\n\n    frame_addr = get_sigframe(ka, regs, sizeof(*frame));\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0))\n\n\tgoto give_sigsegv;\n\n\n\n    install_sigtramp(frame->sf_code, TARGET_NR_sigreturn);\n\n\n\n    setup_sigcontext(regs, &frame->sf_sc);\n\n\n\n    for(i = 0; i < TARGET_NSIG_WORDS; i++) {\n\n\tif(__put_user(set->sig[i], &frame->sf_mask.sig[i]))\n\n\t    goto give_sigsegv;\n\n    }\n\n\n\n    /*\n\n    * Arguments to signal handler:\n\n    *\n\n    *   a0 = signal number\n\n    *   a1 = 0 (should be cause)\n\n    *   a2 = pointer to struct sigcontext\n\n    *\n\n    * $25 and PC point to the signal handler, $29 points to the\n\n    * struct sigframe.\n\n    */\n\n    regs->active_tc.gpr[ 4] = sig;\n\n    regs->active_tc.gpr[ 5] = 0;\n\n    regs->active_tc.gpr[ 6] = frame_addr + offsetof(struct sigframe, sf_sc);\n\n    regs->active_tc.gpr[29] = frame_addr;\n\n    regs->active_tc.gpr[31] = frame_addr + offsetof(struct sigframe, sf_code);\n\n    /* The original kernel code sets CP0_EPC to the handler\n\n    * since it returns to userland using eret\n\n    * we cannot do this here, and we must set PC directly */\n\n    regs->active_tc.PC = regs->active_tc.gpr[25] = ka->_sa_handler;\n\n    mips_set_hflags_isa_mode_from_pc(regs);\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    return;\n\n\n\ngive_sigsegv:\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    force_sig(TARGET_SIGSEGV/*, current*/);\n\n}\n", "idx": 19006, "_split": "valid", "_hash": "f77d91c13d8216343287c7123dd38af1"}
{"project": "qemu", "commit_id": "b38ec5ee7a581776bbce0bdaecb397632c3c4791", "target": 1, "func": "static void pci_msix_write(void *opaque, hwaddr addr,\n\n                           uint64_t val, unsigned size)\n\n{\n\n    XenPCIPassthroughState *s = opaque;\n\n    XenPTMSIX *msix = s->msix;\n\n    XenPTMSIXEntry *entry;\n\n    int entry_nr, offset;\n\n\n\n    entry_nr = addr / PCI_MSIX_ENTRY_SIZE;\n\n    if (entry_nr < 0 || entry_nr >= msix->total_entries) {\n\n        XEN_PT_ERR(&s->dev, \"asked MSI-X entry '%i' invalid!\\n\", entry_nr);\n\n        return;\n\n    }\n\n    entry = &msix->msix_entry[entry_nr];\n\n    offset = addr % PCI_MSIX_ENTRY_SIZE;\n\n\n\n    if (offset != PCI_MSIX_ENTRY_VECTOR_CTRL) {\n\n        const volatile uint32_t *vec_ctrl;\n\n\n\n        if (get_entry_value(entry, offset) == val\n\n            && entry->pirq != XEN_PT_UNASSIGNED_PIRQ) {\n\n            return;\n\n        }\n\n\n\n        /*\n\n         * If Xen intercepts the mask bit access, entry->vec_ctrl may not be\n\n         * up-to-date. Read from hardware directly.\n\n         */\n\n        vec_ctrl = s->msix->phys_iomem_base + entry_nr * PCI_MSIX_ENTRY_SIZE\n\n            + PCI_MSIX_ENTRY_VECTOR_CTRL;\n\n\n\n        if (msix->enabled && !(*vec_ctrl & PCI_MSIX_ENTRY_CTRL_MASKBIT)) {\n\n            XEN_PT_ERR(&s->dev, \"Can't update msix entry %d since MSI-X is\"\n\n                       \" already enabled.\\n\", entry_nr);\n\n            return;\n\n        }\n\n\n\n        entry->updated = true;\n\n    }\n\n\n\n    set_entry_value(entry, offset, val);\n\n\n\n    if (offset == PCI_MSIX_ENTRY_VECTOR_CTRL) {\n\n        if (msix->enabled && !(val & PCI_MSIX_ENTRY_CTRL_MASKBIT)) {\n\n            xen_pt_msix_update_one(s, entry_nr);\n\n        }\n\n    }\n\n}\n", "idx": 19014, "_split": "valid", "_hash": "b95aa1a333d206ec683cfc858fd6bcc0"}
{"project": "qemu", "commit_id": "0752706de257b38763006ff5bb6b39a97e669ba2", "target": 1, "func": "static void tap_set_sndbuf(TAPState *s, const char *sndbuf_str, Monitor *mon)\n\n{\n\n    if (sndbuf_str) {\n\n        config_error(mon, \"No '-net tap,sndbuf=<nbytes>' support available\\n\");\n\n    }\n\n}\n", "idx": 19062, "_split": "valid", "_hash": "ad18da5d3f5e441eb535c5e2f9f40a80"}
{"project": "qemu", "commit_id": "bf8d5166395612b4e856fad57606eb0cff97ae2e", "target": 1, "func": "static uint64_t error_mem_read(void *opaque, hwaddr addr,\n\n                               unsigned size)\n\n{\n\n    abort();\n\n}\n", "idx": 19065, "_split": "valid", "_hash": "c34613ad672be56b9abe7771355eb840"}
{"project": "qemu", "commit_id": "8caa05d8891d0a09dc4c00908c24c6ddfd872bbe", "target": 0, "func": "static void timer_del_locked(QEMUTimerList *timer_list, QEMUTimer *ts)\n\n{\n\n    QEMUTimer **pt, *t;\n\n\n\n    ts->expire_time = -1;\n\n    pt = &timer_list->active_timers;\n\n    for(;;) {\n\n        t = *pt;\n\n        if (!t)\n\n            break;\n\n        if (t == ts) {\n\n            *pt = t->next;\n\n            break;\n\n        }\n\n        pt = &t->next;\n\n    }\n\n}\n", "idx": 19099, "_split": "valid", "_hash": "c057b6973dd1b2bc7fb15eb9a95b6c00"}
{"project": "qemu", "commit_id": "fea505221eaf87889000378d4d33ad0dfd5f4d9d", "target": 0, "func": "static void handle_sys(DisasContext *s, uint32_t insn, unsigned int l,\n\n                       unsigned int op1, unsigned int op2,\n\n                       unsigned int crn, unsigned int crm, unsigned int rt)\n\n{\n\n    unsupported_encoding(s, insn);\n\n}\n", "idx": 19120, "_split": "valid", "_hash": "a737eca3be8d300bf618ff26cb4cb305"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void axisdev88_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    CRISCPU *cpu;\n\n    CPUCRISState *env;\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    DriveInfo *nand;\n\n    qemu_irq irq[30], nmi[2];\n\n    void *etraxfs_dmac;\n\n    struct etraxfs_dma_client *dma_eth;\n\n    int i;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *phys_intmem = g_new(MemoryRegion, 1);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"crisv32\";\n\n    }\n\n    cpu = cpu_cris_init(cpu_model);\n\n    env = &cpu->env;\n\n\n\n    /* allocate RAM */\n\n    memory_region_init_ram(phys_ram, NULL, \"axisdev88.ram\", ram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(phys_ram);\n\n    memory_region_add_subregion(address_space_mem, 0x40000000, phys_ram);\n\n\n\n    /* The ETRAX-FS has 128Kb on chip ram, the docs refer to it as the \n\n       internal memory.  */\n\n    memory_region_init_ram(phys_intmem, NULL, \"axisdev88.chipram\", INTMEM_SIZE,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(phys_intmem);\n\n    memory_region_add_subregion(address_space_mem, 0x38000000, phys_intmem);\n\n\n\n      /* Attach a NAND flash to CS1.  */\n\n    nand = drive_get(IF_MTD, 0, 0);\n\n    nand_state.nand = nand_init(nand ? blk_bs(blk_by_legacy_dinfo(nand)) : NULL,\n\n                                NAND_MFR_STMICRO, 0x39);\n\n    memory_region_init_io(&nand_state.iomem, NULL, &nand_ops, &nand_state,\n\n                          \"nand\", 0x05000000);\n\n    memory_region_add_subregion(address_space_mem, 0x10000000,\n\n                                &nand_state.iomem);\n\n\n\n    gpio_state.nand = &nand_state;\n\n    memory_region_init_io(&gpio_state.iomem, NULL, &gpio_ops, &gpio_state,\n\n                          \"gpio\", 0x5c);\n\n    memory_region_add_subregion(address_space_mem, 0x3001a000,\n\n                                &gpio_state.iomem);\n\n\n\n\n\n    dev = qdev_create(NULL, \"etraxfs,pic\");\n\n    /* FIXME: Is there a proper way to signal vectors to the CPU core?  */\n\n    qdev_prop_set_ptr(dev, \"interrupt_vector\", &env->interrupt_vector);\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(s, 0, 0x3001c000);\n\n    sysbus_connect_irq(s, 0, qdev_get_gpio_in(DEVICE(cpu), CRIS_CPU_IRQ));\n\n    sysbus_connect_irq(s, 1, qdev_get_gpio_in(DEVICE(cpu), CRIS_CPU_NMI));\n\n    for (i = 0; i < 30; i++) {\n\n        irq[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n    nmi[0] = qdev_get_gpio_in(dev, 30);\n\n    nmi[1] = qdev_get_gpio_in(dev, 31);\n\n\n\n    etraxfs_dmac = etraxfs_dmac_init(0x30000000, 10);\n\n    for (i = 0; i < 10; i++) {\n\n        /* On ETRAX, odd numbered channels are inputs.  */\n\n        etraxfs_dmac_connect(etraxfs_dmac, i, irq + 7 + i, i & 1);\n\n    }\n\n\n\n    /* Add the two ethernet blocks.  */\n\n    dma_eth = g_malloc0(sizeof dma_eth[0] * 4); /* Allocate 4 channels.  */\n\n    etraxfs_eth_init(&nd_table[0], 0x30034000, 1, &dma_eth[0], &dma_eth[1]);\n\n    if (nb_nics > 1) {\n\n        etraxfs_eth_init(&nd_table[1], 0x30036000, 2, &dma_eth[2], &dma_eth[3]);\n\n    }\n\n\n\n    /* The DMA Connector block is missing, hardwire things for now.  */\n\n    etraxfs_dmac_connect_client(etraxfs_dmac, 0, &dma_eth[0]);\n\n    etraxfs_dmac_connect_client(etraxfs_dmac, 1, &dma_eth[1]);\n\n    if (nb_nics > 1) {\n\n        etraxfs_dmac_connect_client(etraxfs_dmac, 6, &dma_eth[2]);\n\n        etraxfs_dmac_connect_client(etraxfs_dmac, 7, &dma_eth[3]);\n\n    }\n\n\n\n    /* 2 timers.  */\n\n    sysbus_create_varargs(\"etraxfs,timer\", 0x3001e000, irq[0x1b], nmi[1], NULL);\n\n    sysbus_create_varargs(\"etraxfs,timer\", 0x3005e000, irq[0x1b], nmi[1], NULL);\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        sysbus_create_simple(\"etraxfs,serial\", 0x30026000 + i * 0x2000,\n\n                             irq[0x14 + i]);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        li.image_filename = kernel_filename;\n\n        li.cmdline = kernel_cmdline;\n\n        cris_load_image(cpu, &li);\n\n    } else if (!qtest_enabled()) {\n\n        fprintf(stderr, \"Kernel image must be specified\\n\");\n\n        exit(1);\n\n    }\n\n}\n", "idx": 19122, "_split": "valid", "_hash": "27438e3f9afaabca0df414872338636f"}
{"project": "qemu", "commit_id": "db39fcf1f690b02d612e2bfc00980700887abe03", "target": 0, "func": "static CharDriverState *qemu_chr_open_pp_fd(int fd)\n\n{\n\n    CharDriverState *chr;\n\n    ParallelCharDriver *drv;\n\n\n\n    if (ioctl(fd, PPCLAIM) < 0) {\n\n        close(fd);\n\n        return NULL;\n\n    }\n\n\n\n    drv = g_malloc0(sizeof(ParallelCharDriver));\n\n    drv->fd = fd;\n\n    drv->mode = IEEE1284_MODE_COMPAT;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    chr->chr_write = null_chr_write;\n\n    chr->chr_ioctl = pp_ioctl;\n\n    chr->chr_close = pp_close;\n\n    chr->opaque = drv;\n\n\n\n    return chr;\n\n}\n", "idx": 19130, "_split": "valid", "_hash": "5f9bdb0ea9741fa1516b47dd07e0d7d7"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "const char *bdrv_get_device_or_node_name(const BlockDriverState *bs)\n\n{\n\n    return bs->blk ? blk_name(bs->blk) : bs->node_name;\n\n}\n", "idx": 19137, "_split": "valid", "_hash": "77091b72faaea86c166ec962bf9e81bc"}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static QObject *qmp_output_pop(QmpOutputVisitor *qov, void *qapi)\n\n{\n\n    QStackEntry *e = QSLIST_FIRST(&qov->stack);\n\n    QObject *value;\n\n\n\n    assert(e);\n\n    assert(e->qapi == qapi);\n\n    QSLIST_REMOVE_HEAD(&qov->stack, node);\n\n    value = e->value;\n\n    assert(value);\n\n    g_free(e);\n\n    return value;\n\n}\n", "idx": 19142, "_split": "valid", "_hash": "ed4eaca60cd29d392ce30035f4b5e9fd"}
{"project": "qemu", "commit_id": "298a1665a2800f7264e483c2dd1f551574243a2f", "target": 0, "func": "int coroutine_fn bdrv_is_allocated(BlockDriverState *bs, int64_t offset,\n\n                                   int64_t bytes, int64_t *pnum)\n\n{\n\n    BlockDriverState *file;\n\n    int64_t sector_num = offset >> BDRV_SECTOR_BITS;\n\n    int nb_sectors = bytes >> BDRV_SECTOR_BITS;\n\n    int64_t ret;\n\n    int psectors;\n\n\n\n    assert(QEMU_IS_ALIGNED(offset, BDRV_SECTOR_SIZE));\n\n    assert(QEMU_IS_ALIGNED(bytes, BDRV_SECTOR_SIZE) && bytes < INT_MAX);\n\n    ret = bdrv_get_block_status(bs, sector_num, nb_sectors, &psectors,\n\n                                &file);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    if (pnum) {\n\n        *pnum = psectors * BDRV_SECTOR_SIZE;\n\n    }\n\n    return !!(ret & BDRV_BLOCK_ALLOCATED);\n\n}\n", "idx": 19165, "_split": "valid", "_hash": "1caa037d17f59b119f70a65e0c053b00"}
{"project": "qemu", "commit_id": "ec48c7747acd1be25ca70586bc4e6640765e40c8", "target": 0, "func": "static int rtl8139_cplus_transmit_one(RTL8139State *s)\n\n{\n\n    if (!rtl8139_transmitter_enabled(s))\n\n    {\n\n        DPRINTF(\"+++ C+ mode: transmitter disabled\\n\");\n\n        return 0;\n\n    }\n\n\n\n    if (!rtl8139_cp_transmitter_enabled(s))\n\n    {\n\n        DPRINTF(\"+++ C+ mode: C+ transmitter disabled\\n\");\n\n        return 0 ;\n\n    }\n\n\n\n    int descriptor = s->currCPlusTxDesc;\n\n\n\n    target_phys_addr_t cplus_tx_ring_desc =\n\n        rtl8139_addr64(s->TxAddr[0], s->TxAddr[1]);\n\n\n\n    /* Normal priority ring */\n\n    cplus_tx_ring_desc += 16 * descriptor;\n\n\n\n    DPRINTF(\"+++ C+ mode reading TX descriptor %d from host memory at \"\n\n        \"%08x0x%08x = 0x\"TARGET_FMT_plx\"\\n\", descriptor, s->TxAddr[1],\n\n        s->TxAddr[0], cplus_tx_ring_desc);\n\n\n\n    uint32_t val, txdw0,txdw1,txbufLO,txbufHI;\n\n\n\n    cpu_physical_memory_read(cplus_tx_ring_desc,    (uint8_t *)&val, 4);\n\n    txdw0 = le32_to_cpu(val);\n\n    cpu_physical_memory_read(cplus_tx_ring_desc+4,  (uint8_t *)&val, 4);\n\n    txdw1 = le32_to_cpu(val);\n\n    cpu_physical_memory_read(cplus_tx_ring_desc+8,  (uint8_t *)&val, 4);\n\n    txbufLO = le32_to_cpu(val);\n\n    cpu_physical_memory_read(cplus_tx_ring_desc+12, (uint8_t *)&val, 4);\n\n    txbufHI = le32_to_cpu(val);\n\n\n\n    DPRINTF(\"+++ C+ mode TX descriptor %d %08x %08x %08x %08x\\n\", descriptor,\n\n        txdw0, txdw1, txbufLO, txbufHI);\n\n\n\n/* w0 ownership flag */\n\n#define CP_TX_OWN (1<<31)\n\n/* w0 end of ring flag */\n\n#define CP_TX_EOR (1<<30)\n\n/* first segment of received packet flag */\n\n#define CP_TX_FS (1<<29)\n\n/* last segment of received packet flag */\n\n#define CP_TX_LS (1<<28)\n\n/* large send packet flag */\n\n#define CP_TX_LGSEN (1<<27)\n\n/* large send MSS mask, bits 16...25 */\n\n#define CP_TC_LGSEN_MSS_MASK ((1 << 12) - 1)\n\n\n\n/* IP checksum offload flag */\n\n#define CP_TX_IPCS (1<<18)\n\n/* UDP checksum offload flag */\n\n#define CP_TX_UDPCS (1<<17)\n\n/* TCP checksum offload flag */\n\n#define CP_TX_TCPCS (1<<16)\n\n\n\n/* w0 bits 0...15 : buffer size */\n\n#define CP_TX_BUFFER_SIZE (1<<16)\n\n#define CP_TX_BUFFER_SIZE_MASK (CP_TX_BUFFER_SIZE - 1)\n\n/* w1 add tag flag */\n\n#define CP_TX_TAGC (1<<17)\n\n/* w1 bits 0...15 : VLAN tag (big endian) */\n\n#define CP_TX_VLAN_TAG_MASK ((1<<16) - 1)\n\n/* w2 low  32bit of Rx buffer ptr */\n\n/* w3 high 32bit of Rx buffer ptr */\n\n\n\n/* set after transmission */\n\n/* FIFO underrun flag */\n\n#define CP_TX_STATUS_UNF (1<<25)\n\n/* transmit error summary flag, valid if set any of three below */\n\n#define CP_TX_STATUS_TES (1<<23)\n\n/* out-of-window collision flag */\n\n#define CP_TX_STATUS_OWC (1<<22)\n\n/* link failure flag */\n\n#define CP_TX_STATUS_LNKF (1<<21)\n\n/* excessive collisions flag */\n\n#define CP_TX_STATUS_EXC (1<<20)\n\n\n\n    if (!(txdw0 & CP_TX_OWN))\n\n    {\n\n        DPRINTF(\"C+ Tx mode : descriptor %d is owned by host\\n\", descriptor);\n\n        return 0 ;\n\n    }\n\n\n\n    DPRINTF(\"+++ C+ Tx mode : transmitting from descriptor %d\\n\", descriptor);\n\n\n\n    if (txdw0 & CP_TX_FS)\n\n    {\n\n        DPRINTF(\"+++ C+ Tx mode : descriptor %d is first segment \"\n\n            \"descriptor\\n\", descriptor);\n\n\n\n        /* reset internal buffer offset */\n\n        s->cplus_txbuffer_offset = 0;\n\n    }\n\n\n\n    int txsize = txdw0 & CP_TX_BUFFER_SIZE_MASK;\n\n    target_phys_addr_t tx_addr = rtl8139_addr64(txbufLO, txbufHI);\n\n\n\n    /* make sure we have enough space to assemble the packet */\n\n    if (!s->cplus_txbuffer)\n\n    {\n\n        s->cplus_txbuffer_len = CP_TX_BUFFER_SIZE;\n\n        s->cplus_txbuffer = qemu_malloc(s->cplus_txbuffer_len);\n\n        s->cplus_txbuffer_offset = 0;\n\n\n\n        DPRINTF(\"+++ C+ mode transmission buffer allocated space %d\\n\",\n\n            s->cplus_txbuffer_len);\n\n    }\n\n\n\n    while (s->cplus_txbuffer && s->cplus_txbuffer_offset + txsize >= s->cplus_txbuffer_len)\n\n    {\n\n        s->cplus_txbuffer_len += CP_TX_BUFFER_SIZE;\n\n        s->cplus_txbuffer = qemu_realloc(s->cplus_txbuffer, s->cplus_txbuffer_len);\n\n\n\n        DPRINTF(\"+++ C+ mode transmission buffer space changed to %d\\n\",\n\n            s->cplus_txbuffer_len);\n\n    }\n\n\n\n    if (!s->cplus_txbuffer)\n\n    {\n\n        /* out of memory */\n\n\n\n        DPRINTF(\"+++ C+ mode transmiter failed to reallocate %d bytes\\n\",\n\n            s->cplus_txbuffer_len);\n\n\n\n        /* update tally counter */\n\n        ++s->tally_counters.TxERR;\n\n        ++s->tally_counters.TxAbt;\n\n\n\n        return 0;\n\n    }\n\n\n\n    /* append more data to the packet */\n\n\n\n    DPRINTF(\"+++ C+ mode transmit reading %d bytes from host memory at \"\n\n        TARGET_FMT_plx\" to offset %d\\n\", txsize, tx_addr,\n\n        s->cplus_txbuffer_offset);\n\n\n\n    cpu_physical_memory_read(tx_addr, s->cplus_txbuffer + s->cplus_txbuffer_offset, txsize);\n\n    s->cplus_txbuffer_offset += txsize;\n\n\n\n    /* seek to next Rx descriptor */\n\n    if (txdw0 & CP_TX_EOR)\n\n    {\n\n        s->currCPlusTxDesc = 0;\n\n    }\n\n    else\n\n    {\n\n        ++s->currCPlusTxDesc;\n\n        if (s->currCPlusTxDesc >= 64)\n\n            s->currCPlusTxDesc = 0;\n\n    }\n\n\n\n    /* transfer ownership to target */\n\n    txdw0 &= ~CP_RX_OWN;\n\n\n\n    /* reset error indicator bits */\n\n    txdw0 &= ~CP_TX_STATUS_UNF;\n\n    txdw0 &= ~CP_TX_STATUS_TES;\n\n    txdw0 &= ~CP_TX_STATUS_OWC;\n\n    txdw0 &= ~CP_TX_STATUS_LNKF;\n\n    txdw0 &= ~CP_TX_STATUS_EXC;\n\n\n\n    /* update ring data */\n\n    val = cpu_to_le32(txdw0);\n\n    cpu_physical_memory_write(cplus_tx_ring_desc,    (uint8_t *)&val, 4);\n\n\n\n    /* Now decide if descriptor being processed is holding the last segment of packet */\n\n    if (txdw0 & CP_TX_LS)\n\n    {\n\n        uint8_t dot1q_buffer_space[VLAN_HLEN];\n\n        uint16_t *dot1q_buffer;\n\n\n\n        DPRINTF(\"+++ C+ Tx mode : descriptor %d is last segment descriptor\\n\",\n\n            descriptor);\n\n\n\n        /* can transfer fully assembled packet */\n\n\n\n        uint8_t *saved_buffer  = s->cplus_txbuffer;\n\n        int      saved_size    = s->cplus_txbuffer_offset;\n\n        int      saved_buffer_len = s->cplus_txbuffer_len;\n\n\n\n        /* create vlan tag */\n\n        if (txdw1 & CP_TX_TAGC) {\n\n            /* the vlan tag is in BE byte order in the descriptor\n\n             * BE + le_to_cpu() + ~swap()~ = cpu */\n\n            DPRINTF(\"+++ C+ Tx mode : inserting vlan tag with \"\"tci: %u\\n\",\n\n                bswap16(txdw1 & CP_TX_VLAN_TAG_MASK));\n\n\n\n            dot1q_buffer = (uint16_t *) dot1q_buffer_space;\n\n            dot1q_buffer[0] = cpu_to_be16(ETH_P_8021Q);\n\n            /* BE + le_to_cpu() + ~cpu_to_le()~ = BE */\n\n            dot1q_buffer[1] = cpu_to_le16(txdw1 & CP_TX_VLAN_TAG_MASK);\n\n        } else {\n\n            dot1q_buffer = NULL;\n\n        }\n\n\n\n        /* reset the card space to protect from recursive call */\n\n        s->cplus_txbuffer = NULL;\n\n        s->cplus_txbuffer_offset = 0;\n\n        s->cplus_txbuffer_len = 0;\n\n\n\n        if (txdw0 & (CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN))\n\n        {\n\n            DPRINTF(\"+++ C+ mode offloaded task checksum\\n\");\n\n\n\n            /* ip packet header */\n\n            ip_header *ip = NULL;\n\n            int hlen = 0;\n\n            uint8_t  ip_protocol = 0;\n\n            uint16_t ip_data_len = 0;\n\n\n\n            uint8_t *eth_payload_data = NULL;\n\n            size_t   eth_payload_len  = 0;\n\n\n\n            int proto = be16_to_cpu(*(uint16_t *)(saved_buffer + 12));\n\n            if (proto == ETH_P_IP)\n\n            {\n\n                DPRINTF(\"+++ C+ mode has IP packet\\n\");\n\n\n\n                /* not aligned */\n\n                eth_payload_data = saved_buffer + ETH_HLEN;\n\n                eth_payload_len  = saved_size   - ETH_HLEN;\n\n\n\n                ip = (ip_header*)eth_payload_data;\n\n\n\n                if (IP_HEADER_VERSION(ip) != IP_HEADER_VERSION_4) {\n\n                    DPRINTF(\"+++ C+ mode packet has bad IP version %d \"\n\n                        \"expected %d\\n\", IP_HEADER_VERSION(ip),\n\n                        IP_HEADER_VERSION_4);\n\n                    ip = NULL;\n\n                } else {\n\n                    hlen = IP_HEADER_LENGTH(ip);\n\n                    ip_protocol = ip->ip_p;\n\n                    ip_data_len = be16_to_cpu(ip->ip_len) - hlen;\n\n                }\n\n            }\n\n\n\n            if (ip)\n\n            {\n\n                if (txdw0 & CP_TX_IPCS)\n\n                {\n\n                    DPRINTF(\"+++ C+ mode need IP checksum\\n\");\n\n\n\n                    if (hlen<sizeof(ip_header) || hlen>eth_payload_len) {/* min header length */\n\n                        /* bad packet header len */\n\n                        /* or packet too short */\n\n                    }\n\n                    else\n\n                    {\n\n                        ip->ip_sum = 0;\n\n                        ip->ip_sum = ip_checksum(ip, hlen);\n\n                        DPRINTF(\"+++ C+ mode IP header len=%d checksum=%04x\\n\",\n\n                            hlen, ip->ip_sum);\n\n                    }\n\n                }\n\n\n\n                if ((txdw0 & CP_TX_LGSEN) && ip_protocol == IP_PROTO_TCP)\n\n                {\n\n#if defined (DEBUG_RTL8139)\n\n                    int large_send_mss = (txdw0 >> 16) & CP_TC_LGSEN_MSS_MASK;\n\n#endif\n\n                    DPRINTF(\"+++ C+ mode offloaded task TSO MTU=%d IP data %d \"\n\n                        \"frame data %d specified MSS=%d\\n\", ETH_MTU,\n\n                        ip_data_len, saved_size - ETH_HLEN, large_send_mss);\n\n\n\n                    int tcp_send_offset = 0;\n\n                    int send_count = 0;\n\n\n\n                    /* maximum IP header length is 60 bytes */\n\n                    uint8_t saved_ip_header[60];\n\n\n\n                    /* save IP header template; data area is used in tcp checksum calculation */\n\n                    memcpy(saved_ip_header, eth_payload_data, hlen);\n\n\n\n                    /* a placeholder for checksum calculation routine in tcp case */\n\n                    uint8_t *data_to_checksum     = eth_payload_data + hlen - 12;\n\n                    //                    size_t   data_to_checksum_len = eth_payload_len  - hlen + 12;\n\n\n\n                    /* pointer to TCP header */\n\n                    tcp_header *p_tcp_hdr = (tcp_header*)(eth_payload_data + hlen);\n\n\n\n                    int tcp_hlen = TCP_HEADER_DATA_OFFSET(p_tcp_hdr);\n\n\n\n                    /* ETH_MTU = ip header len + tcp header len + payload */\n\n                    int tcp_data_len = ip_data_len - tcp_hlen;\n\n                    int tcp_chunk_size = ETH_MTU - hlen - tcp_hlen;\n\n\n\n                    DPRINTF(\"+++ C+ mode TSO IP data len %d TCP hlen %d TCP \"\n\n                        \"data len %d TCP chunk size %d\\n\", ip_data_len,\n\n                        tcp_hlen, tcp_data_len, tcp_chunk_size);\n\n\n\n                    /* note the cycle below overwrites IP header data,\n\n                       but restores it from saved_ip_header before sending packet */\n\n\n\n                    int is_last_frame = 0;\n\n\n\n                    for (tcp_send_offset = 0; tcp_send_offset < tcp_data_len; tcp_send_offset += tcp_chunk_size)\n\n                    {\n\n                        uint16_t chunk_size = tcp_chunk_size;\n\n\n\n                        /* check if this is the last frame */\n\n                        if (tcp_send_offset + tcp_chunk_size >= tcp_data_len)\n\n                        {\n\n                            is_last_frame = 1;\n\n                            chunk_size = tcp_data_len - tcp_send_offset;\n\n                        }\n\n\n\n                        DPRINTF(\"+++ C+ mode TSO TCP seqno %08x\\n\",\n\n                            be32_to_cpu(p_tcp_hdr->th_seq));\n\n\n\n                        /* add 4 TCP pseudoheader fields */\n\n                        /* copy IP source and destination fields */\n\n                        memcpy(data_to_checksum, saved_ip_header + 12, 8);\n\n\n\n                        DPRINTF(\"+++ C+ mode TSO calculating TCP checksum for \"\n\n                            \"packet with %d bytes data\\n\", tcp_hlen +\n\n                            chunk_size);\n\n\n\n                        if (tcp_send_offset)\n\n                        {\n\n                            memcpy((uint8_t*)p_tcp_hdr + tcp_hlen, (uint8_t*)p_tcp_hdr + tcp_hlen + tcp_send_offset, chunk_size);\n\n                        }\n\n\n\n                        /* keep PUSH and FIN flags only for the last frame */\n\n                        if (!is_last_frame)\n\n                        {\n\n                            TCP_HEADER_CLEAR_FLAGS(p_tcp_hdr, TCP_FLAG_PUSH|TCP_FLAG_FIN);\n\n                        }\n\n\n\n                        /* recalculate TCP checksum */\n\n                        ip_pseudo_header *p_tcpip_hdr = (ip_pseudo_header *)data_to_checksum;\n\n                        p_tcpip_hdr->zeros      = 0;\n\n                        p_tcpip_hdr->ip_proto   = IP_PROTO_TCP;\n\n                        p_tcpip_hdr->ip_payload = cpu_to_be16(tcp_hlen + chunk_size);\n\n\n\n                        p_tcp_hdr->th_sum = 0;\n\n\n\n                        int tcp_checksum = ip_checksum(data_to_checksum, tcp_hlen + chunk_size + 12);\n\n                        DPRINTF(\"+++ C+ mode TSO TCP checksum %04x\\n\",\n\n                            tcp_checksum);\n\n\n\n                        p_tcp_hdr->th_sum = tcp_checksum;\n\n\n\n                        /* restore IP header */\n\n                        memcpy(eth_payload_data, saved_ip_header, hlen);\n\n\n\n                        /* set IP data length and recalculate IP checksum */\n\n                        ip->ip_len = cpu_to_be16(hlen + tcp_hlen + chunk_size);\n\n\n\n                        /* increment IP id for subsequent frames */\n\n                        ip->ip_id = cpu_to_be16(tcp_send_offset/tcp_chunk_size + be16_to_cpu(ip->ip_id));\n\n\n\n                        ip->ip_sum = 0;\n\n                        ip->ip_sum = ip_checksum(eth_payload_data, hlen);\n\n                        DPRINTF(\"+++ C+ mode TSO IP header len=%d \"\n\n                            \"checksum=%04x\\n\", hlen, ip->ip_sum);\n\n\n\n                        int tso_send_size = ETH_HLEN + hlen + tcp_hlen + chunk_size;\n\n                        DPRINTF(\"+++ C+ mode TSO transferring packet size \"\n\n                            \"%d\\n\", tso_send_size);\n\n                        rtl8139_transfer_frame(s, saved_buffer, tso_send_size,\n\n                            0, (uint8_t *) dot1q_buffer);\n\n\n\n                        /* add transferred count to TCP sequence number */\n\n                        p_tcp_hdr->th_seq = cpu_to_be32(chunk_size + be32_to_cpu(p_tcp_hdr->th_seq));\n\n                        ++send_count;\n\n                    }\n\n\n\n                    /* Stop sending this frame */\n\n                    saved_size = 0;\n\n                }\n\n                else if (txdw0 & (CP_TX_TCPCS|CP_TX_UDPCS))\n\n                {\n\n                    DPRINTF(\"+++ C+ mode need TCP or UDP checksum\\n\");\n\n\n\n                    /* maximum IP header length is 60 bytes */\n\n                    uint8_t saved_ip_header[60];\n\n                    memcpy(saved_ip_header, eth_payload_data, hlen);\n\n\n\n                    uint8_t *data_to_checksum     = eth_payload_data + hlen - 12;\n\n                    //                    size_t   data_to_checksum_len = eth_payload_len  - hlen + 12;\n\n\n\n                    /* add 4 TCP pseudoheader fields */\n\n                    /* copy IP source and destination fields */\n\n                    memcpy(data_to_checksum, saved_ip_header + 12, 8);\n\n\n\n                    if ((txdw0 & CP_TX_TCPCS) && ip_protocol == IP_PROTO_TCP)\n\n                    {\n\n                        DPRINTF(\"+++ C+ mode calculating TCP checksum for \"\n\n                            \"packet with %d bytes data\\n\", ip_data_len);\n\n\n\n                        ip_pseudo_header *p_tcpip_hdr = (ip_pseudo_header *)data_to_checksum;\n\n                        p_tcpip_hdr->zeros      = 0;\n\n                        p_tcpip_hdr->ip_proto   = IP_PROTO_TCP;\n\n                        p_tcpip_hdr->ip_payload = cpu_to_be16(ip_data_len);\n\n\n\n                        tcp_header* p_tcp_hdr = (tcp_header *) (data_to_checksum+12);\n\n\n\n                        p_tcp_hdr->th_sum = 0;\n\n\n\n                        int tcp_checksum = ip_checksum(data_to_checksum, ip_data_len + 12);\n\n                        DPRINTF(\"+++ C+ mode TCP checksum %04x\\n\",\n\n                            tcp_checksum);\n\n\n\n                        p_tcp_hdr->th_sum = tcp_checksum;\n\n                    }\n\n                    else if ((txdw0 & CP_TX_UDPCS) && ip_protocol == IP_PROTO_UDP)\n\n                    {\n\n                        DPRINTF(\"+++ C+ mode calculating UDP checksum for \"\n\n                            \"packet with %d bytes data\\n\", ip_data_len);\n\n\n\n                        ip_pseudo_header *p_udpip_hdr = (ip_pseudo_header *)data_to_checksum;\n\n                        p_udpip_hdr->zeros      = 0;\n\n                        p_udpip_hdr->ip_proto   = IP_PROTO_UDP;\n\n                        p_udpip_hdr->ip_payload = cpu_to_be16(ip_data_len);\n\n\n\n                        udp_header *p_udp_hdr = (udp_header *) (data_to_checksum+12);\n\n\n\n                        p_udp_hdr->uh_sum = 0;\n\n\n\n                        int udp_checksum = ip_checksum(data_to_checksum, ip_data_len + 12);\n\n                        DPRINTF(\"+++ C+ mode UDP checksum %04x\\n\",\n\n                            udp_checksum);\n\n\n\n                        p_udp_hdr->uh_sum = udp_checksum;\n\n                    }\n\n\n\n                    /* restore IP header */\n\n                    memcpy(eth_payload_data, saved_ip_header, hlen);\n\n                }\n\n            }\n\n        }\n\n\n\n        /* update tally counter */\n\n        ++s->tally_counters.TxOk;\n\n\n\n        DPRINTF(\"+++ C+ mode transmitting %d bytes packet\\n\", saved_size);\n\n\n\n        rtl8139_transfer_frame(s, saved_buffer, saved_size, 1,\n\n            (uint8_t *) dot1q_buffer);\n\n\n\n        /* restore card space if there was no recursion and reset offset */\n\n        if (!s->cplus_txbuffer)\n\n        {\n\n            s->cplus_txbuffer        = saved_buffer;\n\n            s->cplus_txbuffer_len    = saved_buffer_len;\n\n            s->cplus_txbuffer_offset = 0;\n\n        }\n\n        else\n\n        {\n\n            qemu_free(saved_buffer);\n\n        }\n\n    }\n\n    else\n\n    {\n\n        DPRINTF(\"+++ C+ mode transmission continue to next descriptor\\n\");\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 19177, "_split": "valid", "_hash": "917a6ce04042d442457ff2a2089babe7"}
{"project": "qemu", "commit_id": "fe40e627c51e38922b64b02b6163aea4b6aad896", "target": 0, "func": "static void object_set_link_property(Object *obj, Visitor *v, void *opaque,\n\n                                     const char *name, Error **errp)\n\n{\n\n    Object **child = opaque;\n\n    bool ambiguous = false;\n\n    const char *type;\n\n    char *path;\n\n\n\n    type = object_property_get_type(obj, name, NULL);\n\n\n\n    visit_type_str(v, &path, name, errp);\n\n\n\n    if (*child) {\n\n        object_unref(*child);\n\n    }\n\n\n\n    if (strcmp(path, \"\") != 0) {\n\n        Object *target;\n\n\n\n        target = object_resolve_path(path, &ambiguous);\n\n        if (target) {\n\n            gchar *target_type;\n\n\n\n            target_type = g_strdup_printf(\"link<%s>\",\n\n                                          object_get_typename(OBJECT(target)));\n\n            if (strcmp(target_type, type) == 0) {\n\n                *child = target;\n\n                object_ref(target);\n\n            } else {\n\n                error_set(errp, QERR_INVALID_PARAMETER_TYPE, name, type);\n\n            }\n\n\n\n            g_free(target_type);\n\n        } else {\n\n            error_set(errp, QERR_DEVICE_NOT_FOUND, path);\n\n        }\n\n    } else {\n\n        *child = NULL;\n\n    }\n\n\n\n    g_free(path);\n\n}\n", "idx": 19181, "_split": "valid", "_hash": "ec9c4ddb0a24aa5631e3f0f58064463c"}
{"project": "qemu", "commit_id": "88affa1c77c9019f3450f851495997897bd14e40", "target": 1, "func": "static void do_info_trace(Monitor *mon)\n\n{\n\n    st_print_trace((FILE *)mon, &monitor_fprintf);\n\n}\n", "idx": 19213, "_split": "valid", "_hash": "7d7ae09f9272bf9e0c00e3afc09f6e1c"}
{"project": "qemu", "commit_id": "27af7d6ea5015e5ef1f7985eab94a8a218267a2b", "target": 1, "func": "static int save_xbzrle_page(QEMUFile *f, uint8_t **current_data,\n\n                            ram_addr_t current_addr, RAMBlock *block,\n\n                            ram_addr_t offset, int cont, bool last_stage)\n\n{\n\n    int encoded_len = 0, bytes_sent = -1;\n\n    uint8_t *prev_cached_page;\n\n\n\n    if (!cache_is_cached(XBZRLE.cache, current_addr)) {\n\n        acct_info.xbzrle_cache_miss++;\n\n        if (!last_stage) {\n\n            if (cache_insert(XBZRLE.cache, current_addr, *current_data) == -1) {\n\n                return -1;\n\n            } else {\n\n                /* update *current_data when the page has been\n\n                   inserted into cache */\n\n                *current_data = get_cached_data(XBZRLE.cache, current_addr);\n\n            }\n\n        }\n\n        return -1;\n\n    }\n\n\n\n    prev_cached_page = get_cached_data(XBZRLE.cache, current_addr);\n\n\n\n    /* save current buffer into memory */\n\n    memcpy(XBZRLE.current_buf, *current_data, TARGET_PAGE_SIZE);\n\n\n\n    /* XBZRLE encoding (if there is no overflow) */\n\n    encoded_len = xbzrle_encode_buffer(prev_cached_page, XBZRLE.current_buf,\n\n                                       TARGET_PAGE_SIZE, XBZRLE.encoded_buf,\n\n                                       TARGET_PAGE_SIZE);\n\n    if (encoded_len == 0) {\n\n        DPRINTF(\"Skipping unmodified page\\n\");\n\n        return 0;\n\n    } else if (encoded_len == -1) {\n\n        DPRINTF(\"Overflow\\n\");\n\n        acct_info.xbzrle_overflows++;\n\n        /* update data in the cache */\n\n        if (!last_stage) {\n\n            memcpy(prev_cached_page, *current_data, TARGET_PAGE_SIZE);\n\n            *current_data = prev_cached_page;\n\n        }\n\n        return -1;\n\n    }\n\n\n\n    /* we need to update the data in the cache, in order to get the same data */\n\n    if (!last_stage) {\n\n        memcpy(prev_cached_page, XBZRLE.current_buf, TARGET_PAGE_SIZE);\n\n    }\n\n\n\n    /* Send XBZRLE based compressed page */\n\n    bytes_sent = save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_XBZRLE);\n\n    qemu_put_byte(f, ENCODING_FLAG_XBZRLE);\n\n    qemu_put_be16(f, encoded_len);\n\n    qemu_put_buffer(f, XBZRLE.encoded_buf, encoded_len);\n\n    bytes_sent += encoded_len + 1 + 2;\n\n    acct_info.xbzrle_pages++;\n\n    acct_info.xbzrle_bytes += bytes_sent;\n\n\n\n    return bytes_sent;\n\n}\n", "idx": 19226, "_split": "valid", "_hash": "2fe4740788286cb1c2cfab0daa476659"}
{"project": "qemu", "commit_id": "444bc908611ccaf4512dc37c33ac3b54d873a62b", "target": 1, "func": "static void scsi_unmap_complete(void *opaque, int ret)\n\n{\n\n    UnmapCBData *data = opaque;\n\n    SCSIDiskReq *r = data->r;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint64_t sector_num;\n\n    uint32_t nb_sectors;\n\n\n\n    r->req.aiocb = NULL;\n\n    if (ret < 0) {\n\n        if (scsi_handle_rw_error(r, -ret)) {\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    if (data->count > 0 && !r->req.io_canceled) {\n\n        sector_num = ldq_be_p(&data->inbuf[0]);\n\n        nb_sectors = ldl_be_p(&data->inbuf[8]) & 0xffffffffULL;\n\n        if (sector_num > sector_num + nb_sectors ||\n\n            sector_num + nb_sectors - 1 > s->qdev.max_lba) {\n\n            scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n\n            goto done;\n\n        }\n\n\n\n        r->req.aiocb = bdrv_aio_discard(s->qdev.conf.bs,\n\n                                        sector_num * (s->qdev.blocksize / 512),\n\n                                        nb_sectors * (s->qdev.blocksize / 512),\n\n                                        scsi_unmap_complete, data);\n\n        data->count--;\n\n        data->inbuf += 16;\n\n        return;\n\n    }\n\n\n\ndone:\n\n    if (data->count == 0) {\n\n        scsi_req_complete(&r->req, GOOD);\n\n    }\n\n    if (!r->req.io_canceled) {\n\n        scsi_req_unref(&r->req);\n\n    }\n\n    g_free(data);\n\n}\n", "idx": 19227, "_split": "valid", "_hash": "651f934c551a90d1ba668dbf8c46a048"}
{"project": "qemu", "commit_id": "f1710638edb2e98008c2a733ffda63ef32b50411", "target": 1, "func": "int qcrypto_hash_bytesv(QCryptoHashAlgorithm alg,\n\n                        const struct iovec *iov,\n\n                        size_t niov,\n\n                        uint8_t **result,\n\n                        size_t *resultlen,\n\n                        Error **errp)\n\n{\n\n#ifdef CONFIG_AF_ALG\n\n    int ret;\n\n\n\n    ret = qcrypto_hash_afalg_driver.hash_bytesv(alg, iov, niov,\n\n                                                result, resultlen,\n\n                                                errp);\n\n    if (ret == 0) {\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * TODO:\n\n     * Maybe we should treat some afalg errors as fatal\n\n     */\n\n    error_free(*errp);\n\n#endif\n\n\n\n    return qcrypto_hash_lib_driver.hash_bytesv(alg, iov, niov,\n\n                                               result, resultlen,\n\n                                               errp);\n\n}\n", "idx": 19233, "_split": "valid", "_hash": "92d977ad482f644a99ab5e599203e29b"}
{"project": "qemu", "commit_id": "5c843af22604edecda10d4bb89d4eede9e1bd3d0", "target": 1, "func": "int net_init_slirp(const Netdev *netdev, const char *name,\n\n                   NetClientState *peer, Error **errp)\n\n{\n\n    /* FIXME error_setg(errp, ...) on failure */\n\n    struct slirp_config_str *config;\n\n    char *vnet;\n\n    int ret;\n\n    const NetdevUserOptions *user;\n\n    const char **dnssearch;\n\n    bool ipv4 = true, ipv6 = true;\n\n\n\n    assert(netdev->type == NET_CLIENT_DRIVER_USER);\n\n    user = &netdev->u.user;\n\n\n\n    if ((user->has_ipv6 && user->ipv6 && !user->has_ipv4) ||\n\n        (user->has_ipv4 && !user->ipv4)) {\n\n        ipv4 = 0;\n\n    }\n\n    if ((user->has_ipv4 && user->ipv4 && !user->has_ipv6) ||\n\n        (user->has_ipv6 && !user->ipv6)) {\n\n        ipv6 = 0;\n\n    }\n\n\n\n    vnet = user->has_net ? g_strdup(user->net) :\n\n           user->has_ip  ? g_strdup_printf(\"%s/24\", user->ip) :\n\n           NULL;\n\n\n\n    dnssearch = slirp_dnssearch(user->dnssearch);\n\n\n\n    /* all optional fields are initialized to \"all bits zero\" */\n\n\n\n    net_init_slirp_configs(user->hostfwd, SLIRP_CFG_HOSTFWD);\n\n    net_init_slirp_configs(user->guestfwd, 0);\n\n\n\n    ret = net_slirp_init(peer, \"user\", name, user->q_restrict,\n\n                         ipv4, vnet, user->host,\n\n                         ipv6, user->ipv6_prefix, user->ipv6_prefixlen,\n\n                         user->ipv6_host, user->hostname, user->tftp,\n\n                         user->bootfile, user->dhcpstart,\n\n                         user->dns, user->ipv6_dns, user->smb,\n\n                         user->smbserver, dnssearch);\n\n\n\n    while (slirp_configs) {\n\n        config = slirp_configs;\n\n        slirp_configs = config->next;\n\n        g_free(config);\n\n    }\n\n\n\n    g_free(vnet);\n\n    g_free(dnssearch);\n\n\n\n    return ret;\n\n}\n", "idx": 19248, "_split": "valid", "_hash": "bd11ed2488b50b5b587b1c041c266eab"}
{"project": "qemu", "commit_id": "b0ba0b9b6b402d738f11f27eea6c94d97bf84cbf", "target": 0, "func": "int pcnet_can_receive(NetClientState *nc)\n\n{\n\n    PCNetState *s = qemu_get_nic_opaque(nc);\n\n    if (CSR_STOP(s) || CSR_SPND(s))\n\n        return 0;\n\n\n\n    return sizeof(s->buffer)-16;\n\n}\n", "idx": 19252, "_split": "valid", "_hash": "fa0bab418d9de310a8730113bb16ecaf"}
{"project": "qemu", "commit_id": "6a81dd172cd5d03fce593741629cb4c78fff10cb", "target": 0, "func": "void *kvmppc_create_spapr_tce(uint32_t liobn, uint32_t window_size, int *pfd,\n\n                              bool vfio_accel)\n\n{\n\n    struct kvm_create_spapr_tce args = {\n\n        .liobn = liobn,\n\n        .window_size = window_size,\n\n    };\n\n    long len;\n\n    int fd;\n\n    void *table;\n\n\n\n    /* Must set fd to -1 so we don't try to munmap when called for\n\n     * destroying the table, which the upper layers -will- do\n\n     */\n\n    *pfd = -1;\n\n    if (!cap_spapr_tce || (vfio_accel && !cap_spapr_vfio)) {\n\n        return NULL;\n\n    }\n\n\n\n    fd = kvm_vm_ioctl(kvm_state, KVM_CREATE_SPAPR_TCE, &args);\n\n    if (fd < 0) {\n\n        fprintf(stderr, \"KVM: Failed to create TCE table for liobn 0x%x\\n\",\n\n                liobn);\n\n        return NULL;\n\n    }\n\n\n\n    len = (window_size / SPAPR_TCE_PAGE_SIZE) * sizeof(uint64_t);\n\n    /* FIXME: round this up to page size */\n\n\n\n    table = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\n    if (table == MAP_FAILED) {\n\n        fprintf(stderr, \"KVM: Failed to map TCE table for liobn 0x%x\\n\",\n\n                liobn);\n\n        close(fd);\n\n        return NULL;\n\n    }\n\n\n\n    *pfd = fd;\n\n    return table;\n\n}\n", "idx": 19264, "_split": "valid", "_hash": "599011d1042757b89a055cb1e00968e7"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void exynos4210_pmu_write(void *opaque, target_phys_addr_t offset,\n\n                                 uint64_t val, unsigned size)\n\n{\n\n    Exynos4210PmuState *s = (Exynos4210PmuState *)opaque;\n\n    unsigned i;\n\n    const Exynos4210PmuReg *reg_p = exynos4210_pmu_regs;\n\n\n\n    for (i = 0; i < PMU_NUM_OF_REGISTERS; i++) {\n\n        if (reg_p->offset == offset) {\n\n            PRINT_DEBUG_EXTEND(\"%s <0x%04x> <- 0x%04x\\n\", reg_p->name,\n\n                    (uint32_t)offset, (uint32_t)val);\n\n            s->reg[i] = val;\n\n            return;\n\n        }\n\n        reg_p++;\n\n    }\n\n    PRINT_DEBUG(\"QEMU PMU ERROR: bad write offset 0x%04x\\n\", (uint32_t)offset);\n\n}\n", "idx": 19278, "_split": "valid", "_hash": "dd6f3538130e1ffd9b2e9b3464e5dc95"}
{"project": "qemu", "commit_id": "45416789e8ccced568a4984af61974adfbfa0f62", "target": 0, "func": "static int omap_validate_emiff_addr(struct omap_mpu_state_s *s,\n\n                target_phys_addr_t addr)\n\n{\n\n    return addr >= OMAP_EMIFF_BASE && addr < OMAP_EMIFF_BASE + s->sdram_size;\n\n}\n", "idx": 19281, "_split": "valid", "_hash": "c3a352f247b227cdffab7a13cadde02d"}
{"project": "qemu", "commit_id": "c96a1c0ba6b88fb47ca734013ae9b9248f78fbb4", "target": 0, "func": "static const CPUArchIdList *pc_possible_cpu_arch_ids(MachineState *machine)\n\n{\n\n    assert(machine->possible_cpus);\n\n    return machine->possible_cpus;\n\n}\n", "idx": 19294, "_split": "valid", "_hash": "c6d0d2ab45deceebed15a03ebf1d7f72"}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_update(void)\n\n{\n\n    int i, delta;\n\n\n\n    if (term_cmd_buf_size != term_last_cmd_buf_size ||\n\n        memcmp(term_cmd_buf, term_last_cmd_buf, term_cmd_buf_size) != 0) {\n\n        for(i = 0; i < term_last_cmd_buf_index; i++) {\n\n            term_printf(\"\\033[D\");\n\n        }\n\n        term_cmd_buf[term_cmd_buf_size] = '\\0';\n\n        term_printf(\"%s\", term_cmd_buf);\n\n        term_printf(\"\\033[K\");\n\n        memcpy(term_last_cmd_buf, term_cmd_buf, term_cmd_buf_size);\n\n        term_last_cmd_buf_size = term_cmd_buf_size;\n\n        term_last_cmd_buf_index = term_cmd_buf_size;\n\n    }\n\n    if (term_cmd_buf_index != term_last_cmd_buf_index) {\n\n        delta = term_cmd_buf_index - term_last_cmd_buf_index;\n\n        if (delta > 0) {\n\n            for(i = 0;i < delta; i++) {\n\n                term_printf(\"\\033[C\");\n\n            }\n\n        } else {\n\n            delta = -delta;\n\n            for(i = 0;i < delta; i++) {\n\n                term_printf(\"\\033[D\");\n\n            }\n\n        }\n\n        term_last_cmd_buf_index = term_cmd_buf_index;\n\n    }\n\n    term_flush();\n\n}\n", "idx": 19325, "_split": "valid", "_hash": "a3cab23c3a024987aac87edd28ffe2ba"}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static uint32_t qvirtio_pci_config_readl(QVirtioDevice *d, uint64_t off)\n\n{\n\n    QVirtioPCIDevice *dev = (QVirtioPCIDevice *)d;\n\n    uint32_t value;\n\n\n\n    value = qpci_io_readl(dev->pdev, CONFIG_BASE(dev) + off);\n\n    if (qvirtio_is_big_endian(d)) {\n\n        value = bswap32(value);\n\n    }\n\n    return value;\n\n}\n", "idx": 19357, "_split": "valid", "_hash": "a8d3cb2e0be10b9de85588c511429ef8"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "int blk_mig_active(void)\n\n{\n\n    return !QSIMPLEQ_EMPTY(&block_mig_state.bmds_list);\n\n}\n", "idx": 19366, "_split": "valid", "_hash": "d242e4b023020aa1513f726b75e7a511"}
{"project": "qemu", "commit_id": "41742767bfa8127954b6f57b39b590adcde3ac6c", "target": 0, "func": "static void isapc_machine_options(MachineClass *m)\n\n{\n\n    pc_common_machine_options(m);\n\n    m->desc = \"ISA-only PC\";\n\n    m->max_cpus = 1;\n\n}\n", "idx": 19372, "_split": "valid", "_hash": "f3250050dd94e6d3a08cb3618692f53d"}
{"project": "qemu", "commit_id": "b544c1aba8681c2fe5d6715fbd37cf6caf1bc7bb", "target": 1, "func": "static inline AIOReq *alloc_aio_req(BDRVSheepdogState *s, SheepdogAIOCB *acb,\n\n                                    uint64_t oid, unsigned int data_len,\n\n                                    uint64_t offset, uint8_t flags,\n\n                                    uint64_t base_oid, unsigned int iov_offset)\n\n{\n\n    AIOReq *aio_req;\n\n\n\n    aio_req = g_malloc(sizeof(*aio_req));\n\n    aio_req->aiocb = acb;\n\n    aio_req->iov_offset = iov_offset;\n\n    aio_req->oid = oid;\n\n    aio_req->base_oid = base_oid;\n\n    aio_req->offset = offset;\n\n    aio_req->data_len = data_len;\n\n    aio_req->flags = flags;\n\n    aio_req->id = s->aioreq_seq_num++;\n\n\n\n    acb->nr_pending++;\n\n    return aio_req;\n\n}\n", "idx": 19423, "_split": "valid", "_hash": "9108878dc25534579ce09636daebd4a4"}
{"project": "qemu", "commit_id": "ded6ddc5a7b95217557fa360913d1213e12d4a6d", "target": 0, "func": "static int32_t scsi_target_send_command(SCSIRequest *req, uint8_t *buf)\n\n{\n\n    SCSITargetReq *r = DO_UPCAST(SCSITargetReq, req, req);\n\n\n\n    switch (buf[0]) {\n\n    case REPORT_LUNS:\n\n        if (!scsi_target_emulate_report_luns(r)) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case INQUIRY:\n\n        if (!scsi_target_emulate_inquiry(r)) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case REQUEST_SENSE:\n\n        scsi_target_alloc_buf(&r->req, scsi_sense_len(req));\n\n        r->len = scsi_device_get_sense(r->req.dev, r->buf,\n\n                                       MIN(req->cmd.xfer, r->buf_len),\n\n                                       (req->cmd.buf[1] & 1) == 0);\n\n        if (r->req.dev->sense_is_ua) {\n\n            scsi_device_unit_attention_reported(req->dev);\n\n            r->req.dev->sense_len = 0;\n\n            r->req.dev->sense_is_ua = false;\n\n        }\n\n        break;\n\n    case TEST_UNIT_READY:\n\n        break;\n\n    default:\n\n        scsi_req_build_sense(req, SENSE_CODE(LUN_NOT_SUPPORTED));\n\n        scsi_req_complete(req, CHECK_CONDITION);\n\n        return 0;\n\n    illegal_request:\n\n        scsi_req_build_sense(req, SENSE_CODE(INVALID_FIELD));\n\n        scsi_req_complete(req, CHECK_CONDITION);\n\n        return 0;\n\n    }\n\n\n\n    if (!r->len) {\n\n        scsi_req_complete(req, GOOD);\n\n    }\n\n    return r->len;\n\n}\n", "idx": 19476, "_split": "valid", "_hash": "30785914efc1a54f38c4a75ea0286505"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline int onenand_load_spare(OneNANDState *s, int sec, int secn,\n\n                void *dest)\n\n{\n\n    uint8_t buf[512];\n\n\n\n    if (s->bdrv_cur) {\n\n        if (bdrv_read(s->bdrv_cur, s->secs_cur + (sec >> 5), buf, 1) < 0)\n\n            return 1;\n\n        memcpy(dest, buf + ((sec & 31) << 4), secn << 4);\n\n    } else if (sec + secn > s->secs_cur)\n\n        return 1;\n\n    else\n\n        memcpy(dest, s->current + (s->secs_cur << 9) + (sec << 4), secn << 4);\n\n \n\n    return 0;\n\n}\n", "idx": 19479, "_split": "valid", "_hash": "3d8c3408749ee5a6c708c3cd2c79beff"}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "static inline void gen_op_fcmps(int fccno, TCGv_i32 r_rs1, TCGv_i32 r_rs2)\n\n{\n\n    switch (fccno) {\n\n    case 0:\n\n        gen_helper_fcmps(cpu_env, r_rs1, r_rs2);\n\n        break;\n\n    case 1:\n\n        gen_helper_fcmps_fcc1(cpu_env, r_rs1, r_rs2);\n\n        break;\n\n    case 2:\n\n        gen_helper_fcmps_fcc2(cpu_env, r_rs1, r_rs2);\n\n        break;\n\n    case 3:\n\n        gen_helper_fcmps_fcc3(cpu_env, r_rs1, r_rs2);\n\n        break;\n\n    }\n\n}\n", "idx": 19480, "_split": "valid", "_hash": "58cafa9f293b7d616944865ba2c5adf1"}
{"project": "qemu", "commit_id": "fd859081453f94c3cbd6527289e41b7fddbf645f", "target": 0, "func": "static void tpm_tis_receive_cb(TPMState *s, uint8_t locty)\n\n{\n\n    TPMTISEmuState *tis = &s->s.tis;\n\n\n\n    assert(s->locty_number == locty);\n\n\n\n    qemu_bh_schedule(tis->bh);\n\n}\n", "idx": 19489, "_split": "valid", "_hash": "1ee6603f5344350a8465bfd8d68bcea1"}
{"project": "qemu", "commit_id": "f7c11b535040df31cc8bc3b1f0c33f546073ee62", "target": 0, "func": "void cpu_physical_memory_unmap(void *buffer, target_phys_addr_t len,\n\n                               int is_write, target_phys_addr_t access_len)\n\n{\n\n    if (buffer != bounce.buffer) {\n\n        if (is_write) {\n\n            ram_addr_t addr1 = qemu_ram_addr_from_host(buffer);\n\n            while (access_len) {\n\n                unsigned l;\n\n                l = TARGET_PAGE_SIZE;\n\n                if (l > access_len)\n\n                    l = access_len;\n\n                if (!cpu_physical_memory_is_dirty(addr1)) {\n\n                    /* invalidate code */\n\n                    tb_invalidate_phys_page_range(addr1, addr1 + l, 0);\n\n                    /* set dirty bit */\n\n                    phys_ram_dirty[addr1 >> TARGET_PAGE_BITS] |=\n\n                        (0xff & ~CODE_DIRTY_FLAG);\n\n                }\n\n                addr1 += l;\n\n                access_len -= l;\n\n            }\n\n        }\n\n        return;\n\n    }\n\n    if (is_write) {\n\n        cpu_physical_memory_write(bounce.addr, bounce.buffer, access_len);\n\n    }\n\n    qemu_vfree(bounce.buffer);\n\n    bounce.buffer = NULL;\n\n    cpu_notify_map_clients();\n\n}\n", "idx": 19504, "_split": "valid", "_hash": "937ed3a4c70a5479055688481fa4a120"}
{"project": "qemu", "commit_id": "4f2d3d705c1ae7dce29254e2c4645c84e77a74d4", "target": 0, "func": "void qdev_prop_set_defaults(DeviceState *dev, Property *props)\n\n{\n\n    if (!props)\n\n        return;\n\n    while (props->name) {\n\n        if (props->defval) {\n\n            qdev_prop_cpy(dev, props, props->defval);\n\n        }\n\n        props++;\n\n    }\n\n}\n", "idx": 19520, "_split": "valid", "_hash": "fe4032ab23b5bae058248c472dd32b58"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static inline void gen_op_evabs(TCGv_i32 ret, TCGv_i32 arg1)\n\n{\n\n    int l1 = gen_new_label();\n\n    int l2 = gen_new_label();\n\n\n\n    tcg_gen_brcondi_i32(TCG_COND_GE, arg1, 0, l1);\n\n    tcg_gen_neg_i32(ret, arg1);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_mov_i32(ret, arg1);\n\n    gen_set_label(l2);\n\n}\n", "idx": 19523, "_split": "valid", "_hash": "41e63c12fa31c586efebecf09459a0ef"}
{"project": "qemu", "commit_id": "d85fa9eb87ba736d2d5ce342fc35f507c8fe29f2", "target": 1, "func": "static coroutine_fn int qemu_gluster_co_flush_to_disk(BlockDriverState *bs)\n\n{\n\n    int ret;\n\n    GlusterAIOCB acb;\n\n    BDRVGlusterState *s = bs->opaque;\n\n\n\n    acb.size = 0;\n\n    acb.ret = 0;\n\n    acb.coroutine = qemu_coroutine_self();\n\n    acb.aio_context = bdrv_get_aio_context(bs);\n\n\n\n    ret = glfs_fsync_async(s->fd, gluster_finish_aiocb, &acb);\n\n    if (ret < 0) {\n\n        return -errno;\n\n    }\n\n\n\n    qemu_coroutine_yield();\n\n    return acb.ret;\n\n}\n", "idx": 19530, "_split": "valid", "_hash": "bb44a851f73a61c277645ee6d45c9d02"}
{"project": "qemu", "commit_id": "8f94a6e40e46cbc8e8014da825d25824b1803b34", "target": 1, "func": "static DriveInfo *blockdev_init(QemuOpts *all_opts,\n\n                                BlockInterfaceType block_default_type)\n\n{\n\n    const char *buf;\n\n    const char *file = NULL;\n\n    const char *serial;\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    int max_devs;\n\n    int index;\n\n    int ro = 0;\n\n    int bdrv_flags = 0;\n\n    int on_read_error, on_write_error;\n\n    const char *devaddr;\n\n    DriveInfo *dinfo;\n\n    ThrottleConfig cfg;\n\n    int snapshot = 0;\n\n    bool copy_on_read;\n\n    int ret;\n\n    Error *error = NULL;\n\n    QemuOpts *opts;\n\n    QDict *bs_opts;\n\n    const char *id;\n\n    bool has_driver_specific_opts;\n\n    BlockDriver *drv = NULL;\n\n\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    media = MEDIA_DISK;\n\n\n\n    /* Check common options by copying from all_opts to opts, all other options\n\n     * are stored in bs_opts. */\n\n    id = qemu_opts_id(all_opts);\n\n    opts = qemu_opts_create(&qemu_common_drive_opts, id, 1, &error);\n\n    if (error_is_set(&error)) {\n\n        qerror_report_err(error);\n\n        error_free(error);\n\n        return NULL;\n\n    }\n\n\n\n    bs_opts = qdict_new();\n\n    qemu_opts_to_qdict(all_opts, bs_opts);\n\n    qemu_opts_absorb_qdict(opts, bs_opts, &error);\n\n    if (error_is_set(&error)) {\n\n        qerror_report_err(error);\n\n        error_free(error);\n\n        return NULL;\n\n    }\n\n\n\n    if (id) {\n\n        qdict_del(bs_opts, \"id\");\n\n    }\n\n\n\n    has_driver_specific_opts = !!qdict_size(bs_opts);\n\n\n\n    /* extract parameters */\n\n    bus_id  = qemu_opt_get_number(opts, \"bus\", 0);\n\n    unit_id = qemu_opt_get_number(opts, \"unit\", -1);\n\n    index   = qemu_opt_get_number(opts, \"index\", -1);\n\n\n\n    cyls  = qemu_opt_get_number(opts, \"cyls\", 0);\n\n    heads = qemu_opt_get_number(opts, \"heads\", 0);\n\n    secs  = qemu_opt_get_number(opts, \"secs\", 0);\n\n\n\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n    ro = qemu_opt_get_bool(opts, \"read-only\", 0);\n\n    copy_on_read = qemu_opt_get_bool(opts, \"copy-on-read\", false);\n\n\n\n    file = qemu_opt_get(opts, \"file\");\n\n    serial = qemu_opt_get(opts, \"serial\");\n\n\n\n    if ((buf = qemu_opt_get(opts, \"if\")) != NULL) {\n\n        for (type = 0; type < IF_COUNT && strcmp(buf, if_name[type]); type++)\n\n            ;\n\n        if (type == IF_COUNT) {\n\n            error_report(\"unsupported bus type '%s'\", buf);\n\n            return NULL;\n\n\t}\n\n    } else {\n\n        type = block_default_type;\n\n    }\n\n\n\n    max_devs = if_max_devs[type];\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1) {\n\n            error_report(\"invalid physical cyls number\");\n\n\t    return NULL;\n\n\t}\n\n        if (heads < 1) {\n\n            error_report(\"invalid physical heads number\");\n\n\t    return NULL;\n\n\t}\n\n        if (secs < 1) {\n\n            error_report(\"invalid physical secs number\");\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"trans\")) != NULL) {\n\n        if (!cyls) {\n\n            error_report(\"'%s' trans must be used with cyls, heads and secs\",\n\n                         buf);\n\n            return NULL;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            error_report(\"'%s' invalid translation type\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"media\")) != NULL) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                error_report(\"CHS can't be set with media=%s\", buf);\n\n\t        return NULL;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    error_report(\"'%s' invalid media\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"discard\")) != NULL) {\n\n        if (bdrv_parse_discard_flags(buf, &bdrv_flags) != 0) {\n\n            error_report(\"invalid discard option\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"cache.writeback\", true)) {\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    }\n\n    if (qemu_opt_get_bool(opts, \"cache.direct\", false)) {\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    }\n\n    if (qemu_opt_get_bool(opts, \"cache.no-flush\", false)) {\n\n        bdrv_flags |= BDRV_O_NO_FLUSH;\n\n    }\n\n\n\n#ifdef CONFIG_LINUX_AIO\n\n    if ((buf = qemu_opt_get(opts, \"aio\")) != NULL) {\n\n        if (!strcmp(buf, \"native\")) {\n\n            bdrv_flags |= BDRV_O_NATIVE_AIO;\n\n        } else if (!strcmp(buf, \"threads\")) {\n\n            /* this is the default */\n\n        } else {\n\n           error_report(\"invalid aio option\");\n\n           return NULL;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n\n        if (is_help_option(buf)) {\n\n            error_printf(\"Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            error_printf(\"\\n\");\n\n            return NULL;\n\n        }\n\n\n\n        drv = bdrv_find_whitelisted_format(buf, ro);\n\n        if (!drv) {\n\n            if (!ro && bdrv_find_whitelisted_format(buf, !ro)) {\n\n                error_report(\"'%s' can be only used as read-only device.\", buf);\n\n            } else {\n\n                error_report(\"'%s' invalid format\", buf);\n\n            }\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* disk I/O throttling */\n\n    memset(&cfg, 0, sizeof(cfg));\n\n    cfg.buckets[THROTTLE_BPS_TOTAL].avg =\n\n        qemu_opt_get_number(opts, \"throttling.bps-total\", 0);\n\n    cfg.buckets[THROTTLE_BPS_READ].avg  =\n\n        qemu_opt_get_number(opts, \"throttling.bps-read\", 0);\n\n    cfg.buckets[THROTTLE_BPS_WRITE].avg =\n\n        qemu_opt_get_number(opts, \"throttling.bps-write\", 0);\n\n    cfg.buckets[THROTTLE_OPS_TOTAL].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-total\", 0);\n\n    cfg.buckets[THROTTLE_OPS_READ].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-read\", 0);\n\n    cfg.buckets[THROTTLE_OPS_WRITE].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-write\", 0);\n\n\n\n    cfg.buckets[THROTTLE_BPS_TOTAL].max =\n\n        qemu_opt_get_number(opts, \"throttling.bps-total-max\", 0);\n\n    cfg.buckets[THROTTLE_BPS_READ].max  =\n\n        qemu_opt_get_number(opts, \"throttling.bps-read-max\", 0);\n\n    cfg.buckets[THROTTLE_BPS_WRITE].max =\n\n        qemu_opt_get_number(opts, \"throttling.bps-write-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_TOTAL].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-total-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_READ].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-read-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_WRITE].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-write-max\", 0);\n\n\n\n    cfg.op_size = qemu_opt_get_number(opts, \"throttling.iops-size\", 0);\n\n\n\n    if (!check_throttle_config(&cfg, &error)) {\n\n        error_report(\"%s\", error_get_pretty(error));\n\n        error_free(error);\n\n        return NULL;\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"boot\") != NULL) {\n\n        fprintf(stderr, \"qemu-kvm: boot=on|off is deprecated and will be \"\n\n                \"ignored. Future versions will reject this parameter. Please \"\n\n                \"update your scripts.\\n\");\n\n    }\n\n\n\n    on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;\n\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO && type != IF_NONE) {\n\n            error_report(\"werror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_write_error = parse_block_error_action(buf, 0);\n\n        if (on_write_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    on_read_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI && type != IF_NONE) {\n\n            error_report(\"rerror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_read_error = parse_block_error_action(buf, 1);\n\n        if (on_read_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if ((devaddr = qemu_opt_get(opts, \"addr\")) != NULL) {\n\n        if (type != IF_VIRTIO) {\n\n            error_report(\"addr is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            error_report(\"index cannot be used with bus and unit\");\n\n            return NULL;\n\n        }\n\n        bus_id = drive_index_to_bus_id(type, index);\n\n        unit_id = drive_index_to_unit_id(type, index);\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get(type, bus_id, unit_id) != NULL) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        error_report(\"unit %d too big (max is %d)\",\n\n                     unit_id, max_devs - 1);\n\n        return NULL;\n\n    }\n\n\n\n    /*\n\n     * catch multiple definitions\n\n     */\n\n\n\n    if (drive_get(type, bus_id, unit_id) != NULL) {\n\n        error_report(\"drive with bus=%d, unit=%d (index=%d) exists\",\n\n                     bus_id, unit_id, index);\n\n        return NULL;\n\n    }\n\n\n\n    /* init */\n\n\n\n    dinfo = g_malloc0(sizeof(*dinfo));\n\n    if ((buf = qemu_opts_id(opts)) != NULL) {\n\n        dinfo->id = g_strdup(buf);\n\n    } else {\n\n        /* no id supplied -> create one */\n\n        dinfo->id = g_malloc0(32);\n\n        if (type == IF_IDE || type == IF_SCSI)\n\n            mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n        if (max_devs)\n\n            snprintf(dinfo->id, 32, \"%s%i%s%i\",\n\n                     if_name[type], bus_id, mediastr, unit_id);\n\n        else\n\n            snprintf(dinfo->id, 32, \"%s%s%i\",\n\n                     if_name[type], mediastr, unit_id);\n\n    }\n\n    dinfo->bdrv = bdrv_new(dinfo->id);\n\n    dinfo->bdrv->open_flags = snapshot ? BDRV_O_SNAPSHOT : 0;\n\n    dinfo->bdrv->read_only = ro;\n\n    dinfo->devaddr = devaddr;\n\n    dinfo->type = type;\n\n    dinfo->bus = bus_id;\n\n    dinfo->unit = unit_id;\n\n    dinfo->cyls = cyls;\n\n    dinfo->heads = heads;\n\n    dinfo->secs = secs;\n\n    dinfo->trans = translation;\n\n    dinfo->opts = all_opts;\n\n    dinfo->refcount = 1;\n\n    if (serial != NULL) {\n\n        dinfo->serial = g_strdup(serial);\n\n    }\n\n    QTAILQ_INSERT_TAIL(&drives, dinfo, next);\n\n\n\n    bdrv_set_on_error(dinfo->bdrv, on_read_error, on_write_error);\n\n\n\n    /* disk I/O throttling */\n\n    if (throttle_enabled(&cfg)) {\n\n        bdrv_io_limits_enable(dinfo->bdrv);\n\n        bdrv_set_io_limits(dinfo->bdrv, &cfg);\n\n    }\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n    case IF_NONE:\n\n        dinfo->media_cd = media == MEDIA_CDROM;\n\n        break;\n\n    case IF_SD:\n\n    case IF_FLOPPY:\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n        break;\n\n    case IF_VIRTIO:\n\n    {\n\n        /* add virtio block device */\n\n        QemuOpts *devopts;\n\n        devopts = qemu_opts_create_nofail(qemu_find_opts(\"device\"));\n\n        if (arch_type == QEMU_ARCH_S390X) {\n\n            qemu_opt_set(devopts, \"driver\", \"virtio-blk-s390\");\n\n        } else {\n\n            qemu_opt_set(devopts, \"driver\", \"virtio-blk-pci\");\n\n        }\n\n        qemu_opt_set(devopts, \"drive\", dinfo->id);\n\n        if (devaddr)\n\n            qemu_opt_set(devopts, \"addr\", devaddr);\n\n        break;\n\n    }\n\n    default:\n\n        abort();\n\n    }\n\n    if (!file || !*file) {\n\n        if (has_driver_specific_opts) {\n\n            file = NULL;\n\n        } else {\n\n            return dinfo;\n\n        }\n\n    }\n\n    if (snapshot) {\n\n        /* always use cache=unsafe with snapshot */\n\n        bdrv_flags &= ~BDRV_O_CACHE_MASK;\n\n        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB|BDRV_O_NO_FLUSH);\n\n    }\n\n\n\n    if (copy_on_read) {\n\n        bdrv_flags |= BDRV_O_COPY_ON_READ;\n\n    }\n\n\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n\n        bdrv_flags |= BDRV_O_INCOMING;\n\n    }\n\n\n\n    if (media == MEDIA_CDROM) {\n\n        /* CDROM is fine for any interface, don't check.  */\n\n        ro = 1;\n\n    } else if (ro == 1) {\n\n        if (type != IF_SCSI && type != IF_VIRTIO && type != IF_FLOPPY &&\n\n            type != IF_NONE && type != IF_PFLASH) {\n\n            error_report(\"read-only not supported by this bus type\");\n\n            goto err;\n\n        }\n\n    }\n\n\n\n    bdrv_flags |= ro ? 0 : BDRV_O_RDWR;\n\n\n\n    if (ro && copy_on_read) {\n\n        error_report(\"warning: disabling copy_on_read on read-only drive\");\n\n    }\n\n\n\n    QINCREF(bs_opts);\n\n    ret = bdrv_open(dinfo->bdrv, file, bs_opts, bdrv_flags, drv, &error);\n\n\n\n    if (ret < 0) {\n\n        error_report(\"could not open disk image %s: %s\",\n\n                     file ?: dinfo->id, error_get_pretty(error));\n\n        goto err;\n\n    }\n\n\n\n    if (bdrv_key_required(dinfo->bdrv))\n\n        autostart = 0;\n\n\n\n    QDECREF(bs_opts);\n\n    qemu_opts_del(opts);\n\n\n\n    return dinfo;\n\n\n\nerr:\n\n    qemu_opts_del(opts);\n\n    QDECREF(bs_opts);\n\n    bdrv_unref(dinfo->bdrv);\n\n    g_free(dinfo->id);\n\n    QTAILQ_REMOVE(&drives, dinfo, next);\n\n    g_free(dinfo);\n\n    return NULL;\n\n}\n", "idx": 19539, "_split": "valid", "_hash": "de2f83e875ec150fc4567d5156950267"}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static inline uint32_t reloc_26_val(tcg_insn_unit *pc, tcg_insn_unit *target)\n\n{\n\n    assert((((uintptr_t)pc ^ (uintptr_t)target) & 0xf0000000) == 0);\n\n    return ((uintptr_t)target >> 2) & 0x3ffffff;\n\n}\n", "idx": 19571, "_split": "valid", "_hash": "88f5eb0c4e1fea9325d89ea28af2b339"}
{"project": "qemu", "commit_id": "9f1d4b1d6939d39fe570d886f6a651f4764bcbcb", "target": 0, "func": "static uint32_t openpic_iack(OpenPICState *opp, IRQDest *dst, int cpu)\n\n{\n\n    IRQSource *src;\n\n    int retval, irq;\n\n\n\n    DPRINTF(\"Lower OpenPIC INT output\\n\");\n\n    qemu_irq_lower(dst->irqs[OPENPIC_OUTPUT_INT]);\n\n\n\n    irq = IRQ_get_next(opp, &dst->raised);\n\n    DPRINTF(\"IACK: irq=%d\\n\", irq);\n\n\n\n    if (irq == -1) {\n\n        /* No more interrupt pending */\n\n        return opp->spve;\n\n    }\n\n\n\n    src = &opp->src[irq];\n\n    if (!(src->ivpr & IVPR_ACTIVITY_MASK) ||\n\n            !(IVPR_PRIORITY(src->ivpr) > dst->ctpr)) {\n\n        /* - Spurious level-sensitive IRQ\n\n         * - Priorities has been changed\n\n         *   and the pending IRQ isn't allowed anymore\n\n         */\n\n        src->ivpr &= ~IVPR_ACTIVITY_MASK;\n\n        retval = opp->spve;\n\n    } else {\n\n        /* IRQ enter servicing state */\n\n        IRQ_setbit(&dst->servicing, irq);\n\n        retval = IVPR_VECTOR(opp, src->ivpr);\n\n    }\n\n    IRQ_resetbit(&dst->raised, irq);\n\n    if (!src->level) {\n\n        /* edge-sensitive IRQ */\n\n        src->ivpr &= ~IVPR_ACTIVITY_MASK;\n\n        src->pending = 0;\n\n    }\n\n\n\n    if ((irq >= opp->irq_ipi0) &&  (irq < (opp->irq_ipi0 + MAX_IPI))) {\n\n        src->idr &= ~(1 << cpu);\n\n        if (src->idr && !src->level) {\n\n            /* trigger on CPUs that didn't know about it yet */\n\n            openpic_set_irq(opp, irq, 1);\n\n            openpic_set_irq(opp, irq, 0);\n\n            /* if all CPUs knew about it, set active bit again */\n\n            src->ivpr |= IVPR_ACTIVITY_MASK;\n\n        }\n\n    }\n\n\n\n    return retval;\n\n}\n", "idx": 19573, "_split": "valid", "_hash": "fc6517d2d3029382e2791997f5085397"}
{"project": "qemu", "commit_id": "b1ab03af890b2b6c5bafc9344b7fe05b392180a5", "target": 1, "func": "static void realview_init(MachineState *machine,\n\n                          enum realview_board_type board_type)\n\n{\n\n    ARMCPU *cpu = NULL;\n\n    CPUARMState *env;\n\n    ObjectClass *cpu_oc;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram_lo = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_hi = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_alias = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_hack = g_new(MemoryRegion, 1);\n\n    DeviceState *dev, *sysctl, *gpio2, *pl041;\n\n    SysBusDevice *busdev;\n\n    qemu_irq pic[64];\n\n    qemu_irq mmc_irq[2];\n\n    PCIBus *pci_bus = NULL;\n\n    NICInfo *nd;\n\n    I2CBus *i2c;\n\n    int n;\n\n    int done_nic = 0;\n\n    qemu_irq cpu_irq[4];\n\n    int is_mpcore = 0;\n\n    int is_pb = 0;\n\n    uint32_t proc_id = 0;\n\n    uint32_t sys_id;\n\n    ram_addr_t low_ram_size;\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    hwaddr periphbase = 0;\n\n\n\n    switch (board_type) {\n\n    case BOARD_EB:\n\n        break;\n\n    case BOARD_EB_MPCORE:\n\n        is_mpcore = 1;\n\n        periphbase = 0x10100000;\n\n        break;\n\n    case BOARD_PB_A8:\n\n        is_pb = 1;\n\n        break;\n\n    case BOARD_PBX_A9:\n\n        is_mpcore = 1;\n\n        is_pb = 1;\n\n        periphbase = 0x1f000000;\n\n        break;\n\n    }\n\n\n\n    cpu_oc = cpu_class_by_name(TYPE_ARM_CPU, machine->cpu_model);\n\n    if (!cpu_oc) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        Object *cpuobj = object_new(object_class_get_name(cpu_oc));\n\n        Error *err = NULL;\n\n\n\n        if (is_pb && is_mpcore) {\n\n            object_property_set_int(cpuobj, periphbase, \"reset-cbar\", &err);\n\n            if (err) {\n\n                error_report(\"%s\", error_get_pretty(err));\n\n                exit(1);\n\n            }\n\n        }\n\n\n\n        object_property_set_bool(cpuobj, true, \"realized\", &err);\n\n        if (err) {\n\n            error_report(\"%s\", error_get_pretty(err));\n\n            exit(1);\n\n        }\n\n\n\n        cpu_irq[n] = qdev_get_gpio_in(DEVICE(cpuobj), ARM_CPU_IRQ);\n\n    }\n\n    cpu = ARM_CPU(first_cpu);\n\n    env = &cpu->env;\n\n    if (arm_feature(env, ARM_FEATURE_V7)) {\n\n        if (is_mpcore) {\n\n            proc_id = 0x0c000000;\n\n        } else {\n\n            proc_id = 0x0e000000;\n\n        }\n\n    } else if (arm_feature(env, ARM_FEATURE_V6K)) {\n\n        proc_id = 0x06000000;\n\n    } else if (arm_feature(env, ARM_FEATURE_V6)) {\n\n        proc_id = 0x04000000;\n\n    } else {\n\n        proc_id = 0x02000000;\n\n    }\n\n\n\n    if (is_pb && ram_size > 0x20000000) {\n\n        /* Core tile RAM.  */\n\n        low_ram_size = ram_size - 0x20000000;\n\n        ram_size = 0x20000000;\n\n        memory_region_init_ram(ram_lo, NULL, \"realview.lowmem\", low_ram_size,\n\n                               &error_abort);\n\n        vmstate_register_ram_global(ram_lo);\n\n        memory_region_add_subregion(sysmem, 0x20000000, ram_lo);\n\n    }\n\n\n\n    memory_region_init_ram(ram_hi, NULL, \"realview.highmem\", ram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(ram_hi);\n\n    low_ram_size = ram_size;\n\n    if (low_ram_size > 0x10000000)\n\n      low_ram_size = 0x10000000;\n\n    /* SDRAM at address zero.  */\n\n    memory_region_init_alias(ram_alias, NULL, \"realview.alias\",\n\n                             ram_hi, 0, low_ram_size);\n\n    memory_region_add_subregion(sysmem, 0, ram_alias);\n\n    if (is_pb) {\n\n        /* And again at a high address.  */\n\n        memory_region_add_subregion(sysmem, 0x70000000, ram_hi);\n\n    } else {\n\n        ram_size = low_ram_size;\n\n    }\n\n\n\n    sys_id = is_pb ? 0x01780500 : 0xc1400400;\n\n    sysctl = qdev_create(NULL, \"realview_sysctl\");\n\n    qdev_prop_set_uint32(sysctl, \"sys_id\", sys_id);\n\n    qdev_prop_set_uint32(sysctl, \"proc_id\", proc_id);\n\n    qdev_init_nofail(sysctl);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(sysctl), 0, 0x10000000);\n\n\n\n    if (is_mpcore) {\n\n        dev = qdev_create(NULL, is_pb ? \"a9mpcore_priv\": \"realview_mpcore\");\n\n        qdev_prop_set_uint32(dev, \"num-cpu\", smp_cpus);\n\n        qdev_init_nofail(dev);\n\n        busdev = SYS_BUS_DEVICE(dev);\n\n        sysbus_mmio_map(busdev, 0, periphbase);\n\n        for (n = 0; n < smp_cpus; n++) {\n\n            sysbus_connect_irq(busdev, n, cpu_irq[n]);\n\n        }\n\n        sysbus_create_varargs(\"l2x0\", periphbase + 0x2000, NULL);\n\n        /* Both A9 and 11MPCore put the GIC CPU i/f at base + 0x100 */\n\n        realview_binfo.gic_cpu_if_addr = periphbase + 0x100;\n\n    } else {\n\n        uint32_t gic_addr = is_pb ? 0x1e000000 : 0x10040000;\n\n        /* For now just create the nIRQ GIC, and ignore the others.  */\n\n        dev = sysbus_create_simple(\"realview_gic\", gic_addr, cpu_irq[0]);\n\n    }\n\n    for (n = 0; n < 64; n++) {\n\n        pic[n] = qdev_get_gpio_in(dev, n);\n\n    }\n\n\n\n    pl041 = qdev_create(NULL, \"pl041\");\n\n    qdev_prop_set_uint32(pl041, \"nc_fifo_depth\", 512);\n\n    qdev_init_nofail(pl041);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(pl041), 0, 0x10004000);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(pl041), 0, pic[19]);\n\n\n\n    sysbus_create_simple(\"pl050_keyboard\", 0x10006000, pic[20]);\n\n    sysbus_create_simple(\"pl050_mouse\", 0x10007000, pic[21]);\n\n\n\n    sysbus_create_simple(\"pl011\", 0x10009000, pic[12]);\n\n    sysbus_create_simple(\"pl011\", 0x1000a000, pic[13]);\n\n    sysbus_create_simple(\"pl011\", 0x1000b000, pic[14]);\n\n    sysbus_create_simple(\"pl011\", 0x1000c000, pic[15]);\n\n\n\n    /* DMA controller is optional, apparently.  */\n\n    sysbus_create_simple(\"pl081\", 0x10030000, pic[24]);\n\n\n\n    sysbus_create_simple(\"sp804\", 0x10011000, pic[4]);\n\n    sysbus_create_simple(\"sp804\", 0x10012000, pic[5]);\n\n\n\n    sysbus_create_simple(\"pl061\", 0x10013000, pic[6]);\n\n    sysbus_create_simple(\"pl061\", 0x10014000, pic[7]);\n\n    gpio2 = sysbus_create_simple(\"pl061\", 0x10015000, pic[8]);\n\n\n\n    sysbus_create_simple(\"pl111\", 0x10020000, pic[23]);\n\n\n\n    dev = sysbus_create_varargs(\"pl181\", 0x10005000, pic[17], pic[18], NULL);\n\n    /* Wire up MMC card detect and read-only signals. These have\n\n     * to go to both the PL061 GPIO and the sysctl register.\n\n     * Note that the PL181 orders these lines (readonly,inserted)\n\n     * and the PL061 has them the other way about. Also the card\n\n     * detect line is inverted.\n\n     */\n\n    mmc_irq[0] = qemu_irq_split(\n\n        qdev_get_gpio_in(sysctl, ARM_SYSCTL_GPIO_MMC_WPROT),\n\n        qdev_get_gpio_in(gpio2, 1));\n\n    mmc_irq[1] = qemu_irq_split(\n\n        qdev_get_gpio_in(sysctl, ARM_SYSCTL_GPIO_MMC_CARDIN),\n\n        qemu_irq_invert(qdev_get_gpio_in(gpio2, 0)));\n\n    qdev_connect_gpio_out(dev, 0, mmc_irq[0]);\n\n    qdev_connect_gpio_out(dev, 1, mmc_irq[1]);\n\n\n\n    sysbus_create_simple(\"pl031\", 0x10017000, pic[10]);\n\n\n\n    if (!is_pb) {\n\n        dev = qdev_create(NULL, \"realview_pci\");\n\n        busdev = SYS_BUS_DEVICE(dev);\n\n        qdev_init_nofail(dev);\n\n        sysbus_mmio_map(busdev, 0, 0x10019000); /* PCI controller registers */\n\n        sysbus_mmio_map(busdev, 1, 0x60000000); /* PCI self-config */\n\n        sysbus_mmio_map(busdev, 2, 0x61000000); /* PCI config */\n\n        sysbus_mmio_map(busdev, 3, 0x62000000); /* PCI I/O */\n\n        sysbus_mmio_map(busdev, 4, 0x63000000); /* PCI memory window 1 */\n\n        sysbus_mmio_map(busdev, 5, 0x64000000); /* PCI memory window 2 */\n\n        sysbus_mmio_map(busdev, 6, 0x68000000); /* PCI memory window 3 */\n\n        sysbus_connect_irq(busdev, 0, pic[48]);\n\n        sysbus_connect_irq(busdev, 1, pic[49]);\n\n        sysbus_connect_irq(busdev, 2, pic[50]);\n\n        sysbus_connect_irq(busdev, 3, pic[51]);\n\n        pci_bus = (PCIBus *)qdev_get_child_bus(dev, \"pci\");\n\n        if (usb_enabled(false)) {\n\n            pci_create_simple(pci_bus, -1, \"pci-ohci\");\n\n        }\n\n        n = drive_get_max_bus(IF_SCSI);\n\n        while (n >= 0) {\n\n            pci_create_simple(pci_bus, -1, \"lsi53c895a\");\n\n            n--;\n\n        }\n\n    }\n\n    for(n = 0; n < nb_nics; n++) {\n\n        nd = &nd_table[n];\n\n\n\n        if (!done_nic && (!nd->model ||\n\n                    strcmp(nd->model, is_pb ? \"lan9118\" : \"smc91c111\") == 0)) {\n\n            if (is_pb) {\n\n                lan9118_init(nd, 0x4e000000, pic[28]);\n\n            } else {\n\n                smc91c111_init(nd, 0x4e000000, pic[28]);\n\n            }\n\n            done_nic = 1;\n\n        } else {\n\n            if (pci_bus) {\n\n                pci_nic_init_nofail(nd, pci_bus, \"rtl8139\", NULL);\n\n            }\n\n        }\n\n    }\n\n\n\n    dev = sysbus_create_simple(\"versatile_i2c\", 0x10002000, NULL);\n\n    i2c = (I2CBus *)qdev_get_child_bus(dev, \"i2c\");\n\n    i2c_create_slave(i2c, \"ds1338\", 0x68);\n\n\n\n    /* Memory map for RealView Emulation Baseboard:  */\n\n    /* 0x10000000 System registers.  */\n\n    /*  0x10001000 System controller.  */\n\n    /* 0x10002000 Two-Wire Serial Bus.  */\n\n    /* 0x10003000 Reserved.  */\n\n    /*  0x10004000 AACI.  */\n\n    /*  0x10005000 MCI.  */\n\n    /* 0x10006000 KMI0.  */\n\n    /* 0x10007000 KMI1.  */\n\n    /*  0x10008000 Character LCD. (EB) */\n\n    /* 0x10009000 UART0.  */\n\n    /* 0x1000a000 UART1.  */\n\n    /* 0x1000b000 UART2.  */\n\n    /* 0x1000c000 UART3.  */\n\n    /*  0x1000d000 SSPI.  */\n\n    /*  0x1000e000 SCI.  */\n\n    /* 0x1000f000 Reserved.  */\n\n    /*  0x10010000 Watchdog.  */\n\n    /* 0x10011000 Timer 0+1.  */\n\n    /* 0x10012000 Timer 2+3.  */\n\n    /*  0x10013000 GPIO 0.  */\n\n    /*  0x10014000 GPIO 1.  */\n\n    /*  0x10015000 GPIO 2.  */\n\n    /*  0x10002000 Two-Wire Serial Bus - DVI. (PB) */\n\n    /* 0x10017000 RTC.  */\n\n    /*  0x10018000 DMC.  */\n\n    /*  0x10019000 PCI controller config.  */\n\n    /*  0x10020000 CLCD.  */\n\n    /* 0x10030000 DMA Controller.  */\n\n    /* 0x10040000 GIC1. (EB) */\n\n    /*  0x10050000 GIC2. (EB) */\n\n    /*  0x10060000 GIC3. (EB) */\n\n    /*  0x10070000 GIC4. (EB) */\n\n    /*  0x10080000 SMC.  */\n\n    /* 0x1e000000 GIC1. (PB) */\n\n    /*  0x1e001000 GIC2. (PB) */\n\n    /*  0x1e002000 GIC3. (PB) */\n\n    /*  0x1e003000 GIC4. (PB) */\n\n    /*  0x40000000 NOR flash.  */\n\n    /*  0x44000000 DoC flash.  */\n\n    /*  0x48000000 SRAM.  */\n\n    /*  0x4c000000 Configuration flash.  */\n\n    /* 0x4e000000 Ethernet.  */\n\n    /*  0x4f000000 USB.  */\n\n    /*  0x50000000 PISMO.  */\n\n    /*  0x54000000 PISMO.  */\n\n    /*  0x58000000 PISMO.  */\n\n    /*  0x5c000000 PISMO.  */\n\n    /* 0x60000000 PCI.  */\n\n    /* 0x60000000 PCI Self Config.  */\n\n    /* 0x61000000 PCI Config.  */\n\n    /* 0x62000000 PCI IO.  */\n\n    /* 0x63000000 PCI mem 0.  */\n\n    /* 0x64000000 PCI mem 1.  */\n\n    /* 0x68000000 PCI mem 2.  */\n\n\n\n    /* ??? Hack to map an additional page of ram for the secondary CPU\n\n       startup code.  I guess this works on real hardware because the\n\n       BootROM happens to be in ROM/flash or in memory that isn't clobbered\n\n       until after Linux boots the secondary CPUs.  */\n\n    memory_region_init_ram(ram_hack, NULL, \"realview.hack\", 0x1000,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(ram_hack);\n\n    memory_region_add_subregion(sysmem, SMP_BOOT_ADDR, ram_hack);\n\n\n\n    realview_binfo.ram_size = ram_size;\n\n    realview_binfo.kernel_filename = machine->kernel_filename;\n\n    realview_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    realview_binfo.initrd_filename = machine->initrd_filename;\n\n    realview_binfo.nb_cpus = smp_cpus;\n\n    realview_binfo.board_id = realview_board_id[board_type];\n\n    realview_binfo.loader_start = (board_type == BOARD_PB_A8 ? 0x70000000 : 0);\n\n    arm_load_kernel(ARM_CPU(first_cpu), &realview_binfo);\n\n}\n", "idx": 19603, "_split": "valid", "_hash": "4b86fb71ec88c545642966d957887ae5"}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_tlbie(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr || !ctx->hv)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    if (NARROW_MODE(ctx)) {\n\n        TCGv t0 = tcg_temp_new();\n\n        tcg_gen_ext32u_tl(t0, cpu_gpr[rB(ctx->opcode)]);\n\n        gen_helper_tlbie(cpu_env, t0);\n\n        tcg_temp_free(t0);\n\n    } else {\n\n        gen_helper_tlbie(cpu_env, cpu_gpr[rB(ctx->opcode)]);\n\n    }\n\n#endif\n\n}\n", "idx": 19615, "_split": "valid", "_hash": "a10c2ecf3c1848d17022ad37f2792e70"}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void qga_vss_fsfreeze(int *nr_volume, Error **errp, bool freeze)\n\n{\n\n    const char *func_name = freeze ? \"requester_freeze\" : \"requester_thaw\";\n\n    QGAVSSRequesterFunc func;\n\n    ErrorSet errset = {\n\n        .error_setg_win32 = error_setg_win32,\n\n        .errp = errp,\n\n    };\n\n\n\n    g_assert(errp);             /* requester.cpp requires it */\n\n    func = (QGAVSSRequesterFunc)GetProcAddress(provider_lib, func_name);\n\n    if (!func) {\n\n        error_setg_win32(errp, GetLastError(), \"failed to load %s from %s\",\n\n                         func_name, QGA_VSS_DLL);\n\n        return;\n\n    }\n\n\n\n    func(nr_volume, &errset);\n\n}\n", "idx": 19648, "_split": "valid", "_hash": "7670a3483b979878e1a2e0f5327e1314"}
{"project": "qemu", "commit_id": "2ecea9b8de5cd74df314541b87f712ae77f862ec", "target": 1, "func": "static void do_change_block(const char *device, const char *filename)\n\n{\n\n    BlockDriverState *bs;\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        term_printf(\"device not found\\n\");\n\n        return;\n\n    }\n\n    if (eject_device(bs, 0) < 0)\n\n        return;\n\n    bdrv_open(bs, filename, 0);\n\n    qemu_key_check(bs, filename);\n\n}\n", "idx": 19659, "_split": "valid", "_hash": "b3b552130601578ae97040dd8e2cc85d"}
{"project": "qemu", "commit_id": "129c7d1c536d0c67a8781cb09fb5bdb3d0f6a2d0", "target": 1, "func": "static NFSServer *nfs_config(QDict *options, Error **errp)\n\n{\n\n    NFSServer *server = NULL;\n\n    QDict *addr = NULL;\n\n    QObject *crumpled_addr = NULL;\n\n    Visitor *iv = NULL;\n\n    Error *local_error = NULL;\n\n\n\n    qdict_extract_subqdict(options, &addr, \"server.\");\n\n    if (!qdict_size(addr)) {\n\n        error_setg(errp, \"NFS server address missing\");\n\n        goto out;\n\n    }\n\n\n\n    crumpled_addr = qdict_crumple(addr, errp);\n\n    if (!crumpled_addr) {\n\n        goto out;\n\n    }\n\n\n\n\n\n\n\n\n\n\n    iv = qobject_input_visitor_new(crumpled_addr);\n\n    visit_type_NFSServer(iv, NULL, &server, &local_error);\n\n    if (local_error) {\n\n        error_propagate(errp, local_error);\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    QDECREF(addr);\n\n    qobject_decref(crumpled_addr);\n\n    visit_free(iv);\n\n    return server;\n\n}", "idx": 19666, "_split": "valid", "_hash": "d95306d6308ef86a3a781ffa80cd2aa5"}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_rfmci(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    /* Restore CPU state */\n\n    gen_helper_rfmci(cpu_env);\n\n    gen_sync_exception(ctx);\n\n#endif\n\n}\n", "idx": 19674, "_split": "valid", "_hash": "691cb5dbe7e8f70d6cd07ea52339bb66"}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void memory_region_transaction_commit(void)\n{\n    AddressSpace *as;\n    assert(memory_region_transaction_depth);\n    --memory_region_transaction_depth;\n    if (!memory_region_transaction_depth) {\n        if (memory_region_update_pending) {\n            MEMORY_LISTENER_CALL_GLOBAL(begin, Forward);\n            QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {\n                address_space_update_topology(as);\n            }\n            MEMORY_LISTENER_CALL_GLOBAL(commit, Forward);\n        } else if (ioeventfd_update_pending) {\n            QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {\n                address_space_update_ioeventfds(as);\n            }\n        }\n        memory_region_clear_pending();\n   }\n}", "idx": 19689, "_split": "valid", "_hash": "84f328a8bb8b0e507edb7fbeb35f6df2"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static uint64_t block_save_pending(QEMUFile *f, void *opaque, uint64_t max_size)\n\n{\n\n    /* Estimate pending number of bytes to send */\n\n    uint64_t pending;\n\n\n\n    qemu_mutex_lock_iothread();\n\n    blk_mig_lock();\n\n    pending = get_remaining_dirty() +\n\n                       block_mig_state.submitted * BLOCK_SIZE +\n\n                       block_mig_state.read_done * BLOCK_SIZE;\n\n\n\n    /* Report at least one block pending during bulk phase */\n\n    if (pending == 0 && !block_mig_state.bulk_completed) {\n\n        pending = BLOCK_SIZE;\n\n    }\n\n    blk_mig_unlock();\n\n    qemu_mutex_unlock_iothread();\n\n\n\n    DPRINTF(\"Enter save live pending  %\" PRIu64 \"\\n\", pending);\n\n    return pending;\n\n}\n", "idx": 19707, "_split": "valid", "_hash": "abc40f386d45271c97611c7b4e96aeff"}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(cmpli)\n\n{\n\n    if (T0 < PARAM(1)) {\n\n        T0 = 0x08;\n\n    } else if (T0 > PARAM(1)) {\n\n        T0 = 0x04;\n\n    } else {\n\n        T0 = 0x02;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 19712, "_split": "valid", "_hash": "aff77b266eba854720fe9102d0367c51"}
{"project": "qemu", "commit_id": "14b6160099f0caf5dc9d62e637b007bc5d719a96", "target": 1, "func": "bool qdict_get_try_bool(const QDict *qdict, const char *key, bool def_value)\n\n{\n\n    QObject *obj;\n\n\n\n    obj = qdict_get(qdict, key);\n\n    if (!obj || qobject_type(obj) != QTYPE_QBOOL)\n\n        return def_value;\n\n\n\n    return qbool_get_bool(qobject_to_qbool(obj));\n\n}\n", "idx": 19734, "_split": "valid", "_hash": "aafdef8b8fde3e5740956793db82b431"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void qemu_rdma_dump_id(const char *who, struct ibv_context *verbs)\n\n{\n\n    struct ibv_port_attr port;\n\n\n\n    if (ibv_query_port(verbs, 1, &port)) {\n\n        fprintf(stderr, \"FAILED TO QUERY PORT INFORMATION!\\n\");\n\n        return;\n\n    }\n\n\n\n    printf(\"%s RDMA Device opened: kernel name %s \"\n\n           \"uverbs device name %s, \"\n\n           \"infiniband_verbs class device path %s, \"\n\n           \"infiniband class device path %s, \"\n\n           \"transport: (%d) %s\\n\",\n\n                who,\n\n                verbs->device->name,\n\n                verbs->device->dev_name,\n\n                verbs->device->dev_path,\n\n                verbs->device->ibdev_path,\n\n                port.link_layer,\n\n                (port.link_layer == IBV_LINK_LAYER_INFINIBAND) ? \"Infiniband\" :\n\n                 ((port.link_layer == IBV_LINK_LAYER_ETHERNET) \n\n                    ? \"Ethernet\" : \"Unknown\"));\n\n}\n", "idx": 19748, "_split": "valid", "_hash": "c89b4caf2a530211874dcd8c395c63d5"}
{"project": "qemu", "commit_id": "5f758366c0710d23e43f4d0f83816b98616a13d0", "target": 1, "func": "static CharDriverState *qmp_chardev_open_serial(ChardevHostdev *serial,\n\n                                                Error **errp)\n\n{\n\n#ifdef HAVE_CHARDEV_TTY\n\n    int fd;\n\n\n\n    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);\n\n    if (error_is_set(errp)) {\n\n        return NULL;\n\n    }\n\n    qemu_set_nonblock(fd);\n\n    return qemu_chr_open_tty_fd(fd);\n\n#else\n\n    error_setg(errp, \"character device backend type 'serial' not supported\");\n\n    return NULL;\n\n#endif\n\n}\n", "idx": 19766, "_split": "valid", "_hash": "6a32452b7903ed249d5b2bf4b7eb5fb2"}
{"project": "qemu", "commit_id": "9745807191a81c45970f780166f44a7f93b18653", "target": 1, "func": "static void gen_mul(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)\n\n{\n\n    TCGv sr_ov = tcg_temp_new();\n\n    TCGv t0 = tcg_temp_new();\n\n\n\n    tcg_gen_muls2_tl(dest, sr_ov, srca, srcb);\n\n    tcg_gen_sari_tl(t0, dest, TARGET_LONG_BITS - 1);\n\n    tcg_gen_setcond_tl(TCG_COND_NE, sr_ov, sr_ov, t0);\n\n    tcg_temp_free(t0);\n\n\n\n    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_ov, ctz32(SR_OV), 1);\n\n\n\n    gen_ove_ov(dc, sr_ov);\n\n    tcg_temp_free(sr_ov);\n\n}\n", "idx": 19785, "_split": "valid", "_hash": "6ad41c4f8991fa5cb04619b9bc659313"}
{"project": "qemu", "commit_id": "9a94ee5bb15793ef69692998ef57794a33074134", "target": 1, "func": "static void rtas_start_cpu(PowerPCCPU *cpu_, sPAPRMachineState *spapr,\n                           uint32_t token, uint32_t nargs,\n                           target_ulong args,\n                           uint32_t nret, target_ulong rets)\n{\n    target_ulong id, start, r3;\n    PowerPCCPU *cpu;\n    if (nargs != 3 || nret != 1) {\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n        return;\n    }\n    id = rtas_ld(args, 0);\n    start = rtas_ld(args, 1);\n    r3 = rtas_ld(args, 2);\n    cpu = spapr_find_cpu(id);\n    if (cpu != NULL) {\n        CPUState *cs = CPU(cpu);\n        CPUPPCState *env = &cpu->env;\n        PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);\n        if (!cs->halted) {\n            rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n            return;\n        }\n        /* This will make sure qemu state is up to date with kvm, and\n         * mark it dirty so our changes get flushed back before the\n         * new cpu enters */\n        kvm_cpu_synchronize_state(cs);\n        env->msr = (1ULL << MSR_SF) | (1ULL << MSR_ME);\n        env->nip = start;\n        env->gpr[3] = r3;\n        cs->halted = 0;\n        spapr_cpu_set_endianness(cpu);\n        spapr_cpu_update_tb_offset(cpu);\n        qemu_cpu_kick(cs);\n        rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n        return;\n    }\n    /* Didn't find a matching cpu */\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n}", "idx": 19791, "_split": "valid", "_hash": "6645ddbde14dfde6545a8c2bd29a5c9f"}
{"project": "qemu", "commit_id": "f68ec8379e88502b4841a110c070e9b118d3151c", "target": 1, "func": "void ide_flush_cache(IDEState *s)\n\n{\n\n    if (s->bs == NULL) {\n\n        ide_flush_cb(s, 0);\n\n        return;\n\n    }\n\n\n\n\n    bdrv_acct_start(s->bs, &s->acct, 0, BDRV_ACCT_FLUSH);\n\n    bdrv_aio_flush(s->bs, ide_flush_cb, s);\n\n}", "idx": 19823, "_split": "valid", "_hash": "d761e0bed819ea943f4937cdb97bb386"}
{"project": "qemu", "commit_id": "788d2599def0e26d92802593b07ec76e8701ccce", "target": 1, "func": "static void spapr_phb_hot_unplug_child(HotplugHandler *plug_handler,\n\n                                       DeviceState *plugged_dev, Error **errp)\n\n{\n\n    sPAPRPHBState *phb = SPAPR_PCI_HOST_BRIDGE(DEVICE(plug_handler));\n\n    PCIDevice *pdev = PCI_DEVICE(plugged_dev);\n\n    sPAPRDRConnectorClass *drck;\n\n    sPAPRDRConnector *drc = spapr_phb_get_pci_drc(phb, pdev);\n\n    Error *local_err = NULL;\n\n\n\n    if (!phb->dr_enabled) {\n\n        error_setg(errp, QERR_BUS_NO_HOTPLUG,\n\n                   object_get_typename(OBJECT(phb)));\n\n        return;\n\n    }\n\n\n\n    g_assert(drc);\n\n\n\n    drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n    if (!drck->release_pending(drc)) {\n\n        spapr_phb_remove_pci_device(drc, phb, pdev, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n        spapr_hotplug_req_remove_by_index(drc);\n\n    }\n\n}\n", "idx": 19825, "_split": "valid", "_hash": "fa329a6993bca077fa74eedacd23da0f"}
{"project": "qemu", "commit_id": "908bcd540f489f7adf2d804347905b0025d808d3", "target": 1, "func": "int bdrv_check(BlockDriverState *bs, BdrvCheckResult *res, BdrvCheckMode fix)\n\n{\n\n\n\n\n    if (bs->drv->bdrv_check == NULL) {\n\n        return -ENOTSUP;\n\n\n\n\n    memset(res, 0, sizeof(*res));\n\n    return bs->drv->bdrv_check(bs, res, fix);\n", "idx": 19833, "_split": "valid", "_hash": "ecb8bf02d8226d44437dddac1f69f6b2"}
{"project": "qemu", "commit_id": "8a93e519f32c40ebc41503fd18607dcaef1ddf7a", "target": 1, "func": "static void map_linear_vram(CirrusVGAState *s)\n\n{\n\n\n\n\n    if (!s->map_addr && s->lfb_addr && s->lfb_end) {\n\n        s->map_addr = s->lfb_addr;\n\n        s->map_end = s->lfb_end;\n\n        cpu_register_physical_memory(s->map_addr, s->map_end - s->map_addr, s->vram_offset);\n\n    }\n\n\n\n    if (!s->map_addr)\n\n        return;\n\n\n\n    s->lfb_vram_mapped = 0;\n\n\n\n\n\n\n\n    if (!(s->cirrus_srcptr != s->cirrus_srcptr_end)\n\n        && !((s->sr[0x07] & 0x01) == 0)\n\n        && !((s->gr[0x0B] & 0x14) == 0x14)\n\n        && !(s->gr[0x0B] & 0x02)) {\n\n\n\n\n\n                                    (s->vram_offset + s->cirrus_bank_base[0]) | IO_MEM_RAM);\n\n\n                                    (s->vram_offset + s->cirrus_bank_base[1]) | IO_MEM_RAM);\n\n\n\n        s->lfb_vram_mapped = 1;\n\n    }\n\n    else {\n\n        cpu_register_physical_memory(isa_mem_base + 0xa0000, 0x20000,\n\n                                     s->vga_io_memory);\n\n    }\n\n\n\n    vga_dirty_log_start((VGAState *)s);\n\n}", "idx": 19835, "_split": "valid", "_hash": "8ea05a437426862c91bf346b16007e4b"}
{"project": "qemu", "commit_id": "362e9299b34b3101aaa20f20363441c9f055fa5e", "target": 1, "func": "static BlockBackend *blockdev_init(const char *file, QDict *bs_opts,\n                                   Error **errp)\n{\n    const char *buf;\n    int bdrv_flags = 0;\n    int on_read_error, on_write_error;\n    bool account_invalid, account_failed;\n    BlockBackend *blk;\n    BlockDriverState *bs;\n    ThrottleConfig cfg;\n    int snapshot = 0;\n    Error *error = NULL;\n    QemuOpts *opts;\n    const char *id;\n    bool has_driver_specific_opts;\n    BlockdevDetectZeroesOptions detect_zeroes =\n        BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF;\n    const char *throttling_group = NULL;\n    /* Check common options by copying from bs_opts to opts, all other options\n     * stay in bs_opts for processing by bdrv_open(). */\n    id = qdict_get_try_str(bs_opts, \"id\");\n    opts = qemu_opts_create(&qemu_common_drive_opts, id, 1, &error);\n    if (error) {\n        error_propagate(errp, error);\n        goto err_no_opts;\n    }\n    qemu_opts_absorb_qdict(opts, bs_opts, &error);\n    if (error) {\n        error_propagate(errp, error);\n        goto early_err;\n    }\n    if (id) {\n        qdict_del(bs_opts, \"id\");\n    }\n    has_driver_specific_opts = !!qdict_size(bs_opts);\n    /* extract parameters */\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n    extract_common_blockdev_options(opts, &bdrv_flags, &throttling_group, &cfg,\n                                    &detect_zeroes, &error);\n    if (error) {\n        error_propagate(errp, error);\n        goto early_err;\n    }\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n        if (is_help_option(buf)) {\n            error_printf(\"Supported formats:\");\n            bdrv_iterate_format(bdrv_format_print, NULL);\n            error_printf(\"\\n\");\n            goto early_err;\n        }\n        if (qdict_haskey(bs_opts, \"driver\")) {\n            error_setg(errp, \"Cannot specify both 'driver' and 'format'\");\n            goto early_err;\n        }\n        qdict_put(bs_opts, \"driver\", qstring_from_str(buf));\n    }\n    on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n        on_write_error = parse_block_error_action(buf, 0, &error);\n        if (error) {\n            error_propagate(errp, error);\n            goto early_err;\n        }\n    }\n    on_read_error = BLOCKDEV_ON_ERROR_REPORT;\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n        on_read_error = parse_block_error_action(buf, 1, &error);\n        if (error) {\n            error_propagate(errp, error);\n            goto early_err;\n        }\n    }\n    if (snapshot) {\n        /* always use cache=unsafe with snapshot */\n        bdrv_flags &= ~BDRV_O_CACHE_MASK;\n        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB|BDRV_O_NO_FLUSH);\n    }\n    /* init */\n    if ((!file || !*file) && !has_driver_specific_opts) {\n        BlockBackendRootState *blk_rs;\n        blk = blk_new(qemu_opts_id(opts), errp);\n        if (!blk) {\n            goto early_err;\n        }\n        blk_rs = blk_get_root_state(blk);\n        blk_rs->open_flags    = bdrv_flags;\n        blk_rs->read_only     = !(bdrv_flags & BDRV_O_RDWR);\n        blk_rs->detect_zeroes = detect_zeroes;\n        if (throttle_enabled(&cfg)) {\n            if (!throttling_group) {\n                throttling_group = blk_name(blk);\n            }\n            blk_rs->throttle_group = g_strdup(throttling_group);\n            blk_rs->throttle_state = throttle_group_incref(throttling_group);\n            blk_rs->throttle_state->cfg = cfg;\n        }\n        QDECREF(bs_opts);\n    } else {\n        if (file && !*file) {\n            file = NULL;\n        }\n        blk = blk_new_open(qemu_opts_id(opts), file, NULL, bs_opts, bdrv_flags,\n                           errp);\n        if (!blk) {\n            goto err_no_bs_opts;\n        }\n        bs = blk_bs(blk);\n        bs->detect_zeroes = detect_zeroes;\n        /* disk I/O throttling */\n        if (throttle_enabled(&cfg)) {\n            if (!throttling_group) {\n                throttling_group = blk_name(blk);\n            }\n            bdrv_io_limits_enable(bs, throttling_group);\n            bdrv_set_io_limits(bs, &cfg);\n        }\n        if (bdrv_key_required(bs)) {\n            autostart = 0;\n        }\n        block_acct_init(blk_get_stats(blk), account_invalid, account_failed);\n    }\n    blk_set_on_error(blk, on_read_error, on_write_error);\nerr_no_bs_opts:\n    qemu_opts_del(opts);\n    return blk;\nearly_err:\n    qemu_opts_del(opts);\nerr_no_opts:\n    QDECREF(bs_opts);\n    return NULL;\n}", "idx": 19866, "_split": "valid", "_hash": "13d2543d0e4fe6e7bd53a9dd05b9ac51"}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "static void escc_mem_write(void *opaque, hwaddr addr,\n\n                           uint64_t val, unsigned size)\n\n{\n\n    ESCCState *serial = opaque;\n\n    ChannelState *s;\n\n    uint32_t saddr;\n\n    int newreg, channel;\n\n\n\n    val &= 0xff;\n\n    saddr = (addr >> serial->it_shift) & 1;\n\n    channel = (addr >> (serial->it_shift + 1)) & 1;\n\n    s = &serial->chn[channel];\n\n    switch (saddr) {\n\n    case SERIAL_CTRL:\n\n        trace_escc_mem_writeb_ctrl(CHN_C(s), s->reg, val & 0xff);\n\n        newreg = 0;\n\n        switch (s->reg) {\n\n        case W_CMD:\n\n            newreg = val & CMD_PTR_MASK;\n\n            val &= CMD_CMD_MASK;\n\n            switch (val) {\n\n            case CMD_HI:\n\n                newreg |= CMD_HI;\n\n                break;\n\n            case CMD_CLR_TXINT:\n\n                clr_txint(s);\n\n                break;\n\n            case CMD_CLR_IUS:\n\n                if (s->rxint_under_svc) {\n\n                    s->rxint_under_svc = 0;\n\n                    if (s->txint) {\n\n                        set_txint(s);\n\n                    }\n\n                } else if (s->txint_under_svc) {\n\n                    s->txint_under_svc = 0;\n\n                }\n\n                escc_update_irq(s);\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n            break;\n\n        case W_INTR ... W_RXCTRL:\n\n        case W_SYNC1 ... W_TXBUF:\n\n        case W_MISC1 ... W_CLOCK:\n\n        case W_MISC2 ... W_EXTINT:\n\n            s->wregs[s->reg] = val;\n\n            break;\n\n        case W_TXCTRL1:\n\n        case W_TXCTRL2:\n\n            s->wregs[s->reg] = val;\n\n            escc_update_parameters(s);\n\n            break;\n\n        case W_BRGLO:\n\n        case W_BRGHI:\n\n            s->wregs[s->reg] = val;\n\n            s->rregs[s->reg] = val;\n\n            escc_update_parameters(s);\n\n            break;\n\n        case W_MINTR:\n\n            switch (val & MINTR_RST_MASK) {\n\n            case 0:\n\n            default:\n\n                break;\n\n            case MINTR_RST_B:\n\n                escc_reset_chn(&serial->chn[0]);\n\n                return;\n\n            case MINTR_RST_A:\n\n                escc_reset_chn(&serial->chn[1]);\n\n                return;\n\n            case MINTR_RST_ALL:\n\n                escc_reset(DEVICE(serial));\n\n                return;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        if (s->reg == 0)\n\n            s->reg = newreg;\n\n        else\n\n            s->reg = 0;\n\n        break;\n\n    case SERIAL_DATA:\n\n        trace_escc_mem_writeb_data(CHN_C(s), val);\n\n        s->tx = val;\n\n        if (s->wregs[W_TXCTRL2] & TXCTRL2_TXEN) { // tx enabled\n\n            if (s->chr)\n\n                qemu_chr_fe_write(s->chr, &s->tx, 1);\n\n            else if (s->type == kbd && !s->disabled) {\n\n                handle_kbd_command(s, val);\n\n            }\n\n        }\n\n        s->rregs[R_STATUS] |= STATUS_TXEMPTY; // Tx buffer empty\n\n        s->rregs[R_SPEC] |= SPEC_ALLSENT; // All sent\n\n        set_txint(s);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 19875, "_split": "valid", "_hash": "18c38e0b1e21a140997c48dfac0f5318"}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static int adb_kbd_request(ADBDevice *d, uint8_t *obuf,\n\n                           const uint8_t *buf, int len)\n\n{\n\n    KBDState *s = ADB_KEYBOARD(d);\n\n    int cmd, reg, olen;\n\n\n\n    if ((buf[0] & 0x0f) == ADB_FLUSH) {\n\n        /* flush keyboard fifo */\n\n        s->wptr = s->rptr = s->count = 0;\n\n        return 0;\n\n    }\n\n\n\n    cmd = buf[0] & 0xc;\n\n    reg = buf[0] & 0x3;\n\n    olen = 0;\n\n    switch(cmd) {\n\n    case ADB_WRITEREG:\n\n        switch(reg) {\n\n        case 2:\n\n            /* LED status */\n\n            break;\n\n        case 3:\n\n            switch(buf[2]) {\n\n            case ADB_CMD_SELF_TEST:\n\n                break;\n\n            case ADB_CMD_CHANGE_ID:\n\n            case ADB_CMD_CHANGE_ID_AND_ACT:\n\n            case ADB_CMD_CHANGE_ID_AND_ENABLE:\n\n                d->devaddr = buf[1] & 0xf;\n\n                break;\n\n            default:\n\n                d->devaddr = buf[1] & 0xf;\n\n                /* we support handlers:\n\n                 * 1: Apple Standard Keyboard\n\n                 * 2: Apple Extended Keyboard (LShift = RShift)\n\n                 * 3: Apple Extended Keyboard (LShift != RShift)\n\n                 */\n\n                if (buf[2] == 1 || buf[2] == 2 || buf[2] == 3) {\n\n                    d->handler = buf[2];\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    case ADB_READREG:\n\n        switch(reg) {\n\n        case 0:\n\n            olen = adb_kbd_poll(d, obuf);\n\n            break;\n\n        case 1:\n\n            break;\n\n        case 2:\n\n            obuf[0] = 0x00; /* XXX: check this */\n\n            obuf[1] = 0x07; /* led status */\n\n            olen = 2;\n\n            break;\n\n        case 3:\n\n            obuf[0] = d->handler;\n\n            obuf[1] = d->devaddr;\n\n            olen = 2;\n\n            break;\n\n        }\n\n        break;\n\n    }\n\n    return olen;\n\n}\n", "idx": 19907, "_split": "valid", "_hash": "8f8422deacf79e72da675ae8f152b7d0"}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static int cdrom_open(BlockDriverState *bs, QDict *options, int flags,\n\n                      Error **errp)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    int ret;\n\n\n\n    s->type = FTYPE_CD;\n\n\n\n    /* open will not fail even if no CD is inserted, so add O_NONBLOCK */\n\n    ret = raw_open_common(bs, options, flags, O_NONBLOCK, errp);\n\n    return ret;\n\n}\n", "idx": 19932, "_split": "valid", "_hash": "691c4e5173438886cedfc5d8f69d6d9f"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void imx_serial_create(int uart, const target_phys_addr_t addr, qemu_irq irq)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *bus;\n\n    CharDriverState *chr;\n\n    const char chr_name[] = \"serial\";\n\n    char label[ARRAY_SIZE(chr_name) + 1];\n\n\n\n    dev = qdev_create(NULL, \"imx-serial\");\n\n\n\n    if (uart >= MAX_SERIAL_PORTS) {\n\n        hw_error(\"Cannot assign uart %d: QEMU supports only %d ports\\n\",\n\n                 uart, MAX_SERIAL_PORTS);\n\n    }\n\n    chr = serial_hds[uart];\n\n    if (!chr) {\n\n        snprintf(label, ARRAY_SIZE(label), \"%s%d\", chr_name, uart);\n\n        chr = qemu_chr_new(label, \"null\", NULL);\n\n        if (!(chr)) {\n\n            hw_error(\"Can't assign serial port to imx-uart%d.\\n\", uart);\n\n        }\n\n    }\n\n\n\n    qdev_prop_set_chr(dev, \"chardev\", chr);\n\n    bus = sysbus_from_qdev(dev);\n\n    qdev_init_nofail(dev);\n\n    if (addr != (target_phys_addr_t)-1) {\n\n        sysbus_mmio_map(bus, 0, addr);\n\n    }\n\n    sysbus_connect_irq(bus, 0, irq);\n\n\n\n}\n", "idx": 19933, "_split": "valid", "_hash": "e44452dac8eef75d25372f0d7de2695c"}
{"project": "qemu", "commit_id": "d07cc1f12d8e15c167857852c39190d770763824", "target": 0, "func": "static KVMMSIRoute *kvm_lookup_msi_route(KVMState *s, MSIMessage msg)\n\n{\n\n    unsigned int hash = kvm_hash_msi(msg.data);\n\n    KVMMSIRoute *route;\n\n\n\n    QTAILQ_FOREACH(route, &s->msi_hashtab[hash], entry) {\n\n        if (route->kroute.u.msi.address_lo == (uint32_t)msg.address &&\n\n            route->kroute.u.msi.address_hi == (msg.address >> 32) &&\n\n            route->kroute.u.msi.data == msg.data) {\n\n            return route;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "idx": 19935, "_split": "valid", "_hash": "029dddbce5a5ec4358ee7731e3c1fecc"}
{"project": "qemu", "commit_id": "02b07434bed8360715198b4cbfdfebd17f7cac32", "target": 0, "func": "static int pxb_bus_num(PCIBus *bus)\n\n{\n\n    PXBDev *pxb = PXB_DEV(bus->parent_dev);\n\n\n\n    return pxb->bus_nr;\n\n}\n", "idx": 19949, "_split": "valid", "_hash": "6e93741d29fc9adc949fdcfa4e9f12cf"}
{"project": "qemu", "commit_id": "3604a76fea6ff37738d4a8f596be38407be74a83", "target": 1, "func": "static void dec_user(DisasContext *dc)\n\n{\n\n    LOG_DIS(\"user\");\n\n\n\n    cpu_abort(dc->env, \"user insn undefined\\n\");\n\n}\n", "idx": 19963, "_split": "valid", "_hash": "ea86ec939232d3df74233bdcde125ca5"}
{"project": "qemu", "commit_id": "4cc2cc085586cdb787a24d78a7ba032fa657275a", "target": 1, "func": "target_ulong helper_load_slb_esid(CPUPPCState *env, target_ulong rb)\n\n{\n\n    target_ulong rt;\n\n\n\n    if (ppc_load_slb_esid(env, rb, &rt) < 0) {\n\n        helper_raise_exception_err(env, POWERPC_EXCP_PROGRAM,\n\n                                   POWERPC_EXCP_INVAL);\n\n    }\n\n    return rt;\n\n}\n", "idx": 19970, "_split": "valid", "_hash": "70fe64f51f9e7fd3b63b8d368923f2bc"}
{"project": "qemu", "commit_id": "f51074cdc6e750daa3b6df727d83449a7e42b391", "target": 1, "func": "void hmp_pci_del(Monitor *mon, const QDict *qdict)\n\n{\n\n    pci_device_hot_remove(mon, qdict_get_str(qdict, \"pci_addr\"));\n\n}\n", "idx": 19991, "_split": "valid", "_hash": "4d496efdb552cd556df1be10a29afa76"}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "QEMUPutMouseEntry *qemu_add_mouse_event_handler(QEMUPutMouseEvent *func,\n\n                                                void *opaque, int absolute,\n\n                                                const char *name)\n\n{\n\n    QEMUPutMouseEntry *s;\n\n\n\n    s = g_malloc0(sizeof(QEMUPutMouseEntry));\n\n\n\n    s->qemu_put_mouse_event = func;\n\n    s->qemu_put_mouse_event_opaque = opaque;\n\n    s->qemu_put_mouse_event_absolute = absolute;\n\n\n\n    s->h.name = name;\n\n    s->h.mask = INPUT_EVENT_MASK_BTN |\n\n        (absolute ? INPUT_EVENT_MASK_ABS : INPUT_EVENT_MASK_REL);\n\n    s->h.event = legacy_mouse_event;\n\n    s->h.sync = legacy_mouse_sync;\n\n    s->s = qemu_input_handler_register((DeviceState *)s,\n\n                                       &s->h);\n\n\n\n    return s;\n\n}\n", "idx": 19993, "_split": "valid", "_hash": "bbf7de236d00ab0faf4a866c91c12104"}
{"project": "qemu", "commit_id": "9745807191a81c45970f780166f44a7f93b18653", "target": 1, "func": "static void gen_add(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)\n\n{\n\n    TCGv t0 = tcg_const_tl(0);\n\n    TCGv res = tcg_temp_new();\n\n    TCGv sr_cy = tcg_temp_new();\n\n    TCGv sr_ov = tcg_temp_new();\n\n\n\n    tcg_gen_add2_tl(res, sr_cy, srca, t0, srcb, t0);\n\n    tcg_gen_xor_tl(sr_ov, srca, srcb);\n\n    tcg_gen_xor_tl(t0, res, srcb);\n\n    tcg_gen_andc_tl(sr_ov, t0, sr_ov);\n\n    tcg_temp_free(t0);\n\n\n\n    tcg_gen_mov_tl(dest, res);\n\n    tcg_temp_free(res);\n\n\n\n    tcg_gen_shri_tl(sr_ov, sr_ov, TARGET_LONG_BITS - 1);\n\n    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);\n\n    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_ov, ctz32(SR_OV), 1);\n\n\n\n    gen_ove_cyov(dc, sr_ov, sr_cy);\n\n    tcg_temp_free(sr_ov);\n\n    tcg_temp_free(sr_cy);\n\n}\n", "idx": 20009, "_split": "valid", "_hash": "035b39386c30a76e61504c79f6f20ba7"}
{"project": "qemu", "commit_id": "7839ff593be03a7de3c6760e0b50c565ea751d36", "target": 1, "func": "static void pc_q35_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size;\n\n    Q35PCIHost *q35_host;\n\n    PCIHostState *phb;\n\n    PCIBus *host_bus;\n\n    PCIDevice *lpc;\n\n    BusState *idebus[MAX_SATA_PORTS];\n\n    ISADevice *rtc_state;\n\n    ISADevice *floppy;\n\n    MemoryRegion *pci_memory;\n\n    MemoryRegion *rom_memory;\n\n    MemoryRegion *ram_memory;\n\n    GSIState *gsi_state;\n\n    ISABus *isa_bus;\n\n    int pci_enabled = 1;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *gsi;\n\n    qemu_irq *i8259;\n\n    int i;\n\n    ICH9LPCState *ich9_lpc;\n\n    PCIDevice *ahci;\n\n    DeviceState *icc_bridge;\n\n    PcGuestInfo *guest_info;\n\n\n\n    if (xen_enabled() && xen_hvm_init(&ram_memory) != 0) {\n\n        fprintf(stderr, \"xen hardware virtual machine initialisation failed\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    icc_bridge = qdev_create(NULL, TYPE_ICC_BRIDGE);\n\n    object_property_add_child(qdev_get_machine(), \"icc-bridge\",\n\n                              OBJECT(icc_bridge), NULL);\n\n\n\n    pc_cpus_init(args->cpu_model, icc_bridge);\n\n    pc_acpi_init(\"q35-acpi-dsdt.aml\");\n\n\n\n    kvmclock_create();\n\n\n\n    if (args->ram_size >= 0xb0000000) {\n\n        above_4g_mem_size = args->ram_size - 0xb0000000;\n\n        below_4g_mem_size = 0xb0000000;\n\n    } else {\n\n        above_4g_mem_size = 0;\n\n        below_4g_mem_size = args->ram_size;\n\n    }\n\n\n\n    /* pci enabled */\n\n    if (pci_enabled) {\n\n        pci_memory = g_new(MemoryRegion, 1);\n\n        memory_region_init(pci_memory, NULL, \"pci\", INT64_MAX);\n\n        rom_memory = pci_memory;\n\n    } else {\n\n        pci_memory = NULL;\n\n        rom_memory = get_system_memory();\n\n    }\n\n\n\n    guest_info = pc_guest_info_init(below_4g_mem_size, above_4g_mem_size);\n\n    guest_info->has_pci_info = has_pci_info;\n\n    guest_info->isapc_ram_fw = false;\n\n    guest_info->has_acpi_build = has_acpi_build;\n\n\n\n    /* allocate ram and load rom/bios */\n\n    if (!xen_enabled()) {\n\n        pc_memory_init(get_system_memory(),\n\n                       args->kernel_filename, args->kernel_cmdline,\n\n                       args->initrd_filename,\n\n                       below_4g_mem_size, above_4g_mem_size,\n\n                       rom_memory, &ram_memory, guest_info);\n\n    }\n\n\n\n    /* irq lines */\n\n    gsi_state = g_malloc0(sizeof(*gsi_state));\n\n    if (kvm_irqchip_in_kernel()) {\n\n        kvm_pc_setup_irq_routing(pci_enabled);\n\n        gsi = qemu_allocate_irqs(kvm_pc_gsi_handler, gsi_state,\n\n                                 GSI_NUM_PINS);\n\n    } else {\n\n        gsi = qemu_allocate_irqs(gsi_handler, gsi_state, GSI_NUM_PINS);\n\n    }\n\n\n\n    /* create pci host bus */\n\n    q35_host = Q35_HOST_DEVICE(qdev_create(NULL, TYPE_Q35_HOST_DEVICE));\n\n\n\n    object_property_add_child(qdev_get_machine(), \"q35\", OBJECT(q35_host), NULL);\n\n    q35_host->mch.ram_memory = ram_memory;\n\n    q35_host->mch.pci_address_space = pci_memory;\n\n    q35_host->mch.system_memory = get_system_memory();\n\n    q35_host->mch.address_space_io = get_system_io();\n\n    q35_host->mch.below_4g_mem_size = below_4g_mem_size;\n\n    q35_host->mch.above_4g_mem_size = above_4g_mem_size;\n\n    q35_host->mch.guest_info = guest_info;\n\n    /* pci */\n\n    qdev_init_nofail(DEVICE(q35_host));\n\n    phb = PCI_HOST_BRIDGE(q35_host);\n\n    host_bus = phb->bus;\n\n    /* create ISA bus */\n\n    lpc = pci_create_simple_multifunction(host_bus, PCI_DEVFN(ICH9_LPC_DEV,\n\n                                          ICH9_LPC_FUNC), true,\n\n                                          TYPE_ICH9_LPC_DEVICE);\n\n    ich9_lpc = ICH9_LPC_DEVICE(lpc);\n\n    ich9_lpc->pic = gsi;\n\n    ich9_lpc->ioapic = gsi_state->ioapic_irq;\n\n    pci_bus_irqs(host_bus, ich9_lpc_set_irq, ich9_lpc_map_irq, ich9_lpc,\n\n                 ICH9_LPC_NB_PIRQS);\n\n    pci_bus_set_route_irq_fn(host_bus, ich9_route_intx_pin_to_irq);\n\n    isa_bus = ich9_lpc->isa_bus;\n\n\n\n    /*end early*/\n\n    isa_bus_irqs(isa_bus, gsi);\n\n\n\n    if (kvm_irqchip_in_kernel()) {\n\n        i8259 = kvm_i8259_init(isa_bus);\n\n    } else if (xen_enabled()) {\n\n        i8259 = xen_interrupt_controller_init();\n\n    } else {\n\n        cpu_irq = pc_allocate_cpu_irq();\n\n        i8259 = i8259_init(isa_bus, cpu_irq[0]);\n\n    }\n\n\n\n    for (i = 0; i < ISA_NUM_IRQS; i++) {\n\n        gsi_state->i8259_irq[i] = i8259[i];\n\n    }\n\n    if (pci_enabled) {\n\n        ioapic_init_gsi(gsi_state, NULL);\n\n    }\n\n    qdev_init_nofail(icc_bridge);\n\n\n\n    pc_register_ferr_irq(gsi[13]);\n\n\n\n    /* init basic PC hardware */\n\n    pc_basic_device_init(isa_bus, gsi, &rtc_state, &floppy, false);\n\n\n\n    /* connect pm stuff to lpc */\n\n    ich9_lpc_pm_init(lpc);\n\n\n\n    /* ahci and SATA device, for q35 1 ahci controller is built-in */\n\n    ahci = pci_create_simple_multifunction(host_bus,\n\n                                           PCI_DEVFN(ICH9_SATA1_DEV,\n\n                                                     ICH9_SATA1_FUNC),\n\n                                           true, \"ich9-ahci\");\n\n    idebus[0] = qdev_get_child_bus(&ahci->qdev, \"ide.0\");\n\n    idebus[1] = qdev_get_child_bus(&ahci->qdev, \"ide.1\");\n\n\n\n    if (usb_enabled(false)) {\n\n        /* Should we create 6 UHCI according to ich9 spec? */\n\n        ehci_create_ich9_with_companions(host_bus, 0x1d);\n\n    }\n\n\n\n    /* TODO: Populate SPD eeprom data.  */\n\n    smbus_eeprom_init(ich9_smb_init(host_bus,\n\n                                    PCI_DEVFN(ICH9_SMB_DEV, ICH9_SMB_FUNC),\n\n                                    0xb100),\n\n                      8, NULL, 0);\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, args->boot_order,\n\n                 floppy, idebus[0], idebus[1], rtc_state);\n\n\n\n    /* the rest devices to which pci devfn is automatically assigned */\n\n    pc_vga_init(isa_bus, host_bus);\n\n    pc_nic_init(isa_bus, host_bus);\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(host_bus);\n\n    }\n\n\n\n    if (has_pvpanic) {\n\n        pvpanic_init(isa_bus);\n\n    }\n\n}\n", "idx": 20023, "_split": "valid", "_hash": "3b1c378cebacbbef53d00a8dcb0e6092"}
{"project": "qemu", "commit_id": "576c6eb6700d241c9d4a6883d25720c7bbaaeccd", "target": 1, "func": "int tap_open(char *ifname, int ifname_size, int *vnet_hdr,\n\n             int vnet_hdr_required, int mq_required, Error **errp)\n\n{\n\n    /* FIXME error_setg(errp, ...) on failure */\n\n    char  dev[10]=\"\";\n\n    int fd;\n\n    if( (fd = tap_alloc(dev, sizeof(dev))) < 0 ){\n\n       fprintf(stderr, \"Cannot allocate TAP device\\n\");\n\n       return -1;\n\n    }\n\n    pstrcpy(ifname, ifname_size, dev);\n\n    if (*vnet_hdr) {\n\n        /* Solaris doesn't have IFF_VNET_HDR */\n\n        *vnet_hdr = 0;\n\n\n\n        if (vnet_hdr_required && !*vnet_hdr) {\n\n            error_report(\"vnet_hdr=1 requested, but no kernel \"\n\n                         \"support for IFF_VNET_HDR available\");\n\n            close(fd);\n\n            return -1;\n\n        }\n\n    }\n\n    fcntl(fd, F_SETFL, O_NONBLOCK);\n\n    return fd;\n\n}\n", "idx": 20036, "_split": "valid", "_hash": "659d200a3a7c5fe686f17d62f9628fa0"}
{"project": "qemu", "commit_id": "16a9e8a5bcc1fb0796828eb654a4f926734e59af", "target": 0, "func": "static void pc_dimm_plug(HotplugHandler *hotplug_dev,\n\n                         DeviceState *dev, Error **errp)\n\n{\n\n    HotplugHandlerClass *hhc;\n\n    Error *local_err = NULL;\n\n    PCMachineState *pcms = PC_MACHINE(hotplug_dev);\n\n    PCDIMMDevice *dimm = PC_DIMM(dev);\n\n    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(dimm);\n\n    MemoryRegion *mr = ddc->get_memory_region(dimm);\n\n    uint64_t align = TARGET_PAGE_SIZE;\n\n\n\n    if (memory_region_get_alignment(mr) && pcms->enforce_aligned_dimm) {\n\n        align = memory_region_get_alignment(mr);\n\n    }\n\n\n\n    if (!pcms->acpi_dev) {\n\n        error_setg(&local_err,\n\n                   \"memory hotplug is not enabled: missing acpi device\");\n\n        goto out;\n\n    }\n\n\n\n    pc_dimm_memory_plug(dev, &pcms->hotplug_memory, mr, align, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    hhc = HOTPLUG_HANDLER_GET_CLASS(pcms->acpi_dev);\n\n    hhc->plug(HOTPLUG_HANDLER(pcms->acpi_dev), dev, &error_abort);\n\nout:\n\n    error_propagate(errp, local_err);\n\n}\n", "idx": 20060, "_split": "valid", "_hash": "a6015a545684468c6ea0d59756554a5c"}
{"project": "qemu", "commit_id": "7a2c4b82340d621bff462672b29c88d2020d68c1", "target": 0, "func": "static void cmd_test_unit_ready(IDEState *s, uint8_t *buf)\n\n{\n\n    if (bdrv_is_inserted(s->bs)) {\n\n        ide_atapi_cmd_ok(s);\n\n    } else {\n\n        ide_atapi_cmd_error(s, SENSE_NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n\n    }\n\n}\n", "idx": 20064, "_split": "valid", "_hash": "d0f9c5e4ba94603e88a7d3df83604f40"}
{"project": "qemu", "commit_id": "2b147555f78c3c20080b201fd1506467fa0ddf43", "target": 0, "func": "static int kvm_s390_check_enable_cmma(KVMState *s)\n\n{\n\n    struct kvm_device_attr attr = {\n\n        .group = KVM_S390_VM_MEM_CTRL,\n\n        .attr = KVM_S390_VM_MEM_ENABLE_CMMA,\n\n    };\n\n\n\n    return kvm_vm_ioctl(s, KVM_HAS_DEVICE_ATTR, &attr);\n\n}\n", "idx": 20068, "_split": "valid", "_hash": "745b360ec8e59de348797887f05db838"}
{"project": "qemu", "commit_id": "1208d7dd5fddc1fbd98de800d17429b4e5578848", "target": 0, "func": "void tcg_optimize(TCGContext *s)\n\n{\n\n    int oi, oi_next, nb_temps, nb_globals;\n\n\n\n    /* Array VALS has an element for each temp.\n\n       If this temp holds a constant then its value is kept in VALS' element.\n\n       If this temp is a copy of other ones then the other copies are\n\n       available through the doubly linked circular list. */\n\n\n\n    nb_temps = s->nb_temps;\n\n    nb_globals = s->nb_globals;\n\n    reset_all_temps(nb_temps);\n\n\n\n    for (oi = s->gen_first_op_idx; oi >= 0; oi = oi_next) {\n\n        tcg_target_ulong mask, partmask, affected;\n\n        int nb_oargs, nb_iargs, i;\n\n        TCGArg tmp;\n\n\n\n        TCGOp * const op = &s->gen_op_buf[oi];\n\n        TCGArg * const args = &s->gen_opparam_buf[op->args];\n\n        TCGOpcode opc = op->opc;\n\n        const TCGOpDef *def = &tcg_op_defs[opc];\n\n\n\n        oi_next = op->next;\n\n        if (opc == INDEX_op_call) {\n\n            nb_oargs = op->callo;\n\n            nb_iargs = op->calli;\n\n        } else {\n\n            nb_oargs = def->nb_oargs;\n\n            nb_iargs = def->nb_iargs;\n\n        }\n\n\n\n        /* Do copy propagation */\n\n        for (i = nb_oargs; i < nb_oargs + nb_iargs; i++) {\n\n            if (temps[args[i]].state == TCG_TEMP_COPY) {\n\n                args[i] = find_better_copy(s, args[i]);\n\n            }\n\n        }\n\n\n\n        /* For commutative operations make constant second argument */\n\n        switch (opc) {\n\n        CASE_OP_32_64(add):\n\n        CASE_OP_32_64(mul):\n\n        CASE_OP_32_64(and):\n\n        CASE_OP_32_64(or):\n\n        CASE_OP_32_64(xor):\n\n        CASE_OP_32_64(eqv):\n\n        CASE_OP_32_64(nand):\n\n        CASE_OP_32_64(nor):\n\n        CASE_OP_32_64(muluh):\n\n        CASE_OP_32_64(mulsh):\n\n            swap_commutative(args[0], &args[1], &args[2]);\n\n            break;\n\n        CASE_OP_32_64(brcond):\n\n            if (swap_commutative(-1, &args[0], &args[1])) {\n\n                args[2] = tcg_swap_cond(args[2]);\n\n            }\n\n            break;\n\n        CASE_OP_32_64(setcond):\n\n            if (swap_commutative(args[0], &args[1], &args[2])) {\n\n                args[3] = tcg_swap_cond(args[3]);\n\n            }\n\n            break;\n\n        CASE_OP_32_64(movcond):\n\n            if (swap_commutative(-1, &args[1], &args[2])) {\n\n                args[5] = tcg_swap_cond(args[5]);\n\n            }\n\n            /* For movcond, we canonicalize the \"false\" input reg to match\n\n               the destination reg so that the tcg backend can implement\n\n               a \"move if true\" operation.  */\n\n            if (swap_commutative(args[0], &args[4], &args[3])) {\n\n                args[5] = tcg_invert_cond(args[5]);\n\n            }\n\n            break;\n\n        CASE_OP_32_64(add2):\n\n            swap_commutative(args[0], &args[2], &args[4]);\n\n            swap_commutative(args[1], &args[3], &args[5]);\n\n            break;\n\n        CASE_OP_32_64(mulu2):\n\n        CASE_OP_32_64(muls2):\n\n            swap_commutative(args[0], &args[2], &args[3]);\n\n            break;\n\n        case INDEX_op_brcond2_i32:\n\n            if (swap_commutative2(&args[0], &args[2])) {\n\n                args[4] = tcg_swap_cond(args[4]);\n\n            }\n\n            break;\n\n        case INDEX_op_setcond2_i32:\n\n            if (swap_commutative2(&args[1], &args[3])) {\n\n                args[5] = tcg_swap_cond(args[5]);\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n\n\n        /* Simplify expressions for \"shift/rot r, 0, a => movi r, 0\",\n\n           and \"sub r, 0, a => neg r, a\" case.  */\n\n        switch (opc) {\n\n        CASE_OP_32_64(shl):\n\n        CASE_OP_32_64(shr):\n\n        CASE_OP_32_64(sar):\n\n        CASE_OP_32_64(rotl):\n\n        CASE_OP_32_64(rotr):\n\n            if (temps[args[1]].state == TCG_TEMP_CONST\n\n                && temps[args[1]].val == 0) {\n\n                tcg_opt_gen_movi(s, op, args, args[0], 0);\n\n                continue;\n\n            }\n\n            break;\n\n        CASE_OP_32_64(sub):\n\n            {\n\n                TCGOpcode neg_op;\n\n                bool have_neg;\n\n\n\n                if (temps[args[2]].state == TCG_TEMP_CONST) {\n\n                    /* Proceed with possible constant folding. */\n\n                    break;\n\n                }\n\n                if (opc == INDEX_op_sub_i32) {\n\n                    neg_op = INDEX_op_neg_i32;\n\n                    have_neg = TCG_TARGET_HAS_neg_i32;\n\n                } else {\n\n                    neg_op = INDEX_op_neg_i64;\n\n                    have_neg = TCG_TARGET_HAS_neg_i64;\n\n                }\n\n                if (!have_neg) {\n\n                    break;\n\n                }\n\n                if (temps[args[1]].state == TCG_TEMP_CONST\n\n                    && temps[args[1]].val == 0) {\n\n                    op->opc = neg_op;\n\n                    reset_temp(args[0]);\n\n                    args[1] = args[2];\n\n                    continue;\n\n                }\n\n            }\n\n            break;\n\n        CASE_OP_32_64(xor):\n\n        CASE_OP_32_64(nand):\n\n            if (temps[args[1]].state != TCG_TEMP_CONST\n\n                && temps[args[2]].state == TCG_TEMP_CONST\n\n                && temps[args[2]].val == -1) {\n\n                i = 1;\n\n                goto try_not;\n\n            }\n\n            break;\n\n        CASE_OP_32_64(nor):\n\n            if (temps[args[1]].state != TCG_TEMP_CONST\n\n                && temps[args[2]].state == TCG_TEMP_CONST\n\n                && temps[args[2]].val == 0) {\n\n                i = 1;\n\n                goto try_not;\n\n            }\n\n            break;\n\n        CASE_OP_32_64(andc):\n\n            if (temps[args[2]].state != TCG_TEMP_CONST\n\n                && temps[args[1]].state == TCG_TEMP_CONST\n\n                && temps[args[1]].val == -1) {\n\n                i = 2;\n\n                goto try_not;\n\n            }\n\n            break;\n\n        CASE_OP_32_64(orc):\n\n        CASE_OP_32_64(eqv):\n\n            if (temps[args[2]].state != TCG_TEMP_CONST\n\n                && temps[args[1]].state == TCG_TEMP_CONST\n\n                && temps[args[1]].val == 0) {\n\n                i = 2;\n\n                goto try_not;\n\n            }\n\n            break;\n\n        try_not:\n\n            {\n\n                TCGOpcode not_op;\n\n                bool have_not;\n\n\n\n                if (def->flags & TCG_OPF_64BIT) {\n\n                    not_op = INDEX_op_not_i64;\n\n                    have_not = TCG_TARGET_HAS_not_i64;\n\n                } else {\n\n                    not_op = INDEX_op_not_i32;\n\n                    have_not = TCG_TARGET_HAS_not_i32;\n\n                }\n\n                if (!have_not) {\n\n                    break;\n\n                }\n\n                op->opc = not_op;\n\n                reset_temp(args[0]);\n\n                args[1] = args[i];\n\n                continue;\n\n            }\n\n        default:\n\n            break;\n\n        }\n\n\n\n        /* Simplify expression for \"op r, a, const => mov r, a\" cases */\n\n        switch (opc) {\n\n        CASE_OP_32_64(add):\n\n        CASE_OP_32_64(sub):\n\n        CASE_OP_32_64(shl):\n\n        CASE_OP_32_64(shr):\n\n        CASE_OP_32_64(sar):\n\n        CASE_OP_32_64(rotl):\n\n        CASE_OP_32_64(rotr):\n\n        CASE_OP_32_64(or):\n\n        CASE_OP_32_64(xor):\n\n        CASE_OP_32_64(andc):\n\n            if (temps[args[1]].state != TCG_TEMP_CONST\n\n                && temps[args[2]].state == TCG_TEMP_CONST\n\n                && temps[args[2]].val == 0) {\n\n                tcg_opt_gen_mov(s, op, args, args[0], args[1]);\n\n                continue;\n\n            }\n\n            break;\n\n        CASE_OP_32_64(and):\n\n        CASE_OP_32_64(orc):\n\n        CASE_OP_32_64(eqv):\n\n            if (temps[args[1]].state != TCG_TEMP_CONST\n\n                && temps[args[2]].state == TCG_TEMP_CONST\n\n                && temps[args[2]].val == -1) {\n\n                tcg_opt_gen_mov(s, op, args, args[0], args[1]);\n\n                continue;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n\n\n        /* Simplify using known-zero bits. Currently only ops with a single\n\n           output argument is supported. */\n\n        mask = -1;\n\n        affected = -1;\n\n        switch (opc) {\n\n        CASE_OP_32_64(ext8s):\n\n            if ((temps[args[1]].mask & 0x80) != 0) {\n\n                break;\n\n            }\n\n        CASE_OP_32_64(ext8u):\n\n            mask = 0xff;\n\n            goto and_const;\n\n        CASE_OP_32_64(ext16s):\n\n            if ((temps[args[1]].mask & 0x8000) != 0) {\n\n                break;\n\n            }\n\n        CASE_OP_32_64(ext16u):\n\n            mask = 0xffff;\n\n            goto and_const;\n\n        case INDEX_op_ext32s_i64:\n\n            if ((temps[args[1]].mask & 0x80000000) != 0) {\n\n                break;\n\n            }\n\n        case INDEX_op_ext32u_i64:\n\n            mask = 0xffffffffU;\n\n            goto and_const;\n\n\n\n        CASE_OP_32_64(and):\n\n            mask = temps[args[2]].mask;\n\n            if (temps[args[2]].state == TCG_TEMP_CONST) {\n\n        and_const:\n\n                affected = temps[args[1]].mask & ~mask;\n\n            }\n\n            mask = temps[args[1]].mask & mask;\n\n            break;\n\n\n\n        CASE_OP_32_64(andc):\n\n            /* Known-zeros does not imply known-ones.  Therefore unless\n\n               args[2] is constant, we can't infer anything from it.  */\n\n            if (temps[args[2]].state == TCG_TEMP_CONST) {\n\n                mask = ~temps[args[2]].mask;\n\n                goto and_const;\n\n            }\n\n            /* But we certainly know nothing outside args[1] may be set. */\n\n            mask = temps[args[1]].mask;\n\n            break;\n\n\n\n        case INDEX_op_sar_i32:\n\n            if (temps[args[2]].state == TCG_TEMP_CONST) {\n\n                tmp = temps[args[2]].val & 31;\n\n                mask = (int32_t)temps[args[1]].mask >> tmp;\n\n            }\n\n            break;\n\n        case INDEX_op_sar_i64:\n\n            if (temps[args[2]].state == TCG_TEMP_CONST) {\n\n                tmp = temps[args[2]].val & 63;\n\n                mask = (int64_t)temps[args[1]].mask >> tmp;\n\n            }\n\n            break;\n\n\n\n        case INDEX_op_shr_i32:\n\n            if (temps[args[2]].state == TCG_TEMP_CONST) {\n\n                tmp = temps[args[2]].val & 31;\n\n                mask = (uint32_t)temps[args[1]].mask >> tmp;\n\n            }\n\n            break;\n\n        case INDEX_op_shr_i64:\n\n            if (temps[args[2]].state == TCG_TEMP_CONST) {\n\n                tmp = temps[args[2]].val & 63;\n\n                mask = (uint64_t)temps[args[1]].mask >> tmp;\n\n            }\n\n            break;\n\n\n\n        case INDEX_op_trunc_shr_i32:\n\n            mask = (uint64_t)temps[args[1]].mask >> args[2];\n\n            break;\n\n\n\n        CASE_OP_32_64(shl):\n\n            if (temps[args[2]].state == TCG_TEMP_CONST) {\n\n                tmp = temps[args[2]].val & (TCG_TARGET_REG_BITS - 1);\n\n                mask = temps[args[1]].mask << tmp;\n\n            }\n\n            break;\n\n\n\n        CASE_OP_32_64(neg):\n\n            /* Set to 1 all bits to the left of the rightmost.  */\n\n            mask = -(temps[args[1]].mask & -temps[args[1]].mask);\n\n            break;\n\n\n\n        CASE_OP_32_64(deposit):\n\n            mask = deposit64(temps[args[1]].mask, args[3], args[4],\n\n                             temps[args[2]].mask);\n\n            break;\n\n\n\n        CASE_OP_32_64(or):\n\n        CASE_OP_32_64(xor):\n\n            mask = temps[args[1]].mask | temps[args[2]].mask;\n\n            break;\n\n\n\n        CASE_OP_32_64(setcond):\n\n        case INDEX_op_setcond2_i32:\n\n            mask = 1;\n\n            break;\n\n\n\n        CASE_OP_32_64(movcond):\n\n            mask = temps[args[3]].mask | temps[args[4]].mask;\n\n            break;\n\n\n\n        CASE_OP_32_64(ld8u):\n\n            mask = 0xff;\n\n            break;\n\n        CASE_OP_32_64(ld16u):\n\n            mask = 0xffff;\n\n            break;\n\n        case INDEX_op_ld32u_i64:\n\n            mask = 0xffffffffu;\n\n            break;\n\n\n\n        CASE_OP_32_64(qemu_ld):\n\n            {\n\n                TCGMemOpIdx oi = args[nb_oargs + nb_iargs];\n\n                TCGMemOp mop = get_memop(oi);\n\n                if (!(mop & MO_SIGN)) {\n\n                    mask = (2ULL << ((8 << (mop & MO_SIZE)) - 1)) - 1;\n\n                }\n\n            }\n\n            break;\n\n\n\n        default:\n\n            break;\n\n        }\n\n\n\n        /* 32-bit ops generate 32-bit results.  For the result is zero test\n\n           below, we can ignore high bits, but for further optimizations we\n\n           need to record that the high bits contain garbage.  */\n\n        partmask = mask;\n\n        if (!(def->flags & TCG_OPF_64BIT)) {\n\n            mask |= ~(tcg_target_ulong)0xffffffffu;\n\n            partmask &= 0xffffffffu;\n\n            affected &= 0xffffffffu;\n\n        }\n\n\n\n        if (partmask == 0) {\n\n            assert(nb_oargs == 1);\n\n            tcg_opt_gen_movi(s, op, args, args[0], 0);\n\n            continue;\n\n        }\n\n        if (affected == 0) {\n\n            assert(nb_oargs == 1);\n\n            tcg_opt_gen_mov(s, op, args, args[0], args[1]);\n\n            continue;\n\n        }\n\n\n\n        /* Simplify expression for \"op r, a, 0 => movi r, 0\" cases */\n\n        switch (opc) {\n\n        CASE_OP_32_64(and):\n\n        CASE_OP_32_64(mul):\n\n        CASE_OP_32_64(muluh):\n\n        CASE_OP_32_64(mulsh):\n\n            if ((temps[args[2]].state == TCG_TEMP_CONST\n\n                && temps[args[2]].val == 0)) {\n\n                tcg_opt_gen_movi(s, op, args, args[0], 0);\n\n                continue;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n\n\n        /* Simplify expression for \"op r, a, a => mov r, a\" cases */\n\n        switch (opc) {\n\n        CASE_OP_32_64(or):\n\n        CASE_OP_32_64(and):\n\n            if (temps_are_copies(args[1], args[2])) {\n\n                tcg_opt_gen_mov(s, op, args, args[0], args[1]);\n\n                continue;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n\n\n        /* Simplify expression for \"op r, a, a => movi r, 0\" cases */\n\n        switch (opc) {\n\n        CASE_OP_32_64(andc):\n\n        CASE_OP_32_64(sub):\n\n        CASE_OP_32_64(xor):\n\n            if (temps_are_copies(args[1], args[2])) {\n\n                tcg_opt_gen_movi(s, op, args, args[0], 0);\n\n                continue;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n\n\n        /* Propagate constants through copy operations and do constant\n\n           folding.  Constants will be substituted to arguments by register\n\n           allocator where needed and possible.  Also detect copies. */\n\n        switch (opc) {\n\n        CASE_OP_32_64(mov):\n\n            tcg_opt_gen_mov(s, op, args, args[0], args[1]);\n\n            break;\n\n        CASE_OP_32_64(movi):\n\n            tcg_opt_gen_movi(s, op, args, args[0], args[1]);\n\n            break;\n\n\n\n        CASE_OP_32_64(not):\n\n        CASE_OP_32_64(neg):\n\n        CASE_OP_32_64(ext8s):\n\n        CASE_OP_32_64(ext8u):\n\n        CASE_OP_32_64(ext16s):\n\n        CASE_OP_32_64(ext16u):\n\n        case INDEX_op_ext32s_i64:\n\n        case INDEX_op_ext32u_i64:\n\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n\n                tmp = do_constant_folding(opc, temps[args[1]].val, 0);\n\n                tcg_opt_gen_movi(s, op, args, args[0], tmp);\n\n                break;\n\n            }\n\n            goto do_default;\n\n\n\n        case INDEX_op_trunc_shr_i32:\n\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n\n                tmp = do_constant_folding(opc, temps[args[1]].val, args[2]);\n\n                tcg_opt_gen_movi(s, op, args, args[0], tmp);\n\n                break;\n\n            }\n\n            goto do_default;\n\n\n\n        CASE_OP_32_64(add):\n\n        CASE_OP_32_64(sub):\n\n        CASE_OP_32_64(mul):\n\n        CASE_OP_32_64(or):\n\n        CASE_OP_32_64(and):\n\n        CASE_OP_32_64(xor):\n\n        CASE_OP_32_64(shl):\n\n        CASE_OP_32_64(shr):\n\n        CASE_OP_32_64(sar):\n\n        CASE_OP_32_64(rotl):\n\n        CASE_OP_32_64(rotr):\n\n        CASE_OP_32_64(andc):\n\n        CASE_OP_32_64(orc):\n\n        CASE_OP_32_64(eqv):\n\n        CASE_OP_32_64(nand):\n\n        CASE_OP_32_64(nor):\n\n        CASE_OP_32_64(muluh):\n\n        CASE_OP_32_64(mulsh):\n\n        CASE_OP_32_64(div):\n\n        CASE_OP_32_64(divu):\n\n        CASE_OP_32_64(rem):\n\n        CASE_OP_32_64(remu):\n\n            if (temps[args[1]].state == TCG_TEMP_CONST\n\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n\n                tmp = do_constant_folding(opc, temps[args[1]].val,\n\n                                          temps[args[2]].val);\n\n                tcg_opt_gen_movi(s, op, args, args[0], tmp);\n\n                break;\n\n            }\n\n            goto do_default;\n\n\n\n        CASE_OP_32_64(deposit):\n\n            if (temps[args[1]].state == TCG_TEMP_CONST\n\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n\n                tmp = deposit64(temps[args[1]].val, args[3], args[4],\n\n                                temps[args[2]].val);\n\n                tcg_opt_gen_movi(s, op, args, args[0], tmp);\n\n                break;\n\n            }\n\n            goto do_default;\n\n\n\n        CASE_OP_32_64(setcond):\n\n            tmp = do_constant_folding_cond(opc, args[1], args[2], args[3]);\n\n            if (tmp != 2) {\n\n                tcg_opt_gen_movi(s, op, args, args[0], tmp);\n\n                break;\n\n            }\n\n            goto do_default;\n\n\n\n        CASE_OP_32_64(brcond):\n\n            tmp = do_constant_folding_cond(opc, args[0], args[1], args[2]);\n\n            if (tmp != 2) {\n\n                if (tmp) {\n\n                    reset_all_temps(nb_temps);\n\n                    op->opc = INDEX_op_br;\n\n                    args[0] = args[3];\n\n                } else {\n\n                    tcg_op_remove(s, op);\n\n                }\n\n                break;\n\n            }\n\n            goto do_default;\n\n\n\n        CASE_OP_32_64(movcond):\n\n            tmp = do_constant_folding_cond(opc, args[1], args[2], args[5]);\n\n            if (tmp != 2) {\n\n                tcg_opt_gen_mov(s, op, args, args[0], args[4-tmp]);\n\n                break;\n\n            }\n\n            goto do_default;\n\n\n\n        case INDEX_op_add2_i32:\n\n        case INDEX_op_sub2_i32:\n\n            if (temps[args[2]].state == TCG_TEMP_CONST\n\n                && temps[args[3]].state == TCG_TEMP_CONST\n\n                && temps[args[4]].state == TCG_TEMP_CONST\n\n                && temps[args[5]].state == TCG_TEMP_CONST) {\n\n                uint32_t al = temps[args[2]].val;\n\n                uint32_t ah = temps[args[3]].val;\n\n                uint32_t bl = temps[args[4]].val;\n\n                uint32_t bh = temps[args[5]].val;\n\n                uint64_t a = ((uint64_t)ah << 32) | al;\n\n                uint64_t b = ((uint64_t)bh << 32) | bl;\n\n                TCGArg rl, rh;\n\n                TCGOp *op2 = insert_op_before(s, op, INDEX_op_movi_i32, 2);\n\n                TCGArg *args2 = &s->gen_opparam_buf[op2->args];\n\n\n\n                if (opc == INDEX_op_add2_i32) {\n\n                    a += b;\n\n                } else {\n\n                    a -= b;\n\n                }\n\n\n\n                rl = args[0];\n\n                rh = args[1];\n\n                tcg_opt_gen_movi(s, op, args, rl, (int32_t)a);\n\n                tcg_opt_gen_movi(s, op2, args2, rh, (int32_t)(a >> 32));\n\n\n\n                /* We've done all we need to do with the movi.  Skip it.  */\n\n                oi_next = op2->next;\n\n                break;\n\n            }\n\n            goto do_default;\n\n\n\n        case INDEX_op_mulu2_i32:\n\n            if (temps[args[2]].state == TCG_TEMP_CONST\n\n                && temps[args[3]].state == TCG_TEMP_CONST) {\n\n                uint32_t a = temps[args[2]].val;\n\n                uint32_t b = temps[args[3]].val;\n\n                uint64_t r = (uint64_t)a * b;\n\n                TCGArg rl, rh;\n\n                TCGOp *op2 = insert_op_before(s, op, INDEX_op_movi_i32, 2);\n\n                TCGArg *args2 = &s->gen_opparam_buf[op2->args];\n\n\n\n                rl = args[0];\n\n                rh = args[1];\n\n                tcg_opt_gen_movi(s, op, args, rl, (int32_t)r);\n\n                tcg_opt_gen_movi(s, op2, args2, rh, (int32_t)(r >> 32));\n\n\n\n                /* We've done all we need to do with the movi.  Skip it.  */\n\n                oi_next = op2->next;\n\n                break;\n\n            }\n\n            goto do_default;\n\n\n\n        case INDEX_op_brcond2_i32:\n\n            tmp = do_constant_folding_cond2(&args[0], &args[2], args[4]);\n\n            if (tmp != 2) {\n\n                if (tmp) {\n\n            do_brcond_true:\n\n                    reset_all_temps(nb_temps);\n\n                    op->opc = INDEX_op_br;\n\n                    args[0] = args[5];\n\n                } else {\n\n            do_brcond_false:\n\n                    tcg_op_remove(s, op);\n\n                }\n\n            } else if ((args[4] == TCG_COND_LT || args[4] == TCG_COND_GE)\n\n                       && temps[args[2]].state == TCG_TEMP_CONST\n\n                       && temps[args[3]].state == TCG_TEMP_CONST\n\n                       && temps[args[2]].val == 0\n\n                       && temps[args[3]].val == 0) {\n\n                /* Simplify LT/GE comparisons vs zero to a single compare\n\n                   vs the high word of the input.  */\n\n            do_brcond_high:\n\n                reset_all_temps(nb_temps);\n\n                op->opc = INDEX_op_brcond_i32;\n\n                args[0] = args[1];\n\n                args[1] = args[3];\n\n                args[2] = args[4];\n\n                args[3] = args[5];\n\n            } else if (args[4] == TCG_COND_EQ) {\n\n                /* Simplify EQ comparisons where one of the pairs\n\n                   can be simplified.  */\n\n                tmp = do_constant_folding_cond(INDEX_op_brcond_i32,\n\n                                               args[0], args[2], TCG_COND_EQ);\n\n                if (tmp == 0) {\n\n                    goto do_brcond_false;\n\n                } else if (tmp == 1) {\n\n                    goto do_brcond_high;\n\n                }\n\n                tmp = do_constant_folding_cond(INDEX_op_brcond_i32,\n\n                                               args[1], args[3], TCG_COND_EQ);\n\n                if (tmp == 0) {\n\n                    goto do_brcond_false;\n\n                } else if (tmp != 1) {\n\n                    goto do_default;\n\n                }\n\n            do_brcond_low:\n\n                reset_all_temps(nb_temps);\n\n                op->opc = INDEX_op_brcond_i32;\n\n                args[1] = args[2];\n\n                args[2] = args[4];\n\n                args[3] = args[5];\n\n            } else if (args[4] == TCG_COND_NE) {\n\n                /* Simplify NE comparisons where one of the pairs\n\n                   can be simplified.  */\n\n                tmp = do_constant_folding_cond(INDEX_op_brcond_i32,\n\n                                               args[0], args[2], TCG_COND_NE);\n\n                if (tmp == 0) {\n\n                    goto do_brcond_high;\n\n                } else if (tmp == 1) {\n\n                    goto do_brcond_true;\n\n                }\n\n                tmp = do_constant_folding_cond(INDEX_op_brcond_i32,\n\n                                               args[1], args[3], TCG_COND_NE);\n\n                if (tmp == 0) {\n\n                    goto do_brcond_low;\n\n                } else if (tmp == 1) {\n\n                    goto do_brcond_true;\n\n                }\n\n                goto do_default;\n\n            } else {\n\n                goto do_default;\n\n            }\n\n            break;\n\n\n\n        case INDEX_op_setcond2_i32:\n\n            tmp = do_constant_folding_cond2(&args[1], &args[3], args[5]);\n\n            if (tmp != 2) {\n\n            do_setcond_const:\n\n                tcg_opt_gen_movi(s, op, args, args[0], tmp);\n\n            } else if ((args[5] == TCG_COND_LT || args[5] == TCG_COND_GE)\n\n                       && temps[args[3]].state == TCG_TEMP_CONST\n\n                       && temps[args[4]].state == TCG_TEMP_CONST\n\n                       && temps[args[3]].val == 0\n\n                       && temps[args[4]].val == 0) {\n\n                /* Simplify LT/GE comparisons vs zero to a single compare\n\n                   vs the high word of the input.  */\n\n            do_setcond_high:\n\n                reset_temp(args[0]);\n\n                temps[args[0]].mask = 1;\n\n                op->opc = INDEX_op_setcond_i32;\n\n                args[1] = args[2];\n\n                args[2] = args[4];\n\n                args[3] = args[5];\n\n            } else if (args[5] == TCG_COND_EQ) {\n\n                /* Simplify EQ comparisons where one of the pairs\n\n                   can be simplified.  */\n\n                tmp = do_constant_folding_cond(INDEX_op_setcond_i32,\n\n                                               args[1], args[3], TCG_COND_EQ);\n\n                if (tmp == 0) {\n\n                    goto do_setcond_const;\n\n                } else if (tmp == 1) {\n\n                    goto do_setcond_high;\n\n                }\n\n                tmp = do_constant_folding_cond(INDEX_op_setcond_i32,\n\n                                               args[2], args[4], TCG_COND_EQ);\n\n                if (tmp == 0) {\n\n                    goto do_setcond_high;\n\n                } else if (tmp != 1) {\n\n                    goto do_default;\n\n                }\n\n            do_setcond_low:\n\n                reset_temp(args[0]);\n\n                temps[args[0]].mask = 1;\n\n                op->opc = INDEX_op_setcond_i32;\n\n                args[2] = args[3];\n\n                args[3] = args[5];\n\n            } else if (args[5] == TCG_COND_NE) {\n\n                /* Simplify NE comparisons where one of the pairs\n\n                   can be simplified.  */\n\n                tmp = do_constant_folding_cond(INDEX_op_setcond_i32,\n\n                                               args[1], args[3], TCG_COND_NE);\n\n                if (tmp == 0) {\n\n                    goto do_setcond_high;\n\n                } else if (tmp == 1) {\n\n                    goto do_setcond_const;\n\n                }\n\n                tmp = do_constant_folding_cond(INDEX_op_setcond_i32,\n\n                                               args[2], args[4], TCG_COND_NE);\n\n                if (tmp == 0) {\n\n                    goto do_setcond_low;\n\n                } else if (tmp == 1) {\n\n                    goto do_setcond_const;\n\n                }\n\n                goto do_default;\n\n            } else {\n\n                goto do_default;\n\n            }\n\n            break;\n\n\n\n        case INDEX_op_call:\n\n            if (!(args[nb_oargs + nb_iargs + 1]\n\n                  & (TCG_CALL_NO_READ_GLOBALS | TCG_CALL_NO_WRITE_GLOBALS))) {\n\n                for (i = 0; i < nb_globals; i++) {\n\n                    reset_temp(i);\n\n                }\n\n            }\n\n            goto do_reset_output;\n\n\n\n        default:\n\n        do_default:\n\n            /* Default case: we know nothing about operation (or were unable\n\n               to compute the operation result) so no propagation is done.\n\n               We trash everything if the operation is the end of a basic\n\n               block, otherwise we only trash the output args.  \"mask\" is\n\n               the non-zero bits mask for the first output arg.  */\n\n            if (def->flags & TCG_OPF_BB_END) {\n\n                reset_all_temps(nb_temps);\n\n            } else {\n\n        do_reset_output:\n\n                for (i = 0; i < nb_oargs; i++) {\n\n                    reset_temp(args[i]);\n\n                    /* Save the corresponding known-zero bits mask for the\n\n                       first output argument (only one supported so far). */\n\n                    if (i == 0) {\n\n                        temps[args[i]].mask = mask;\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 20077, "_split": "valid", "_hash": "bbba83413883c1469fefba9fe88e8e82"}
{"project": "qemu", "commit_id": "84007e81814bd1b523eb36b027ef8a84d7f00206", "target": 0, "func": "static int net_host_check_device(const char *device)\n\n{\n\n    int i;\n\n    const char *valid_param_list[] = { \"tap\", \"socket\", \"dump\"\n\n#ifdef CONFIG_NET_BRIDGE\n\n                                       , \"bridge\"\n\n#endif\n\n#ifdef CONFIG_SLIRP\n\n                                       ,\"user\"\n\n#endif\n\n#ifdef CONFIG_VDE\n\n                                       ,\"vde\"\n\n#endif\n\n    };\n\n    for (i = 0; i < ARRAY_SIZE(valid_param_list); i++) {\n\n        if (!strncmp(valid_param_list[i], device,\n\n                     strlen(valid_param_list[i])))\n\n            return 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 20098, "_split": "valid", "_hash": "57f2d2341071394f0a2180bdc734cc04"}
{"project": "qemu", "commit_id": "5029fe12dccbe261d5bd5bc840110ae48aa112c9", "target": 0, "func": "uint32_t pci_default_read_config(PCIDevice *d,\n\n                                 uint32_t address, int len)\n\n{\n\n    uint32_t val;\n\n\n\n    switch(len) {\n\n    default:\n\n    case 4:\n\n\tif (address <= 0xfc) {\n\n            val = pci_get_long(d->config + address);\n\n\t    break;\n\n\t}\n\n\t/* fall through */\n\n    case 2:\n\n        if (address <= 0xfe) {\n\n            val = pci_get_word(d->config + address);\n\n\t    break;\n\n\t}\n\n\t/* fall through */\n\n    case 1:\n\n        val = pci_get_byte(d->config + address);\n\n        break;\n\n    }\n\n    return val;\n\n}\n", "idx": 20106, "_split": "valid", "_hash": "e85bdaddfc050ccecbf56d7399fd0936"}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void l2x0_class_init(ObjectClass *klass, void *data)\n\n{\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    k->init = l2x0_priv_init;\n\n    dc->vmsd = &vmstate_l2x0;\n\n    dc->no_user = 1;\n\n    dc->props = l2x0_properties;\n\n    dc->reset = l2x0_priv_reset;\n\n}\n", "idx": 20130, "_split": "valid", "_hash": "ea0ab54ba2104f0f56aead3d1e95427a"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "const char *bdrv_get_format_name(BlockDriverState *bs)\n\n{\n\n    return bs->drv ? bs->drv->format_name : NULL;\n\n}\n", "idx": 20144, "_split": "valid", "_hash": "c9d2b999c69fa2e09bc41ad082764e74"}
{"project": "qemu", "commit_id": "52d631dcc70144b6ce8293db78cd6de635331c83", "target": 1, "func": "static inline void powerpc_excp(CPUPPCState *env, int excp_model, int excp)\n\n{\n\n    target_ulong msr, new_msr, vector;\n\n    int srr0, srr1, asrr0, asrr1;\n\n    int lpes0, lpes1, lev;\n\n\n\n    if (0) {\n\n        /* XXX: find a suitable condition to enable the hypervisor mode */\n\n        lpes0 = (env->spr[SPR_LPCR] >> 1) & 1;\n\n        lpes1 = (env->spr[SPR_LPCR] >> 2) & 1;\n\n    } else {\n\n        /* Those values ensure we won't enter the hypervisor mode */\n\n        lpes0 = 0;\n\n        lpes1 = 1;\n\n    }\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"Raise exception at \" TARGET_FMT_lx\n\n                  \" => %08x (%02x)\\n\", env->nip, excp, env->error_code);\n\n\n\n    /* new srr1 value excluding must-be-zero bits */\n\n    msr = env->msr & ~0x783f0000ULL;\n\n\n\n    /* new interrupt handler msr */\n\n    new_msr = env->msr & ((target_ulong)1 << MSR_ME);\n\n\n\n    /* target registers */\n\n    srr0 = SPR_SRR0;\n\n    srr1 = SPR_SRR1;\n\n    asrr0 = -1;\n\n    asrr1 = -1;\n\n\n\n    switch (excp) {\n\n    case POWERPC_EXCP_NONE:\n\n        /* Should never happen */\n\n        return;\n\n    case POWERPC_EXCP_CRITICAL:    /* Critical input                         */\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_40x:\n\n            srr0 = SPR_40x_SRR2;\n\n            srr1 = SPR_40x_SRR3;\n\n            break;\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_CSRR0;\n\n            srr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        case POWERPC_EXCP_G2:\n\n            break;\n\n        default:\n\n            goto excp_invalid;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_MCHECK:    /* Machine check exception                  */\n\n        if (msr_me == 0) {\n\n            /* Machine check exception is not enabled.\n\n             * Enter checkstop state.\n\n             */\n\n            if (qemu_log_enabled()) {\n\n                qemu_log(\"Machine check while not allowed. \"\n\n                        \"Entering checkstop state\\n\");\n\n            } else {\n\n                fprintf(stderr, \"Machine check while not allowed. \"\n\n                        \"Entering checkstop state\\n\");\n\n            }\n\n            env->halted = 1;\n\n            env->interrupt_request |= CPU_INTERRUPT_EXITTB;\n\n        }\n\n        if (0) {\n\n            /* XXX: find a suitable condition to enable the hypervisor mode */\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n\n\n        /* machine check exceptions don't have ME set */\n\n        new_msr &= ~((target_ulong)1 << MSR_ME);\n\n\n\n        /* XXX: should also have something loaded in DAR / DSISR */\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_40x:\n\n            srr0 = SPR_40x_SRR2;\n\n            srr1 = SPR_40x_SRR3;\n\n            break;\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_MCSRR0;\n\n            srr1 = SPR_BOOKE_MCSRR1;\n\n            asrr0 = SPR_BOOKE_CSRR0;\n\n            asrr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_DSI:       /* Data storage exception                   */\n\n        LOG_EXCP(\"DSI exception: DSISR=\" TARGET_FMT_lx\" DAR=\" TARGET_FMT_lx\n\n                 \"\\n\", env->spr[SPR_DSISR], env->spr[SPR_DAR]);\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_ISI:       /* Instruction storage exception            */\n\n        LOG_EXCP(\"ISI exception: msr=\" TARGET_FMT_lx \", nip=\" TARGET_FMT_lx\n\n                 \"\\n\", msr, env->nip);\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        msr |= env->error_code;\n\n        goto store_next;\n\n    case POWERPC_EXCP_EXTERNAL:  /* External input                           */\n\n        if (lpes0 == 1)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_ALIGN:     /* Alignment exception                      */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        /* XXX: this is false */\n\n        /* Get rS/rD and rA from faulting opcode */\n\n        env->spr[SPR_DSISR] |= (ldl_code((env->nip - 4)) & 0x03FF0000) >> 16;\n\n        goto store_current;\n\n    case POWERPC_EXCP_PROGRAM:   /* Program exception                        */\n\n        switch (env->error_code & ~0xF) {\n\n        case POWERPC_EXCP_FP:\n\n            if ((msr_fe0 == 0 && msr_fe1 == 0) || msr_fp == 0) {\n\n                LOG_EXCP(\"Ignore floating point exception\\n\");\n\n                env->exception_index = POWERPC_EXCP_NONE;\n\n                env->error_code = 0;\n\n                return;\n\n            }\n\n            if (lpes1 == 0)\n\n                new_msr |= (target_ulong)MSR_HVB;\n\n            msr |= 0x00100000;\n\n            if (msr_fe0 == msr_fe1)\n\n                goto store_next;\n\n            msr |= 0x00010000;\n\n            break;\n\n        case POWERPC_EXCP_INVAL:\n\n            LOG_EXCP(\"Invalid instruction at \" TARGET_FMT_lx \"\\n\", env->nip);\n\n            if (lpes1 == 0)\n\n                new_msr |= (target_ulong)MSR_HVB;\n\n            msr |= 0x00080000;\n\n            env->spr[SPR_BOOKE_ESR] = ESR_PIL;\n\n            break;\n\n        case POWERPC_EXCP_PRIV:\n\n            if (lpes1 == 0)\n\n                new_msr |= (target_ulong)MSR_HVB;\n\n            msr |= 0x00040000;\n\n            env->spr[SPR_BOOKE_ESR] = ESR_PPR;\n\n            break;\n\n        case POWERPC_EXCP_TRAP:\n\n            if (lpes1 == 0)\n\n                new_msr |= (target_ulong)MSR_HVB;\n\n            msr |= 0x00020000;\n\n            env->spr[SPR_BOOKE_ESR] = ESR_PTR;\n\n            break;\n\n        default:\n\n            /* Should never occur */\n\n            cpu_abort(env, \"Invalid program exception %d. Aborting\\n\",\n\n                      env->error_code);\n\n            break;\n\n        }\n\n        goto store_current;\n\n    case POWERPC_EXCP_FPU:       /* Floating-point unavailable exception     */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_current;\n\n    case POWERPC_EXCP_SYSCALL:   /* System call exception                    */\n\n        dump_syscall(env);\n\n        lev = env->error_code;\n\n        if ((lev == 1) && cpu_ppc_hypercall) {\n\n            cpu_ppc_hypercall(env);\n\n            return;\n\n        }\n\n        if (lev == 1 || (lpes0 == 0 && lpes1 == 0))\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_APU:       /* Auxiliary processor unavailable          */\n\n        goto store_current;\n\n    case POWERPC_EXCP_DECR:      /* Decrementer exception                    */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_FIT:       /* Fixed-interval timer interrupt           */\n\n        /* FIT on 4xx */\n\n        LOG_EXCP(\"FIT exception\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_WDT:       /* Watchdog timer interrupt                 */\n\n        LOG_EXCP(\"WDT exception\\n\");\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_CSRR0;\n\n            srr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_DTLB:      /* Data TLB error                           */\n\n        goto store_next;\n\n    case POWERPC_EXCP_ITLB:      /* Instruction TLB error                    */\n\n        goto store_next;\n\n    case POWERPC_EXCP_DEBUG:     /* Debug interrupt                          */\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_DSRR0;\n\n            srr1 = SPR_BOOKE_DSRR1;\n\n            asrr0 = SPR_BOOKE_CSRR0;\n\n            asrr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Debug exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_SPEU:      /* SPE/embedded floating-point unavailable  */\n\n        env->spr[SPR_BOOKE_ESR] = ESR_SPV;\n\n        goto store_current;\n\n    case POWERPC_EXCP_EFPDI:     /* Embedded floating-point data interrupt   */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Embedded floating point data exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        env->spr[SPR_BOOKE_ESR] = ESR_SPV;\n\n        goto store_next;\n\n    case POWERPC_EXCP_EFPRI:     /* Embedded floating-point round interrupt  */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Embedded floating point round exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        env->spr[SPR_BOOKE_ESR] = ESR_SPV;\n\n        goto store_next;\n\n    case POWERPC_EXCP_EPERFM:    /* Embedded performance monitor interrupt   */\n\n        /* XXX: TODO */\n\n        cpu_abort(env,\n\n                  \"Performance counter exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_DOORI:     /* Embedded doorbell interrupt              */\n\n        goto store_next;\n\n    case POWERPC_EXCP_DOORCI:    /* Embedded doorbell critical interrupt     */\n\n        srr0 = SPR_BOOKE_CSRR0;\n\n        srr1 = SPR_BOOKE_CSRR1;\n\n        goto store_next;\n\n    case POWERPC_EXCP_RESET:     /* System reset exception                   */\n\n        if (msr_pow) {\n\n            /* indicate that we resumed from power save mode */\n\n            msr |= 0x10000;\n\n        } else {\n\n            new_msr &= ~((target_ulong)1 << MSR_ME);\n\n        }\n\n\n\n        if (0) {\n\n            /* XXX: find a suitable condition to enable the hypervisor mode */\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_DSEG:      /* Data segment exception                   */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_ISEG:      /* Instruction segment exception            */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_HDECR:     /* Hypervisor decrementer exception         */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)MSR_HVB;\n\n        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);\n\n        goto store_next;\n\n    case POWERPC_EXCP_TRACE:     /* Trace exception                          */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_HDSI:      /* Hypervisor data storage exception        */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)MSR_HVB;\n\n        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);\n\n        goto store_next;\n\n    case POWERPC_EXCP_HISI:      /* Hypervisor instruction storage exception */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)MSR_HVB;\n\n        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);\n\n        goto store_next;\n\n    case POWERPC_EXCP_HDSEG:     /* Hypervisor data segment exception        */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)MSR_HVB;\n\n        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);\n\n        goto store_next;\n\n    case POWERPC_EXCP_HISEG:     /* Hypervisor instruction segment exception */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)MSR_HVB;\n\n        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);\n\n        goto store_next;\n\n    case POWERPC_EXCP_VPU:       /* Vector unavailable exception             */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_current;\n\n    case POWERPC_EXCP_PIT:       /* Programmable interval timer interrupt    */\n\n        LOG_EXCP(\"PIT exception\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_IO:        /* IO error exception                       */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"601 IO error exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_RUNM:      /* Run mode exception                       */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"601 run mode exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_EMUL:      /* Emulation trap exception                 */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"602 emulation trap exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_IFTLB:     /* Instruction fetch TLB error              */\n\n        if (lpes1 == 0) /* XXX: check this */\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_602:\n\n        case POWERPC_EXCP_603:\n\n        case POWERPC_EXCP_603E:\n\n        case POWERPC_EXCP_G2:\n\n            goto tlb_miss_tgpr;\n\n        case POWERPC_EXCP_7x5:\n\n            goto tlb_miss;\n\n        case POWERPC_EXCP_74xx:\n\n            goto tlb_miss_74xx;\n\n        default:\n\n            cpu_abort(env, \"Invalid instruction TLB miss exception\\n\");\n\n            break;\n\n        }\n\n        break;\n\n    case POWERPC_EXCP_DLTLB:     /* Data load TLB miss                       */\n\n        if (lpes1 == 0) /* XXX: check this */\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_602:\n\n        case POWERPC_EXCP_603:\n\n        case POWERPC_EXCP_603E:\n\n        case POWERPC_EXCP_G2:\n\n            goto tlb_miss_tgpr;\n\n        case POWERPC_EXCP_7x5:\n\n            goto tlb_miss;\n\n        case POWERPC_EXCP_74xx:\n\n            goto tlb_miss_74xx;\n\n        default:\n\n            cpu_abort(env, \"Invalid data load TLB miss exception\\n\");\n\n            break;\n\n        }\n\n        break;\n\n    case POWERPC_EXCP_DSTLB:     /* Data store TLB miss                      */\n\n        if (lpes1 == 0) /* XXX: check this */\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_602:\n\n        case POWERPC_EXCP_603:\n\n        case POWERPC_EXCP_603E:\n\n        case POWERPC_EXCP_G2:\n\n        tlb_miss_tgpr:\n\n            /* Swap temporary saved registers with GPRs */\n\n            if (!(new_msr & ((target_ulong)1 << MSR_TGPR))) {\n\n                new_msr |= (target_ulong)1 << MSR_TGPR;\n\n                hreg_swap_gpr_tgpr(env);\n\n            }\n\n            goto tlb_miss;\n\n        case POWERPC_EXCP_7x5:\n\n        tlb_miss:\n\n#if defined (DEBUG_SOFTWARE_TLB)\n\n            if (qemu_log_enabled()) {\n\n                const char *es;\n\n                target_ulong *miss, *cmp;\n\n                int en;\n\n                if (excp == POWERPC_EXCP_IFTLB) {\n\n                    es = \"I\";\n\n                    en = 'I';\n\n                    miss = &env->spr[SPR_IMISS];\n\n                    cmp = &env->spr[SPR_ICMP];\n\n                } else {\n\n                    if (excp == POWERPC_EXCP_DLTLB)\n\n                        es = \"DL\";\n\n                    else\n\n                        es = \"DS\";\n\n                    en = 'D';\n\n                    miss = &env->spr[SPR_DMISS];\n\n                    cmp = &env->spr[SPR_DCMP];\n\n                }\n\n                qemu_log(\"6xx %sTLB miss: %cM \" TARGET_FMT_lx \" %cC \"\n\n                         TARGET_FMT_lx \" H1 \" TARGET_FMT_lx \" H2 \"\n\n                         TARGET_FMT_lx \" %08x\\n\", es, en, *miss, en, *cmp,\n\n                         env->spr[SPR_HASH1], env->spr[SPR_HASH2],\n\n                         env->error_code);\n\n            }\n\n#endif\n\n            msr |= env->crf[0] << 28;\n\n            msr |= env->error_code; /* key, D/I, S/L bits */\n\n            /* Set way using a LRU mechanism */\n\n            msr |= ((env->last_way + 1) & (env->nb_ways - 1)) << 17;\n\n            break;\n\n        case POWERPC_EXCP_74xx:\n\n        tlb_miss_74xx:\n\n#if defined (DEBUG_SOFTWARE_TLB)\n\n            if (qemu_log_enabled()) {\n\n                const char *es;\n\n                target_ulong *miss, *cmp;\n\n                int en;\n\n                if (excp == POWERPC_EXCP_IFTLB) {\n\n                    es = \"I\";\n\n                    en = 'I';\n\n                    miss = &env->spr[SPR_TLBMISS];\n\n                    cmp = &env->spr[SPR_PTEHI];\n\n                } else {\n\n                    if (excp == POWERPC_EXCP_DLTLB)\n\n                        es = \"DL\";\n\n                    else\n\n                        es = \"DS\";\n\n                    en = 'D';\n\n                    miss = &env->spr[SPR_TLBMISS];\n\n                    cmp = &env->spr[SPR_PTEHI];\n\n                }\n\n                qemu_log(\"74xx %sTLB miss: %cM \" TARGET_FMT_lx \" %cC \"\n\n                         TARGET_FMT_lx \" %08x\\n\", es, en, *miss, en, *cmp,\n\n                         env->error_code);\n\n            }\n\n#endif\n\n            msr |= env->error_code; /* key bit */\n\n            break;\n\n        default:\n\n            cpu_abort(env, \"Invalid data store TLB miss exception\\n\");\n\n            break;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_FPA:       /* Floating-point assist exception          */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Floating point assist exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_DABR:      /* Data address breakpoint                  */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"DABR exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_IABR:      /* Instruction address breakpoint           */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"IABR exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_SMI:       /* System management interrupt              */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"SMI exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_THERM:     /* Thermal interrupt                        */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Thermal management exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_PERFM:     /* Embedded performance monitor interrupt   */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        /* XXX: TODO */\n\n        cpu_abort(env,\n\n                  \"Performance counter exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_VPUA:      /* Vector assist exception                  */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"VPU assist exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_SOFTP:     /* Soft patch exception                     */\n\n        /* XXX: TODO */\n\n        cpu_abort(env,\n\n                  \"970 soft-patch exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_MAINT:     /* Maintenance exception                    */\n\n        /* XXX: TODO */\n\n        cpu_abort(env,\n\n                  \"970 maintenance exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_MEXTBR:    /* Maskable external breakpoint             */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Maskable external exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_NMEXTBR:   /* Non maskable external breakpoint         */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Non maskable external exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    default:\n\n    excp_invalid:\n\n        cpu_abort(env, \"Invalid PowerPC exception %d. Aborting\\n\", excp);\n\n        break;\n\n    store_current:\n\n        /* save current instruction location */\n\n        env->spr[srr0] = env->nip - 4;\n\n        break;\n\n    store_next:\n\n        /* save next instruction location */\n\n        env->spr[srr0] = env->nip;\n\n        break;\n\n    }\n\n    /* Save MSR */\n\n    env->spr[srr1] = msr;\n\n    /* If any alternate SRR register are defined, duplicate saved values */\n\n    if (asrr0 != -1)\n\n        env->spr[asrr0] = env->spr[srr0];\n\n    if (asrr1 != -1)\n\n        env->spr[asrr1] = env->spr[srr1];\n\n    /* If we disactivated any translation, flush TLBs */\n\n    if (new_msr & ((1 << MSR_IR) | (1 << MSR_DR)))\n\n        tlb_flush(env, 1);\n\n\n\n    if (msr_ile) {\n\n        new_msr |= (target_ulong)1 << MSR_LE;\n\n    }\n\n\n\n    /* Jump to handler */\n\n    vector = env->excp_vectors[excp];\n\n    if (vector == (target_ulong)-1ULL) {\n\n        cpu_abort(env, \"Raised an exception without defined vector %d\\n\",\n\n                  excp);\n\n    }\n\n    vector |= env->excp_prefix;\n\n#if defined(TARGET_PPC64)\n\n    if (excp_model == POWERPC_EXCP_BOOKE) {\n\n        if (!msr_icm) {\n\n            vector = (uint32_t)vector;\n\n        } else {\n\n            new_msr |= (target_ulong)1 << MSR_CM;\n\n        }\n\n    } else {\n\n        if (!msr_isf && !(env->mmu_model & POWERPC_MMU_64)) {\n\n            vector = (uint32_t)vector;\n\n        } else {\n\n            new_msr |= (target_ulong)1 << MSR_SF;\n\n        }\n\n    }\n\n#endif\n\n    /* XXX: we don't use hreg_store_msr here as already have treated\n\n     *      any special case that could occur. Just store MSR and update hflags\n\n     */\n\n    env->msr = new_msr & env->msr_mask;\n\n    hreg_compute_hflags(env);\n\n    env->nip = vector;\n\n    /* Reset exception state */\n\n    env->exception_index = POWERPC_EXCP_NONE;\n\n    env->error_code = 0;\n\n\n\n    if ((env->mmu_model == POWERPC_MMU_BOOKE) ||\n\n        (env->mmu_model == POWERPC_MMU_BOOKE206)) {\n\n        /* XXX: The BookE changes address space when switching modes,\n\n                we should probably implement that as different MMU indexes,\n\n                but for the moment we do it the slow way and flush all.  */\n\n        tlb_flush(env, 1);\n\n    }\n\n}\n", "idx": 20179, "_split": "valid", "_hash": "eb719960bb12c7403472841f3ac2d41d"}
{"project": "qemu", "commit_id": "7f4a930e64b9e69cd340395a7e4f0494aef4fcdd", "target": 1, "func": "static int vhost_user_migration_done(struct vhost_dev *dev, char* mac_addr)\n\n{\n\n    VhostUserMsg msg = { 0 };\n\n    int err;\n\n\n\n    assert(dev->vhost_ops->backend_type == VHOST_BACKEND_TYPE_USER);\n\n\n\n    /* If guest supports GUEST_ANNOUNCE do nothing */\n\n    if (virtio_has_feature(dev->acked_features, VIRTIO_NET_F_GUEST_ANNOUNCE)) {\n\n        return 0;\n\n    }\n\n\n\n    /* if backend supports VHOST_USER_PROTOCOL_F_RARP ask it to send the RARP */\n\n    if (virtio_has_feature(dev->protocol_features,\n\n                           VHOST_USER_PROTOCOL_F_RARP)) {\n\n        msg.request = VHOST_USER_SEND_RARP;\n\n        msg.flags = VHOST_USER_VERSION;\n\n        memcpy((char *)&msg.u64, mac_addr, 6);\n\n        msg.size = sizeof(m.u64);\n\n\n\n        err = vhost_user_write(dev, &msg, NULL, 0);\n\n        return err;\n\n    }\n\n    return -1;\n\n}\n", "idx": 20183, "_split": "valid", "_hash": "a444532046f693613eb2da3a19560f88"}
{"project": "qemu", "commit_id": "2ee4aed86ff2ba38a0e1846de18a9aec38d73015", "target": 0, "func": "void do_tlbwr (void)\n\n{\n\n    int r = cpu_mips_get_random(env);\n\n\n\n    invalidate_tlb(r, 1);\n\n    fill_tlb(r);\n\n}\n", "idx": 20204, "_split": "valid", "_hash": "bb6b31bfe7613a377392066c3d03de91"}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static void raw_close(BlockDriverState *bs)\n\n{\n\n}\n", "idx": 20214, "_split": "valid", "_hash": "b46f1a173bc027ca8a5228d20d1fe364"}
{"project": "qemu", "commit_id": "1e39d97af086d525cd0408eaa5d19783ea165906", "target": 0, "func": "static void gen_interrupt(DisasContext *s, int intno,\n\n                          target_ulong cur_eip, target_ulong next_eip)\n\n{\n\n    gen_update_cc_op(s);\n\n    gen_jmp_im(cur_eip);\n\n    gen_helper_raise_interrupt(cpu_env, tcg_const_i32(intno),\n\n                               tcg_const_i32(next_eip - cur_eip));\n\n    s->is_jmp = DISAS_TB_JUMP;\n\n}\n", "idx": 20222, "_split": "valid", "_hash": "beeef34649d9f37b5c9a4d2a832337c8"}
{"project": "qemu", "commit_id": "de00982e9e14e2d6ba3d148f02c5a1e94deaa985", "target": 0, "func": "static uint32_t platform_mmio_read(ReadWriteHandler *handler, pcibus_t addr, int len)\n\n{\n\n    DPRINTF(\"Warning: attempted read from physical address \"\n\n            \"0x\" TARGET_FMT_plx \" in xen platform mmio space\\n\", addr);\n\n\n\n    return 0;\n\n}\n", "idx": 20240, "_split": "valid", "_hash": "e491935fc13e4064274483b8f821fef9"}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "int cpu_sparc_handle_mmu_fault (CPUState *env, target_ulong address, int rw,\n\n                              int mmu_idx, int is_softmmu)\n\n{\n\n    target_ulong virt_addr, vaddr;\n\n    target_phys_addr_t paddr;\n\n    int error_code = 0, prot, ret = 0, access_index;\n\n\n\n    error_code = get_physical_address(env, &paddr, &prot, &access_index,\n\n                                      address, rw, mmu_idx);\n\n    if (error_code == 0) {\n\n        virt_addr = address & TARGET_PAGE_MASK;\n\n        vaddr = virt_addr + ((address & TARGET_PAGE_MASK) &\n\n                             (TARGET_PAGE_SIZE - 1));\n\n#ifdef DEBUG_MMU\n\n        printf(\"Translate at 0x%\" PRIx64 \" -> 0x%\" PRIx64 \", vaddr 0x%\" PRIx64\n\n               \"\\n\", address, paddr, vaddr);\n\n#endif\n\n        ret = tlb_set_page_exec(env, vaddr, paddr, prot, mmu_idx, is_softmmu);\n\n        return ret;\n\n    }\n\n    // XXX\n\n    return 1;\n\n}\n", "idx": 20241, "_split": "valid", "_hash": "0aaf5140c8c7d9e135ccf58eb9e07e53"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "DriveInfo *drive_init(QemuOpts *opts, void *opaque,\n\n                      int *fatal_error)\n\n{\n\n    const char *buf;\n\n    const char *file = NULL;\n\n    char devname[128];\n\n    const char *serial;\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriver *drv = NULL;\n\n    QEMUMachine *machine = opaque;\n\n    int max_devs;\n\n    int index;\n\n    int cache;\n\n    int aio = 0;\n\n    int bdrv_flags, onerror;\n\n    const char *devaddr;\n\n    DriveInfo *dinfo;\n\n    int snapshot = 0;\n\n\n\n    *fatal_error = 1;\n\n\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    cache = 1;\n\n\n\n    if (machine && machine->use_scsi) {\n\n        type = IF_SCSI;\n\n        max_devs = MAX_SCSI_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"scsi\");\n\n    } else {\n\n        type = IF_IDE;\n\n        max_devs = MAX_IDE_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"ide\");\n\n    }\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n    bus_id  = qemu_opt_get_number(opts, \"bus\", 0);\n\n    unit_id = qemu_opt_get_number(opts, \"unit\", -1);\n\n    index   = qemu_opt_get_number(opts, \"index\", -1);\n\n\n\n    cyls  = qemu_opt_get_number(opts, \"cyls\", 0);\n\n    heads = qemu_opt_get_number(opts, \"heads\", 0);\n\n    secs  = qemu_opt_get_number(opts, \"secs\", 0);\n\n\n\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n\n\n    file = qemu_opt_get(opts, \"file\");\n\n    serial = qemu_opt_get(opts, \"serial\");\n\n\n\n    if ((buf = qemu_opt_get(opts, \"if\")) != NULL) {\n\n        pstrcpy(devname, sizeof(devname), buf);\n\n        if (!strcmp(buf, \"ide\")) {\n\n\t    type = IF_IDE;\n\n            max_devs = MAX_IDE_DEVS;\n\n        } else if (!strcmp(buf, \"scsi\")) {\n\n\t    type = IF_SCSI;\n\n            max_devs = MAX_SCSI_DEVS;\n\n        } else if (!strcmp(buf, \"floppy\")) {\n\n\t    type = IF_FLOPPY;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"pflash\")) {\n\n\t    type = IF_PFLASH;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"mtd\")) {\n\n\t    type = IF_MTD;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"sd\")) {\n\n\t    type = IF_SD;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"xen\")) {\n\n\t    type = IF_XEN;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"none\")) {\n\n\t    type = IF_NONE;\n\n            max_devs = 0;\n\n\t} else {\n\n            fprintf(stderr, \"qemu: unsupported bus type '%s'\\n\", buf);\n\n            return NULL;\n\n\t}\n\n    }\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1 || cyls > 16383) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical cyls number\\n\", buf);\n\n\t    return NULL;\n\n\t}\n\n        if (heads < 1 || heads > 16) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical heads number\\n\", buf);\n\n\t    return NULL;\n\n\t}\n\n        if (secs < 1 || secs > 63) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical secs number\\n\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"trans\")) != NULL) {\n\n        if (!cyls) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' trans must be used with cyls,heads and secs\\n\",\n\n                    buf);\n\n            return NULL;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            fprintf(stderr, \"qemu: '%s' invalid translation type\\n\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"media\")) != NULL) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                fprintf(stderr,\n\n                        \"qemu: '%s' invalid physical CHS format\\n\", buf);\n\n\t        return NULL;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid media\\n\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"cache\")) != NULL) {\n\n        if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\"))\n\n            cache = 0;\n\n        else if (!strcmp(buf, \"writethrough\"))\n\n            cache = 1;\n\n        else if (!strcmp(buf, \"writeback\"))\n\n            cache = 2;\n\n        else {\n\n           fprintf(stderr, \"qemu: invalid cache option\\n\");\n\n           return NULL;\n\n        }\n\n    }\n\n\n\n#ifdef CONFIG_LINUX_AIO\n\n    if ((buf = qemu_opt_get(opts, \"aio\")) != NULL) {\n\n        if (!strcmp(buf, \"threads\"))\n\n            aio = 0;\n\n        else if (!strcmp(buf, \"native\"))\n\n            aio = 1;\n\n        else {\n\n           fprintf(stderr, \"qemu: invalid aio option\\n\");\n\n           return NULL;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n\n       if (strcmp(buf, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            fprintf(stderr, \"\\n\");\n\n\t    return NULL;\n\n        }\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            fprintf(stderr, \"qemu: '%s' invalid format\\n\", buf);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    onerror = BLOCK_ERR_STOP_ENOSPC;\n\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n\n            fprintf(stderr, \"werror is no supported by this format\\n\");\n\n            return NULL;\n\n        }\n\n        if (!strcmp(buf, \"ignore\"))\n\n            onerror = BLOCK_ERR_IGNORE;\n\n        else if (!strcmp(buf, \"enospc\"))\n\n            onerror = BLOCK_ERR_STOP_ENOSPC;\n\n        else if (!strcmp(buf, \"stop\"))\n\n            onerror = BLOCK_ERR_STOP_ANY;\n\n        else if (!strcmp(buf, \"report\"))\n\n            onerror = BLOCK_ERR_REPORT;\n\n        else {\n\n            fprintf(stderr, \"qemu: '%s' invalid write error action\\n\", buf);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if ((devaddr = qemu_opt_get(opts, \"addr\")) != NULL) {\n\n        if (type != IF_VIRTIO) {\n\n            fprintf(stderr, \"addr is not supported\\n\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            fprintf(stderr,\n\n                    \"qemu: index cannot be used with bus and unit\\n\");\n\n            return NULL;\n\n        }\n\n        if (max_devs == 0)\n\n        {\n\n            unit_id = index;\n\n            bus_id = 0;\n\n        } else {\n\n            unit_id = index % max_devs;\n\n            bus_id = index / max_devs;\n\n        }\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get(type, bus_id, unit_id) != NULL) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        fprintf(stderr, \"qemu: unit %d too big (max is %d)\\n\",\n\n                unit_id, max_devs - 1);\n\n        return NULL;\n\n    }\n\n\n\n    /*\n\n     * ignore multiple definitions\n\n     */\n\n\n\n    if (drive_get(type, bus_id, unit_id) != NULL) {\n\n        *fatal_error = 0;\n\n        return NULL;\n\n    }\n\n\n\n    /* init */\n\n\n\n    dinfo = qemu_mallocz(sizeof(*dinfo));\n\n    if ((buf = qemu_opts_id(opts)) != NULL) {\n\n        dinfo->id = qemu_strdup(buf);\n\n    } else {\n\n        /* no id supplied -> create one */\n\n        dinfo->id = qemu_mallocz(32);\n\n        if (type == IF_IDE || type == IF_SCSI)\n\n            mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n        if (max_devs)\n\n            snprintf(dinfo->id, 32, \"%s%i%s%i\",\n\n                     devname, bus_id, mediastr, unit_id);\n\n        else\n\n            snprintf(dinfo->id, 32, \"%s%s%i\",\n\n                     devname, mediastr, unit_id);\n\n    }\n\n    dinfo->bdrv = bdrv_new(dinfo->id);\n\n    dinfo->devaddr = devaddr;\n\n    dinfo->type = type;\n\n    dinfo->bus = bus_id;\n\n    dinfo->unit = unit_id;\n\n    dinfo->onerror = onerror;\n\n    dinfo->opts = opts;\n\n    if (serial)\n\n        strncpy(dinfo->serial, serial, sizeof(serial));\n\n    TAILQ_INSERT_TAIL(&drives, dinfo, next);\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(dinfo->bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(dinfo->bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(dinfo->bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(dinfo->bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n    case IF_NONE:\n\n        break;\n\n    case IF_VIRTIO:\n\n        /* add virtio block device */\n\n        opts = qemu_opts_create(&qemu_device_opts, NULL, 0);\n\n        qemu_opt_set(opts, \"driver\", \"virtio-blk-pci\");\n\n        qemu_opt_set(opts, \"drive\", dinfo->id);\n\n        if (devaddr)\n\n            qemu_opt_set(opts, \"addr\", devaddr);\n\n        break;\n\n    case IF_COUNT:\n\n        abort();\n\n    }\n\n    if (!file) {\n\n        *fatal_error = 0;\n\n        return NULL;\n\n    }\n\n    bdrv_flags = 0;\n\n    if (snapshot) {\n\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n\n        cache = 2; /* always use write-back with snapshot */\n\n    }\n\n    if (cache == 0) /* no caching */\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    else if (cache == 2) /* write-back */\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n\n\n    if (aio == 1) {\n\n        bdrv_flags |= BDRV_O_NATIVE_AIO;\n\n    } else {\n\n        bdrv_flags &= ~BDRV_O_NATIVE_AIO;\n\n    }\n\n\n\n    if (bdrv_open2(dinfo->bdrv, file, bdrv_flags, drv) < 0) {\n\n        fprintf(stderr, \"qemu: could not open disk image %s\\n\",\n\n                        file);\n\n        return NULL;\n\n    }\n\n\n\n    if (bdrv_key_required(dinfo->bdrv))\n\n        autostart = 0;\n\n    *fatal_error = 0;\n\n    return dinfo;\n\n}\n", "idx": 20288, "_split": "valid", "_hash": "f0e845b7a59a28cf3f4fa6ee50b2dc11"}
{"project": "qemu", "commit_id": "715c54071a43ab978dc12b9da22a5016203ed284", "target": 0, "func": "static int htab_save_setup(QEMUFile *f, void *opaque)\n\n{\n\n    sPAPRMachineState *spapr = opaque;\n\n\n\n    /* \"Iteration\" header */\n\n    qemu_put_be32(f, spapr->htab_shift);\n\n\n\n    if (spapr->htab) {\n\n        spapr->htab_save_index = 0;\n\n        spapr->htab_first_pass = true;\n\n    } else {\n\n        assert(kvm_enabled());\n\n\n\n        spapr->htab_fd = kvmppc_get_htab_fd(false);\n\n        spapr->htab_fd_stale = false;\n\n        if (spapr->htab_fd < 0) {\n\n            fprintf(stderr, \"Unable to open fd for reading hash table from KVM: %s\\n\",\n\n                    strerror(errno));\n\n            return -1;\n\n        }\n\n    }\n\n\n\n\n\n    return 0;\n\n}\n", "idx": 20366, "_split": "valid", "_hash": "ea39dfffefeb02add24edb19b1c31cd3"}
{"project": "qemu", "commit_id": "79ca616f291124d166ca173e512c4ace1c2fe8b2", "target": 0, "func": "int pci_drive_hot_add(Monitor *mon, const QDict *qdict, DriveInfo *dinfo)\n\n{\n\n    int dom, pci_bus;\n\n    unsigned slot;\n\n    PCIDevice *dev;\n\n    const char *pci_addr = qdict_get_str(qdict, \"pci_addr\");\n\n\n\n    switch (dinfo->type) {\n\n    case IF_SCSI:\n\n        if (pci_read_devaddr(mon, pci_addr, &dom, &pci_bus, &slot)) {\n\n            goto err;\n\n        }\n\n        dev = pci_find_device(pci_find_root_bus(dom), pci_bus,\n\n                              PCI_DEVFN(slot, 0));\n\n        if (!dev) {\n\n            monitor_printf(mon, \"no pci device with address %s\\n\", pci_addr);\n\n            goto err;\n\n        }\n\n        if (scsi_hot_add(mon, &dev->qdev, dinfo, 1) != 0) {\n\n            goto err;\n\n        }\n\n        break;\n\n    default:\n\n        monitor_printf(mon, \"Can't hot-add drive to type %d\\n\", dinfo->type);\n\n        goto err;\n\n    }\n\n\n\n    return 0;\n\nerr:\n\n    return -1;\n\n}\n", "idx": 20367, "_split": "valid", "_hash": "07f759218a884257e719a53d9b0ffe8f"}
{"project": "qemu", "commit_id": "ba41249678f8c1504bf07706ddb0eda0d36cccc2", "target": 0, "func": "void cpu_loop(CPUSH4State *env)\n\n{\n\n    CPUState *cs = CPU(sh_env_get_cpu(env));\n\n    int trapnr, ret;\n\n    target_siginfo_t info;\n\n\n\n    while (1) {\n\n        cpu_exec_start(cs);\n\n        trapnr = cpu_sh4_exec(cs);\n\n        cpu_exec_end(cs);\n\n\n\n        switch (trapnr) {\n\n        case 0x160:\n\n            env->pc += 2;\n\n            ret = do_syscall(env,\n\n                             env->gregs[3],\n\n                             env->gregs[4],\n\n                             env->gregs[5],\n\n                             env->gregs[6],\n\n                             env->gregs[7],\n\n                             env->gregs[0],\n\n                             env->gregs[1],\n\n                             0, 0);\n\n            env->gregs[0] = ret;\n\n            break;\n\n        case EXCP_INTERRUPT:\n\n            /* just indicate that signals should be handled asap */\n\n            break;\n\n        case EXCP_DEBUG:\n\n            {\n\n                int sig;\n\n\n\n                sig = gdb_handlesig(cs, TARGET_SIGTRAP);\n\n                if (sig)\n\n                  {\n\n                    info.si_signo = sig;\n\n                    info.si_errno = 0;\n\n                    info.si_code = TARGET_TRAP_BRKPT;\n\n                    queue_signal(env, info.si_signo, &info);\n\n                  }\n\n            }\n\n            break;\n\n\tcase 0xa0:\n\n\tcase 0xc0:\n\n            info.si_signo = TARGET_SIGSEGV;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_SEGV_MAPERR;\n\n            info._sifields._sigfault._addr = env->tea;\n\n            queue_signal(env, info.si_signo, &info);\n\n\t    break;\n\n\n\n        default:\n\n            printf (\"Unhandled trap: 0x%x\\n\", trapnr);\n\n            cpu_dump_state(cs, stderr, fprintf, 0);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n        process_pending_signals (env);\n\n    }\n\n}\n", "idx": 20395, "_split": "valid", "_hash": "125486b97413033fa46f866ac682c45e"}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "static inline void gen_op_fcmps(int fccno, TCGv r_rs1, TCGv r_rs2)\n\n{\n\n    gen_helper_fcmps(cpu_env, r_rs1, r_rs2);\n\n}\n", "idx": 20402, "_split": "valid", "_hash": "2fd1cd6a9615b48f5ae5fa1774cc2c8b"}
{"project": "qemu", "commit_id": "74b4c74d5efb0a489bdf0acc5b5d0197167e7649", "target": 0, "func": "static void set_sigp_status(SigpInfo *si, uint64_t status)\n\n{\n\n    *si->status_reg &= 0xffffffff00000000ULL;\n\n    *si->status_reg |= status;\n\n    si->cc = SIGP_CC_STATUS_STORED;\n\n}\n", "idx": 20403, "_split": "valid", "_hash": "8486fd08845957ff7247dd2e63dc6340"}
{"project": "qemu", "commit_id": "36b15c79aa1bef5fe7543f9f2629b6413720bbfb", "target": 0, "func": "static VirtIOSCSIReq *virtio_scsi_pop_req(VirtIOSCSI *s, VirtQueue *vq)\n\n{\n\n    VirtIOSCSIReq *req;\n\n    req = g_malloc(sizeof(*req));\n\n    if (!virtqueue_pop(vq, &req->elem)) {\n\n        g_free(req);\n\n        return NULL;\n\n    }\n\n\n\n    virtio_scsi_parse_req(s, vq, req);\n\n    return req;\n\n}\n", "idx": 20407, "_split": "valid", "_hash": "27646ee0151d165197fba93100af221e"}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "void OPPROTO op_divb_AL_T0(void)\n\n{\n\n    unsigned int num, den, q, r;\n\n\n\n    num = (EAX & 0xffff);\n\n    den = (T0 & 0xff);\n\n    if (den == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n    q = (num / den) & 0xff;\n\n    r = (num % den) & 0xff;\n\n    EAX = (EAX & ~0xffff) | (r << 8) | q;\n\n}\n", "idx": 20417, "_split": "valid", "_hash": "45c36d2ce5788652363f19bb4840f95f"}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_eval_bgu(TCGv dst, TCGv_i32 src)\n\n{\n\n    gen_mov_reg_Z(cpu_tmp0, src);\n\n    gen_mov_reg_C(dst, src);\n\n    tcg_gen_or_tl(dst, dst, cpu_tmp0);\n\n    tcg_gen_xori_tl(dst, dst, 0x1);\n\n}\n", "idx": 20436, "_split": "valid", "_hash": "b2d080a3c001b1d019c936d7c78c1232"}
{"project": "qemu", "commit_id": "ab06ec43577177a442e8e5ca28d0154efe4ff60f", "target": 0, "func": "static void test_pxe_virtio_pci(void)\n\n{\n\n    test_pxe_one(\"-device virtio-net-pci,netdev=\" NETNAME, false);\n\n}\n", "idx": 20444, "_split": "valid", "_hash": "13d1234d059b684602fae210a4de6a5f"}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline void gen_add_data_offset(DisasContext *s, unsigned int insn,\n\n                                       TCGv var)\n\n{\n\n    int val, rm, shift, shiftop;\n\n    TCGv offset;\n\n\n\n    if (!(insn & (1 << 25))) {\n\n        /* immediate */\n\n        val = insn & 0xfff;\n\n        if (!(insn & (1 << 23)))\n\n            val = -val;\n\n        if (val != 0)\n\n            tcg_gen_addi_i32(var, var, val);\n\n    } else {\n\n        /* shift/register */\n\n        rm = (insn) & 0xf;\n\n        shift = (insn >> 7) & 0x1f;\n\n        shiftop = (insn >> 5) & 3;\n\n        offset = load_reg(s, rm);\n\n        gen_arm_shift_im(offset, shiftop, shift, 0);\n\n        if (!(insn & (1 << 23)))\n\n            tcg_gen_sub_i32(var, var, offset);\n\n        else\n\n            tcg_gen_add_i32(var, var, offset);\n\n        dead_tmp(offset);\n\n    }\n\n}\n", "idx": 20478, "_split": "valid", "_hash": "368f2e38f65fb46429ded461d5899798"}
{"project": "qemu", "commit_id": "fdfab37dfeffefbd4533b4158055c9b82d7c3e69", "target": 0, "func": "static int count_contiguous_clusters(int nb_clusters, int cluster_size,\n\n        uint64_t *l2_table, uint64_t stop_flags)\n\n{\n\n    int i;\n\n    QCow2ClusterType first_cluster_type;\n\n    uint64_t mask = stop_flags | L2E_OFFSET_MASK | QCOW_OFLAG_COMPRESSED;\n\n    uint64_t first_entry = be64_to_cpu(l2_table[0]);\n\n    uint64_t offset = first_entry & mask;\n\n\n\n    if (!offset) {\n\n        return 0;\n\n    }\n\n\n\n    /* must be allocated */\n\n    first_cluster_type = qcow2_get_cluster_type(first_entry);\n\n    assert(first_cluster_type == QCOW2_CLUSTER_NORMAL ||\n\n           (first_cluster_type == QCOW2_CLUSTER_ZERO &&\n\n            (first_entry & L2E_OFFSET_MASK) != 0));\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t l2_entry = be64_to_cpu(l2_table[i]) & mask;\n\n        if (offset + (uint64_t) i * cluster_size != l2_entry) {\n\n            break;\n\n        }\n\n    }\n\n\n\n\treturn i;\n\n}\n", "idx": 20497, "_split": "valid", "_hash": "99dfc957fead3ab824045e93355ed550"}
{"project": "qemu", "commit_id": "d20423788e3a3d5f6a2aad8315779bf3f952ca36", "target": 0, "func": "static inline int name_to_handle(int dirfd, const char *name,\n\n                                 struct file_handle *fh, int *mnt_id, int flags)\n\n{\n\n    return syscall(__NR_name_to_handle_at, dirfd, name, fh, mnt_id, flags);\n\n}\n", "idx": 20530, "_split": "valid", "_hash": "d4bf0d5a41eb6652e21aba05c30c57ee"}
{"project": "qemu", "commit_id": "4fc9af53d88c0a2a810704a06cb39a7182982e4e", "target": 0, "func": "static void generate_bootsect(uint32_t gpr[8], uint16_t segs[6], uint16_t ip)\n\n{\n\n    uint8_t bootsect[512], *p;\n\n    int i;\n\n    int hda;\n\n\n\n    hda = drive_get_index(IF_IDE, 0, 0);\n\n    if (hda == -1) {\n\n\tfprintf(stderr, \"A disk image must be given for 'hda' when booting \"\n\n\t\t\"a Linux kernel\\n(if you really don't want it, use /dev/zero)\\n\");\n\n\texit(1);\n\n    }\n\n\n\n    memset(bootsect, 0, sizeof(bootsect));\n\n\n\n    /* Copy the MSDOS partition table if possible */\n\n    bdrv_read(drives_table[hda].bdrv, 0, bootsect, 1);\n\n\n\n    /* Make sure we have a partition signature */\n\n    bootsect[510] = 0x55;\n\n    bootsect[511] = 0xaa;\n\n\n\n    /* Actual code */\n\n    p = bootsect;\n\n    *p++ = 0xfa;\t\t/* CLI */\n\n    *p++ = 0xfc;\t\t/* CLD */\n\n\n\n    for (i = 0; i < 6; i++) {\n\n\tif (i == 1)\t\t/* Skip CS */\n\n\t    continue;\n\n\n\n\t*p++ = 0xb8;\t\t/* MOV AX,imm16 */\n\n\t*p++ = segs[i];\n\n\t*p++ = segs[i] >> 8;\n\n\t*p++ = 0x8e;\t\t/* MOV <seg>,AX */\n\n\t*p++ = 0xc0 + (i << 3);\n\n    }\n\n\n\n    for (i = 0; i < 8; i++) {\n\n\t*p++ = 0x66;\t\t/* 32-bit operand size */\n\n\t*p++ = 0xb8 + i;\t/* MOV <reg>,imm32 */\n\n\t*p++ = gpr[i];\n\n\t*p++ = gpr[i] >> 8;\n\n\t*p++ = gpr[i] >> 16;\n\n\t*p++ = gpr[i] >> 24;\n\n    }\n\n\n\n    *p++ = 0xea;\t\t/* JMP FAR */\n\n    *p++ = ip;\t\t\t/* IP */\n\n    *p++ = ip >> 8;\n\n    *p++ = segs[1];\t\t/* CS */\n\n    *p++ = segs[1] >> 8;\n\n\n\n    bdrv_set_boot_sector(drives_table[hda].bdrv, bootsect, sizeof(bootsect));\n\n}\n", "idx": 20532, "_split": "valid", "_hash": "fe6b59c22110b6d95b6367f769f0842c"}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fmsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2,\n\n                      uint64_t arg3)\n\n{\n\n    CPU_DoubleU farg1, farg2, farg3;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n    farg3.ll = arg3;\n\n\n\n    if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||\n\n                 (float64_is_zero(farg1.d) &&\n\n                  float64_is_infinity(farg2.d)))) {\n\n        /* Multiplication of zero by infinity */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIMZ);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d) ||\n\n                     float64_is_signaling_nan(farg3.d))) {\n\n            /* sNaN operation */\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        /* This is the way the PowerPC specification defines it */\n\n        float128 ft0_128, ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) &&\n\n                     float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) == float64_is_neg(farg3.d))) {\n\n            /* Magnitude subtraction of infinities */\n\n            farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_sub(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n    }\n\n    return farg1.ll;\n\n}\n", "idx": 20550, "_split": "valid", "_hash": "1dcdfb11c5f61f0831b88212c48c43f8"}
{"project": "qemu", "commit_id": "5905fbc9c94ccd744c1b249472eafcc2d827548a", "target": 0, "func": "static bool bdrv_exceed_bps_limits(BlockDriverState *bs, int nb_sectors,\n\n                 bool is_write, double elapsed_time, uint64_t *wait)\n\n{\n\n    uint64_t bps_limit = 0;\n\n    double   bytes_limit, bytes_base, bytes_res;\n\n    double   slice_time, wait_time;\n\n\n\n    if (bs->io_limits.bps[BLOCK_IO_LIMIT_TOTAL]) {\n\n        bps_limit = bs->io_limits.bps[BLOCK_IO_LIMIT_TOTAL];\n\n    } else if (bs->io_limits.bps[is_write]) {\n\n        bps_limit = bs->io_limits.bps[is_write];\n\n    } else {\n\n        if (wait) {\n\n            *wait = 0;\n\n        }\n\n\n\n        return false;\n\n    }\n\n\n\n    slice_time = bs->slice_end - bs->slice_start;\n\n    slice_time /= (NANOSECONDS_PER_SECOND);\n\n    bytes_limit = bps_limit * slice_time;\n\n    bytes_base  = bs->nr_bytes[is_write] - bs->io_base.bytes[is_write];\n\n    if (bs->io_limits.bps[BLOCK_IO_LIMIT_TOTAL]) {\n\n        bytes_base += bs->nr_bytes[!is_write] - bs->io_base.bytes[!is_write];\n\n    }\n\n\n\n    /* bytes_base: the bytes of data which have been read/written; and\n\n     *             it is obtained from the history statistic info.\n\n     * bytes_res: the remaining bytes of data which need to be read/written.\n\n     * (bytes_base + bytes_res) / bps_limit: used to calcuate\n\n     *             the total time for completing reading/writting all data.\n\n     */\n\n    bytes_res   = (unsigned) nb_sectors * BDRV_SECTOR_SIZE;\n\n\n\n    if (bytes_base + bytes_res <= bytes_limit) {\n\n        if (wait) {\n\n            *wait = 0;\n\n        }\n\n\n\n        return false;\n\n    }\n\n\n\n    /* Calc approx time to dispatch */\n\n    wait_time = (bytes_base + bytes_res) / bps_limit - elapsed_time;\n\n\n\n    /* When the I/O rate at runtime exceeds the limits,\n\n     * bs->slice_end need to be extended in order that the current statistic\n\n     * info can be kept until the timer fire, so it is increased and tuned\n\n     * based on the result of experiment.\n\n     */\n\n    bs->slice_time = wait_time * BLOCK_IO_SLICE_TIME * 10;\n\n    bs->slice_end += bs->slice_time - 3 * BLOCK_IO_SLICE_TIME;\n\n    if (wait) {\n\n        *wait = wait_time * BLOCK_IO_SLICE_TIME * 10;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 20557, "_split": "valid", "_hash": "a2671304f6213fb95f1cfa9d9a64075a"}
{"project": "qemu", "commit_id": "39f72ef94ba74701d18daf82b44c18a60f94eb60", "target": 1, "func": "static void xilinx_enet_realize(DeviceState *dev, Error **errp)\n\n{\n\n    XilinxAXIEnet *s = XILINX_AXI_ENET(dev);\n\n    XilinxAXIEnetStreamSlave *ds = XILINX_AXI_ENET_DATA_STREAM(&s->rx_data_dev);\n\n    XilinxAXIEnetStreamSlave *cs = XILINX_AXI_ENET_CONTROL_STREAM(\n\n                                                            &s->rx_control_dev);\n\n    Error *local_errp = NULL;\n\n\n\n    object_property_add_link(OBJECT(ds), \"enet\", \"xlnx.axi-ethernet\",\n\n                             (Object **) &ds->enet,\n\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE,\n\n                             &local_errp);\n\n    object_property_add_link(OBJECT(cs), \"enet\", \"xlnx.axi-ethernet\",\n\n                             (Object **) &cs->enet,\n\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE,\n\n                             &local_errp);\n\n    if (local_errp) {\n\n        goto xilinx_enet_realize_fail;\n\n    }\n\n    object_property_set_link(OBJECT(ds), OBJECT(s), \"enet\", &local_errp);\n\n    object_property_set_link(OBJECT(cs), OBJECT(s), \"enet\", &local_errp);\n\n    if (local_errp) {\n\n        goto xilinx_enet_realize_fail;\n\n    }\n\n\n\n    qemu_macaddr_default_if_unset(&s->conf.macaddr);\n\n    s->nic = qemu_new_nic(&net_xilinx_enet_info, &s->conf,\n\n                          object_get_typename(OBJECT(dev)), dev->id, s);\n\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n\n\n\n    tdk_init(&s->TEMAC.phy);\n\n    mdio_attach(&s->TEMAC.mdio_bus, &s->TEMAC.phy, s->c_phyaddr);\n\n\n\n    s->TEMAC.parent = s;\n\n\n\n    s->rxmem = g_malloc(s->c_rxmem);\n\n    return;\n\n\n\nxilinx_enet_realize_fail:\n\n    if (!*errp) {\n\n        *errp = local_errp;\n\n    }\n\n}", "idx": 20603, "_split": "valid", "_hash": "5e1457f97ff469620ee32146f3f0ae26"}
{"project": "qemu", "commit_id": "6376f9522372d589f3efe60001dc0486237dd375", "target": 1, "func": "static DriveInfo *blockdev_init(const char *file, QDict *bs_opts,\n\n                                Error **errp)\n\n{\n\n    const char *buf;\n\n    const char *serial;\n\n    int ro = 0;\n\n    int bdrv_flags = 0;\n\n    int on_read_error, on_write_error;\n\n    DriveInfo *dinfo;\n\n    ThrottleConfig cfg;\n\n    int snapshot = 0;\n\n    bool copy_on_read;\n\n    int ret;\n\n    Error *error = NULL;\n\n    QemuOpts *opts;\n\n    const char *id;\n\n    bool has_driver_specific_opts;\n\n    BlockdevDetectZeroesOptions detect_zeroes;\n\n    BlockDriver *drv = NULL;\n\n\n\n    /* Check common options by copying from bs_opts to opts, all other options\n\n     * stay in bs_opts for processing by bdrv_open(). */\n\n    id = qdict_get_try_str(bs_opts, \"id\");\n\n    opts = qemu_opts_create(&qemu_common_drive_opts, id, 1, &error);\n\n    if (error) {\n\n        error_propagate(errp, error);\n\n        return NULL;\n\n    }\n\n\n\n    qemu_opts_absorb_qdict(opts, bs_opts, &error);\n\n    if (error) {\n\n        error_propagate(errp, error);\n\n        goto early_err;\n\n    }\n\n\n\n    if (id) {\n\n        qdict_del(bs_opts, \"id\");\n\n    }\n\n\n\n    has_driver_specific_opts = !!qdict_size(bs_opts);\n\n\n\n    /* extract parameters */\n\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n    ro = qemu_opt_get_bool(opts, \"read-only\", 0);\n\n    copy_on_read = qemu_opt_get_bool(opts, \"copy-on-read\", false);\n\n\n\n    serial = qemu_opt_get(opts, \"serial\");\n\n\n\n    if ((buf = qemu_opt_get(opts, \"discard\")) != NULL) {\n\n        if (bdrv_parse_discard_flags(buf, &bdrv_flags) != 0) {\n\n            error_setg(errp, \"invalid discard option\");\n\n            goto early_err;\n\n        }\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"cache.writeback\", true)) {\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    }\n\n    if (qemu_opt_get_bool(opts, \"cache.direct\", false)) {\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    }\n\n    if (qemu_opt_get_bool(opts, \"cache.no-flush\", false)) {\n\n        bdrv_flags |= BDRV_O_NO_FLUSH;\n\n    }\n\n\n\n#ifdef CONFIG_LINUX_AIO\n\n    if ((buf = qemu_opt_get(opts, \"aio\")) != NULL) {\n\n        if (!strcmp(buf, \"native\")) {\n\n            bdrv_flags |= BDRV_O_NATIVE_AIO;\n\n        } else if (!strcmp(buf, \"threads\")) {\n\n            /* this is the default */\n\n        } else {\n\n           error_setg(errp, \"invalid aio option\");\n\n           goto early_err;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n\n        if (is_help_option(buf)) {\n\n            error_printf(\"Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            error_printf(\"\\n\");\n\n            goto early_err;\n\n        }\n\n\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            error_setg(errp, \"'%s' invalid format\", buf);\n\n            goto early_err;\n\n        }\n\n    }\n\n\n\n    /* disk I/O throttling */\n\n    memset(&cfg, 0, sizeof(cfg));\n\n    cfg.buckets[THROTTLE_BPS_TOTAL].avg =\n\n        qemu_opt_get_number(opts, \"throttling.bps-total\", 0);\n\n    cfg.buckets[THROTTLE_BPS_READ].avg  =\n\n        qemu_opt_get_number(opts, \"throttling.bps-read\", 0);\n\n    cfg.buckets[THROTTLE_BPS_WRITE].avg =\n\n        qemu_opt_get_number(opts, \"throttling.bps-write\", 0);\n\n    cfg.buckets[THROTTLE_OPS_TOTAL].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-total\", 0);\n\n    cfg.buckets[THROTTLE_OPS_READ].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-read\", 0);\n\n    cfg.buckets[THROTTLE_OPS_WRITE].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-write\", 0);\n\n\n\n    cfg.buckets[THROTTLE_BPS_TOTAL].max =\n\n        qemu_opt_get_number(opts, \"throttling.bps-total-max\", 0);\n\n    cfg.buckets[THROTTLE_BPS_READ].max  =\n\n        qemu_opt_get_number(opts, \"throttling.bps-read-max\", 0);\n\n    cfg.buckets[THROTTLE_BPS_WRITE].max =\n\n        qemu_opt_get_number(opts, \"throttling.bps-write-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_TOTAL].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-total-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_READ].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-read-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_WRITE].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-write-max\", 0);\n\n\n\n    cfg.op_size = qemu_opt_get_number(opts, \"throttling.iops-size\", 0);\n\n\n\n    if (!check_throttle_config(&cfg, &error)) {\n\n        error_propagate(errp, error);\n\n        goto early_err;\n\n    }\n\n\n\n    on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;\n\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n\n        on_write_error = parse_block_error_action(buf, 0, &error);\n\n        if (error) {\n\n            error_propagate(errp, error);\n\n            goto early_err;\n\n        }\n\n    }\n\n\n\n    on_read_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n\n        on_read_error = parse_block_error_action(buf, 1, &error);\n\n        if (error) {\n\n            error_propagate(errp, error);\n\n            goto early_err;\n\n        }\n\n    }\n\n\n\n    detect_zeroes =\n\n        parse_enum_option(BlockdevDetectZeroesOptions_lookup,\n\n                          qemu_opt_get(opts, \"detect-zeroes\"),\n\n                          BLOCKDEV_DETECT_ZEROES_OPTIONS_MAX,\n\n                          BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF,\n\n                          &error);\n\n    if (error) {\n\n        error_propagate(errp, error);\n\n        goto early_err;\n\n    }\n\n\n\n    if (detect_zeroes == BLOCKDEV_DETECT_ZEROES_OPTIONS_UNMAP &&\n\n        !(bdrv_flags & BDRV_O_UNMAP)) {\n\n        error_setg(errp, \"setting detect-zeroes to unmap is not allowed \"\n\n                         \"without setting discard operation to unmap\");\n\n        goto early_err;\n\n    }\n\n\n\n    /* init */\n\n    dinfo = g_malloc0(sizeof(*dinfo));\n\n    dinfo->id = g_strdup(qemu_opts_id(opts));\n\n    dinfo->bdrv = bdrv_new(dinfo->id, &error);\n\n    if (error) {\n\n        error_propagate(errp, error);\n\n        goto bdrv_new_err;\n\n    }\n\n    dinfo->bdrv->open_flags = snapshot ? BDRV_O_SNAPSHOT : 0;\n\n    dinfo->bdrv->read_only = ro;\n\n    dinfo->bdrv->detect_zeroes = detect_zeroes;\n\n    dinfo->refcount = 1;\n\n    if (serial != NULL) {\n\n        dinfo->serial = g_strdup(serial);\n\n    }\n\n    QTAILQ_INSERT_TAIL(&drives, dinfo, next);\n\n\n\n    bdrv_set_on_error(dinfo->bdrv, on_read_error, on_write_error);\n\n\n\n    /* disk I/O throttling */\n\n    if (throttle_enabled(&cfg)) {\n\n        bdrv_io_limits_enable(dinfo->bdrv);\n\n        bdrv_set_io_limits(dinfo->bdrv, &cfg);\n\n    }\n\n\n\n    if (!file || !*file) {\n\n        if (has_driver_specific_opts) {\n\n            file = NULL;\n\n        } else {\n\n            QDECREF(bs_opts);\n\n            qemu_opts_del(opts);\n\n            return dinfo;\n\n        }\n\n    }\n\n    if (snapshot) {\n\n        /* always use cache=unsafe with snapshot */\n\n        bdrv_flags &= ~BDRV_O_CACHE_MASK;\n\n        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB|BDRV_O_NO_FLUSH);\n\n    }\n\n\n\n    if (copy_on_read) {\n\n        bdrv_flags |= BDRV_O_COPY_ON_READ;\n\n    }\n\n\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n\n        bdrv_flags |= BDRV_O_INCOMING;\n\n    }\n\n\n\n    bdrv_flags |= ro ? 0 : BDRV_O_RDWR;\n\n\n\n    QINCREF(bs_opts);\n\n    ret = bdrv_open(&dinfo->bdrv, file, NULL, bs_opts, bdrv_flags, drv, &error);\n\n\n\n    if (ret < 0) {\n\n        error_setg(errp, \"could not open disk image %s: %s\",\n\n                   file ?: dinfo->id, error_get_pretty(error));\n\n        error_free(error);\n\n        goto err;\n\n    }\n\n\n\n    if (bdrv_key_required(dinfo->bdrv))\n\n        autostart = 0;\n\n\n\n    QDECREF(bs_opts);\n\n    qemu_opts_del(opts);\n\n\n\n    return dinfo;\n\n\n\nerr:\n\n    bdrv_unref(dinfo->bdrv);\n\n    QTAILQ_REMOVE(&drives, dinfo, next);\n\nbdrv_new_err:\n\n    g_free(dinfo->id);\n\n    g_free(dinfo);\n\nearly_err:\n\n    QDECREF(bs_opts);\n\n    qemu_opts_del(opts);\n\n    return NULL;\n\n}\n", "idx": 20614, "_split": "valid", "_hash": "38c87bb1065a75a87946c9c902d9a269"}
{"project": "qemu", "commit_id": "e04fb07fd1676e9facd7f3f878c1bbe03bccd26b", "target": 1, "func": "static void qemu_rbd_aio_event_reader(void *opaque)\n\n{\n\n    BDRVRBDState *s = opaque;\n\n\n\n    ssize_t ret;\n\n\n\n    do {\n\n        char *p = (char *)&s->event_rcb;\n\n\n\n        /* now read the rcb pointer that was sent from a non qemu thread */\n\n        ret = read(s->fds[RBD_FD_READ], p + s->event_reader_pos,\n\n                   sizeof(s->event_rcb) - s->event_reader_pos);\n\n        if (ret > 0) {\n\n            s->event_reader_pos += ret;\n\n            if (s->event_reader_pos == sizeof(s->event_rcb)) {\n\n                s->event_reader_pos = 0;\n\n                qemu_rbd_complete_aio(s->event_rcb);\n\n            }\n\n        }\n\n    } while (ret < 0 && errno == EINTR);\n\n}\n", "idx": 20657, "_split": "valid", "_hash": "e2b37a1a9cee05daaffddfc52227519d"}
{"project": "qemu", "commit_id": "2db59a76c421cdd1039d10e32a9798952d3ff5ba", "target": 1, "func": "static void gen_wsr_windowbase(DisasContext *dc, uint32_t sr, TCGv_i32 v)\n\n{\n\n    gen_helper_wsr_windowbase(cpu_env, v);\n\n    reset_used_window(dc);\n\n}\n", "idx": 20676, "_split": "valid", "_hash": "eccc93a9fe8d5dc050b75440a027d6ef"}
{"project": "qemu", "commit_id": "06a1307379fcd6c551185ad87679cd7ed896b9ea", "target": 1, "func": "static void virtio_pci_exit(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = VIRTIO_PCI(pci_dev);\n\n    virtio_pci_stop_ioeventfd(proxy);\n\n    memory_region_destroy(&proxy->bar);\n\n    msix_uninit_exclusive_bar(pci_dev);\n\n}\n", "idx": 20692, "_split": "valid", "_hash": "19a1014b23805cbdc593fe3423c6ac15"}
{"project": "qemu", "commit_id": "7ec1e5ea4bd0700fa48da86bffa2fcc6146c410a", "target": 0, "func": "static void gen_stf_asi(DisasContext *dc, TCGv addr,\n\n                        int insn, int size, int rd)\n\n{\n\n    TCGv_i32 r_asi, r_size, r_rd;\n\n\n\n    r_asi = gen_get_asi(dc, insn);\n\n    r_size = tcg_const_i32(size);\n\n    r_rd = tcg_const_i32(rd);\n\n    gen_helper_stf_asi(cpu_env, addr, r_asi, r_size, r_rd);\n\n    tcg_temp_free_i32(r_rd);\n\n    tcg_temp_free_i32(r_size);\n\n    tcg_temp_free_i32(r_asi);\n\n}\n", "idx": 20726, "_split": "valid", "_hash": "e463875dcde811c8f4fcf9e3a1afc55c"}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "static int kvm_arch_set_tsc_khz(CPUState *cs)\n\n{\n\n    X86CPU *cpu = X86_CPU(cs);\n\n    CPUX86State *env = &cpu->env;\n\n    int r;\n\n\n\n    if (!env->tsc_khz) {\n\n        return 0;\n\n    }\n\n\n\n    r = kvm_check_extension(cs->kvm_state, KVM_CAP_TSC_CONTROL) ?\n\n        kvm_vcpu_ioctl(cs, KVM_SET_TSC_KHZ, env->tsc_khz) :\n\n        -ENOTSUP;\n\n    if (r < 0) {\n\n        /* When KVM_SET_TSC_KHZ fails, it's an error only if the current\n\n         * TSC frequency doesn't match the one we want.\n\n         */\n\n        int cur_freq = kvm_check_extension(cs->kvm_state, KVM_CAP_GET_TSC_KHZ) ?\n\n                       kvm_vcpu_ioctl(cs, KVM_GET_TSC_KHZ) :\n\n                       -ENOTSUP;\n\n        if (cur_freq <= 0 || cur_freq != env->tsc_khz) {\n\n            error_report(\"warning: TSC frequency mismatch between \"\n\n                         \"VM (%\" PRId64 \" kHz) and host (%d kHz), \"\n\n                         \"and TSC scaling unavailable\",\n\n                         env->tsc_khz, cur_freq);\n\n            return r;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 20744, "_split": "valid", "_hash": "c159583aa18fe85091240e8fb291d0f2"}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "pvscsi_realizefn(PCIDevice *pci_dev, Error **errp)\n\n{\n\n    PVSCSIState *s = PVSCSI(pci_dev);\n\n\n\n    trace_pvscsi_state(\"init\");\n\n\n\n    /* PCI subsystem ID, subsystem vendor ID, revision */\n\n    if (PVSCSI_USE_OLD_PCI_CONFIGURATION(s)) {\n\n        pci_set_word(pci_dev->config + PCI_SUBSYSTEM_ID, 0x1000);\n\n    } else {\n\n        pci_set_word(pci_dev->config + PCI_SUBSYSTEM_VENDOR_ID,\n\n                     PCI_VENDOR_ID_VMWARE);\n\n        pci_set_word(pci_dev->config + PCI_SUBSYSTEM_ID,\n\n                     PCI_DEVICE_ID_VMWARE_PVSCSI);\n\n        pci_config_set_revision(pci_dev->config, 0x2);\n\n    }\n\n\n\n    /* PCI latency timer = 255 */\n\n    pci_dev->config[PCI_LATENCY_TIMER] = 0xff;\n\n\n\n    /* Interrupt pin A */\n\n    pci_config_set_interrupt_pin(pci_dev->config, 1);\n\n\n\n    memory_region_init_io(&s->io_space, OBJECT(s), &pvscsi_ops, s,\n\n                          \"pvscsi-io\", PVSCSI_MEM_SPACE_SIZE);\n\n    pci_register_bar(pci_dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &s->io_space);\n\n\n\n    pvscsi_init_msi(s);\n\n\n\n    if (pci_is_express(pci_dev) && pci_bus_is_express(pci_dev->bus)) {\n\n        pcie_endpoint_cap_init(pci_dev, PVSCSI_EXP_EP_OFFSET);\n\n    }\n\n\n\n    s->completion_worker = qemu_bh_new(pvscsi_process_completion_queue, s);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(pci_dev),\n\n                 &pvscsi_scsi_info, NULL);\n\n    /* override default SCSI bus hotplug-handler, with pvscsi's one */\n\n    qbus_set_hotplug_handler(BUS(&s->bus), DEVICE(s), &error_abort);\n\n    pvscsi_reset_state(s);\n\n}\n", "idx": 20823, "_split": "valid", "_hash": "ce88ec737f0b775ce84bcf47ef60d83c"}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void vde_from_qemu(void *opaque, const uint8_t *buf, int size)\n\n{\n\n    VDEState *s = opaque;\n\n    int ret;\n\n    for(;;) {\n\n        ret = vde_send(s->vde, (const char *)buf, size, 0);\n\n        if (ret < 0 && errno == EINTR) {\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 20826, "_split": "valid", "_hash": "82377affc7e66a5a899df66756efe140"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void mipsnet_ioport_write(void *opaque, target_phys_addr_t addr,\n\n                                 uint64_t val, unsigned int size)\n\n{\n\n    MIPSnetState *s = opaque;\n\n\n\n    addr &= 0x3f;\n\n    trace_mipsnet_write(addr, val);\n\n    switch (addr) {\n\n    case MIPSNET_TX_DATA_COUNT:\n\n\ts->tx_count = (val <= MAX_ETH_FRAME_SIZE) ? val : 0;\n\n        s->tx_written = 0;\n\n        break;\n\n    case MIPSNET_INT_CTL:\n\n        if (val & MIPSNET_INTCTL_TXDONE) {\n\n            s->intctl &= ~MIPSNET_INTCTL_TXDONE;\n\n        } else if (val & MIPSNET_INTCTL_RXDONE) {\n\n            s->intctl &= ~MIPSNET_INTCTL_RXDONE;\n\n        } else if (val & MIPSNET_INTCTL_TESTBIT) {\n\n            mipsnet_reset(s);\n\n            s->intctl |= MIPSNET_INTCTL_TESTBIT;\n\n        } else if (!val) {\n\n            /* ACK testbit interrupt, flag was cleared on read. */\n\n        }\n\n        s->busy = !!s->intctl;\n\n        mipsnet_update_irq(s);\n\n        break;\n\n    case MIPSNET_TX_DATA_BUFFER:\n\n        s->tx_buffer[s->tx_written++] = val;\n\n        if (s->tx_written == s->tx_count) {\n\n            /* Send buffer. */\n\n            trace_mipsnet_send(s->tx_count);\n\n            qemu_send_packet(&s->nic->nc, s->tx_buffer, s->tx_count);\n\n            s->tx_count = s->tx_written = 0;\n\n            s->intctl |= MIPSNET_INTCTL_TXDONE;\n\n            s->busy = 1;\n\n            mipsnet_update_irq(s);\n\n        }\n\n        break;\n\n    /* Read-only registers */\n\n    case MIPSNET_DEV_ID:\n\n    case MIPSNET_BUSY:\n\n    case MIPSNET_RX_DATA_COUNT:\n\n    case MIPSNET_INTERRUPT_INFO:\n\n    case MIPSNET_RX_DATA_BUFFER:\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 20895, "_split": "valid", "_hash": "25f99c2d1678a81d950a46d765339d48"}
{"project": "qemu", "commit_id": "90d131fb6504ed12a37dc8433375cc683c30e9da", "target": 0, "func": "mac_writereg(E1000State *s, int index, uint32_t val)\n\n{\n\n    uint32_t macaddr[2];\n\n\n\n    s->mac_reg[index] = val;\n\n\n\n    if (index == RA || index == RA + 1) {\n\n        macaddr[0] = cpu_to_le32(s->mac_reg[RA]);\n\n        macaddr[1] = cpu_to_le32(s->mac_reg[RA + 1]);\n\n        qemu_format_nic_info_str(qemu_get_queue(s->nic), (uint8_t *)macaddr);\n\n    }\n\n}\n", "idx": 20898, "_split": "valid", "_hash": "d5eeb0dc811840ded2a5357845700595"}
{"project": "qemu", "commit_id": "e2779de053b64f023de382fd87b3596613d47d1e", "target": 0, "func": "static int xen_pt_pmcsr_reg_write(XenPCIPassthroughState *s,\n\n                                  XenPTReg *cfg_entry, uint16_t *val,\n\n                                  uint16_t dev_value, uint16_t valid_mask)\n\n{\n\n    XenPTRegInfo *reg = cfg_entry->reg;\n\n    uint16_t writable_mask = 0;\n\n    uint16_t throughable_mask = get_throughable_mask(s, reg, valid_mask);\n\n\n\n    /* modify emulate register */\n\n    writable_mask = reg->emu_mask & ~reg->ro_mask & valid_mask;\n\n    cfg_entry->data = XEN_PT_MERGE_VALUE(*val, cfg_entry->data, writable_mask);\n\n\n\n    /* create value for writing to I/O device register */\n\n    *val = XEN_PT_MERGE_VALUE(*val, dev_value & ~PCI_PM_CTRL_PME_STATUS,\n\n                              throughable_mask);\n\n\n\n    return 0;\n\n}\n", "idx": 20899, "_split": "valid", "_hash": "67eb470a077c5f7255c9e2bfd63c4017"}
{"project": "qemu", "commit_id": "c7eb1f02edba91e3eec4682fa1adca877696d11d", "target": 0, "func": "static int net_socket_connect_init(VLANState *vlan,\n\n                                   const char *model,\n\n                                   const char *name,\n\n                                   const char *host_str)\n\n{\n\n    NetSocketState *s;\n\n    int fd, connected, ret, err;\n\n    struct sockaddr_in saddr;\n\n\n\n    if (parse_host_port(&saddr, host_str) < 0)\n\n        return -1;\n\n\n\n    fd = qemu_socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        return -1;\n\n    }\n\n    socket_set_nonblock(fd);\n\n\n\n    connected = 0;\n\n    for(;;) {\n\n        ret = connect(fd, (struct sockaddr *)&saddr, sizeof(saddr));\n\n        if (ret < 0) {\n\n            err = socket_error();\n\n            if (err == EINTR || err == EWOULDBLOCK) {\n\n            } else if (err == EINPROGRESS) {\n\n                break;\n\n#ifdef _WIN32\n\n            } else if (err == WSAEALREADY) {\n\n                break;\n\n#endif\n\n            } else {\n\n                perror(\"connect\");\n\n                closesocket(fd);\n\n                return -1;\n\n            }\n\n        } else {\n\n            connected = 1;\n\n            break;\n\n        }\n\n    }\n\n    s = net_socket_fd_init(vlan, model, name, fd, connected);\n\n    if (!s)\n\n        return -1;\n\n    snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n             \"socket: connect to %s:%d\",\n\n             inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));\n\n    return 0;\n\n}\n", "idx": 20906, "_split": "valid", "_hash": "3314dafdabb6fc98088afc0f13afc644"}
{"project": "qemu", "commit_id": "1f3870ab242018b724b845957f7f928a2d7c1f5b", "target": 0, "func": "static int usb_device_del(const char *devname)\n\n{\n\n    USBPort *port;\n\n    USBPort **lastp;\n\n    USBDevice *dev;\n\n    int bus_num, addr;\n\n    const char *p;\n\n\n\n    if (!used_usb_ports)\n\n        return -1;\n\n\n\n    p = strchr(devname, '.');\n\n    if (!p)\n\n        return -1;\n\n    bus_num = strtoul(devname, NULL, 0);\n\n    addr = strtoul(p + 1, NULL, 0);\n\n    if (bus_num != 0)\n\n        return -1;\n\n\n\n    lastp = &used_usb_ports;\n\n    port = used_usb_ports;\n\n    while (port && port->dev->addr != addr) {\n\n        lastp = &port->next;\n\n        port = port->next;\n\n    }\n\n\n\n    if (!port)\n\n        return -1;\n\n\n\n    dev = port->dev;\n\n    *lastp = port->next;\n\n    usb_attach(port, NULL);\n\n    dev->handle_destroy(dev);\n\n    port->next = free_usb_ports;\n\n    free_usb_ports = port;\n\n    return 0;\n\n}\n", "idx": 20910, "_split": "valid", "_hash": "f26ed90b60e214af81559f90550ea0dc"}
{"project": "qemu", "commit_id": "69ef1f36b0f882fc5ba9491fb272fa5f83ac1d3d", "target": 1, "func": "void qmp_migrate_set_parameters(bool has_compress_level,\n\n                                int64_t compress_level,\n\n                                bool has_compress_threads,\n\n                                int64_t compress_threads,\n\n                                bool has_decompress_threads,\n\n                                int64_t decompress_threads,\n\n                                bool has_cpu_throttle_initial,\n\n                                int64_t cpu_throttle_initial,\n\n                                bool has_cpu_throttle_increment,\n\n                                int64_t cpu_throttle_increment,\n\n                                bool has_tls_creds,\n\n                                const char *tls_creds,\n\n                                bool has_tls_hostname,\n\n                                const char *tls_hostname,\n\n                                Error **errp)\n\n{\n\n    MigrationState *s = migrate_get_current();\n\n\n\n    if (has_compress_level && (compress_level < 0 || compress_level > 9)) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"compress_level\",\n\n                   \"is invalid, it should be in the range of 0 to 9\");\n\n        return;\n\n\n    if (has_compress_threads &&\n\n            (compress_threads < 1 || compress_threads > 255)) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE,\n\n                   \"compress_threads\",\n\n                   \"is invalid, it should be in the range of 1 to 255\");\n\n        return;\n\n\n    if (has_decompress_threads &&\n\n            (decompress_threads < 1 || decompress_threads > 255)) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE,\n\n                   \"decompress_threads\",\n\n                   \"is invalid, it should be in the range of 1 to 255\");\n\n        return;\n\n\n    if (has_cpu_throttle_initial &&\n\n            (cpu_throttle_initial < 1 || cpu_throttle_initial > 99)) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE,\n\n                   \"cpu_throttle_initial\",\n\n                   \"an integer in the range of 1 to 99\");\n\n\n    if (has_cpu_throttle_increment &&\n\n            (cpu_throttle_increment < 1 || cpu_throttle_increment > 99)) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE,\n\n                   \"cpu_throttle_increment\",\n\n                   \"an integer in the range of 1 to 99\");\n\n\n\n\n    if (has_compress_level) {\n\n        s->parameters.compress_level = compress_level;\n\n\n    if (has_compress_threads) {\n\n        s->parameters.compress_threads = compress_threads;\n\n\n    if (has_decompress_threads) {\n\n        s->parameters.decompress_threads = decompress_threads;\n\n\n    if (has_cpu_throttle_initial) {\n\n        s->parameters.cpu_throttle_initial = cpu_throttle_initial;\n\n\n    if (has_cpu_throttle_increment) {\n\n        s->parameters.cpu_throttle_increment = cpu_throttle_increment;\n\n\n\n\n\n\n\n\n\n", "idx": 20916, "_split": "valid", "_hash": "0b7ff28131934642a1f16daf58f4f975"}
{"project": "qemu", "commit_id": "d1fdf257d52822695f5ace6c586e059aa17d4b79", "target": 0, "func": "static int drop_sync(QIOChannel *ioc, size_t size, Error **errp)\n\n{\n\n    ssize_t ret = 0;\n\n    char small[1024];\n\n    char *buffer;\n\n\n\n    buffer = sizeof(small) >= size ? small : g_malloc(MIN(65536, size));\n\n    while (size > 0) {\n\n        ssize_t count = MIN(65536, size);\n\n        ret = read_sync(ioc, buffer, MIN(65536, size), errp);\n\n\n\n        if (ret < 0) {\n\n            goto cleanup;\n\n        }\n\n        size -= count;\n\n    }\n\n\n\n cleanup:\n\n    if (buffer != small) {\n\n        g_free(buffer);\n\n    }\n\n    return ret;\n\n}\n", "idx": 20929, "_split": "valid", "_hash": "ff0cf7dd04e98565528902d2c4323046"}
{"project": "qemu", "commit_id": "8a5bb1f114c5959cf6b247a737394afb0c518b40", "target": 0, "func": "static int check_refcounts_l1(BlockDriverState *bs,\n\n                              BdrvCheckResult *res,\n\n                              void **refcount_table,\n\n                              int64_t *refcount_table_size,\n\n                              int64_t l1_table_offset, int l1_size,\n\n                              int flags)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t *l1_table = NULL, l2_offset, l1_size2;\n\n    int i, ret;\n\n\n\n    l1_size2 = l1_size * sizeof(uint64_t);\n\n\n\n    /* Mark L1 table as used */\n\n    ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                        l1_table_offset, l1_size2);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Read L1 table entries from disk */\n\n    if (l1_size2 > 0) {\n\n        l1_table = g_try_malloc(l1_size2);\n\n        if (l1_table == NULL) {\n\n            ret = -ENOMEM;\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n        ret = bdrv_pread(bs->file, l1_table_offset, l1_table, l1_size2);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR: I/O error in check_refcounts_l1\\n\");\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n        for(i = 0;i < l1_size; i++)\n\n            be64_to_cpus(&l1_table[i]);\n\n    }\n\n\n\n    /* Do the actual checks */\n\n    for(i = 0; i < l1_size; i++) {\n\n        l2_offset = l1_table[i];\n\n        if (l2_offset) {\n\n            /* Mark L2 table as used */\n\n            l2_offset &= L1E_OFFSET_MASK;\n\n            ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                                l2_offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            /* L2 tables are cluster aligned */\n\n            if (offset_into_cluster(s, l2_offset)) {\n\n                fprintf(stderr, \"ERROR l2_offset=%\" PRIx64 \": Table is not \"\n\n                    \"cluster aligned; L1 entry corrupted\\n\", l2_offset);\n\n                res->corruptions++;\n\n            }\n\n\n\n            /* Process and check L2 entries */\n\n            ret = check_refcounts_l2(bs, res, refcount_table,\n\n                                     refcount_table_size, l2_offset, flags);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n    g_free(l1_table);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(l1_table);\n\n    return ret;\n\n}\n", "idx": 20957, "_split": "valid", "_hash": "bd673a5c90f6d8c5dca9853d3d2c1063"}
{"project": "qemu", "commit_id": "b78c2b3aad2b42084265c89f93a92733d68e9003", "target": 0, "func": "static void pl061_update(pl061_state *s)\n\n{\n\n    uint8_t changed;\n\n    uint8_t mask;\n\n    uint8_t out;\n\n    int i;\n\n\n\n    /* Outputs float high.  */\n\n    /* FIXME: This is board dependent.  */\n\n    out = (s->data & s->dir) | ~s->dir;\n\n    changed = s->old_data ^ out;\n\n    if (!changed)\n\n        return;\n\n\n\n    s->old_data = out;\n\n    for (i = 0; i < 8; i++) {\n\n        mask = 1 << i;\n\n        if ((changed & mask) && s->out) {\n\n            DPRINTF(\"Set output %d = %d\\n\", i, (out & mask) != 0);\n\n            qemu_set_irq(s->out[i], (out & mask) != 0);\n\n        }\n\n    }\n\n\n\n    /* FIXME: Implement input interrupts.  */\n\n}\n", "idx": 20963, "_split": "valid", "_hash": "dfec07dfc7c7133c82c76aec322b6993"}
{"project": "qemu", "commit_id": "8d999995e45c1002aa11f269c98f2e93e6f8c42a", "target": 0, "func": "void gic_set_pending_private(GICState *s, int cpu, int irq)\n\n{\n\n    int cm = 1 << cpu;\n\n\n\n    if (GIC_TEST_PENDING(irq, cm))\n\n        return;\n\n\n\n    DPRINTF(\"Set %d pending cpu %d\\n\", irq, cpu);\n\n    GIC_SET_PENDING(irq, cm);\n\n    gic_update(s);\n\n}\n", "idx": 20981, "_split": "valid", "_hash": "30c25d8280784c1b36a783a1099e2307"}
{"project": "qemu", "commit_id": "2a1639291bf9f3c88c62d10459fedaa677536ff5", "target": 0, "func": "static uint32_t pxa2xx_pm_read(void *opaque, target_phys_addr_t addr)\n\n{\n\n    struct pxa2xx_state_s *s = (struct pxa2xx_state_s *) opaque;\n\n    if (addr > s->pm_base + PCMD31) {\n\n        /* Special case: PWRI2C registers appear in the same range.  */\n\n        return pxa2xx_i2c_read(s->i2c[1], addr);\n\n    }\n\n    addr -= s->pm_base;\n\n\n\n    switch (addr) {\n\n    case PMCR ... PCMD31:\n\n        if (addr & 3)\n\n            goto fail;\n\n\n\n        return s->pm_regs[addr >> 2];\n\n    default:\n\n    fail:\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 20987, "_split": "valid", "_hash": "3de63f6e085d6086c024e63a612032f3"}
{"project": "qemu", "commit_id": "2aece63c8a9d2c3a8ff41d2febc4cdeff2633331", "target": 0, "func": "static void ivshmem_check_memdev_is_busy(Object *obj, const char *name,\n\n                                         Object *val, Error **errp)\n\n{\n\n    MemoryRegion *mr;\n\n\n\n    mr = host_memory_backend_get_memory(MEMORY_BACKEND(val), &error_abort);\n\n    if (memory_region_is_mapped(mr)) {\n\n        char *path = object_get_canonical_path_component(val);\n\n        error_setg(errp, \"can't use already busy memdev: %s\", path);\n\n        g_free(path);\n\n    } else {\n\n        qdev_prop_allow_set_link_before_realize(obj, name, val, errp);\n\n    }\n\n}\n", "idx": 20997, "_split": "valid", "_hash": "89ec61884b4f0ee88c10f449010747cb"}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void fd_chr_close(struct CharDriverState *chr)\n\n{\n\n    FDCharDriver *s = chr->opaque;\n\n\n\n    if (s->fd_in_tag) {\n\n        g_source_remove(s->fd_in_tag);\n\n        s->fd_in_tag = 0;\n\n    }\n\n\n\n    if (s->fd_in) {\n\n        g_io_channel_unref(s->fd_in);\n\n    }\n\n    if (s->fd_out) {\n\n        g_io_channel_unref(s->fd_out);\n\n    }\n\n\n\n    g_free(s);\n\n    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);\n\n}\n", "idx": 21008, "_split": "valid", "_hash": "02a09d133d2db124e6515172a96b49cb"}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void async_complete(void *opaque)\n\n{\n\n    USBHostDevice *s = opaque;\n\n    AsyncURB *aurb;\n\n    int urbs = 0;\n\n\n\n    while (1) {\n\n        USBPacket *p;\n\n\n\n        int r = ioctl(s->fd, USBDEVFS_REAPURBNDELAY, &aurb);\n\n        if (r < 0) {\n\n            if (errno == EAGAIN) {\n\n                if (urbs > 2) {\n\n                    fprintf(stderr, \"husb: %d iso urbs finished at once\\n\", urbs);\n\n                }\n\n                return;\n\n            }\n\n            if (errno == ENODEV && !s->closing) {\n\n                do_disconnect(s);\n\n                return;\n\n            }\n\n\n\n            DPRINTF(\"husb: async. reap urb failed errno %d\\n\", errno);\n\n            return;\n\n        }\n\n\n\n        DPRINTF(\"husb: async completed. aurb %p status %d alen %d\\n\",\n\n                aurb, aurb->urb.status, aurb->urb.actual_length);\n\n\n\n        /* If this is a buffered iso urb mark it as complete and don't do\n\n           anything else (it is handled further in usb_host_handle_iso_data) */\n\n        if (aurb->iso_frame_idx == -1) {\n\n            int inflight;\n\n            if (aurb->urb.status == -EPIPE) {\n\n                set_halt(s, aurb->urb.endpoint & 0xf);\n\n            }\n\n            aurb->iso_frame_idx = 0;\n\n            urbs++;\n\n            inflight = change_iso_inflight(s, aurb->urb.endpoint & 0xf, -1);\n\n            if (inflight == 0 && is_iso_started(s, aurb->urb.endpoint & 0xf)) {\n\n                fprintf(stderr, \"husb: out of buffers for iso stream\\n\");\n\n            }\n\n            continue;\n\n        }\n\n\n\n        p = aurb->packet;\n\n\n\n        if (p) {\n\n            switch (aurb->urb.status) {\n\n            case 0:\n\n                p->len += aurb->urb.actual_length;\n\n                break;\n\n\n\n            case -EPIPE:\n\n                set_halt(s, p->devep);\n\n                p->len = USB_RET_STALL;\n\n                break;\n\n\n\n            default:\n\n                p->len = USB_RET_NAK;\n\n                break;\n\n            }\n\n\n\n            if (aurb->urb.type == USBDEVFS_URB_TYPE_CONTROL) {\n\n                usb_generic_async_ctrl_complete(&s->dev, p);\n\n            } else if (!aurb->more) {\n\n                usb_packet_complete(&s->dev, p);\n\n            }\n\n        }\n\n\n\n        async_free(aurb);\n\n    }\n\n}\n", "idx": 21009, "_split": "valid", "_hash": "66e441ef6e139844620d66dc12fefa5d"}
{"project": "qemu", "commit_id": "413d463f43fbc4dd3a601e80a5724aa384a265a0", "target": 1, "func": "static void dhcp_decode(const struct bootp_t *bp, int *pmsg_type,\n\n                        struct in_addr *preq_addr)\n\n{\n\n    const uint8_t *p, *p_end;\n\n    int len, tag;\n\n\n\n    *pmsg_type = 0;\n\n    preq_addr->s_addr = htonl(0L);\n\n\n\n    p = bp->bp_vend;\n\n    p_end = p + DHCP_OPT_LEN;\n\n    if (memcmp(p, rfc1533_cookie, 4) != 0)\n\n        return;\n\n    p += 4;\n\n    while (p < p_end) {\n\n        tag = p[0];\n\n        if (tag == RFC1533_PAD) {\n\n            p++;\n\n        } else if (tag == RFC1533_END) {\n\n\n        } else {\n\n            p++;\n\n            if (p >= p_end)\n\n\n            len = *p++;\n\n\n\n\n            DPRINTF(\"dhcp: tag=%d len=%d\\n\", tag, len);\n\n\n\n            switch(tag) {\n\n            case RFC2132_MSG_TYPE:\n\n                if (len >= 1)\n\n                    *pmsg_type = p[0];\n\n\n            case RFC2132_REQ_ADDR:\n\n                if (len >= 4) {\n\n                    memcpy(&(preq_addr->s_addr), p, 4);\n\n\n\n            default:\n\n\n\n            p += len;\n\n\n\n    if (*pmsg_type == DHCPREQUEST && preq_addr->s_addr == htonl(0L) &&\n\n        bp->bp_ciaddr.s_addr) {\n\n        memcpy(&(preq_addr->s_addr), &bp->bp_ciaddr, 4);\n\n", "idx": 21020, "_split": "valid", "_hash": "e8828bd36b55af6383fb709d843f41d8"}
{"project": "qemu", "commit_id": "fc34059f080680b560b3f656988fdd9a75cd0eab", "target": 1, "func": "static void GCC_FMT_ATTR(2, 3) qtest_sendf(CharBackend *chr,\n\n                                           const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n    gchar *buffer;\n\n\n\n    va_start(ap, fmt);\n\n    buffer = g_strdup_vprintf(fmt, ap);\n\n    qtest_send(chr, buffer);\n\n\n    va_end(ap);\n\n}", "idx": 21026, "_split": "valid", "_hash": "0973df3910a6750af4aca7442afda522"}
{"project": "qemu", "commit_id": "f897bf751fbd95e4015b95d202c706548586813a", "target": 1, "func": "static int virtio_blk_load_device(VirtIODevice *vdev, QEMUFile *f,\n\n                                  int version_id)\n\n{\n\n    VirtIOBlock *s = VIRTIO_BLK(vdev);\n\n\n\n    while (qemu_get_sbyte(f)) {\n\n        VirtIOBlockReq *req = virtio_blk_alloc_request(s);\n\n        qemu_get_buffer(f, (unsigned char *)req->elem,\n\n                        sizeof(VirtQueueElement));\n\n        req->next = s->rq;\n\n        s->rq = req;\n\n\n\n        virtqueue_map_sg(req->elem->in_sg, req->elem->in_addr,\n\n            req->elem->in_num, 1);\n\n        virtqueue_map_sg(req->elem->out_sg, req->elem->out_addr,\n\n            req->elem->out_num, 0);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21033, "_split": "valid", "_hash": "91ad3bf297b352665af9754ecc600620"}
{"project": "qemu", "commit_id": "4207117c93357347500235952ce7891688089cb1", "target": 0, "func": "struct pxa2xx_state_s *pxa270_init(DisplayState *ds, const char *revision)\n\n{\n\n    struct pxa2xx_state_s *s;\n\n    struct pxa2xx_ssp_s *ssp;\n\n    char cpu_model[16];\n\n    int iomemtype, i;\n\n    s = (struct pxa2xx_state_s *) qemu_mallocz(sizeof(struct pxa2xx_state_s));\n\n\n\n    s->env = cpu_init();\n\n    snprintf(cpu_model, sizeof(cpu_model), \"pxa270-%s\", revision);\n\n    cpu_arm_set_model(s->env, cpu_model);\n\n\n\n    s->pic = pxa2xx_pic_init(0x40d00000, s->env);\n\n\n\n    s->dma = pxa27x_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]);\n\n\n\n    pxa27x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0],\n\n                    s->pic[PXA27X_PIC_OST_4_11], s->env);\n\n\n\n    s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 121);\n\n\n\n    s->mmc = pxa2xx_mmci_init(0x41100000, s->pic[PXA2XX_PIC_MMC], s->dma);\n\n\n\n    for (i = 0; pxa270_serial[i].io_base; i ++)\n\n        if (serial_hds[i])\n\n            serial_mm_init(pxa270_serial[i].io_base, 2,\n\n                            s->pic[pxa270_serial[i].irqn], serial_hds[i], 1);\n\n        else\n\n            break;\n\n    if (serial_hds[i])\n\n        s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP],\n\n                        s->dma, serial_hds[i]);\n\n\n\n    if (ds)\n\n        s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD], ds);\n\n\n\n    s->cm_base = 0x41300000;\n\n    s->cm_regs[CCCR >> 4] = 0x02000210;\t/* 416.0 MHz */\n\n    s->clkcfg = 0x00000009;\t\t/* Turbo mode active */\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_cm_readfn,\n\n                    pxa2xx_cm_writefn, s);\n\n    cpu_register_physical_memory(s->cm_base, 0xfff, iomemtype);\n\n\n\n    cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s);\n\n\n\n    s->mm_base = 0x48000000;\n\n    s->mm_regs[MDMRS >> 2] = 0x00020002;\n\n    s->mm_regs[MDREFR >> 2] = 0x03ca4000;\n\n    s->mm_regs[MECR >> 2] = 0x00000001;\t/* Two PC Card sockets */\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_mm_readfn,\n\n                    pxa2xx_mm_writefn, s);\n\n    cpu_register_physical_memory(s->mm_base, 0xfff, iomemtype);\n\n\n\n    for (i = 0; pxa27x_ssp[i].io_base; i ++);\n\n    s->ssp = (struct pxa2xx_ssp_s **)\n\n            qemu_mallocz(sizeof(struct pxa2xx_ssp_s *) * i);\n\n    ssp = (struct pxa2xx_ssp_s *)\n\n            qemu_mallocz(sizeof(struct pxa2xx_ssp_s) * i);\n\n    for (i = 0; pxa27x_ssp[i].io_base; i ++) {\n\n        s->ssp[i] = &ssp[i];\n\n        ssp[i].base = pxa27x_ssp[i].io_base;\n\n        ssp[i].irq = s->pic[pxa27x_ssp[i].irqn];\n\n\n\n        iomemtype = cpu_register_io_memory(0, pxa2xx_ssp_readfn,\n\n                        pxa2xx_ssp_writefn, &ssp[i]);\n\n        cpu_register_physical_memory(ssp[i].base, 0xfff, iomemtype);\n\n    }\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pxa(0x4c000000, 3, -1, s->pic[PXA2XX_PIC_USBH1]);\n\n    }\n\n\n\n    s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);\n\n    s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);\n\n\n\n    s->rtc_base = 0x40900000;\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_rtc_readfn,\n\n                    pxa2xx_rtc_writefn, s);\n\n    cpu_register_physical_memory(s->rtc_base, 0xfff, iomemtype);\n\n    pxa2xx_rtc_reset(s);\n\n\n\n    s->pm_base = 0x40f00000;\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_pm_readfn,\n\n                    pxa2xx_pm_writefn, s);\n\n    cpu_register_physical_memory(s->pm_base, 0xfff, iomemtype);\n\n\n\n    s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma);\n\n\n\n    /* GPIO1 resets the processor */\n\n    /* The handler can be overriden by board-specific code */\n\n    pxa2xx_gpio_handler_set(s->gpio, 1, pxa2xx_reset, s);\n\n    return s;\n\n}\n", "idx": 21091, "_split": "valid", "_hash": "9dea1d28be0652f809771099e887ce15"}
{"project": "qemu", "commit_id": "3ac216270a62418519c08e88c17005a8f1539cf2", "target": 1, "func": "static int hdev_has_zero_init(BlockDriverState *bs)\n\n{\n\n    return 0;\n\n}\n", "idx": 21124, "_split": "valid", "_hash": "d3616f40fb5b54293de76accd96ed318"}
{"project": "qemu", "commit_id": "a15fcc3cf69ee3d408f60d6cc316488d2b0249b4", "target": 1, "func": "void visit_start_struct(Visitor *v, const char *name, void **obj,\n\n                        size_t size, Error **errp)\n\n{\n\n    Error *err = NULL;\n\n\n\n    if (obj) {\n\n        assert(size);\n\n        assert(v->type != VISITOR_OUTPUT || *obj);\n\n    }\n\n    v->start_struct(v, name, obj, size, &err);\n\n    if (obj && v->type == VISITOR_INPUT) {\n\n        assert(!err != !*obj);\n\n    }\n\n    error_propagate(errp, err);\n\n}\n", "idx": 21160, "_split": "valid", "_hash": "afe9bd93c5a7249dedc5c3b089e1ee35"}
{"project": "qemu", "commit_id": "ac58fe7b2c67a9be142beacd4c6ee51f3264d90f", "target": 1, "func": "static void pmac_ide_transfer_cb(void *opaque, int ret)\n\n{\n\n    DBDMA_io *io = opaque;\n\n    MACIOIDEState *m = io->opaque;\n\n    IDEState *s = idebus_active_if(&m->bus);\n\n    int64_t sector_num;\n\n    int nsector, remainder;\n\n    int64_t offset;\n\n\n\n    MACIO_DPRINTF(\"pmac_ide_transfer_cb\\n\");\n\n\n\n    if (ret < 0) {\n\n        MACIO_DPRINTF(\"DMA error\\n\");\n\n        m->aiocb = NULL;\n\n        ide_dma_error(s);\n\n        io->remainder_len = 0;\n\n        goto done;\n\n    }\n\n\n\n    if (!m->dma_active) {\n\n        MACIO_DPRINTF(\"waiting for data (%#x - %#x - %x)\\n\",\n\n                      s->nsector, io->len, s->status);\n\n        /* data not ready yet, wait for the channel to get restarted */\n\n        io->processing = false;\n\n        return;\n\n    }\n\n\n\n    if (s->io_buffer_size <= 0) {\n\n        MACIO_DPRINTF(\"end of transfer\\n\");\n\n        s->status = READY_STAT | SEEK_STAT;\n\n        ide_set_irq(s->bus);\n\n        m->dma_active = false;\n\n        goto done;\n\n    }\n\n\n\n    if (io->len == 0) {\n\n        MACIO_DPRINTF(\"End of DMA transfer\\n\");\n\n        goto done;\n\n    }\n\n\n\n    /* Calculate number of sectors */\n\n    sector_num = ide_get_sector(s) + (s->io_buffer_index >> 9);\n\n    offset = (ide_get_sector(s) << 9) + s->io_buffer_index;\n\n    nsector = (io->len + 0x1ff) >> 9;\n\n    remainder = io->len & 0x1ff;\n\n\n\n    s->nsector -= nsector;\n\n\n\n    MACIO_DPRINTF(\"nsector: %d   remainder: %x\\n\", nsector, remainder);\n\n    MACIO_DPRINTF(\"sector: %\"PRIx64\"   %x\\n\", sector_num, nsector);\n\n\n\n    switch (s->dma_cmd) {\n\n    case IDE_DMA_READ:\n\n        pmac_dma_read(s->blk, offset, io->len, pmac_ide_transfer_cb, io);\n\n        break;\n\n    case IDE_DMA_WRITE:\n\n        pmac_dma_write(s->blk, sector_num, nsector, pmac_ide_transfer_cb, io);\n\n        break;\n\n    case IDE_DMA_TRIM:\n\n        MACIO_DPRINTF(\"TRIM command issued!\");\n\n        break;\n\n    }\n\n\n\n    return;\n\n\n\ndone:\n\n    if (s->dma_cmd == IDE_DMA_READ || s->dma_cmd == IDE_DMA_WRITE) {\n\n        block_acct_done(blk_get_stats(s->blk), &s->acct);\n\n    }\n\n    io->dma_end(opaque);\n\n}\n", "idx": 21171, "_split": "valid", "_hash": "f7f4f07788aa681a9b57736e907be2af"}
{"project": "qemu", "commit_id": "42e4126b793d15ec40f3a84017e1d8afecda1b6d", "target": 1, "func": "void pci_default_write_config(PCIDevice *d, uint32_t addr, uint32_t val, int l)\n\n{\n\n    int i, was_irq_disabled = pci_irq_disabled(d);\n\n    uint32_t config_size = pci_config_size(d);\n\n\n\n    for (i = 0; i < l && addr + i < config_size; val >>= 8, ++i) {\n\n        uint8_t wmask = d->wmask[addr + i];\n\n        uint8_t w1cmask = d->w1cmask[addr + i];\n\n        assert(!(wmask & w1cmask));\n\n        d->config[addr + i] = (d->config[addr + i] & ~wmask) | (val & wmask);\n\n        d->config[addr + i] &= ~(val & w1cmask); /* W1C: Write 1 to Clear */\n\n    }\n\n    if (ranges_overlap(addr, l, PCI_BASE_ADDRESS_0, 24) ||\n\n        ranges_overlap(addr, l, PCI_ROM_ADDRESS, 4) ||\n\n        ranges_overlap(addr, l, PCI_ROM_ADDRESS1, 4) ||\n\n        range_covers_byte(addr, l, PCI_COMMAND))\n\n        pci_update_mappings(d);\n\n\n\n    if (range_covers_byte(addr, l, PCI_COMMAND))\n\n        pci_update_irq_disabled(d, was_irq_disabled);\n\n}\n", "idx": 21189, "_split": "valid", "_hash": "41c3be9426a967dfabfab468bd33f2fc"}
{"project": "qemu", "commit_id": "425532d71d5d295cc9c649500e4969ac621ce51d", "target": 0, "func": "static inline int check_fit_i32(uint32_t val, unsigned int bits)\n\n{\n\n    return ((val << (32 - bits)) >> (32 - bits)) == val;\n\n}\n", "idx": 21196, "_split": "valid", "_hash": "a05bf65092a86930978cc201a17445da"}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_getattr(void *opaque)\n\n{\n\n    int32_t fid;\n\n    size_t offset = 7;\n\n    ssize_t retval = 0;\n\n    struct stat stbuf;\n\n    V9fsFidState *fidp;\n\n    uint64_t request_mask;\n\n    V9fsStatDotl v9stat_dotl;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dq\", &fid, &request_mask);\n\n    trace_v9fs_getattr(pdu->tag, pdu->id, fid, request_mask);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        retval = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n    /*\n\n     * Currently we only support BASIC fields in stat, so there is no\n\n     * need to look at request_mask.\n\n     */\n\n    retval = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n\n    if (retval < 0) {\n\n        goto out;\n\n    }\n\n    stat_to_v9stat_dotl(s, &stbuf, &v9stat_dotl);\n\n\n\n    /*  fill st_gen if requested and supported by underlying fs */\n\n    if (request_mask & P9_STATS_GEN) {\n\n        retval = v9fs_co_st_gen(pdu, &fidp->path, stbuf.st_mode, &v9stat_dotl);\n\n        if (retval < 0) {\n\n            goto out;\n\n        }\n\n        v9stat_dotl.st_result_mask |= P9_STATS_GEN;\n\n    }\n\n    retval = offset;\n\n    retval += pdu_marshal(pdu, offset, \"A\", &v9stat_dotl);\n\n    trace_v9fs_getattr_return(pdu->tag, pdu->id, v9stat_dotl.st_result_mask,\n\n                              v9stat_dotl.st_mode, v9stat_dotl.st_uid,\n\n                              v9stat_dotl.st_gid);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(s, pdu, retval);\n\n}\n", "idx": 21200, "_split": "valid", "_hash": "cd14e3ea6307d267cea871dfb8208687"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "int qemu_timeout_ns_to_ms(int64_t ns)\n\n{\n\n    int64_t ms;\n\n    if (ns < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (!ns) {\n\n        return 0;\n\n    }\n\n\n\n    /* Always round up, because it's better to wait too long than to wait too\n\n     * little and effectively busy-wait\n\n     */\n\n    ms = DIV_ROUND_UP(ns, SCALE_MS);\n\n\n\n    /* To avoid overflow problems, limit this to 2^31, i.e. approx 25 days */\n\n    if (ms > (int64_t) INT32_MAX) {\n\n        ms = INT32_MAX;\n\n    }\n\n\n\n    return (int) ms;\n\n}\n", "idx": 21215, "_split": "valid", "_hash": "1083bfccc9b36812f3803591c48394ed"}
{"project": "qemu", "commit_id": "13d1fd44c46629aad672f192abbf02238c6cbf36", "target": 1, "func": "static void qxl_init_ramsize(PCIQXLDevice *qxl, uint32_t ram_min_mb)\n\n{\n\n    /* vga ram (bar 0) */\n\n    if (qxl->ram_size_mb != -1) {\n\n        qxl->vga.vram_size = qxl->ram_size_mb * 1024 * 1024;\n\n    }\n\n    if (qxl->vga.vram_size < ram_min_mb * 1024 * 1024) {\n\n        qxl->vga.vram_size = ram_min_mb * 1024 * 1024;\n\n    }\n\n\n\n    /* vram32 (surfaces, 32bit, bar 1) */\n\n    if (qxl->vram32_size_mb != -1) {\n\n        qxl->vram32_size = qxl->vram32_size_mb * 1024 * 1024;\n\n    }\n\n    if (qxl->vram32_size < 4096) {\n\n        qxl->vram32_size = 4096;\n\n    }\n\n\n\n    /* vram (surfaces, 64bit, bar 4+5) */\n\n    if (qxl->vram_size_mb != -1) {\n\n        qxl->vram_size = qxl->vram_size_mb * 1024 * 1024;\n\n    }\n\n    if (qxl->vram_size < qxl->vram32_size) {\n\n        qxl->vram_size = qxl->vram32_size;\n\n    }\n\n\n\n    if (qxl->revision == 1) {\n\n        qxl->vram32_size = 4096;\n\n        qxl->vram_size = 4096;\n\n    }\n\n    qxl->vga.vram_size = msb_mask(qxl->vga.vram_size * 2 - 1);\n\n    qxl->vram32_size = msb_mask(qxl->vram32_size * 2 - 1);\n\n    qxl->vram_size = msb_mask(qxl->vram_size * 2 - 1);\n\n}\n", "idx": 21230, "_split": "valid", "_hash": "57e402fec40f15ed2248cb6b2d2b14a7"}
{"project": "qemu", "commit_id": "aa5cb7f5e8bf2e6737d0cb36c118332ca26e7797", "target": 1, "func": "static void register_types(void)\n\n{\n\n    register_char_driver(\"null\", CHARDEV_BACKEND_KIND_NULL, NULL,\n\n                         qemu_chr_open_null);\n\n    register_char_driver(\"socket\", CHARDEV_BACKEND_KIND_SOCKET,\n\n                         qemu_chr_parse_socket, qmp_chardev_open_socket);\n\n    register_char_driver(\"udp\", CHARDEV_BACKEND_KIND_UDP, qemu_chr_parse_udp,\n\n                         qmp_chardev_open_udp);\n\n    register_char_driver(\"ringbuf\", CHARDEV_BACKEND_KIND_RINGBUF,\n\n                         qemu_chr_parse_ringbuf, qemu_chr_open_ringbuf);\n\n    register_char_driver(\"file\", CHARDEV_BACKEND_KIND_FILE,\n\n                         qemu_chr_parse_file_out, qmp_chardev_open_file);\n\n    register_char_driver(\"stdio\", CHARDEV_BACKEND_KIND_STDIO,\n\n                         qemu_chr_parse_stdio, qemu_chr_open_stdio);\n\n#if defined HAVE_CHARDEV_SERIAL\n\n    register_char_driver(\"serial\", CHARDEV_BACKEND_KIND_SERIAL,\n\n                         qemu_chr_parse_serial, qmp_chardev_open_serial);\n\n    register_char_driver(\"tty\", CHARDEV_BACKEND_KIND_SERIAL,\n\n                         qemu_chr_parse_serial, qmp_chardev_open_serial);\n\n#endif\n\n#ifdef HAVE_CHARDEV_PARPORT\n\n    register_char_driver(\"parallel\", CHARDEV_BACKEND_KIND_PARALLEL,\n\n                         qemu_chr_parse_parallel, qmp_chardev_open_parallel);\n\n    register_char_driver(\"parport\", CHARDEV_BACKEND_KIND_PARALLEL,\n\n                         qemu_chr_parse_parallel, qmp_chardev_open_parallel);\n\n#endif\n\n#ifdef HAVE_CHARDEV_PTY\n\n    register_char_driver(\"pty\", CHARDEV_BACKEND_KIND_PTY, NULL,\n\n                         qemu_chr_open_pty);\n\n#endif\n\n#ifdef _WIN32\n\n    register_char_driver(\"console\", CHARDEV_BACKEND_KIND_CONSOLE, NULL,\n\n                         qemu_chr_open_win_con);\n\n#endif\n\n    register_char_driver(\"pipe\", CHARDEV_BACKEND_KIND_PIPE,\n\n                         qemu_chr_parse_pipe, qemu_chr_open_pipe);\n\n    register_char_driver(\"mux\", CHARDEV_BACKEND_KIND_MUX, qemu_chr_parse_mux,\n\n                         qemu_chr_open_mux);\n\n    /* Bug-compatibility: */\n\n    register_char_driver(\"memory\", CHARDEV_BACKEND_KIND_MEMORY,\n\n                         qemu_chr_parse_ringbuf, qemu_chr_open_ringbuf);\n\n    /* this must be done after machine init, since we register FEs with muxes\n\n     * as part of realize functions like serial_isa_realizefn when -nographic\n\n     * is specified\n\n     */\n\n    qemu_add_machine_init_done_notifier(&muxes_realize_notify);\n\n\n\n    atexit(qemu_chr_cleanup);\n\n}\n", "idx": 21238, "_split": "valid", "_hash": "556a9f11618340f25f68dd81f33422f4"}
{"project": "qemu", "commit_id": "fc5d642fcae392bbc9fed9ac6bc78ac29ed48372", "target": 1, "func": "static void on_vcpu(CPUState *env, void (*func)(void *data), void *data)\n\n{\n\n    if (env == cpu_single_env) {\n\n        func(data);\n\n        return;\n\n    }\n\n    abort();\n\n}\n", "idx": 21282, "_split": "valid", "_hash": "1009910fe945fd55d2fee41e64051420"}
{"project": "qemu", "commit_id": "d42cf28837801cd1f835089fe9db2a42a1af55cd", "target": 0, "func": "static void bdrv_drain_recurse(BlockDriverState *bs)\n\n{\n\n    BdrvChild *child;\n\n\n\n    if (bs->drv && bs->drv->bdrv_drain) {\n\n        bs->drv->bdrv_drain(bs);\n\n    }\n\n    QLIST_FOREACH(child, &bs->children, next) {\n\n        bdrv_drain_recurse(child->bs);\n\n    }\n\n}\n", "idx": 21313, "_split": "valid", "_hash": "729d4a7bfe25053866e1f679e1825b5a"}
{"project": "qemu", "commit_id": "a7c31816288a8f20fc387d69d441413e7a8c9ff1", "target": 0, "func": "static void dump_qobject(fprintf_function func_fprintf, void *f,\n\n                         int comp_indent, QObject *obj)\n\n{\n\n    switch (qobject_type(obj)) {\n\n        case QTYPE_QINT: {\n\n            QInt *value = qobject_to_qint(obj);\n\n            func_fprintf(f, \"%\" PRId64, qint_get_int(value));\n\n            break;\n\n        }\n\n        case QTYPE_QSTRING: {\n\n            QString *value = qobject_to_qstring(obj);\n\n            func_fprintf(f, \"%s\", qstring_get_str(value));\n\n            break;\n\n        }\n\n        case QTYPE_QDICT: {\n\n            QDict *value = qobject_to_qdict(obj);\n\n            dump_qdict(func_fprintf, f, comp_indent, value);\n\n            break;\n\n        }\n\n        case QTYPE_QLIST: {\n\n            QList *value = qobject_to_qlist(obj);\n\n            dump_qlist(func_fprintf, f, comp_indent, value);\n\n            break;\n\n        }\n\n        case QTYPE_QFLOAT: {\n\n            QFloat *value = qobject_to_qfloat(obj);\n\n            func_fprintf(f, \"%g\", qfloat_get_double(value));\n\n            break;\n\n        }\n\n        case QTYPE_QBOOL: {\n\n            QBool *value = qobject_to_qbool(obj);\n\n            func_fprintf(f, \"%s\", qbool_get_int(value) ? \"true\" : \"false\");\n\n            break;\n\n        }\n\n        case QTYPE_QERROR: {\n\n            QString *value = qerror_human((QError *)obj);\n\n            func_fprintf(f, \"%s\", qstring_get_str(value));\n\n            QDECREF(value);\n\n            break;\n\n        }\n\n        case QTYPE_NONE:\n\n            break;\n\n        case QTYPE_MAX:\n\n        default:\n\n            abort();\n\n    }\n\n}\n", "idx": 21319, "_split": "valid", "_hash": "cf7031ea54cef1c77277e9f87e8566a9"}
{"project": "qemu", "commit_id": "c527e0afcd7d719abc3a5ca5e4c8ac2fe48b999f", "target": 1, "func": "vmxnet3_dump_tx_descr(struct Vmxnet3_TxDesc *descr)\n\n{\n\n    VMW_PKPRN(\"TX DESCR: \"\n\n              \"addr %\" PRIx64 \", len: %d, gen: %d, rsvd: %d, \"\n\n              \"dtype: %d, ext1: %d, msscof: %d, hlen: %d, om: %d, \"\n\n              \"eop: %d, cq: %d, ext2: %d, ti: %d, tci: %d\",\n\n              le64_to_cpu(descr->addr), descr->len, descr->gen, descr->rsvd,\n\n              descr->dtype, descr->ext1, descr->msscof, descr->hlen, descr->om,\n\n              descr->eop, descr->cq, descr->ext2, descr->ti, descr->tci);\n\n}\n", "idx": 21334, "_split": "valid", "_hash": "b7e4e5119072d34b60e7c9547db80587"}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_dsdt(GArray *table_data, GArray *linker,\n\n           AcpiCpuInfo *cpu, AcpiPmInfo *pm, AcpiMiscInfo *misc,\n\n           PcPciInfo *pci)\n\n{\n\n    CrsRangeEntry *entry;\n\n    Aml *dsdt, *sb_scope, *scope, *dev, *method, *field, *pkg, *crs;\n\n    GPtrArray *mem_ranges = g_ptr_array_new_with_free_func(crs_range_free);\n\n    GPtrArray *io_ranges = g_ptr_array_new_with_free_func(crs_range_free);\n\n    MachineState *machine = MACHINE(qdev_get_machine());\n\n    PCMachineState *pcms = PC_MACHINE(machine);\n\n    uint32_t nr_mem = machine->ram_slots;\n\n    int root_bus_limit = 0xFF;\n\n    PCIBus *bus = NULL;\n\n    int i;\n\n\n\n    dsdt = init_aml_allocator();\n\n\n\n    /* Reserve space for header */\n\n    acpi_data_push(dsdt->buf, sizeof(AcpiTableHeader));\n\n\n\n    build_dbg_aml(dsdt);\n\n    if (misc->is_piix4) {\n\n        sb_scope = aml_scope(\"_SB\");\n\n        dev = aml_device(\"PCI0\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n\n        aml_append(sb_scope, dev);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        build_hpet_aml(dsdt);\n\n        build_piix4_pm(dsdt);\n\n        build_piix4_isa_bridge(dsdt);\n\n        build_isa_devices_aml(dsdt);\n\n        build_piix4_pci_hotplug(dsdt);\n\n        build_piix4_pci0_int(dsdt);\n\n    } else {\n\n        sb_scope = aml_scope(\"_SB\");\n\n        aml_append(sb_scope,\n\n            aml_operation_region(\"PCST\", AML_SYSTEM_IO, 0xae00, 0x0c));\n\n        aml_append(sb_scope,\n\n            aml_operation_region(\"PCSB\", AML_SYSTEM_IO, 0xae0c, 0x01));\n\n        field = aml_field(\"PCSB\", AML_ANY_ACC, AML_NOLOCK, AML_WRITE_AS_ZEROS);\n\n        aml_append(field, aml_named_field(\"PCIB\", 8));\n\n        aml_append(sb_scope, field);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        sb_scope = aml_scope(\"_SB\");\n\n        dev = aml_device(\"PCI0\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A08\")));\n\n        aml_append(dev, aml_name_decl(\"_CID\", aml_eisaid(\"PNP0A03\")));\n\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n\n        aml_append(dev, aml_name_decl(\"SUPP\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"CTRL\", aml_int(0)));\n\n        aml_append(dev, build_q35_osc_method());\n\n        aml_append(sb_scope, dev);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        build_hpet_aml(dsdt);\n\n        build_q35_isa_bridge(dsdt);\n\n        build_isa_devices_aml(dsdt);\n\n        build_q35_pci0_int(dsdt);\n\n    }\n\n\n\n    build_cpu_hotplug_aml(dsdt);\n\n    build_memory_hotplug_aml(dsdt, nr_mem, pm->mem_hp_io_base,\n\n                             pm->mem_hp_io_len);\n\n\n\n    scope =  aml_scope(\"_GPE\");\n\n    {\n\n        aml_append(scope, aml_name_decl(\"_HID\", aml_string(\"ACPI0006\")));\n\n\n\n        aml_append(scope, aml_method(\"_L00\", 0, AML_NOTSERIALIZED));\n\n\n\n        if (misc->is_piix4) {\n\n            method = aml_method(\"_E01\", 0, AML_NOTSERIALIZED);\n\n            aml_append(method,\n\n                aml_acquire(aml_name(\"\\\\_SB.PCI0.BLCK\"), 0xFFFF));\n\n            aml_append(method, aml_call0(\"\\\\_SB.PCI0.PCNT\"));\n\n            aml_append(method, aml_release(aml_name(\"\\\\_SB.PCI0.BLCK\")));\n\n            aml_append(scope, method);\n\n        } else {\n\n            aml_append(scope, aml_method(\"_L01\", 0, AML_NOTSERIALIZED));\n\n        }\n\n\n\n        method = aml_method(\"_E02\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_call0(\"\\\\_SB.\" CPU_SCAN_METHOD));\n\n        aml_append(scope, method);\n\n\n\n        method = aml_method(\"_E03\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_call0(MEMORY_HOTPLUG_HANDLER_PATH));\n\n        aml_append(scope, method);\n\n\n\n        aml_append(scope, aml_method(\"_L04\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L05\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L06\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L07\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L08\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L09\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L0A\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L0B\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L0C\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L0D\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L0E\", 0, AML_NOTSERIALIZED));\n\n        aml_append(scope, aml_method(\"_L0F\", 0, AML_NOTSERIALIZED));\n\n    }\n\n    aml_append(dsdt, scope);\n\n\n\n    bus = PC_MACHINE(machine)->bus;\n\n    if (bus) {\n\n        QLIST_FOREACH(bus, &bus->child, sibling) {\n\n            uint8_t bus_num = pci_bus_num(bus);\n\n            uint8_t numa_node = pci_bus_numa_node(bus);\n\n\n\n            /* look only for expander root buses */\n\n            if (!pci_bus_is_root(bus)) {\n\n                continue;\n\n            }\n\n\n\n            if (bus_num < root_bus_limit) {\n\n                root_bus_limit = bus_num - 1;\n\n            }\n\n\n\n            scope = aml_scope(\"\\\\_SB\");\n\n            dev = aml_device(\"PC%.02X\", bus_num);\n\n            aml_append(dev, aml_name_decl(\"_UID\", aml_int(bus_num)));\n\n            aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n\n            aml_append(dev, aml_name_decl(\"_BBN\", aml_int(bus_num)));\n\n\n\n            if (numa_node != NUMA_NODE_UNASSIGNED) {\n\n                aml_append(dev, aml_name_decl(\"_PXM\", aml_int(numa_node)));\n\n            }\n\n\n\n            aml_append(dev, build_prt(false));\n\n            crs = build_crs(PCI_HOST_BRIDGE(BUS(bus)->parent),\n\n                            io_ranges, mem_ranges);\n\n            aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n            aml_append(scope, dev);\n\n            aml_append(dsdt, scope);\n\n        }\n\n    }\n\n\n\n    scope = aml_scope(\"\\\\_SB.PCI0\");\n\n    /* build PCI0._CRS */\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                            0x0000, 0x0, root_bus_limit,\n\n                            0x0000, root_bus_limit + 1));\n\n    aml_append(crs, aml_io(AML_DECODE16, 0x0CF8, 0x0CF8, 0x01, 0x08));\n\n\n\n    aml_append(crs,\n\n        aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                    AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                    0x0000, 0x0000, 0x0CF7, 0x0000, 0x0CF8));\n\n\n\n    crs_replace_with_free_ranges(io_ranges, 0x0D00, 0xFFFF);\n\n    for (i = 0; i < io_ranges->len; i++) {\n\n        entry = g_ptr_array_index(io_ranges, i);\n\n        aml_append(crs,\n\n            aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                        AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                        0x0000, entry->base, entry->limit,\n\n                        0x0000, entry->limit - entry->base + 1));\n\n    }\n\n\n\n    aml_append(crs,\n\n        aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                         AML_CACHEABLE, AML_READ_WRITE,\n\n                         0, 0x000A0000, 0x000BFFFF, 0, 0x00020000));\n\n\n\n    crs_replace_with_free_ranges(mem_ranges, pci->w32.begin, pci->w32.end - 1);\n\n    for (i = 0; i < mem_ranges->len; i++) {\n\n        entry = g_ptr_array_index(mem_ranges, i);\n\n        aml_append(crs,\n\n            aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_NON_CACHEABLE, AML_READ_WRITE,\n\n                             0, entry->base, entry->limit,\n\n                             0, entry->limit - entry->base + 1));\n\n    }\n\n\n\n    if (pci->w64.begin) {\n\n        aml_append(crs,\n\n            aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_CACHEABLE, AML_READ_WRITE,\n\n                             0, pci->w64.begin, pci->w64.end - 1, 0,\n\n                             pci->w64.end - pci->w64.begin));\n\n    }\n\n    aml_append(scope, aml_name_decl(\"_CRS\", crs));\n\n\n\n    /* reserve GPE0 block resources */\n\n    dev = aml_device(\"GPE0\");\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n\n    aml_append(dev, aml_name_decl(\"_UID\", aml_string(\"GPE0 resources\")));\n\n    /* device present, functioning, decoding, not shown in UI */\n\n    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_io(AML_DECODE16, pm->gpe0_blk, pm->gpe0_blk, 1, pm->gpe0_blk_len)\n\n    );\n\n    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n    aml_append(scope, dev);\n\n\n\n    g_ptr_array_free(io_ranges, true);\n\n    g_ptr_array_free(mem_ranges, true);\n\n\n\n    /* reserve PCIHP resources */\n\n    if (pm->pcihp_io_len) {\n\n        dev = aml_device(\"PHPR\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n\n        aml_append(dev,\n\n            aml_name_decl(\"_UID\", aml_string(\"PCI Hotplug resources\")));\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, pm->pcihp_io_base, pm->pcihp_io_base, 1,\n\n                   pm->pcihp_io_len)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n        aml_append(scope, dev);\n\n    }\n\n    aml_append(dsdt, scope);\n\n\n\n    /*  create S3_ / S4_ / S5_ packages if necessary */\n\n    scope = aml_scope(\"\\\\\");\n\n    if (!pm->s3_disabled) {\n\n        pkg = aml_package(4);\n\n        aml_append(pkg, aml_int(1)); /* PM1a_CNT.SLP_TYP */\n\n        aml_append(pkg, aml_int(1)); /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(scope, aml_name_decl(\"_S3\", pkg));\n\n    }\n\n\n\n    if (!pm->s4_disabled) {\n\n        pkg = aml_package(4);\n\n        aml_append(pkg, aml_int(pm->s4_val)); /* PM1a_CNT.SLP_TYP */\n\n        /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n\n        aml_append(pkg, aml_int(pm->s4_val));\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(scope, aml_name_decl(\"_S4\", pkg));\n\n    }\n\n\n\n    pkg = aml_package(4);\n\n    aml_append(pkg, aml_int(0)); /* PM1a_CNT.SLP_TYP */\n\n    aml_append(pkg, aml_int(0)); /* PM1b_CNT.SLP_TYP not impl. */\n\n    aml_append(pkg, aml_int(0)); /* reserved */\n\n    aml_append(pkg, aml_int(0)); /* reserved */\n\n    aml_append(scope, aml_name_decl(\"_S5\", pkg));\n\n    aml_append(dsdt, scope);\n\n\n\n    if (misc->applesmc_io_base) {\n\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n\n        dev = aml_device(\"SMC\");\n\n\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"APP0001\")));\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, misc->applesmc_io_base, misc->applesmc_io_base,\n\n                   0x01, APPLESMC_MAX_DATA_LENGTH)\n\n        );\n\n        aml_append(crs, aml_irq_no_flags(6));\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    if (misc->pvpanic_port) {\n\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n\n\n\n        dev = aml_device(\"PEVT\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0001\")));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, misc->pvpanic_port, misc->pvpanic_port, 1, 1)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(dev, aml_operation_region(\"PEOR\", AML_SYSTEM_IO,\n\n                                              misc->pvpanic_port, 1));\n\n        field = aml_field(\"PEOR\", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);\n\n        aml_append(field, aml_named_field(\"PEPT\", 8));\n\n        aml_append(dev, field);\n\n\n\n        /* device present, functioning, decoding, shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n\n\n        method = aml_method(\"RDPT\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_store(aml_name(\"PEPT\"), aml_local(0)));\n\n        aml_append(method, aml_return(aml_local(0)));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"WRPT\", 1, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_store(aml_arg(0), aml_name(\"PEPT\")));\n\n        aml_append(dev, method);\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    sb_scope = aml_scope(\"\\\\_SB\");\n\n    {\n\n        build_processor_devices(sb_scope, pcms->apic_id_limit, cpu, pm);\n\n\n\n        build_memory_devices(sb_scope, nr_mem, pm->mem_hp_io_base,\n\n                             pm->mem_hp_io_len);\n\n\n\n        {\n\n            Object *pci_host;\n\n            PCIBus *bus = NULL;\n\n\n\n            pci_host = acpi_get_i386_pci_host();\n\n            if (pci_host) {\n\n                bus = PCI_HOST_BRIDGE(pci_host)->bus;\n\n            }\n\n\n\n            if (bus) {\n\n                Aml *scope = aml_scope(\"PCI0\");\n\n                /* Scan all PCI buses. Generate tables to support hotplug. */\n\n                build_append_pci_bus_devices(scope, bus, pm->pcihp_bridge_en);\n\n\n\n                if (misc->tpm_version != TPM_VERSION_UNSPEC) {\n\n                    dev = aml_device(\"ISA.TPM\");\n\n                    aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0C31\")));\n\n                    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n                    crs = aml_resource_template();\n\n                    aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,\n\n                               TPM_TIS_ADDR_SIZE, AML_READ_WRITE));\n\n                    aml_append(crs, aml_irq_no_flags(TPM_TIS_IRQ));\n\n                    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n                    aml_append(scope, dev);\n\n                }\n\n\n\n                aml_append(sb_scope, scope);\n\n            }\n\n        }\n\n        aml_append(dsdt, sb_scope);\n\n    }\n\n\n\n    /* copy AML table into ACPI tables blob and patch header there */\n\n    g_array_append_vals(table_data, dsdt->buf->data, dsdt->buf->len);\n\n    build_header(linker, table_data,\n\n        (void *)(table_data->data + table_data->len - dsdt->buf->len),\n\n        \"DSDT\", dsdt->buf->len, 1, NULL);\n\n    free_aml_allocator();\n\n}\n", "idx": 21345, "_split": "valid", "_hash": "ffce49035ce5a52de6e38f141cca8eaf"}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "INLINE bits64 extractFloat64Frac( float64 a )\n\n{\n\n\n\n    return a & LIT64( 0x000FFFFFFFFFFFFF );\n\n\n\n}\n", "idx": 21369, "_split": "valid", "_hash": "5b38eaeb3784c6ed38b6c66b94831e2e"}
{"project": "qemu", "commit_id": "c9087c2a6068b23207517f7d7ff796e68290358b", "target": 1, "func": "setup_sigcontext(struct target_sigcontext *sc, struct target_fpstate *fpstate,\n\n\t\t CPUX86State *env, unsigned long mask)\n\n{\n\n\tint err = 0;\n\n\n\n\terr |= __put_user(env->segs[R_GS], (unsigned int *)&sc->gs);\n\n\terr |= __put_user(env->segs[R_FS], (unsigned int *)&sc->fs);\n\n\terr |= __put_user(env->segs[R_ES], (unsigned int *)&sc->es);\n\n\terr |= __put_user(env->segs[R_DS], (unsigned int *)&sc->ds);\n\n\terr |= __put_user(env->regs[R_EDI], &sc->edi);\n\n\terr |= __put_user(env->regs[R_ESI], &sc->esi);\n\n\terr |= __put_user(env->regs[R_EBP], &sc->ebp);\n\n\terr |= __put_user(env->regs[R_ESP], &sc->esp);\n\n\terr |= __put_user(env->regs[R_EBX], &sc->ebx);\n\n\terr |= __put_user(env->regs[R_EDX], &sc->edx);\n\n\terr |= __put_user(env->regs[R_ECX], &sc->ecx);\n\n\terr |= __put_user(env->regs[R_EAX], &sc->eax);\n\n\terr |= __put_user(env->exception_index, &sc->trapno);\n\n\terr |= __put_user(env->error_code, &sc->err);\n\n\terr |= __put_user(env->eip, &sc->eip);\n\n\terr |= __put_user(env->segs[R_CS], (unsigned int *)&sc->cs);\n\n\terr |= __put_user(env->eflags, &sc->eflags);\n\n\terr |= __put_user(env->regs[R_ESP], &sc->esp_at_signal);\n\n\terr |= __put_user(env->segs[R_SS], (unsigned int *)&sc->ss);\n\n#if 0\n\n\ttmp = save_i387(fpstate);\n\n\tif (tmp < 0)\n\n\t  err = 1;\n\n\telse\n\n\t  err |= __put_user(tmp ? fpstate : NULL, &sc->fpstate);\n\n#else\n\n        err |= __put_user(0, &sc->fpstate);\n\n#endif\n\n\t/* non-iBCS2 extensions.. */\n\n\terr |= __put_user(mask, &sc->oldmask);\n\n\terr |= __put_user(/*current->thread.cr2*/ 0, &sc->cr2);\n\n\treturn err;\n\n}\n", "idx": 21372, "_split": "valid", "_hash": "7c0fd6a5df2eebbf7dfa26758a83f4b7"}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void esp_command_complete(SCSIBus *bus, int reason, uint32_t tag,\n\n                                 uint32_t arg)\n\n{\n\n    ESPState *s = DO_UPCAST(ESPState, busdev.qdev, bus->qbus.parent);\n\n\n\n    if (reason == SCSI_REASON_DONE) {\n\n        DPRINTF(\"SCSI Command complete\\n\");\n\n        if (s->ti_size != 0)\n\n            DPRINTF(\"SCSI command completed unexpectedly\\n\");\n\n        s->ti_size = 0;\n\n        s->dma_left = 0;\n\n        s->async_len = 0;\n\n        if (arg)\n\n            DPRINTF(\"Command failed\\n\");\n\n        s->sense = arg;\n\n        s->rregs[ESP_RSTAT] = STAT_ST;\n\n        esp_dma_done(s);\n\n        s->current_dev = NULL;\n\n    } else {\n\n        DPRINTF(\"transfer %d/%d\\n\", s->dma_left, s->ti_size);\n\n        s->async_len = arg;\n\n        s->async_buf = s->current_dev->info->get_buf(s->current_dev, 0);\n\n        if (s->dma_left) {\n\n            esp_do_dma(s);\n\n        } else if (s->dma_counter != 0 && s->ti_size <= 0) {\n\n            /* If this was the last part of a DMA transfer then the\n\n               completion interrupt is deferred to here.  */\n\n            esp_dma_done(s);\n\n        }\n\n    }\n\n}\n", "idx": 21389, "_split": "valid", "_hash": "68deec57594bccde4458174cd0616613"}
{"project": "qemu", "commit_id": "6c2d1c32d084320081b0cd047f8cacd6e722d03a", "target": 1, "func": "static void ehci_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    EHCIPCIInfo *i = data;\n\n\n\n    k->init = usb_ehci_pci_initfn;\n\n    k->vendor_id = i->vendor_id;\n\n    k->device_id = i->device_id;\n\n    k->revision = i->revision;\n\n    k->class_id = PCI_CLASS_SERIAL_USB;\n\n    k->config_write = usb_ehci_pci_write_config;\n\n\n    dc->vmsd = &vmstate_ehci_pci;\n\n    dc->props = ehci_pci_properties;\n\n}", "idx": 21407, "_split": "valid", "_hash": "7a91ed3d3ba381fcc4358a36537e7ab7"}
{"project": "qemu", "commit_id": "99a9ef44dca4be93f60c38d83a79eaaf8c56548a", "target": 0, "func": "static void curses_refresh(DisplayChangeListener *dcl)\n\n{\n\n    int chr, nextchr, keysym, keycode, keycode_alt;\n\n\n\n    curses_winch_check();\n\n\n\n    if (invalidate) {\n\n        clear();\n\n        refresh();\n\n        curses_calc_pad();\n\n        graphic_hw_invalidate(NULL);\n\n        invalidate = 0;\n\n    }\n\n\n\n    graphic_hw_text_update(NULL, screen);\n\n\n\n    nextchr = ERR;\n\n    while (1) {\n\n        /* while there are any pending key strokes to process */\n\n        if (nextchr == ERR)\n\n            chr = getch();\n\n        else {\n\n            chr = nextchr;\n\n            nextchr = ERR;\n\n        }\n\n\n\n        if (chr == ERR)\n\n            break;\n\n\n\n#ifdef KEY_RESIZE\n\n        /* this shouldn't occur when we use a custom SIGWINCH handler */\n\n        if (chr == KEY_RESIZE) {\n\n            clear();\n\n            refresh();\n\n            curses_calc_pad();\n\n            curses_update(dcl, 0, 0, width, height);\n\n            continue;\n\n        }\n\n#endif\n\n\n\n        keycode = curses2keycode[chr];\n\n        keycode_alt = 0;\n\n\n\n        /* alt key */\n\n        if (keycode == 1) {\n\n            nextchr = getch();\n\n\n\n            if (nextchr != ERR) {\n\n                chr = nextchr;\n\n                keycode_alt = ALT;\n\n                keycode = curses2keycode[nextchr];\n\n                nextchr = ERR;\n\n\n\n                if (keycode != -1) {\n\n                    keycode |= ALT;\n\n\n\n                    /* process keys reserved for qemu */\n\n                    if (keycode >= QEMU_KEY_CONSOLE0 &&\n\n                            keycode < QEMU_KEY_CONSOLE0 + 9) {\n\n                        erase();\n\n                        wnoutrefresh(stdscr);\n\n                        console_select(keycode - QEMU_KEY_CONSOLE0);\n\n\n\n                        invalidate = 1;\n\n                        continue;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        if (kbd_layout) {\n\n            keysym = -1;\n\n            if (chr < CURSES_KEYS)\n\n                keysym = curses2keysym[chr];\n\n\n\n            if (keysym == -1) {\n\n                if (chr < ' ') {\n\n                    keysym = chr + '@';\n\n                    if (keysym >= 'A' && keysym <= 'Z')\n\n                        keysym += 'a' - 'A';\n\n                    keysym |= KEYSYM_CNTRL;\n\n                } else\n\n                    keysym = chr;\n\n            }\n\n\n\n            keycode = keysym2scancode(kbd_layout, keysym & KEYSYM_MASK);\n\n            if (keycode == 0)\n\n                continue;\n\n\n\n            keycode |= (keysym & ~KEYSYM_MASK) >> 16;\n\n            keycode |= keycode_alt;\n\n        }\n\n\n\n        if (keycode == -1)\n\n            continue;\n\n\n\n        if (qemu_console_is_graphic(NULL)) {\n\n            /* since terminals don't know about key press and release\n\n             * events, we need to emit both for each key received */\n\n            if (keycode & SHIFT) {\n\n                qemu_input_event_send_key_number(NULL, SHIFT_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & CNTRL) {\n\n                qemu_input_event_send_key_number(NULL, CNTRL_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALT) {\n\n                qemu_input_event_send_key_number(NULL, ALT_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALTGR) {\n\n                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n\n\n            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, true);\n\n            qemu_input_event_send_key_delay(0);\n\n            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, false);\n\n            qemu_input_event_send_key_delay(0);\n\n\n\n            if (keycode & ALTGR) {\n\n                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALT) {\n\n                qemu_input_event_send_key_number(NULL, ALT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & CNTRL) {\n\n                qemu_input_event_send_key_number(NULL, CNTRL_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & SHIFT) {\n\n                qemu_input_event_send_key_number(NULL, SHIFT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n        } else {\n\n            keysym = -1;\n\n            if (chr < CURSES_KEYS) {\n\n                keysym = curses2qemu[chr];\n\n            }\n\n            if (keysym == -1)\n\n                keysym = chr;\n\n\n\n            kbd_put_keysym(keysym);\n\n        }\n\n    }\n\n}\n", "idx": 21417, "_split": "valid", "_hash": "4102bd3cfe7e1d713ce57cadd587afe5"}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static ssize_t proxy_lgetxattr(FsContext *ctx, V9fsPath *fs_path,\n\n                               const char *name, void *value, size_t size)\n\n{\n\n    int retval;\n\n    V9fsString xname;\n\n\n\n    v9fs_string_init(&xname);\n\n    v9fs_string_sprintf(&xname, \"%s\", name);\n\n    retval = v9fs_request(ctx->private, T_LGETXATTR, value, \"dss\", size,\n\n                          fs_path, &xname);\n\n    v9fs_string_free(&xname);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n    }\n\n    return retval;\n\n}\n", "idx": 21434, "_split": "valid", "_hash": "3d3b0047979609a269a02120ebb39660"}
{"project": "qemu", "commit_id": "a7ffaf5c96e26820edffa94eeac766fe60bfdd31", "target": 0, "func": "static void cadence_timer_sync(CadenceTimerState *s)\n\n{\n\n    int i;\n\n    int64_t r, x;\n\n    int64_t interval = ((s->reg_count & COUNTER_CTRL_INT) ?\n\n            (int64_t)s->reg_interval + 1 : 0x10000ULL) << 16;\n\n    uint64_t old_time = s->cpu_time;\n\n\n\n    s->cpu_time = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n    DB_PRINT(\"cpu time: %lld ns\\n\", (long long)old_time);\n\n\n\n    if (!s->cpu_time_valid || old_time == s->cpu_time) {\n\n        s->cpu_time_valid = 1;\n\n        return;\n\n    }\n\n\n\n    r = (int64_t)cadence_timer_get_steps(s, s->cpu_time - old_time);\n\n    x = (int64_t)s->reg_value + ((s->reg_count & COUNTER_CTRL_DEC) ? -r : r);\n\n\n\n    for (i = 0; i < 3; ++i) {\n\n        int64_t m = (int64_t)s->reg_match[i] << 16;\n\n        if (m > interval) {\n\n            continue;\n\n        }\n\n        /* check to see if match event has occurred. check m +/- interval\n\n         * to account for match events in wrap around cases */\n\n        if (is_between(m, s->reg_value, x) ||\n\n            is_between(m + interval, s->reg_value, x) ||\n\n            is_between(m - interval, s->reg_value, x)) {\n\n            s->reg_intr |= (2 << i);\n\n        }\n\n    }\n\n    while (x < 0) {\n\n        x += interval;\n\n    }\n\n    s->reg_value = (uint32_t)(x % interval);\n\n\n\n    if (s->reg_value != x) {\n\n        s->reg_intr |= (s->reg_count & COUNTER_CTRL_INT) ?\n\n            COUNTER_INTR_IV : COUNTER_INTR_OV;\n\n    }\n\n    cadence_timer_update(s);\n\n}\n", "idx": 21436, "_split": "valid", "_hash": "5368eb25525cd7f122caad14d410e0d8"}
{"project": "qemu", "commit_id": "bec1631100323fac0900aea71043d5c4e22fc2fa", "target": 0, "func": "static void tcg_out_brcond_i64(TCGContext *s, TCGCond cond, TCGReg arg1,\n\n                               int32_t arg2, int const_arg2, int label)\n\n{\n\n    /* For 64-bit signed comparisons vs zero, we can avoid the compare.  */\n\n    if (arg2 == 0 && !is_unsigned_cond(cond)) {\n\n        TCGLabel *l = &s->labels[label];\n\n        int off16;\n\n\n\n        if (l->has_value) {\n\n            off16 = INSN_OFF16(tcg_pcrel_diff(s, l->u.value_ptr));\n\n        } else {\n\n            /* Make sure to preserve destinations during retranslation.  */\n\n            off16 = *s->code_ptr & INSN_OFF16(-1);\n\n            tcg_out_reloc(s, s->code_ptr, R_SPARC_WDISP16, label, 0);\n\n        }\n\n        tcg_out32(s, INSN_OP(0) | INSN_OP2(3) | BPR_PT | INSN_RS1(arg1)\n\n                  | INSN_COND(tcg_cond_to_rcond[cond]) | off16);\n\n    } else {\n\n        tcg_out_cmp(s, arg1, arg2, const_arg2);\n\n        tcg_out_bpcc(s, tcg_cond_to_bcond[cond], BPCC_XCC | BPCC_PT, label);\n\n    }\n\n    tcg_out_nop(s);\n\n}\n", "idx": 21440, "_split": "valid", "_hash": "50dd1297f37a141f88a33bb8503be136"}
{"project": "qemu", "commit_id": "95be1196030c003a65052fc7b8a3394fdac690a8", "target": 0, "func": "int pci_bridge_initfn(PCIDevice *dev)\n\n{\n\n    PCIBus *parent = dev->bus;\n\n    PCIBridge *br = DO_UPCAST(PCIBridge, dev, dev);\n\n    PCIBus *sec_bus = &br->sec_bus;\n\n\n\n    pci_set_word(dev->config + PCI_STATUS,\n\n                 PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);\n\n    pci_config_set_class(dev->config, PCI_CLASS_BRIDGE_PCI);\n\n    dev->config[PCI_HEADER_TYPE] =\n\n        (dev->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |\n\n        PCI_HEADER_TYPE_BRIDGE;\n\n    pci_set_word(dev->config + PCI_SEC_STATUS,\n\n                 PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);\n\n\n\n    qbus_create_inplace(&sec_bus->qbus, &pci_bus_info, &dev->qdev,\n\n                        br->bus_name);\n\n    sec_bus->parent_dev = dev;\n\n    sec_bus->map_irq = br->map_irq;\n\n    sec_bus->address_space_mem = &br->address_space_mem;\n\n    memory_region_init(&br->address_space_mem, \"pci_bridge_pci\", INT64_MAX);\n\n    sec_bus->address_space_io = &br->address_space_io;\n\n    memory_region_init(&br->address_space_io, \"pci_bridge_io\", 65536);\n\n    pci_bridge_region_init(br);\n\n    QLIST_INIT(&sec_bus->child);\n\n    QLIST_INSERT_HEAD(&parent->child, sec_bus, sibling);\n\n    return 0;\n\n}\n", "idx": 21453, "_split": "valid", "_hash": "4c5bc315a535b1aea51a75b676134816"}
{"project": "qemu", "commit_id": "4f298a4b2957b7833bc607c951ca27c458d98d88", "target": 1, "func": "static void clear_sdr_rep(IPMIBmcSim *ibs,\n\n                          uint8_t *cmd, unsigned int cmd_len,\n\n                          uint8_t *rsp, unsigned int *rsp_len,\n\n                          unsigned int max_rsp_len)\n\n{\n\n    IPMI_CHECK_CMD_LEN(8);\n\n    IPMI_CHECK_RESERVATION(2, ibs->sdr.reservation);\n\n    if (cmd[4] != 'C' || cmd[5] != 'L' || cmd[6] != 'R') {\n\n        rsp[2] = IPMI_CC_INVALID_DATA_FIELD;\n\n        return;\n\n    }\n\n    if (cmd[7] == 0xaa) {\n\n        ibs->sdr.next_free = 0;\n\n        ibs->sdr.overflow = 0;\n\n        set_timestamp(ibs, ibs->sdr.last_clear);\n\n        IPMI_ADD_RSP_DATA(1); /* Erasure complete */\n\n        sdr_inc_reservation(&ibs->sdr);\n\n    } else if (cmd[7] == 0) {\n\n        IPMI_ADD_RSP_DATA(1); /* Erasure complete */\n\n    } else {\n\n        rsp[2] = IPMI_CC_INVALID_DATA_FIELD;\n\n        return;\n\n    }\n\n}\n", "idx": 21468, "_split": "valid", "_hash": "229d4aebd2aed6275abb047c5031fb3a"}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static CharDriverState *qmp_chardev_open_file(const char *id,\n\n                                              ChardevBackend *backend,\n\n                                              ChardevReturn *ret,\n\n                                              Error **errp)\n\n{\n\n    ChardevFile *file = backend->u.file;\n\n    ChardevCommon *common = qapi_ChardevFile_base(file);\n\n    HANDLE out;\n\n\n\n    if (file->has_in) {\n\n        error_setg(errp, \"input file not supported\");\n\n        return NULL;\n\n    }\n\n\n\n    out = CreateFile(file->out, GENERIC_WRITE, FILE_SHARE_READ, NULL,\n\n                     OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n\n    if (out == INVALID_HANDLE_VALUE) {\n\n        error_setg(errp, \"open %s failed\", file->out);\n\n        return NULL;\n\n    }\n\n    return qemu_chr_open_win_file(out, common, errp);\n\n}\n", "idx": 21483, "_split": "valid", "_hash": "aec459fe6d05c712c1347957fc508147"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_debug_event(BlockDriverState *bs, BlkDebugEvent event)\n\n{\n\n    if (!bs || !bs->drv || !bs->drv->bdrv_debug_event) {\n\n        return;\n\n    }\n\n\n\n    bs->drv->bdrv_debug_event(bs, event);\n\n}\n", "idx": 21531, "_split": "valid", "_hash": "de628b2e2d3aceb9ab3cc6d2fc5779ad"}
{"project": "qemu", "commit_id": "16a9e8a5bcc1fb0796828eb654a4f926734e59af", "target": 0, "func": "static bool pc_machine_get_aligned_dimm(Object *obj, Error **errp)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(obj);\n\n\n\n    return pcms->enforce_aligned_dimm;\n\n}\n", "idx": 21555, "_split": "valid", "_hash": "b6a3b7a5f470d252ec53aa0ea9de9c05"}
{"project": "qemu", "commit_id": "b192af8acc597a6e8068873434e56e0c7de1b7d3", "target": 0, "func": "static int refresh_total_sectors(BlockDriverState *bs, int64_t hint)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    /* Do not attempt drv->bdrv_getlength() on scsi-generic devices */\n\n    if (bs->sg)\n\n        return 0;\n\n\n\n    /* query actual device if possible, otherwise just trust the hint */\n\n    if (drv->bdrv_getlength) {\n\n        int64_t length = drv->bdrv_getlength(bs);\n\n        if (length < 0) {\n\n            return length;\n\n        }\n\n        hint = DIV_ROUND_UP(length, BDRV_SECTOR_SIZE);\n\n    }\n\n\n\n    bs->total_sectors = hint;\n\n    return 0;\n\n}\n", "idx": 21561, "_split": "valid", "_hash": "9222571ec9fdc174d46fa240cb61e3a0"}
{"project": "qemu", "commit_id": "13344f3a17e0a785c0eb8e36f69518f21aa8a91a", "target": 1, "func": "BlockStatsList *qmp_query_blockstats(Error **errp)\n{\n    BlockStatsList *head = NULL, **p_next = &head;\n    BlockDriverState *bs = NULL;\n     while ((bs = bdrv_next(bs))) {\n        BlockStatsList *info = g_malloc0(sizeof(*info));\n        info->value = bdrv_query_stats(bs);\n        *p_next = info;\n        p_next = &info->next;\n    }\n    return head;\n}", "idx": 21564, "_split": "valid", "_hash": "3901301364261dd4faf3b19ca748d13e"}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void gen_spr_74xx (CPUPPCState *env)\n\n{\n\n    /* Processor identification */\n\n    spr_register(env, SPR_PIR, \"PIR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_pir,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_MMCR2, \"MMCR2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_UMMCR2, \"UMMCR2\",\n\n                 &spr_read_ureg, SPR_NOACCESS,\n\n                 &spr_read_ureg, SPR_NOACCESS,\n\n                 0x00000000);\n\n    /* XXX: not implemented */\n\n    spr_register(env, SPR_BAMR, \"BAMR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_MSSCR0, \"MSSCR0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Altivec */\n\n    spr_register(env, SPR_VRSAVE, \"VRSAVE\",\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_L2CR, \"L2CR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, NULL,\n\n                 0x00000000);\n\n    /* Not strictly an SPR */\n\n    vscr_init(env, 0x00010000);\n\n}\n", "idx": 21587, "_split": "valid", "_hash": "36330577e3af5d4bed3977b0c953db8d"}
{"project": "qemu", "commit_id": "6c5b5645ae0b73c052df962e18e48d87bb7385e0", "target": 0, "func": "static abi_long do_sendrecvmsg_locked(int fd, struct target_msghdr *msgp,\n\n                                      int flags, int send)\n\n{\n\n    abi_long ret, len;\n\n    struct msghdr msg;\n\n    int count;\n\n    struct iovec *vec;\n\n    abi_ulong target_vec;\n\n\n\n    if (msgp->msg_name) {\n\n        msg.msg_namelen = tswap32(msgp->msg_namelen);\n\n        msg.msg_name = alloca(msg.msg_namelen+1);\n\n        ret = target_to_host_sockaddr(fd, msg.msg_name,\n\n                                      tswapal(msgp->msg_name),\n\n                                      msg.msg_namelen);\n\n        if (ret) {\n\n            goto out2;\n\n        }\n\n    } else {\n\n        msg.msg_name = NULL;\n\n        msg.msg_namelen = 0;\n\n    }\n\n    msg.msg_controllen = 2 * tswapal(msgp->msg_controllen);\n\n    msg.msg_control = alloca(msg.msg_controllen);\n\n    msg.msg_flags = tswap32(msgp->msg_flags);\n\n\n\n    count = tswapal(msgp->msg_iovlen);\n\n    target_vec = tswapal(msgp->msg_iov);\n\n    vec = lock_iovec(send ? VERIFY_READ : VERIFY_WRITE,\n\n                     target_vec, count, send);\n\n    if (vec == NULL) {\n\n        ret = -host_to_target_errno(errno);\n\n        goto out2;\n\n    }\n\n    msg.msg_iovlen = count;\n\n    msg.msg_iov = vec;\n\n\n\n    if (send) {\n\n        ret = target_to_host_cmsg(&msg, msgp);\n\n        if (ret == 0)\n\n            ret = get_errno(sendmsg(fd, &msg, flags));\n\n    } else {\n\n        ret = get_errno(recvmsg(fd, &msg, flags));\n\n        if (!is_error(ret)) {\n\n            len = ret;\n\n            ret = host_to_target_cmsg(msgp, &msg);\n\n            if (!is_error(ret)) {\n\n                msgp->msg_namelen = tswap32(msg.msg_namelen);\n\n                if (msg.msg_name != NULL) {\n\n                    ret = host_to_target_sockaddr(tswapal(msgp->msg_name),\n\n                                    msg.msg_name, msg.msg_namelen);\n\n                    if (ret) {\n\n                        goto out;\n\n                    }\n\n                }\n\n\n\n                ret = len;\n\n            }\n\n        }\n\n    }\n\n\n\nout:\n\n    unlock_iovec(vec, target_vec, count, !send);\n\nout2:\n\n    return ret;\n\n}\n", "idx": 21619, "_split": "valid", "_hash": "78ec0b4d27554f30bbbfe6eecd87e7a8"}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void omap_clkm_write(void *opaque, hwaddr addr,\n\n                            uint64_t value, unsigned size)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque;\n\n    uint16_t diff;\n\n    omap_clk clk;\n\n    static const char *clkschemename[8] = {\n\n        \"fully synchronous\", \"fully asynchronous\", \"synchronous scalable\",\n\n        \"mix mode 1\", \"mix mode 2\", \"bypass mode\", \"mix mode 3\", \"mix mode 4\",\n\n    };\n\n\n\n    if (size != 2) {\n\n        omap_badwidth_write16(opaque, addr, value);\n\n        return;\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x00:\t/* ARM_CKCTL */\n\n        diff = s->clkm.arm_ckctl ^ value;\n\n        s->clkm.arm_ckctl = value & 0x7fff;\n\n        omap_clkm_ckctl_update(s, diff, value);\n\n        return;\n\n\n\n    case 0x04:\t/* ARM_IDLECT1 */\n\n        diff = s->clkm.arm_idlect1 ^ value;\n\n        s->clkm.arm_idlect1 = value & 0x0fff;\n\n        omap_clkm_idlect1_update(s, diff, value);\n\n        return;\n\n\n\n    case 0x08:\t/* ARM_IDLECT2 */\n\n        diff = s->clkm.arm_idlect2 ^ value;\n\n        s->clkm.arm_idlect2 = value & 0x07ff;\n\n        omap_clkm_idlect2_update(s, diff, value);\n\n        return;\n\n\n\n    case 0x0c:\t/* ARM_EWUPCT */\n\n        s->clkm.arm_ewupct = value & 0x003f;\n\n        return;\n\n\n\n    case 0x10:\t/* ARM_RSTCT1 */\n\n        diff = s->clkm.arm_rstct1 ^ value;\n\n        s->clkm.arm_rstct1 = value & 0x0007;\n\n        if (value & 9) {\n\n            qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);\n\n            s->clkm.cold_start = 0xa;\n\n        }\n\n        if (diff & ~value & 4) {\t\t\t\t/* DSP_RST */\n\n            omap_mpui_reset(s);\n\n            omap_tipb_bridge_reset(s->private_tipb);\n\n            omap_tipb_bridge_reset(s->public_tipb);\n\n        }\n\n        if (diff & 2) {\t\t\t\t\t\t/* DSP_EN */\n\n            clk = omap_findclk(s, \"dsp_ck\");\n\n            omap_clk_canidle(clk, (~value >> 1) & 1);\n\n        }\n\n        return;\n\n\n\n    case 0x14:\t/* ARM_RSTCT2 */\n\n        s->clkm.arm_rstct2 = value & 0x0001;\n\n        return;\n\n\n\n    case 0x18:\t/* ARM_SYSST */\n\n        if ((s->clkm.clocking_scheme ^ (value >> 11)) & 7) {\n\n            s->clkm.clocking_scheme = (value >> 11) & 7;\n\n            printf(\"%s: clocking scheme set to %s\\n\", __FUNCTION__,\n\n                            clkschemename[s->clkm.clocking_scheme]);\n\n        }\n\n        s->clkm.cold_start &= value & 0x3f;\n\n        return;\n\n\n\n    case 0x1c:\t/* ARM_CKOUT1 */\n\n        diff = s->clkm.arm_ckout1 ^ value;\n\n        s->clkm.arm_ckout1 = value & 0x003f;\n\n        omap_clkm_ckout1_update(s, diff, value);\n\n        return;\n\n\n\n    case 0x20:\t/* ARM_CKOUT2 */\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n    }\n\n}\n", "idx": 21621, "_split": "valid", "_hash": "af06c5b66a23f1159b795d305bd0cce3"}
{"project": "qemu", "commit_id": "903585dec63ee83bd8149006e31f92ea789b38e3", "target": 0, "func": "static void ppce500_reset_device_tree(void *opaque)\n\n{\n\n    DeviceTreeParams *p = opaque;\n\n    ppce500_load_device_tree(p->machine, &p->params, p->addr, p->initrd_base,\n\n                             p->initrd_size, false);\n\n}\n", "idx": 21627, "_split": "valid", "_hash": "4c3eeadf2333415d7b2371a4e9c4fa56"}
{"project": "qemu", "commit_id": "1bd075f29ea6d11853475c7c42734595720c3ac6", "target": 1, "func": "iscsi_aio_write16_cb(struct iscsi_context *iscsi, int status,\n\n                     void *command_data, void *opaque)\n\n{\n\n    IscsiAIOCB *acb = opaque;\n\n\n\n    trace_iscsi_aio_write16_cb(iscsi, status, acb, acb->canceled);\n\n\n\n    g_free(acb->buf);\n\n\n\n    if (acb->canceled != 0) {\n\n        qemu_aio_release(acb);\n\n        scsi_free_scsi_task(acb->task);\n\n        acb->task = NULL;\n\n        return;\n\n    }\n\n\n\n    acb->status = 0;\n\n    if (status < 0) {\n\n        error_report(\"Failed to write16 data to iSCSI lun. %s\",\n\n                     iscsi_get_error(iscsi));\n\n        acb->status = -EIO;\n\n    }\n\n\n\n    iscsi_schedule_bh(acb);\n\n    scsi_free_scsi_task(acb->task);\n\n    acb->task = NULL;\n\n}\n", "idx": 21633, "_split": "valid", "_hash": "7c2b704b2dc384f7f00952b1bde8ba13"}
{"project": "qemu", "commit_id": "7ea2d269cb84ca7a2f4b7c3735634176f7c1dc35", "target": 1, "func": "NBDExport *nbd_export_new(BlockDriverState *bs, off_t dev_offset,\n\n                          off_t size, uint32_t nbdflags,\n\n                          void (*close)(NBDExport *))\n\n{\n\n    NBDExport *exp = g_malloc0(sizeof(NBDExport));\n\n    exp->refcount = 1;\n\n    QTAILQ_INIT(&exp->clients);\n\n    exp->bs = bs;\n\n    exp->dev_offset = dev_offset;\n\n    exp->nbdflags = nbdflags;\n\n    exp->size = size == -1 ? bdrv_getlength(bs) : size;\n\n    exp->close = close;\n\n    exp->ctx = bdrv_get_aio_context(bs);\n\n    bdrv_ref(bs);\n\n    bdrv_add_aio_context_notifier(bs, bs_aio_attached, bs_aio_detach, exp);\n\n\n\n\n\n\n\n    return exp;\n\n}", "idx": 21691, "_split": "valid", "_hash": "dd1ed42d1ea5c3663ac30958bb7845e6"}
{"project": "qemu", "commit_id": "aedbe19297907143f17b733a7ff0e0534377bed1", "target": 1, "func": "static int qemu_reset_requested(void)\n\n{\n\n    int r = reset_requested;\n\n    if (r && replay_checkpoint(CHECKPOINT_RESET_REQUESTED)) {\n\n        reset_requested = 0;\n\n        return r;\n\n    }\n\n    return false;\n\n}\n", "idx": 21704, "_split": "valid", "_hash": "f2f7b6aceb7102b3149d87fff0877591"}
{"project": "qemu", "commit_id": "c89e91a76b361feaa09a48c20e6d18ae92ad0b4a", "target": 0, "func": "static int add_calxeda_midway_xgmac_fdt_node(SysBusDevice *sbdev, void *opaque)\n\n{\n\n    PlatformBusFDTData *data = opaque;\n\n    PlatformBusDevice *pbus = data->pbus;\n\n    void *fdt = data->fdt;\n\n    const char *parent_node = data->pbus_node_name;\n\n    int compat_str_len, i, ret = -1;\n\n    char *nodename;\n\n    uint32_t *irq_attr, *reg_attr;\n\n    uint64_t mmio_base, irq_number;\n\n    VFIOPlatformDevice *vdev = VFIO_PLATFORM_DEVICE(sbdev);\n\n    VFIODevice *vbasedev = &vdev->vbasedev;\n\n\n\n    mmio_base = platform_bus_get_mmio_addr(pbus, sbdev, 0);\n\n    nodename = g_strdup_printf(\"%s/%s@%\" PRIx64, parent_node,\n\n                               vbasedev->name, mmio_base);\n\n    qemu_fdt_add_subnode(fdt, nodename);\n\n\n\n    compat_str_len = strlen(vdev->compat) + 1;\n\n    qemu_fdt_setprop(fdt, nodename, \"compatible\",\n\n                          vdev->compat, compat_str_len);\n\n\n\n    qemu_fdt_setprop(fdt, nodename, \"dma-coherent\", \"\", 0);\n\n\n\n    reg_attr = g_new(uint32_t, vbasedev->num_regions * 2);\n\n    for (i = 0; i < vbasedev->num_regions; i++) {\n\n        mmio_base = platform_bus_get_mmio_addr(pbus, sbdev, i);\n\n        reg_attr[2 * i] = cpu_to_be32(mmio_base);\n\n        reg_attr[2 * i + 1] = cpu_to_be32(\n\n                                memory_region_size(&vdev->regions[i]->mem));\n\n    }\n\n    ret = qemu_fdt_setprop(fdt, nodename, \"reg\", reg_attr,\n\n                           vbasedev->num_regions * 2 * sizeof(uint32_t));\n\n    if (ret) {\n\n        error_report(\"could not set reg property of node %s\", nodename);\n\n        goto fail_reg;\n\n    }\n\n\n\n    irq_attr = g_new(uint32_t, vbasedev->num_irqs * 3);\n\n    for (i = 0; i < vbasedev->num_irqs; i++) {\n\n        irq_number = platform_bus_get_irqn(pbus, sbdev , i)\n\n                         + data->irq_start;\n\n        irq_attr[3 * i] = cpu_to_be32(GIC_FDT_IRQ_TYPE_SPI);\n\n        irq_attr[3 * i + 1] = cpu_to_be32(irq_number);\n\n        irq_attr[3 * i + 2] = cpu_to_be32(GIC_FDT_IRQ_FLAGS_LEVEL_HI);\n\n    }\n\n    ret = qemu_fdt_setprop(fdt, nodename, \"interrupts\",\n\n                     irq_attr, vbasedev->num_irqs * 3 * sizeof(uint32_t));\n\n    if (ret) {\n\n        error_report(\"could not set interrupts property of node %s\",\n\n                     nodename);\n\n    }\n\n    g_free(irq_attr);\n\nfail_reg:\n\n    g_free(reg_attr);\n\n    g_free(nodename);\n\n    return ret;\n\n}\n", "idx": 21726, "_split": "valid", "_hash": "23a54253129f82ac1b5cf5ff0fb014c3"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_pwt_s *omap_pwt_init(MemoryRegion *system_memory,\n\n                                        target_phys_addr_t base,\n\n                                        omap_clk clk)\n\n{\n\n    struct omap_pwt_s *s = g_malloc0(sizeof(*s));\n\n    s->clk = clk;\n\n    omap_pwt_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_pwt_ops, s,\n\n                          \"omap-pwt\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n    return s;\n\n}\n", "idx": 21746, "_split": "valid", "_hash": "17760545fd44daeb8db7a40a6a2d5acd"}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_tbl (const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return cpu_ppc_load_tbl(env);\n\n}\n", "idx": 21823, "_split": "valid", "_hash": "b106d6546545143a49c7014b2a5ef517"}
{"project": "qemu", "commit_id": "08a2d4c4ffde60e48819449f461274c43ad6e2d3", "target": 0, "func": "static void sdl_grab_start(void)\n\n{\n\n    if (guest_cursor) {\n\n        SDL_SetCursor(guest_sprite);\n\n        SDL_WarpMouse(guest_x, guest_y);\n\n    } else\n\n        sdl_hide_cursor();\n\n\n\n    if (SDL_WM_GrabInput(SDL_GRAB_ON) == SDL_GRAB_ON) {\n\n        gui_grab = 1;\n\n        sdl_update_caption();\n\n    } else\n\n        sdl_show_cursor();\n\n}\n", "idx": 21858, "_split": "valid", "_hash": "aa0fb82098026caddd394f5ce48d5d0a"}
{"project": "qemu", "commit_id": "872dd82c83745a603d2e07a03d34313eb6467ae4", "target": 0, "func": "VirtQueue *virtio_add_queue(VirtIODevice *vdev, int queue_size,\n\n                            VirtIOHandleOutput handle_output)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < VIRTIO_QUEUE_MAX; i++) {\n\n        if (vdev->vq[i].vring.num == 0)\n\n            break;\n\n    }\n\n\n\n    if (i == VIRTIO_QUEUE_MAX || queue_size > VIRTQUEUE_MAX_SIZE)\n\n        abort();\n\n\n\n    vdev->vq[i].vring.num = queue_size;\n\n    vdev->vq[i].vring.num_default = queue_size;\n\n    vdev->vq[i].vring.align = VIRTIO_PCI_VRING_ALIGN;\n\n    vdev->vq[i].handle_output = handle_output;\n\n    vdev->vq[i].handle_aio_output = NULL;\n\n\n\n    return &vdev->vq[i];\n\n}\n", "idx": 21860, "_split": "valid", "_hash": "e7b958eadd358bf7126354049de35a76"}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static void discard_vq_data(VirtQueue *vq, VirtIODevice *vdev)\n\n{\n\n    VirtQueueElement elem;\n\n\n\n    if (!virtio_queue_ready(vq)) {\n\n        return;\n\n    }\n\n    while (virtqueue_pop(vq, &elem)) {\n\n        virtqueue_push(vq, &elem, 0);\n\n    }\n\n    virtio_notify(vdev, vq);\n\n}\n", "idx": 21864, "_split": "valid", "_hash": "0fcbd348c3289f99adadfccc1bbabea9"}
{"project": "qemu", "commit_id": "35efba2cc6812dc980c336d7b9bf81dbfb5daf00", "target": 0, "func": "static void usbredir_chardev_open(USBRedirDevice *dev)\n\n{\n\n    uint32_t caps[USB_REDIR_CAPS_SIZE] = { 0, };\n\n    char version[32];\n\n    int flags = 0;\n\n\n\n    /* Make sure any pending closes are handled (no-op if none pending) */\n\n    usbredir_chardev_close_bh(dev);\n\n    qemu_bh_cancel(dev->chardev_close_bh);\n\n\n\n    DPRINTF(\"creating usbredirparser\\n\");\n\n\n\n    strcpy(version, \"qemu usb-redir guest \");\n\n    pstrcat(version, sizeof(version), qemu_get_version());\n\n\n\n    dev->parser = qemu_oom_check(usbredirparser_create());\n\n    dev->parser->priv = dev;\n\n    dev->parser->log_func = usbredir_log;\n\n    dev->parser->read_func = usbredir_read;\n\n    dev->parser->write_func = usbredir_write;\n\n    dev->parser->hello_func = usbredir_hello;\n\n    dev->parser->device_connect_func = usbredir_device_connect;\n\n    dev->parser->device_disconnect_func = usbredir_device_disconnect;\n\n    dev->parser->interface_info_func = usbredir_interface_info;\n\n    dev->parser->ep_info_func = usbredir_ep_info;\n\n    dev->parser->configuration_status_func = usbredir_configuration_status;\n\n    dev->parser->alt_setting_status_func = usbredir_alt_setting_status;\n\n    dev->parser->iso_stream_status_func = usbredir_iso_stream_status;\n\n    dev->parser->interrupt_receiving_status_func =\n\n        usbredir_interrupt_receiving_status;\n\n    dev->parser->bulk_streams_status_func = usbredir_bulk_streams_status;\n\n    dev->parser->control_packet_func = usbredir_control_packet;\n\n    dev->parser->bulk_packet_func = usbredir_bulk_packet;\n\n    dev->parser->iso_packet_func = usbredir_iso_packet;\n\n    dev->parser->interrupt_packet_func = usbredir_interrupt_packet;\n\n    dev->read_buf = NULL;\n\n    dev->read_buf_size = 0;\n\n\n\n    usbredirparser_caps_set_cap(caps, usb_redir_cap_connect_device_version);\n\n    usbredirparser_caps_set_cap(caps, usb_redir_cap_filter);\n\n    usbredirparser_caps_set_cap(caps, usb_redir_cap_ep_info_max_packet_size);\n\n    usbredirparser_caps_set_cap(caps, usb_redir_cap_64bits_ids);\n\n\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n\n        flags |= usbredirparser_fl_no_hello;\n\n    }\n\n    usbredirparser_init(dev->parser, version, caps, USB_REDIR_CAPS_SIZE,\n\n                        flags);\n\n    usbredirparser_do_write(dev->parser);\n\n}\n", "idx": 21871, "_split": "valid", "_hash": "e7329bf477b66c357eae6d26b9dbe08f"}
{"project": "qemu", "commit_id": "90e56fb46d0a7add88ed463efa4e723a6238f692", "target": 0, "func": "void migrate_compress_threads_create(void)\n\n{\n\n    int i, thread_count;\n\n\n\n    if (!migrate_use_compression()) {\n\n        return;\n\n    }\n\n    quit_comp_thread = false;\n\n    compression_switch = true;\n\n    thread_count = migrate_compress_threads();\n\n    compress_threads = g_new0(QemuThread, thread_count);\n\n    comp_param = g_new0(CompressParam, thread_count);\n\n    comp_done_cond = g_new0(QemuCond, 1);\n\n    comp_done_lock = g_new0(QemuMutex, 1);\n\n    qemu_cond_init(comp_done_cond);\n\n    qemu_mutex_init(comp_done_lock);\n\n    for (i = 0; i < thread_count; i++) {\n\n        /* com_param[i].file is just used as a dummy buffer to save data, set\n\n         * it's ops to empty.\n\n         */\n\n        comp_param[i].file = qemu_fopen_ops(NULL, &empty_ops);\n\n        comp_param[i].done = true;\n\n        qemu_mutex_init(&comp_param[i].mutex);\n\n        qemu_cond_init(&comp_param[i].cond);\n\n        qemu_thread_create(compress_threads + i, \"compress\",\n\n                           do_data_compress, comp_param + i,\n\n                           QEMU_THREAD_JOINABLE);\n\n    }\n\n}\n", "idx": 21875, "_split": "valid", "_hash": "8ca31fd91ffe036d1dac2673661365b8"}
{"project": "qemu", "commit_id": "703008e81a6ace40f227aae16d630014e5016af1", "target": 0, "func": "void validate_bootdevices(const char *devices)\n\n{\n\n    /* We just do some generic consistency checks */\n\n    const char *p;\n\n    int bitmap = 0;\n\n\n\n    for (p = devices; *p != '\\0'; p++) {\n\n        /* Allowed boot devices are:\n\n         * a-b: floppy disk drives\n\n         * c-f: IDE disk drives\n\n         * g-m: machine implementation dependent drives\n\n         * n-p: network devices\n\n         * It's up to each machine implementation to check if the given boot\n\n         * devices match the actual hardware implementation and firmware\n\n         * features.\n\n         */\n\n        if (*p < 'a' || *p > 'p') {\n\n            fprintf(stderr, \"Invalid boot device '%c'\\n\", *p);\n\n            exit(1);\n\n        }\n\n        if (bitmap & (1 << (*p - 'a'))) {\n\n            fprintf(stderr, \"Boot device '%c' was given twice\\n\", *p);\n\n            exit(1);\n\n        }\n\n        bitmap |= 1 << (*p - 'a');\n\n    }\n\n}\n", "idx": 21876, "_split": "valid", "_hash": "843b9155418bcbd0b6aeccb2efac91ba"}
{"project": "qemu", "commit_id": "cfb2d02be9413d45b30ed6d8e38800250b6b4b48", "target": 0, "func": "static inline void cpu_loop_exec_tb(CPUState *cpu, TranslationBlock *tb,\n\n                                    TranslationBlock **last_tb, int *tb_exit,\n\n                                    SyncClocks *sc)\n\n{\n\n    uintptr_t ret;\n\n    int32_t insns_left;\n\n\n\n    if (unlikely(atomic_read(&cpu->exit_request))) {\n\n        return;\n\n    }\n\n\n\n    trace_exec_tb(tb, tb->pc);\n\n    ret = cpu_tb_exec(cpu, tb);\n\n    tb = (TranslationBlock *)(ret & ~TB_EXIT_MASK);\n\n    *tb_exit = ret & TB_EXIT_MASK;\n\n    if (*tb_exit != TB_EXIT_REQUESTED) {\n\n        *last_tb = tb;\n\n        return;\n\n    }\n\n\n\n    *last_tb = NULL;\n\n    insns_left = atomic_read(&cpu->icount_decr.u32);\n\n    atomic_set(&cpu->icount_decr.u16.high, 0);\n\n    if (insns_left < 0) {\n\n        /* Something asked us to stop executing\n\n         * chained TBs; just continue round the main\n\n         * loop. Whatever requested the exit will also\n\n         * have set something else (eg exit_request or\n\n         * interrupt_request) which we will handle\n\n         * next time around the loop.  But we need to\n\n         * ensure the zeroing of tcg_exit_req (see cpu_tb_exec)\n\n         * comes before the next read of cpu->exit_request\n\n         * or cpu->interrupt_request.\n\n         */\n\n        smp_mb();\n\n        return;\n\n    }\n\n\n\n    /* Instruction counter expired.  */\n\n    assert(use_icount);\n\n#ifndef CONFIG_USER_ONLY\n\n    if (cpu->icount_extra) {\n\n        /* Refill decrementer and continue execution.  */\n\n        cpu->icount_extra += insns_left;\n\n        insns_left = MIN(0xffff, cpu->icount_extra);\n\n        cpu->icount_extra -= insns_left;\n\n        cpu->icount_decr.u16.low = insns_left;\n\n    } else {\n\n        /* Execute any remaining instructions, then let the main loop\n\n         * handle the next event.\n\n         */\n\n        if (insns_left > 0) {\n\n            cpu_exec_nocache(cpu, insns_left, tb, false);\n\n            align_clocks(sc, cpu);\n\n        }\n\n        cpu->exception_index = EXCP_INTERRUPT;\n\n        cpu_loop_exit(cpu);\n\n    }\n\n#endif\n\n}\n", "idx": 21880, "_split": "valid", "_hash": "a0c2db351d7d3369b5f221461eda80d8"}
{"project": "qemu", "commit_id": "32532f215c49f005aaef942adfae34cbcc5fa678", "target": 1, "func": "static void pc_dimm_realize(DeviceState *dev, Error **errp)\n\n{\n\n    PCDIMMDevice *dimm = PC_DIMM(dev);\n\n\n\n    if (!dimm->hostmem) {\n\n        error_setg(errp, \"'\" PC_DIMM_MEMDEV_PROP \"' property is not set\");\n\n        return;\n\n    }\n\n    if ((nb_numa_nodes > 0) && (dimm->node >= nb_numa_nodes)) {\n\n        error_setg(errp, \"'DIMM property \" PC_DIMM_NODE_PROP \" has value %\"\n\n                   PRIu32 \"' which exceeds the number of numa nodes: %d\",\n\n                   dimm->node, nb_numa_nodes);\n\n        return;\n\n    }\n\n}\n", "idx": 21901, "_split": "valid", "_hash": "4e84644bbcfc43426b264cc8b6a8e046"}
{"project": "qemu", "commit_id": "dd09c36159858c66ab6e47c688e4177dd3912bf0", "target": 1, "func": "void cpu_write_xer(CPUPPCState *env, target_ulong xer)\n\n{\n\n    env->so = (xer >> XER_SO) & 1;\n\n    env->ov = (xer >> XER_OV) & 1;\n\n    env->ca = (xer >> XER_CA) & 1;\n\n    env->xer = xer & ~((1u << XER_SO) | (1u << XER_OV) | (1u << XER_CA));\n\n}\n", "idx": 21918, "_split": "valid", "_hash": "f78f29af9369a71f214005c95e81c9e3"}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "void helper_divq_EAX_T0(void)\n\n{\n\n    uint64_t r0, r1;\n\n    if (T0 == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n    r0 = EAX;\n\n    r1 = EDX;\n\n    div64(&r0, &r1, T0);\n\n    EAX = r0;\n\n    EDX = r1;\n\n}\n", "idx": 21921, "_split": "valid", "_hash": "1674a6328a43e8402da54e525b568eb9"}
{"project": "qemu", "commit_id": "640601c7cb1b6b41d3e1a435b986266c2b71e9bc", "target": 1, "func": "vu_queue_flush(VuDev *dev, VuVirtq *vq, unsigned int count)\n\n{\n\n    uint16_t old, new;\n\n\n\n    if (unlikely(dev->broken)) {\n\n        return;\n\n    }\n\n\n\n    /* Make sure buffer is written before we update index. */\n\n    smp_wmb();\n\n\n\n    old = vq->used_idx;\n\n    new = old + count;\n\n    vring_used_idx_set(dev, vq, new);\n\n    vq->inuse -= count;\n\n    if (unlikely((int16_t)(new - vq->signalled_used) < (uint16_t)(new - old))) {\n\n        vq->signalled_used_valid = false;\n\n    }\n\n}\n", "idx": 21980, "_split": "valid", "_hash": "2348f584431de1e6fff0751d0d269376"}
{"project": "qemu", "commit_id": "1108b2f8a939fb5778d384149e2f1b99062a72da", "target": 1, "func": "static int ioh3420_initfn(PCIDevice *d)\n\n{\n\n    PCIEPort *p = PCIE_PORT(d);\n\n    PCIESlot *s = PCIE_SLOT(d);\n\n    int rc;\n\n\n\n    pci_bridge_initfn(d, TYPE_PCIE_BUS);\n\n    pcie_port_init_reg(d);\n\n\n\n    rc = pci_bridge_ssvid_init(d, IOH_EP_SSVID_OFFSET,\n\n                               IOH_EP_SSVID_SVID, IOH_EP_SSVID_SSID);\n\n    if (rc < 0) {\n\n        goto err_bridge;\n\n    }\n\n\n\n    rc = msi_init(d, IOH_EP_MSI_OFFSET, IOH_EP_MSI_NR_VECTOR,\n\n                  IOH_EP_MSI_SUPPORTED_FLAGS & PCI_MSI_FLAGS_64BIT,\n\n                  IOH_EP_MSI_SUPPORTED_FLAGS & PCI_MSI_FLAGS_MASKBIT);\n\n    if (rc < 0) {\n\n        goto err_bridge;\n\n    }\n\n\n\n    rc = pcie_cap_init(d, IOH_EP_EXP_OFFSET, PCI_EXP_TYPE_ROOT_PORT, p->port);\n\n    if (rc < 0) {\n\n        goto err_msi;\n\n    }\n\n\n\n    pcie_cap_arifwd_init(d);\n\n    pcie_cap_deverr_init(d);\n\n    pcie_cap_slot_init(d, s->slot);\n\n    pcie_cap_root_init(d);\n\n\n\n    pcie_chassis_create(s->chassis);\n\n    rc = pcie_chassis_add_slot(s);\n\n    if (rc < 0) {\n\n        goto err_pcie_cap;\n\n    }\n\n\n\n    rc = pcie_aer_init(d, IOH_EP_AER_OFFSET, PCI_ERR_SIZEOF);\n\n    if (rc < 0) {\n\n        goto err;\n\n    }\n\n    pcie_aer_root_init(d);\n\n    ioh3420_aer_vector_update(d);\n\n\n\n    return 0;\n\n\n\nerr:\n\n    pcie_chassis_del_slot(s);\n\nerr_pcie_cap:\n\n    pcie_cap_exit(d);\n\nerr_msi:\n\n    msi_uninit(d);\n\nerr_bridge:\n\n    pci_bridge_exitfn(d);\n\n    return rc;\n\n}\n", "idx": 22002, "_split": "valid", "_hash": "5c5aa13a71148c1c328a6e3ade1915c6"}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid)\n\n{\n\n    int32_t datalen;\n\n    int lun;\n\n\n\n    DPRINTF(\"do_busid_cmd: busid 0x%x\\n\", busid);\n\n    lun = busid & 7;\n\n    datalen = s->current_dev->info->send_command(s->current_dev, 0, buf, lun);\n\n    s->ti_size = datalen;\n\n    if (datalen != 0) {\n\n        s->rregs[ESP_RSTAT] = STAT_TC;\n\n        s->dma_left = 0;\n\n        s->dma_counter = 0;\n\n        if (datalen > 0) {\n\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n\n            s->current_dev->info->read_data(s->current_dev, 0);\n\n        } else {\n\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n\n            s->current_dev->info->write_data(s->current_dev, 0);\n\n        }\n\n    }\n\n    s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n\n    s->rregs[ESP_RSEQ] = SEQ_CD;\n\n    esp_raise_irq(s);\n\n}\n", "idx": 22029, "_split": "valid", "_hash": "d0428edb2917ed09adc02a791c1253c4"}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static TCGv neon_load_scratch(int scratch)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_ld_i32(tmp, cpu_env, offsetof(CPUARMState, vfp.scratch[scratch]));\n\n    return tmp;\n\n}\n", "idx": 22045, "_split": "valid", "_hash": "a982f0cb9b109db392eb1824938eaa4e"}
{"project": "qemu", "commit_id": "0b368a10c71af96f6cf93b0ba5c2ee3bdbd50e96", "target": 1, "func": "static int kvm_put_msrs(X86CPU *cpu, int level)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    int i;\n\n    int ret;\n\n\n\n    kvm_msr_buf_reset(cpu);\n\n\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, env->sysenter_cs);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, env->sysenter_esp);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, env->sysenter_eip);\n\n    kvm_msr_entry_add(cpu, MSR_PAT, env->pat);\n\n    if (has_msr_star) {\n\n        kvm_msr_entry_add(cpu, MSR_STAR, env->star);\n\n    }\n\n    if (has_msr_hsave_pa) {\n\n        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, env->vm_hsave);\n\n    }\n\n    if (has_msr_tsc_aux) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_AUX, env->tsc_aux);\n\n    }\n\n    if (has_msr_tsc_adjust) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, env->tsc_adjust);\n\n    }\n\n    if (has_msr_misc_enable) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE,\n\n                          env->msr_ia32_misc_enable);\n\n    }\n\n    if (has_msr_smbase) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, env->smbase);\n\n    }\n\n    if (has_msr_bndcfgs) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, env->msr_bndcfgs);\n\n    }\n\n    if (has_msr_xss) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_XSS, env->xss);\n\n    }\n\n#ifdef TARGET_X86_64\n\n    if (lm_capable_kernel) {\n\n        kvm_msr_entry_add(cpu, MSR_CSTAR, env->cstar);\n\n        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, env->kernelgsbase);\n\n        kvm_msr_entry_add(cpu, MSR_FMASK, env->fmask);\n\n        kvm_msr_entry_add(cpu, MSR_LSTAR, env->lstar);\n\n    }\n\n#endif\n\n    /*\n\n     * The following MSRs have side effects on the guest or are too heavy\n\n     * for normal writeback. Limit them to reset or full state updates.\n\n     */\n\n    if (level >= KVM_PUT_RESET_STATE) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_TSC, env->tsc);\n\n        kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, env->system_time_msr);\n\n        kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, env->wall_clock_msr);\n\n        if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_ASYNC_PF)) {\n\n            kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, env->async_pf_en_msr);\n\n        }\n\n        if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_PV_EOI)) {\n\n            kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, env->pv_eoi_en_msr);\n\n        }\n\n        if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_STEAL_TIME)) {\n\n            kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, env->steal_time_msr);\n\n        }\n\n        if (has_msr_architectural_pmu) {\n\n            /* Stop the counter.  */\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);\n\n\n\n            /* Set the counter values.  */\n\n            for (i = 0; i < MAX_FIXED_COUNTERS; i++) {\n\n                kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i,\n\n                                  env->msr_fixed_counters[i]);\n\n            }\n\n            for (i = 0; i < num_architectural_pmu_counters; i++) {\n\n                kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i,\n\n                                  env->msr_gp_counters[i]);\n\n                kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i,\n\n                                  env->msr_gp_evtsel[i]);\n\n            }\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS,\n\n                              env->msr_global_status);\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL,\n\n                              env->msr_global_ovf_ctrl);\n\n\n\n            /* Now start the PMU.  */\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL,\n\n                              env->msr_fixed_ctr_ctrl);\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL,\n\n                              env->msr_global_ctrl);\n\n        }\n\n        /*\n\n         * Hyper-V partition-wide MSRs: to avoid clearing them on cpu hot-add,\n\n         * only sync them to KVM on the first cpu\n\n         */\n\n        if (current_cpu == first_cpu) {\n\n            if (has_msr_hv_hypercall) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID,\n\n                                  env->msr_hv_guest_os_id);\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL,\n\n                                  env->msr_hv_hypercall);\n\n            }\n\n            if (cpu->hyperv_time) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC,\n\n                                  env->msr_hv_tsc);\n\n            }\n\n        }\n\n        if (cpu->hyperv_vapic) {\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE,\n\n                              env->msr_hv_vapic);\n\n        }\n\n        if (has_msr_hv_crash) {\n\n            int j;\n\n\n\n            for (j = 0; j < HV_CRASH_PARAMS; j++)\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j,\n\n                                  env->msr_hv_crash_params[j]);\n\n\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_CTL, HV_CRASH_CTL_NOTIFY);\n\n        }\n\n        if (has_msr_hv_runtime) {\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, env->msr_hv_runtime);\n\n        }\n\n        if (cpu->hyperv_synic) {\n\n            int j;\n\n\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, HV_SYNIC_VERSION);\n\n\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL,\n\n                              env->msr_hv_synic_control);\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP,\n\n                              env->msr_hv_synic_evt_page);\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP,\n\n                              env->msr_hv_synic_msg_page);\n\n\n\n            for (j = 0; j < ARRAY_SIZE(env->msr_hv_synic_sint); j++) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_SINT0 + j,\n\n                                  env->msr_hv_synic_sint[j]);\n\n            }\n\n        }\n\n        if (has_msr_hv_stimer) {\n\n            int j;\n\n\n\n            for (j = 0; j < ARRAY_SIZE(env->msr_hv_stimer_config); j++) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_STIMER0_CONFIG + j * 2,\n\n                                env->msr_hv_stimer_config[j]);\n\n            }\n\n\n\n            for (j = 0; j < ARRAY_SIZE(env->msr_hv_stimer_count); j++) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_STIMER0_COUNT + j * 2,\n\n                                env->msr_hv_stimer_count[j]);\n\n            }\n\n        }\n\n        if (env->features[FEAT_1_EDX] & CPUID_MTRR) {\n\n            uint64_t phys_mask = MAKE_64BIT_MASK(0, cpu->phys_bits);\n\n\n\n            kvm_msr_entry_add(cpu, MSR_MTRRdefType, env->mtrr_deftype);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, env->mtrr_fixed[0]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, env->mtrr_fixed[1]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, env->mtrr_fixed[2]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, env->mtrr_fixed[3]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, env->mtrr_fixed[4]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, env->mtrr_fixed[5]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, env->mtrr_fixed[6]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, env->mtrr_fixed[7]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, env->mtrr_fixed[8]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, env->mtrr_fixed[9]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, env->mtrr_fixed[10]);\n\n            for (i = 0; i < MSR_MTRRcap_VCNT; i++) {\n\n                /* The CPU GPs if we write to a bit above the physical limit of\n\n                 * the host CPU (and KVM emulates that)\n\n                 */\n\n                uint64_t mask = env->mtrr_var[i].mask;\n\n                mask &= phys_mask;\n\n\n\n                kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i),\n\n                                  env->mtrr_var[i].base);\n\n                kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), mask);\n\n            }\n\n        }\n\n\n\n        /* Note: MSR_IA32_FEATURE_CONTROL is written separately, see\n\n         *       kvm_put_msr_feature_control. */\n\n    }\n\n    if (env->mcg_cap) {\n\n        int i;\n\n\n\n        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, env->mcg_status);\n\n        kvm_msr_entry_add(cpu, MSR_MCG_CTL, env->mcg_ctl);\n\n        if (has_msr_mcg_ext_ctl) {\n\n            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, env->mcg_ext_ctl);\n\n        }\n\n        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, env->mce_banks[i]);\n\n        }\n\n    }\n\n\n\n    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (ret < cpu->kvm_msr_buf->nmsrs) {\n\n        struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];\n\n        error_report(\"error: failed to set MSR 0x%\" PRIx32 \" to 0x%\" PRIx64,\n\n                     (uint32_t)e->index, (uint64_t)e->data);\n\n    }\n\n\n\n    assert(ret == cpu->kvm_msr_buf->nmsrs);\n\n    return 0;\n\n}\n", "idx": 22060, "_split": "valid", "_hash": "78416ec4c42024c7da84dfbe6884e3a5"}
{"project": "qemu", "commit_id": "234ac1a9025bcfcc532449f72a97b3d4754d466c", "target": 0, "func": "void bdrv_append(BlockDriverState *bs_new, BlockDriverState *bs_top,\n\n                 Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n\n\n    assert(!atomic_read(&bs_top->in_flight));\n\n    assert(!atomic_read(&bs_new->in_flight));\n\n\n\n    bdrv_set_backing_hd(bs_new, bs_top, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out;\n\n    }\n\n\n\n    change_parent_backing_link(bs_top, bs_new);\n\n\n\n    /* bs_new is now referenced by its new parents, we don't need the\n\n     * additional reference any more. */\n\nout:\n\n    bdrv_unref(bs_new);\n\n}\n", "idx": 22080, "_split": "valid", "_hash": "d79a11e659b69ef99f07723fcc7d120a"}
{"project": "qemu", "commit_id": "be09ac4194bd0a61c0d9412c32431fbe2273cba1", "target": 0, "func": "static abi_long do_sendto(int fd, abi_ulong msg, size_t len, int flags,\n\n                          abi_ulong target_addr, socklen_t addrlen)\n\n{\n\n    void *addr;\n\n    void *host_msg;\n\n    abi_long ret;\n\n\n\n    if (addrlen < 0 || addrlen > MAX_SOCK_ADDR)\n\n        return -TARGET_EINVAL;\n\n\n\n    host_msg = lock_user(VERIFY_READ, msg, len, 1);\n\n    if (!host_msg)\n\n        return -TARGET_EFAULT;\n\n    if (target_addr) {\n\n        addr = alloca(addrlen);\n\n        target_to_host_sockaddr(addr, target_addr, addrlen);\n\n        ret = get_errno(sendto(fd, host_msg, len, flags, addr, addrlen));\n\n    } else {\n\n        ret = get_errno(send(fd, host_msg, len, flags));\n\n    }\n\n    unlock_user(host_msg, msg, 0);\n\n    return ret;\n\n}\n", "idx": 22081, "_split": "valid", "_hash": "90859b9b41e94761201de23c7995c252"}
{"project": "qemu", "commit_id": "0e2487bd6f56445b43307536a465ee2ba810aed9", "target": 0, "func": "void qxl_render_resize(PCIQXLDevice *qxl)\n\n{\n\n    QXLSurfaceCreate *sc = &qxl->guest_primary.surface;\n\n\n\n    qxl->guest_primary.stride = sc->stride;\n\n    qxl->guest_primary.resized++;\n\n    switch (sc->format) {\n\n    case SPICE_SURFACE_FMT_16_555:\n\n        qxl->guest_primary.bytes_pp = 2;\n\n        qxl->guest_primary.bits_pp = 15;\n\n        break;\n\n    case SPICE_SURFACE_FMT_16_565:\n\n        qxl->guest_primary.bytes_pp = 2;\n\n        qxl->guest_primary.bits_pp = 16;\n\n        break;\n\n    case SPICE_SURFACE_FMT_32_xRGB:\n\n    case SPICE_SURFACE_FMT_32_ARGB:\n\n        qxl->guest_primary.bytes_pp = 4;\n\n        qxl->guest_primary.bits_pp = 32;\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: unhandled format: %x\\n\", __FUNCTION__,\n\n                qxl->guest_primary.surface.format);\n\n        qxl->guest_primary.bytes_pp = 4;\n\n        qxl->guest_primary.bits_pp = 32;\n\n        break;\n\n    }\n\n}\n", "idx": 22083, "_split": "valid", "_hash": "5cd4a81f4432208ce33b0d61f125c146"}
{"project": "qemu", "commit_id": "5b8d7289e9e92a0d7bcecb93cd189e245fef10cd", "target": 0, "func": "static bool insn_crosses_page(CPUARMState *env, DisasContext *s)\n\n{\n\n    /* Return true if the insn at dc->pc might cross a page boundary.\n\n     * (False positives are OK, false negatives are not.)\n\n     */\n\n    uint16_t insn;\n\n\n\n    if ((s->pc & 3) == 0) {\n\n        /* At a 4-aligned address we can't be crossing a page */\n\n        return false;\n\n    }\n\n\n\n    /* This must be a Thumb insn */\n\n    insn = arm_lduw_code(env, s->pc, s->sctlr_b);\n\n\n\n    if ((insn >> 11) >= 0x1d) {\n\n        /* Top five bits 0b11101 / 0b11110 / 0b11111 : this is the\n\n         * First half of a 32-bit Thumb insn. Thumb-1 cores might\n\n         * end up actually treating this as two 16-bit insns (see the\n\n         * code at the start of disas_thumb2_insn()) but we don't bother\n\n         * to check for that as it is unlikely, and false positives here\n\n         * are harmless.\n\n         */\n\n        return true;\n\n    }\n\n    /* Definitely a 16-bit insn, can't be crossing a page. */\n\n    return false;\n\n}\n", "idx": 22097, "_split": "valid", "_hash": "9b53c350fa0052ae0f431a720dc83882"}
{"project": "qemu", "commit_id": "c338b6ad609699cf352c8dd6338360b7e3895ad0", "target": 0, "func": "static int vmdk_is_cid_valid(BlockDriverState *bs)\n\n{\n\n#ifdef CHECK_CID\n\n    BDRVVmdkState *s = bs->opaque;\n\n    BlockDriverState *p_bs = bs->backing_hd;\n\n    uint32_t cur_pcid;\n\n\n\n    if (p_bs) {\n\n        cur_pcid = vmdk_read_cid(p_bs, 0);\n\n        if (s->parent_cid != cur_pcid) {\n\n            /* CID not valid */\n\n            return 0;\n\n        }\n\n    }\n\n#endif\n\n    /* CID valid */\n\n    return 1;\n\n}\n", "idx": 22104, "_split": "valid", "_hash": "1f3e27ecdf91310890c87d64ce0b6b89"}
{"project": "qemu", "commit_id": "a702b35388c307ce2364691e2edc14094701c81e", "target": 0, "func": "static uint32_t slavio_timer_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    SLAVIO_TIMERState *s = opaque;\n\n    uint32_t saddr, ret;\n\n\n\n    saddr = (addr & TIMER_MAXADDR) >> 2;\n\n    switch (saddr) {\n\n    case 0:\n\n        // read limit (system counter mode) or read most signifying\n\n        // part of counter (user mode)\n\n        if (slavio_timer_is_user(s)) {\n\n            // read user timer MSW\n\n            slavio_timer_get_out(s);\n\n            ret = s->counthigh;\n\n        } else {\n\n            // read limit\n\n            // clear irq\n\n            qemu_irq_lower(s->irq);\n\n            s->reached = 0;\n\n            ret = s->limit & 0x7fffffff;\n\n        }\n\n        break;\n\n    case 1:\n\n        // read counter and reached bit (system mode) or read lsbits\n\n        // of counter (user mode)\n\n        slavio_timer_get_out(s);\n\n        if (slavio_timer_is_user(s)) // read user timer LSW\n\n            ret = s->count & 0xffffffe00;\n\n        else // read limit\n\n            ret = (s->count & 0x7ffffe00) | s->reached;\n\n        break;\n\n    case 3:\n\n        // only available in processor counter/timer\n\n        // read start/stop status\n\n        ret = s->running;\n\n        break;\n\n    case 4:\n\n        // only available in system counter\n\n        // read user/system mode\n\n        ret = s->slave_mode;\n\n        break;\n\n    default:\n\n        DPRINTF(\"invalid read address \" TARGET_FMT_plx \"\\n\", addr);\n\n        ret = 0;\n\n        break;\n\n    }\n\n    DPRINTF(\"read \" TARGET_FMT_plx \" = %08x\\n\", addr, ret);\n\n\n\n    return ret;\n\n}\n", "idx": 22105, "_split": "valid", "_hash": "e561d17e87ba0439bb894da6febc102d"}
{"project": "qemu", "commit_id": "9abc62f6445795522d1bf5bf17f642e44eaf032d", "target": 0, "func": "void qemu_system_suspend_request(void)\n\n{\n\n    if (is_suspended) {\n\n        return;\n\n    }\n\n    suspend_requested = 1;\n\n    cpu_stop_current();\n\n    qemu_notify_event();\n\n}\n", "idx": 22109, "_split": "valid", "_hash": "d87b3d59c6e0f2690c4dbf7b425dc804"}
{"project": "qemu", "commit_id": "89dbe18089127cf90993359096b659ea6f819848", "target": 0, "func": "static void ssh_parse_filename(const char *filename, QDict *options,\n\n                               Error **errp)\n\n{\n\n    if (qdict_haskey(options, \"user\") ||\n\n        qdict_haskey(options, \"host\") ||\n\n        qdict_haskey(options, \"port\") ||\n\n        qdict_haskey(options, \"path\") ||\n\n        qdict_haskey(options, \"host_key_check\")) {\n\n        error_setg(errp, \"user, host, port, path, host_key_check cannot be used at the same time as a file option\");\n\n        return;\n\n    }\n\n\n\n    parse_uri(filename, options, errp);\n\n}\n", "idx": 22119, "_split": "valid", "_hash": "96557262d1ce5e982c36fa68aca58e5d"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void do_acl_show(Monitor *mon, const QDict *qdict)\n\n{\n\n    const char *aclname = qdict_get_str(qdict, \"aclname\");\n\n    qemu_acl *acl = find_acl(mon, aclname);\n\n    qemu_acl_entry *entry;\n\n    int i = 0;\n\n\n\n    if (acl) {\n\n        monitor_printf(mon, \"policy: %s\\n\",\n\n                       acl->defaultDeny ? \"deny\" : \"allow\");\n\n        TAILQ_FOREACH(entry, &acl->entries, next) {\n\n            i++;\n\n            monitor_printf(mon, \"%d: %s %s\\n\", i,\n\n                           entry->deny ? \"deny\" : \"allow\", entry->match);\n\n        }\n\n    }\n\n}\n", "idx": 22142, "_split": "valid", "_hash": "3b8264f45dbe3b665f99b84d7426a14e"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "MemoryRegionSection *phys_page_find(AddressSpaceDispatch *d, target_phys_addr_t index)\n\n{\n\n    PhysPageEntry lp = d->phys_map;\n\n    PhysPageEntry *p;\n\n    int i;\n\n    uint16_t s_index = phys_section_unassigned;\n\n\n\n    for (i = P_L2_LEVELS - 1; i >= 0 && !lp.is_leaf; i--) {\n\n        if (lp.ptr == PHYS_MAP_NODE_NIL) {\n\n            goto not_found;\n\n        }\n\n        p = phys_map_nodes[lp.ptr];\n\n        lp = p[(index >> (i * L2_BITS)) & (L2_SIZE - 1)];\n\n    }\n\n\n\n    s_index = lp.ptr;\n\nnot_found:\n\n    return &phys_sections[s_index];\n\n}\n", "idx": 22143, "_split": "valid", "_hash": "9d75371593db520ab353113ae6a3e43a"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int drive_get_max_bus(BlockInterfaceType type)\n\n{\n\n    int max_bus;\n\n    DriveInfo *dinfo;\n\n\n\n    max_bus = -1;\n\n    TAILQ_FOREACH(dinfo, &drives, next) {\n\n        if(dinfo->type == type &&\n\n           dinfo->bus > max_bus)\n\n            max_bus = dinfo->bus;\n\n    }\n\n    return max_bus;\n\n}\n", "idx": 22184, "_split": "valid", "_hash": "d779dc7dc0e63f00b719e2c4be0d47af"}
{"project": "qemu", "commit_id": "c021f8e65f5009a5ab5711d9d5326fcab553ef1c", "target": 0, "func": "PCIBus *pci_find_bus(PCIBus *bus, int bus_num)\n\n{\n\n    PCIBus *sec;\n\n\n\n    if (!bus)\n\n        return NULL;\n\n\n\n    if (pci_bus_num(bus) == bus_num) {\n\n        return bus;\n\n    }\n\n\n\n    /* try child bus */\n\n    QLIST_FOREACH(sec, &bus->child, sibling) {\n\n\n\n        if (!bus->parent_dev /* pci host bridge */\n\n            || (pci_bus_num(sec) <= bus_num &&\n\n                bus->parent_dev->config[PCI_SUBORDINATE_BUS])) {\n\n            return pci_find_bus(sec, bus_num);\n\n        }\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 22187, "_split": "valid", "_hash": "48b3e2a18169bf9268b7785f4cb1af8c"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "ser_write(void *opaque, target_phys_addr_t addr,\n\n          uint64_t val64, unsigned int size)\n\n{\n\n    struct etrax_serial *s = opaque;\n\n    uint32_t value = val64;\n\n    unsigned char ch = val64;\n\n    D(CPUCRISState *env = s->env);\n\n\n\n    D(qemu_log(\"%s \" TARGET_FMT_plx \"=%x\\n\",  __func__, addr, value));\n\n    addr >>= 2;\n\n    switch (addr)\n\n    {\n\n        case RW_DOUT:\n\n            qemu_chr_fe_write(s->chr, &ch, 1);\n\n            s->regs[R_INTR] |= 3;\n\n            s->pending_tx = 1;\n\n            s->regs[addr] = value;\n\n            break;\n\n        case RW_ACK_INTR:\n\n            if (s->pending_tx) {\n\n                value &= ~1;\n\n                s->pending_tx = 0;\n\n                D(qemu_log(\"fixedup value=%x r_intr=%x\\n\",\n\n                           value, s->regs[R_INTR]));\n\n            }\n\n            s->regs[addr] = value;\n\n            s->regs[R_INTR] &= ~value;\n\n            D(printf(\"r_intr=%x\\n\", s->regs[R_INTR]));\n\n            break;\n\n        default:\n\n            s->regs[addr] = value;\n\n            break;\n\n    }\n\n    ser_update_irq(s);\n\n}\n", "idx": 22189, "_split": "valid", "_hash": "1c98c9235c3f0eb87e292e5078692028"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void gic_dist_writeb(void *opaque, target_phys_addr_t offset,\n\n                            uint32_t value)\n\n{\n\n    GICState *s = (GICState *)opaque;\n\n    int irq;\n\n    int i;\n\n    int cpu;\n\n\n\n    cpu = gic_get_current_cpu(s);\n\n    if (offset < 0x100) {\n\n        if (offset == 0) {\n\n            s->enabled = (value & 1);\n\n            DPRINTF(\"Distribution %sabled\\n\", s->enabled ? \"En\" : \"Dis\");\n\n        } else if (offset < 4) {\n\n            /* ignored.  */\n\n        } else if (offset >= 0x80) {\n\n            /* Interrupt Security Registers, RAZ/WI */\n\n        } else {\n\n            goto bad_reg;\n\n        }\n\n    } else if (offset < 0x180) {\n\n        /* Interrupt Set Enable.  */\n\n        irq = (offset - 0x100) * 8 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        if (irq < 16)\n\n          value = 0xff;\n\n        for (i = 0; i < 8; i++) {\n\n            if (value & (1 << i)) {\n\n                int mask = (irq < GIC_INTERNAL) ? (1 << cpu) : GIC_TARGET(irq);\n\n                int cm = (irq < GIC_INTERNAL) ? (1 << cpu) : ALL_CPU_MASK;\n\n\n\n                if (!GIC_TEST_ENABLED(irq + i, cm)) {\n\n                    DPRINTF(\"Enabled IRQ %d\\n\", irq + i);\n\n                }\n\n                GIC_SET_ENABLED(irq + i, cm);\n\n                /* If a raised level triggered IRQ enabled then mark\n\n                   is as pending.  */\n\n                if (GIC_TEST_LEVEL(irq + i, mask)\n\n                        && !GIC_TEST_TRIGGER(irq + i)) {\n\n                    DPRINTF(\"Set %d pending mask %x\\n\", irq + i, mask);\n\n                    GIC_SET_PENDING(irq + i, mask);\n\n                }\n\n            }\n\n        }\n\n    } else if (offset < 0x200) {\n\n        /* Interrupt Clear Enable.  */\n\n        irq = (offset - 0x180) * 8 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        if (irq < 16)\n\n          value = 0;\n\n        for (i = 0; i < 8; i++) {\n\n            if (value & (1 << i)) {\n\n                int cm = (irq < GIC_INTERNAL) ? (1 << cpu) : ALL_CPU_MASK;\n\n\n\n                if (GIC_TEST_ENABLED(irq + i, cm)) {\n\n                    DPRINTF(\"Disabled IRQ %d\\n\", irq + i);\n\n                }\n\n                GIC_CLEAR_ENABLED(irq + i, cm);\n\n            }\n\n        }\n\n    } else if (offset < 0x280) {\n\n        /* Interrupt Set Pending.  */\n\n        irq = (offset - 0x200) * 8 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        if (irq < 16)\n\n          irq = 0;\n\n\n\n        for (i = 0; i < 8; i++) {\n\n            if (value & (1 << i)) {\n\n                GIC_SET_PENDING(irq + i, GIC_TARGET(irq));\n\n            }\n\n        }\n\n    } else if (offset < 0x300) {\n\n        /* Interrupt Clear Pending.  */\n\n        irq = (offset - 0x280) * 8 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        for (i = 0; i < 8; i++) {\n\n            /* ??? This currently clears the pending bit for all CPUs, even\n\n               for per-CPU interrupts.  It's unclear whether this is the\n\n               corect behavior.  */\n\n            if (value & (1 << i)) {\n\n                GIC_CLEAR_PENDING(irq + i, ALL_CPU_MASK);\n\n            }\n\n        }\n\n    } else if (offset < 0x400) {\n\n        /* Interrupt Active.  */\n\n        goto bad_reg;\n\n    } else if (offset < 0x800) {\n\n        /* Interrupt Priority.  */\n\n        irq = (offset - 0x400) + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        if (irq < GIC_INTERNAL) {\n\n            s->priority1[irq][cpu] = value;\n\n        } else {\n\n            s->priority2[irq - GIC_INTERNAL] = value;\n\n        }\n\n    } else if (offset < 0xc00) {\n\n        /* Interrupt CPU Target. RAZ/WI on uniprocessor GICs, with the\n\n         * annoying exception of the 11MPCore's GIC.\n\n         */\n\n        if (s->num_cpu != 1 || s->revision == REV_11MPCORE) {\n\n            irq = (offset - 0x800) + GIC_BASE_IRQ;\n\n            if (irq >= s->num_irq) {\n\n                goto bad_reg;\n\n            }\n\n            if (irq < 29) {\n\n                value = 0;\n\n            } else if (irq < GIC_INTERNAL) {\n\n                value = ALL_CPU_MASK;\n\n            }\n\n            s->irq_target[irq] = value & ALL_CPU_MASK;\n\n        }\n\n    } else if (offset < 0xf00) {\n\n        /* Interrupt Configuration.  */\n\n        irq = (offset - 0xc00) * 4 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        if (irq < GIC_INTERNAL)\n\n            value |= 0xaa;\n\n        for (i = 0; i < 4; i++) {\n\n            if (value & (1 << (i * 2))) {\n\n                GIC_SET_MODEL(irq + i);\n\n            } else {\n\n                GIC_CLEAR_MODEL(irq + i);\n\n            }\n\n            if (value & (2 << (i * 2))) {\n\n                GIC_SET_TRIGGER(irq + i);\n\n            } else {\n\n                GIC_CLEAR_TRIGGER(irq + i);\n\n            }\n\n        }\n\n    } else {\n\n        /* 0xf00 is only handled for 32-bit writes.  */\n\n        goto bad_reg;\n\n    }\n\n    gic_update(s);\n\n    return;\n\nbad_reg:\n\n    hw_error(\"gic_dist_writeb: Bad offset %x\\n\", (int)offset);\n\n}\n", "idx": 22190, "_split": "valid", "_hash": "0489da5ddef35751814082463924bf1a"}
{"project": "qemu", "commit_id": "ee17e84830e2e7030d57db5b415719e9022573cd", "target": 0, "func": "static void virtio_blk_handle_request(VirtIOBlockReq *req,\n\n    MultiReqBuffer *mrb)\n\n{\n\n    uint32_t type;\n\n    struct iovec *iov = req->elem->out_sg;\n\n    unsigned out_num = req->elem->out_num;\n\n\n\n    if (req->elem->out_num < 1 || req->elem->in_num < 1) {\n\n        error_report(\"virtio-blk missing headers\");\n\n        exit(1);\n\n    }\n\n\n\n    if (req->elem->out_sg[0].iov_len < sizeof(req->out) ||\n\n        req->elem->in_sg[req->elem->in_num - 1].iov_len < sizeof(*req->in)) {\n\n        error_report(\"virtio-blk header not in correct element\");\n\n        exit(1);\n\n    }\n\n\n\n    if (unlikely(iov_to_buf(iov, out_num, 0, &req->out,\n\n                            sizeof(req->out)) != sizeof(req->out))) {\n\n        error_report(\"virtio-blk request outhdr too short\");\n\n        exit(1);\n\n    }\n\n    iov_discard_front(&iov, &out_num, sizeof(req->out));\n\n    req->in = (void *)req->elem->in_sg[req->elem->in_num - 1].iov_base;\n\n\n\n    type = ldl_p(&req->out.type);\n\n\n\n    if (type & VIRTIO_BLK_T_FLUSH) {\n\n        virtio_blk_handle_flush(req, mrb);\n\n    } else if (type & VIRTIO_BLK_T_SCSI_CMD) {\n\n        virtio_blk_handle_scsi(req);\n\n    } else if (type & VIRTIO_BLK_T_GET_ID) {\n\n        VirtIOBlock *s = req->dev;\n\n\n\n        /*\n\n         * NB: per existing s/n string convention the string is\n\n         * terminated by '\\0' only when shorter than buffer.\n\n         */\n\n        strncpy(req->elem->in_sg[0].iov_base,\n\n                s->blk.serial ? s->blk.serial : \"\",\n\n                MIN(req->elem->in_sg[0].iov_len, VIRTIO_BLK_ID_BYTES));\n\n        virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);\n\n        virtio_blk_free_request(req);\n\n    } else if (type & VIRTIO_BLK_T_OUT) {\n\n        qemu_iovec_init_external(&req->qiov, &req->elem->out_sg[1],\n\n                                 req->elem->out_num - 1);\n\n        virtio_blk_handle_write(req, mrb);\n\n    } else if (type == VIRTIO_BLK_T_IN || type == VIRTIO_BLK_T_BARRIER) {\n\n        /* VIRTIO_BLK_T_IN is 0, so we can't just & it. */\n\n        qemu_iovec_init_external(&req->qiov, &req->elem->in_sg[0],\n\n                                 req->elem->in_num - 1);\n\n        virtio_blk_handle_read(req);\n\n    } else {\n\n        virtio_blk_req_complete(req, VIRTIO_BLK_S_UNSUPP);\n\n        virtio_blk_free_request(req);\n\n    }\n\n}\n", "idx": 22192, "_split": "valid", "_hash": "ed58f43c2631f3974d0fca3808d50471"}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_addq_lo(DisasContext *s, TCGv val, int rlow)\n\n{\n\n    TCGv tmp;\n\n    TCGv tmp2;\n\n\n\n    /* Load value and extend to 64 bits.  */\n\n    tmp = tcg_temp_new(TCG_TYPE_I64);\n\n    tmp2 = load_reg(s, rlow);\n\n    tcg_gen_extu_i32_i64(tmp, tmp2);\n\n    dead_tmp(tmp2);\n\n    tcg_gen_add_i64(val, val, tmp);\n\n}\n", "idx": 22213, "_split": "valid", "_hash": "ec7848aa18d07693a4cb15ebecce5704"}
{"project": "qemu", "commit_id": "d2d979c628e4b2c4a3cb71a31841875795c79043", "target": 1, "func": "static void nbd_close(BlockDriverState *bs)\n{\n    nbd_teardown_connection(bs);\n}", "idx": 22223, "_split": "valid", "_hash": "5009af5ad835fbbad29ceed02f06a83d"}
{"project": "qemu", "commit_id": "aa4a3dce1c88ed51b616806b8214b7c8428b7470", "target": 1, "func": "static void vmxnet3_handle_command(VMXNET3State *s, uint64_t cmd)\n\n{\n\n    s->last_command = cmd;\n\n\n\n    switch (cmd) {\n\n    case VMXNET3_CMD_GET_PERM_MAC_HI:\n\n        VMW_CBPRN(\"Set: Get upper part of permanent MAC\");\n\n        break;\n\n\n\n    case VMXNET3_CMD_GET_PERM_MAC_LO:\n\n        VMW_CBPRN(\"Set: Get lower part of permanent MAC\");\n\n        break;\n\n\n\n    case VMXNET3_CMD_GET_STATS:\n\n        VMW_CBPRN(\"Set: Get device statistics\");\n\n        vmxnet3_fill_stats(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_ACTIVATE_DEV:\n\n        VMW_CBPRN(\"Set: Activating vmxnet3 device\");\n\n        vmxnet3_activate_device(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_UPDATE_RX_MODE:\n\n        VMW_CBPRN(\"Set: Update rx mode\");\n\n        vmxnet3_update_rx_mode(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_UPDATE_VLAN_FILTERS:\n\n        VMW_CBPRN(\"Set: Update VLAN filters\");\n\n        vmxnet3_update_vlan_filters(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_UPDATE_MAC_FILTERS:\n\n        VMW_CBPRN(\"Set: Update MAC filters\");\n\n        vmxnet3_update_mcast_filters(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_UPDATE_FEATURE:\n\n        VMW_CBPRN(\"Set: Update features\");\n\n        vmxnet3_update_features(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_UPDATE_PMCFG:\n\n        VMW_CBPRN(\"Set: Update power management config\");\n\n        vmxnet3_update_pm_state(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_GET_LINK:\n\n        VMW_CBPRN(\"Set: Get link\");\n\n        break;\n\n\n\n    case VMXNET3_CMD_RESET_DEV:\n\n        VMW_CBPRN(\"Set: Reset device\");\n\n        vmxnet3_reset(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_QUIESCE_DEV:\n\n        VMW_CBPRN(\"Set: VMXNET3_CMD_QUIESCE_DEV - pause the device\");\n\n        vmxnet3_deactivate_device(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_GET_CONF_INTR:\n\n        VMW_CBPRN(\"Set: VMXNET3_CMD_GET_CONF_INTR - interrupt configuration\");\n\n        break;\n\n\n\n    case VMXNET3_CMD_GET_ADAPTIVE_RING_INFO:\n\n        VMW_CBPRN(\"Set: VMXNET3_CMD_GET_ADAPTIVE_RING_INFO - \"\n\n                  \"adaptive ring info flags\");\n\n        break;\n\n\n\n    default:\n\n        VMW_CBPRN(\"Received unknown command: %\" PRIx64, cmd);\n\n        break;\n\n    }\n\n}\n", "idx": 22226, "_split": "valid", "_hash": "2d7292b20aa43df9d8259f9024360dbd"}
{"project": "qemu", "commit_id": "5cbab1bfdeab274e5d4e3353fa626ba8697eed10", "target": 1, "func": "static void kvm_s390_flic_realize(DeviceState *dev, Error **errp)\n\n{\n\n    KVMS390FLICState *flic_state = KVM_S390_FLIC(dev);\n\n    struct kvm_create_device cd = {0};\n\n    struct kvm_device_attr test_attr = {0};\n\n    int ret;\n\n    Error *errp_local = NULL;\n\n\n\n\n\n\n\n    flic_state->fd = -1;\n\n    if (!kvm_check_extension(kvm_state, KVM_CAP_DEVICE_CTRL)) {\n\n        error_setg_errno(&errp_local, errno, \"KVM is missing capability\"\n\n                         \" KVM_CAP_DEVICE_CTRL\");\n\n        trace_flic_no_device_api(errno);\n\n\n\n\n\n    cd.type = KVM_DEV_TYPE_FLIC;\n\n    ret = kvm_vm_ioctl(kvm_state, KVM_CREATE_DEVICE, &cd);\n\n    if (ret < 0) {\n\n        error_setg_errno(&errp_local, errno, \"Creating the KVM device failed\");\n\n        trace_flic_create_device(errno);\n\n\n\n    flic_state->fd = cd.fd;\n\n\n\n    /* Check clear_io_irq support */\n\n    test_attr.group = KVM_DEV_FLIC_CLEAR_IO_IRQ;\n\n    flic_state->clear_io_supported = !ioctl(flic_state->fd,\n\n                                            KVM_HAS_DEVICE_ATTR, test_attr);\n\n\n\n    return;\n\nfail:\n\n    error_propagate(errp, errp_local);\n", "idx": 22236, "_split": "valid", "_hash": "bad5a9d0b00266bdc11eb8435e628277"}
{"project": "qemu", "commit_id": "a86156401559cb4401cf9ecc704faeab6fc8bb19", "target": 1, "func": "static void test_visitor_out_empty(TestOutputVisitorData *data,\n\n                                   const void *unused)\n\n{\n\n    QObject *arg;\n\n\n\n    arg = qmp_output_get_qobject(data->qov);\n\n    g_assert(qobject_type(arg) == QTYPE_QNULL);\n\n\n\n    qobject_decref(arg);\n\n}", "idx": 22244, "_split": "valid", "_hash": "f3ff7f4028a5d7a2d953cf0dae9abd0b"}
{"project": "qemu", "commit_id": "2531088f6c1ce1f620f8d5a545f0af95598e69fc", "target": 1, "func": "uint32_t gic_acknowledge_irq(GICState *s, int cpu, MemTxAttrs attrs)\n\n{\n\n    int ret, irq, src;\n\n    int cm = 1 << cpu;\n\n\n\n    /* gic_get_current_pending_irq() will return 1022 or 1023 appropriately\n\n     * for the case where this GIC supports grouping and the pending interrupt\n\n     * is in the wrong group.\n\n     */\n\n    irq = gic_get_current_pending_irq(s, cpu, attrs);\n\n\n\n\n    if (irq >= GIC_MAXIRQ) {\n\n        DPRINTF(\"ACK, no pending interrupt or it is hidden: %d\\n\", irq);\n\n        return irq;\n\n    }\n\n\n\n    if (GIC_GET_PRIORITY(irq, cpu) >= s->running_priority[cpu]) {\n\n        DPRINTF(\"ACK, pending interrupt (%d) has insufficient priority\\n\", irq);\n\n        return 1023;\n\n    }\n\n\n\n    if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {\n\n        /* Clear pending flags for both level and edge triggered interrupts.\n\n         * Level triggered IRQs will be reasserted once they become inactive.\n\n         */\n\n        GIC_CLEAR_PENDING(irq, GIC_TEST_MODEL(irq) ? ALL_CPU_MASK : cm);\n\n        ret = irq;\n\n    } else {\n\n        if (irq < GIC_NR_SGIS) {\n\n            /* Lookup the source CPU for the SGI and clear this in the\n\n             * sgi_pending map.  Return the src and clear the overall pending\n\n             * state on this CPU if the SGI is not pending from any CPUs.\n\n             */\n\n            assert(s->sgi_pending[irq][cpu] != 0);\n\n            src = ctz32(s->sgi_pending[irq][cpu]);\n\n            s->sgi_pending[irq][cpu] &= ~(1 << src);\n\n            if (s->sgi_pending[irq][cpu] == 0) {\n\n                GIC_CLEAR_PENDING(irq, GIC_TEST_MODEL(irq) ? ALL_CPU_MASK : cm);\n\n            }\n\n            ret = irq | ((src & 0x7) << 10);\n\n        } else {\n\n            /* Clear pending state for both level and edge triggered\n\n             * interrupts. (level triggered interrupts with an active line\n\n             * remain pending, see gic_test_pending)\n\n             */\n\n            GIC_CLEAR_PENDING(irq, GIC_TEST_MODEL(irq) ? ALL_CPU_MASK : cm);\n\n            ret = irq;\n\n        }\n\n    }\n\n\n\n    gic_activate_irq(s, cpu, irq);\n\n    gic_update(s);\n\n    DPRINTF(\"ACK %d\\n\", irq);\n\n    return ret;\n\n}", "idx": 22261, "_split": "valid", "_hash": "42b7bf89007ea7f1511755c579c12569"}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void virtio_net_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    VirtIONet *n = opaque;\n\n    struct virtio_net_hdr_mrg_rxbuf *mhdr = NULL;\n\n    size_t hdr_len, offset, i;\n\n\n\n    if (!do_virtio_net_can_receive(n, size))\n\n        return;\n\n\n\n    if (!receive_filter(n, buf, size))\n\n        return;\n\n\n\n    /* hdr_len refers to the header we supply to the guest */\n\n    hdr_len = n->mergeable_rx_bufs ?\n\n        sizeof(struct virtio_net_hdr_mrg_rxbuf) : sizeof(struct virtio_net_hdr);\n\n\n\n    offset = i = 0;\n\n\n\n    while (offset < size) {\n\n        VirtQueueElement elem;\n\n        int len, total;\n\n        struct iovec sg[VIRTQUEUE_MAX_SIZE];\n\n\n\n        len = total = 0;\n\n\n\n        if ((i != 0 && !n->mergeable_rx_bufs) ||\n\n            virtqueue_pop(n->rx_vq, &elem) == 0) {\n\n            if (i == 0)\n\n                return;\n\n            fprintf(stderr, \"virtio-net truncating packet\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        if (elem.in_num < 1) {\n\n            fprintf(stderr, \"virtio-net receive queue contains no in buffers\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        if (!n->mergeable_rx_bufs && elem.in_sg[0].iov_len != hdr_len) {\n\n            fprintf(stderr, \"virtio-net header not in first element\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        memcpy(&sg, &elem.in_sg[0], sizeof(sg[0]) * elem.in_num);\n\n\n\n        if (i == 0) {\n\n            if (n->mergeable_rx_bufs)\n\n                mhdr = (struct virtio_net_hdr_mrg_rxbuf *)sg[0].iov_base;\n\n\n\n            offset += receive_header(n, sg, elem.in_num,\n\n                                     buf + offset, size - offset, hdr_len);\n\n            total += hdr_len;\n\n        }\n\n\n\n        /* copy in packet.  ugh */\n\n        len = iov_fill(sg, elem.in_num,\n\n                       buf + offset, size - offset);\n\n        total += len;\n\n\n\n        /* signal other side */\n\n        virtqueue_fill(n->rx_vq, &elem, total, i++);\n\n\n\n        offset += len;\n\n    }\n\n\n\n    if (mhdr)\n\n        mhdr->num_buffers = i;\n\n\n\n    virtqueue_flush(n->rx_vq, i);\n\n    virtio_notify(&n->vdev, n->rx_vq);\n\n}\n", "idx": 22269, "_split": "valid", "_hash": "1f6a8a54ebc0d7b3f4de18778837b6cf"}
{"project": "qemu", "commit_id": "0e7b176ae01d5a664d4cbf619a7315819494e6cb", "target": 0, "func": "static void aarch64_any_initfn(Object *obj)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(obj);\n\n\n\n    set_feature(&cpu->env, ARM_FEATURE_V8);\n\n    set_feature(&cpu->env, ARM_FEATURE_VFP4);\n\n    set_feature(&cpu->env, ARM_FEATURE_NEON);\n\n    set_feature(&cpu->env, ARM_FEATURE_AARCH64);\n\n    set_feature(&cpu->env, ARM_FEATURE_V8_AES);\n\n    set_feature(&cpu->env, ARM_FEATURE_V8_SHA1);\n\n    set_feature(&cpu->env, ARM_FEATURE_V8_SHA256);\n\n    set_feature(&cpu->env, ARM_FEATURE_V8_PMULL);\n\n    set_feature(&cpu->env, ARM_FEATURE_CRC);\n\n    cpu->ctr = 0x80030003; /* 32 byte I and D cacheline size, VIPT icache */\n\n    cpu->dcz_blocksize = 7; /*  512 bytes */\n\n}\n", "idx": 22291, "_split": "valid", "_hash": "39a27ef5e0ab86d70565906f2e8ac76c"}
{"project": "qemu", "commit_id": "82342e91b60a4a078811df4e1a545e57abffa11d", "target": 1, "func": "e1000e_set_icr(E1000ECore *core, int index, uint32_t val)\n\n{\n\n    if ((core->mac[ICR] & E1000_ICR_ASSERTED) &&\n\n        (core->mac[CTRL_EXT] & E1000_CTRL_EXT_IAME)) {\n\n        trace_e1000e_irq_icr_process_iame();\n\n        e1000e_clear_ims_bits(core, core->mac[IAM]);\n\n    }\n\n\n\n    trace_e1000e_irq_icr_write(val, core->mac[ICR], core->mac[ICR] & ~val);\n\n    core->mac[ICR] &= ~val;\n\n    e1000e_update_interrupt_state(core);\n\n}\n", "idx": 22315, "_split": "valid", "_hash": "c09cb4474af2ca784db67c25872f6891"}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "MemoryRegionSection *phys_page_find(target_phys_addr_t index)\n\n{\n\n    PhysPageEntry lp = phys_map;\n\n    PhysPageEntry *p;\n\n    int i;\n\n    uint16_t s_index = phys_section_unassigned;\n\n\n\n    for (i = P_L2_LEVELS - 1; i >= 0 && !lp.is_leaf; i--) {\n\n        if (lp.ptr == PHYS_MAP_NODE_NIL) {\n\n            goto not_found;\n\n        }\n\n        p = phys_map_nodes[lp.ptr];\n\n        lp = p[(index >> (i * L2_BITS)) & (L2_SIZE - 1)];\n\n    }\n\n\n\n    s_index = lp.ptr;\n\nnot_found:\n\n    return &phys_sections[s_index];\n\n}\n", "idx": 22331, "_split": "valid", "_hash": "7f9a8bcdef3fde9f2cadf0dc329fa988"}
{"project": "qemu", "commit_id": "ef76dc59fa5203d146a2acf85a0ad5a5971a4824", "target": 0, "func": "START_TEST(float_number)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        double decoded;\n\n        int skip;\n\n    } test_cases[] = {\n\n        { \"32.43\", 32.43 },\n\n        { \"0.222\", 0.222 },\n\n        { \"-32.12313\", -32.12313 },\n\n        { \"-32.20e-10\", -32.20e-10, .skip = 1 },\n\n        { },\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QFloat *qfloat;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded);\n\n        fail_unless(obj != NULL);\n\n        fail_unless(qobject_type(obj) == QTYPE_QFLOAT);\n\n\n\n        qfloat = qobject_to_qfloat(obj);\n\n        fail_unless(qfloat_get_double(qfloat) == test_cases[i].decoded);\n\n\n\n        if (test_cases[i].skip == 0) {\n\n            QString *str;\n\n\n\n            str = qobject_to_json(obj);\n\n            fail_unless(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);\n\n            QDECREF(str);\n\n        }\n\n\n\n        QDECREF(qfloat);\n\n    }\n\n}\n", "idx": 22334, "_split": "valid", "_hash": "78565447743e3dd80be404e53e2b1ecf"}
{"project": "qemu", "commit_id": "488d65772ce94aa439f26d7136db384aec460bcb", "target": 1, "func": "static void check_watchpoint(int offset, int len_mask, int flags)\n\n{\n\n    CPUState *env = cpu_single_env;\n\n    target_ulong pc, cs_base;\n\n    TranslationBlock *tb;\n\n    target_ulong vaddr;\n\n    CPUWatchpoint *wp;\n\n    int cpu_flags;\n\n\n\n    if (env->watchpoint_hit) {\n\n        /* We re-entered the check after replacing the TB. Now raise\n\n         * the debug interrupt so that is will trigger after the\n\n         * current instruction. */\n\n        cpu_interrupt(env, CPU_INTERRUPT_DEBUG);\n\n        return;\n\n    }\n\n    vaddr = (env->mem_io_vaddr & TARGET_PAGE_MASK) + offset;\n\n    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {\n\n        if ((vaddr == (wp->vaddr & len_mask) ||\n\n             (vaddr & wp->len_mask) == wp->vaddr) && (wp->flags & flags)) {\n\n            wp->flags |= BP_WATCHPOINT_HIT;\n\n            if (!env->watchpoint_hit) {\n\n                env->watchpoint_hit = wp;\n\n                tb = tb_find_pc(env->mem_io_pc);\n\n                if (!tb) {\n\n                    cpu_abort(env, \"check_watchpoint: could not find TB for \"\n\n                              \"pc=%p\", (void *)env->mem_io_pc);\n\n                }\n\n                cpu_restore_state(tb, env, env->mem_io_pc);\n\n                tb_phys_invalidate(tb, -1);\n\n                if (wp->flags & BP_STOP_BEFORE_ACCESS) {\n\n                    env->exception_index = EXCP_DEBUG;\n\n                } else {\n\n                    cpu_get_tb_cpu_state(env, &pc, &cs_base, &cpu_flags);\n\n                    tb_gen_code(env, pc, cs_base, cpu_flags, 1);\n\n                }\n\n                cpu_resume_from_signal(env, NULL);\n\n            }\n\n        } else {\n\n            wp->flags &= ~BP_WATCHPOINT_HIT;\n\n        }\n\n    }\n\n}\n", "idx": 22350, "_split": "valid", "_hash": "984e3b6a0168f4eed6fd653107b4ae6f"}
{"project": "qemu", "commit_id": "d4370741402a97b8b6d0c38fef18ab38bf25ab22", "target": 1, "func": "static gboolean gd_vc_in(GIOChannel *chan, GIOCondition cond, void *opaque)\n\n{\n\n    VirtualConsole *vc = opaque;\n\n    uint8_t buffer[1024];\n\n    ssize_t len;\n\n\n\n    len = read(vc->fd, buffer, sizeof(buffer));\n\n    if (len <= 0) {\n\n        return FALSE;\n\n    }\n\n\n\n    qemu_chr_be_write(vc->chr, buffer, len);\n\n\n\n    return TRUE;\n\n}\n", "idx": 22368, "_split": "valid", "_hash": "fa12d80df055accb59cf35c9143a00b9"}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static void vnc_write_s32(VncState *vs, int32_t value)\n\n{\n\n    vnc_write_u32(vs, *(uint32_t *)&value);\n\n}\n", "idx": 22415, "_split": "valid", "_hash": "6c11ea6f0ca0fcd30222dd4f1743d18d"}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static int vnc_zlib_stop(VncState *vs)\n\n{\n\n    z_streamp zstream = &vs->zlib_stream;\n\n    int previous_out;\n\n\n\n    // switch back to normal output/zlib buffers\n\n    vs->zlib = vs->output;\n\n    vs->output = vs->zlib_tmp;\n\n\n\n    // compress the zlib buffer\n\n\n\n    // initialize the stream\n\n    // XXX need one stream per session\n\n    if (zstream->opaque != vs) {\n\n        int err;\n\n\n\n        VNC_DEBUG(\"VNC: initializing zlib stream\\n\");\n\n        VNC_DEBUG(\"VNC: opaque = %p | vs = %p\\n\", zstream->opaque, vs);\n\n        zstream->zalloc = vnc_zlib_zalloc;\n\n        zstream->zfree = vnc_zlib_zfree;\n\n\n\n        err = deflateInit2(zstream, vs->tight_compression, Z_DEFLATED, MAX_WBITS,\n\n                           MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n\n\n\n        if (err != Z_OK) {\n\n            fprintf(stderr, \"VNC: error initializing zlib\\n\");\n\n            return -1;\n\n        }\n\n\n\n        vs->zlib_level = vs->tight_compression;\n\n        zstream->opaque = vs;\n\n    }\n\n\n\n    if (vs->tight_compression != vs->zlib_level) {\n\n        if (deflateParams(zstream, vs->tight_compression,\n\n                          Z_DEFAULT_STRATEGY) != Z_OK) {\n\n            return -1;\n\n        }\n\n        vs->zlib_level = vs->tight_compression;\n\n    }\n\n\n\n    // reserve memory in output buffer\n\n    buffer_reserve(&vs->output, vs->zlib.offset + 64);\n\n\n\n    // set pointers\n\n    zstream->next_in = vs->zlib.buffer;\n\n    zstream->avail_in = vs->zlib.offset;\n\n    zstream->next_out = vs->output.buffer + vs->output.offset;\n\n    zstream->avail_out = vs->output.capacity - vs->output.offset;\n\n    zstream->data_type = Z_BINARY;\n\n    previous_out = zstream->total_out;\n\n\n\n    // start encoding\n\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n\n        fprintf(stderr, \"VNC: error during zlib compression\\n\");\n\n        return -1;\n\n    }\n\n\n\n    vs->output.offset = vs->output.capacity - zstream->avail_out;\n\n    return zstream->total_out - previous_out;\n\n}\n", "idx": 22423, "_split": "valid", "_hash": "f71ff58ebee59746465fdc4fc3d79081"}
{"project": "qemu", "commit_id": "4828b10bda6a74a22a7695303e0648157d0e3ea4", "target": 0, "func": "void acpi_memory_plug_cb(ACPIREGS *ar, qemu_irq irq, MemHotplugState *mem_st,\n\n                         DeviceState *dev, Error **errp)\n\n{\n\n    MemStatus *mdev;\n\n\n\n    mdev = acpi_memory_slot_status(mem_st, dev, errp);\n\n    if (!mdev) {\n\n        return;\n\n    }\n\n\n\n    mdev->dimm = dev;\n\n    mdev->is_enabled = true;\n\n    mdev->is_inserting = true;\n\n\n\n    /* do ACPI magic */\n\n    acpi_send_gpe_event(ar, irq, ACPI_MEMORY_HOTPLUG_STATUS);\n\n    return;\n\n}\n", "idx": 22477, "_split": "valid", "_hash": "4fed37cf2eceeafd8d603de77d779077"}
{"project": "qemu", "commit_id": "dd4d607e40dcd2cb7646b510504880a70939d91b", "target": 0, "func": "static int vtd_page_walk(VTDContextEntry *ce, uint64_t start, uint64_t end,\n\n                         vtd_page_walk_hook hook_fn, void *private)\n\n{\n\n    dma_addr_t addr = vtd_get_slpt_base_from_context(ce);\n\n    uint32_t level = vtd_get_level_from_context_entry(ce);\n\n\n\n    if (!vtd_iova_range_check(start, ce)) {\n\n        return -VTD_FR_ADDR_BEYOND_MGAW;\n\n    }\n\n\n\n    if (!vtd_iova_range_check(end, ce)) {\n\n        /* Fix end so that it reaches the maximum */\n\n        end = vtd_iova_limit(ce);\n\n    }\n\n\n\n    return vtd_page_walk_level(addr, start, end, hook_fn, private,\n\n                               level, true, true, false);\n\n}\n", "idx": 22482, "_split": "valid", "_hash": "eac7fcb78830346e9a0cf86a55ce62bb"}
{"project": "qemu", "commit_id": "08844473820c93541fc47bdfeae0f2cc88cfab59", "target": 0, "func": "static int coroutine_fn bdrv_co_readv_em(BlockDriverState *bs,\n\n                                         int64_t sector_num, int nb_sectors,\n\n                                         QEMUIOVector *iov)\n\n{\n\n    return bdrv_co_io_em(bs, sector_num, nb_sectors, iov, false);\n\n}\n", "idx": 22483, "_split": "valid", "_hash": "163c3a69f6ae393ac2530d8f13d818e9"}
{"project": "qemu", "commit_id": "5e30a07d6d70d3073ff61e6db79d61c2b688502f", "target": 1, "func": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    int32_t len;\n\n    uint8_t command;\n\n    uint8_t *outbuf;\n\n    int rc;\n\n\n\n    command = buf[0];\n\n    outbuf = (uint8_t *)r->iov.iov_base;\n\n    DPRINTF(\"Command: lun=%d tag=0x%x data=0x%02x\", req->lun, req->tag, buf[0]);\n\n\n\n    if (scsi_req_parse(&r->req, buf) != 0) {\n\n        BADF(\"Unsupported command length, command %x\\n\", command);\n\n        scsi_command_complete(r, CHECK_CONDITION, SENSE_CODE(INVALID_OPCODE));\n\n        return 0;\n\n    }\n\n#ifdef DEBUG_SCSI\n\n    {\n\n        int i;\n\n        for (i = 1; i < r->req.cmd.len; i++) {\n\n            printf(\" 0x%02x\", buf[i]);\n\n        }\n\n        printf(\"\\n\");\n\n    }\n\n#endif\n\n\n\n    if (req->lun) {\n\n        /* Only LUN 0 supported.  */\n\n        DPRINTF(\"Unimplemented LUN %d\\n\", req->lun);\n\n        if (command != REQUEST_SENSE && command != INQUIRY) {\n\n            scsi_command_complete(r, CHECK_CONDITION,\n\n                                  SENSE_CODE(LUN_NOT_SUPPORTED));\n\n            return 0;\n\n        }\n\n    }\n\n    switch (command) {\n\n    case TEST_UNIT_READY:\n\n    case REQUEST_SENSE:\n\n    case INQUIRY:\n\n    case MODE_SENSE:\n\n    case MODE_SENSE_10:\n\n    case RESERVE:\n\n    case RESERVE_10:\n\n    case RELEASE:\n\n    case RELEASE_10:\n\n    case START_STOP:\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n    case READ_CAPACITY:\n\n    case SYNCHRONIZE_CACHE:\n\n    case READ_TOC:\n\n    case GET_CONFIGURATION:\n\n    case SERVICE_ACTION_IN:\n\n    case REPORT_LUNS:\n\n    case VERIFY:\n\n        rc = scsi_disk_emulate_command(r, outbuf);\n\n        if (rc < 0) {\n\n            return 0;\n\n        }\n\n\n\n        r->iov.iov_len = rc;\n\n        break;\n\n    case READ_6:\n\n    case READ_10:\n\n    case READ_12:\n\n    case READ_16:\n\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n\n        DPRINTF(\"Read (sector %\" PRId64 \", count %d)\\n\", r->req.cmd.lba, len);\n\n        if (r->req.cmd.lba > s->max_lba)\n\n            goto illegal_lba;\n\n        r->sector = r->req.cmd.lba * s->cluster_size;\n\n        r->sector_count = len * s->cluster_size;\n\n        break;\n\n    case WRITE_6:\n\n    case WRITE_10:\n\n    case WRITE_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_VERIFY_16:\n\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n\n        DPRINTF(\"Write %s(sector %\" PRId64 \", count %d)\\n\",\n\n                (command & 0xe) == 0xe ? \"And Verify \" : \"\",\n\n                r->req.cmd.lba, len);\n\n        if (r->req.cmd.lba > s->max_lba)\n\n            goto illegal_lba;\n\n        r->sector = r->req.cmd.lba * s->cluster_size;\n\n        r->sector_count = len * s->cluster_size;\n\n        break;\n\n    case MODE_SELECT:\n\n        DPRINTF(\"Mode Select(6) (len %lu)\\n\", (long)r->req.cmd.xfer);\n\n        /* We don't support mode parameter changes.\n\n           Allow the mode parameter header + block descriptors only. */\n\n        if (r->req.cmd.xfer > 12) {\n\n            goto fail;\n\n        }\n\n        break;\n\n    case MODE_SELECT_10:\n\n        DPRINTF(\"Mode Select(10) (len %lu)\\n\", (long)r->req.cmd.xfer);\n\n        /* We don't support mode parameter changes.\n\n           Allow the mode parameter header + block descriptors only. */\n\n        if (r->req.cmd.xfer > 16) {\n\n            goto fail;\n\n        }\n\n        break;\n\n    case SEEK_6:\n\n    case SEEK_10:\n\n        DPRINTF(\"Seek(%d) (sector %\" PRId64 \")\\n\", command == SEEK_6 ? 6 : 10,\n\n                r->req.cmd.lba);\n\n        if (r->req.cmd.lba > s->max_lba) {\n\n            goto illegal_lba;\n\n        }\n\n        break;\n\n    case WRITE_SAME_16:\n\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n\n\n\n        DPRINTF(\"WRITE SAME(16) (sector %\" PRId64 \", count %d)\\n\",\n\n                r->req.cmd.lba, len);\n\n\n\n        if (r->req.cmd.lba > s->max_lba) {\n\n            goto illegal_lba;\n\n        }\n\n\n\n        /*\n\n         * We only support WRITE SAME with the unmap bit set for now.\n\n         */\n\n        if (!(buf[1] & 0x8)) {\n\n            goto fail;\n\n        }\n\n\n\n        rc = bdrv_discard(s->bs, r->req.cmd.lba * s->cluster_size,\n\n                          len * s->cluster_size);\n\n        if (rc < 0) {\n\n            /* XXX: better error code ?*/\n\n            goto fail;\n\n        }\n\n\n\n        break;\n\n    default:\n\n        DPRINTF(\"Unknown SCSI command (%2.2x)\\n\", buf[0]);\n\n        scsi_command_complete(r, CHECK_CONDITION, SENSE_CODE(INVALID_OPCODE));\n\n        return 0;\n\n    fail:\n\n        scsi_command_complete(r, CHECK_CONDITION, SENSE_CODE(INVALID_FIELD));\n\n        return 0;\n\n    illegal_lba:\n\n        scsi_command_complete(r, CHECK_CONDITION, SENSE_CODE(LBA_OUT_OF_RANGE));\n\n        return 0;\n\n    }\n\n    if (r->sector_count == 0 && r->iov.iov_len == 0) {\n\n        scsi_command_complete(r, GOOD, SENSE_CODE(NO_SENSE));\n\n    }\n\n    len = r->sector_count * 512 + r->iov.iov_len;\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n\n        return -len;\n\n    } else {\n\n        if (!r->sector_count)\n\n            r->sector_count = -1;\n\n        return len;\n\n    }\n\n}\n", "idx": 22494, "_split": "valid", "_hash": "d7d6765992fd8580f2e99255cd14a7ee"}
{"project": "qemu", "commit_id": "5706db1deb061ee9affdcea81e59c4c2cad7c41e", "target": 1, "func": "static int wav_init_out (HWVoiceOut *hw, struct audsettings *as)\n\n{\n\n    WAVVoiceOut *wav = (WAVVoiceOut *) hw;\n\n    int bits16 = 0, stereo = 0;\n\n    uint8_t hdr[] = {\n\n        0x52, 0x49, 0x46, 0x46, 0x00, 0x00, 0x00, 0x00, 0x57, 0x41, 0x56,\n\n        0x45, 0x66, 0x6d, 0x74, 0x20, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00,\n\n        0x02, 0x00, 0x44, 0xac, 0x00, 0x00, 0x10, 0xb1, 0x02, 0x00, 0x04,\n\n        0x00, 0x10, 0x00, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00\n\n    };\n\n    struct audsettings wav_as = conf.settings;\n\n\n\n    (void) as;\n\n\n\n    stereo = wav_as.nchannels == 2;\n\n    switch (wav_as.fmt) {\n\n    case AUD_FMT_S8:\n\n    case AUD_FMT_U8:\n\n        bits16 = 0;\n\n        break;\n\n\n\n    case AUD_FMT_S16:\n\n    case AUD_FMT_U16:\n\n        bits16 = 1;\n\n        break;\n\n\n\n    case AUD_FMT_S32:\n\n    case AUD_FMT_U32:\n\n        dolog (\"WAVE files can not handle 32bit formats\\n\");\n\n        return -1;\n\n    }\n\n\n\n    hdr[34] = bits16 ? 0x10 : 0x08;\n\n\n\n    wav_as.endianness = 0;\n\n    audio_pcm_init_info (&hw->info, &wav_as);\n\n\n\n    hw->samples = 1024;\n\n    wav->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    if (!wav->pcm_buf) {\n\n        dolog (\"Could not allocate buffer (%d bytes)\\n\",\n\n               hw->samples << hw->info.shift);\n\n        return -1;\n\n    }\n\n\n\n    le_store (hdr + 22, hw->info.nchannels, 2);\n\n    le_store (hdr + 24, hw->info.freq, 4);\n\n    le_store (hdr + 28, hw->info.freq << (bits16 + stereo), 4);\n\n    le_store (hdr + 32, 1 << (bits16 + stereo), 2);\n\n\n\n    wav->f = fopen (conf.wav_path, \"wb\");\n\n    if (!wav->f) {\n\n        dolog (\"Failed to open wave file `%s'\\nReason: %s\\n\",\n\n               conf.wav_path, strerror (errno));\n\n        g_free (wav->pcm_buf);\n\n        wav->pcm_buf = NULL;\n\n        return -1;\n\n    }\n\n\n\n    if (fwrite (hdr, sizeof (hdr), 1, wav->f) != 1) {\n\n        dolog (\"wav_init_out: failed to write header\\nReason: %s\\n\",\n\n               strerror(errno));\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22507, "_split": "valid", "_hash": "f8e18d2ae01c4100fbfae2c9964da827"}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void t_gen_cc_jmp(TCGv pc_true, TCGv pc_false)\n\n{\n\n\tTCGv btaken;\n\n\tint l1;\n\n\n\n\tl1 = gen_new_label();\n\n\tbtaken = tcg_temp_new(TCG_TYPE_TL);\n\n\n\n\t/* Conditional jmp.  */\n\n\ttcg_gen_mov_tl(btaken, env_btaken);\n\n\ttcg_gen_mov_tl(env_pc, pc_false);\n\n\ttcg_gen_brcondi_tl(TCG_COND_EQ, btaken, 0, l1);\n\n\ttcg_gen_mov_tl(env_pc, pc_true);\n\n\tgen_set_label(l1);\n\n\n\n\ttcg_temp_free(btaken);\n\n}\n", "idx": 22546, "_split": "valid", "_hash": "12def6ee171d58dff1634e5210f0459e"}
{"project": "qemu", "commit_id": "958c717df97ea9ca47a2253b8371130fe5f22980", "target": 0, "func": "NBDClient *nbd_client_new(NBDExport *exp, int csock,\n\n                          void (*close)(NBDClient *))\n\n{\n\n    NBDClient *client;\n\n    client = g_malloc0(sizeof(NBDClient));\n\n    client->refcount = 1;\n\n    client->exp = exp;\n\n    client->sock = csock;\n\n    if (nbd_send_negotiate(client)) {\n\n        g_free(client);\n\n        return NULL;\n\n    }\n\n    client->close = close;\n\n    qemu_co_mutex_init(&client->send_lock);\n\n    qemu_set_fd_handler2(csock, nbd_can_read, nbd_read, NULL, client);\n\n\n\n    if (exp) {\n\n        QTAILQ_INSERT_TAIL(&exp->clients, client, next);\n\n        nbd_export_get(exp);\n\n    }\n\n    return client;\n\n}\n", "idx": 22547, "_split": "valid", "_hash": "671ed2219d7c2378c34b16d99ad60d58"}
{"project": "qemu", "commit_id": "7e84c2498f0ff3999937d18d1e9abaa030400000", "target": 0, "func": "void helper_ljmp_protected_T0_T1(void)\n\n{\n\n    int new_cs, new_eip;\n\n    uint32_t e1, e2, cpl, dpl, rpl, limit;\n\n\n\n    new_cs = T0;\n\n    new_eip = T1;\n\n    if ((new_cs & 0xfffc) == 0)\n\n        raise_exception_err(EXCP0D_GPF, 0);\n\n    if (load_segment(&e1, &e2, new_cs) != 0)\n\n        raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    if (e2 & DESC_S_MASK) {\n\n        if (!(e2 & DESC_CS_MASK))\n\n            raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);\n\n        dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n        if (e2 & DESC_CS_MASK) {\n\n            /* conforming code segment */\n\n            if (dpl > cpl)\n\n                raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);\n\n        } else {\n\n            /* non conforming code segment */\n\n            rpl = new_cs & 3;\n\n            if (rpl > cpl)\n\n                raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);\n\n            if (dpl != cpl)\n\n                raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);\n\n        }\n\n        if (!(e2 & DESC_P_MASK))\n\n            raise_exception_err(EXCP0B_NOSEG, new_cs & 0xfffc);\n\n        limit = get_seg_limit(e1, e2);\n\n        if (new_eip > limit)\n\n            raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);\n\n        cpu_x86_load_seg_cache(env, R_CS, (new_cs & 0xfffc) | cpl,\n\n                       get_seg_base(e1, e2), limit, e2);\n\n        EIP = new_eip;\n\n    } else {\n\n        cpu_abort(env, \"jmp to call/task gate not supported 0x%04x:0x%08x\", \n\n                  new_cs, new_eip);\n\n    }\n\n}\n", "idx": 22553, "_split": "valid", "_hash": "37d88050ffcb65e2fa58c2dd70c54d3a"}
{"project": "qemu", "commit_id": "b53dd4495ced2432a0b652ea895e651d07336f7e", "target": 1, "func": "static void usb_xhci_exit(PCIDevice *dev)\n\n{\n\n    int i;\n\n    XHCIState *xhci = XHCI(dev);\n\n\n\n    trace_usb_xhci_exit();\n\n\n\n    for (i = 0; i < xhci->numslots; i++) {\n\n        xhci_disable_slot(xhci, i + 1);\n\n    }\n\n\n\n    if (xhci->mfwrap_timer) {\n\n        timer_del(xhci->mfwrap_timer);\n\n        timer_free(xhci->mfwrap_timer);\n\n        xhci->mfwrap_timer = NULL;\n\n    }\n\n\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);\n\n\n\n    for (i = 0; i < xhci->numports; i++) {\n\n        XHCIPort *port = &xhci->ports[i];\n\n        memory_region_del_subregion(&xhci->mem, &port->mem);\n\n    }\n\n\n\n    /* destroy msix memory region */\n\n    if (dev->msix_table && dev->msix_pba\n\n        && dev->msix_entry_used) {\n\n        memory_region_del_subregion(&xhci->mem, &dev->msix_table_mmio);\n\n        memory_region_del_subregion(&xhci->mem, &dev->msix_pba_mmio);\n\n    }\n\n\n\n    usb_bus_release(&xhci->bus);\n\n}\n", "idx": 22619, "_split": "valid", "_hash": "d8f82e95b1ee51812a85b5986b80957d"}
{"project": "qemu", "commit_id": "f03a1af581b926118d619ad1acc3304ad84d5e5b", "target": 1, "func": "static void init_excp_POWER7 (CPUPPCState *env)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;\n\n    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;\n\n    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;\n\n    env->excp_vectors[POWERPC_EXCP_DSEG]     = 0x00000380;\n\n    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;\n\n    env->excp_vectors[POWERPC_EXCP_ISEG]     = 0x00000480;\n\n    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;\n\n    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;\n\n    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;\n\n    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;\n\n    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;\n\n    env->excp_vectors[POWERPC_EXCP_HDECR]    = 0x00000980;\n\n    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;\n\n    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;\n\n    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;\n\n    env->excp_vectors[POWERPC_EXCP_VPU]      = 0x00000F20;\n\n    env->excp_vectors[POWERPC_EXCP_VSXU]     = 0x00000F40;\n\n    env->excp_vectors[POWERPC_EXCP_FU]       = 0x00000F60;\n\n    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;\n\n    env->excp_vectors[POWERPC_EXCP_MAINT]    = 0x00001600;\n\n    env->excp_vectors[POWERPC_EXCP_VPUA]     = 0x00001700;\n\n    env->excp_vectors[POWERPC_EXCP_THERM]    = 0x00001800;\n\n    /* Hardware reset vector */\n\n    env->hreset_vector = 0x0000000000000100ULL;\n\n#endif\n\n}\n", "idx": 22640, "_split": "valid", "_hash": "dc2bef38dde92ac479cfee0e2b8d0a99"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int socket_get_fd(void *opaque)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n\n\n    return s->fd;\n\n}\n", "idx": 22666, "_split": "valid", "_hash": "ff2270ffe565540cc12fc17308de957e"}
{"project": "qemu", "commit_id": "966439a67830239a6c520c5df6c55627b8153c8b", "target": 1, "func": "void do_addmeo_64 (void)\n\n{\n\n    T1 = T0;\n\n    T0 += xer_ca + (-1);\n\n    if (likely(!((uint64_t)T1 &\n\n                 ((uint64_t)T1 ^ (uint64_t)T0) & (1ULL << 63)))) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n    }\n\n    if (likely(T1 != 0))\n\n        xer_ca = 1;\n\n}\n", "idx": 22688, "_split": "valid", "_hash": "407d3c54e0f6f96d0d6dcbe5e4ec9850"}
{"project": "qemu", "commit_id": "32c813e6c2a857b93b897901b7e20281397528a3", "target": 0, "func": "size_t qcrypto_cipher_get_key_len(QCryptoCipherAlgorithm alg)\n\n{\n\n    if (alg >= G_N_ELEMENTS(alg_key_len)) {\n\n        return 0;\n\n    }\n\n    return alg_key_len[alg];\n\n}\n", "idx": 22724, "_split": "valid", "_hash": "948fa37b598c395d6d220c6713dfcc5e"}
{"project": "qemu", "commit_id": "dc523cd348c47372faa7271c9aab2030f94c290d", "target": 0, "func": "static int img_amend(int argc, char **argv)\n\n{\n\n    int c, ret = 0;\n\n    char *options = NULL;\n\n    QemuOptsList *create_opts = NULL;\n\n    QemuOpts *opts = NULL;\n\n    const char *fmt = NULL, *filename, *cache;\n\n    int flags;\n\n    bool quiet = false, progress = false;\n\n    BlockBackend *blk = NULL;\n\n    BlockDriverState *bs = NULL;\n\n\n\n    cache = BDRV_DEFAULT_CACHE;\n\n    for (;;) {\n\n        c = getopt(argc, argv, \"ho:f:t:pq\");\n\n        if (c == -1) {\n\n            break;\n\n        }\n\n\n\n        switch (c) {\n\n            case 'h':\n\n            case '?':\n\n                help();\n\n                break;\n\n            case 'o':\n\n                if (!is_valid_option_list(optarg)) {\n\n                    error_report(\"Invalid option list: %s\", optarg);\n\n                    ret = -1;\n\n                    goto out;\n\n                }\n\n                if (!options) {\n\n                    options = g_strdup(optarg);\n\n                } else {\n\n                    char *old_options = options;\n\n                    options = g_strdup_printf(\"%s,%s\", options, optarg);\n\n                    g_free(old_options);\n\n                }\n\n                break;\n\n            case 'f':\n\n                fmt = optarg;\n\n                break;\n\n            case 't':\n\n                cache = optarg;\n\n                break;\n\n            case 'p':\n\n                progress = true;\n\n                break;\n\n            case 'q':\n\n                quiet = true;\n\n                break;\n\n        }\n\n    }\n\n\n\n    if (!options) {\n\n        error_exit(\"Must specify options (-o)\");\n\n    }\n\n\n\n    if (quiet) {\n\n        progress = false;\n\n    }\n\n    qemu_progress_init(progress, 1.0);\n\n\n\n    filename = (optind == argc - 1) ? argv[argc - 1] : NULL;\n\n    if (fmt && has_help_option(options)) {\n\n        /* If a format is explicitly specified (and possibly no filename is\n\n         * given), print option help here */\n\n        ret = print_block_option_help(filename, fmt);\n\n        goto out;\n\n    }\n\n\n\n    if (optind != argc - 1) {\n\n        error_report(\"Expecting one image file name\");\n\n        ret = -1;\n\n        goto out;\n\n    }\n\n\n\n    flags = BDRV_O_FLAGS | BDRV_O_RDWR;\n\n    ret = bdrv_parse_cache_flags(cache, &flags);\n\n    if (ret < 0) {\n\n        error_report(\"Invalid cache option: %s\", cache);\n\n        goto out;\n\n    }\n\n\n\n    blk = img_open(\"image\", filename, fmt, flags, true, quiet);\n\n    if (!blk) {\n\n        ret = -1;\n\n        goto out;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    fmt = bs->drv->format_name;\n\n\n\n    if (has_help_option(options)) {\n\n        /* If the format was auto-detected, print option help here */\n\n        ret = print_block_option_help(filename, fmt);\n\n        goto out;\n\n    }\n\n\n\n    if (!bs->drv->create_opts) {\n\n        error_report(\"Format driver '%s' does not support any options to amend\",\n\n                     fmt);\n\n        ret = -1;\n\n        goto out;\n\n    }\n\n\n\n    create_opts = qemu_opts_append(create_opts, bs->drv->create_opts);\n\n    opts = qemu_opts_create(create_opts, NULL, 0, &error_abort);\n\n    if (options && qemu_opts_do_parse(opts, options, NULL)) {\n\n        error_report(\"Invalid options for file format '%s'\", fmt);\n\n        ret = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* In case the driver does not call amend_status_cb() */\n\n    qemu_progress_print(0.f, 0);\n\n    ret = bdrv_amend_options(bs, opts, &amend_status_cb);\n\n    qemu_progress_print(100.f, 0);\n\n    if (ret < 0) {\n\n        error_report(\"Error while amending options: %s\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    qemu_progress_end();\n\n\n\n    blk_unref(blk);\n\n    qemu_opts_del(opts);\n\n    qemu_opts_free(create_opts);\n\n    g_free(options);\n\n\n\n    if (ret) {\n\n        return 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22739, "_split": "valid", "_hash": "1ae7349fe7e69594d0fe4213a37cd712"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void channel_load_g(struct fs_dma_ctrl *ctrl, int c)\n\n{\n\n\ttarget_phys_addr_t addr = channel_reg(ctrl, c, RW_GROUP);\n\n\n\n\t/* Load and decode. FIXME: handle endianness.  */\n\n\tcpu_physical_memory_read (addr, \n\n\t\t\t\t  (void *) &ctrl->channels[c].current_g, \n\n\t\t\t\t  sizeof ctrl->channels[c].current_g);\n\n}\n", "idx": 22753, "_split": "valid", "_hash": "bb84668d8ebf9e6d6c7989b770e9877a"}
{"project": "qemu", "commit_id": "2c5b1d2a479273cec4c1be491745f48b0808b508", "target": 0, "func": "uint32_t HELPER(rer)(CPUXtensaState *env, uint32_t addr)\n\n{\n\n    return address_space_ldl(env->address_space_er, addr,\n\n                             (MemTxAttrs){0}, NULL);\n\n}\n", "idx": 22774, "_split": "valid", "_hash": "c80b903ecc5360e4516d02923c741d93"}
{"project": "qemu", "commit_id": "3a5c76baf312d83cb77c8faa72c5f7a477effed0", "target": 0, "func": "static void sun4uv_init(MemoryRegion *address_space_mem,\n\n                        MachineState *machine,\n\n                        const struct hwdef *hwdef)\n\n{\n\n    SPARCCPU *cpu;\n\n    Nvram *nvram;\n\n    unsigned int i;\n\n    uint64_t initrd_addr, initrd_size, kernel_addr, kernel_size, kernel_entry;\n\n    PCIBus *pci_bus, *pci_bus2, *pci_bus3;\n\n    ISABus *isa_bus;\n\n    SysBusDevice *s;\n\n    qemu_irq *ivec_irqs, *pbm_irqs;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    DriveInfo *fd[MAX_FD];\n\n    FWCfgState *fw_cfg;\n\n\n\n    /* init CPUs */\n\n    cpu = cpu_devinit(machine->cpu_model, hwdef);\n\n\n\n    /* set up devices */\n\n    ram_init(0, machine->ram_size);\n\n\n\n    prom_init(hwdef->prom_addr, bios_name);\n\n\n\n    ivec_irqs = qemu_allocate_irqs(cpu_set_ivec_irq, cpu, IVEC_MAX);\n\n    pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, ivec_irqs, &pci_bus2,\n\n                           &pci_bus3, &pbm_irqs);\n\n    pci_vga_init(pci_bus);\n\n\n\n    // XXX Should be pci_bus3\n\n    isa_bus = pci_ebus_init(pci_bus, -1, pbm_irqs);\n\n\n\n    i = 0;\n\n    if (hwdef->console_serial_base) {\n\n        serial_mm_init(address_space_mem, hwdef->console_serial_base, 0,\n\n                       NULL, 115200, serial_hds[i], DEVICE_BIG_ENDIAN);\n\n        i++;\n\n    }\n\n\n\n    serial_hds_isa_init(isa_bus, MAX_SERIAL_PORTS);\n\n    parallel_hds_isa_init(isa_bus, MAX_PARALLEL_PORTS);\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init_nofail(&nd_table[i], pci_bus, \"ne2k_pci\", NULL);\n\n\n\n    ide_drive_get(hd, ARRAY_SIZE(hd));\n\n\n\n    pci_cmd646_ide_init(pci_bus, hd, 1);\n\n\n\n    isa_create_simple(isa_bus, \"i8042\");\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        fd[i] = drive_get(IF_FLOPPY, 0, i);\n\n    }\n\n    fdctrl_init_isa(isa_bus, fd);\n\n\n\n    /* Map NVRAM into I/O (ebus) space */\n\n    nvram = m48t59_init(NULL, 0, 0, NVRAM_SIZE, 1968, 59);\n\n    s = SYS_BUS_DEVICE(nvram);\n\n    memory_region_add_subregion(get_system_io(), 0x2000,\n\n                                sysbus_mmio_get_region(s, 0));\n\n \n\n    initrd_size = 0;\n\n    initrd_addr = 0;\n\n    kernel_size = sun4u_load_kernel(machine->kernel_filename,\n\n                                    machine->initrd_filename,\n\n                                    ram_size, &initrd_size, &initrd_addr,\n\n                                    &kernel_addr, &kernel_entry);\n\n\n\n    sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, \"Sun4u\", machine->ram_size,\n\n                           machine->boot_order,\n\n                           kernel_addr, kernel_size,\n\n                           machine->kernel_cmdline,\n\n                           initrd_addr, initrd_size,\n\n                           /* XXX: need an option to load a NVRAM image */\n\n                           0,\n\n                           graphic_width, graphic_height, graphic_depth,\n\n                           (uint8_t *)&nd_table[0].macaddr);\n\n\n\n    fw_cfg = fw_cfg_init_io(BIOS_CFG_IOPORT);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, (uint16_t)max_cpus);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_entry);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (machine->kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_CMDLINE_SIZE,\n\n                       strlen(machine->kernel_cmdline) + 1);\n\n        fw_cfg_add_string(fw_cfg, FW_CFG_CMDLINE_DATA, machine->kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_CMDLINE_SIZE, 0);\n\n    }\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_INITRD_ADDR, initrd_addr);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, machine->boot_order[0]);\n\n\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_SPARC64_WIDTH, graphic_width);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_SPARC64_HEIGHT, graphic_height);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_SPARC64_DEPTH, graphic_depth);\n\n\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}\n", "idx": 22775, "_split": "valid", "_hash": "a91f5eeb1f93f259bc7eee458eb7275e"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void fw_cfg_data_mem_write(void *opaque, target_phys_addr_t addr,\n\n                                  uint64_t value, unsigned size)\n\n{\n\n    fw_cfg_write(opaque, (uint8_t)value);\n\n}\n", "idx": 22787, "_split": "valid", "_hash": "95dbddbd7e3edb9de7b3eac65ca50adb"}
{"project": "qemu", "commit_id": "4d9ebf751a5a98e5dc2e26baf2344e744f4fa7b9", "target": 0, "func": "static void do_cpu_reset(void *opaque)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    CPUARMState *env = &cpu->env;\n\n    const struct arm_boot_info *info = env->boot_info;\n\n\n\n    cpu_reset(CPU(cpu));\n\n    if (info) {\n\n        if (!info->is_linux) {\n\n            /* Jump to the entry point.  */\n\n            env->regs[15] = info->entry & 0xfffffffe;\n\n            env->thumb = info->entry & 1;\n\n        } else {\n\n            if (CPU(cpu) == first_cpu) {\n\n                env->regs[15] = info->loader_start;\n\n                if (!info->dtb_filename) {\n\n                    if (old_param) {\n\n                        set_kernel_args_old(info);\n\n                    } else {\n\n                        set_kernel_args(info);\n\n                    }\n\n                }\n\n            } else {\n\n                info->secondary_cpu_reset_hook(cpu, info);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 22794, "_split": "valid", "_hash": "807b6b2921a91f718f8a327e62f4b328"}
{"project": "qemu", "commit_id": "cb5ef3fa1871522a0886627033459e94bd537fb7", "target": 1, "func": "static int tmp105_tx(I2CSlave *i2c, uint8_t data)\n\n{\n\n    TMP105State *s = (TMP105State *) i2c;\n\n\n\n    if (!s->len ++)\n\n        s->pointer = data;\n\n    else {\n\n        if (s->len <= 2)\n\n            s->buf[s->len - 1] = data;\n\n        tmp105_write(s);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 22837, "_split": "valid", "_hash": "d07dd425f9756f50ca6a892e8e33452b"}
{"project": "qemu", "commit_id": "215e79c01c4e6f766eb9add56c56453e9ea1d948", "target": 0, "func": "static bool cpu_thread_is_idle(CPUState *cpu)\n\n{\n\n    if (cpu->stop || cpu->queued_work_first) {\n\n        return false;\n\n    }\n\n    if (cpu->stopped || !runstate_is_running()) {\n\n        return true;\n\n    }\n\n    if (!cpu->halted || qemu_cpu_has_work(cpu) ||\n\n        kvm_async_interrupts_enabled()) {\n\n        return false;\n\n    }\n\n    return true;\n\n}\n", "idx": 22855, "_split": "valid", "_hash": "6502ff3f94b46363c5a70ff79a791ad8"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static inline QEMUClock *qemu_clock_ptr(QEMUClockType type)\n\n{\n\n    return &qemu_clocks[type];\n\n}\n", "idx": 22867, "_split": "valid", "_hash": "2a90b7fcff637f7045bee4416bb8fc14"}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "static VncJobQueue *vnc_queue_init(void)\n\n{\n\n    VncJobQueue *queue = g_malloc0(sizeof(VncJobQueue));\n\n\n\n    qemu_cond_init(&queue->cond);\n\n    qemu_mutex_init(&queue->mutex);\n\n    QTAILQ_INIT(&queue->jobs);\n\n    return queue;\n\n}\n", "idx": 22954, "_split": "valid", "_hash": "1ab5db3cfb3b7035a2cb7eb3451f8bc3"}
{"project": "qemu", "commit_id": "7b35030eedc26eff82210caa2b0fff2f9d0df453", "target": 1, "func": "void test_tls_write_cert_chain(const char *filename,\n\n                               gnutls_x509_crt_t *certs,\n\n                               size_t ncerts)\n\n{\n\n    size_t i;\n\n    size_t capacity = 1024, offset = 0;\n\n    char *buffer = g_new0(char, capacity);\n\n    int err;\n\n\n\n    for (i = 0; i < ncerts; i++) {\n\n        size_t len = capacity - offset;\n\n    retry:\n\n        err = gnutls_x509_crt_export(certs[i], GNUTLS_X509_FMT_PEM,\n\n                                     buffer + offset, &len);\n\n        if (err < 0) {\n\n            if (err == GNUTLS_E_SHORT_MEMORY_BUFFER) {\n\n                buffer = g_renew(char, buffer, offset + len);\n\n                capacity = offset + len;\n\n                goto retry;\n\n            }\n\n            g_critical(\"Failed to export certificate chain %s: %d\",\n\n                       gnutls_strerror(err), err);\n\n            abort();\n\n        }\n\n        offset += len;\n\n    }\n\n\n\n    if (!g_file_set_contents(filename, buffer, offset, NULL)) {\n\n        abort();\n\n    }\n\n\n}", "idx": 22957, "_split": "valid", "_hash": "d4bf64a2846515a25e84806eeba936ba"}
{"project": "qemu", "commit_id": "eba90e4efc80bc30c7d952ee6ea442207517a0da", "target": 0, "func": "int64_t strtosz_suffix_unit(const char *nptr, char **end,\n\n                            const char default_suffix, int64_t unit)\n\n{\n\n    int64_t retval = -1;\n\n    char *endptr;\n\n    unsigned char c, d;\n\n    int mul_required = 0;\n\n    double val, mul, integral, fraction;\n\n\n\n    errno = 0;\n\n    val = strtod(nptr, &endptr);\n\n    if (isnan(val) || endptr == nptr || errno != 0) {\n\n        goto fail;\n\n    }\n\n    fraction = modf(val, &integral);\n\n    if (fraction != 0) {\n\n        mul_required = 1;\n\n    }\n\n    /*\n\n     * Any whitespace character is fine for terminating the number,\n\n     * in addition we accept ',' to handle strings where the size is\n\n     * part of a multi token argument.\n\n     */\n\n    c = *endptr;\n\n    d = c;\n\n    if (qemu_isspace(c) || c == '\\0' || c == ',') {\n\n        c = 0;\n\n        d = default_suffix;\n\n    }\n\n    switch (qemu_toupper(d)) {\n\n    case STRTOSZ_DEFSUFFIX_B:\n\n        mul = 1;\n\n        if (mul_required) {\n\n            goto fail;\n\n        }\n\n        break;\n\n    case STRTOSZ_DEFSUFFIX_KB:\n\n        mul = unit;\n\n        break;\n\n    case STRTOSZ_DEFSUFFIX_MB:\n\n        mul = unit * unit;\n\n        break;\n\n    case STRTOSZ_DEFSUFFIX_GB:\n\n        mul = unit * unit * unit;\n\n        break;\n\n    case STRTOSZ_DEFSUFFIX_TB:\n\n        mul = unit * unit * unit * unit;\n\n        break;\n\n    default:\n\n        goto fail;\n\n    }\n\n    /*\n\n     * If not terminated by whitespace, ',', or \\0, increment endptr\n\n     * to point to next character, then check that we are terminated\n\n     * by an appropriate separating character, ie. whitespace, ',', or\n\n     * \\0. If not, we are seeing trailing garbage, thus fail.\n\n     */\n\n    if (c != 0) {\n\n        endptr++;\n\n        if (!qemu_isspace(*endptr) && *endptr != ',' && *endptr != 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n    if ((val * mul >= INT64_MAX) || val < 0) {\n\n        goto fail;\n\n    }\n\n    retval = val * mul;\n\n\n\nfail:\n\n    if (end) {\n\n        *end = endptr;\n\n    }\n\n\n\n    return retval;\n\n}\n", "idx": 23011, "_split": "valid", "_hash": "ad6e3011365b4cec1fadc2d51c13286d"}
{"project": "qemu", "commit_id": "7d5e199ade76c53ec316ab6779800581bb47c50a", "target": 0, "func": "static void qmp_output_push_obj(QmpOutputVisitor *qov, QObject *value,\n\n                                void *qapi)\n\n{\n\n    QStackEntry *e = g_malloc0(sizeof(*e));\n\n\n\n    assert(qov->root);\n\n    assert(value);\n\n    e->value = value;\n\n    e->qapi = qapi;\n\n    QSLIST_INSERT_HEAD(&qov->stack, e, node);\n\n}\n", "idx": 23015, "_split": "valid", "_hash": "13b33994d4f7aeded7fbdc14498c7641"}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "int qemu_global_option(const char *str)\n\n{\n\n    char driver[64], property[64];\n\n    QemuOpts *opts;\n\n    int rc, offset;\n\n\n\n    rc = sscanf(str, \"%63[^.].%63[^=]%n\", driver, property, &offset);\n\n    if (rc < 2 || str[offset] != '=') {\n\n        error_report(\"can't parse: \\\"%s\\\"\", str);\n\n        return -1;\n\n    }\n\n\n\n    opts = qemu_opts_create(&qemu_global_opts, NULL, 0);\n\n    qemu_opt_set(opts, \"driver\", driver);\n\n    qemu_opt_set(opts, \"property\", property);\n\n    qemu_opt_set(opts, \"value\", str+offset+1);\n\n    return 0;\n\n}\n", "idx": 23033, "_split": "valid", "_hash": "5a6880eaf8fa0a7838c516b4e7ad6179"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "QEMUFile *qemu_fdopen(int fd, const char *mode)\n\n{\n\n    QEMUFileSocket *s;\n\n\n\n    if (mode == NULL ||\n\n        (mode[0] != 'r' && mode[0] != 'w') ||\n\n        mode[1] != 'b' || mode[2] != 0) {\n\n        fprintf(stderr, \"qemu_fdopen: Argument validity check failed\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    s = g_malloc0(sizeof(QEMUFileSocket));\n\n    s->fd = fd;\n\n\n\n    if (mode[0] == 'r') {\n\n        s->file = qemu_fopen_ops(s, &unix_read_ops);\n\n    } else {\n\n        s->file = qemu_fopen_ops(s, &unix_write_ops);\n\n    }\n\n    return s->file;\n\n}\n", "idx": 23034, "_split": "valid", "_hash": "4b0919825705fd704d020d2069e525d1"}
{"project": "qemu", "commit_id": "ede9c94acf6cd1968de4188c0228b714ab871a86", "target": 0, "func": "static int vtd_interrupt_remap_msi(IntelIOMMUState *iommu,\n\n                                   MSIMessage *origin,\n\n                                   MSIMessage *translated)\n\n{\n\n    int ret = 0;\n\n    VTD_IR_MSIAddress addr;\n\n    uint16_t index;\n\n    VTDIrq irq = {};\n\n\n\n    assert(origin && translated);\n\n\n\n    if (!iommu || !iommu->intr_enabled) {\n\n        goto do_not_translate;\n\n    }\n\n\n\n    if (origin->address & VTD_MSI_ADDR_HI_MASK) {\n\n        VTD_DPRINTF(GENERAL, \"error: MSI addr high 32 bits nonzero\"\n\n                    \" during interrupt remapping: 0x%\"PRIx32,\n\n                    (uint32_t)((origin->address & VTD_MSI_ADDR_HI_MASK) >> \\\n\n                    VTD_MSI_ADDR_HI_SHIFT));\n\n        return -VTD_FR_IR_REQ_RSVD;\n\n    }\n\n\n\n    addr.data = origin->address & VTD_MSI_ADDR_LO_MASK;\n\n    if (le16_to_cpu(addr.__head) != 0xfee) {\n\n        VTD_DPRINTF(GENERAL, \"error: MSI addr low 32 bits invalid: \"\n\n                    \"0x%\"PRIx32, addr.data);\n\n        return -VTD_FR_IR_REQ_RSVD;\n\n    }\n\n\n\n    /* This is compatible mode. */\n\n    if (addr.int_mode != VTD_IR_INT_FORMAT_REMAP) {\n\n        goto do_not_translate;\n\n    }\n\n\n\n    index = addr.index_h << 15 | le16_to_cpu(addr.index_l);\n\n\n\n#define  VTD_IR_MSI_DATA_SUBHANDLE       (0x0000ffff)\n\n#define  VTD_IR_MSI_DATA_RESERVED        (0xffff0000)\n\n\n\n    if (addr.sub_valid) {\n\n        /* See VT-d spec 5.1.2.2 and 5.1.3 on subhandle */\n\n        index += origin->data & VTD_IR_MSI_DATA_SUBHANDLE;\n\n    }\n\n\n\n    ret = vtd_remap_irq_get(iommu, index, &irq);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (addr.sub_valid) {\n\n        VTD_DPRINTF(IR, \"received MSI interrupt\");\n\n        if (origin->data & VTD_IR_MSI_DATA_RESERVED) {\n\n            VTD_DPRINTF(GENERAL, \"error: MSI data bits non-zero for \"\n\n                        \"interrupt remappable entry: 0x%\"PRIx32,\n\n                        origin->data);\n\n            return -VTD_FR_IR_REQ_RSVD;\n\n        }\n\n    } else {\n\n        uint8_t vector = origin->data & 0xff;\n\n        VTD_DPRINTF(IR, \"received IOAPIC interrupt\");\n\n        /* IOAPIC entry vector should be aligned with IRTE vector\n\n         * (see vt-d spec 5.1.5.1). */\n\n        if (vector != irq.vector) {\n\n            VTD_DPRINTF(GENERAL, \"IOAPIC vector inconsistent: \"\n\n                        \"entry: %d, IRTE: %d, index: %d\",\n\n                        vector, irq.vector, index);\n\n        }\n\n    }\n\n\n\n    /*\n\n     * We'd better keep the last two bits, assuming that guest OS\n\n     * might modify it. Keep it does not hurt after all.\n\n     */\n\n    irq.msi_addr_last_bits = addr.__not_care;\n\n\n\n    /* Translate VTDIrq to MSI message */\n\n    vtd_generate_msi_message(&irq, translated);\n\n\n\n    VTD_DPRINTF(IR, \"mapping MSI 0x%\"PRIx64\":0x%\"PRIx32 \" -> \"\n\n                \"0x%\"PRIx64\":0x%\"PRIx32, origin->address, origin->data,\n\n                translated->address, translated->data);\n\n    return 0;\n\n\n\ndo_not_translate:\n\n    memcpy(translated, origin, sizeof(*origin));\n\n    return 0;\n\n}\n", "idx": 23070, "_split": "valid", "_hash": "969cce5c27032f69a240bac54fba0f62"}
{"project": "qemu", "commit_id": "02a2cbc872df99205eeafd399f01c210e0b797c4", "target": 0, "func": "static bool vtd_process_inv_desc(IntelIOMMUState *s)\n\n{\n\n    VTDInvDesc inv_desc;\n\n    uint8_t desc_type;\n\n\n\n    VTD_DPRINTF(INV, \"iq head %\"PRIu16, s->iq_head);\n\n    if (!vtd_get_inv_desc(s->iq, s->iq_head, &inv_desc)) {\n\n        s->iq_last_desc_type = VTD_INV_DESC_NONE;\n\n        return false;\n\n    }\n\n    desc_type = inv_desc.lo & VTD_INV_DESC_TYPE;\n\n    /* FIXME: should update at first or at last? */\n\n    s->iq_last_desc_type = desc_type;\n\n\n\n    switch (desc_type) {\n\n    case VTD_INV_DESC_CC:\n\n        VTD_DPRINTF(INV, \"Context-cache Invalidate Descriptor hi 0x%\"PRIx64\n\n                    \" lo 0x%\"PRIx64, inv_desc.hi, inv_desc.lo);\n\n        if (!vtd_process_context_cache_desc(s, &inv_desc)) {\n\n            return false;\n\n        }\n\n        break;\n\n\n\n    case VTD_INV_DESC_IOTLB:\n\n        VTD_DPRINTF(INV, \"IOTLB Invalidate Descriptor hi 0x%\"PRIx64\n\n                    \" lo 0x%\"PRIx64, inv_desc.hi, inv_desc.lo);\n\n        if (!vtd_process_iotlb_desc(s, &inv_desc)) {\n\n            return false;\n\n        }\n\n        break;\n\n\n\n    case VTD_INV_DESC_WAIT:\n\n        VTD_DPRINTF(INV, \"Invalidation Wait Descriptor hi 0x%\"PRIx64\n\n                    \" lo 0x%\"PRIx64, inv_desc.hi, inv_desc.lo);\n\n        if (!vtd_process_wait_desc(s, &inv_desc)) {\n\n            return false;\n\n        }\n\n        break;\n\n\n\n    case VTD_INV_DESC_IEC:\n\n        VTD_DPRINTF(INV, \"Interrupt Entry Cache Invalidation \"\n\n                    \"not implemented yet\");\n\n        /*\n\n         * Since currently we do not cache interrupt entries, we can\n\n         * just mark this descriptor as \"good\" and move on.\n\n         */\n\n        break;\n\n\n\n    default:\n\n        VTD_DPRINTF(GENERAL, \"error: unkonw Invalidation Descriptor type \"\n\n                    \"hi 0x%\"PRIx64 \" lo 0x%\"PRIx64 \" type %\"PRIu8,\n\n                    inv_desc.hi, inv_desc.lo, desc_type);\n\n        return false;\n\n    }\n\n    s->iq_head++;\n\n    if (s->iq_head == s->iq_size) {\n\n        s->iq_head = 0;\n\n    }\n\n    return true;\n\n}\n", "idx": 23071, "_split": "valid", "_hash": "b9ea4116a4ac0b437b3ffa580e48f4e1"}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static bool cmd_read_pio(IDEState *s, uint8_t cmd)\n\n{\n\n    bool lba48 = (cmd == WIN_READ_EXT);\n\n\n\n    if (s->drive_kind == IDE_CD) {\n\n        ide_set_signature(s); /* odd, but ATA4 8.27.5.2 requires it */\n\n        ide_abort_command(s);\n\n        return true;\n\n    }\n\n\n\n    if (!s->bs) {\n\n        ide_abort_command(s);\n\n        return true;\n\n    }\n\n\n\n    ide_cmd_lba48_transform(s, lba48);\n\n    s->req_nb_sectors = 1;\n\n    ide_sector_read(s);\n\n\n\n    return false;\n\n}\n", "idx": 23075, "_split": "valid", "_hash": "65e26e96dcf2b16318bd1da8f380723b"}
{"project": "qemu", "commit_id": "25cec2b896a977565ca04e5c649aab8c6e48bda8", "target": 1, "func": "void os_setup_post(void)\n\n{\n\n    int fd = 0;\n\n\n\n    if (daemonize) {\n\n        uint8_t status = 0;\n\n        ssize_t len;\n\n\n\n        do {        \n\n            len = write(daemon_pipe, &status, 1);\n\n        } while (len < 0 && errno == EINTR);\n\n        if (len != 1) {\n\n            exit(1);\n\n        }\n\n        if (chdir(\"/\")) {\n\n            perror(\"not able to chdir to /\");\n\n            exit(1);\n\n        }\n\n        TFR(fd = qemu_open(\"/dev/null\", O_RDWR));\n\n        if (fd == -1) {\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    change_root();\n\n    change_process_uid();\n\n\n\n    if (daemonize) {\n\n        dup2(fd, 0);\n\n        dup2(fd, 1);\n\n        dup2(fd, 2);\n\n\n\n        close(fd);\n\n    }\n\n}\n", "idx": 23093, "_split": "valid", "_hash": "b0da883c8c48f1f8cbf66058e2630ba9"}
{"project": "qemu", "commit_id": "1e242b5544a48bc43eca9c637dc91ec06bcf3a31", "target": 0, "func": "int qcow2_check_metadata_overlap(BlockDriverState *bs, int chk, int64_t offset,\n\n                                 int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int i, j;\n\n\n\n    if (!size) {\n\n        return 0;\n\n    }\n\n\n\n    if (chk & QCOW2_OL_MAIN_HEADER) {\n\n        if (offset < s->cluster_size) {\n\n            return QCOW2_OL_MAIN_HEADER;\n\n        }\n\n    }\n\n\n\n    /* align range to test to cluster boundaries */\n\n    size = align_offset(offset_into_cluster(s, offset) + size, s->cluster_size);\n\n    offset = start_of_cluster(s, offset);\n\n\n\n    if ((chk & QCOW2_OL_ACTIVE_L1) && s->l1_size) {\n\n        if (overlaps_with(s->l1_table_offset, s->l1_size * sizeof(uint64_t))) {\n\n            return QCOW2_OL_ACTIVE_L1;\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_REFCOUNT_TABLE) && s->refcount_table_size) {\n\n        if (overlaps_with(s->refcount_table_offset,\n\n            s->refcount_table_size * sizeof(uint64_t))) {\n\n            return QCOW2_OL_REFCOUNT_TABLE;\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_SNAPSHOT_TABLE) && s->snapshots_size) {\n\n        if (overlaps_with(s->snapshots_offset, s->snapshots_size)) {\n\n            return QCOW2_OL_SNAPSHOT_TABLE;\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_INACTIVE_L1) && s->snapshots) {\n\n        for (i = 0; i < s->nb_snapshots; i++) {\n\n            if (s->snapshots[i].l1_size &&\n\n                overlaps_with(s->snapshots[i].l1_table_offset,\n\n                s->snapshots[i].l1_size * sizeof(uint64_t))) {\n\n                return QCOW2_OL_INACTIVE_L1;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_ACTIVE_L2) && s->l1_table) {\n\n        for (i = 0; i < s->l1_size; i++) {\n\n            if ((s->l1_table[i] & L1E_OFFSET_MASK) &&\n\n                overlaps_with(s->l1_table[i] & L1E_OFFSET_MASK,\n\n                s->cluster_size)) {\n\n                return QCOW2_OL_ACTIVE_L2;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_REFCOUNT_BLOCK) && s->refcount_table) {\n\n        for (i = 0; i < s->refcount_table_size; i++) {\n\n            if ((s->refcount_table[i] & REFT_OFFSET_MASK) &&\n\n                overlaps_with(s->refcount_table[i] & REFT_OFFSET_MASK,\n\n                s->cluster_size)) {\n\n                return QCOW2_OL_REFCOUNT_BLOCK;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_INACTIVE_L2) && s->snapshots) {\n\n        for (i = 0; i < s->nb_snapshots; i++) {\n\n            uint64_t l1_ofs = s->snapshots[i].l1_table_offset;\n\n            uint32_t l1_sz  = s->snapshots[i].l1_size;\n\n            uint64_t *l1 = g_malloc(l1_sz * sizeof(uint64_t));\n\n            int ret;\n\n\n\n            ret = bdrv_read(bs->file, l1_ofs / BDRV_SECTOR_SIZE, (uint8_t *)l1,\n\n                            l1_sz * sizeof(uint64_t) / BDRV_SECTOR_SIZE);\n\n\n\n            if (ret < 0) {\n\n                g_free(l1);\n\n                return ret;\n\n            }\n\n\n\n            for (j = 0; j < l1_sz; j++) {\n\n                if ((l1[j] & L1E_OFFSET_MASK) &&\n\n                    overlaps_with(l1[j] & L1E_OFFSET_MASK, s->cluster_size)) {\n\n                    g_free(l1);\n\n                    return QCOW2_OL_INACTIVE_L2;\n\n                }\n\n            }\n\n\n\n            g_free(l1);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23102, "_split": "valid", "_hash": "38e14dd74036f03c158d457c70236b48"}
{"project": "qemu", "commit_id": "7c08db30e6a43f7083a881eb07bfbc878e001e08", "target": 0, "func": "static int cpu_x86_find_by_name(X86CPU *cpu, x86_def_t *x86_cpu_def,\n\n                                const char *name)\n\n{\n\n    x86_def_t *def;\n\n    int i;\n\n\n\n    if (name == NULL) {\n\n        return -1;\n\n    }\n\n    if (kvm_enabled() && strcmp(name, \"host\") == 0) {\n\n        kvm_cpu_fill_host(x86_cpu_def);\n\n        object_property_set_bool(OBJECT(cpu), true, \"pmu\", &error_abort);\n\n        return 0;\n\n    }\n\n\n\n    for (i = 0; i < ARRAY_SIZE(builtin_x86_defs); i++) {\n\n        def = &builtin_x86_defs[i];\n\n        if (strcmp(name, def->name) == 0) {\n\n            memcpy(x86_cpu_def, def, sizeof(*def));\n\n            /* sysenter isn't supported in compatibility mode on AMD,\n\n             * syscall isn't supported in compatibility mode on Intel.\n\n             * Normally we advertise the actual CPU vendor, but you can\n\n             * override this using the 'vendor' property if you want to use\n\n             * KVM's sysenter/syscall emulation in compatibility mode and\n\n             * when doing cross vendor migration\n\n             */\n\n            if (kvm_enabled()) {\n\n                uint32_t  ebx = 0, ecx = 0, edx = 0;\n\n                host_cpuid(0, 0, NULL, &ebx, &ecx, &edx);\n\n                x86_cpu_vendor_words2str(x86_cpu_def->vendor, ebx, edx, ecx);\n\n            }\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return -1;\n\n}\n", "idx": 23109, "_split": "valid", "_hash": "66f0839e0eee4edfd081e46382570db8"}
{"project": "qemu", "commit_id": "9005b2a7589540a3733b3abdcfbccfe7746cd1a1", "target": 0, "func": "static int pty_chr_write(CharDriverState *chr, const uint8_t *buf, int len)\n\n{\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (!s->connected) {\n\n        /* guest sends data, check for (re-)connect */\n\n        pty_chr_update_read_handler(chr);\n\n        return 0;\n\n    }\n\n    return io_channel_send(s->fd, buf, len);\n\n}\n", "idx": 23135, "_split": "valid", "_hash": "e2c3776fd3008449a9cbc7c007924adf"}
{"project": "qemu", "commit_id": "63ae0915f8ec9746d17a25c27f64cf65550627ab", "target": 0, "func": "static void gen_rlwimi(DisasContext *ctx)\n\n{\n\n    uint32_t mb, me, sh;\n\n\n\n    mb = MB(ctx->opcode);\n\n    me = ME(ctx->opcode);\n\n    sh = SH(ctx->opcode);\n\n    if (likely(sh == (31-me) && mb <= me)) {\n\n        tcg_gen_deposit_tl(cpu_gpr[rA(ctx->opcode)], cpu_gpr[rA(ctx->opcode)],\n\n                           cpu_gpr[rS(ctx->opcode)], sh, me - mb + 1);\n\n    } else {\n\n        target_ulong mask;\n\n        TCGv t1;\n\n        TCGv t0 = tcg_temp_new();\n\n#if defined(TARGET_PPC64)\n\n        tcg_gen_deposit_i64(t0, cpu_gpr[rS(ctx->opcode)],\n\n            cpu_gpr[rS(ctx->opcode)], 32, 32);\n\n        tcg_gen_rotli_i64(t0, t0, sh);\n\n#else\n\n        tcg_gen_rotli_i32(t0, cpu_gpr[rS(ctx->opcode)], sh);\n\n#endif\n\n#if defined(TARGET_PPC64)\n\n        mb += 32;\n\n        me += 32;\n\n#endif\n\n        mask = MASK(mb, me);\n\n        t1 = tcg_temp_new();\n\n        tcg_gen_andi_tl(t0, t0, mask);\n\n        tcg_gen_andi_tl(t1, cpu_gpr[rA(ctx->opcode)], ~mask);\n\n        tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1);\n\n        tcg_temp_free(t0);\n\n        tcg_temp_free(t1);\n\n    }\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);\n\n}\n", "idx": 23146, "_split": "valid", "_hash": "e447f8a6c8327cd6391253a5965dee6b"}
{"project": "qemu", "commit_id": "e4a3507e86a1ef1453d603031bca27d5ac4cff3c", "target": 0, "func": "static ssize_t test_block_write_func(QCryptoBlock *block,\n\n                                     void *opaque,\n\n                                     size_t offset,\n\n                                     const uint8_t *buf,\n\n                                     size_t buflen,\n\n                                     Error **errp)\n\n{\n\n    Buffer *header = opaque;\n\n\n\n    g_assert_cmpint(buflen + offset, <=, header->capacity);\n\n\n\n    memcpy(header->buffer + offset, buf, buflen);\n\n    header->offset = offset + buflen;\n\n\n\n    return buflen;\n\n}\n", "idx": 23167, "_split": "valid", "_hash": "4fcdabbc78bfcee43d29d455fbdf6262"}
{"project": "qemu", "commit_id": "375092332eeaa6e47561ce47fd36144cdaf964d0", "target": 0, "func": "static ssize_t block_crypto_read_func(QCryptoBlock *block,\n\n                                      size_t offset,\n\n                                      uint8_t *buf,\n\n                                      size_t buflen,\n\n                                      Error **errp,\n\n                                      void *opaque)\n\n{\n\n    BlockDriverState *bs = opaque;\n\n    ssize_t ret;\n\n\n\n    ret = bdrv_pread(bs->file, offset, buf, buflen);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not read encryption header\");\n\n        return ret;\n\n    }\n\n    return ret;\n\n}\n", "idx": 23173, "_split": "valid", "_hash": "f43e49797cea2a3c18536063d7638003"}
{"project": "qemu", "commit_id": "ed4f86e8b6eff8e600c69adee68c7cd34dd2cccb", "target": 1, "func": "int load_multiboot(FWCfgState *fw_cfg,\n                   FILE *f,\n                   const char *kernel_filename,\n                   const char *initrd_filename,\n                   const char *kernel_cmdline,\n                   int kernel_file_size,\n                   uint8_t *header)\n{\n    int i, is_multiboot = 0;\n    uint32_t flags = 0;\n    uint32_t mh_entry_addr;\n    uint32_t mh_load_addr;\n    uint32_t mb_kernel_size;\n    MultibootState mbs;\n    uint8_t bootinfo[MBI_SIZE];\n    uint8_t *mb_bootinfo_data;\n    uint32_t cmdline_len;\n    /* Ok, let's see if it is a multiboot image.\n       The header is 12x32bit long, so the latest entry may be 8192 - 48. */\n    for (i = 0; i < (8192 - 48); i += 4) {\n        if (ldl_p(header+i) == 0x1BADB002) {\n            uint32_t checksum = ldl_p(header+i+8);\n            flags = ldl_p(header+i+4);\n            checksum += flags;\n            checksum += (uint32_t)0x1BADB002;\n            if (!checksum) {\n                is_multiboot = 1;\n                break;\n    if (!is_multiboot)\n        return 0; /* no multiboot */\n    mb_debug(\"qemu: I believe we found a multiboot image!\\n\");\n    memset(bootinfo, 0, sizeof(bootinfo));\n    memset(&mbs, 0, sizeof(mbs));\n    if (flags & 0x00000004) { /* MULTIBOOT_HEADER_HAS_VBE */\n        fprintf(stderr, \"qemu: multiboot knows VBE. we don't.\\n\");\n    if (!(flags & 0x00010000)) { /* MULTIBOOT_HEADER_HAS_ADDR */\n        uint64_t elf_entry;\n        uint64_t elf_low, elf_high;\n        int kernel_size;\n        fclose(f);\n        if (((struct elf64_hdr*)header)->e_machine == EM_X86_64) {\n            fprintf(stderr, \"Cannot load x86-64 image, give a 32bit one.\\n\");\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n                               &elf_low, &elf_high, 0, I386_ELF_MACHINE,\n                               0, 0);\n        if (kernel_size < 0) {\n            fprintf(stderr, \"Error while loading elf kernel\\n\");\n        mh_load_addr = elf_low;\n        mb_kernel_size = elf_high - elf_low;\n        mh_entry_addr = elf_entry;\n        mbs.mb_buf = g_malloc(mb_kernel_size);\n        if (rom_copy(mbs.mb_buf, mh_load_addr, mb_kernel_size) != mb_kernel_size) {\n            fprintf(stderr, \"Error while fetching elf kernel from rom\\n\");\n        mb_debug(\"qemu: loading multiboot-elf kernel (%#x bytes) with entry %#zx\\n\",\n                  mb_kernel_size, (size_t)mh_entry_addr);\n    } else {\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_ADDR. */\n        uint32_t mh_header_addr = ldl_p(header+i+12);\n        uint32_t mh_load_end_addr = ldl_p(header+i+20);\n        uint32_t mh_bss_end_addr = ldl_p(header+i+24);\n        mh_load_addr = ldl_p(header+i+16);\n        uint32_t mb_kernel_text_offset = i - (mh_header_addr - mh_load_addr);\n        uint32_t mb_load_size = 0;\n        mh_entry_addr = ldl_p(header+i+28);\n        if (mh_load_end_addr) {\n            mb_kernel_size = mh_bss_end_addr - mh_load_addr;\n            mb_load_size = mh_load_end_addr - mh_load_addr;\n        } else {\n            mb_kernel_size = kernel_file_size - mb_kernel_text_offset;\n            mb_load_size = mb_kernel_size;\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_VBE.\n        uint32_t mh_mode_type = ldl_p(header+i+32);\n        uint32_t mh_width = ldl_p(header+i+36);\n        uint32_t mh_height = ldl_p(header+i+40);\n        uint32_t mh_depth = ldl_p(header+i+44); */\n        mb_debug(\"multiboot: mh_header_addr = %#x\\n\", mh_header_addr);\n        mb_debug(\"multiboot: mh_load_addr = %#x\\n\", mh_load_addr);\n        mb_debug(\"multiboot: mh_load_end_addr = %#x\\n\", mh_load_end_addr);\n        mb_debug(\"multiboot: mh_bss_end_addr = %#x\\n\", mh_bss_end_addr);\n        mb_debug(\"qemu: loading multiboot kernel (%#x bytes) at %#x\\n\",\n                 mb_load_size, mh_load_addr);\n        mbs.mb_buf = g_malloc(mb_kernel_size);\n        fseek(f, mb_kernel_text_offset, SEEK_SET);\n        if (fread(mbs.mb_buf, 1, mb_load_size, f) != mb_load_size) {\n            fprintf(stderr, \"fread() failed\\n\");\n        memset(mbs.mb_buf + mb_load_size, 0, mb_kernel_size - mb_load_size);\n        fclose(f);\n    mbs.mb_buf_phys = mh_load_addr;\n    mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_kernel_size);\n    mbs.offset_mbinfo = mbs.mb_buf_size;\n    /* Calculate space for cmdlines, bootloader name, and mb_mods */\n    cmdline_len = strlen(kernel_filename) + 1;\n    cmdline_len += strlen(kernel_cmdline) + 1;\n    if (initrd_filename) {\n        const char *r = initrd_filename;\n        cmdline_len += strlen(r) + 1;\n        mbs.mb_mods_avail = 1;\n        while (*(r = get_opt_value(NULL, 0, r))) {\n           mbs.mb_mods_avail++;\n           r++;\n    mbs.mb_buf_size += cmdline_len;\n    mbs.mb_buf_size += MB_MOD_SIZE * mbs.mb_mods_avail;\n    mbs.mb_buf_size += strlen(bootloader_name) + 1;\n    mbs.mb_buf_size = TARGET_PAGE_ALIGN(mbs.mb_buf_size);\n    /* enlarge mb_buf to hold cmdlines, bootloader, mb-info structs */\n    mbs.mb_buf            = g_realloc(mbs.mb_buf, mbs.mb_buf_size);\n    mbs.offset_cmdlines   = mbs.offset_mbinfo + mbs.mb_mods_avail * MB_MOD_SIZE;\n    mbs.offset_bootloader = mbs.offset_cmdlines + cmdline_len;\n    if (initrd_filename) {\n        const char *next_initrd;\n        char not_last, tmpbuf[strlen(initrd_filename) + 1];\n        mbs.offset_mods = mbs.mb_buf_size;\n        do {\n            char *next_space;\n            int mb_mod_length;\n            uint32_t offs = mbs.mb_buf_size;\n            next_initrd = get_opt_value(tmpbuf, sizeof(tmpbuf), initrd_filename);\n            not_last = *next_initrd;\n            /* if a space comes after the module filename, treat everything\n               after that as parameters */\n            hwaddr c = mb_add_cmdline(&mbs, tmpbuf);\n            if ((next_space = strchr(tmpbuf, ' ')))\n                *next_space = '\\0';\n            mb_debug(\"multiboot loading module: %s\\n\", tmpbuf);\n            mb_mod_length = get_image_size(tmpbuf);\n            if (mb_mod_length < 0) {\n                fprintf(stderr, \"Failed to open file '%s'\\n\", tmpbuf);\n            mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_mod_length + mbs.mb_buf_size);\n            mbs.mb_buf = g_realloc(mbs.mb_buf, mbs.mb_buf_size);\n            load_image(tmpbuf, (unsigned char *)mbs.mb_buf + offs);\n            mb_add_mod(&mbs, mbs.mb_buf_phys + offs,\n                       mbs.mb_buf_phys + offs + mb_mod_length, c);\n            mb_debug(\"mod_start: %p\\nmod_end:   %p\\n  cmdline: \"TARGET_FMT_plx\"\\n\",\n                     (char *)mbs.mb_buf + offs,\n                     (char *)mbs.mb_buf + offs + mb_mod_length, c);\n            initrd_filename = next_initrd+1;\n        } while (not_last);\n    /* Commandline support */\n    char kcmdline[strlen(kernel_filename) + strlen(kernel_cmdline) + 2];\n    snprintf(kcmdline, sizeof(kcmdline), \"%s %s\",\n             kernel_filename, kernel_cmdline);\n    stl_p(bootinfo + MBI_CMDLINE, mb_add_cmdline(&mbs, kcmdline));\n    stl_p(bootinfo + MBI_BOOTLOADER, mb_add_bootloader(&mbs, bootloader_name));\n    stl_p(bootinfo + MBI_MODS_ADDR,  mbs.mb_buf_phys + mbs.offset_mbinfo);\n    stl_p(bootinfo + MBI_MODS_COUNT, mbs.mb_mods_count); /* mods_count */\n    /* the kernel is where we want it to be now */\n    stl_p(bootinfo + MBI_FLAGS, MULTIBOOT_FLAGS_MEMORY\n                                | MULTIBOOT_FLAGS_BOOT_DEVICE\n                                | MULTIBOOT_FLAGS_CMDLINE\n                                | MULTIBOOT_FLAGS_MODULES\n                                | MULTIBOOT_FLAGS_MMAP\n                                | MULTIBOOT_FLAGS_BOOTLOADER);\n    stl_p(bootinfo + MBI_BOOT_DEVICE, 0x8000ffff); /* XXX: use the -boot switch? */\n    stl_p(bootinfo + MBI_MMAP_ADDR,   ADDR_E820_MAP);\n    mb_debug(\"multiboot: mh_entry_addr = %#x\\n\", mh_entry_addr);\n    mb_debug(\"           mb_buf_phys   = \"TARGET_FMT_plx\"\\n\", mbs.mb_buf_phys);\n    mb_debug(\"           mod_start     = \"TARGET_FMT_plx\"\\n\", mbs.mb_buf_phys + mbs.offset_mods);\n    mb_debug(\"           mb_mods_count = %d\\n\", mbs.mb_mods_count);\n    /* save bootinfo off the stack */\n    mb_bootinfo_data = g_memdup(bootinfo, sizeof(bootinfo));\n    /* Pass variables to option rom */\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ENTRY, mh_entry_addr);\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, mh_load_addr);\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, mbs.mb_buf_size);\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_KERNEL_DATA,\n                     mbs.mb_buf, mbs.mb_buf_size);\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, ADDR_MBI);\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, sizeof(bootinfo));\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_INITRD_DATA, mb_bootinfo_data,\n                     sizeof(bootinfo));\n    option_rom[nb_option_roms].name = \"multiboot.bin\";\n    option_rom[nb_option_roms].bootindex = 0;\n    nb_option_roms++;\n    return 1; /* yes, we are multiboot */", "idx": 23204, "_split": "valid", "_hash": "c5d6809f1a213e1c9434a10eaabefbb4"}
{"project": "qemu", "commit_id": "a5b0f6d5c0f6678c078354c432a1f0943374f087", "target": 0, "func": "static void lm32_cpu_reset(CPUState *s)\n\n{\n\n    LM32CPU *cpu = LM32_CPU(s);\n\n    LM32CPUClass *lcc = LM32_CPU_GET_CLASS(cpu);\n\n    CPULM32State *env = &cpu->env;\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_RESET)) {\n\n        qemu_log(\"CPU Reset (CPU %d)\\n\", s->cpu_index);\n\n        log_cpu_state(env, 0);\n\n    }\n\n\n\n    lcc->parent_reset(s);\n\n\n\n    tlb_flush(env, 1);\n\n\n\n    /* reset cpu state */\n\n    memset(env, 0, offsetof(CPULM32State, breakpoints));\n\n}\n", "idx": 23227, "_split": "valid", "_hash": "1666756dd959cb522e6c94f245630c4a"}
{"project": "qemu", "commit_id": "b5e85329026115b5a679849f45e7c19c2714e4fd", "target": 1, "func": "uint32_t HELPER(tprot)(CPUS390XState *env, uint64_t a1, uint64_t a2)\n\n{\n\n    S390CPU *cpu = s390_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n\n\n    /*\n\n     * TODO: we currently don't handle all access protection types\n\n     * (including access-list and key-controlled) as well as AR mode.\n\n     */\n\n    if (!s390_cpu_virt_mem_check_write(cpu, a1, 0, 1)) {\n\n        /* Fetching permitted; storing permitted */\n\n        return 0;\n\n    }\n\n    switch (env->int_pgm_code) {\n\n    case PGM_PROTECTION:\n\n        /* Fetching permitted; storing not permitted */\n\n        cs->exception_index = 0;\n\n        return 1;\n\n    case PGM_ADDRESSING:\n\n        /* Fetching not permitted; storing not permitted */\n\n        cs->exception_index = 0;\n\n        return 2;\n\n    case PGM_ASCE_TYPE:\n\n    case PGM_REG_FIRST_TRANS:\n\n    case PGM_REG_SEC_TRANS:\n\n    case PGM_REG_THIRD_TRANS:\n\n    case PGM_SEGMENT_TRANS:\n\n    case PGM_PAGE_TRANS:\n\n    case PGM_ALET_SPEC:\n\n    case PGM_ALEN_SPEC:\n\n    case PGM_ALE_SEQ:\n\n    case PGM_ASTE_VALID:\n\n    case PGM_ASTE_SEQ:\n\n    case PGM_EXT_AUTH:\n\n        /* Translation not available */\n\n        cs->exception_index = 0;\n\n        return 3;\n\n    }\n\n    /* any other exception is forwarded to the guest */\n\n    s390_cpu_virt_mem_handle_exc(cpu, GETPC());\n\n    return 0;\n\n}\n", "idx": 23292, "_split": "valid", "_hash": "649ae4bf0e9ac4ebe2b47e884d62c552"}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static int adb_kbd_poll(ADBDevice *d, uint8_t *obuf)\n\n{\n\n    KBDState *s = ADB_KEYBOARD(d);\n\n    int keycode;\n\n    int olen;\n\n\n\n    olen = 0;\n\n    if (s->count == 0) {\n\n        return 0;\n\n    }\n\n    keycode = s->data[s->rptr];\n\n    s->rptr++;\n\n    if (s->rptr == sizeof(s->data)) {\n\n        s->rptr = 0;\n\n    }\n\n    s->count--;\n\n    /*\n\n     * The power key is the only two byte value key, so it is a special case.\n\n     * Since 0x7f is not a used keycode for ADB we overload it to indicate the\n\n     * power button when we're storing keycodes in our internal buffer, and\n\n     * expand it out to two bytes when we send to the guest.\n\n     */\n\n    if (keycode == 0x7f) {\n\n        obuf[0] = 0x7f;\n\n        obuf[1] = 0x7f;\n\n        olen = 2;\n\n    } else {\n\n        obuf[0] = keycode;\n\n        /* NOTE: the power key key-up is the two byte sequence 0xff 0xff;\n\n         * otherwise we could in theory send a second keycode in the second\n\n         * byte, but choose not to bother.\n\n         */\n\n        obuf[1] = 0xff;\n\n        olen = 2;\n\n    }\n\n\n\n    return olen;\n\n}\n", "idx": 23298, "_split": "valid", "_hash": "169b9f3e6d99e57e1538710d637929c9"}
{"project": "qemu", "commit_id": "3761abb167847e9d848588bf15c5d7476845f7e8", "target": 1, "func": "static void qxl_create_guest_primary(PCIQXLDevice *qxl, int loadvm,\n\n                                     qxl_async_io async)\n\n{\n\n    QXLDevSurfaceCreate surface;\n\n    QXLSurfaceCreate *sc = &qxl->guest_primary.surface;\n\n    int size;\n\n    int requested_height = le32_to_cpu(sc->height);\n\n    int requested_stride = le32_to_cpu(sc->stride);\n\n\n\n    size = abs(requested_stride) * requested_height;\n\n    if (size > qxl->vgamem_size) {\n\n        qxl_set_guest_bug(qxl, \"%s: requested primary larger then framebuffer\"\n\n                               \" size\", __func__);\n\n        return;\n\n    }\n\n\n\n    if (qxl->mode == QXL_MODE_NATIVE) {\n\n        qxl_set_guest_bug(qxl, \"%s: nop since already in QXL_MODE_NATIVE\",\n\n                      __func__);\n\n    }\n\n    qxl_exit_vga_mode(qxl);\n\n\n\n    surface.format     = le32_to_cpu(sc->format);\n\n    surface.height     = le32_to_cpu(sc->height);\n\n    surface.mem        = le64_to_cpu(sc->mem);\n\n    surface.position   = le32_to_cpu(sc->position);\n\n    surface.stride     = le32_to_cpu(sc->stride);\n\n    surface.width      = le32_to_cpu(sc->width);\n\n    surface.type       = le32_to_cpu(sc->type);\n\n    surface.flags      = le32_to_cpu(sc->flags);\n\n    trace_qxl_create_guest_primary(qxl->id, sc->width, sc->height, sc->mem,\n\n                                   sc->format, sc->position);\n\n    trace_qxl_create_guest_primary_rest(qxl->id, sc->stride, sc->type,\n\n                                        sc->flags);\n\n\n\n    if ((surface.stride & 0x3) != 0) {\n\n        qxl_set_guest_bug(qxl, \"primary surface stride = %d %% 4 != 0\",\n\n                          surface.stride);\n\n        return;\n\n    }\n\n\n\n    surface.mouse_mode = true;\n\n    surface.group_id   = MEMSLOT_GROUP_GUEST;\n\n    if (loadvm) {\n\n        surface.flags |= QXL_SURF_FLAG_KEEP_DATA;\n\n    }\n\n\n\n    qxl->mode = QXL_MODE_NATIVE;\n\n    qxl->cmdflags = 0;\n\n    qemu_spice_create_primary_surface(&qxl->ssd, 0, &surface, async);\n\n\n\n    if (async == QXL_SYNC) {\n\n        qxl_create_guest_primary_complete(qxl);\n\n    }\n\n}\n", "idx": 23314, "_split": "valid", "_hash": "e15ef45ba4d41682ab6e4f234b14f5e9"}
{"project": "qemu", "commit_id": "1bc04a8880374407c4b12d82ceb8752e12ff5336", "target": 0, "func": "static void pmsav7_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                         uint64_t value)\n\n{\n\n    ARMCPU *cpu = arm_env_get_cpu(env);\n\n    uint32_t *u32p = *(uint32_t **)raw_ptr(env, ri);\n\n\n\n    if (!u32p) {\n\n        return;\n\n    }\n\n\n\n    u32p += env->pmsav7.rnr;\n\n    tlb_flush(CPU(cpu)); /* Mappings may have changed - purge! */\n\n    *u32p = value;\n\n}\n", "idx": 23365, "_split": "valid", "_hash": "12b95862b3a3dd4a361bdf2599c4fc19"}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_opts_del(QemuOpts *opts)\n\n{\n\n    QemuOpt *opt;\n\n\n\n    for (;;) {\n\n        opt = TAILQ_FIRST(&opts->head);\n\n        if (opt == NULL)\n\n            break;\n\n        qemu_opt_del(opt);\n\n    }\n\n    TAILQ_REMOVE(&opts->list->head, opts, next);\n\n    qemu_free(opts);\n\n}\n", "idx": 23366, "_split": "valid", "_hash": "9ca6e22f909aeea188ab339c6dec60c9"}
{"project": "qemu", "commit_id": "581b9e29f36eec5de0779c3dbade980e4405d92e", "target": 0, "func": "static int raw_pwrite(BlockDriverState *bs, int64_t offset,\n\n                      const uint8_t *buf, int count)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    int size, ret, shift, sum;\n\n\n\n    sum = 0;\n\n\n\n    if (s->aligned_buf != NULL) {\n\n\n\n        if (offset & 0x1ff) {\n\n            /* align offset on a 512 bytes boundary */\n\n            shift = offset & 0x1ff;\n\n            ret = raw_pread_aligned(bs, offset - shift, s->aligned_buf, 512);\n\n            if (ret < 0)\n\n                return ret;\n\n\n\n            size = 512 - shift;\n\n            if (size > count)\n\n                size = count;\n\n            memcpy(s->aligned_buf + shift, buf, size);\n\n\n\n            ret = raw_pwrite_aligned(bs, offset - shift, s->aligned_buf, 512);\n\n            if (ret < 0)\n\n                return ret;\n\n\n\n            buf += size;\n\n            offset += size;\n\n            count -= size;\n\n            sum += size;\n\n\n\n            if (count == 0)\n\n                return sum;\n\n        }\n\n        if (count & 0x1ff || (uintptr_t) buf & 0x1ff) {\n\n\n\n            while ((size = (count & ~0x1ff)) != 0) {\n\n\n\n                if (size > ALIGNED_BUFFER_SIZE)\n\n                    size = ALIGNED_BUFFER_SIZE;\n\n\n\n                memcpy(s->aligned_buf, buf, size);\n\n\n\n                ret = raw_pwrite_aligned(bs, offset, s->aligned_buf, size);\n\n                if (ret < 0)\n\n                    return ret;\n\n\n\n                buf += ret;\n\n                offset += ret;\n\n                count -= ret;\n\n                sum += ret;\n\n            }\n\n            /* here, count < 512 because (count & ~0x1ff) == 0 */\n\n            if (count) {\n\n                ret = raw_pread_aligned(bs, offset, s->aligned_buf, 512);\n\n                if (ret < 0)\n\n                    return ret;\n\n                 memcpy(s->aligned_buf, buf, count);\n\n\n\n                 ret = raw_pwrite_aligned(bs, offset, s->aligned_buf, 512);\n\n                 if (ret < 0)\n\n                     return ret;\n\n                 if (count < ret)\n\n                     ret = count;\n\n\n\n                 sum += ret;\n\n            }\n\n            return sum;\n\n        }\n\n    }\n\n    return raw_pwrite_aligned(bs, offset, buf, count) + sum;\n\n}\n", "idx": 23368, "_split": "valid", "_hash": "28f457f45c9bdea7dd4a2198c7880054"}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "void acpi_pcihp_device_unplug_cb(HotplugHandler *hotplug_dev, AcpiPciHpState *s,\n\n                                 DeviceState *dev, Error **errp)\n\n{\n\n    PCIDevice *pdev = PCI_DEVICE(dev);\n\n    int slot = PCI_SLOT(pdev->devfn);\n\n    int bsel = acpi_pcihp_get_bsel(pdev->bus);\n\n    if (bsel < 0) {\n\n        error_setg(errp, \"Unsupported bus. Bus doesn't have property '\"\n\n                   ACPI_PCIHP_PROP_BSEL \"' set\");\n\n        return;\n\n    }\n\n\n\n    s->acpi_pcihp_pci_status[bsel].down |= (1U << slot);\n\n    acpi_send_event(DEVICE(hotplug_dev), ACPI_PCI_HOTPLUG_STATUS);\n\n}\n", "idx": 23373, "_split": "valid", "_hash": "ce67bf66dced80f91011501fd783e255"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_debug_resume(BlockDriverState *bs, const char *tag)\n\n{\n\n    while (bs && (!bs->drv || !bs->drv->bdrv_debug_resume)) {\n\n        bs = bs->file;\n\n    }\n\n\n\n    if (bs && bs->drv && bs->drv->bdrv_debug_resume) {\n\n        return bs->drv->bdrv_debug_resume(bs, tag);\n\n    }\n\n\n\n    return -ENOTSUP;\n\n}\n", "idx": 23379, "_split": "valid", "_hash": "8bb94f2d4085d3ae5f5bd7b25756fe62"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t mpc8544_guts_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    uint32_t value = 0;\n\n    CPUPPCState *env = cpu_single_env;\n\n\n\n    addr &= MPC8544_GUTS_MMIO_SIZE - 1;\n\n    switch (addr) {\n\n    case MPC8544_GUTS_ADDR_PVR:\n\n        value = env->spr[SPR_PVR];\n\n        break;\n\n    case MPC8544_GUTS_ADDR_SVR:\n\n        value = env->spr[SPR_E500_SVR];\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"guts: Unknown register read: %x\\n\", (int)addr);\n\n        break;\n\n    }\n\n\n\n    return value;\n\n}\n", "idx": 23394, "_split": "valid", "_hash": "5d70f4a5f54705d3c964bb7992ff823f"}
{"project": "qemu", "commit_id": "45803a039670cbee914dcb54cf3952f9b2d64d1f", "target": 0, "func": "int bdrv_set_read_only(BlockDriverState *bs, bool read_only, Error **errp)\n\n{\n\n    /* Do not set read_only if copy_on_read is enabled */\n\n    if (bs->copy_on_read && read_only) {\n\n        error_setg(errp, \"Can't set node '%s' to r/o with copy-on-read enabled\",\n\n                   bdrv_get_device_or_node_name(bs));\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Do not clear read_only if it is prohibited */\n\n    if (!read_only && !(bs->open_flags & BDRV_O_ALLOW_RDWR)) {\n\n        error_setg(errp, \"Node '%s' is read only\",\n\n                   bdrv_get_device_or_node_name(bs));\n\n        return -EPERM;\n\n    }\n\n\n\n    bs->read_only = read_only;\n\n    return 0;\n\n}\n", "idx": 23396, "_split": "valid", "_hash": "b10b4a29fbfe68806179efeea980a22d"}
{"project": "qemu", "commit_id": "539de1246d355d3b8aa33fb7cde732352d8827c7", "target": 0, "func": "int qemu_savevm_state_begin(Monitor *mon, QEMUFile *f, int blk_enable,\n\n                            int shared)\n\n{\n\n    SaveStateEntry *se;\n\n    int ret;\n\n\n\n    QTAILQ_FOREACH(se, &savevm_handlers, entry) {\n\n        if(se->set_params == NULL) {\n\n            continue;\n\n\t}\n\n\tse->set_params(blk_enable, shared, se->opaque);\n\n    }\n\n    \n\n    qemu_put_be32(f, QEMU_VM_FILE_MAGIC);\n\n    qemu_put_be32(f, QEMU_VM_FILE_VERSION);\n\n\n\n    QTAILQ_FOREACH(se, &savevm_handlers, entry) {\n\n        int len;\n\n\n\n        if (se->save_live_state == NULL)\n\n            continue;\n\n\n\n        /* Section type */\n\n        qemu_put_byte(f, QEMU_VM_SECTION_START);\n\n        qemu_put_be32(f, se->section_id);\n\n\n\n        /* ID string */\n\n        len = strlen(se->idstr);\n\n        qemu_put_byte(f, len);\n\n        qemu_put_buffer(f, (uint8_t *)se->idstr, len);\n\n\n\n        qemu_put_be32(f, se->instance_id);\n\n        qemu_put_be32(f, se->version_id);\n\n\n\n        ret = se->save_live_state(mon, f, QEMU_VM_SECTION_START, se->opaque);\n\n        if (ret < 0) {\n\n            qemu_savevm_state_cancel(mon, f);\n\n            return ret;\n\n        }\n\n    }\n\n    ret = qemu_file_get_error(f);\n\n    if (ret != 0) {\n\n        qemu_savevm_state_cancel(mon, f);\n\n    }\n\n\n\n    return ret;\n\n\n\n}\n", "idx": 23404, "_split": "valid", "_hash": "7f0bca29e5bdd62e349d90271d22607d"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_conditional_jump(DisasContext * ctx,\n\n\t\t\t\t target_ulong ift, target_ulong ifnott)\n\n{\n\n    int l1;\n\n    TCGv sr;\n\n\n\n    l1 = gen_new_label();\n\n    sr = tcg_temp_new();\n\n    tcg_gen_andi_i32(sr, cpu_sr, SR_T);\n\n    tcg_gen_brcondi_i32(TCG_COND_NE, sr, 0, l1);\n\n    gen_goto_tb(ctx, 0, ifnott);\n\n    gen_set_label(l1);\n\n    gen_goto_tb(ctx, 1, ift);\n\n}\n", "idx": 23409, "_split": "valid", "_hash": "d35d41084797b77476121efc5ab82e08"}
{"project": "qemu", "commit_id": "57d84cf35302fe51789c18354bf09a521bb603df", "target": 1, "func": "static void remove_port(VirtIOSerial *vser, uint32_t port_id)\n\n{\n\n    VirtIOSerialPort *port;\n\n    unsigned int i;\n\n\n\n    i = port_id / 32;\n\n    vser->ports_map[i] &= ~(1U << (port_id % 32));\n\n\n\n    port = find_port_by_id(vser, port_id);\n\n    /*\n\n     * This function is only called from qdev's unplug callback; if we\n\n     * get a NULL port here, we're in trouble.\n\n     */\n\n    assert(port);\n\n\n\n    /* Flush out any unconsumed buffers first */\n\n    discard_vq_data(port->ovq, VIRTIO_DEVICE(port->vser));\n\n\n\n    send_control_event(vser, port->id, VIRTIO_CONSOLE_PORT_REMOVE, 1);\n\n}\n", "idx": 23430, "_split": "valid", "_hash": "0d298f3dc59a13f33975575240565d83"}
{"project": "qemu", "commit_id": "63ae0915f8ec9746d17a25c27f64cf65550627ab", "target": 0, "func": "static void gen_rlwinm(DisasContext *ctx)\n\n{\n\n    uint32_t mb, me, sh;\n\n\n\n    sh = SH(ctx->opcode);\n\n    mb = MB(ctx->opcode);\n\n    me = ME(ctx->opcode);\n\n\n\n    if (likely(mb == 0 && me == (31 - sh))) {\n\n        if (likely(sh == 0)) {\n\n            tcg_gen_ext32u_tl(cpu_gpr[rA(ctx->opcode)], cpu_gpr[rS(ctx->opcode)]);\n\n        } else {\n\n            TCGv t0 = tcg_temp_new();\n\n            tcg_gen_ext32u_tl(t0, cpu_gpr[rS(ctx->opcode)]);\n\n            tcg_gen_shli_tl(t0, t0, sh);\n\n            tcg_gen_ext32u_tl(cpu_gpr[rA(ctx->opcode)], t0);\n\n            tcg_temp_free(t0);\n\n        }\n\n    } else if (likely(sh != 0 && me == 31 && sh == (32 - mb))) {\n\n        TCGv t0 = tcg_temp_new();\n\n        tcg_gen_ext32u_tl(t0, cpu_gpr[rS(ctx->opcode)]);\n\n        tcg_gen_shri_tl(t0, t0, mb);\n\n        tcg_gen_ext32u_tl(cpu_gpr[rA(ctx->opcode)], t0);\n\n        tcg_temp_free(t0);\n\n    } else if (likely(mb == 0 && me == 31)) {\n\n        TCGv_i32 t0 = tcg_temp_new_i32();\n\n        tcg_gen_trunc_tl_i32(t0, cpu_gpr[rS(ctx->opcode)]);\n\n        tcg_gen_rotli_i32(t0, t0, sh);\n\n        tcg_gen_extu_i32_tl(cpu_gpr[rA(ctx->opcode)], t0);\n\n        tcg_temp_free_i32(t0);\n\n    } else {\n\n        TCGv t0 = tcg_temp_new();\n\n#if defined(TARGET_PPC64)\n\n        tcg_gen_deposit_i64(t0, cpu_gpr[rS(ctx->opcode)],\n\n            cpu_gpr[rS(ctx->opcode)], 32, 32);\n\n        tcg_gen_rotli_i64(t0, t0, sh);\n\n#else\n\n        tcg_gen_rotli_i32(t0, cpu_gpr[rS(ctx->opcode)], sh);\n\n#endif\n\n#if defined(TARGET_PPC64)\n\n        mb += 32;\n\n        me += 32;\n\n#endif\n\n        tcg_gen_andi_tl(cpu_gpr[rA(ctx->opcode)], t0, MASK(mb, me));\n\n        tcg_temp_free(t0);\n\n    }\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);\n\n}\n", "idx": 23444, "_split": "valid", "_hash": "74b53322dbb3896dea8d4bb536d46a6e"}
{"project": "qemu", "commit_id": "08844473820c93541fc47bdfeae0f2cc88cfab59", "target": 0, "func": "void bdrv_setup_io_funcs(BlockDriver *bdrv)\n\n{\n\n    /* Block drivers without coroutine functions need emulation */\n\n    if (!bdrv->bdrv_co_readv) {\n\n        bdrv->bdrv_co_readv = bdrv_co_readv_em;\n\n        bdrv->bdrv_co_writev = bdrv_co_writev_em;\n\n\n\n        /* bdrv_co_readv_em()/brdv_co_writev_em() work in terms of aio, so if\n\n         * the block driver lacks aio we need to emulate that too.\n\n         */\n\n        if (!bdrv->bdrv_aio_readv) {\n\n            /* add AIO emulation layer */\n\n            bdrv->bdrv_aio_readv = bdrv_aio_readv_em;\n\n            bdrv->bdrv_aio_writev = bdrv_aio_writev_em;\n\n        }\n\n    }\n\n}\n", "idx": 23483, "_split": "valid", "_hash": "62dcc5409330e119d5baeae94fab97bc"}
{"project": "qemu", "commit_id": "e1f7b4812eab992de46c98b3726745afb042a7f0", "target": 0, "func": "size_t virtio_serial_guest_ready(VirtIOSerialPort *port)\n\n{\n\n    VirtQueue *vq = port->ivq;\n\n    unsigned int bytes;\n\n\n\n    if (!virtio_queue_ready(vq) ||\n\n        !(port->vser->vdev.status & VIRTIO_CONFIG_S_DRIVER_OK) ||\n\n        virtio_queue_empty(vq)) {\n\n        return 0;\n\n    }\n\n    if (use_multiport(port->vser) && !port->guest_connected) {\n\n        return 0;\n\n    }\n\n    virtqueue_get_avail_bytes(vq, &bytes, NULL);\n\n    return bytes;\n\n}\n", "idx": 23511, "_split": "valid", "_hash": "5b9a16a00610546324a4158303eb181f"}
{"project": "qemu", "commit_id": "2d0d2837dcf786da415cf4165d37f4ddd684ff57", "target": 0, "func": "DriveInfo *add_init_drive(const char *optstr)\n\n{\n\n    DriveInfo *dinfo;\n\n    QemuOpts *opts;\n\n\n\n    opts = drive_def(optstr);\n\n    if (!opts)\n\n        return NULL;\n\n\n\n    dinfo = drive_init(opts, current_machine->use_scsi);\n\n    if (!dinfo) {\n\n        qemu_opts_del(opts);\n\n        return NULL;\n\n    }\n\n\n\n    return dinfo;\n\n}\n", "idx": 23520, "_split": "valid", "_hash": "7a0a619f1ce63259b42106a2311d2579"}
{"project": "qemu", "commit_id": "e912c96f7d2e5ccd8a6352ee74f5beee2a7d9976", "target": 0, "func": "static BusState *qbus_find_recursive(BusState *bus, const char *name,\n\n                                     const char *bus_typename)\n\n{\n\n    BusChild *kid;\n\n    BusState *child, *ret;\n\n    int match = 1;\n\n\n\n    if (name && (strcmp(bus->name, name) != 0)) {\n\n        match = 0;\n\n    }\n\n    if (bus_typename &&\n\n        (strcmp(object_get_typename(OBJECT(bus)), bus_typename) != 0)) {\n\n        match = 0;\n\n    }\n\n    if (match) {\n\n        return bus;\n\n    }\n\n\n\n    QTAILQ_FOREACH(kid, &bus->children, sibling) {\n\n        DeviceState *dev = kid->child;\n\n        QLIST_FOREACH(child, &dev->child_bus, sibling) {\n\n            ret = qbus_find_recursive(child, name, bus_typename);\n\n            if (ret) {\n\n                return ret;\n\n            }\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "idx": 23523, "_split": "valid", "_hash": "4b561700a501ed19ce3f07ff6358e6b2"}
{"project": "qemu", "commit_id": "ee312992a323530ea2cda8680f3a34746c72db8f", "target": 0, "func": "void qemu_input_event_sync(void)\n\n{\n\n    QemuInputHandlerState *s;\n\n\n\n    if (!runstate_is_running() && !runstate_check(RUN_STATE_SUSPENDED)) {\n\n        return;\n\n    }\n\n\n\n    trace_input_event_sync();\n\n\n\n    QTAILQ_FOREACH(s, &handlers, node) {\n\n        if (!s->events) {\n\n            continue;\n\n        }\n\n        if (s->handler->sync) {\n\n            s->handler->sync(s->dev);\n\n        }\n\n        s->events = 0;\n\n    }\n\n}\n", "idx": 23545, "_split": "valid", "_hash": "0c979ea3d3eed4ec37682ee320ea861c"}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_in_native_list_int64(TestInputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    test_native_list_integer_helper(data, unused,\n\n                                    USER_DEF_NATIVE_LIST_UNION_KIND_S64);\n\n}\n", "idx": 23589, "_split": "valid", "_hash": "024a29ffd731590ba69399d9b42836ac"}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "static void qint_destroy_obj(QObject *obj)\n\n{\n\n    assert(obj != NULL);\n\n    g_free(qobject_to_qint(obj));\n\n}\n", "idx": 23590, "_split": "valid", "_hash": "2cb40a0bbf30afb1b1dfe7374f7c85d4"}
{"project": "qemu", "commit_id": "7e01376daea75e888c370aab521a7d4aeaf2ffd1", "target": 0, "func": "int ioinst_handle_tsch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)\n\n{\n\n    CPUS390XState *env = &cpu->env;\n\n    int cssid, ssid, schid, m;\n\n    SubchDev *sch;\n\n    IRB irb;\n\n    uint64_t addr;\n\n    int cc, irb_len;\n\n    uint8_t ar;\n\n\n\n    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid)) {\n\n        program_interrupt(env, PGM_OPERAND, 2);\n\n        return -EIO;\n\n    }\n\n    trace_ioinst_sch_id(\"tsch\", cssid, ssid, schid);\n\n    addr = decode_basedisp_s(env, ipb, &ar);\n\n    if (addr & 3) {\n\n        program_interrupt(env, PGM_SPECIFICATION, 2);\n\n        return -EIO;\n\n    }\n\n\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (sch && css_subch_visible(sch)) {\n\n        cc = css_do_tsch_get_irb(sch, &irb, &irb_len);\n\n    } else {\n\n        cc = 3;\n\n    }\n\n    /* 0 - status pending, 1 - not status pending, 3 - not operational */\n\n    if (cc != 3) {\n\n        if (s390_cpu_virt_mem_write(cpu, addr, ar, &irb, irb_len) != 0) {\n\n            return -EFAULT;\n\n        }\n\n        css_do_tsch_update_subch(sch);\n\n    } else {\n\n        irb_len = sizeof(irb) - sizeof(irb.emw);\n\n        /* Access exceptions have a higher priority than cc3 */\n\n        if (s390_cpu_virt_mem_check_write(cpu, addr, ar, irb_len) != 0) {\n\n            return -EFAULT;\n\n        }\n\n    }\n\n\n\n    setcc(cpu, cc);\n\n    return 0;\n\n}\n", "idx": 23594, "_split": "valid", "_hash": "3ee2037a16379571b74cecab5f523fc9"}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static ssize_t v9fs_synth_pwritev(FsContext *ctx, V9fsFidOpenState *fs,\n\n                                  const struct iovec *iov,\n\n                                  int iovcnt, off_t offset)\n\n{\n\n    int i, count = 0, wcount;\n\n    V9fsSynthOpenState *synth_open = fs->private;\n\n    V9fsSynthNode *node = synth_open->node;\n\n    if (!node->attr->write) {\n\n        errno = EPERM;\n\n        return -1;\n\n    }\n\n    for (i = 0; i < iovcnt; i++) {\n\n        wcount = node->attr->write(iov[i].iov_base, iov[i].iov_len,\n\n                                   offset, node->private);\n\n        offset += wcount;\n\n        count  += wcount;\n\n        /* If we wrote less than requested. we are done */\n\n        if (wcount < iov[i].iov_len) {\n\n            break;\n\n        }\n\n    }\n\n    return count;\n\n}\n", "idx": 23616, "_split": "valid", "_hash": "0b59915a9ccdc2172b87e96bf7aa86dc"}
{"project": "qemu", "commit_id": "153eba4726dfa1bdfc31d1fe973b2a61b9035492", "target": 0, "func": "static void piix4_device_unplug_request_cb(HotplugHandler *hotplug_dev,\n\n                                           DeviceState *dev, Error **errp)\n\n{\n\n    PIIX4PMState *s = PIIX4_PM(hotplug_dev);\n\n\n\n    if (s->acpi_memory_hotplug.is_enabled &&\n\n        object_dynamic_cast(OBJECT(dev), TYPE_PC_DIMM)) {\n\n        acpi_memory_unplug_request_cb(hotplug_dev, &s->acpi_memory_hotplug,\n\n                                      dev, errp);\n\n    } else if (object_dynamic_cast(OBJECT(dev), TYPE_PCI_DEVICE)) {\n\n        acpi_pcihp_device_unplug_cb(hotplug_dev, &s->acpi_pci_hotplug, dev,\n\n                                    errp);\n\n    } else if (object_dynamic_cast(OBJECT(dev), TYPE_CPU) &&\n\n               !s->cpu_hotplug_legacy) {\n\n        acpi_cpu_unplug_request_cb(hotplug_dev, &s->cpuhp_state, dev, errp);\n\n    } else {\n\n        error_setg(errp, \"acpi: device unplug request for not supported device\"\n\n                   \" type: %s\", object_get_typename(OBJECT(dev)));\n\n    }\n\n}\n", "idx": 23621, "_split": "valid", "_hash": "bb01e8e4527a69cd0502071ddf527531"}
{"project": "qemu", "commit_id": "d87aa138039a4be6d705793fd3e397c69c52405a", "target": 1, "func": "static void ohci_td_pkt(const char *msg, const uint8_t *buf, size_t len)\n\n{\n\n    bool print16 = !!trace_event_get_state(TRACE_USB_OHCI_TD_PKT_SHORT);\n\n    bool printall = !!trace_event_get_state(TRACE_USB_OHCI_TD_PKT_FULL);\n\n    const int width = 16;\n\n    int i;\n\n    char tmp[3 * width + 1];\n\n    char *p = tmp;\n\n\n\n    if (!printall && !print16) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; ; i++) {\n\n        if (i && (!(i % width) || (i == len))) {\n\n            if (!printall) {\n\n                trace_usb_ohci_td_pkt_short(msg, tmp);\n\n                break;\n\n            }\n\n            trace_usb_ohci_td_pkt_full(msg, tmp);\n\n            p = tmp;\n\n            *p = 0;\n\n        }\n\n        if (i == len) {\n\n            break;\n\n        }\n\n\n\n        p += sprintf(p, \" %.2x\", buf[i]);\n\n    }\n\n}\n", "idx": 23663, "_split": "valid", "_hash": "3a36882650b40f75435b130e9785bd39"}
{"project": "qemu", "commit_id": "9ea63c05d90ba85d819f9b2472ce6dfba7a403b4", "target": 0, "func": "int do_subchannel_work_virtual(SubchDev *sch)\n\n{\n\n\n\n    SCSW *s = &sch->curr_status.scsw;\n\n\n\n    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {\n\n        sch_handle_clear_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {\n\n        sch_handle_halt_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {\n\n        /* Triggered by both ssch and rsch. */\n\n        sch_handle_start_func_virtual(sch);\n\n    } else {\n\n        /* Cannot happen. */\n\n        return 0;\n\n    }\n\n    css_inject_io_interrupt(sch);\n\n    return 0;\n\n}\n", "idx": 23682, "_split": "valid", "_hash": "7b0751cfd4c6491fd7171f41f038cea2"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static inline uint64_t ldq_phys_internal(target_phys_addr_t addr,\n\n                                         enum device_endian endian)\n\n{\n\n    uint8_t *ptr;\n\n    uint64_t val;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!(memory_region_is_ram(section->mr) ||\n\n          memory_region_is_romd(section->mr))) {\n\n        /* I/O case */\n\n        addr = memory_region_section_addr(section, addr);\n\n\n\n        /* XXX This is broken when device endian != cpu endian.\n\n               Fix and add \"endian\" variable check */\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n        val = io_mem_read(section->mr, addr, 4) << 32;\n\n        val |= io_mem_read(section->mr, addr + 4, 4);\n\n#else\n\n        val = io_mem_read(section->mr, addr, 4);\n\n        val |= io_mem_read(section->mr, addr + 4, 4) << 32;\n\n#endif\n\n    } else {\n\n        /* RAM case */\n\n        ptr = qemu_get_ram_ptr((memory_region_get_ram_addr(section->mr)\n\n                                & TARGET_PAGE_MASK)\n\n                               + memory_region_section_addr(section, addr));\n\n        switch (endian) {\n\n        case DEVICE_LITTLE_ENDIAN:\n\n            val = ldq_le_p(ptr);\n\n            break;\n\n        case DEVICE_BIG_ENDIAN:\n\n            val = ldq_be_p(ptr);\n\n            break;\n\n        default:\n\n            val = ldq_p(ptr);\n\n            break;\n\n        }\n\n    }\n\n    return val;\n\n}\n", "idx": 23686, "_split": "valid", "_hash": "30a45f796675968667ba4327bc4b96e3"}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static int raw_reopen_prepare(BDRVReopenState *reopen_state,\n\n                              BlockReopenQueue *queue, Error **errp)\n\n{\n\n    assert(reopen_state != NULL);\n\n    assert(reopen_state->bs != NULL);\n\n\n\n    reopen_state->opaque = g_new0(BDRVRawState, 1);\n\n\n\n    return raw_read_options(\n\n        reopen_state->options,\n\n        reopen_state->bs,\n\n        reopen_state->opaque,\n\n        errp);\n\n}\n", "idx": 23689, "_split": "valid", "_hash": "6440cbc09e4fe88fadd6c70cb389a755"}
{"project": "qemu", "commit_id": "f67409a5bb43ebe74401fa8e187267eb0f139293", "target": 1, "func": "static void nfs_refresh_filename(BlockDriverState *bs, QDict *options)\n\n{\n\n    NFSClient *client = bs->opaque;\n\n    QDict *opts = qdict_new();\n\n    QObject *server_qdict;\n\n    Visitor *ov;\n\n\n\n    qdict_put(opts, \"driver\", qstring_from_str(\"nfs\"));\n\n\n\n    if (client->uid && !client->gid) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nfs://%s%s?uid=%\" PRId64, client->server->host, client->path,\n\n                 client->uid);\n\n    } else if (!client->uid && client->gid) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nfs://%s%s?gid=%\" PRId64, client->server->host, client->path,\n\n                 client->gid);\n\n    } else if (client->uid && client->gid) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nfs://%s%s?uid=%\" PRId64 \"&gid=%\" PRId64,\n\n                 client->server->host, client->path, client->uid, client->gid);\n\n    } else {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nfs://%s%s\", client->server->host, client->path);\n\n    }\n\n\n\n    ov = qobject_output_visitor_new(&server_qdict);\n\n    visit_type_NFSServer(ov, NULL, &client->server, &error_abort);\n\n    visit_complete(ov, &server_qdict);\n\n    assert(qobject_type(server_qdict) == QTYPE_QDICT);\n\n\n\n    qdict_put_obj(opts, \"server\", server_qdict);\n\n    qdict_put(opts, \"path\", qstring_from_str(client->path));\n\n\n\n    if (client->uid) {\n\n        qdict_put(opts, \"uid\", qint_from_int(client->uid));\n\n    }\n\n    if (client->gid) {\n\n        qdict_put(opts, \"gid\", qint_from_int(client->gid));\n\n    }\n\n    if (client->tcp_syncnt) {\n\n        qdict_put(opts, \"tcp-syncnt\",\n\n                      qint_from_int(client->tcp_syncnt));\n\n    }\n\n    if (client->readahead) {\n\n        qdict_put(opts, \"readahead\",\n\n                      qint_from_int(client->readahead));\n\n    }\n\n    if (client->pagecache) {\n\n        qdict_put(opts, \"pagecache\",\n\n                      qint_from_int(client->pagecache));\n\n    }\n\n    if (client->debug) {\n\n        qdict_put(opts, \"debug\", qint_from_int(client->debug));\n\n    }\n\n\n\n    visit_free(ov);\n\n    qdict_flatten(opts);\n\n    bs->full_open_options = opts;\n\n}\n", "idx": 23710, "_split": "valid", "_hash": "7bd7efe52b1b5382249ffb5dec76570a"}
{"project": "qemu", "commit_id": "e829b0bb054ed3389e5b22dad61875e51674e629", "target": 1, "func": "iscsi_readcapacity16_cb(struct iscsi_context *iscsi, int status,\n\n                        void *command_data, void *opaque)\n\n{\n\n    struct IscsiTask *itask = opaque;\n\n    struct scsi_readcapacity16 *rc16;\n\n    struct scsi_task *task = command_data;\n\n\n\n    if (status != 0) {\n\n        error_report(\"iSCSI: Failed to read capacity of iSCSI lun. %s\",\n\n                     iscsi_get_error(iscsi));\n\n        itask->status   = 1;\n\n        itask->complete = 1;\n\n        scsi_free_scsi_task(task);\n\n        return;\n\n    }\n\n\n\n    rc16 = scsi_datain_unmarshall(task);\n\n    if (rc16 == NULL) {\n\n        error_report(\"iSCSI: Failed to unmarshall readcapacity16 data.\");\n\n        itask->status   = 1;\n\n        itask->complete = 1;\n\n        scsi_free_scsi_task(task);\n\n        return;\n\n    }\n\n\n\n    itask->iscsilun->block_size = rc16->block_length;\n\n    itask->iscsilun->num_blocks = rc16->returned_lba + 1;\n\n    itask->bs->total_sectors    = itask->iscsilun->num_blocks *\n\n                               itask->iscsilun->block_size / BDRV_SECTOR_SIZE ;\n\n\n\n    itask->status   = 0;\n\n    itask->complete = 1;\n\n    scsi_free_scsi_task(task);\n\n}\n", "idx": 23727, "_split": "valid", "_hash": "941ac2003a3730d75b0bcd19e1a4b214"}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fnmsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2,\n\n                       uint64_t arg3)\n\n{\n\n    CPU_DoubleU farg1, farg2, farg3;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n    farg3.ll = arg3;\n\n\n\n    if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||\n\n                 (float64_is_zero(farg1.d) &&\n\n                  float64_is_infinity(farg2.d)))) {\n\n        /* Multiplication of zero by infinity */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIMZ);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d) ||\n\n                     float64_is_signaling_nan(farg3.d))) {\n\n            /* sNaN operation */\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        /* This is the way the PowerPC specification defines it */\n\n        float128 ft0_128, ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) &&\n\n                     float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) == float64_is_neg(farg3.d))) {\n\n            /* Magnitude subtraction of infinities */\n\n            farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_sub(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n        if (likely(!float64_is_any_nan(farg1.d))) {\n\n            farg1.d = float64_chs(farg1.d);\n\n        }\n\n    }\n\n    return farg1.ll;\n\n}\n", "idx": 23733, "_split": "valid", "_hash": "7b8a70cddcd646fb315f0fb79cf3c7ba"}
{"project": "qemu", "commit_id": "765a707000e838c30b18d712fe6cb3dd8e0435f3", "target": 1, "func": "static int megasas_map_dcmd(MegasasState *s, MegasasCmd *cmd)\n\n{\n\n    dma_addr_t iov_pa, iov_size;\n\n\n\n    cmd->flags = le16_to_cpu(cmd->frame->header.flags);\n\n    if (!cmd->frame->header.sge_count) {\n\n        trace_megasas_dcmd_zero_sge(cmd->index);\n\n        cmd->iov_size = 0;\n\n        return 0;\n\n    } else if (cmd->frame->header.sge_count > 1) {\n\n        trace_megasas_dcmd_invalid_sge(cmd->index,\n\n                                       cmd->frame->header.sge_count);\n\n        cmd->iov_size = 0;\n\n        return -1;\n\n    }\n\n    iov_pa = megasas_sgl_get_addr(cmd, &cmd->frame->dcmd.sgl);\n\n    iov_size = megasas_sgl_get_len(cmd, &cmd->frame->dcmd.sgl);\n\n    pci_dma_sglist_init(&cmd->qsg, PCI_DEVICE(s), 1);\n\n    qemu_sglist_add(&cmd->qsg, iov_pa, iov_size);\n\n    cmd->iov_size = iov_size;\n\n    return cmd->iov_size;\n\n}\n", "idx": 23761, "_split": "valid", "_hash": "5cc3f51d319fe467ad56c5a7c4160c9e"}
{"project": "qemu", "commit_id": "4b9b7092b4cbef084138a446b8247ba89fd474f4", "target": 1, "func": "static void cdrom_change_cb(void *opaque, int reason)\n\n{\n\n    IDEState *s = opaque;\n\n    uint64_t nb_sectors;\n\n\n\n    if (!(reason & CHANGE_MEDIA)) {\n\n        return;\n\n    }\n\n\n\n    bdrv_get_geometry(s->bs, &nb_sectors);\n\n    s->nb_sectors = nb_sectors;\n\n\n\n    s->sense_key = SENSE_UNIT_ATTENTION;\n\n    s->asc = ASC_MEDIUM_MAY_HAVE_CHANGED;\n\n    s->cdrom_changed = 1;\n\n    s->events.new_media = true;\n\n    ide_set_irq(s->bus);\n\n}\n", "idx": 23772, "_split": "valid", "_hash": "7e3d20f1e8996ce7d7f093bb982adbf7"}
{"project": "qemu", "commit_id": "52f34623b499cb0273118b1f637c2c6ebaf5d5a1", "target": 1, "func": "static int gdb_handle_packet(GDBState *s, const char *line_buf)\n\n{\n\n    CPUArchState *env;\n\n    const char *p;\n\n    uint32_t thread;\n\n    int ch, reg_size, type, res;\n\n    char buf[MAX_PACKET_LENGTH];\n\n    uint8_t mem_buf[MAX_PACKET_LENGTH];\n\n    uint8_t *registers;\n\n    target_ulong addr, len;\n\n\n\n#ifdef DEBUG_GDB\n\n    printf(\"command='%s'\\n\", line_buf);\n\n#endif\n\n    p = line_buf;\n\n    ch = *p++;\n\n    switch(ch) {\n\n    case '?':\n\n        /* TODO: Make this return the correct value for user-mode.  */\n\n        snprintf(buf, sizeof(buf), \"T%02xthread:%02x;\", GDB_SIGNAL_TRAP,\n\n                 cpu_index(ENV_GET_CPU(s->c_cpu)));\n\n        put_packet(s, buf);\n\n        /* Remove all the breakpoints when this query is issued,\n\n         * because gdb is doing and initial connect and the state\n\n         * should be cleaned up.\n\n         */\n\n        gdb_breakpoint_remove_all();\n\n        break;\n\n    case 'c':\n\n        if (*p != '\\0') {\n\n            addr = strtoull(p, (char **)&p, 16);\n\n            gdb_set_cpu_pc(s, addr);\n\n        }\n\n        s->signal = 0;\n\n        gdb_continue(s);\n\n\treturn RS_IDLE;\n\n    case 'C':\n\n        s->signal = gdb_signal_to_target (strtoul(p, (char **)&p, 16));\n\n        if (s->signal == -1)\n\n            s->signal = 0;\n\n        gdb_continue(s);\n\n        return RS_IDLE;\n\n    case 'v':\n\n        if (strncmp(p, \"Cont\", 4) == 0) {\n\n            int res_signal, res_thread;\n\n\n\n            p += 4;\n\n            if (*p == '?') {\n\n                put_packet(s, \"vCont;c;C;s;S\");\n\n                break;\n\n            }\n\n            res = 0;\n\n            res_signal = 0;\n\n            res_thread = 0;\n\n            while (*p) {\n\n                int action, signal;\n\n\n\n                if (*p++ != ';') {\n\n                    res = 0;\n\n                    break;\n\n                }\n\n                action = *p++;\n\n                signal = 0;\n\n                if (action == 'C' || action == 'S') {\n\n                    signal = strtoul(p, (char **)&p, 16);\n\n                } else if (action != 'c' && action != 's') {\n\n                    res = 0;\n\n                    break;\n\n                }\n\n                thread = 0;\n\n                if (*p == ':') {\n\n                    thread = strtoull(p+1, (char **)&p, 16);\n\n                }\n\n                action = tolower(action);\n\n                if (res == 0 || (res == 'c' && action == 's')) {\n\n                    res = action;\n\n                    res_signal = signal;\n\n                    res_thread = thread;\n\n                }\n\n            }\n\n            if (res) {\n\n                if (res_thread != -1 && res_thread != 0) {\n\n                    env = find_cpu(res_thread);\n\n                    if (env == NULL) {\n\n                        put_packet(s, \"E22\");\n\n                        break;\n\n                    }\n\n                    s->c_cpu = env;\n\n                }\n\n                if (res == 's') {\n\n                    cpu_single_step(s->c_cpu, sstep_flags);\n\n                }\n\n                s->signal = res_signal;\n\n                gdb_continue(s);\n\n                return RS_IDLE;\n\n            }\n\n            break;\n\n        } else {\n\n            goto unknown_command;\n\n        }\n\n    case 'k':\n\n#ifdef CONFIG_USER_ONLY\n\n        /* Kill the target */\n\n        fprintf(stderr, \"\\nQEMU: Terminated via GDBstub\\n\");\n\n        exit(0);\n\n#endif\n\n    case 'D':\n\n        /* Detach packet */\n\n        gdb_breakpoint_remove_all();\n\n        gdb_syscall_mode = GDB_SYS_DISABLED;\n\n        gdb_continue(s);\n\n        put_packet(s, \"OK\");\n\n        break;\n\n    case 's':\n\n        if (*p != '\\0') {\n\n            addr = strtoull(p, (char **)&p, 16);\n\n            gdb_set_cpu_pc(s, addr);\n\n        }\n\n        cpu_single_step(s->c_cpu, sstep_flags);\n\n        gdb_continue(s);\n\n\treturn RS_IDLE;\n\n    case 'F':\n\n        {\n\n            target_ulong ret;\n\n            target_ulong err;\n\n\n\n            ret = strtoull(p, (char **)&p, 16);\n\n            if (*p == ',') {\n\n                p++;\n\n                err = strtoull(p, (char **)&p, 16);\n\n            } else {\n\n                err = 0;\n\n            }\n\n            if (*p == ',')\n\n                p++;\n\n            type = *p;\n\n            if (s->current_syscall_cb) {\n\n                s->current_syscall_cb(s->c_cpu, ret, err);\n\n                s->current_syscall_cb = NULL;\n\n            }\n\n            if (type == 'C') {\n\n                put_packet(s, \"T02\");\n\n            } else {\n\n                gdb_continue(s);\n\n            }\n\n        }\n\n        break;\n\n    case 'g':\n\n        cpu_synchronize_state(ENV_GET_CPU(s->g_cpu));\n\n        env = s->g_cpu;\n\n        len = 0;\n\n        for (addr = 0; addr < num_g_regs; addr++) {\n\n            reg_size = gdb_read_register(s->g_cpu, mem_buf + len, addr);\n\n            len += reg_size;\n\n        }\n\n        memtohex(buf, mem_buf, len);\n\n        put_packet(s, buf);\n\n        break;\n\n    case 'G':\n\n        cpu_synchronize_state(ENV_GET_CPU(s->g_cpu));\n\n        env = s->g_cpu;\n\n        registers = mem_buf;\n\n        len = strlen(p) / 2;\n\n        hextomem((uint8_t *)registers, p, len);\n\n        for (addr = 0; addr < num_g_regs && len > 0; addr++) {\n\n            reg_size = gdb_write_register(s->g_cpu, registers, addr);\n\n            len -= reg_size;\n\n            registers += reg_size;\n\n        }\n\n        put_packet(s, \"OK\");\n\n        break;\n\n    case 'm':\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        len = strtoull(p, NULL, 16);\n\n        if (target_memory_rw_debug(s->g_cpu, addr, mem_buf, len, 0) != 0) {\n\n            put_packet (s, \"E14\");\n\n        } else {\n\n            memtohex(buf, mem_buf, len);\n\n            put_packet(s, buf);\n\n        }\n\n        break;\n\n    case 'M':\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        len = strtoull(p, (char **)&p, 16);\n\n        if (*p == ':')\n\n            p++;\n\n        hextomem(mem_buf, p, len);\n\n        if (target_memory_rw_debug(s->g_cpu, addr, mem_buf, len, 1) != 0) {\n\n            put_packet(s, \"E14\");\n\n        } else {\n\n            put_packet(s, \"OK\");\n\n        }\n\n        break;\n\n    case 'p':\n\n        /* Older gdb are really dumb, and don't use 'g' if 'p' is avaialable.\n\n           This works, but can be very slow.  Anything new enough to\n\n           understand XML also knows how to use this properly.  */\n\n        if (!gdb_has_xml)\n\n            goto unknown_command;\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        reg_size = gdb_read_register(s->g_cpu, mem_buf, addr);\n\n        if (reg_size) {\n\n            memtohex(buf, mem_buf, reg_size);\n\n            put_packet(s, buf);\n\n        } else {\n\n            put_packet(s, \"E14\");\n\n        }\n\n        break;\n\n    case 'P':\n\n        if (!gdb_has_xml)\n\n            goto unknown_command;\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        if (*p == '=')\n\n            p++;\n\n        reg_size = strlen(p) / 2;\n\n        hextomem(mem_buf, p, reg_size);\n\n        gdb_write_register(s->g_cpu, mem_buf, addr);\n\n        put_packet(s, \"OK\");\n\n        break;\n\n    case 'Z':\n\n    case 'z':\n\n        type = strtoul(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        len = strtoull(p, (char **)&p, 16);\n\n        if (ch == 'Z')\n\n            res = gdb_breakpoint_insert(addr, len, type);\n\n        else\n\n            res = gdb_breakpoint_remove(addr, len, type);\n\n        if (res >= 0)\n\n             put_packet(s, \"OK\");\n\n        else if (res == -ENOSYS)\n\n            put_packet(s, \"\");\n\n        else\n\n            put_packet(s, \"E22\");\n\n        break;\n\n    case 'H':\n\n        type = *p++;\n\n        thread = strtoull(p, (char **)&p, 16);\n\n        if (thread == -1 || thread == 0) {\n\n            put_packet(s, \"OK\");\n\n            break;\n\n        }\n\n        env = find_cpu(thread);\n\n        if (env == NULL) {\n\n            put_packet(s, \"E22\");\n\n            break;\n\n        }\n\n        switch (type) {\n\n        case 'c':\n\n            s->c_cpu = env;\n\n            put_packet(s, \"OK\");\n\n            break;\n\n        case 'g':\n\n            s->g_cpu = env;\n\n            put_packet(s, \"OK\");\n\n            break;\n\n        default:\n\n             put_packet(s, \"E22\");\n\n             break;\n\n        }\n\n        break;\n\n    case 'T':\n\n        thread = strtoull(p, (char **)&p, 16);\n\n        env = find_cpu(thread);\n\n\n\n        if (env != NULL) {\n\n            put_packet(s, \"OK\");\n\n        } else {\n\n            put_packet(s, \"E22\");\n\n        }\n\n        break;\n\n    case 'q':\n\n    case 'Q':\n\n        /* parse any 'q' packets here */\n\n        if (!strcmp(p,\"qemu.sstepbits\")) {\n\n            /* Query Breakpoint bit definitions */\n\n            snprintf(buf, sizeof(buf), \"ENABLE=%x,NOIRQ=%x,NOTIMER=%x\",\n\n                     SSTEP_ENABLE,\n\n                     SSTEP_NOIRQ,\n\n                     SSTEP_NOTIMER);\n\n            put_packet(s, buf);\n\n            break;\n\n        } else if (strncmp(p,\"qemu.sstep\",10) == 0) {\n\n            /* Display or change the sstep_flags */\n\n            p += 10;\n\n            if (*p != '=') {\n\n                /* Display current setting */\n\n                snprintf(buf, sizeof(buf), \"0x%x\", sstep_flags);\n\n                put_packet(s, buf);\n\n                break;\n\n            }\n\n            p++;\n\n            type = strtoul(p, (char **)&p, 16);\n\n            sstep_flags = type;\n\n            put_packet(s, \"OK\");\n\n            break;\n\n        } else if (strcmp(p,\"C\") == 0) {\n\n            /* \"Current thread\" remains vague in the spec, so always return\n\n             *  the first CPU (gdb returns the first thread). */\n\n            put_packet(s, \"QC1\");\n\n            break;\n\n        } else if (strcmp(p,\"fThreadInfo\") == 0) {\n\n            s->query_cpu = first_cpu->env_ptr;\n\n            goto report_cpuinfo;\n\n        } else if (strcmp(p,\"sThreadInfo\") == 0) {\n\n        report_cpuinfo:\n\n            if (s->query_cpu) {\n\n                snprintf(buf, sizeof(buf), \"m%x\",\n\n                         cpu_index(ENV_GET_CPU(s->query_cpu)));\n\n                put_packet(s, buf);\n\n                s->query_cpu = ENV_GET_CPU(s->query_cpu)->next_cpu->env_ptr;\n\n            } else\n\n                put_packet(s, \"l\");\n\n            break;\n\n        } else if (strncmp(p,\"ThreadExtraInfo,\", 16) == 0) {\n\n            thread = strtoull(p+16, (char **)&p, 16);\n\n            env = find_cpu(thread);\n\n            if (env != NULL) {\n\n                CPUState *cpu = ENV_GET_CPU(env);\n\n                cpu_synchronize_state(cpu);\n\n                len = snprintf((char *)mem_buf, sizeof(mem_buf),\n\n                               \"CPU#%d [%s]\", cpu->cpu_index,\n\n                               cpu->halted ? \"halted \" : \"running\");\n\n                memtohex(buf, mem_buf, len);\n\n                put_packet(s, buf);\n\n            }\n\n            break;\n\n        }\n\n#ifdef CONFIG_USER_ONLY\n\n        else if (strncmp(p, \"Offsets\", 7) == 0) {\n\n            TaskState *ts = s->c_cpu->opaque;\n\n\n\n            snprintf(buf, sizeof(buf),\n\n                     \"Text=\" TARGET_ABI_FMT_lx \";Data=\" TARGET_ABI_FMT_lx\n\n                     \";Bss=\" TARGET_ABI_FMT_lx,\n\n                     ts->info->code_offset,\n\n                     ts->info->data_offset,\n\n                     ts->info->data_offset);\n\n            put_packet(s, buf);\n\n            break;\n\n        }\n\n#else /* !CONFIG_USER_ONLY */\n\n        else if (strncmp(p, \"Rcmd,\", 5) == 0) {\n\n            int len = strlen(p + 5);\n\n\n\n            if ((len % 2) != 0) {\n\n                put_packet(s, \"E01\");\n\n                break;\n\n            }\n\n            hextomem(mem_buf, p + 5, len);\n\n            len = len / 2;\n\n            mem_buf[len++] = 0;\n\n            qemu_chr_be_write(s->mon_chr, mem_buf, len);\n\n            put_packet(s, \"OK\");\n\n            break;\n\n        }\n\n#endif /* !CONFIG_USER_ONLY */\n\n        if (strncmp(p, \"Supported\", 9) == 0) {\n\n            snprintf(buf, sizeof(buf), \"PacketSize=%x\", MAX_PACKET_LENGTH);\n\n#ifdef GDB_CORE_XML\n\n            pstrcat(buf, sizeof(buf), \";qXfer:features:read+\");\n\n#endif\n\n            put_packet(s, buf);\n\n            break;\n\n        }\n\n#ifdef GDB_CORE_XML\n\n        if (strncmp(p, \"Xfer:features:read:\", 19) == 0) {\n\n            const char *xml;\n\n            target_ulong total_len;\n\n\n\n            gdb_has_xml = 1;\n\n            p += 19;\n\n            xml = get_feature_xml(p, &p);\n\n            if (!xml) {\n\n                snprintf(buf, sizeof(buf), \"E00\");\n\n                put_packet(s, buf);\n\n                break;\n\n            }\n\n\n\n            if (*p == ':')\n\n                p++;\n\n            addr = strtoul(p, (char **)&p, 16);\n\n            if (*p == ',')\n\n                p++;\n\n            len = strtoul(p, (char **)&p, 16);\n\n\n\n            total_len = strlen(xml);\n\n            if (addr > total_len) {\n\n                snprintf(buf, sizeof(buf), \"E00\");\n\n                put_packet(s, buf);\n\n                break;\n\n            }\n\n            if (len > (MAX_PACKET_LENGTH - 5) / 2)\n\n                len = (MAX_PACKET_LENGTH - 5) / 2;\n\n            if (len < total_len - addr) {\n\n                buf[0] = 'm';\n\n                len = memtox(buf + 1, xml + addr, len);\n\n            } else {\n\n                buf[0] = 'l';\n\n                len = memtox(buf + 1, xml + addr, total_len - addr);\n\n            }\n\n            put_packet_binary(s, buf, len + 1);\n\n            break;\n\n        }\n\n#endif\n\n        /* Unrecognised 'q' command.  */\n\n        goto unknown_command;\n\n\n\n    default:\n\n    unknown_command:\n\n        /* put empty packet */\n\n        buf[0] = '\\0';\n\n        put_packet(s, buf);\n\n        break;\n\n    }\n\n    return RS_IDLE;\n\n}\n", "idx": 23774, "_split": "valid", "_hash": "d59f4ff051bfc57bc4c69e7006fed7b5"}
{"project": "qemu", "commit_id": "599d0c45615b7d099d256738a586d0f63bc707e6", "target": 1, "func": "static int xen_host_pci_sysfs_path(const XenHostPCIDevice *d,\n\n                                   const char *name, char *buf, ssize_t size)\n\n{\n\n    int rc;\n\n\n\n    rc = snprintf(buf, size, \"/sys/bus/pci/devices/%04x:%02x:%02x.%d/%s\",\n\n                  d->domain, d->bus, d->dev, d->func, name);\n\n\n\n    if (rc >= size || rc < 0) {\n\n        /* The output is truncated, or some other error was encountered */\n\n        return -ENODEV;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23806, "_split": "valid", "_hash": "3f7fc785fb4e928c0ae05199bf51778c"}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_validate_fail_union_native_list(TestInputVisitorData *data,\n\n                                                 const void *unused)\n\n{\n\n    UserDefNativeListUnion *tmp = NULL;\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data,\n\n                           \"{ 'type': 'integer', 'data' : [ 'string' ] }\");\n\n\n\n    visit_type_UserDefNativeListUnion(v, NULL, &tmp, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!tmp);\n\n}\n", "idx": 23822, "_split": "valid", "_hash": "4df60d6f02a4dd0c64c8d23e9a63e0a0"}
{"project": "qemu", "commit_id": "b3f7f0c5e6449be7275f1762bccbfa2177395a3b", "target": 1, "func": "static int colo_do_checkpoint_transaction(MigrationState *s,\n\n                                          QIOChannelBuffer *bioc,\n\n                                          QEMUFile *fb)\n\n{\n\n    Error *local_err = NULL;\n\n    int ret = -1;\n\n\n\n    colo_send_message(s->to_dst_file, COLO_MESSAGE_CHECKPOINT_REQUEST,\n\n                      &local_err);\n\n    if (local_err) {\n\n\n\n\n\n    colo_receive_check_message(s->rp_state.from_dst_file,\n\n                    COLO_MESSAGE_CHECKPOINT_REPLY, &local_err);\n\n    if (local_err) {\n\n\n\n    /* Reset channel-buffer directly */\n\n    qio_channel_io_seek(QIO_CHANNEL(bioc), 0, 0, NULL);\n\n    bioc->usage = 0;\n\n\n\n    qemu_mutex_lock_iothread();\n\n\n\n\n\n    vm_stop_force_state(RUN_STATE_COLO);\n\n\n    trace_colo_vm_state_change(\"run\", \"stop\");\n\n\n\n\n\n\n\n\n\n\n    /* Disable block migration */\n\n    s->params.blk = 0;\n\n    s->params.shared = 0;\n\n    qemu_savevm_state_header(fb);\n\n    qemu_savevm_state_begin(fb, &s->params);\n\n    qemu_mutex_lock_iothread();\n\n    qemu_savevm_state_complete_precopy(fb, false);\n\n\n\n\n    qemu_fflush(fb);\n\n\n\n    colo_send_message(s->to_dst_file, COLO_MESSAGE_VMSTATE_SEND, &local_err);\n\n    if (local_err) {\n\n\n\n\n     * We need the size of the VMstate data in Secondary side,\n\n     * With which we can decide how much data should be read.\n\n\n    colo_send_message_value(s->to_dst_file, COLO_MESSAGE_VMSTATE_SIZE,\n\n                            bioc->usage, &local_err);\n\n    if (local_err) {\n\n\n\n\n\n    qemu_put_buffer(s->to_dst_file, bioc->data, bioc->usage);\n\n    qemu_fflush(s->to_dst_file);\n\n    ret = qemu_file_get_error(s->to_dst_file);\n\n    if (ret < 0) {\n\n\n\n\n\n    colo_receive_check_message(s->rp_state.from_dst_file,\n\n                       COLO_MESSAGE_VMSTATE_RECEIVED, &local_err);\n\n    if (local_err) {\n\n\n\n\n\n    colo_receive_check_message(s->rp_state.from_dst_file,\n\n                       COLO_MESSAGE_VMSTATE_LOADED, &local_err);\n\n    if (local_err) {\n\n\n\n\n\n    ret = 0;\n\n\n\n    qemu_mutex_lock_iothread();\n\n    vm_start();\n\n\n    trace_colo_vm_state_change(\"stop\", \"run\");\n\n\n\nout:\n\n    if (local_err) {\n\n        error_report_err(local_err);\n\n\n    return ret;\n", "idx": 23840, "_split": "valid", "_hash": "49fd891ae0cb41805da21afcca26491f"}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qpci_msix_disable(QPCIDevice *dev)\n\n{\n\n    uint8_t addr;\n\n    uint16_t val;\n\n\n\n    g_assert(dev->msix_enabled);\n\n    addr = qpci_find_capability(dev, PCI_CAP_ID_MSIX);\n\n    g_assert_cmphex(addr, !=, 0);\n\n    val = qpci_config_readw(dev, addr + PCI_MSIX_FLAGS);\n\n    qpci_config_writew(dev, addr + PCI_MSIX_FLAGS,\n\n                                                val & ~PCI_MSIX_FLAGS_ENABLE);\n\n\n\n    qpci_iounmap(dev, dev->msix_table);\n\n    qpci_iounmap(dev, dev->msix_pba);\n\n    dev->msix_enabled = 0;\n\n    dev->msix_table = NULL;\n\n    dev->msix_pba = NULL;\n\n}\n", "idx": 23841, "_split": "valid", "_hash": "0424921f6b16611e916474d19f39ee2f"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_rtc_s *omap_rtc_init(MemoryRegion *system_memory,\n\n                                        target_phys_addr_t base,\n\n                                        qemu_irq timerirq, qemu_irq alarmirq,\n\n                                        omap_clk clk)\n\n{\n\n    struct omap_rtc_s *s = (struct omap_rtc_s *)\n\n            g_malloc0(sizeof(struct omap_rtc_s));\n\n\n\n    s->irq = timerirq;\n\n    s->alarm = alarmirq;\n\n    s->clk = qemu_new_timer_ms(rtc_clock, omap_rtc_tick, s);\n\n\n\n    omap_rtc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_rtc_ops, s,\n\n                          \"omap-rtc\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 23847, "_split": "valid", "_hash": "f185574131bcb4b385ee22df8f2ef341"}
{"project": "qemu", "commit_id": "ccf1e2dcd6091eea1fc2341c63201aa1a6094978", "target": 0, "func": "static ssize_t qio_channel_socket_writev(QIOChannel *ioc,\n\n                                         const struct iovec *iov,\n\n                                         size_t niov,\n\n                                         int *fds,\n\n                                         size_t nfds,\n\n                                         Error **errp)\n\n{\n\n    QIOChannelSocket *sioc = QIO_CHANNEL_SOCKET(ioc);\n\n    ssize_t ret;\n\n    struct msghdr msg = { NULL, };\n\n    char control[CMSG_SPACE(sizeof(int) * SOCKET_MAX_FDS)] = { 0 };\n\n    size_t fdsize = sizeof(int) * nfds;\n\n    struct cmsghdr *cmsg;\n\n\n\n    msg.msg_iov = (struct iovec *)iov;\n\n    msg.msg_iovlen = niov;\n\n\n\n    if (nfds) {\n\n        if (nfds > SOCKET_MAX_FDS) {\n\n            error_setg_errno(errp, EINVAL,\n\n                             \"Only %d FDs can be sent, got %zu\",\n\n                             SOCKET_MAX_FDS, nfds);\n\n            return -1;\n\n        }\n\n\n\n        msg.msg_control = control;\n\n        msg.msg_controllen = CMSG_SPACE(sizeof(int) * nfds);\n\n\n\n        cmsg = CMSG_FIRSTHDR(&msg);\n\n        cmsg->cmsg_len = CMSG_LEN(fdsize);\n\n        cmsg->cmsg_level = SOL_SOCKET;\n\n        cmsg->cmsg_type = SCM_RIGHTS;\n\n        memcpy(CMSG_DATA(cmsg), fds, fdsize);\n\n    }\n\n\n\n retry:\n\n    ret = sendmsg(sioc->fd, &msg, 0);\n\n    if (ret <= 0) {\n\n        if (socket_error() == EAGAIN ||\n\n            socket_error() == EWOULDBLOCK) {\n\n            return QIO_CHANNEL_ERR_BLOCK;\n\n        }\n\n        if (socket_error() == EINTR) {\n\n            goto retry;\n\n        }\n\n        error_setg_errno(errp, socket_error(),\n\n                         \"Unable to write to socket\");\n\n        return -1;\n\n    }\n\n    return ret;\n\n}\n", "idx": 23849, "_split": "valid", "_hash": "4a6c278a53253bd252da0f9727c6d880"}
{"project": "qemu", "commit_id": "9167a69a816b8956d62da628b5b4dc87674647d6", "target": 0, "func": "void *lsi_scsi_init(PCIBus *bus, int devfn)\n\n{\n\n    LSIState *s;\n\n\n\n    s = (LSIState *)pci_register_device(bus, \"LSI53C895A SCSI HBA\",\n\n                                        sizeof(*s), devfn, NULL, NULL);\n\n    if (s == NULL) {\n\n        fprintf(stderr, \"lsi-scsi: Failed to register PCI device\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    s->pci_dev.config[0x00] = 0x00;\n\n    s->pci_dev.config[0x01] = 0x10;\n\n    s->pci_dev.config[0x02] = 0x12;\n\n    s->pci_dev.config[0x03] = 0x00;\n\n    s->pci_dev.config[0x0b] = 0x01;\n\n    s->pci_dev.config[0x3d] = 0x01; /* interrupt pin 1 */\n\n\n\n    s->mmio_io_addr = cpu_register_io_memory(0, lsi_mmio_readfn,\n\n                                             lsi_mmio_writefn, s);\n\n    s->ram_io_addr = cpu_register_io_memory(0, lsi_ram_readfn,\n\n                                            lsi_ram_writefn, s);\n\n\n\n    pci_register_io_region((struct PCIDevice *)s, 0, 256,\n\n                           PCI_ADDRESS_SPACE_IO, lsi_io_mapfunc);\n\n    pci_register_io_region((struct PCIDevice *)s, 1, 0x400,\n\n                           PCI_ADDRESS_SPACE_MEM, lsi_mmio_mapfunc);\n\n    pci_register_io_region((struct PCIDevice *)s, 2, 0x2000,\n\n                           PCI_ADDRESS_SPACE_MEM, lsi_ram_mapfunc);\n\n    s->queue = qemu_malloc(sizeof(lsi_queue));\n\n    s->queue_len = 1;\n\n    s->active_commands = 0;\n\n\n\n    lsi_soft_reset(s);\n\n\n\n    return s;\n\n}\n", "idx": 23861, "_split": "valid", "_hash": "86e4f97993ada2b7b44f6d553a3a6837"}
{"project": "qemu", "commit_id": "38ee14f4f33f8836fc0e209ca59c6ae8c6edf380", "target": 1, "func": "static void vnc_refresh(DisplayChangeListener *dcl)\n\n{\n\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n\n    VncState *vs, *vn;\n\n    int has_dirty, rects = 0;\n\n\n\n    graphic_hw_update(NULL);\n\n\n\n    if (vnc_trylock_display(vd)) {\n\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n\n        return;\n\n    }\n\n\n\n    has_dirty = vnc_refresh_server_surface(vd);\n\n    vnc_unlock_display(vd);\n\n\n\n    QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {\n\n        rects += vnc_update_client(vs, has_dirty);\n\n        /* vs might be free()ed here */\n\n    }\n\n\n\n    if (QTAILQ_EMPTY(&vd->clients)) {\n\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_MAX);\n\n        return;\n\n    }\n\n\n\n    if (has_dirty && rects) {\n\n        vd->dcl.update_interval /= 2;\n\n        if (vd->dcl.update_interval < VNC_REFRESH_INTERVAL_BASE) {\n\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_BASE;\n\n        }\n\n    } else {\n\n        vd->dcl.update_interval += VNC_REFRESH_INTERVAL_INC;\n\n        if (vd->dcl.update_interval > VNC_REFRESH_INTERVAL_MAX) {\n\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_MAX;\n\n        }\n\n    }\n\n}\n", "idx": 23894, "_split": "valid", "_hash": "1be4d02850ffd2ffcda9bed8224061cd"}
{"project": "qemu", "commit_id": "751f8cfe2a556b3ef49f6af2860e2d1d2a1ec66a", "target": 1, "func": "int monitor_set_cpu(int cpu_index)\n\n{\n\n    CPUState *cpu;\n\n\n\n    cpu = qemu_get_cpu(cpu_index);\n\n    if (cpu == NULL) {\n\n        return -1;\n\n    }\n\n    cur_mon->mon_cpu = cpu;\n\n    return 0;\n\n}\n", "idx": 23911, "_split": "valid", "_hash": "47406ec436974e33ca3782c28b2829d3"}
{"project": "qemu", "commit_id": "9ecaa27e7123211f45ca723a736ffae14f6c1f42", "target": 1, "func": "uint32_t HELPER(mul32)(CPUOpenRISCState *env,\n\n                       uint32_t ra, uint32_t rb)\n\n{\n\n    uint64_t result;\n\n    uint32_t high, cy;\n\n\n\n    OpenRISCCPU *cpu = openrisc_env_get_cpu(env);\n\n\n\n    result = (uint64_t)ra * rb;\n\n    /* regisiers in or32 is 32bit, so 32 is NOT a magic number.\n\n       or64 is not handled in this function, and not implement yet,\n\n       TARGET_LONG_BITS for or64 is 64, it will break this function,\n\n       so, we didn't use TARGET_LONG_BITS here.  */\n\n    high = result >> 32;\n\n    cy = result >> (32 - 1);\n\n\n\n    if ((cy & 0x1) == 0x0) {\n\n        if (high == 0x0) {\n\n            return result;\n\n        }\n\n    }\n\n\n\n    if ((cy & 0x1) == 0x1) {\n\n        if (high == 0xffffffff) {\n\n            return result;\n\n        }\n\n    }\n\n\n\n    cpu->env.sr |= (SR_OV | SR_CY);\n\n    if (cpu->env.sr & SR_OVE) {\n\n        raise_exception(cpu, EXCP_RANGE);\n\n    }\n\n\n\n    return result;\n\n}\n", "idx": 23949, "_split": "valid", "_hash": "91d36272d07f33aa1d540ef43d7d4dd4"}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float64 HELPER(ucf64_sf2df)(float32 x, CPUUniCore32State *env)\n\n{\n\n    return float32_to_float64(x, &env->ucf64.fp_status);\n\n}\n", "idx": 24042, "_split": "valid", "_hash": "941860b4d6434f4868dcae70548495e9"}
{"project": "qemu", "commit_id": "30656b097e9dd7978d3fe9416cb9f5a421a9e63e", "target": 0, "func": "static ssize_t colo_rewriter_receive_iov(NetFilterState *nf,\n\n                                         NetClientState *sender,\n\n                                         unsigned flags,\n\n                                         const struct iovec *iov,\n\n                                         int iovcnt,\n\n                                         NetPacketSent *sent_cb)\n\n{\n\n    RewriterState *s = FILTER_COLO_REWRITER(nf);\n\n    Connection *conn;\n\n    ConnectionKey key;\n\n    Packet *pkt;\n\n    ssize_t size = iov_size(iov, iovcnt);\n\n    char *buf = g_malloc0(size);\n\n\n\n    iov_to_buf(iov, iovcnt, 0, buf, size);\n\n    pkt = packet_new(buf, size);\n\n\n\n    /*\n\n     * if we get tcp packet\n\n     * we will rewrite it to make secondary guest's\n\n     * connection established successfully\n\n     */\n\n    if (pkt && is_tcp_packet(pkt)) {\n\n\n\n        fill_connection_key(pkt, &key);\n\n\n\n        if (sender == nf->netdev) {\n\n            /*\n\n             * We need make tcp TX and RX packet\n\n             * into one connection.\n\n             */\n\n            reverse_connection_key(&key);\n\n        }\n\n        conn = connection_get(s->connection_track_table,\n\n                              &key,\n\n                              NULL);\n\n\n\n        if (sender == nf->netdev) {\n\n            /* NET_FILTER_DIRECTION_TX */\n\n            /* handle_primary_tcp_pkt */\n\n        } else {\n\n            /* NET_FILTER_DIRECTION_RX */\n\n            /* handle_secondary_tcp_pkt */\n\n        }\n\n    }\n\n\n\n    packet_destroy(pkt, NULL);\n\n    pkt = NULL;\n\n    return 0;\n\n}\n", "idx": 24046, "_split": "valid", "_hash": "5592c1dbe899e6caae7cb31c4acbecfb"}
{"project": "qemu", "commit_id": "a3251186fc6a04d421e9c4b65aa04ec32379ec38", "target": 0, "func": "static CCPrepare gen_prepare_cc(DisasContext *s, int b, TCGv reg)\n\n{\n\n    int inv, jcc_op, size, cond;\n\n    CCPrepare cc;\n\n    TCGv t0;\n\n\n\n    inv = b & 1;\n\n    jcc_op = (b >> 1) & 7;\n\n\n\n    switch (s->cc_op) {\n\n    case CC_OP_SUBB ... CC_OP_SUBQ:\n\n        /* We optimize relational operators for the cmp/jcc case.  */\n\n        size = s->cc_op - CC_OP_SUBB;\n\n        switch (jcc_op) {\n\n        case JCC_BE:\n\n            tcg_gen_add_tl(cpu_tmp4, cpu_cc_dst, cpu_cc_src);\n\n            gen_extu(size, cpu_tmp4);\n\n            t0 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, false);\n\n            cc = (CCPrepare) { .cond = TCG_COND_LEU, .reg = cpu_tmp4,\n\n                               .reg2 = t0, .mask = -1, .use_reg2 = true };\n\n            break;\n\n\n\n        case JCC_L:\n\n            cond = TCG_COND_LT;\n\n            goto fast_jcc_l;\n\n        case JCC_LE:\n\n            cond = TCG_COND_LE;\n\n        fast_jcc_l:\n\n            tcg_gen_add_tl(cpu_tmp4, cpu_cc_dst, cpu_cc_src);\n\n            gen_exts(size, cpu_tmp4);\n\n            t0 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, true);\n\n            cc = (CCPrepare) { .cond = cond, .reg = cpu_tmp4,\n\n                               .reg2 = t0, .mask = -1, .use_reg2 = true };\n\n            break;\n\n\n\n        default:\n\n            goto slow_jcc;\n\n        }\n\n        break;\n\n\n\n    default:\n\n    slow_jcc:\n\n        /* This actually generates good code for JC, JZ and JS.  */\n\n        switch (jcc_op) {\n\n        case JCC_O:\n\n            cc = gen_prepare_eflags_o(s, reg);\n\n            break;\n\n        case JCC_B:\n\n            cc = gen_prepare_eflags_c(s, reg);\n\n            break;\n\n        case JCC_Z:\n\n            cc = gen_prepare_eflags_z(s, reg);\n\n            break;\n\n        case JCC_BE:\n\n            gen_compute_eflags(s);\n\n            cc = (CCPrepare) { .cond = TCG_COND_NE, .reg = cpu_cc_src,\n\n                               .mask = CC_Z | CC_C };\n\n            break;\n\n        case JCC_S:\n\n            cc = gen_prepare_eflags_s(s, reg);\n\n            break;\n\n        case JCC_P:\n\n            cc = gen_prepare_eflags_p(s, reg);\n\n            break;\n\n        case JCC_L:\n\n            gen_compute_eflags(s);\n\n            if (TCGV_EQUAL(reg, cpu_cc_src)) {\n\n                reg = cpu_tmp0;\n\n            }\n\n            tcg_gen_shri_tl(reg, cpu_cc_src, 4); /* CC_O -> CC_S */\n\n            tcg_gen_xor_tl(reg, reg, cpu_cc_src);\n\n            cc = (CCPrepare) { .cond = TCG_COND_NE, .reg = reg,\n\n                               .mask = CC_S };\n\n            break;\n\n        default:\n\n        case JCC_LE:\n\n            gen_compute_eflags(s);\n\n            if (TCGV_EQUAL(reg, cpu_cc_src)) {\n\n                reg = cpu_tmp0;\n\n            }\n\n            tcg_gen_shri_tl(reg, cpu_cc_src, 4); /* CC_O -> CC_S */\n\n            tcg_gen_xor_tl(reg, reg, cpu_cc_src);\n\n            cc = (CCPrepare) { .cond = TCG_COND_NE, .reg = reg,\n\n                               .mask = CC_S | CC_Z };\n\n            break;\n\n        }\n\n        break;\n\n    }\n\n\n\n    if (inv) {\n\n        cc.cond = tcg_invert_cond(cc.cond);\n\n    }\n\n    return cc;\n\n}\n", "idx": 24053, "_split": "valid", "_hash": "485fe3a7daad13a4343de024af422011"}
{"project": "qemu", "commit_id": "5706db1deb061ee9affdcea81e59c4c2cad7c41e", "target": 1, "func": "static int alsa_init_out (HWVoiceOut *hw, struct audsettings *as)\n\n{\n\n    ALSAVoiceOut *alsa = (ALSAVoiceOut *) hw;\n\n    struct alsa_params_req req;\n\n    struct alsa_params_obt obt;\n\n    snd_pcm_t *handle;\n\n    struct audsettings obt_as;\n\n\n\n    req.fmt = aud_to_alsafmt (as->fmt, as->endianness);\n\n    req.freq = as->freq;\n\n    req.nchannels = as->nchannels;\n\n    req.period_size = conf.period_size_out;\n\n    req.buffer_size = conf.buffer_size_out;\n\n    req.size_in_usec = conf.size_in_usec_out;\n\n    req.override_mask =\n\n        (conf.period_size_out_overridden ? 1 : 0) |\n\n        (conf.buffer_size_out_overridden ? 2 : 0);\n\n\n\n    if (alsa_open (0, &req, &obt, &handle)) {\n\n        return -1;\n\n    }\n\n\n\n    obt_as.freq = obt.freq;\n\n    obt_as.nchannels = obt.nchannels;\n\n    obt_as.fmt = obt.fmt;\n\n    obt_as.endianness = obt.endianness;\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    hw->samples = obt.samples;\n\n\n\n    alsa->pcm_buf = audio_calloc (AUDIO_FUNC, obt.samples, 1 << hw->info.shift);\n\n    if (!alsa->pcm_buf) {\n\n        dolog (\"Could not allocate DAC buffer (%d samples, each %d bytes)\\n\",\n\n               hw->samples, 1 << hw->info.shift);\n\n        alsa_anal_close1 (&handle);\n\n        return -1;\n\n    }\n\n\n\n    alsa->handle = handle;\n\n    return 0;\n\n}\n", "idx": 24066, "_split": "valid", "_hash": "268cb80b2415f8167c7c76dc7011f6c4"}
{"project": "qemu", "commit_id": "60dcbcb5b1a0d185be607b03fc7a15bf1bab4bec", "target": 0, "func": "static abi_ulong setup_arg_pages(abi_ulong p, struct linux_binprm *bprm,\n\n                                 struct image_info *info)\n\n{\n\n    abi_ulong stack_base, size, error;\n\n    int i;\n\n\n\n    /* Create enough stack to hold everything.  If we don't use\n\n     * it for args, we'll use it for something else...\n\n     */\n\n    size = guest_stack_size;\n\n    if (size < MAX_ARG_PAGES*TARGET_PAGE_SIZE)\n\n        size = MAX_ARG_PAGES*TARGET_PAGE_SIZE;\n\n    error = target_mmap(0,\n\n                        size + qemu_host_page_size,\n\n                        PROT_READ | PROT_WRITE,\n\n                        MAP_PRIVATE | MAP_ANONYMOUS,\n\n                        -1, 0);\n\n    if (error == -1) {\n\n        perror(\"stk mmap\");\n\n        exit(-1);\n\n    }\n\n    /* we reserve one extra page at the top of the stack as guard */\n\n    target_mprotect(error + size, qemu_host_page_size, PROT_NONE);\n\n\n\n    info->stack_limit = error;\n\n    stack_base = error + size - MAX_ARG_PAGES*TARGET_PAGE_SIZE;\n\n    p += stack_base;\n\n\n\n    for (i = 0 ; i < MAX_ARG_PAGES ; i++) {\n\n        if (bprm->page[i]) {\n\n            info->rss++;\n\n            /* FIXME - check return value of memcpy_to_target() for failure */\n\n            memcpy_to_target(stack_base, bprm->page[i], TARGET_PAGE_SIZE);\n\n            free(bprm->page[i]);\n\n        }\n\n        stack_base += TARGET_PAGE_SIZE;\n\n    }\n\n    return p;\n\n}\n", "idx": 24089, "_split": "valid", "_hash": "23283fae0229e3b35e884ea50834c811"}
{"project": "qemu", "commit_id": "9ef91a677110ec200d7b2904fc4bcae5a77329ad", "target": 0, "func": "static size_t handle_aiocb_rw_vector(struct qemu_paiocb *aiocb)\n\n{\n\n    size_t offset = 0;\n\n    ssize_t len;\n\n\n\n    do {\n\n        if (aiocb->aio_type == QEMU_PAIO_WRITE)\n\n            len = qemu_pwritev(aiocb->aio_fildes,\n\n                               aiocb->aio_iov,\n\n                               aiocb->aio_niov,\n\n                               aiocb->aio_offset + offset);\n\n         else\n\n            len = qemu_preadv(aiocb->aio_fildes,\n\n                              aiocb->aio_iov,\n\n                              aiocb->aio_niov,\n\n                              aiocb->aio_offset + offset);\n\n    } while (len == -1 && errno == EINTR);\n\n\n\n    if (len == -1)\n\n        return -errno;\n\n    return len;\n\n}\n", "idx": 24095, "_split": "valid", "_hash": "661a278d7bc001ca4c65aeda65506158"}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static VncClientInfo *qmp_query_vnc_client(const VncState *client)\n\n{\n\n    struct sockaddr_storage sa;\n\n    socklen_t salen = sizeof(sa);\n\n    char host[NI_MAXHOST];\n\n    char serv[NI_MAXSERV];\n\n    VncClientInfo *info;\n\n\n\n    if (getpeername(client->csock, (struct sockaddr *)&sa, &salen) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    if (getnameinfo((struct sockaddr *)&sa, salen,\n\n                    host, sizeof(host),\n\n                    serv, sizeof(serv),\n\n                    NI_NUMERICHOST | NI_NUMERICSERV) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    info = g_malloc0(sizeof(*info));\n\n    info->base = g_malloc0(sizeof(*info->base));\n\n    info->base->host = g_strdup(host);\n\n    info->base->service = g_strdup(serv);\n\n    info->base->family = inet_netfamily(sa.ss_family);\n\n    info->base->websocket = client->websocket;\n\n\n\n#ifdef CONFIG_VNC_TLS\n\n    if (client->tls.session && client->tls.dname) {\n\n        info->has_x509_dname = true;\n\n        info->x509_dname = g_strdup(client->tls.dname);\n\n    }\n\n#endif\n\n#ifdef CONFIG_VNC_SASL\n\n    if (client->sasl.conn && client->sasl.username) {\n\n        info->has_sasl_username = true;\n\n        info->sasl_username = g_strdup(client->sasl.username);\n\n    }\n\n#endif\n\n\n\n    return info;\n\n}\n", "idx": 24114, "_split": "valid", "_hash": "5e85d8ba987313f1de2700ebe6d0d32b"}
{"project": "qemu", "commit_id": "ea375f9ab8c76686dca0af8cb4f87a4eb569cad3", "target": 1, "func": "int kvm_arch_put_registers(CPUState *env)\n\n{\n\n    struct kvm_regs regs;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = kvm_vcpu_ioctl(env, KVM_GET_REGS, &regs);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    regs.ctr = env->ctr;\n\n    regs.lr  = env->lr;\n\n    regs.xer = env->xer;\n\n    regs.msr = env->msr;\n\n    regs.pc = env->nip;\n\n\n\n    regs.srr0 = env->spr[SPR_SRR0];\n\n    regs.srr1 = env->spr[SPR_SRR1];\n\n\n\n    regs.sprg0 = env->spr[SPR_SPRG0];\n\n    regs.sprg1 = env->spr[SPR_SPRG1];\n\n    regs.sprg2 = env->spr[SPR_SPRG2];\n\n    regs.sprg3 = env->spr[SPR_SPRG3];\n\n    regs.sprg4 = env->spr[SPR_SPRG4];\n\n    regs.sprg5 = env->spr[SPR_SPRG5];\n\n    regs.sprg6 = env->spr[SPR_SPRG6];\n\n    regs.sprg7 = env->spr[SPR_SPRG7];\n\n\n\n    for (i = 0;i < 32; i++)\n\n        regs.gpr[i] = env->gpr[i];\n\n\n\n    ret = kvm_vcpu_ioctl(env, KVM_SET_REGS, &regs);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    return ret;\n\n}\n", "idx": 24117, "_split": "valid", "_hash": "93bc5b0e7b242ab1c2bf382dd5d5abe0"}
{"project": "qemu", "commit_id": "5b5cb08683b6715a2aca5314168e68ff0665912b", "target": 0, "func": "static void msix_mmio_writel(void *opaque, target_phys_addr_t addr,\n\n                             uint32_t val)\n\n{\n\n    PCIDevice *dev = opaque;\n\n    unsigned int offset = addr & (MSIX_PAGE_SIZE - 1) & ~0x3;\n\n    int vector = offset / MSIX_ENTRY_SIZE;\n\n    pci_set_long(dev->msix_table_page + offset, val);\n\n    if (!msix_is_masked(dev, vector) && msix_is_pending(dev, vector)) {\n\n        msix_clr_pending(dev, vector);\n\n        msix_notify(dev, vector);\n\n    }\n\n}\n", "idx": 24156, "_split": "valid", "_hash": "2a4a14eb3270f90aa112585c4b0bd8bd"}
{"project": "qemu", "commit_id": "698feb5e13a2d763369909ce33f2bd7a7c1c11c0", "target": 0, "func": "static void vhost_iommu_region_del(MemoryListener *listener,\n\n                                   MemoryRegionSection *section)\n\n{\n\n    struct vhost_dev *dev = container_of(listener, struct vhost_dev,\n\n                                         iommu_listener);\n\n    struct vhost_iommu *iommu;\n\n\n\n    if (!memory_region_is_iommu(section->mr)) {\n\n        return;\n\n    }\n\n\n\n    QLIST_FOREACH(iommu, &dev->iommu_list, iommu_next) {\n\n        if (iommu->mr == section->mr) {\n\n            memory_region_unregister_iommu_notifier(iommu->mr,\n\n                                                    &iommu->n);\n\n            QLIST_REMOVE(iommu, iommu_next);\n\n            g_free(iommu);\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 24160, "_split": "valid", "_hash": "99f34088bf1229f2bf36b0d70f816321"}
{"project": "qemu", "commit_id": "ba5e6bfa1aee29a8f72c5538c565dfb9889cf273", "target": 0, "func": "static void vfio_vga_quirk_teardown(VFIOPCIDevice *vdev)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < ARRAY_SIZE(vdev->vga.region); i++) {\n\n        while (!QLIST_EMPTY(&vdev->vga.region[i].quirks)) {\n\n            VFIOQuirk *quirk = QLIST_FIRST(&vdev->vga.region[i].quirks);\n\n            memory_region_del_subregion(&vdev->vga.region[i].mem, &quirk->mem);\n\n            object_unparent(OBJECT(&quirk->mem));\n\n            QLIST_REMOVE(quirk, next);\n\n            g_free(quirk);\n\n        }\n\n    }\n\n}\n", "idx": 24161, "_split": "valid", "_hash": "8b51492f6fa429bae05c6b00dcf1501d"}
{"project": "qemu", "commit_id": "6dc06f08b3d6c0347df00ac68d9f30e2b233a749", "target": 0, "func": "int scsi_req_get_sense(SCSIRequest *req, uint8_t *buf, int len)\n\n{\n\n    assert(len >= 14);\n\n    if (!req->sense_len) {\n\n        return 0;\n\n    }\n\n    return scsi_build_sense(req->sense, req->sense_len, buf, len, true);\n\n}\n", "idx": 24168, "_split": "valid", "_hash": "11cb622a2fb3736c2848ae415200d260"}
{"project": "qemu", "commit_id": "250a87d5561a7212fe43357b084f69992eced75a", "target": 0, "func": "uint64_t HELPER(popcnt)(uint64_t r2)\n\n{\n\n    uint64_t ret = 0;\n\n    int i;\n\n\n\n    for (i = 0; i < 64; i += 8) {\n\n        uint64_t t = ctpop32((r2 >> i) & 0xff);\n\n        ret |= t << i;\n\n    }\n\n    return ret;\n\n}\n", "idx": 24199, "_split": "valid", "_hash": "13c857895d88e1dec5df4d08960c4ff6"}
{"project": "qemu", "commit_id": "92fb73b9b0c0ba40d1dbef61dc798bf9499d084a", "target": 0, "func": "static void pxa2xx_lcdc_dma0_redraw_vert(struct pxa2xx_lcdc_s *s,\n\n                uint8_t *fb, int *miny, int *maxy)\n\n{\n\n    int y, src_width, dest_width, dirty[2];\n\n    uint8_t *src, *dest;\n\n    ram_addr_t x, addr, new_addr, start, end;\n\n    drawfn fn = 0;\n\n    if (s->dest_width)\n\n        fn = s->line_fn[s->transp][s->bpp];\n\n    if (!fn)\n\n        return;\n\n\n\n    src = fb;\n\n    src_width = (s->xres + 3) & ~3;     /* Pad to a 4 pixels multiple */\n\n    if (s->bpp == pxa_lcdc_19pbpp || s->bpp == pxa_lcdc_18pbpp)\n\n        src_width *= 3;\n\n    else if (s->bpp > pxa_lcdc_16bpp)\n\n        src_width *= 4;\n\n    else if (s->bpp > pxa_lcdc_8bpp)\n\n        src_width *= 2;\n\n\n\n    dest_width = s->yres * s->dest_width;\n\n    dest = ds_get_data(s->ds) + dest_width * (s->xres - 1);\n\n\n\n    addr = (ram_addr_t) (fb - phys_ram_base);\n\n    start = addr + s->yres * src_width;\n\n    end = addr;\n\n    dirty[0] = dirty[1] = cpu_physical_memory_get_dirty(start, VGA_DIRTY_FLAG);\n\n    for (y = 0; y < s->yres; y ++) {\n\n        new_addr = addr + src_width;\n\n        for (x = addr + TARGET_PAGE_SIZE; x < new_addr;\n\n                        x += TARGET_PAGE_SIZE) {\n\n            dirty[1] = cpu_physical_memory_get_dirty(x, VGA_DIRTY_FLAG);\n\n            dirty[0] |= dirty[1];\n\n        }\n\n        if (dirty[0] || s->invalidated) {\n\n            fn((uint32_t *) s->dma_ch[0].palette,\n\n                            dest, src, s->xres, -dest_width);\n\n            if (addr < start)\n\n                start = addr;\n\n            end = new_addr;\n\n            if (y < *miny)\n\n                *miny = y;\n\n            if (y >= *maxy)\n\n                *maxy = y + 1;\n\n        }\n\n        addr = new_addr;\n\n        dirty[0] = dirty[1];\n\n        src += src_width;\n\n        dest += s->dest_width;\n\n    }\n\n\n\n    if (end > start)\n\n        cpu_physical_memory_reset_dirty(start, end, VGA_DIRTY_FLAG);\n\n}\n", "idx": 24218, "_split": "valid", "_hash": "b62874515c4c787036942a91ece48371"}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_backspace(void)\n\n{\n\n    if (term_cmd_buf_index > 0) {\n\n        term_backward_char();\n\n        term_delete_char();\n\n    }\n\n}\n", "idx": 24219, "_split": "valid", "_hash": "3f18b8852eabc05066f7ed05caa11f4c"}
{"project": "qemu", "commit_id": "b3a62939561e07bc34493444fa926b6137cba4e8", "target": 0, "func": "TCGv_i64 tcg_global_reg_new_i64(int reg, const char *name)\n\n{\n\n    int idx;\n\n\n\n    idx = tcg_global_reg_new_internal(TCG_TYPE_I64, reg, name);\n\n    return MAKE_TCGV_I64(idx);\n\n}\n", "idx": 24308, "_split": "valid", "_hash": "0870edd94185873acb3647fc55a686dd"}
{"project": "qemu", "commit_id": "908c67fca4b2c12a9b2336aa9c188f84468b60b7", "target": 0, "func": "static void gen_window_check1(DisasContext *dc, unsigned r1)\n\n{\n\n    if (dc->tb->flags & XTENSA_TBFLAG_EXCM) {\n\n        return;\n\n    }\n\n    if (option_enabled(dc, XTENSA_OPTION_WINDOWED_REGISTER) &&\n\n            r1 / 4 > dc->used_window) {\n\n        TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n        TCGv_i32 w = tcg_const_i32(r1 / 4);\n\n\n\n        dc->used_window = r1 / 4;\n\n        gen_advance_ccount(dc);\n\n        gen_helper_window_check(cpu_env, pc, w);\n\n\n\n        tcg_temp_free(w);\n\n        tcg_temp_free(pc);\n\n    }\n\n}\n", "idx": 24309, "_split": "valid", "_hash": "b0373341030052ffe6ba9cd35c81c089"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_notify(AioContext *ctx)\n\n{\n\n    /* Write e.g. bh->scheduled before reading ctx->notify_me.  Pairs\n\n     * with atomic_or in aio_ctx_prepare or atomic_add in aio_poll.\n\n     */\n\n    smp_mb();\n\n    if (ctx->notify_me) {\n\n        event_notifier_set(&ctx->notifier);\n\n        atomic_mb_set(&ctx->notified, true);\n\n    }\n\n}\n", "idx": 24318, "_split": "valid", "_hash": "19db7cff512683077f86ab58de015b94"}
{"project": "qemu", "commit_id": "d3c348b6e3af3598bfcb755d59f8f4de80a2228a", "target": 0, "func": "static void xlnx_zynqmp_qspips_reset(DeviceState *d)\n\n{\n\n    XlnxZynqMPQSPIPS *s = XLNX_ZYNQMP_QSPIPS(d);\n\n    int i;\n\n\n\n    xilinx_spips_reset(d);\n\n\n\n    for (i = 0; i < XLNX_ZYNQMP_SPIPS_R_MAX; i++) {\n\n        s->regs[i] = 0;\n\n    }\n\n    fifo8_reset(&s->rx_fifo_g);\n\n    fifo8_reset(&s->rx_fifo_g);\n\n    fifo32_reset(&s->fifo_g);\n\n    s->regs[R_INTR_STATUS] = R_INTR_STATUS_RESET;\n\n    s->regs[R_GPIO] = 1;\n\n    s->regs[R_LPBK_DLY_ADJ] = R_LPBK_DLY_ADJ_RESET;\n\n    s->regs[R_GQSPI_GFIFO_THRESH] = 0x10;\n\n    s->regs[R_MOD_ID] = 0x01090101;\n\n    s->regs[R_GQSPI_IMR] = R_GQSPI_IMR_RESET;\n\n    s->regs[R_GQSPI_TX_THRESH] = 1;\n\n    s->regs[R_GQSPI_RX_THRESH] = 1;\n\n    s->regs[R_GQSPI_GPIO] = 1;\n\n    s->regs[R_GQSPI_LPBK_DLY_ADJ] = R_GQSPI_LPBK_DLY_ADJ_RESET;\n\n    s->regs[R_GQSPI_MOD_ID] = R_GQSPI_MOD_ID_RESET;\n\n    s->regs[R_QSPIDMA_DST_CTRL] = R_QSPIDMA_DST_CTRL_RESET;\n\n    s->regs[R_QSPIDMA_DST_I_MASK] = R_QSPIDMA_DST_I_MASK_RESET;\n\n    s->regs[R_QSPIDMA_DST_CTRL2] = R_QSPIDMA_DST_CTRL2_RESET;\n\n    s->man_start_com_g = false;\n\n    s->gqspi_irqline = 0;\n\n    xlnx_zynqmp_qspips_update_ixr(s);\n\n}\n", "idx": 24320, "_split": "valid", "_hash": "774aa4577d031a66284124e6d1724e98"}
{"project": "qemu", "commit_id": "715c54071a43ab978dc12b9da22a5016203ed284", "target": 0, "func": "static void spapr_reset_htab(sPAPRMachineState *spapr)\n\n{\n\n    long shift;\n\n    int index;\n\n\n\n    shift = kvmppc_reset_htab(spapr->htab_shift);\n\n    if (shift < 0) {\n\n        error_setg(&error_abort, \"Failed to reset HTAB\");\n\n    } else if (shift > 0) {\n\n        if (shift != spapr->htab_shift) {\n\n            error_setg(&error_abort, \"Requested HTAB allocation failed during reset\");\n\n        }\n\n\n\n        /* Tell readers to update their file descriptor */\n\n        if (spapr->htab_fd >= 0) {\n\n            spapr->htab_fd_stale = true;\n\n        }\n\n    } else {\n\n        memset(spapr->htab, 0, HTAB_SIZE(spapr));\n\n\n\n        for (index = 0; index < HTAB_SIZE(spapr) / HASH_PTE_SIZE_64; index++) {\n\n            DIRTY_HPTE(HPTE(spapr->htab, index));\n\n        }\n\n    }\n\n\n\n    /* Update the RMA size if necessary */\n\n    if (spapr->vrma_adjust) {\n\n        spapr->rma_size = kvmppc_rma_size(spapr_node0_size(),\n\n                                          spapr->htab_shift);\n\n    }\n\n}\n", "idx": 24326, "_split": "valid", "_hash": "8d94ae7907681898aac28ad62d4d9cc2"}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void load_tco(const TestData *d)\n\n{\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO_RLD, 4);\n\n}\n", "idx": 24334, "_split": "valid", "_hash": "ea48de32862cec68db6a4ca19c7537f0"}
{"project": "qemu", "commit_id": "4bc02e230d1e0fd41d2a892d81dcad56e3b3702d", "target": 1, "func": "target_ulong helper_srad(CPUPPCState *env, target_ulong value,\n\n                         target_ulong shift)\n\n{\n\n    int64_t ret;\n\n\n\n    if (likely(!(shift & 0x40))) {\n\n        if (likely((uint64_t)shift != 0)) {\n\n            shift &= 0x3f;\n\n            ret = (int64_t)value >> shift;\n\n            if (likely(ret >= 0 || (value & ((1 << shift) - 1)) == 0)) {\n\n                env->ca = 0;\n\n            } else {\n\n                env->ca = 1;\n\n            }\n\n        } else {\n\n            ret = (int64_t)value;\n\n            env->ca = 0;\n\n        }\n\n    } else {\n\n        ret = (int64_t)value >> 63;\n\n        env->ca = (ret != 0);\n\n    }\n\n    return ret;\n\n}\n", "idx": 24336, "_split": "valid", "_hash": "5a48cace128a69287d1163ec3906a3a9"}
{"project": "qemu", "commit_id": "e3cffe6fad29e07d401eabb913a6d88501d5c143", "target": 1, "func": "static target_ulong h_remove(PowerPCCPU *cpu, sPAPRMachineState *spapr,\n\n                             target_ulong opcode, target_ulong *args)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    target_ulong flags = args[0];\n\n    target_ulong pte_index = args[1];\n\n    target_ulong avpn = args[2];\n\n    RemoveResult ret;\n\n\n\n    ret = remove_hpte(cpu, pte_index, avpn, flags,\n\n                      &args[0], &args[1]);\n\n\n\n    switch (ret) {\n\n    case REMOVE_SUCCESS:\n\n        check_tlb_flush(env);\n\n        return H_SUCCESS;\n\n\n\n    case REMOVE_NOT_FOUND:\n\n        return H_NOT_FOUND;\n\n\n\n    case REMOVE_PARM:\n\n        return H_PARAMETER;\n\n\n\n    case REMOVE_HW:\n\n        return H_HARDWARE;\n\n    }\n\n\n\n    g_assert_not_reached();\n\n}\n", "idx": 24339, "_split": "valid", "_hash": "fd6809fb484edda46a8bd917eca79cfa"}
{"project": "qemu", "commit_id": "4154c7e03fa55b4cf52509a83d50d6c09d743b77", "target": 1, "func": "e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)\n\n{\n\n    return core->mac[r->dh] == core->mac[r->dt];\n\n}\n", "idx": 24384, "_split": "valid", "_hash": "66d9d5d42e01a479f9e36e98cac63949"}
{"project": "qemu", "commit_id": "9ed257d1d1c65dbe5a08f207e5106e98384e1860", "target": 1, "func": "void xen_hvm_init(PCMachineState *pcms, MemoryRegion **ram_memory)\n\n{\n\n    int i, rc;\n\n    xen_pfn_t ioreq_pfn;\n\n    xen_pfn_t bufioreq_pfn;\n\n    evtchn_port_t bufioreq_evtchn;\n\n    XenIOState *state;\n\n\n\n    state = g_malloc0(sizeof (XenIOState));\n\n\n\n    state->xce_handle = xenevtchn_open(NULL, 0);\n\n    if (state->xce_handle == NULL) {\n\n        perror(\"xen: event channel open\");\n\n        goto err;\n\n    }\n\n\n\n    state->xenstore = xs_daemon_open();\n\n    if (state->xenstore == NULL) {\n\n        perror(\"xen: xenstore open\");\n\n        goto err;\n\n    }\n\n\n\n    rc = xen_create_ioreq_server(xen_xc, xen_domid, &state->ioservid);\n\n    if (rc < 0) {\n\n        perror(\"xen: ioreq server create\");\n\n        goto err;\n\n    }\n\n\n\n    state->exit.notify = xen_exit_notifier;\n\n    qemu_add_exit_notifier(&state->exit);\n\n\n\n    state->suspend.notify = xen_suspend_notifier;\n\n    qemu_register_suspend_notifier(&state->suspend);\n\n\n\n    state->wakeup.notify = xen_wakeup_notifier;\n\n    qemu_register_wakeup_notifier(&state->wakeup);\n\n\n\n    rc = xen_get_ioreq_server_info(xen_xc, xen_domid, state->ioservid,\n\n                                   &ioreq_pfn, &bufioreq_pfn,\n\n                                   &bufioreq_evtchn);\n\n    if (rc < 0) {\n\n        error_report(\"failed to get ioreq server info: error %d handle=\" XC_INTERFACE_FMT,\n\n                     errno, xen_xc);\n\n        goto err;\n\n    }\n\n\n\n    DPRINTF(\"shared page at pfn %lx\\n\", ioreq_pfn);\n\n    DPRINTF(\"buffered io page at pfn %lx\\n\", bufioreq_pfn);\n\n    DPRINTF(\"buffered io evtchn is %x\\n\", bufioreq_evtchn);\n\n\n\n    state->shared_page = xc_map_foreign_range(xen_xc, xen_domid, XC_PAGE_SIZE,\n\n                                              PROT_READ|PROT_WRITE, ioreq_pfn);\n\n    if (state->shared_page == NULL) {\n\n        error_report(\"map shared IO page returned error %d handle=\" XC_INTERFACE_FMT,\n\n                     errno, xen_xc);\n\n        goto err;\n\n    }\n\n\n\n    rc = xen_get_vmport_regs_pfn(xen_xc, xen_domid, &ioreq_pfn);\n\n    if (!rc) {\n\n        DPRINTF(\"shared vmport page at pfn %lx\\n\", ioreq_pfn);\n\n        state->shared_vmport_page =\n\n            xc_map_foreign_range(xen_xc, xen_domid, XC_PAGE_SIZE,\n\n                                 PROT_READ|PROT_WRITE, ioreq_pfn);\n\n        if (state->shared_vmport_page == NULL) {\n\n            error_report(\"map shared vmport IO page returned error %d handle=\"\n\n                         XC_INTERFACE_FMT, errno, xen_xc);\n\n            goto err;\n\n        }\n\n    } else if (rc != -ENOSYS) {\n\n        error_report(\"get vmport regs pfn returned error %d, rc=%d\",\n\n                     errno, rc);\n\n        goto err;\n\n    }\n\n\n\n    state->buffered_io_page = xc_map_foreign_range(xen_xc, xen_domid,\n\n                                                   XC_PAGE_SIZE,\n\n                                                   PROT_READ|PROT_WRITE,\n\n                                                   bufioreq_pfn);\n\n    if (state->buffered_io_page == NULL) {\n\n        error_report(\"map buffered IO page returned error %d\", errno);\n\n        goto err;\n\n    }\n\n\n\n    /* Note: cpus is empty at this point in init */\n\n    state->cpu_by_vcpu_id = g_malloc0(max_cpus * sizeof(CPUState *));\n\n\n\n    rc = xen_set_ioreq_server_state(xen_xc, xen_domid, state->ioservid, true);\n\n    if (rc < 0) {\n\n        error_report(\"failed to enable ioreq server info: error %d handle=\" XC_INTERFACE_FMT,\n\n                     errno, xen_xc);\n\n        goto err;\n\n    }\n\n\n\n    state->ioreq_local_port = g_malloc0(max_cpus * sizeof (evtchn_port_t));\n\n\n\n    /* FIXME: how about if we overflow the page here? */\n\n    for (i = 0; i < max_cpus; i++) {\n\n        rc = xenevtchn_bind_interdomain(state->xce_handle, xen_domid,\n\n                                        xen_vcpu_eport(state->shared_page, i));\n\n        if (rc == -1) {\n\n            error_report(\"shared evtchn %d bind error %d\", i, errno);\n\n            goto err;\n\n        }\n\n        state->ioreq_local_port[i] = rc;\n\n    }\n\n\n\n    rc = xenevtchn_bind_interdomain(state->xce_handle, xen_domid,\n\n                                    bufioreq_evtchn);\n\n    if (rc == -1) {\n\n        error_report(\"buffered evtchn bind error %d\", errno);\n\n        goto err;\n\n    }\n\n    state->bufioreq_local_port = rc;\n\n\n\n    /* Init RAM management */\n\n    xen_map_cache_init(xen_phys_offset_to_gaddr, state);\n\n    xen_ram_init(pcms, ram_size, ram_memory);\n\n\n\n    qemu_add_vm_change_state_handler(xen_hvm_change_state_handler, state);\n\n\n\n    state->memory_listener = xen_memory_listener;\n\n    QLIST_INIT(&state->physmap);\n\n    memory_listener_register(&state->memory_listener, &address_space_memory);\n\n    state->log_for_dirtybit = NULL;\n\n\n\n    state->io_listener = xen_io_listener;\n\n    memory_listener_register(&state->io_listener, &address_space_io);\n\n\n\n    state->device_listener = xen_device_listener;\n\n    device_listener_register(&state->device_listener);\n\n\n\n    /* Initialize backend core & drivers */\n\n    if (xen_be_init() != 0) {\n\n        error_report(\"xen backend core setup failed\");\n\n        goto err;\n\n    }\n\n    xen_be_register(\"console\", &xen_console_ops);\n\n    xen_be_register(\"vkbd\", &xen_kbdmouse_ops);\n\n    xen_be_register(\"qdisk\", &xen_blkdev_ops);\n\n    xen_read_physmap(state);\n\n    return;\n\n\n\nerr:\n\n    error_report(\"xen hardware virtual machine initialisation failed\");\n\n    exit(1);\n\n}\n", "idx": 24392, "_split": "valid", "_hash": "4b809a6a4ac649675799f6d013b5055b"}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtol_full_empty(void)\n\n{\n\n    const char *str = \"\";\n\n    long res = 999L;\n\n    int err;\n\n\n\n    err =  qemu_strtol(str, NULL, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n}\n", "idx": 24410, "_split": "valid", "_hash": "734a8d77c9e105aa4951f6529dd848db"}
{"project": "qemu", "commit_id": "3d90c6254863693a6b13d918d2b8682e08bbc681", "target": 1, "func": "static void vga_draw_graphic(VGACommonState *s, int full_update)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s->con);\n\n    int y1, y, update, linesize, y_start, double_scan, mask, depth;\n\n    int width, height, shift_control, line_offset, bwidth, bits;\n\n    ram_addr_t page0, page1;\n\n    DirtyBitmapSnapshot *snap = NULL;\n\n    int disp_width, multi_scan, multi_run;\n\n    uint8_t *d;\n\n    uint32_t v, addr1, addr;\n\n    vga_draw_line_func *vga_draw_line = NULL;\n\n    bool share_surface;\n\n    pixman_format_code_t format;\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n    bool byteswap = !s->big_endian_fb;\n\n#else\n\n    bool byteswap = s->big_endian_fb;\n\n#endif\n\n\n\n    full_update |= update_basic_params(s);\n\n\n\n    s->get_resolution(s, &width, &height);\n\n    disp_width = width;\n\n\n\n    shift_control = (s->gr[VGA_GFX_MODE] >> 5) & 3;\n\n    double_scan = (s->cr[VGA_CRTC_MAX_SCAN] >> 7);\n\n    if (shift_control != 1) {\n\n        multi_scan = (((s->cr[VGA_CRTC_MAX_SCAN] & 0x1f) + 1) << double_scan)\n\n            - 1;\n\n    } else {\n\n        /* in CGA modes, multi_scan is ignored */\n\n        /* XXX: is it correct ? */\n\n        multi_scan = double_scan;\n\n    }\n\n    multi_run = multi_scan;\n\n    if (shift_control != s->shift_control ||\n\n        double_scan != s->double_scan) {\n\n        full_update = 1;\n\n        s->shift_control = shift_control;\n\n        s->double_scan = double_scan;\n\n    }\n\n\n\n    if (shift_control == 0) {\n\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n\n            disp_width <<= 1;\n\n        }\n\n    } else if (shift_control == 1) {\n\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n\n            disp_width <<= 1;\n\n        }\n\n    }\n\n\n\n    depth = s->get_bpp(s);\n\n\n\n    /*\n\n     * Check whether we can share the surface with the backend\n\n     * or whether we need a shadow surface. We share native\n\n     * endian surfaces for 15bpp and above and byteswapped\n\n     * surfaces for 24bpp and above.\n\n     */\n\n    format = qemu_default_pixman_format(depth, !byteswap);\n\n    if (format) {\n\n        share_surface = dpy_gfx_check_format(s->con, format)\n\n            && !s->force_shadow;\n\n    } else {\n\n        share_surface = false;\n\n    }\n\n    if (s->line_offset != s->last_line_offset ||\n\n        disp_width != s->last_width ||\n\n        height != s->last_height ||\n\n        s->last_depth != depth ||\n\n        s->last_byteswap != byteswap ||\n\n        share_surface != is_buffer_shared(surface)) {\n\n        if (share_surface) {\n\n            surface = qemu_create_displaysurface_from(disp_width,\n\n                    height, format, s->line_offset,\n\n                    s->vram_ptr + (s->start_addr * 4));\n\n            dpy_gfx_replace_surface(s->con, surface);\n\n        } else {\n\n            qemu_console_resize(s->con, disp_width, height);\n\n            surface = qemu_console_surface(s->con);\n\n        }\n\n        s->last_scr_width = disp_width;\n\n        s->last_scr_height = height;\n\n        s->last_width = disp_width;\n\n        s->last_height = height;\n\n        s->last_line_offset = s->line_offset;\n\n        s->last_depth = depth;\n\n        s->last_byteswap = byteswap;\n\n        full_update = 1;\n\n    } else if (is_buffer_shared(surface) &&\n\n               (full_update || surface_data(surface) != s->vram_ptr\n\n                + (s->start_addr * 4))) {\n\n        pixman_format_code_t format =\n\n            qemu_default_pixman_format(depth, !byteswap);\n\n        surface = qemu_create_displaysurface_from(disp_width,\n\n                height, format, s->line_offset,\n\n                s->vram_ptr + (s->start_addr * 4));\n\n        dpy_gfx_replace_surface(s->con, surface);\n\n    }\n\n\n\n    if (shift_control == 0) {\n\n        full_update |= update_palette16(s);\n\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n\n            v = VGA_DRAW_LINE4D2;\n\n        } else {\n\n            v = VGA_DRAW_LINE4;\n\n        }\n\n        bits = 4;\n\n    } else if (shift_control == 1) {\n\n        full_update |= update_palette16(s);\n\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n\n            v = VGA_DRAW_LINE2D2;\n\n        } else {\n\n            v = VGA_DRAW_LINE2;\n\n        }\n\n        bits = 4;\n\n    } else {\n\n        switch(s->get_bpp(s)) {\n\n        default:\n\n        case 0:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8D2;\n\n            bits = 4;\n\n            break;\n\n        case 8:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8;\n\n            bits = 8;\n\n            break;\n\n        case 15:\n\n            v = s->big_endian_fb ? VGA_DRAW_LINE15_BE : VGA_DRAW_LINE15_LE;\n\n            bits = 16;\n\n            break;\n\n        case 16:\n\n            v = s->big_endian_fb ? VGA_DRAW_LINE16_BE : VGA_DRAW_LINE16_LE;\n\n            bits = 16;\n\n            break;\n\n        case 24:\n\n            v = s->big_endian_fb ? VGA_DRAW_LINE24_BE : VGA_DRAW_LINE24_LE;\n\n            bits = 24;\n\n            break;\n\n        case 32:\n\n            v = s->big_endian_fb ? VGA_DRAW_LINE32_BE : VGA_DRAW_LINE32_LE;\n\n            bits = 32;\n\n            break;\n\n        }\n\n    }\n\n    vga_draw_line = vga_draw_line_table[v];\n\n\n\n    if (!is_buffer_shared(surface) && s->cursor_invalidate) {\n\n        s->cursor_invalidate(s);\n\n    }\n\n\n\n    line_offset = s->line_offset;\n\n#if 0\n\n    printf(\"w=%d h=%d v=%d line_offset=%d cr[0x09]=0x%02x cr[0x17]=0x%02x linecmp=%d sr[0x01]=0x%02x\\n\",\n\n           width, height, v, line_offset, s->cr[9], s->cr[VGA_CRTC_MODE],\n\n           s->line_compare, sr(s, VGA_SEQ_CLOCK_MODE));\n\n#endif\n\n    addr1 = (s->start_addr * 4);\n\n    bwidth = DIV_ROUND_UP(width * bits, 8);\n\n    y_start = -1;\n\n    d = surface_data(surface);\n\n    linesize = surface_stride(surface);\n\n    y1 = 0;\n\n\n\n    if (!full_update) {\n\n        ram_addr_t region_start = addr1;\n\n        ram_addr_t region_end = addr1 + line_offset * height;\n\n        vga_sync_dirty_bitmap(s);\n\n        if (s->line_compare < height) {\n\n            /* split screen mode */\n\n            region_start = 0;\n\n        }\n\n        snap = memory_region_snapshot_and_clear_dirty(&s->vram, region_start,\n\n                                                      region_end - region_start,\n\n                                                      DIRTY_MEMORY_VGA);\n\n    }\n\n\n\n    for(y = 0; y < height; y++) {\n\n        addr = addr1;\n\n        if (!(s->cr[VGA_CRTC_MODE] & 1)) {\n\n            int shift;\n\n            /* CGA compatibility handling */\n\n            shift = 14 + ((s->cr[VGA_CRTC_MODE] >> 6) & 1);\n\n            addr = (addr & ~(1 << shift)) | ((y1 & 1) << shift);\n\n        }\n\n        if (!(s->cr[VGA_CRTC_MODE] & 2)) {\n\n            addr = (addr & ~0x8000) | ((y1 & 2) << 14);\n\n        }\n\n        update = full_update;\n\n        page0 = addr;\n\n        page1 = addr + bwidth - 1;\n\n        if (full_update) {\n\n            update = 1;\n\n        } else {\n\n            update = memory_region_snapshot_get_dirty(&s->vram, snap,\n\n                                                      page0, page1 - page0);\n\n        }\n\n        /* explicit invalidation for the hardware cursor (cirrus only) */\n\n        update |= vga_scanline_invalidated(s, y);\n\n        if (update) {\n\n            if (y_start < 0)\n\n                y_start = y;\n\n            if (!(is_buffer_shared(surface))) {\n\n                vga_draw_line(s, d, s->vram_ptr + addr, width);\n\n                if (s->cursor_draw_line)\n\n                    s->cursor_draw_line(s, d, y);\n\n            }\n\n        } else {\n\n            if (y_start >= 0) {\n\n                /* flush to display */\n\n                dpy_gfx_update(s->con, 0, y_start,\n\n                               disp_width, y - y_start);\n\n                y_start = -1;\n\n            }\n\n        }\n\n        if (!multi_run) {\n\n            mask = (s->cr[VGA_CRTC_MODE] & 3) ^ 3;\n\n            if ((y1 & mask) == mask)\n\n                addr1 += line_offset;\n\n            y1++;\n\n            multi_run = multi_scan;\n\n        } else {\n\n            multi_run--;\n\n        }\n\n        /* line compare acts on the displayed lines */\n\n        if (y == s->line_compare)\n\n            addr1 = 0;\n\n        d += linesize;\n\n    }\n\n    if (y_start >= 0) {\n\n        /* flush to display */\n\n        dpy_gfx_update(s->con, 0, y_start,\n\n                       disp_width, y - y_start);\n\n    }\n\n    g_free(snap);\n\n    memset(s->invalidated_y_table, 0, sizeof(s->invalidated_y_table));\n\n}\n", "idx": 24415, "_split": "valid", "_hash": "aaf9dfc0598e093b45131ab824544427"}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static int nbd_co_readv(BlockDriverState *bs, int64_t sector_num,\n\n                        int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n\n\n    return nbd_client_session_co_readv(&s->client, sector_num,\n\n                                       nb_sectors, qiov);\n\n}\n", "idx": 24448, "_split": "valid", "_hash": "fc8a02f3e009c80d3e9053d74eee3a79"}
{"project": "qemu", "commit_id": "de08c606f9ddafe647b6843e2b10a6d6030b0fc0", "target": 0, "func": "int bdrv_snapshot_list(BlockDriverState *bs,\n\n                       QEMUSnapshotInfo **psn_info)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n    if (drv->bdrv_snapshot_list)\n\n        return drv->bdrv_snapshot_list(bs, psn_info);\n\n    if (bs->file)\n\n        return bdrv_snapshot_list(bs->file, psn_info);\n\n    return -ENOTSUP;\n\n}\n", "idx": 24502, "_split": "valid", "_hash": "b8683bf4190d487f12f0ea6a9c5083ed"}
{"project": "qemu", "commit_id": "97f90cbfe810bb153fc44bde732d9639610783bb", "target": 0, "func": "static void dec_store(DisasContext *dc)\n\n{\n\n    TCGv t, *addr;\n\n    unsigned int size;\n\n\n\n    size = 1 << (dc->opcode & 3);\n\n\n\n    if (size > 4 && (dc->tb_flags & MSR_EE_FLAG)\n\n          && !(dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)) {\n\n        tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);\n\n        t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n        return;\n\n    }\n\n\n\n    LOG_DIS(\"s%d%s\\n\", size, dc->type_b ? \"i\" : \"\");\n\n    t_sync_flags(dc);\n\n    /* If we get a fault on a dslot, the jmpstate better be in sync.  */\n\n    sync_jmpstate(dc);\n\n    addr = compute_ldst_addr(dc, &t);\n\n\n\n    /* Verify alignment if needed.  */\n\n    if ((dc->env->pvr.regs[2] & PVR2_UNALIGNED_EXC_MASK) && size > 1) {\n\n        gen_helper_memalign(*addr, tcg_const_tl(dc->rd),\n\n                            tcg_const_tl(1), tcg_const_tl(size - 1));\n\n    }\n\n\n\n    gen_store(dc, *addr, cpu_R[dc->rd], size);\n\n    if (addr == &t)\n\n        tcg_temp_free(t);\n\n}\n", "idx": 24511, "_split": "valid", "_hash": "4104dec8c3d26c2a970d9630ff5fc8ae"}
{"project": "qemu", "commit_id": "8360544a6d3a54df1fce80f55ba4ad075a8ded54", "target": 0, "func": "static void qpci_spapr_io_writew(QPCIBus *bus, void *addr, uint16_t value)\n\n{\n\n    QPCIBusSPAPR *s = container_of(bus, QPCIBusSPAPR, bus);\n\n    uint64_t port = (uintptr_t)addr;\n\n    value = bswap16(value);\n\n    if (port < s->pio.size) {\n\n        writew(s->pio_cpu_base + port, value);\n\n    } else {\n\n        writew(s->mmio_cpu_base + port, value);\n\n    }\n\n}\n", "idx": 24514, "_split": "valid", "_hash": "22d74cb8e071348252f8182cf370e425"}
{"project": "qemu", "commit_id": "fafc0b6afed9d913ddbcd2da87e5d39da9bf04c5", "target": 1, "func": "int kvm_arch_get_registers(CPUState *env)\n\n{\n\n    struct kvm_regs regs;\n\n    struct kvm_sregs sregs;\n\n    uint32_t cr;\n\n    int i, ret;\n\n\n\n    ret = kvm_vcpu_ioctl(env, KVM_GET_REGS, &regs);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    cr = regs.cr;\n\n    for (i = 7; i >= 0; i--) {\n\n        env->crf[i] = cr & 15;\n\n        cr >>= 4;\n\n    }\n\n\n\n    env->ctr = regs.ctr;\n\n    env->lr = regs.lr;\n\n    env->xer = regs.xer;\n\n    env->msr = regs.msr;\n\n    env->nip = regs.pc;\n\n\n\n    env->spr[SPR_SRR0] = regs.srr0;\n\n    env->spr[SPR_SRR1] = regs.srr1;\n\n\n\n    env->spr[SPR_SPRG0] = regs.sprg0;\n\n    env->spr[SPR_SPRG1] = regs.sprg1;\n\n    env->spr[SPR_SPRG2] = regs.sprg2;\n\n    env->spr[SPR_SPRG3] = regs.sprg3;\n\n    env->spr[SPR_SPRG4] = regs.sprg4;\n\n    env->spr[SPR_SPRG5] = regs.sprg5;\n\n    env->spr[SPR_SPRG6] = regs.sprg6;\n\n    env->spr[SPR_SPRG7] = regs.sprg7;\n\n\n\n    env->spr[SPR_BOOKE_PID] = regs.pid;\n\n\n\n    for (i = 0;i < 32; i++)\n\n        env->gpr[i] = regs.gpr[i];\n\n\n\n#ifdef KVM_CAP_PPC_BOOKE_SREGS\n\n    if (cap_booke_sregs) {\n\n        ret = kvm_vcpu_ioctl(env, KVM_GET_SREGS, &sregs);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_BASE) {\n\n            env->spr[SPR_BOOKE_CSRR0] = sregs.u.e.csrr0;\n\n            env->spr[SPR_BOOKE_CSRR1] = sregs.u.e.csrr1;\n\n            env->spr[SPR_BOOKE_ESR] = sregs.u.e.esr;\n\n            env->spr[SPR_BOOKE_DEAR] = sregs.u.e.dear;\n\n            env->spr[SPR_BOOKE_MCSR] = sregs.u.e.mcsr;\n\n            env->spr[SPR_BOOKE_TSR] = sregs.u.e.tsr;\n\n            env->spr[SPR_BOOKE_TCR] = sregs.u.e.tcr;\n\n            env->spr[SPR_DECR] = sregs.u.e.dec;\n\n            env->spr[SPR_TBL] = sregs.u.e.tb & 0xffffffff;\n\n            env->spr[SPR_TBU] = sregs.u.e.tb >> 32;\n\n            env->spr[SPR_VRSAVE] = sregs.u.e.vrsave;\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_ARCH206) {\n\n            env->spr[SPR_BOOKE_PIR] = sregs.u.e.pir;\n\n            env->spr[SPR_BOOKE_MCSRR0] = sregs.u.e.mcsrr0;\n\n            env->spr[SPR_BOOKE_MCSRR1] = sregs.u.e.mcsrr1;\n\n            env->spr[SPR_BOOKE_DECAR] = sregs.u.e.decar;\n\n            env->spr[SPR_BOOKE_IVPR] = sregs.u.e.ivpr;\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_64) {\n\n            env->spr[SPR_BOOKE_EPCR] = sregs.u.e.epcr;\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_SPRG8) {\n\n            env->spr[SPR_BOOKE_SPRG8] = sregs.u.e.sprg8;\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_IVOR) {\n\n            env->spr[SPR_BOOKE_IVOR0] = sregs.u.e.ivor_low[0];\n\n            env->spr[SPR_BOOKE_IVOR1] = sregs.u.e.ivor_low[1];\n\n            env->spr[SPR_BOOKE_IVOR2] = sregs.u.e.ivor_low[2];\n\n            env->spr[SPR_BOOKE_IVOR3] = sregs.u.e.ivor_low[3];\n\n            env->spr[SPR_BOOKE_IVOR4] = sregs.u.e.ivor_low[4];\n\n            env->spr[SPR_BOOKE_IVOR5] = sregs.u.e.ivor_low[5];\n\n            env->spr[SPR_BOOKE_IVOR6] = sregs.u.e.ivor_low[6];\n\n            env->spr[SPR_BOOKE_IVOR7] = sregs.u.e.ivor_low[7];\n\n            env->spr[SPR_BOOKE_IVOR8] = sregs.u.e.ivor_low[8];\n\n            env->spr[SPR_BOOKE_IVOR9] = sregs.u.e.ivor_low[9];\n\n            env->spr[SPR_BOOKE_IVOR10] = sregs.u.e.ivor_low[10];\n\n            env->spr[SPR_BOOKE_IVOR11] = sregs.u.e.ivor_low[11];\n\n            env->spr[SPR_BOOKE_IVOR12] = sregs.u.e.ivor_low[12];\n\n            env->spr[SPR_BOOKE_IVOR13] = sregs.u.e.ivor_low[13];\n\n            env->spr[SPR_BOOKE_IVOR14] = sregs.u.e.ivor_low[14];\n\n            env->spr[SPR_BOOKE_IVOR15] = sregs.u.e.ivor_low[15];\n\n\n\n            if (sregs.u.e.features & KVM_SREGS_E_SPE) {\n\n                env->spr[SPR_BOOKE_IVOR32] = sregs.u.e.ivor_high[0];\n\n                env->spr[SPR_BOOKE_IVOR33] = sregs.u.e.ivor_high[1];\n\n                env->spr[SPR_BOOKE_IVOR34] = sregs.u.e.ivor_high[2];\n\n            }\n\n\n\n            if (sregs.u.e.features & KVM_SREGS_E_PM) {\n\n                env->spr[SPR_BOOKE_IVOR35] = sregs.u.e.ivor_high[3];\n\n            }\n\n\n\n            if (sregs.u.e.features & KVM_SREGS_E_PC) {\n\n                env->spr[SPR_BOOKE_IVOR36] = sregs.u.e.ivor_high[4];\n\n                env->spr[SPR_BOOKE_IVOR37] = sregs.u.e.ivor_high[5];\n\n            }\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_ARCH206_MMU) {\n\n            env->spr[SPR_BOOKE_MAS0] = sregs.u.e.mas0;\n\n            env->spr[SPR_BOOKE_MAS1] = sregs.u.e.mas1;\n\n            env->spr[SPR_BOOKE_MAS2] = sregs.u.e.mas2;\n\n            env->spr[SPR_BOOKE_MAS3] = sregs.u.e.mas7_3 & 0xffffffff;\n\n            env->spr[SPR_BOOKE_MAS4] = sregs.u.e.mas4;\n\n            env->spr[SPR_BOOKE_MAS6] = sregs.u.e.mas6;\n\n            env->spr[SPR_BOOKE_MAS7] = sregs.u.e.mas7_3 >> 32;\n\n            env->spr[SPR_MMUCFG] = sregs.u.e.mmucfg;\n\n            env->spr[SPR_BOOKE_TLB0CFG] = sregs.u.e.tlbcfg[0];\n\n            env->spr[SPR_BOOKE_TLB1CFG] = sregs.u.e.tlbcfg[1];\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_EXP) {\n\n            env->spr[SPR_BOOKE_EPR] = sregs.u.e.epr;\n\n        }\n\n\n\n        if (sregs.u.e.features & KVM_SREGS_E_PD) {\n\n            env->spr[SPR_BOOKE_EPLC] = sregs.u.e.eplc;\n\n            env->spr[SPR_BOOKE_EPSC] = sregs.u.e.epsc;\n\n        }\n\n\n\n        if (sregs.u.e.impl_id == KVM_SREGS_E_IMPL_FSL) {\n\n            env->spr[SPR_E500_SVR] = sregs.u.e.impl.fsl.svr;\n\n            env->spr[SPR_Exxx_MCAR] = sregs.u.e.impl.fsl.mcar;\n\n            env->spr[SPR_HID0] = sregs.u.e.impl.fsl.hid0;\n\n\n\n            if (sregs.u.e.impl.fsl.features & KVM_SREGS_E_FSL_PIDn) {\n\n                env->spr[SPR_BOOKE_PID1] = sregs.u.e.impl.fsl.pid1;\n\n                env->spr[SPR_BOOKE_PID2] = sregs.u.e.impl.fsl.pid2;\n\n            }\n\n        }\n\n    }\n\n#endif\n\n\n\n#ifdef KVM_CAP_PPC_SEGSTATE\n\n    if (cap_segstate) {\n\n        ret = kvm_vcpu_ioctl(env, KVM_GET_SREGS, &sregs);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        ppc_store_sdr1(env, sregs.u.s.sdr1);\n\n\n\n        /* Sync SLB */\n\n#ifdef TARGET_PPC64\n\n        for (i = 0; i < 64; i++) {\n\n            ppc_store_slb(env, sregs.u.s.ppc64.slb[i].slbe,\n\n                               sregs.u.s.ppc64.slb[i].slbv);\n\n        }\n\n#endif\n\n\n\n        /* Sync SRs */\n\n        for (i = 0; i < 16; i++) {\n\n            env->sr[i] = sregs.u.s.ppc32.sr[i];\n\n        }\n\n\n\n        /* Sync BATs */\n\n        for (i = 0; i < 8; i++) {\n\n            env->DBAT[0][i] = sregs.u.s.ppc32.dbat[i] & 0xffffffff;\n\n            env->DBAT[1][i] = sregs.u.s.ppc32.dbat[i] >> 32;\n\n            env->IBAT[0][i] = sregs.u.s.ppc32.ibat[i] & 0xffffffff;\n\n            env->IBAT[1][i] = sregs.u.s.ppc32.ibat[i] >> 32;\n\n        }\n\n    }\n\n#endif\n\n\n\n    return 0;\n\n}\n", "idx": 24533, "_split": "valid", "_hash": "18ae164dbd633cbcca9b6747fb6fa5cd"}
{"project": "qemu", "commit_id": "3baf720e6b920d583ce2834d05e5a4e9603a1d56", "target": 1, "func": "static int cdrom_probe_device(const char *filename)\n\n{\n\n    if (strstart(filename, \"/dev/cd\", NULL))\n\n        return 100;\n\n    return 0;\n\n}\n", "idx": 24543, "_split": "valid", "_hash": "9b3da9e78d8412f9941a283bfd379430"}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "static int qio_channel_socket_listen_worker(QIOTask *task,\n\n                                            Error **errp,\n\n                                            gpointer opaque)\n\n{\n\n    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(qio_task_get_source(task));\n\n    SocketAddress *addr = opaque;\n\n    int ret;\n\n\n\n    ret = qio_channel_socket_listen_sync(ioc,\n\n                                         addr,\n\n                                         errp);\n\n\n\n    object_unref(OBJECT(ioc));\n\n    return ret;\n\n}\n", "idx": 24544, "_split": "valid", "_hash": "7fa3032b10bb43eee5f3fb9ba8d80f15"}
{"project": "qemu", "commit_id": "f2ad97ff81da51c064b9e87720ff48a0874f45d4", "target": 1, "func": "static USBPort *xhci_lookup_uport(XHCIState *xhci, uint32_t *slot_ctx)\n\n{\n\n    USBPort *uport;\n\n    char path[32];\n\n    int i, pos, port;\n\n\n\n    port = (slot_ctx[1]>>16) & 0xFF;\n\n\n\n\n    port = xhci->ports[port-1].uport->index+1;\n\n    pos = snprintf(path, sizeof(path), \"%d\", port);\n\n    for (i = 0; i < 5; i++) {\n\n        port = (slot_ctx[0] >> 4*i) & 0x0f;\n\n        if (!port) {\n\n            break;\n\n\n        pos += snprintf(path + pos, sizeof(path) - pos, \".%d\", port);\n\n\n\n\n    QTAILQ_FOREACH(uport, &xhci->bus.used, next) {\n\n        if (strcmp(uport->path, path) == 0) {\n\n            return uport;\n\n\n\n", "idx": 24547, "_split": "valid", "_hash": "d100776a72e2641430acc478ceeec6fd"}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void io_watch_poll_finalize(GSource *source)\n\n{\n\n    IOWatchPoll *iwp = io_watch_poll_from_source(source);\n\n    if (iwp->src) {\n\n        g_source_destroy(iwp->src);\n\n        g_source_unref(iwp->src);\n\n        iwp->src = NULL;\n\n    }\n\n}\n", "idx": 24548, "_split": "valid", "_hash": "8ffd7b9f73de265755b708850811f158"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void bmdma_addr_write(void *opaque, target_phys_addr_t addr,\n\n                             uint64_t data, unsigned width)\n\n{\n\n    BMDMAState *bm = opaque;\n\n    int shift = addr * 8;\n\n    uint32_t mask = (1ULL << (width * 8)) - 1;\n\n\n\n#ifdef DEBUG_IDE\n\n    printf(\"%s: 0x%08x\\n\", __func__, (unsigned)data);\n\n#endif\n\n    bm->addr &= ~(mask << shift);\n\n    bm->addr |= ((data & mask) << shift) & ~3;\n\n}\n", "idx": 24597, "_split": "valid", "_hash": "e255616d7a076b64f18469bc9a97d40a"}
{"project": "qemu", "commit_id": "6f1de6b70d857d5e316ae6fd908f52818b827b08", "target": 0, "func": "int qemu_chr_fe_add_watch(CharDriverState *s, GIOCondition cond,\n\n                          GIOFunc func, void *user_data)\n\n{\n\n    GSource *src;\n\n    guint tag;\n\n\n\n    if (s->chr_add_watch == NULL) {\n\n        return -ENOSYS;\n\n    }\n\n\n\n    src = s->chr_add_watch(s, cond);\n\n    if (!src) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    g_source_set_callback(src, (GSourceFunc)func, user_data, NULL);\n\n    tag = g_source_attach(src, NULL);\n\n    g_source_unref(src);\n\n\n\n    return tag;\n\n}\n", "idx": 24600, "_split": "valid", "_hash": "12623f8f47077af5882c080dd908dcc4"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "uint64_t ldq_phys(target_phys_addr_t addr)\n\n{\n\n    return ldq_phys_internal(addr, DEVICE_NATIVE_ENDIAN);\n\n}\n", "idx": 24602, "_split": "valid", "_hash": "78068958f5e3e458db05e409757bc4ef"}
{"project": "qemu", "commit_id": "56ad3e54dad6cdcee8668d170df161d89581846f", "target": 1, "func": "static ssize_t mp_dacl_getxattr(FsContext *ctx, const char *path,\n\n                                const char *name, void *value, size_t size)\n\n{\n\n    char *buffer;\n\n    ssize_t ret;\n\n\n\n    buffer = rpath(ctx, path);\n\n    ret = lgetxattr(buffer, MAP_ACL_DEFAULT, value, size);\n\n    g_free(buffer);\n\n    return ret;\n\n}\n", "idx": 24611, "_split": "valid", "_hash": "8ed729c9f2685eb8fd4e3de99ffd9e38"}
{"project": "qemu", "commit_id": "5712db6ae5101db645f71edc393368cd59bfd314", "target": 1, "func": "static void fw_cfg_realize(DeviceState *dev, Error **errp)\n\n{\n\n    FWCfgState *s = FW_CFG(dev);\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n\n\n    if (s->ctl_iobase + 1 == s->data_iobase) {\n\n        sysbus_add_io(sbd, s->ctl_iobase, &s->comb_iomem);\n\n    } else {\n\n        if (s->ctl_iobase) {\n\n            sysbus_add_io(sbd, s->ctl_iobase, &s->ctl_iomem);\n\n        }\n\n        if (s->data_iobase) {\n\n            sysbus_add_io(sbd, s->data_iobase, &s->data_iomem);\n\n        }\n\n    }\n\n}\n", "idx": 24615, "_split": "valid", "_hash": "2421fe4ed955725600483cd753a007f8"}
{"project": "qemu", "commit_id": "a4d8e8daee324e230b0155915f562743f4fff5d8", "target": 1, "func": "static void vscsi_got_payload(VSCSIState *s, vscsi_crq *crq)\n\n{\n\n    vscsi_req *req;\n\n    int done;\n\n\n\n    req = vscsi_get_req(s);\n\n    if (req == NULL) {\n\n        fprintf(stderr, \"VSCSI: Failed to get a request !\\n\");\n\n        return;\n\n    }\n\n\n\n    /* We only support a limited number of descriptors, we know\n\n     * the ibmvscsi driver uses up to 10 max, so it should fit\n\n     * in our 256 bytes IUs. If not we'll have to increase the size\n\n     * of the structure.\n\n     */\n\n    if (crq->s.IU_length > sizeof(union viosrp_iu)) {\n\n        fprintf(stderr, \"VSCSI: SRP IU too long (%d bytes) !\\n\",\n\n                crq->s.IU_length);\n\n        return;\n\n    }\n\n\n\n    /* XXX Handle failure differently ? */\n\n    if (spapr_tce_dma_read(&s->vdev, crq->s.IU_data_ptr, &req->iu,\n\n                           crq->s.IU_length)) {\n\n        fprintf(stderr, \"vscsi_got_payload: DMA read failure !\\n\");\n\n        g_free(req);\n\n    }\n\n    memcpy(&req->crq, crq, sizeof(vscsi_crq));\n\n\n\n    if (crq->s.format == VIOSRP_MAD_FORMAT) {\n\n        done = vscsi_handle_mad_req(s, req);\n\n    } else {\n\n        done = vscsi_handle_srp_req(s, req);\n\n    }\n\n\n\n    if (done) {\n\n        vscsi_put_req(req);\n\n    }\n\n}\n", "idx": 24620, "_split": "valid", "_hash": "5072fd956f52bcccaa49f8c1f7a4b198"}
{"project": "qemu", "commit_id": "8a5865f331028e66b4ed233129d7a914c2d5bfc7", "target": 1, "func": "static MTPData *usb_mtp_get_object_info(MTPState *s, MTPControl *c,\n\n                                        MTPObject *o)\n\n{\n\n    MTPData *d = usb_mtp_data_alloc(c);\n\n\n\n    trace_usb_mtp_op_get_object_info(s->dev.addr, o->handle, o->path);\n\n\n\n    usb_mtp_add_u32(d, QEMU_STORAGE_ID);\n\n    usb_mtp_add_u16(d, o->format);\n\n    usb_mtp_add_u16(d, 0);\n\n    usb_mtp_add_u32(d, o->stat.st_size);\n\n\n\n    usb_mtp_add_u16(d, 0);\n\n    usb_mtp_add_u32(d, 0);\n\n    usb_mtp_add_u32(d, 0);\n\n    usb_mtp_add_u32(d, 0);\n\n    usb_mtp_add_u32(d, 0);\n\n    usb_mtp_add_u32(d, 0);\n\n    usb_mtp_add_u32(d, 0);\n\n\n\n    if (o->parent) {\n\n        usb_mtp_add_u32(d, o->parent->handle);\n\n    } else {\n\n        usb_mtp_add_u32(d, 0);\n\n    }\n\n    if (o->format == FMT_ASSOCIATION) {\n\n        usb_mtp_add_u16(d, 0x0001);\n\n        usb_mtp_add_u32(d, 0x00000001);\n\n        usb_mtp_add_u32(d, 0);\n\n    } else {\n\n        usb_mtp_add_u16(d, 0);\n\n        usb_mtp_add_u32(d, 0);\n\n        usb_mtp_add_u32(d, 0);\n\n    }\n\n\n\n    usb_mtp_add_str(d, o->name);\n\n    usb_mtp_add_time(d, o->stat.st_ctime);\n\n    usb_mtp_add_time(d, o->stat.st_mtime);\n\n    usb_mtp_add_wstr(d, L\"\");\n\n\n\n    return d;\n\n}\n", "idx": 24632, "_split": "valid", "_hash": "aafd76a547d707dda1afd7e9b5b83b7d"}
{"project": "qemu", "commit_id": "1b57bd4f2f4993104a5cb48912435396faa10d58", "target": 1, "func": "static inline bool rom_order_compare(Rom *rom, Rom *item)\n\n{\n\n    return (rom->as > item->as) ||\n\n           (rom->as == item->as && rom->addr >= item->addr);\n\n}\n", "idx": 24635, "_split": "valid", "_hash": "5aad1856baa423a084978d169fb89aaa"}
{"project": "qemu", "commit_id": "12de9a396acbc95e25c5d60ed097cc55777eaaed", "target": 1, "func": "static int slb_lookup (CPUState *env, target_ulong eaddr,\n\n                       target_ulong *vsid, target_ulong *page_mask, int *attr)\n\n{\n\n    target_phys_addr_t sr_base;\n\n    target_ulong mask;\n\n    uint64_t tmp64;\n\n    uint32_t tmp;\n\n    int n, ret;\n\n    int slb_nr;\n\n\n\n    ret = -5;\n\n    sr_base = env->spr[SPR_ASR];\n\n    mask = 0x0000000000000000ULL; /* Avoid gcc warning */\n\n#if 0 /* XXX: Fix this */\n\n    slb_nr = env->slb_nr;\n\n#else\n\n    slb_nr = 32;\n\n#endif\n\n    for (n = 0; n < slb_nr; n++) {\n\n        tmp64 = ldq_phys(sr_base);\n\n        if (tmp64 & 0x0000000008000000ULL) {\n\n            /* SLB entry is valid */\n\n            switch (tmp64 & 0x0000000006000000ULL) {\n\n            case 0x0000000000000000ULL:\n\n                /* 256 MB segment */\n\n                mask = 0xFFFFFFFFF0000000ULL;\n\n                break;\n\n            case 0x0000000002000000ULL:\n\n                /* 1 TB segment */\n\n                mask = 0xFFFF000000000000ULL;\n\n                break;\n\n            case 0x0000000004000000ULL:\n\n            case 0x0000000006000000ULL:\n\n                /* Reserved => segment is invalid */\n\n                continue;\n\n            }\n\n            if ((eaddr & mask) == (tmp64 & mask)) {\n\n                /* SLB match */\n\n                tmp = ldl_phys(sr_base + 8);\n\n                *vsid = ((tmp64 << 24) | (tmp >> 8)) & 0x0003FFFFFFFFFFFFULL;\n\n                *page_mask = ~mask;\n\n                *attr = tmp & 0xFF;\n\n                ret = 0;\n\n                break;\n\n            }\n\n        }\n\n        sr_base += 12;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24644, "_split": "valid", "_hash": "47a6027a643ce7fd659e57507130f507"}
{"project": "qemu", "commit_id": "6c8d56a2e95712a6206a2671d2b04b2e59cabc0b", "target": 1, "func": "static uint8_t fw_cfg_read(FWCfgState *s)\n\n{\n\n    int arch = !!(s->cur_entry & FW_CFG_ARCH_LOCAL);\n\n    FWCfgEntry *e = (s->cur_entry == FW_CFG_INVALID) ? NULL :\n\n                    &s->entries[arch][s->cur_entry & FW_CFG_ENTRY_MASK];\n\n    uint8_t ret;\n\n\n\n    if (s->cur_entry == FW_CFG_INVALID || !e->data || s->cur_offset >= e->len)\n\n        ret = 0;\n\n    else {\n\n        ret = e->data[s->cur_offset++];\n\n    }\n\n\n\n    trace_fw_cfg_read(s, ret);\n\n    return ret;\n\n}\n", "idx": 24649, "_split": "valid", "_hash": "a27ae2053661b86ae219723d87c87484"}
{"project": "qemu", "commit_id": "698bdfa07d66b5ec218a60229e58eae1dcde00e5", "target": 1, "func": "void qmp_block_resize(bool has_device, const char *device,\n\n                      bool has_node_name, const char *node_name,\n\n                      int64_t size, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    BlockBackend *blk = NULL;\n\n    BlockDriverState *bs;\n\n    AioContext *aio_context;\n\n    int ret;\n\n\n\n    bs = bdrv_lookup_bs(has_device ? device : NULL,\n\n                        has_node_name ? node_name : NULL,\n\n                        &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    if (!bdrv_is_first_non_filter(bs)) {\n\n        error_setg(errp, QERR_FEATURE_DISABLED, \"resize\");\n\n        goto out;\n\n    }\n\n\n\n    if (size < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"size\", \"a >0 size\");\n\n        goto out;\n\n    }\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_RESIZE, NULL)) {\n\n        error_setg(errp, QERR_DEVICE_IN_USE, device);\n\n        goto out;\n\n    }\n\n\n\n    blk = blk_new(BLK_PERM_RESIZE, BLK_PERM_ALL);\n\n    ret = blk_insert_bs(blk, bs, errp);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    /* complete all in-flight operations before resizing the device */\n\n    bdrv_drain_all();\n\n\n\n    ret = blk_truncate(blk, size, errp);\n\n\n\nout:\n\n    blk_unref(blk);\n\n    aio_context_release(aio_context);\n\n}\n", "idx": 24650, "_split": "valid", "_hash": "5a04ed851be2309eeb9b97ed651a087a"}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static int cow_update_bitmap(BlockDriverState *bs, int64_t sector_num,\n\n        int nb_sectors)\n\n{\n\n    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;\n\n    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;\n\n    bool first = true;\n\n    int sector_bits;\n\n\n\n    for ( ; nb_sectors;\n\n            bitnum += sector_bits,\n\n            nb_sectors -= sector_bits,\n\n            offset += BDRV_SECTOR_SIZE) {\n\n        int ret, set;\n\n        uint8_t bitmap[BDRV_SECTOR_SIZE];\n\n\n\n        bitnum &= BITS_PER_BITMAP_SECTOR - 1;\n\n        sector_bits = MIN(nb_sectors, BITS_PER_BITMAP_SECTOR - bitnum);\n\n\n\n        ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        /* Skip over any already set bits */\n\n        set = cow_find_streak(bitmap, 1, bitnum, sector_bits);\n\n        bitnum += set;\n\n        sector_bits -= set;\n\n        nb_sectors -= set;\n\n        if (!sector_bits) {\n\n            continue;\n\n        }\n\n\n\n        if (first) {\n\n            ret = bdrv_flush(bs->file);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n            first = false;\n\n        }\n\n\n\n        cow_set_bits(bitmap, bitnum, sector_bits);\n\n\n\n        ret = bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap));\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24682, "_split": "valid", "_hash": "0ecd603e47787d54ee34a9a4476e96d5"}
{"project": "qemu", "commit_id": "b29a0341d7ed7e7df4bf77a41db8e614f1ddb645", "target": 0, "func": "void op_mtc0_ebase (void)\n\n{\n\n    /* vectored interrupts not implemented */\n\n    /* Multi-CPU not implemented */\n\n    env->CP0_EBase = (int32_t)0x80000000 | (T0 & 0x3FFFF000);\n\n    RETURN();\n\n}\n", "idx": 24695, "_split": "valid", "_hash": "f552db373001984f4fd7a5a660b97efc"}
{"project": "qemu", "commit_id": "f186d64d8fda4bb22c15beb8e45b7814fbd8b51e", "target": 0, "func": "bool replay_checkpoint(ReplayCheckpoint checkpoint)\n\n{\n\n    bool res = false;\n\n    assert(EVENT_CHECKPOINT + checkpoint <= EVENT_CHECKPOINT_LAST);\n\n    replay_save_instructions();\n\n\n\n    if (!replay_file) {\n\n        return true;\n\n    }\n\n\n\n    replay_mutex_lock();\n\n\n\n    if (replay_mode == REPLAY_MODE_PLAY) {\n\n        if (replay_next_event_is(EVENT_CHECKPOINT + checkpoint)) {\n\n            replay_finish_event();\n\n        } else if (replay_data_kind != EVENT_ASYNC) {\n\n            res = false;\n\n            goto out;\n\n        }\n\n        replay_read_events(checkpoint);\n\n        /* replay_read_events may leave some unread events.\n\n           Return false if not all of the events associated with\n\n           checkpoint were processed */\n\n        res = replay_data_kind != EVENT_ASYNC;\n\n    } else if (replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_put_event(EVENT_CHECKPOINT + checkpoint);\n\n        replay_save_events(checkpoint);\n\n        res = true;\n\n    }\n\nout:\n\n    replay_mutex_unlock();\n\n    return res;\n\n}\n", "idx": 24711, "_split": "valid", "_hash": "1057dee2b5a89b8d97aba9e92919e68e"}
{"project": "qemu", "commit_id": "13f1c773640171efa8175b1ba6dcd624c1ad68c1", "target": 0, "func": "static void openrisc_sim_machine_init(MachineClass *mc)\n\n{\n\n    mc->desc = \"or1k simulation\";\n\n    mc->init = openrisc_sim_init;\n\n    mc->max_cpus = 1;\n\n    mc->is_default = 1;\n\n}\n", "idx": 24716, "_split": "valid", "_hash": "de7d931138428815402bd741f2c6ed32"}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static int coroutine_fn qed_aio_write_inplace(QEDAIOCB *acb, uint64_t offset,\n\n                                              size_t len)\n\n{\n\n    /* Allocate buffer for zero writes */\n\n    if (acb->flags & QED_AIOCB_ZERO) {\n\n        struct iovec *iov = acb->qiov->iov;\n\n\n\n        if (!iov->iov_base) {\n\n            iov->iov_base = qemu_try_blockalign(acb->bs, iov->iov_len);\n\n            if (iov->iov_base == NULL) {\n\n                return -ENOMEM;\n\n            }\n\n            memset(iov->iov_base, 0, iov->iov_len);\n\n        }\n\n    }\n\n\n\n    /* Calculate the I/O vector */\n\n    acb->cur_cluster = offset;\n\n    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);\n\n\n\n    /* Do the actual write */\n\n    return qed_aio_write_main(acb);\n\n}\n", "idx": 24726, "_split": "valid", "_hash": "e2df766e9283726fac6565566319c044"}
{"project": "qemu", "commit_id": "439e2a6e10ed7f5da819bf7dcaa54b8cfdbeab0d", "target": 0, "func": "Aml *aml_add(Aml *arg1, Aml *arg2)\n\n{\n\n    Aml *var = aml_opcode(0x72 /* AddOp */);\n\n    aml_append(var, arg1);\n\n    aml_append(var, arg2);\n\n    build_append_byte(var->buf, 0x00 /* NullNameOp */);\n\n    return var;\n\n}\n", "idx": 24727, "_split": "valid", "_hash": "521d195750b0146b95eb39765eef100e"}
{"project": "qemu", "commit_id": "f0495f56c9f4574140c392bdbad42721ba692d19", "target": 0, "func": "static int menelaus_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    MenelausState *s = (MenelausState *) opaque;\n\n\n\n    s->firstbyte = qemu_get_be32(f);\n\n    qemu_get_8s(f, &s->reg);\n\n\n\n    if (s->rtc.ctrl & 1)\t\t\t\t\t/* RTC_EN */\n\n        menelaus_rtc_stop(s);\n\n    qemu_get_8s(f, &s->vcore[0]);\n\n    qemu_get_8s(f, &s->vcore[1]);\n\n    qemu_get_8s(f, &s->vcore[2]);\n\n    qemu_get_8s(f, &s->vcore[3]);\n\n    qemu_get_8s(f, &s->vcore[4]);\n\n    qemu_get_8s(f, &s->dcdc[0]);\n\n    qemu_get_8s(f, &s->dcdc[1]);\n\n    qemu_get_8s(f, &s->dcdc[2]);\n\n    qemu_get_8s(f, &s->ldo[0]);\n\n    qemu_get_8s(f, &s->ldo[1]);\n\n    qemu_get_8s(f, &s->ldo[2]);\n\n    qemu_get_8s(f, &s->ldo[3]);\n\n    qemu_get_8s(f, &s->ldo[4]);\n\n    qemu_get_8s(f, &s->ldo[5]);\n\n    qemu_get_8s(f, &s->ldo[6]);\n\n    qemu_get_8s(f, &s->ldo[7]);\n\n    qemu_get_8s(f, &s->sleep[0]);\n\n    qemu_get_8s(f, &s->sleep[1]);\n\n    qemu_get_8s(f, &s->osc);\n\n    qemu_get_8s(f, &s->detect);\n\n    qemu_get_be16s(f, &s->mask);\n\n    qemu_get_be16s(f, &s->status);\n\n    qemu_get_8s(f, &s->dir);\n\n    qemu_get_8s(f, &s->inputs);\n\n    qemu_get_8s(f, &s->outputs);\n\n    qemu_get_8s(f, &s->bbsms);\n\n    qemu_get_8s(f, &s->pull[0]);\n\n    qemu_get_8s(f, &s->pull[1]);\n\n    qemu_get_8s(f, &s->pull[2]);\n\n    qemu_get_8s(f, &s->pull[3]);\n\n    qemu_get_8s(f, &s->mmc_ctrl[0]);\n\n    qemu_get_8s(f, &s->mmc_ctrl[1]);\n\n    qemu_get_8s(f, &s->mmc_ctrl[2]);\n\n    qemu_get_8s(f, &s->mmc_debounce);\n\n    qemu_get_8s(f, &s->rtc.ctrl);\n\n    qemu_get_be16s(f, &s->rtc.comp);\n\n    s->rtc.next = qemu_get_be16(f);\n\n    tm_get(f, &s->rtc.new);\n\n    tm_get(f, &s->rtc.alm);\n\n    s->pwrbtn_state = qemu_get_byte(f);\n\n    menelaus_alm_update(s);\n\n    menelaus_update(s);\n\n    if (s->rtc.ctrl & 1)\t\t\t\t\t/* RTC_EN */\n\n        menelaus_rtc_start(s);\n\n\n\n    i2c_slave_load(f, &s->i2c);\n\n    return 0;\n\n}\n", "idx": 24728, "_split": "valid", "_hash": "ad891462b46dc4ee049b3704816d4d29"}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void find_completion(const char *cmdline)\n\n{\n\n    const char *cmdname;\n\n    char *args[MAX_ARGS];\n\n    int nb_args, i, len;\n\n    const char *ptype, *str;\n\n    term_cmd_t *cmd;\n\n\n\n    parse_cmdline(cmdline, &nb_args, args);\n\n#ifdef DEBUG_COMPLETION\n\n    for(i = 0; i < nb_args; i++) {\n\n        term_printf(\"arg%d = '%s'\\n\", i, (char *)args[i]);\n\n    }\n\n#endif\n\n\n\n    /* if the line ends with a space, it means we want to complete the\n\n       next arg */\n\n    len = strlen(cmdline);\n\n    if (len > 0 && isspace(cmdline[len - 1])) {\n\n        if (nb_args >= MAX_ARGS)\n\n            return;\n\n        args[nb_args++] = qemu_strdup(\"\");\n\n    }\n\n    if (nb_args <= 1) {\n\n        /* command completion */\n\n        if (nb_args == 0)\n\n            cmdname = \"\";\n\n        else\n\n            cmdname = args[0];\n\n        completion_index = strlen(cmdname);\n\n        for(cmd = term_cmds; cmd->name != NULL; cmd++) {\n\n            cmd_completion(cmdname, cmd->name);\n\n        }\n\n    } else {\n\n        /* find the command */\n\n        for(cmd = term_cmds; cmd->name != NULL; cmd++) {\n\n            if (compare_cmd(args[0], cmd->name))\n\n                goto found;\n\n        }\n\n        return;\n\n    found:\n\n        ptype = cmd->args_type;\n\n        for(i = 0; i < nb_args - 2; i++) {\n\n            if (*ptype != '\\0') {\n\n                ptype++;\n\n                while (*ptype == '?')\n\n                    ptype++;\n\n            }\n\n        }\n\n        str = args[nb_args - 1];\n\n        switch(*ptype) {\n\n        case 'F':\n\n            /* file completion */\n\n            completion_index = strlen(str);\n\n            file_completion(str);\n\n            break;\n\n        case 'B':\n\n            /* block device name completion */\n\n            completion_index = strlen(str);\n\n            bdrv_iterate(block_completion_it, (void *)str);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    for(i = 0; i < nb_args; i++)\n\n        qemu_free(args[i]);\n\n}\n", "idx": 24743, "_split": "valid", "_hash": "b39921ffc70f9c2569704e2ad273f4b3"}
{"project": "qemu", "commit_id": "2c62f08ddbf3fa80dc7202eb9a2ea60ae44e2cc5", "target": 0, "func": "static int pci_cirrus_vga_initfn(PCIDevice *dev)\n\n{\n\n     PCICirrusVGAState *d = DO_UPCAST(PCICirrusVGAState, dev, dev);\n\n     CirrusVGAState *s = &d->cirrus_vga;\n\n     PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(dev);\n\n     int16_t device_id = pc->device_id;\n\n\n\n     /* setup VGA */\n\n     vga_common_init(&s->vga);\n\n     cirrus_init_common(s, device_id, 1, pci_address_space(dev),\n\n                        pci_address_space_io(dev));\n\n     s->vga.con = graphic_console_init(s->vga.update, s->vga.invalidate,\n\n                                       s->vga.screen_dump, s->vga.text_update,\n\n                                       &s->vga);\n\n\n\n     /* setup PCI */\n\n\n\n    memory_region_init(&s->pci_bar, \"cirrus-pci-bar0\", 0x2000000);\n\n\n\n    /* XXX: add byte swapping apertures */\n\n    memory_region_add_subregion(&s->pci_bar, 0, &s->cirrus_linear_io);\n\n    memory_region_add_subregion(&s->pci_bar, 0x1000000,\n\n                                &s->cirrus_linear_bitblt_io);\n\n\n\n     /* setup memory space */\n\n     /* memory #0 LFB */\n\n     /* memory #1 memory-mapped I/O */\n\n     /* XXX: s->vga.vram_size must be a power of two */\n\n     pci_register_bar(&d->dev, 0, PCI_BASE_ADDRESS_MEM_PREFETCH, &s->pci_bar);\n\n     if (device_id == CIRRUS_ID_CLGD5446) {\n\n         pci_register_bar(&d->dev, 1, 0, &s->cirrus_mmio_io);\n\n     }\n\n     return 0;\n\n}\n", "idx": 24758, "_split": "valid", "_hash": "e7064eee60c1d962131c2faadf8b8232"}
{"project": "qemu", "commit_id": "7c38ecd09763107513bacc791856fdbb582a107c", "target": 1, "func": "static int acpi_pcihp_get_bsel(PCIBus *bus)\n\n{\n\n    QObject *o = object_property_get_qobject(OBJECT(bus),\n\n                                             ACPI_PCIHP_PROP_BSEL, NULL);\n\n    int64_t bsel = -1;\n\n    if (o) {\n\n        bsel = qint_get_int(qobject_to_qint(o));\n\n    }\n\n    if (bsel < 0) {\n\n        return -1;\n\n    }\n\n    return bsel;\n\n}\n", "idx": 24763, "_split": "valid", "_hash": "d9cf9c92f69a720d9d56a4275e4083e1"}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "void vnc_client_write(void *opaque)\n\n{\n\n    long ret;\n\n    VncState *vs = opaque;\n\n\n\n#ifdef CONFIG_VNC_TLS\n\n    if (vs->tls.session) {\n\n\tret = gnutls_write(vs->tls.session, vs->output.buffer, vs->output.offset);\n\n\tif (ret < 0) {\n\n\t    if (ret == GNUTLS_E_AGAIN)\n\n\t\terrno = EAGAIN;\n\n\t    else\n\n\t\terrno = EIO;\n\n\t    ret = -1;\n\n\t}\n\n    } else\n\n#endif /* CONFIG_VNC_TLS */\n\n\tret = send(vs->csock, vs->output.buffer, vs->output.offset, 0);\n\n    ret = vnc_client_io_error(vs, ret, socket_error());\n\n    if (!ret)\n\n\treturn;\n\n\n\n    memmove(vs->output.buffer, vs->output.buffer + ret, (vs->output.offset - ret));\n\n    vs->output.offset -= ret;\n\n\n\n    if (vs->output.offset == 0) {\n\n\tqemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, NULL, vs);\n\n    }\n\n}\n", "idx": 24764, "_split": "valid", "_hash": "9d87ce3e106c8f4c9cde3c90b4f66f45"}
{"project": "qemu", "commit_id": "08942ac17922d923a7cc5cf9854e9cc4b150b942", "target": 1, "func": "int spapr_tce_dma_write(VIOsPAPRDevice *dev, uint64_t taddr, const void *buf,\n                        uint32_t size)\n{\n#ifdef DEBUG_TCE\n    fprintf(stderr, \"spapr_tce_dma_write taddr=0x%llx size=0x%x\\n\",\n            (unsigned long long)taddr, size);\n#endif\n    while (size) {\n        uint64_t tce;\n        uint32_t lsize;\n        uint64_t txaddr;\n        /* Check if we are in bound */\n        if (taddr >= dev->rtce_window_size) {\n#ifdef DEBUG_TCE\n            fprintf(stderr, \"spapr_tce_dma_write out of bounds\\n\");\n#endif\n            return H_DEST_PARM;\n        tce = dev->rtce_table[taddr >> SPAPR_VIO_TCE_PAGE_SHIFT].tce;\n        /* How much til end of page ? */\n        lsize = MIN(size, ((~taddr) & SPAPR_VIO_TCE_PAGE_MASK) + 1);\n        /* Check TCE */\n        if (!(tce & 2)) {\n            return H_DEST_PARM;\n        /* Translate */\n        txaddr = (tce & ~SPAPR_VIO_TCE_PAGE_MASK) |\n            (taddr & SPAPR_VIO_TCE_PAGE_MASK);\n#ifdef DEBUG_TCE\n        fprintf(stderr, \" -> write to txaddr=0x%llx, size=0x%x\\n\",\n                (unsigned long long)txaddr, lsize);\n#endif\n        /* Do it */\n        cpu_physical_memory_write(txaddr, buf, lsize);\n        buf += lsize;\n        taddr += lsize;\n        size -= lsize;", "idx": 24813, "_split": "valid", "_hash": "a8b72ee0c7a09596afe75236fd8ba9e8"}
{"project": "qemu", "commit_id": "5bf81c8d63db0216a4d29dc87f9ce530bb791dd1", "target": 1, "func": "void vmstate_save_state(QEMUFile *f, const VMStateDescription *vmsd,\n\n                        void *opaque)\n\n{\n\n    VMStateField *field = vmsd->fields;\n\n\n\n    if (vmsd->pre_save) {\n\n        vmsd->pre_save(opaque);\n\n\n    while (field->name) {\n\n        if (!field->field_exists ||\n\n            field->field_exists(opaque, vmsd->version_id)) {\n\n            void *base_addr = vmstate_base_addr(opaque, field);\n\n            int i, n_elems = vmstate_n_elems(opaque, field);\n\n            int size = vmstate_size(opaque, field);\n\n\n\n            for (i = 0; i < n_elems; i++) {\n\n                void *addr = base_addr + size * i;\n\n\n\n                if (field->flags & VMS_ARRAY_OF_POINTER) {\n\n                    addr = *(void **)addr;\n\n\n                if (field->flags & VMS_STRUCT) {\n\n                    vmstate_save_state(f, field->vmsd, addr);\n\n\n                    field->info->put(f, addr, size);\n\n\n\n\n\n\n\n\n\n\n        field++;\n\n\n    vmstate_subsection_save(f, vmsd, opaque);\n", "idx": 24830, "_split": "valid", "_hash": "3c69706848d58b2c222c5e07a2040d91"}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_closedir(FsContext *ctx, V9fsFidOpenState *fs)\n\n{\n\n    V9fsSynthOpenState *synth_open = fs->private;\n\n    V9fsSynthNode *node = synth_open->node;\n\n\n\n    node->open_count--;\n\n    g_free(synth_open);\n\n    fs->private = NULL;\n\n    return 0;\n\n}\n", "idx": 24842, "_split": "valid", "_hash": "bf107af26ad18a374e3d0c6af2d21e6e"}
{"project": "qemu", "commit_id": "c16de8f59a2bcbe2dc037524cc648de896f581a4", "target": 0, "func": "static int blk_root_inactivate(BdrvChild *child)\n\n{\n\n    BlockBackend *blk = child->opaque;\n\n\n\n    if (blk->disable_perm) {\n\n        return 0;\n\n    }\n\n\n\n    /* Only inactivate BlockBackends for guest devices (which are inactive at\n\n     * this point because the VM is stopped) and unattached monitor-owned\n\n     * BlockBackends. If there is still any other user like a block job, then\n\n     * we simply can't inactivate the image. */\n\n    if (!blk->dev && !blk_name(blk)[0]) {\n\n        return -EPERM;\n\n    }\n\n\n\n    blk->disable_perm = true;\n\n    if (blk->root) {\n\n        bdrv_child_try_set_perm(blk->root, 0, BLK_PERM_ALL, &error_abort);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24863, "_split": "valid", "_hash": "d3d099c170ea815d5b68b742876bcb35"}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_update_rect_flush(struct vmsvga_state_s *s)\n\n{\n\n    struct vmsvga_rect_s *rect;\n\n    if (s->invalidated) {\n\n        s->redraw_fifo_first = s->redraw_fifo_last;\n\n        return;\n\n    }\n\n    /* Overlapping region updates can be optimised out here - if someone\n\n     * knows a smart algorithm to do that, please share.  */\n\n    while (s->redraw_fifo_first != s->redraw_fifo_last) {\n\n        rect = &s->redraw_fifo[s->redraw_fifo_first ++];\n\n        s->redraw_fifo_first &= REDRAW_FIFO_LEN - 1;\n\n        vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);\n\n    }\n\n}\n", "idx": 24865, "_split": "valid", "_hash": "a475b710274b4fa60e7e0740de2f590e"}
{"project": "qemu", "commit_id": "0923c577f993d61eeaf41f66db1e1010fa113976", "target": 0, "func": "length_f(int argc, char **argv)\n\n{\n\n        int64_t size;\n\n\tchar s1[64];\n\n\n\n\tsize = bdrv_getlength(bs);\n\n\tif (size < 0) {\n\n\t\tprintf(\"getlength: %s\", strerror(size));\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tcvtstr(size, s1, sizeof(s1));\n\n\tprintf(\"%s\\n\", s1);\n\n\treturn 0;\n\n}\n", "idx": 24872, "_split": "valid", "_hash": "03f1e2110d0b55384148100f3f0a7cc4"}
{"project": "qemu", "commit_id": "855011be05fad72e17e0280d0bab87a4bc840695", "target": 0, "func": "static void kvm_arm_gic_get(GICState *s)\n\n{\n\n    /* TODO: there isn't currently a kernel interface to get the GIC state */\n\n}\n", "idx": 24885, "_split": "valid", "_hash": "6e6123e964cbe619e5bb505d52ef5ae6"}
{"project": "qemu", "commit_id": "faadf50e2962dd54175647a80bd6fc4319c91973", "target": 1, "func": "static void init_proc_601 (CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_601(env);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_601_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_601_HID5, \"HID5\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_601_HID15, \"HID15\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Memory management */\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->nb_tlb = 64;\n\n    env->nb_ways = 2;\n\n    env->id_tlbs = 0;\n\n#endif\n\n    init_excp_601(env);\n\n    env->dcache_line_size = 64;\n\n    env->icache_line_size = 64;\n\n    /* XXX: TODO: allocate internal IRQ controller */\n\n}\n", "idx": 24918, "_split": "valid", "_hash": "a468995641e36bdd821f6d0ebe6a17c7"}
{"project": "qemu", "commit_id": "24b856ca63f1c72b5043af6b291e7cc35900f4d6", "target": 0, "func": "static int i6300esb_init(PCIDevice *dev)\n\n{\n\n    I6300State *d = DO_UPCAST(I6300State, dev, dev);\n\n    uint8_t *pci_conf;\n\n    int io_mem;\n\n    static CPUReadMemoryFunc * const mem_read[3] = {\n\n        i6300esb_mem_readb,\n\n        i6300esb_mem_readw,\n\n        i6300esb_mem_readl,\n\n    };\n\n    static CPUWriteMemoryFunc * const mem_write[3] = {\n\n        i6300esb_mem_writeb,\n\n        i6300esb_mem_writew,\n\n        i6300esb_mem_writel,\n\n    };\n\n\n\n    i6300esb_debug(\"I6300State = %p\\n\", d);\n\n\n\n    d->timer = qemu_new_timer_ns(vm_clock, i6300esb_timer_expired, d);\n\n    d->previous_reboot_flag = 0;\n\n\n\n    pci_conf = d->dev.config;\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_ESB_9);\n\n    pci_config_set_class(pci_conf, PCI_CLASS_SYSTEM_OTHER);\n\n\n\n    io_mem = cpu_register_io_memory(mem_read, mem_write, d,\n\n                                    DEVICE_NATIVE_ENDIAN);\n\n    pci_register_bar_simple(&d->dev, 0, 0x10, 0, io_mem);\n\n    /* qemu_register_coalesced_mmio (addr, 0x10); ? */\n\n\n\n    return 0;\n\n}\n", "idx": 24935, "_split": "valid", "_hash": "66184581ca5e7ae6d6fa77c1e9ffb361"}
{"project": "qemu", "commit_id": "0ddf08db22a9ef6b122d8c4cfe5b25d2c2c51962", "target": 0, "func": "NBDExport *nbd_export_new(BlockDriverState *bs, off_t dev_offset,\n\n                          off_t size, uint32_t nbdflags)\n\n{\n\n    NBDExport *exp = g_malloc0(sizeof(NBDExport));\n\n    QSIMPLEQ_INIT(&exp->requests);\n\n    exp->refcount = 1;\n\n    QTAILQ_INIT(&exp->clients);\n\n    exp->bs = bs;\n\n    exp->dev_offset = dev_offset;\n\n    exp->nbdflags = nbdflags;\n\n    exp->size = size == -1 ? bdrv_getlength(bs) : size;\n\n    return exp;\n\n}\n", "idx": 24937, "_split": "valid", "_hash": "7fc6df6ee89396ea0889109f2c594907"}
{"project": "qemu", "commit_id": "2572b37a4751cc967582d7d04f21d9bf97187ae5", "target": 0, "func": "static BlockDriverAIOCB *bdrv_aio_rw_vector(BlockDriverState *bs,\n\n                                            int64_t sector_num,\n\n                                            QEMUIOVector *qiov,\n\n                                            int nb_sectors,\n\n                                            BlockDriverCompletionFunc *cb,\n\n                                            void *opaque,\n\n                                            int is_write)\n\n\n\n{\n\n    BlockDriverAIOCBSync *acb;\n\n\n\n    acb = qemu_aio_get(&bdrv_em_aiocb_info, bs, cb, opaque);\n\n    acb->is_write = is_write;\n\n    acb->qiov = qiov;\n\n    acb->bounce = qemu_blockalign(bs, qiov->size);\n\n    acb->bh = qemu_bh_new(bdrv_aio_bh_cb, acb);\n\n\n\n    if (is_write) {\n\n        qemu_iovec_to_buf(acb->qiov, 0, acb->bounce, qiov->size);\n\n        acb->ret = bs->drv->bdrv_write(bs, sector_num, acb->bounce, nb_sectors);\n\n    } else {\n\n        acb->ret = bs->drv->bdrv_read(bs, sector_num, acb->bounce, nb_sectors);\n\n    }\n\n\n\n    qemu_bh_schedule(acb->bh);\n\n\n\n    return &acb->common;\n\n}\n", "idx": 24938, "_split": "valid", "_hash": "021b1662abb1233fc055be1ee668c4ff"}
{"project": "qemu", "commit_id": "49fb65c7f985baa56d2964e0a85c1f098e3e2a9d", "target": 1, "func": "static void virtio_scsi_push_event(VirtIOSCSI *s, SCSIDevice *dev,\n\n                                   uint32_t event, uint32_t reason)\n\n{\n\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);\n\n    VirtIOSCSIReq *req = virtio_scsi_pop_req(s, vs->event_vq);\n\n    VirtIOSCSIEvent *evt;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    int in_size;\n\n\n\n    if (!(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK)) {\n\n        return;\n\n    }\n\n\n\n    if (!req) {\n\n        s->events_dropped = true;\n\n        return;\n\n    }\n\n\n\n    if (req->elem.out_num || req->elem.in_num != 1) {\n\n        virtio_scsi_bad_req();\n\n    }\n\n\n\n    if (s->events_dropped) {\n\n        event |= VIRTIO_SCSI_T_EVENTS_MISSED;\n\n        s->events_dropped = false;\n\n    }\n\n\n\n    in_size = req->elem.in_sg[0].iov_len;\n\n    if (in_size < sizeof(VirtIOSCSIEvent)) {\n\n        virtio_scsi_bad_req();\n\n    }\n\n\n\n    evt = req->resp.event;\n\n    memset(evt, 0, sizeof(VirtIOSCSIEvent));\n\n    evt->event = event;\n\n    evt->reason = reason;\n\n    if (!dev) {\n\n        assert(event == VIRTIO_SCSI_T_NO_EVENT);\n\n    } else {\n\n        evt->lun[0] = 1;\n\n        evt->lun[1] = dev->id;\n\n\n\n        /* Linux wants us to keep the same encoding we use for REPORT LUNS.  */\n\n        if (dev->lun >= 256) {\n\n            evt->lun[2] = (dev->lun >> 8) | 0x40;\n\n        }\n\n        evt->lun[3] = dev->lun & 0xFF;\n\n    }\n\n    virtio_scsi_complete_req(req);\n\n}\n", "idx": 24950, "_split": "valid", "_hash": "60dd74b8a8e4caab019b1f0e7339ca01"}
{"project": "qemu", "commit_id": "bb639f829f139ddc83325b3b6825f93096ee44f1", "target": 1, "func": "static void ahci_irq_raise(AHCIState *s, AHCIDevice *dev)\n\n{\n\n    AHCIPCIState *d = container_of(s, AHCIPCIState, ahci);\n\n    PCIDevice *pci_dev =\n\n        (PCIDevice *)object_dynamic_cast(OBJECT(d), TYPE_PCI_DEVICE);\n\n\n\n    DPRINTF(0, \"raise irq\\n\");\n\n\n\n    if (pci_dev && msi_enabled(pci_dev)) {\n\n        msi_notify(pci_dev, 0);\n\n    } else {\n\n        qemu_irq_raise(s->irq);\n\n    }\n\n}\n", "idx": 24965, "_split": "valid", "_hash": "7f32e642bc2e9b99f8aa814512a8882e"}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "void run_on_cpu(CPUState *env, void (*func)(void *data), void *data)\n\n{\n\n    struct qemu_work_item wi;\n\n\n\n    if (qemu_cpu_self(env)) {\n\n        func(data);\n\n        return;\n\n    }\n\n\n\n    wi.func = func;\n\n    wi.data = data;\n\n    if (!env->queued_work_first)\n\n        env->queued_work_first = &wi;\n\n    else\n\n        env->queued_work_last->next = &wi;\n\n    env->queued_work_last = &wi;\n\n    wi.next = NULL;\n\n    wi.done = false;\n\n\n\n    qemu_cpu_kick(env);\n\n    while (!wi.done) {\n\n        CPUState *self_env = cpu_single_env;\n\n\n\n        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);\n\n        cpu_single_env = self_env;\n\n    }\n\n}\n", "idx": 25007, "_split": "valid", "_hash": "2939c096983e0019e9f99e767965e614"}
{"project": "qemu", "commit_id": "53bb8cc4855827f2981bf0566076233573a05bd7", "target": 1, "func": "static sd_rsp_type_t sd_normal_command(SDState *sd,\n\n                                       SDRequest req)\n\n{\n\n    uint32_t rca = 0x0000;\n\n    uint64_t addr = (sd->ocr & (1 << 30)) ? (uint64_t) req.arg << 9 : req.arg;\n\n\n\n    if (sd_cmd_type[req.cmd] == sd_ac || sd_cmd_type[req.cmd] == sd_adtc)\n\n        rca = req.arg >> 16;\n\n\n\n    DPRINTF(\"CMD%d 0x%08x state %d\\n\", req.cmd, req.arg, sd->state);\n\n    switch (req.cmd) {\n\n    /* Basic commands (Class 0 and Class 1) */\n\n    case 0:\t/* CMD0:   GO_IDLE_STATE */\n\n        switch (sd->state) {\n\n        case sd_inactive_state:\n\n            return sd->spi ? sd_r1 : sd_r0;\n\n\n\n        default:\n\n            sd->state = sd_idle_state;\n\n            sd_reset(sd, sd->bdrv);\n\n            return sd->spi ? sd_r1 : sd_r0;\n\n        }\n\n        break;\n\n\n\n    case 1:\t/* CMD1:   SEND_OP_CMD */\n\n        if (!sd->spi)\n\n            goto bad_cmd;\n\n\n\n        sd->state = sd_transfer_state;\n\n        return sd_r1;\n\n\n\n    case 2:\t/* CMD2:   ALL_SEND_CID */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->state) {\n\n        case sd_ready_state:\n\n            sd->state = sd_identification_state;\n\n            return sd_r2_i;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 3:\t/* CMD3:   SEND_RELATIVE_ADDR */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->state) {\n\n        case sd_identification_state:\n\n        case sd_standby_state:\n\n            sd->state = sd_standby_state;\n\n            sd_set_rca(sd);\n\n            return sd_r6;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 4:\t/* CMD4:   SEND_DSR */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->state) {\n\n        case sd_standby_state:\n\n            break;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 5: /* CMD5: reserved for SDIO cards */\n\n        sd->card_status |= ILLEGAL_COMMAND;\n\n        return sd_r0;\n\n\n\n    case 6:\t/* CMD6:   SWITCH_FUNCTION */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->mode) {\n\n        case sd_data_transfer_mode:\n\n            sd_function_switch(sd, req.arg);\n\n            sd->state = sd_sendingdata_state;\n\n            sd->data_start = 0;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 7:\t/* CMD7:   SELECT/DESELECT_CARD */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->state) {\n\n        case sd_standby_state:\n\n            if (sd->rca != rca)\n\n                return sd_r0;\n\n\n\n            sd->state = sd_transfer_state;\n\n            return sd_r1b;\n\n\n\n        case sd_transfer_state:\n\n        case sd_sendingdata_state:\n\n            if (sd->rca == rca)\n\n                break;\n\n\n\n            sd->state = sd_standby_state;\n\n            return sd_r1b;\n\n\n\n        case sd_disconnect_state:\n\n            if (sd->rca != rca)\n\n                return sd_r0;\n\n\n\n            sd->state = sd_programming_state;\n\n            return sd_r1b;\n\n\n\n        case sd_programming_state:\n\n            if (sd->rca == rca)\n\n                break;\n\n\n\n            sd->state = sd_disconnect_state;\n\n            return sd_r1b;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 8:\t/* CMD8:   SEND_IF_COND */\n\n        /* Physical Layer Specification Version 2.00 command */\n\n        switch (sd->state) {\n\n        case sd_idle_state:\n\n            sd->vhs = 0;\n\n\n\n            /* No response if not exactly one VHS bit is set.  */\n\n            if (!(req.arg >> 8) || (req.arg >> ffs(req.arg & ~0xff)))\n\n                return sd->spi ? sd_r7 : sd_r0;\n\n\n\n            /* Accept.  */\n\n            sd->vhs = req.arg;\n\n            return sd_r7;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 9:\t/* CMD9:   SEND_CSD */\n\n        switch (sd->state) {\n\n        case sd_standby_state:\n\n            if (sd->rca != rca)\n\n                return sd_r0;\n\n\n\n            return sd_r2_s;\n\n\n\n        case sd_transfer_state:\n\n            if (!sd->spi)\n\n                break;\n\n            sd->state = sd_sendingdata_state;\n\n            memcpy(sd->data, sd->csd, 16);\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 10:\t/* CMD10:  SEND_CID */\n\n        switch (sd->state) {\n\n        case sd_standby_state:\n\n            if (sd->rca != rca)\n\n                return sd_r0;\n\n\n\n            return sd_r2_i;\n\n\n\n        case sd_transfer_state:\n\n            if (!sd->spi)\n\n                break;\n\n            sd->state = sd_sendingdata_state;\n\n            memcpy(sd->data, sd->cid, 16);\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 11:\t/* CMD11:  READ_DAT_UNTIL_STOP */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_sendingdata_state;\n\n            sd->data_start = req.arg;\n\n            sd->data_offset = 0;\n\n\n\n            if (sd->data_start + sd->blk_len > sd->size)\n\n                sd->card_status |= ADDRESS_ERROR;\n\n            return sd_r0;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 12:\t/* CMD12:  STOP_TRANSMISSION */\n\n        switch (sd->state) {\n\n        case sd_sendingdata_state:\n\n            sd->state = sd_transfer_state;\n\n            return sd_r1b;\n\n\n\n        case sd_receivingdata_state:\n\n            sd->state = sd_programming_state;\n\n            /* Bzzzzzzztt .... Operation complete.  */\n\n            sd->state = sd_transfer_state;\n\n            return sd_r1b;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 13:\t/* CMD13:  SEND_STATUS */\n\n        switch (sd->mode) {\n\n        case sd_data_transfer_mode:\n\n            if (sd->rca != rca)\n\n                return sd_r0;\n\n\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 15:\t/* CMD15:  GO_INACTIVE_STATE */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->mode) {\n\n        case sd_data_transfer_mode:\n\n            if (sd->rca != rca)\n\n                return sd_r0;\n\n\n\n            sd->state = sd_inactive_state;\n\n            return sd_r0;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    /* Block read commands (Classs 2) */\n\n    case 16:\t/* CMD16:  SET_BLOCKLEN */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            if (req.arg > (1 << HWBLOCK_SHIFT))\n\n                sd->card_status |= BLOCK_LEN_ERROR;\n\n            else\n\n                sd->blk_len = req.arg;\n\n\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 17:\t/* CMD17:  READ_SINGLE_BLOCK */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_sendingdata_state;\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n\n\n            if (sd->data_start + sd->blk_len > sd->size)\n\n                sd->card_status |= ADDRESS_ERROR;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 18:\t/* CMD18:  READ_MULTIPLE_BLOCK */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_sendingdata_state;\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n\n\n            if (sd->data_start + sd->blk_len > sd->size)\n\n                sd->card_status |= ADDRESS_ERROR;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    /* Block write commands (Class 4) */\n\n    case 24:\t/* CMD24:  WRITE_SINGLE_BLOCK */\n\n        if (sd->spi)\n\n            goto unimplemented_cmd;\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            /* Writing in SPI mode not implemented.  */\n\n            if (sd->spi)\n\n                break;\n\n            sd->state = sd_receivingdata_state;\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n            sd->blk_written = 0;\n\n\n\n            if (sd->data_start + sd->blk_len > sd->size)\n\n                sd->card_status |= ADDRESS_ERROR;\n\n            if (sd_wp_addr(sd, sd->data_start))\n\n                sd->card_status |= WP_VIOLATION;\n\n            if (sd->csd[14] & 0x30)\n\n                sd->card_status |= WP_VIOLATION;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 25:\t/* CMD25:  WRITE_MULTIPLE_BLOCK */\n\n        if (sd->spi)\n\n            goto unimplemented_cmd;\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            /* Writing in SPI mode not implemented.  */\n\n            if (sd->spi)\n\n                break;\n\n            sd->state = sd_receivingdata_state;\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n            sd->blk_written = 0;\n\n\n\n            if (sd->data_start + sd->blk_len > sd->size)\n\n                sd->card_status |= ADDRESS_ERROR;\n\n            if (sd_wp_addr(sd, sd->data_start))\n\n                sd->card_status |= WP_VIOLATION;\n\n            if (sd->csd[14] & 0x30)\n\n                sd->card_status |= WP_VIOLATION;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 26:\t/* CMD26:  PROGRAM_CID */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_receivingdata_state;\n\n            sd->data_start = 0;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 27:\t/* CMD27:  PROGRAM_CSD */\n\n        if (sd->spi)\n\n            goto unimplemented_cmd;\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_receivingdata_state;\n\n            sd->data_start = 0;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    /* Write protection (Class 6) */\n\n    case 28:\t/* CMD28:  SET_WRITE_PROT */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            if (addr >= sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                return sd_r1b;\n\n            }\n\n\n\n            sd->state = sd_programming_state;\n\n            sd->wp_groups[addr >> (HWBLOCK_SHIFT +\n\n                            SECTOR_SHIFT + WPGROUP_SHIFT)] = 1;\n\n            /* Bzzzzzzztt .... Operation complete.  */\n\n            sd->state = sd_transfer_state;\n\n            return sd_r1b;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 29:\t/* CMD29:  CLR_WRITE_PROT */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            if (addr >= sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                return sd_r1b;\n\n            }\n\n\n\n            sd->state = sd_programming_state;\n\n            sd->wp_groups[addr >> (HWBLOCK_SHIFT +\n\n                            SECTOR_SHIFT + WPGROUP_SHIFT)] = 0;\n\n            /* Bzzzzzzztt .... Operation complete.  */\n\n            sd->state = sd_transfer_state;\n\n            return sd_r1b;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 30:\t/* CMD30:  SEND_WRITE_PROT */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_sendingdata_state;\n\n            *(uint32_t *) sd->data = sd_wpbits(sd, req.arg);\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n            return sd_r1b;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    /* Erase commands (Class 5) */\n\n    case 32:\t/* CMD32:  ERASE_WR_BLK_START */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->erase_start = req.arg;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 33:\t/* CMD33:  ERASE_WR_BLK_END */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->erase_end = req.arg;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 38:\t/* CMD38:  ERASE */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            if (sd->csd[14] & 0x30) {\n\n                sd->card_status |= WP_VIOLATION;\n\n                return sd_r1b;\n\n            }\n\n\n\n            sd->state = sd_programming_state;\n\n            sd_erase(sd);\n\n            /* Bzzzzzzztt .... Operation complete.  */\n\n            sd->state = sd_transfer_state;\n\n            return sd_r1b;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    /* Lock card commands (Class 7) */\n\n    case 42:\t/* CMD42:  LOCK_UNLOCK */\n\n        if (sd->spi)\n\n            goto unimplemented_cmd;\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_receivingdata_state;\n\n            sd->data_start = 0;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 52:\n\n    case 53:\n\n        /* CMD52, CMD53: reserved for SDIO cards\n\n         * (see the SDIO Simplified Specification V2.0)\n\n         * Handle as illegal command but do not complain\n\n         * on stderr, as some OSes may use these in their\n\n         * probing for presence of an SDIO card.\n\n         */\n\n        sd->card_status |= ILLEGAL_COMMAND;\n\n        return sd_r0;\n\n\n\n    /* Application specific commands (Class 8) */\n\n    case 55:\t/* CMD55:  APP_CMD */\n\n        if (sd->rca != rca)\n\n            return sd_r0;\n\n\n\n        sd->card_status |= APP_CMD;\n\n        return sd_r1;\n\n\n\n    case 56:\t/* CMD56:  GEN_CMD */\n\n        fprintf(stderr, \"SD: GEN_CMD 0x%08x\\n\", req.arg);\n\n\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->data_offset = 0;\n\n            if (req.arg & 1)\n\n                sd->state = sd_sendingdata_state;\n\n            else\n\n                sd->state = sd_receivingdata_state;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default:\n\n    bad_cmd:\n\n        sd->card_status |= ILLEGAL_COMMAND;\n\n\n\n        fprintf(stderr, \"SD: Unknown CMD%i\\n\", req.cmd);\n\n        return sd_r0;\n\n\n\n    unimplemented_cmd:\n\n        /* Commands that are recognised but not yet implemented in SPI mode.  */\n\n        sd->card_status |= ILLEGAL_COMMAND;\n\n        fprintf(stderr, \"SD: CMD%i not implemented in SPI mode\\n\", req.cmd);\n\n        return sd_r0;\n\n    }\n\n\n\n    sd->card_status |= ILLEGAL_COMMAND;\n\n    fprintf(stderr, \"SD: CMD%i in a wrong state\\n\", req.cmd);\n\n    return sd_r0;\n\n}\n", "idx": 25049, "_split": "valid", "_hash": "124ed3053e9010b78a38ac32b7c928d8"}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint8_equal(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint8_t *v = pv;\n\n    uint8_t v2;\n\n    qemu_get_8s(f, &v2);\n\n\n\n    if (*v == v2) {\n\n        return 0;\n\n    }\n\n    return -EINVAL;\n\n}\n", "idx": 25123, "_split": "valid", "_hash": "cc637af25a5b44972363f1a0d3ead178"}
{"project": "qemu", "commit_id": "74f24cb6306d065045d0e2215a7d10533fa59c57", "target": 1, "func": "static void test_visitor_in_intList(TestInputVisitorData *data,\n\n                                    const void *unused)\n\n{\n\n    int64_t value[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 20};\n\n    int16List *res = NULL, *tmp;\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n    int i = 0;\n\n\n\n    v = visitor_input_test_init(data, \"1,2,0,2-4,20,5-9,1-8\");\n\n\n\n    visit_type_int16List(v, NULL, &res, &error_abort);\n\n    tmp = res;\n\n    while (i < sizeof(value) / sizeof(value[0])) {\n\n        g_assert(tmp);\n\n        g_assert_cmpint(tmp->value, ==, value[i++]);\n\n        tmp = tmp->next;\n\n    }\n\n    g_assert(!tmp);\n\n\n\n    tmp = res;\n\n    while (tmp) {\n\n        res = res->next;\n\n        g_free(tmp);\n\n        tmp = res;\n\n    }\n\n\n\n    visitor_input_teardown(data, unused);\n\n\n\n    v = visitor_input_test_init(data, \"not an int list\");\n\n\n\n    visit_type_int16List(v, NULL, &res, &err);\n\n    /* FIXME fix the visitor, then error_free_or_abort(&err) here */\n\n}\n", "idx": 25146, "_split": "valid", "_hash": "8cd690f066c13cc98231924224764e11"}
{"project": "qemu", "commit_id": "4f400ab52009ed8f76fa541454a4368f9515f897", "target": 1, "func": "gen_intermediate_code_internal(CPUState *env, TranslationBlock *tb,\n\n                               int search_pc)\n\n{\n\n\tuint16_t *gen_opc_end;\n\n   \tuint32_t pc_start;\n\n\tunsigned int insn_len;\n\n\tint j, lj;\n\n\tstruct DisasContext *dc = &ctx;\n\n\tuint32_t next_page_start;\n\n\n\n\tpc_start = tb->pc;\n\n\tdc->env = env;\n\n\tdc->tb = tb;\n\n\n\n\tgen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n\n\n\tdc->is_jmp = DISAS_NEXT;\n\n\tdc->pc = pc_start;\n\n\tdc->singlestep_enabled = env->singlestep_enabled;\n\n\tdc->flagx_live = 0;\n\n\tdc->flags_x = 0;\n\n\tnext_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n\tlj = -1;\n\n\tdo\n\n\t{\n\n\t\tcheck_breakpoint(env, dc);\n\n\t\tif (dc->is_jmp == DISAS_JUMP)\n\n\t\t\tgoto done;\n\n\n\n\t\tif (search_pc) {\n\n\t\t\tj = gen_opc_ptr - gen_opc_buf;\n\n\t\t\tif (lj < j) {\n\n\t\t\t\tlj++;\n\n\t\t\t\twhile (lj < j)\n\n\t\t\t\t\tgen_opc_instr_start[lj++] = 0;\n\n\t\t\t}\n\n\t\t\tgen_opc_pc[lj] = dc->pc;\n\n\t\t\tgen_opc_instr_start[lj] = 1;\n\n\t\t}\n\n\n\n\t\tinsn_len = cris_decoder(dc);\n\n\t\tSTATS(gen_op_exec_insn());\n\n\t\tdc->pc += insn_len;\n\n\t\tif (!dc->flagx_live\n\n\t\t    || (dc->flagx_live &&\n\n\t\t\t!(dc->cc_op == CC_OP_FLAGS && dc->flags_x))) {\n\n\t\t\tgen_movl_T0_preg[PR_CCS]();\n\n\t\t\tgen_op_andl_T0_im(~X_FLAG);\n\n\t\t\tgen_movl_preg_T0[PR_CCS]();\n\n\t\t\tdc->flagx_live = 1;\n\n\t\t\tdc->flags_x = 0;\n\n\t\t}\n\n\n\n\t\t/* Check for delayed branches here. If we do it before\n\n\t\t   actually genereating any host code, the simulator will just\n\n\t\t   loop doing nothing for on this program location.  */\n\n\t\tif (dc->delayed_branch) {\n\n\t\t\tdc->delayed_branch--;\n\n\t\t\tif (dc->delayed_branch == 0)\n\n\t\t\t{\n\n\t\t\t\tif (dc->bcc == CC_A) {\n\n\t\t\t\t\tgen_op_jmp1 ();\n\n\t\t\t\t\tdc->is_jmp = DISAS_UPDATE;\n\n\t\t\t\t}\n\n\t\t\t\telse {\n\n\t\t\t\t\t/* Conditional jmp.  */\n\n\t\t\t\t\tgen_op_cc_jmp (dc->delayed_pc, dc->pc);\n\n\t\t\t\t\tdc->is_jmp = DISAS_UPDATE;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\n\t\tif (env->singlestep_enabled)\n\n\t\t\tbreak;\n\n\t} while (!dc->is_jmp && gen_opc_ptr < gen_opc_end\n\n\t\t && dc->pc < next_page_start);\n\n\n\n\tif (!dc->is_jmp) {\n\n\t\tgen_op_movl_T0_im((long)dc->pc);\n\n\t\tgen_op_movl_pc_T0();\n\n\t}\n\n\n\n\tcris_evaluate_flags (dc);\n\n  done:\n\n\tif (__builtin_expect(env->singlestep_enabled, 0)) {\n\n\t\tgen_op_debug();\n\n\t} else {\n\n\t\tswitch(dc->is_jmp) {\n\n\t\t\tcase DISAS_NEXT:\n\n\t\t\t\tgen_goto_tb(dc, 1, dc->pc);\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\tcase DISAS_JUMP:\n\n\t\t\tcase DISAS_UPDATE:\n\n\t\t\t\t/* indicate that the hash table must be used\n\n\t\t\t\t   to find the next TB */\n\n\t\t\t\ttcg_gen_exit_tb(0);\n\n\t\t\t\tbreak;\n\n\t\t\tcase DISAS_TB_JUMP:\n\n\t\t\t\t/* nothing more to generate */\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t*gen_opc_ptr = INDEX_op_end;\n\n\tif (search_pc) {\n\n\t\tj = gen_opc_ptr - gen_opc_buf;\n\n\t\tlj++;\n\n\t\twhile (lj <= j)\n\n\t\t\tgen_opc_instr_start[lj++] = 0;\n\n\t} else {\n\n\t\ttb->size = dc->pc - pc_start;\n\n\t}\n\n\n\n#ifdef DEBUG_DISAS\n\n\tif (loglevel & CPU_LOG_TB_IN_ASM) {\n\n\t\tfprintf(logfile, \"--------------\\n\");\n\n\t\tfprintf(logfile, \"IN: %s\\n\", lookup_symbol(pc_start));\n\n\t\ttarget_disas(logfile, pc_start, dc->pc + 4 - pc_start, 0);\n\n\t\tfprintf(logfile, \"\\n\");\n\n\t}\n\n#endif\n\n\treturn 0;\n\n}\n", "idx": 25157, "_split": "valid", "_hash": "bc30e1795bca22bff77ad98cdf4f1a4a"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_io_limits_disable(BlockDriverState *bs)\n\n{\n\n    bs->io_limits_enabled = false;\n\n\n\n    bdrv_start_throttled_reqs(bs);\n\n\n\n    throttle_destroy(&bs->throttle_state);\n\n}\n", "idx": 25206, "_split": "valid", "_hash": "b179039159a792da64d898940a85862e"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static int coroutine_fn bdrv_co_do_preadv(BlockDriverState *bs,\n\n    int64_t offset, unsigned int bytes, QEMUIOVector *qiov,\n\n    BdrvRequestFlags flags)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    BdrvTrackedRequest req;\n\n\n\n    uint64_t align = bdrv_get_align(bs);\n\n    uint8_t *head_buf = NULL;\n\n    uint8_t *tail_buf = NULL;\n\n    QEMUIOVector local_qiov;\n\n    bool use_local_qiov = false;\n\n    int ret;\n\n\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n\n\n    ret = bdrv_check_byte_request(bs, offset, bytes);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (bs->copy_on_read) {\n\n        flags |= BDRV_REQ_COPY_ON_READ;\n\n    }\n\n\n\n    /* throttling disk I/O */\n\n    if (bs->io_limits_enabled) {\n\n        bdrv_io_limits_intercept(bs, bytes, false);\n\n    }\n\n\n\n    /* Align read if necessary by padding qiov */\n\n    if (offset & (align - 1)) {\n\n        head_buf = qemu_blockalign(bs, align);\n\n        qemu_iovec_init(&local_qiov, qiov->niov + 2);\n\n        qemu_iovec_add(&local_qiov, head_buf, offset & (align - 1));\n\n        qemu_iovec_concat(&local_qiov, qiov, 0, qiov->size);\n\n        use_local_qiov = true;\n\n\n\n        bytes += offset & (align - 1);\n\n        offset = offset & ~(align - 1);\n\n    }\n\n\n\n    if ((offset + bytes) & (align - 1)) {\n\n        if (!use_local_qiov) {\n\n            qemu_iovec_init(&local_qiov, qiov->niov + 1);\n\n            qemu_iovec_concat(&local_qiov, qiov, 0, qiov->size);\n\n            use_local_qiov = true;\n\n        }\n\n        tail_buf = qemu_blockalign(bs, align);\n\n        qemu_iovec_add(&local_qiov, tail_buf,\n\n                       align - ((offset + bytes) & (align - 1)));\n\n\n\n        bytes = ROUND_UP(bytes, align);\n\n    }\n\n\n\n    tracked_request_begin(&req, bs, offset, bytes, false);\n\n    ret = bdrv_aligned_preadv(bs, &req, offset, bytes, align,\n\n                              use_local_qiov ? &local_qiov : qiov,\n\n                              flags);\n\n    tracked_request_end(&req);\n\n\n\n    if (use_local_qiov) {\n\n        qemu_iovec_destroy(&local_qiov);\n\n        qemu_vfree(head_buf);\n\n        qemu_vfree(tail_buf);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 25219, "_split": "valid", "_hash": "1a571feb293a5634dd46c1027b7fa092"}
{"project": "qemu", "commit_id": "1ec26c757d5996468afcc0dced4fad04139574b3", "target": 0, "func": "void kvmppc_update_sdr1(target_ulong sdr1)\n\n{\n\n    CPUState *cs;\n\n\n\n    CPU_FOREACH(cs) {\n\n        run_on_cpu(cs, kvmppc_pivot_hpt_cpu, RUN_ON_CPU_TARGET_PTR(sdr1));\n\n    }\n\n}\n", "idx": 25232, "_split": "valid", "_hash": "8a9840bda25291eb4724ef4842f85819"}
{"project": "qemu", "commit_id": "a22313deca720e038ebc5805cf451b3a685d29ce", "target": 0, "func": "static void vfio_start_irqfd_injection(SysBusDevice *sbdev, qemu_irq irq)\n\n{\n\n    VFIOPlatformDevice *vdev = VFIO_PLATFORM_DEVICE(sbdev);\n\n    VFIOINTp *intp;\n\n\n\n    if (!kvm_irqfds_enabled() || !kvm_resamplefds_enabled() ||\n\n        !vdev->irqfd_allowed) {\n\n        goto fail_irqfd;\n\n    }\n\n\n\n    QLIST_FOREACH(intp, &vdev->intp_list, next) {\n\n        if (intp->qemuirq == irq) {\n\n            break;\n\n        }\n\n    }\n\n    assert(intp);\n\n\n\n    if (kvm_irqchip_add_irqfd_notifier(kvm_state, &intp->interrupt,\n\n                                   &intp->unmask, irq) < 0) {\n\n        goto fail_irqfd;\n\n    }\n\n\n\n    if (vfio_set_trigger_eventfd(intp, NULL) < 0) {\n\n        goto fail_vfio;\n\n    }\n\n    if (vfio_set_resample_eventfd(intp) < 0) {\n\n        goto fail_vfio;\n\n    }\n\n\n\n    intp->kvm_accel = true;\n\n\n\n    trace_vfio_platform_start_irqfd_injection(intp->pin,\n\n                                     event_notifier_get_fd(&intp->interrupt),\n\n                                     event_notifier_get_fd(&intp->unmask));\n\n    return;\n\nfail_vfio:\n\n    kvm_irqchip_remove_irqfd_notifier(kvm_state, &intp->interrupt, irq);\n\n    error_report(\"vfio: failed to start eventfd signaling for IRQ %d: %m\",\n\n                 intp->pin);\n\n    abort();\n\nfail_irqfd:\n\n    vfio_start_eventfd_injection(sbdev, irq);\n\n    return;\n\n}\n", "idx": 25234, "_split": "valid", "_hash": "69e74f2ebcf88e165b639de4163fc1f7"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_mpuio_write(void *opaque, target_phys_addr_t addr,\n\n                             uint64_t value, unsigned size)\n\n{\n\n    struct omap_mpuio_s *s = (struct omap_mpuio_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n    uint16_t diff;\n\n    int ln;\n\n\n\n    if (size != 2) {\n\n        return omap_badwidth_write16(opaque, addr, value);\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x04:\t/* OUTPUT_REG */\n\n        diff = (s->outputs ^ value) & ~s->dir;\n\n        s->outputs = value;\n\n        while ((ln = ffs(diff))) {\n\n            ln --;\n\n            if (s->handler[ln])\n\n                qemu_set_irq(s->handler[ln], (value >> ln) & 1);\n\n            diff &= ~(1 << ln);\n\n        }\n\n        break;\n\n\n\n    case 0x08:\t/* IO_CNTL */\n\n        diff = s->outputs & (s->dir ^ value);\n\n        s->dir = value;\n\n\n\n        value = s->outputs & ~s->dir;\n\n        while ((ln = ffs(diff))) {\n\n            ln --;\n\n            if (s->handler[ln])\n\n                qemu_set_irq(s->handler[ln], (value >> ln) & 1);\n\n            diff &= ~(1 << ln);\n\n        }\n\n        break;\n\n\n\n    case 0x14:\t/* KBC_REG */\n\n        s->cols = value;\n\n        omap_mpuio_kbd_update(s);\n\n        break;\n\n\n\n    case 0x18:\t/* GPIO_EVENT_MODE_REG */\n\n        s->event = value & 0x1f;\n\n        break;\n\n\n\n    case 0x1c:\t/* GPIO_INT_EDGE_REG */\n\n        s->edge = value;\n\n        break;\n\n\n\n    case 0x28:\t/* KBD_MASKIT */\n\n        s->kbd_mask = value & 1;\n\n        omap_mpuio_kbd_update(s);\n\n        break;\n\n\n\n    case 0x2c:\t/* GPIO_MASKIT */\n\n        s->mask = value;\n\n        break;\n\n\n\n    case 0x30:\t/* GPIO_DEBOUNCING_REG */\n\n        s->debounce = value & 0x1ff;\n\n        break;\n\n\n\n    case 0x00:\t/* INPUT_LATCH */\n\n    case 0x10:\t/* KBR_LATCH */\n\n    case 0x20:\t/* KBD_INT */\n\n    case 0x24:\t/* GPIO_INT */\n\n    case 0x34:\t/* GPIO_LATCH_REG */\n\n        OMAP_RO_REG(addr);\n\n        return;\n\n\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n        return;\n\n    }\n\n}\n", "idx": 25238, "_split": "valid", "_hash": "0f1228b8c0ec8ef2597141075dcdc8f4"}
{"project": "qemu", "commit_id": "a308817743be5cc051d3379477f54027deb0befb", "target": 1, "func": "int net_init_tap(const NetClientOptions *opts, const char *name,\n\n                 NetClientState *peer, Error **errp)\n\n{\n\n    /* FIXME error_setg(errp, ...) on failure */\n\n    const NetdevTapOptions *tap;\n\n    int fd, vnet_hdr = 0, i = 0, queues;\n\n    /* for the no-fd, no-helper case */\n\n    const char *script = NULL; /* suppress wrong \"uninit'd use\" gcc warning */\n\n    const char *downscript = NULL;\n\n    Error *err = NULL;\n\n    const char *vhostfdname;\n\n    char ifname[128];\n\n\n\n    assert(opts->kind == NET_CLIENT_OPTIONS_KIND_TAP);\n\n    tap = opts->tap;\n\n    queues = tap->has_queues ? tap->queues : 1;\n\n    vhostfdname = tap->has_vhostfd ? tap->vhostfd : NULL;\n\n\n\n    /* QEMU vlans does not support multiqueue tap, in this case peer is set.\n\n     * For -netdev, peer is always NULL. */\n\n    if (peer && (tap->has_queues || tap->has_fds || tap->has_vhostfds)) {\n\n        error_report(\"Multiqueue tap cannot be used with QEMU vlans\");\n\n        return -1;\n\n    }\n\n\n\n    if (tap->has_fd) {\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n\n            tap->has_fds || tap->has_vhostfds) {\n\n            error_report(\"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                         \"helper=, queues=, fds=, and vhostfds= \"\n\n                         \"are invalid with fd=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = monitor_fd_param(cur_mon, tap->fd, &err);\n\n        if (fd == -1) {\n\n            error_report_err(err);\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"tap\", name, NULL,\n\n                         script, downscript,\n\n                         vhostfdname, vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_report_err(err);\n\n            return -1;\n\n        }\n\n    } else if (tap->has_fds) {\n\n        char *fds[MAX_TAP_QUEUES];\n\n        char *vhost_fds[MAX_TAP_QUEUES];\n\n        int nfds, nvhosts;\n\n\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n\n            tap->has_vhostfd) {\n\n            error_report(\"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                         \"helper=, queues=, and vhostfd= \"\n\n                         \"are invalid with fds=\");\n\n            return -1;\n\n        }\n\n\n\n        nfds = get_fds(tap->fds, fds, MAX_TAP_QUEUES);\n\n        if (tap->has_vhostfds) {\n\n            nvhosts = get_fds(tap->vhostfds, vhost_fds, MAX_TAP_QUEUES);\n\n            if (nfds != nvhosts) {\n\n                error_report(\"The number of fds passed does not match the \"\n\n                             \"number of vhostfds passed\");\n\n                return -1;\n\n            }\n\n        }\n\n\n\n        for (i = 0; i < nfds; i++) {\n\n            fd = monitor_fd_param(cur_mon, fds[i], &err);\n\n            if (fd == -1) {\n\n                error_report_err(err);\n\n                return -1;\n\n            }\n\n\n\n            fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n            if (i == 0) {\n\n                vnet_hdr = tap_probe_vnet_hdr(fd);\n\n            } else if (vnet_hdr != tap_probe_vnet_hdr(fd)) {\n\n                error_report(\"vnet_hdr not consistent across given tap fds\");\n\n                return -1;\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             script, downscript,\n\n                             tap->has_vhostfds ? vhost_fds[i] : NULL,\n\n                             vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_report_err(err);\n\n                return -1;\n\n            }\n\n        }\n\n    } else if (tap->has_helper) {\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_queues || tap->has_vhostfds) {\n\n            error_report(\"ifname=, script=, downscript=, and vnet_hdr= \"\n\n                         \"queues=, and vhostfds= are invalid with helper=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = net_bridge_run_helper(tap->helper, DEFAULT_BRIDGE_INTERFACE,\n\n                                   errp);\n\n        if (fd == -1) {\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"bridge\", name, ifname,\n\n                         script, downscript, vhostfdname,\n\n                         vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_report_err(err);\n\n            close(fd);\n\n            return -1;\n\n        }\n\n    } else {\n\n        if (tap->has_vhostfds) {\n\n            error_report(\"vhostfds= is invalid if fds= wasn't specified\");\n\n            return -1;\n\n        }\n\n        script = tap->has_script ? tap->script : DEFAULT_NETWORK_SCRIPT;\n\n        downscript = tap->has_downscript ? tap->downscript :\n\n            DEFAULT_NETWORK_DOWN_SCRIPT;\n\n\n\n        if (tap->has_ifname) {\n\n            pstrcpy(ifname, sizeof ifname, tap->ifname);\n\n        } else {\n\n            ifname[0] = '\\0';\n\n        }\n\n\n\n        for (i = 0; i < queues; i++) {\n\n            fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? \"no\" : script,\n\n                              ifname, sizeof ifname, queues > 1, &err);\n\n            if (fd == -1) {\n\n                error_report_err(err);\n\n                return -1;\n\n            }\n\n\n\n            if (queues > 1 && i == 0 && !tap->has_ifname) {\n\n                if (tap_fd_get_ifname(fd, ifname)) {\n\n                    error_report(\"Fail to get ifname\");\n\n                    close(fd);\n\n                    return -1;\n\n                }\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             i >= 1 ? \"no\" : script,\n\n                             i >= 1 ? \"no\" : downscript,\n\n                             vhostfdname, vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_report_err(err);\n\n                close(fd);\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25256, "_split": "valid", "_hash": "0097e3a0eb46e6f4d92647d6db82a7aa"}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static void proxy_rewinddir(FsContext *ctx, V9fsFidOpenState *fs)\n\n{\n\n    rewinddir(fs->dir);\n\n}\n", "idx": 25278, "_split": "valid", "_hash": "6d8434c6d421f0b3b524bd7efb2b51bf"}
{"project": "qemu", "commit_id": "7aff0f218cf623fbc4e2fe86c3ed8985ca3f2a9a", "target": 0, "func": "static int pci_ivshmem_init(PCIDevice *dev)\n\n{\n\n    IVShmemState *s = DO_UPCAST(IVShmemState, dev, dev);\n\n    uint8_t *pci_conf;\n\n\n\n    if (s->sizearg == NULL)\n\n        s->ivshmem_size = 4 << 20; /* 4 MB default */\n\n    else {\n\n        s->ivshmem_size = ivshmem_get_size(s);\n\n    }\n\n\n\n    register_savevm(&s->dev.qdev, \"ivshmem\", 0, 0, ivshmem_save, ivshmem_load,\n\n                                                                        dev);\n\n\n\n    /* IRQFD requires MSI */\n\n    if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) &&\n\n        !ivshmem_has_feature(s, IVSHMEM_MSI)) {\n\n        fprintf(stderr, \"ivshmem: ioeventfd/irqfd requires MSI\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* check that role is reasonable */\n\n    if (s->role) {\n\n        if (strncmp(s->role, \"peer\", 5) == 0) {\n\n            s->role_val = IVSHMEM_PEER;\n\n        } else if (strncmp(s->role, \"master\", 7) == 0) {\n\n            s->role_val = IVSHMEM_MASTER;\n\n        } else {\n\n            fprintf(stderr, \"ivshmem: 'role' must be 'peer' or 'master'\\n\");\n\n            exit(1);\n\n        }\n\n    } else {\n\n        s->role_val = IVSHMEM_MASTER; /* default */\n\n    }\n\n\n\n    if (s->role_val == IVSHMEM_PEER) {\n\n        register_device_unmigratable(&s->dev.qdev, \"ivshmem\", s);\n\n    }\n\n\n\n    pci_conf = s->dev.config;\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_REDHAT_QUMRANET);\n\n    pci_conf[0x02] = 0x10;\n\n    pci_conf[0x03] = 0x11;\n\n    pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;\n\n    pci_config_set_class(pci_conf, PCI_CLASS_MEMORY_RAM);\n\n    pci_conf[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL;\n\n\n\n    pci_config_set_interrupt_pin(pci_conf, 1);\n\n\n\n    s->shm_pci_addr = 0;\n\n    s->ivshmem_offset = 0;\n\n    s->shm_fd = 0;\n\n\n\n    s->ivshmem_mmio_io_addr = cpu_register_io_memory(ivshmem_mmio_read,\n\n                                    ivshmem_mmio_write, s, DEVICE_NATIVE_ENDIAN);\n\n    /* region for registers*/\n\n    pci_register_bar(&s->dev, 0, IVSHMEM_REG_BAR_SIZE,\n\n                           PCI_BASE_ADDRESS_SPACE_MEMORY, ivshmem_mmio_map);\n\n\n\n    if ((s->server_chr != NULL) &&\n\n                        (strncmp(s->server_chr->filename, \"unix:\", 5) == 0)) {\n\n        /* if we get a UNIX socket as the parameter we will talk\n\n         * to the ivshmem server to receive the memory region */\n\n\n\n        if (s->shmobj != NULL) {\n\n            fprintf(stderr, \"WARNING: do not specify both 'chardev' \"\n\n                                                \"and 'shm' with ivshmem\\n\");\n\n        }\n\n\n\n        IVSHMEM_DPRINTF(\"using shared memory server (socket = %s)\\n\",\n\n                                                    s->server_chr->filename);\n\n\n\n        if (ivshmem_has_feature(s, IVSHMEM_MSI)) {\n\n            ivshmem_setup_msi(s);\n\n        }\n\n\n\n        /* we allocate enough space for 16 guests and grow as needed */\n\n        s->nb_peers = 16;\n\n        s->vm_id = -1;\n\n\n\n        /* allocate/initialize space for interrupt handling */\n\n        s->peers = qemu_mallocz(s->nb_peers * sizeof(Peer));\n\n\n\n        pci_register_bar(&s->dev, 2, s->ivshmem_size,\n\n                                PCI_BASE_ADDRESS_SPACE_MEMORY, ivshmem_map);\n\n\n\n        s->eventfd_chr = qemu_mallocz(s->vectors * sizeof(CharDriverState *));\n\n\n\n        qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive, ivshmem_read,\n\n                     ivshmem_event, s);\n\n    } else {\n\n        /* just map the file immediately, we're not using a server */\n\n        int fd;\n\n\n\n        if (s->shmobj == NULL) {\n\n            fprintf(stderr, \"Must specify 'chardev' or 'shm' to ivshmem\\n\");\n\n        }\n\n\n\n        IVSHMEM_DPRINTF(\"using shm_open (shm object = %s)\\n\", s->shmobj);\n\n\n\n        /* try opening with O_EXCL and if it succeeds zero the memory\n\n         * by truncating to 0 */\n\n        if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL,\n\n                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {\n\n           /* truncate file to length PCI device's memory */\n\n            if (ftruncate(fd, s->ivshmem_size) != 0) {\n\n                fprintf(stderr, \"ivshmem: could not truncate shared file\\n\");\n\n            }\n\n\n\n        } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR,\n\n                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {\n\n            fprintf(stderr, \"ivshmem: could not open shared file\\n\");\n\n            exit(-1);\n\n\n\n        }\n\n\n\n        if (check_shm_size(s, fd) == -1) {\n\n            exit(-1);\n\n        }\n\n\n\n        create_shared_memory_BAR(s, fd);\n\n\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25280, "_split": "valid", "_hash": "99ff75c96361c7e326a9f5031ed82800"}
{"project": "qemu", "commit_id": "bec93d7283b635aabaf0bbff67b6da7fc99e020a", "target": 0, "func": "static void gen_compute_eflags_c(DisasContext *s, TCGv reg, bool inv)\n\n{\n\n    TCGv t0, t1;\n\n    int size;\n\n\n\n    switch (s->cc_op) {\n\n    case CC_OP_SUBB ... CC_OP_SUBQ:\n\n        /* (DATA_TYPE)(CC_DST + CC_SRC) < (DATA_TYPE)CC_SRC */\n\n        size = s->cc_op - CC_OP_SUBB;\n\n        t1 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, false);\n\n        /* If no temporary was used, be careful not to alias t1 and t0.  */\n\n        t0 = TCGV_EQUAL(t1, cpu_cc_src) ? cpu_tmp0 : reg;\n\n        tcg_gen_add_tl(t0, cpu_cc_dst, cpu_cc_src);\n\n        gen_extu(size, t0);\n\n        goto add_sub;\n\n\n\n    case CC_OP_ADDB ... CC_OP_ADDQ:\n\n        /* (DATA_TYPE)CC_DST < (DATA_TYPE)CC_SRC */\n\n        size = s->cc_op - CC_OP_ADDB;\n\n        t1 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, false);\n\n        t0 = gen_ext_tl(reg, cpu_cc_dst, size, false);\n\n    add_sub:\n\n        tcg_gen_setcond_tl(inv ? TCG_COND_GEU : TCG_COND_LTU, reg, t0, t1);\n\n        inv = false;\n\n        break;\n\n\n\n    case CC_OP_SBBB ... CC_OP_SBBQ:\n\n        /* (DATA_TYPE)(CC_DST + CC_SRC + 1) <= (DATA_TYPE)CC_SRC */\n\n        size = s->cc_op - CC_OP_SBBB;\n\n        t1 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, false);\n\n        if (TCGV_EQUAL(t1, reg) && TCGV_EQUAL(reg, cpu_cc_src)) {\n\n            tcg_gen_mov_tl(cpu_tmp0, cpu_cc_src);\n\n            t1 = cpu_tmp0;\n\n        }\n\n\n\n        tcg_gen_add_tl(reg, cpu_cc_dst, cpu_cc_src);\n\n        tcg_gen_addi_tl(reg, reg, 1);\n\n        gen_extu(size, reg);\n\n        t0 = reg;\n\n        goto adc_sbb;\n\n\n\n    case CC_OP_ADCB ... CC_OP_ADCQ:\n\n        /* (DATA_TYPE)CC_DST <= (DATA_TYPE)CC_SRC */\n\n        size = s->cc_op - CC_OP_ADCB;\n\n        t1 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, false);\n\n        t0 = gen_ext_tl(reg, cpu_cc_dst, size, false);\n\n    adc_sbb:\n\n        tcg_gen_setcond_tl(inv ? TCG_COND_GTU : TCG_COND_LEU, reg, t0, t1);\n\n        inv = false;\n\n        break;\n\n\n\n    case CC_OP_LOGICB ... CC_OP_LOGICQ:\n\n        tcg_gen_movi_tl(reg, 0);\n\n        break;\n\n\n\n    case CC_OP_INCB ... CC_OP_INCQ:\n\n    case CC_OP_DECB ... CC_OP_DECQ:\n\n        if (inv) {\n\n            tcg_gen_xori_tl(reg, cpu_cc_src, 1);\n\n        } else {\n\n            tcg_gen_mov_tl(reg, cpu_cc_src);\n\n        }\n\n        inv = false;\n\n        break;\n\n\n\n    case CC_OP_SHLB ... CC_OP_SHLQ:\n\n        /* (CC_SRC >> (DATA_BITS - 1)) & 1 */\n\n        size = s->cc_op - CC_OP_SHLB;\n\n        tcg_gen_shri_tl(reg, cpu_cc_src, (8 << size) - 1);\n\n        tcg_gen_andi_tl(reg, reg, 1);\n\n        break;\n\n\n\n    case CC_OP_MULB ... CC_OP_MULQ:\n\n        tcg_gen_setcondi_tl(inv ? TCG_COND_EQ : TCG_COND_NE,\n\n                            reg, cpu_cc_src, 0);\n\n        inv = false;\n\n        break;\n\n\n\n    case CC_OP_EFLAGS:\n\n    case CC_OP_SARB ... CC_OP_SARQ:\n\n        /* CC_SRC & 1 */\n\n        tcg_gen_andi_tl(reg, cpu_cc_src, 1);\n\n        break;\n\n\n\n    default:\n\n       /* The need to compute only C from CC_OP_DYNAMIC is important\n\n          in efficiently implementing e.g. INC at the start of a TB.  */\n\n       gen_update_cc_op(s);\n\n       gen_helper_cc_compute_c(cpu_tmp2_i32, cpu_env, cpu_cc_op);\n\n       tcg_gen_extu_i32_tl(reg, cpu_tmp2_i32);\n\n       break;\n\n    }\n\n    if (inv) {\n\n        tcg_gen_xori_tl(reg, reg, 1);\n\n    }\n\n}\n", "idx": 25324, "_split": "valid", "_hash": "ecb19cc300e168b9f78a167b2b97d0e5"}
{"project": "qemu", "commit_id": "3f66f764ee25f10d3e1144ebc057a949421b7728", "target": 0, "func": "static void test_struct(gconstpointer opaque)\n\n{\n\n    TestArgs *args = (TestArgs *) opaque;\n\n    const SerializeOps *ops = args->ops;\n\n    TestStruct *ts = struct_create();\n\n    TestStruct *ts_copy = NULL;\n\n    Error *err = NULL;\n\n    void *serialize_data;\n\n\n\n    ops->serialize(ts, &serialize_data, visit_struct, &err);\n\n    ops->deserialize((void **)&ts_copy, serialize_data, visit_struct, &err); \n\n\n\n    g_assert(err == NULL);\n\n    struct_compare(ts, ts_copy);\n\n\n\n    struct_cleanup(ts);\n\n    struct_cleanup(ts_copy);\n\n\n\n    ops->cleanup(serialize_data);\n\n    g_free(args);\n\n}\n", "idx": 25325, "_split": "valid", "_hash": "00e2b7f1f12845bfc37a64197ce6ab48"}
{"project": "qemu", "commit_id": "2fb50a33401a2415b71ddc291e8a77bcd2f9e547", "target": 0, "func": "static void set_irq_level(void *opaque, int n, int level)\n\n{\n\n    NVICState *s = opaque;\n\n    VecInfo *vec;\n\n\n\n    n += NVIC_FIRST_IRQ;\n\n\n\n    assert(n >= NVIC_FIRST_IRQ && n < s->num_irq);\n\n\n\n    trace_nvic_set_irq_level(n, level);\n\n\n\n    /* The pending status of an external interrupt is\n\n     * latched on rising edge and exception handler return.\n\n     *\n\n     * Pulsing the IRQ will always run the handler\n\n     * once, and the handler will re-run until the\n\n     * level is low when the handler completes.\n\n     */\n\n    vec = &s->vectors[n];\n\n    if (level != vec->level) {\n\n        vec->level = level;\n\n        if (level) {\n\n            armv7m_nvic_set_pending(s, n);\n\n        }\n\n    }\n\n}\n", "idx": 25363, "_split": "valid", "_hash": "fa0efd4db6125abc58edc8100f0fddf3"}
{"project": "qemu", "commit_id": "93b91c59dbccde6e4d25661150c1529bd5ee4a06", "target": 1, "func": "QObject *qmp_dispatch(QObject *request)\n\n{\n\n    Error *err = NULL;\n\n    QObject *ret;\n\n    QDict *rsp;\n\n\n\n    ret = do_qmp_dispatch(request, &err);\n\n\n\n    rsp = qdict_new();\n\n    if (err) {\n\n        qdict_put_obj(rsp, \"error\", error_get_qobject(err));\n\n        error_free(err);\n\n    } else if (ret) {\n\n        qdict_put_obj(rsp, \"return\", ret);\n\n    } else {\n\n        QDECREF(rsp);\n\n        return NULL;\n\n    }\n\n\n\n    return QOBJECT(rsp);\n\n}\n", "idx": 25388, "_split": "valid", "_hash": "e8dc5e2f3b9b0604b686c7544ac75403"}
{"project": "qemu", "commit_id": "e05ca8200216149008fa1b1d1d847bf16691f6b4", "target": 1, "func": "int vhost_dev_start(struct vhost_dev *hdev, VirtIODevice *vdev)\n\n{\n\n    int i, r;\n\n\n\n    hdev->started = true;\n\n\n\n    r = vhost_dev_set_features(hdev, hdev->log_enabled);\n\n    if (r < 0) {\n\n        goto fail_features;\n\n    }\n\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_MEM_TABLE, hdev->mem);\n\n    if (r < 0) {\n\n        r = -errno;\n\n        goto fail_mem;\n\n    }\n\n    for (i = 0; i < hdev->nvqs; ++i) {\n\n        r = vhost_virtqueue_start(hdev,\n\n                                  vdev,\n\n                                  hdev->vqs + i,\n\n                                  hdev->vq_index + i);\n\n        if (r < 0) {\n\n            goto fail_vq;\n\n        }\n\n    }\n\n\n\n    if (hdev->log_enabled) {\n\n        hdev->log_size = vhost_get_log_size(hdev);\n\n        hdev->log = hdev->log_size ?\n\n            g_malloc0(hdev->log_size * sizeof *hdev->log) : NULL;\n\n        r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_LOG_BASE, hdev->log);\n\n        if (r < 0) {\n\n            r = -errno;\n\n            goto fail_log;\n\n        }\n\n    }\n\n\n\n    return 0;\n\nfail_log:\n\nfail_vq:\n\n    while (--i >= 0) {\n\n        vhost_virtqueue_stop(hdev,\n\n                             vdev,\n\n                             hdev->vqs + i,\n\n                             hdev->vq_index + i);\n\n    }\n\n    i = hdev->nvqs;\n\nfail_mem:\n\nfail_features:\n\n\n\n    hdev->started = false;\n\n    return r;\n\n}\n", "idx": 25414, "_split": "valid", "_hash": "519929cc69c70403f32e955fbd9f8860"}
{"project": "qemu", "commit_id": "21b2f13ae21974e0fd7f8da99d84628a8000d1d7", "target": 1, "func": "static void mmubooke_dump_mmu(FILE *f, fprintf_function cpu_fprintf,\n\n                                 CPUPPCState *env)\n\n{\n\n    ppcemb_tlb_t *entry;\n\n    int i;\n\n\n\n    if (kvm_enabled() && !env->kvm_sw_tlb) {\n\n        cpu_fprintf(f, \"Cannot access KVM TLB\\n\");\n\n        return;\n\n    }\n\n\n\n    cpu_fprintf(f, \"\\nTLB:\\n\");\n\n    cpu_fprintf(f, \"Effective          Physical           Size PID   Prot     \"\n\n                \"Attr\\n\");\n\n\n\n    entry = &env->tlb.tlbe[0];\n\n    for (i = 0; i < env->nb_tlb; i++, entry++) {\n\n        hwaddr ea, pa;\n\n        target_ulong mask;\n\n        uint64_t size = (uint64_t)entry->size;\n\n        char size_buf[20];\n\n\n\n        /* Check valid flag */\n\n        if (!(entry->prot & PAGE_VALID)) {\n\n            continue;\n\n        }\n\n\n\n        mask = ~(entry->size - 1);\n\n        ea = entry->EPN & mask;\n\n        pa = entry->RPN & mask;\n\n#if (TARGET_PHYS_ADDR_SPACE_BITS >= 36)\n\n        /* Extend the physical address to 36 bits */\n\n        pa |= (hwaddr)(entry->RPN & 0xF) << 32;\n\n#endif\n\n        size /= 1024;\n\n        if (size >= 1024) {\n\n            snprintf(size_buf, sizeof(size_buf), \"%3\" PRId64 \"M\", size / 1024);\n\n        } else {\n\n            snprintf(size_buf, sizeof(size_buf), \"%3\" PRId64 \"k\", size);\n\n        }\n\n        cpu_fprintf(f, \"0x%016\" PRIx64 \" 0x%016\" PRIx64 \" %s %-5u %08x %08x\\n\",\n\n                    (uint64_t)ea, (uint64_t)pa, size_buf, (uint32_t)entry->PID,\n\n                    entry->prot, entry->attr);\n\n    }\n\n\n\n}\n", "idx": 25468, "_split": "valid", "_hash": "1a2cca6505638c3edade1376e13822a4"}
{"project": "qemu", "commit_id": "55a10996034cb2e633f0437cedd97f345183c0ec", "target": 1, "func": "InetSocketAddress *inet_parse(const char *str, Error **errp)\n\n{\n\n    InetSocketAddress *addr;\n\n    const char *optstr, *h;\n\n    char host[64];\n\n    char port[33];\n\n    int to;\n\n    int pos;\n\n\n\n    addr = g_new0(InetSocketAddress, 1);\n\n\n\n    /* parse address */\n\n    if (str[0] == ':') {\n\n        /* no host given */\n\n        host[0] = '\\0';\n\n        if (1 != sscanf(str, \":%32[^,]%n\", port, &pos)) {\n\n            error_setg(errp, \"error parsing port in address '%s'\", str);\n\n            goto fail;\n\n        }\n\n    } else if (str[0] == '[') {\n\n        /* IPv6 addr */\n\n        if (2 != sscanf(str, \"[%64[^]]]:%32[^,]%n\", host, port, &pos)) {\n\n            error_setg(errp, \"error parsing IPv6 address '%s'\", str);\n\n            goto fail;\n\n        }\n\n        addr->ipv6 = addr->has_ipv6 = true;\n\n    } else {\n\n        /* hostname or IPv4 addr */\n\n        if (2 != sscanf(str, \"%64[^:]:%32[^,]%n\", host, port, &pos)) {\n\n            error_setg(errp, \"error parsing address '%s'\", str);\n\n            goto fail;\n\n        }\n\n        if (host[strspn(host, \"0123456789.\")] == '\\0') {\n\n            addr->ipv4 = addr->has_ipv4 = true;\n\n        }\n\n    }\n\n\n\n    addr->host = g_strdup(host);\n\n    addr->port = g_strdup(port);\n\n\n\n    /* parse options */\n\n    optstr = str + pos;\n\n    h = strstr(optstr, \",to=\");\n\n    if (h) {\n\n        h += 4;\n\n        if (sscanf(h, \"%d%n\", &to, &pos) != 1 ||\n\n            (h[pos] != '\\0' && h[pos] != ',')) {\n\n            error_setg(errp, \"error parsing to= argument\");\n\n            goto fail;\n\n        }\n\n        addr->has_to = true;\n\n        addr->to = to;\n\n    }\n\n    if (strstr(optstr, \",ipv4\")) {\n\n        addr->ipv4 = addr->has_ipv4 = true;\n\n    }\n\n    if (strstr(optstr, \",ipv6\")) {\n\n        addr->ipv6 = addr->has_ipv6 = true;\n\n    }\n\n    return addr;\n\n\n\nfail:\n\n    qapi_free_InetSocketAddress(addr);\n\n    return NULL;\n\n}\n", "idx": 25494, "_split": "valid", "_hash": "de8579011d9341986e99768769925cc8"}
{"project": "qemu", "commit_id": "967b75230b9720ea2b3ae49f38f8287026125f9f", "target": 1, "func": "static void pnv_chip_power9_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PnvChipClass *k = PNV_CHIP_CLASS(klass);\n\n\n\n    k->cpu_model = \"POWER9\";\n\n    k->chip_type = PNV_CHIP_POWER9;\n\n    k->chip_cfam_id = 0x100d104980000000ull; /* P9 Nimbus DD1.0 */\n\n    k->cores_mask = POWER9_CORE_MASK;\n\n    k->core_pir = pnv_chip_core_pir_p9;\n\n\n    dc->desc = \"PowerNV Chip POWER9\";\n\n}", "idx": 25498, "_split": "valid", "_hash": "050a4b4912daa59fa3f1daac4542f8f6"}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void omap_rfbi_transfer_start(struct omap_dss_s *s)\n\n{\n\n    void *data;\n\n    hwaddr len;\n\n    hwaddr data_addr;\n\n    int pitch;\n\n    static void *bounce_buffer;\n\n    static hwaddr bounce_len;\n\n\n\n    if (!s->rfbi.enable || s->rfbi.busy)\n\n        return;\n\n\n\n    if (s->rfbi.control & (1 << 1)) {\t\t\t\t/* BYPASS */\n\n        /* TODO: in non-Bypass mode we probably need to just assert the\n\n         * DRQ and wait for DMA to write the pixels.  */\n\n        fprintf(stderr, \"%s: Bypass mode unimplemented\\n\", __FUNCTION__);\n\n        return;\n\n    }\n\n\n\n    if (!(s->dispc.control & (1 << 11)))\t\t\t/* RFBIMODE */\n\n        return;\n\n    /* TODO: check that LCD output is enabled in DISPC.  */\n\n\n\n    s->rfbi.busy = 1;\n\n\n\n    len = s->rfbi.pixels * 2;\n\n\n\n    data_addr = s->dispc.l[0].addr[0];\n\n    data = cpu_physical_memory_map(data_addr, &len, 0);\n\n    if (data && len != s->rfbi.pixels * 2) {\n\n        cpu_physical_memory_unmap(data, len, 0, 0);\n\n        data = NULL;\n\n        len = s->rfbi.pixels * 2;\n\n    }\n\n    if (!data) {\n\n        if (len > bounce_len) {\n\n            bounce_buffer = g_realloc(bounce_buffer, len);\n\n        }\n\n        data = bounce_buffer;\n\n        cpu_physical_memory_read(data_addr, data, len);\n\n    }\n\n\n\n    /* TODO bpp */\n\n    s->rfbi.pixels = 0;\n\n\n\n    /* TODO: negative values */\n\n    pitch = s->dispc.l[0].nx + (s->dispc.l[0].rowinc - 1) / 2;\n\n\n\n    if ((s->rfbi.control & (1 << 2)) && s->rfbi.chip[0])\n\n        s->rfbi.chip[0]->block(s->rfbi.chip[0]->opaque, 1, data, len, pitch);\n\n    if ((s->rfbi.control & (1 << 3)) && s->rfbi.chip[1])\n\n        s->rfbi.chip[1]->block(s->rfbi.chip[1]->opaque, 1, data, len, pitch);\n\n\n\n    if (data != bounce_buffer) {\n\n        cpu_physical_memory_unmap(data, len, 0, len);\n\n    }\n\n\n\n    omap_rfbi_transfer_stop(s);\n\n\n\n    /* TODO */\n\n    s->dispc.irqst |= 1;\t\t\t\t\t/* FRAMEDONE */\n\n    omap_dispc_interrupt_update(s);\n\n}\n", "idx": 25506, "_split": "valid", "_hash": "c678a15923f718fb61b043b84a292422"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,\n\n                          unsigned npfd, int64_t timeout)\n\n{\n\n    return false;\n\n}\n", "idx": 25519, "_split": "valid", "_hash": "d32d9cbe020cc60eabc6d6c0d4f8b2e4"}
{"project": "qemu", "commit_id": "53724ee565565f69560dbe17553bede8c0169379", "target": 0, "func": "void spapr_tce_reset(DMAContext *dma)\n\n{\n\n    if (dma) {\n\n        sPAPRTCETable *tcet = DO_UPCAST(sPAPRTCETable, dma, dma);\n\n        size_t table_size = (tcet->window_size >> SPAPR_TCE_PAGE_SHIFT)\n\n            * sizeof(sPAPRTCE);\n\n\n\n        memset(tcet->table, 0, table_size);\n\n    }\n\n}\n", "idx": 25551, "_split": "valid", "_hash": "04ca43d01d88bb673b5fe1ca643c80b6"}
{"project": "qemu", "commit_id": "7f0317cfc8da620cdb38cb5cfec5f82b8dd05403", "target": 1, "func": "static void mirror_start_job(BlockDriverState *bs, BlockDriverState *target,\n\n                             const char *replaces,\n\n                             int64_t speed, uint32_t granularity,\n\n                             int64_t buf_size,\n\n                             BlockMirrorBackingMode backing_mode,\n\n                             BlockdevOnError on_source_error,\n\n                             BlockdevOnError on_target_error,\n\n                             bool unmap,\n\n                             BlockCompletionFunc *cb,\n\n                             void *opaque, Error **errp,\n\n                             const BlockJobDriver *driver,\n\n                             bool is_none_mode, BlockDriverState *base)\n\n{\n\n    MirrorBlockJob *s;\n\n\n\n    if (granularity == 0) {\n\n        granularity = bdrv_get_default_bitmap_granularity(target);\n\n    }\n\n\n\n    assert ((granularity & (granularity - 1)) == 0);\n\n\n\n    if (buf_size < 0) {\n\n        error_setg(errp, \"Invalid parameter 'buf-size'\");\n\n        return;\n\n    }\n\n\n\n    if (buf_size == 0) {\n\n        buf_size = DEFAULT_MIRROR_BUF_SIZE;\n\n    }\n\n\n\n    s = block_job_create(driver, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->target = blk_new();\n\n    blk_insert_bs(s->target, target);\n\n\n\n    s->replaces = g_strdup(replaces);\n\n    s->on_source_error = on_source_error;\n\n    s->on_target_error = on_target_error;\n\n    s->is_none_mode = is_none_mode;\n\n    s->backing_mode = backing_mode;\n\n    s->base = base;\n\n    s->granularity = granularity;\n\n    s->buf_size = ROUND_UP(buf_size, granularity);\n\n    s->unmap = unmap;\n\n\n\n    s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp);\n\n    if (!s->dirty_bitmap) {\n\n        g_free(s->replaces);\n\n        blk_unref(s->target);\n\n        block_job_unref(&s->common);\n\n        return;\n\n    }\n\n\n\n    bdrv_op_block_all(target, s->common.blocker);\n\n\n\n    s->common.co = qemu_coroutine_create(mirror_run);\n\n    trace_mirror_start(bs, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}\n", "idx": 25555, "_split": "valid", "_hash": "41afc08b40b4e7e9e56de583681274d4"}
{"project": "qemu", "commit_id": "90e496386fe7fd32c189561f846b7913f95b8cf4", "target": 0, "func": "static inline int fp_reg_hi_offset(int regno)\n\n{\n\n    return offsetof(CPUARMState, vfp.regs[regno * 2 + 1]);\n\n}\n", "idx": 25570, "_split": "valid", "_hash": "3b12ba6cfc3d6b39cc0f67c7f6a86d8e"}
{"project": "qemu", "commit_id": "7466bc49107fbd84336ba680f860d5eadd6def13", "target": 0, "func": "void qemu_spice_display_init(DisplayState *ds)\n\n{\n\n    assert(sdpy.ds == NULL);\n\n    sdpy.ds = ds;\n\n    sdpy.bufsize = (16 * 1024 * 1024);\n\n    sdpy.buf = qemu_malloc(sdpy.bufsize);\n\n    pthread_mutex_init(&sdpy.lock, NULL);\n\n    register_displaychangelistener(ds, &display_listener);\n\n\n\n    sdpy.qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_interface(&sdpy.qxl.base);\n\n    assert(sdpy.worker);\n\n\n\n    qemu_add_vm_change_state_handler(qemu_spice_vm_change_state_handler, &sdpy);\n\n    qemu_spice_create_host_memslot(&sdpy);\n\n    qemu_spice_create_host_primary(&sdpy);\n\n}\n", "idx": 25576, "_split": "valid", "_hash": "d18dc95854e1550bf8b2b379cb2780f8"}
{"project": "qemu", "commit_id": "b7bad50ae81efeb180609eeecdb086ebc7536ed7", "target": 0, "func": "static void cryptodev_builtin_cleanup(\n\n             CryptoDevBackend *backend,\n\n             Error **errp)\n\n{\n\n    CryptoDevBackendBuiltin *builtin =\n\n                      CRYPTODEV_BACKEND_BUILTIN(backend);\n\n    size_t i;\n\n    int queues = backend->conf.peers.queues;\n\n    CryptoDevBackendClient *cc;\n\n\n\n    for (i = 0; i < MAX_NUM_SESSIONS; i++) {\n\n        if (builtin->sessions[i] != NULL) {\n\n            cryptodev_builtin_sym_close_session(\n\n                    backend, i, 0, errp);\n\n        }\n\n    }\n\n\n\n    assert(queues == 1);\n\n\n\n    for (i = 0; i < queues; i++) {\n\n        cc = backend->conf.peers.ccs[i];\n\n        if (cc) {\n\n            cryptodev_backend_free_client(cc);\n\n            backend->conf.peers.ccs[i] = NULL;\n\n        }\n\n    }\n\n\n\n    cryptodev_backend_set_ready(backend, false);\n\n}\n", "idx": 25585, "_split": "valid", "_hash": "c020a519abcb71d93d0a7c8bfd7df6ca"}
{"project": "qemu", "commit_id": "ce137829e7e58fcdc5ba63b5e256f972e80be438", "target": 1, "func": "static void clear_commits(BDRVVVFATState* s)\n\n{\n\n    int i;\n\nDLOG(fprintf(stderr, \"clear_commits (%d commits)\\n\", s->commits.next));\n\n    for (i = 0; i < s->commits.next; i++) {\n\n\tcommit_t* commit = array_get(&(s->commits), i);\n\n\tassert(commit->path || commit->action == ACTION_WRITEOUT);\n\n\tif (commit->action != ACTION_WRITEOUT) {\n\n\t    assert(commit->path);\n\n\t    free(commit->path);\n\n\t} else\n\n\t    assert(commit->path == NULL);\n\n    }\n\n    s->commits.next = 0;\n\n}\n", "idx": 25586, "_split": "valid", "_hash": "0f3f1a3bb75e02fcbbfc9f7307d72dec"}
{"project": "qemu", "commit_id": "c527e0afcd7d719abc3a5ca5e4c8ac2fe48b999f", "target": 1, "func": "vmxnet3_dump_rx_descr(struct Vmxnet3_RxDesc *descr)\n\n{\n\n    VMW_PKPRN(\"RX DESCR: addr %\" PRIx64 \", len: %d, gen: %d, rsvd: %d, \"\n\n              \"dtype: %d, ext1: %d, btype: %d\",\n\n              le64_to_cpu(descr->addr), descr->len, descr->gen,\n\n              descr->rsvd, descr->dtype, descr->ext1, descr->btype);\n\n}\n", "idx": 25600, "_split": "valid", "_hash": "7ebb59db8a8c20fb58c28aba11a12bbb"}
{"project": "qemu", "commit_id": "2ffcb18de0bc02ad8a836ec955584c02b70e0e24", "target": 0, "func": "int do_netdev_del(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    const char *id = qdict_get_str(qdict, \"id\");\n\n    VLANClientState *vc;\n\n\n\n    vc = qemu_find_netdev(id);\n\n    if (!vc || vc->info->type == NET_CLIENT_TYPE_NIC) {\n\n        qerror_report(QERR_DEVICE_NOT_FOUND, id);\n\n        return -1;\n\n    }\n\n    if (vc->peer) {\n\n        qerror_report(QERR_DEVICE_IN_USE, id);\n\n        return -1;\n\n    }\n\n    qemu_del_vlan_client(vc);\n\n    qemu_opts_del(qemu_opts_find(&qemu_netdev_opts, id));\n\n    return 0;\n\n}\n", "idx": 25622, "_split": "valid", "_hash": "d25be1b218e51bbfa2004c81f5959395"}
{"project": "qemu", "commit_id": "59b060be184aff59cfa101c937c8139e66f452f2", "target": 0, "func": "int qcrypto_pbkdf2(QCryptoHashAlgorithm hash G_GNUC_UNUSED,\n\n                   const uint8_t *key G_GNUC_UNUSED,\n\n                   size_t nkey G_GNUC_UNUSED,\n\n                   const uint8_t *salt G_GNUC_UNUSED,\n\n                   size_t nsalt G_GNUC_UNUSED,\n\n                   unsigned int iterations G_GNUC_UNUSED,\n\n                   uint8_t *out G_GNUC_UNUSED,\n\n                   size_t nout G_GNUC_UNUSED,\n\n                   Error **errp)\n\n{\n\n    error_setg_errno(errp, ENOSYS,\n\n                     \"No crypto library supporting PBKDF in this build\");\n\n    return -1;\n\n}\n", "idx": 25624, "_split": "valid", "_hash": "13cb779fe8f2e8dd861bd74e14a05e6b"}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static void qmp_chardev_open_socket(Chardev *chr,\n\n                                    ChardevBackend *backend,\n\n                                    bool *be_opened,\n\n                                    Error **errp)\n\n{\n\n    SocketChardev *s = SOCKET_CHARDEV(chr);\n\n    ChardevSocket *sock = backend->u.socket.data;\n\n    SocketAddress *addr = sock->addr;\n\n    bool do_nodelay     = sock->has_nodelay ? sock->nodelay : false;\n\n    bool is_listen      = sock->has_server  ? sock->server  : true;\n\n    bool is_telnet      = sock->has_telnet  ? sock->telnet  : false;\n\n    bool is_tn3270      = sock->has_tn3270  ? sock->tn3270  : false;\n\n    bool is_waitconnect = sock->has_wait    ? sock->wait    : false;\n\n    int64_t reconnect   = sock->has_reconnect ? sock->reconnect : 0;\n\n    QIOChannelSocket *sioc = NULL;\n\n\n\n    s->is_listen = is_listen;\n\n    s->is_telnet = is_telnet;\n\n    s->is_tn3270 = is_tn3270;\n\n    s->do_nodelay = do_nodelay;\n\n    if (sock->tls_creds) {\n\n        Object *creds;\n\n        creds = object_resolve_path_component(\n\n            object_get_objects_root(), sock->tls_creds);\n\n        if (!creds) {\n\n            error_setg(errp, \"No TLS credentials with id '%s'\",\n\n                       sock->tls_creds);\n\n            goto error;\n\n        }\n\n        s->tls_creds = (QCryptoTLSCreds *)\n\n            object_dynamic_cast(creds,\n\n                                TYPE_QCRYPTO_TLS_CREDS);\n\n        if (!s->tls_creds) {\n\n            error_setg(errp, \"Object with id '%s' is not TLS credentials\",\n\n                       sock->tls_creds);\n\n            goto error;\n\n        }\n\n        object_ref(OBJECT(s->tls_creds));\n\n        if (is_listen) {\n\n            if (s->tls_creds->endpoint != QCRYPTO_TLS_CREDS_ENDPOINT_SERVER) {\n\n                error_setg(errp, \"%s\",\n\n                           \"Expected TLS credentials for server endpoint\");\n\n                goto error;\n\n            }\n\n        } else {\n\n            if (s->tls_creds->endpoint != QCRYPTO_TLS_CREDS_ENDPOINT_CLIENT) {\n\n                error_setg(errp, \"%s\",\n\n                           \"Expected TLS credentials for client endpoint\");\n\n                goto error;\n\n            }\n\n        }\n\n    }\n\n\n\n    s->addr = QAPI_CLONE(SocketAddress, sock->addr);\n\n\n\n    qemu_chr_set_feature(chr, QEMU_CHAR_FEATURE_RECONNECTABLE);\n\n    /* TODO SOCKET_ADDRESS_FD where fd has AF_UNIX */\n\n    if (addr->type == SOCKET_ADDRESS_KIND_UNIX) {\n\n        qemu_chr_set_feature(chr, QEMU_CHAR_FEATURE_FD_PASS);\n\n    }\n\n\n\n    /* be isn't opened until we get a connection */\n\n    *be_opened = false;\n\n\n\n    update_disconnected_filename(s);\n\n\n\n    if (is_listen) {\n\n        if (is_telnet || is_tn3270) {\n\n            s->do_telnetopt = 1;\n\n        }\n\n    } else if (reconnect > 0) {\n\n        s->reconnect_time = reconnect;\n\n    }\n\n\n\n    if (s->reconnect_time) {\n\n        sioc = qio_channel_socket_new();\n\n        tcp_chr_set_client_ioc_name(chr, sioc);\n\n        qio_channel_socket_connect_async(sioc, s->addr,\n\n                                         qemu_chr_socket_connected,\n\n                                         chr, NULL);\n\n    } else {\n\n        if (s->is_listen) {\n\n            char *name;\n\n            sioc = qio_channel_socket_new();\n\n\n\n            name = g_strdup_printf(\"chardev-tcp-listener-%s\", chr->label);\n\n            qio_channel_set_name(QIO_CHANNEL(sioc), name);\n\n            g_free(name);\n\n\n\n            if (qio_channel_socket_listen_sync(sioc, s->addr, errp) < 0) {\n\n                goto error;\n\n            }\n\n\n\n            qapi_free_SocketAddress(s->addr);\n\n            s->addr = socket_local_address(sioc->fd, errp);\n\n            update_disconnected_filename(s);\n\n\n\n            s->listen_ioc = sioc;\n\n            if (is_waitconnect &&\n\n                qemu_chr_wait_connected(chr, errp) < 0) {\n\n                return;\n\n            }\n\n            if (!s->ioc) {\n\n                s->listen_tag = qio_channel_add_watch(\n\n                    QIO_CHANNEL(s->listen_ioc), G_IO_IN,\n\n                    tcp_chr_accept, chr, NULL);\n\n            }\n\n        } else if (qemu_chr_wait_connected(chr, errp) < 0) {\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    return;\n\n\n\nerror:\n\n    if (sioc) {\n\n        object_unref(OBJECT(sioc));\n\n    }\n\n}\n", "idx": 25625, "_split": "valid", "_hash": "64f6bf61897888ff7a1c2cf25d94b2fb"}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static inline void vmxnet3_ring_read_curr_cell(Vmxnet3Ring *ring, void *buff)\n\n{\n\n    vmw_shmem_read(vmxnet3_ring_curr_cell_pa(ring), buff, ring->cell_size);\n\n}\n", "idx": 25676, "_split": "valid", "_hash": "f1682a275df7524f297eaf9b4d901ee2"}
{"project": "qemu", "commit_id": "456d60692310e7ac25cf822cc1e98192ad636ece", "target": 1, "func": "static CharDriverState* create_eventfd_chr_device(void * opaque, EventNotifier *n,\n\n                                                  int vector)\n\n{\n\n    /* create a event character device based on the passed eventfd */\n\n    IVShmemState *s = opaque;\n\n    CharDriverState * chr;\n\n    int eventfd = event_notifier_get_fd(n);\n\n\n\n    chr = qemu_chr_open_eventfd(eventfd);\n\n\n\n    if (chr == NULL) {\n\n        fprintf(stderr, \"creating eventfd for eventfd %d failed\\n\", eventfd);\n\n        exit(-1);\n\n    }\n\n\n\n\n    /* if MSI is supported we need multiple interrupts */\n\n    if (ivshmem_has_feature(s, IVSHMEM_MSI)) {\n\n        s->eventfd_table[vector].pdev = &s->dev;\n\n        s->eventfd_table[vector].vector = vector;\n\n\n\n        qemu_chr_add_handlers(chr, ivshmem_can_receive, fake_irqfd,\n\n                      ivshmem_event, &s->eventfd_table[vector]);\n\n    } else {\n\n        qemu_chr_add_handlers(chr, ivshmem_can_receive, ivshmem_receive,\n\n                      ivshmem_event, s);\n\n    }\n\n\n\n    return chr;\n\n\n\n}", "idx": 25682, "_split": "valid", "_hash": "e0326dfd8ce0db1f69432250c97b973d"}
{"project": "qemu", "commit_id": "3a3b8502e6f0c8d30865c5f36d2c3ae4114000b5", "target": 1, "func": "static void xics_realize(DeviceState *dev, Error **errp)\n\n{\n\n    XICSState *icp = XICS(dev);\n\n    Error *error = NULL;\n\n    int i;\n\n\n\n    if (!icp->nr_servers) {\n\n        error_setg(errp, \"Number of servers needs to be greater 0\");\n\n        return;\n\n    }\n\n\n\n    /* Registration of global state belongs into realize */\n\n    spapr_rtas_register(\"ibm,set-xive\", rtas_set_xive);\n\n    spapr_rtas_register(\"ibm,get-xive\", rtas_get_xive);\n\n    spapr_rtas_register(\"ibm,int-off\", rtas_int_off);\n\n    spapr_rtas_register(\"ibm,int-on\", rtas_int_on);\n\n\n\n    spapr_register_hypercall(H_CPPR, h_cppr);\n\n    spapr_register_hypercall(H_IPI, h_ipi);\n\n    spapr_register_hypercall(H_XIRR, h_xirr);\n\n    spapr_register_hypercall(H_XIRR_X, h_xirr_x);\n\n    spapr_register_hypercall(H_EOI, h_eoi);\n\n    spapr_register_hypercall(H_IPOLL, h_ipoll);\n\n\n\n    object_property_set_bool(OBJECT(icp->ics), true, \"realized\", &error);\n\n    if (error) {\n\n        error_propagate(errp, error);\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < icp->nr_servers; i++) {\n\n        object_property_set_bool(OBJECT(&icp->ss[i]), true, \"realized\", &error);\n\n        if (error) {\n\n            error_propagate(errp, error);\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 25686, "_split": "valid", "_hash": "7a8c6220e0db00639e824804123dd8d9"}
{"project": "qemu", "commit_id": "fae69416294223d84db425e58e7bbf6a08c45801", "target": 1, "func": "int nbd_trip(BlockDriverState *bs, int csock, off_t size,\n\n             uint64_t dev_offset, uint32_t nbdflags,\n\n             uint8_t *data)\n\n{\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    int ret;\n\n\n\n    TRACE(\"Reading request.\");\n\n\n\n    if (nbd_receive_request(csock, &request) == -1)\n\n        return -1;\n\n\n\n    if (request.len > NBD_BUFFER_SIZE) {\n\n        LOG(\"len (%u) is larger than max len (%u)\",\n\n            request.len, NBD_BUFFER_SIZE);\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    if ((request.from + request.len) < request.from) {\n\n        LOG(\"integer overflow detected! \"\n\n            \"you're probably being attacked\");\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    if ((request.from + request.len) > size) {\n\n            LOG(\"From: %\" PRIu64 \", Len: %u, Size: %\" PRIu64\n\n            \", Offset: %\" PRIu64 \"\\n\",\n\n                    request.from, request.len, (uint64_t)size, dev_offset);\n\n        LOG(\"requested operation past EOF--bad client?\");\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    TRACE(\"Decoding type\");\n\n\n\n    reply.handle = request.handle;\n\n    reply.error = 0;\n\n\n\n    switch (request.type & NBD_CMD_MASK_COMMAND) {\n\n    case NBD_CMD_READ:\n\n        TRACE(\"Request type is READ\");\n\n\n\n        ret = bdrv_read(bs, (request.from + dev_offset) / 512,\n\n                        data, request.len / 512);\n\n        if (ret < 0) {\n\n            LOG(\"reading from file failed\");\n\n            reply.error = -ret;\n\n            request.len = 0;\n\n        }\n\n\n\n        TRACE(\"Read %u byte(s)\", request.len);\n\n        if (nbd_do_send_reply(csock, &reply, data, request.len) < 0)\n\n            return -1;\n\n        break;\n\n    case NBD_CMD_WRITE:\n\n        TRACE(\"Request type is WRITE\");\n\n\n\n        TRACE(\"Reading %u byte(s)\", request.len);\n\n\n\n        if (read_sync(csock, data, request.len) != request.len) {\n\n            LOG(\"reading from socket failed\");\n\n            errno = EINVAL;\n\n            return -1;\n\n        }\n\n\n\n        if (nbdflags & NBD_FLAG_READ_ONLY) {\n\n            TRACE(\"Server is read-only, return error\");\n\n            reply.error = 1;\n\n        } else {\n\n            TRACE(\"Writing to device\");\n\n\n\n            ret = bdrv_write(bs, (request.from + dev_offset) / 512,\n\n                             data, request.len / 512);\n\n            if (ret < 0) {\n\n                LOG(\"writing to file failed\");\n\n                reply.error = -ret;\n\n                request.len = 0;\n\n            }\n\n\n\n            if (request.type & NBD_CMD_FLAG_FUA) {\n\n                ret = bdrv_flush(bs);\n\n                if (ret < 0) {\n\n                    LOG(\"flush failed\");\n\n                    reply.error = -ret;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (nbd_do_send_reply(csock, &reply, NULL, 0) < 0)\n\n            return -1;\n\n        break;\n\n    case NBD_CMD_DISC:\n\n        TRACE(\"Request type is DISCONNECT\");\n\n        errno = 0;\n\n        return 1;\n\n    case NBD_CMD_FLUSH:\n\n        TRACE(\"Request type is FLUSH\");\n\n\n\n        ret = bdrv_flush(bs);\n\n        if (ret < 0) {\n\n            LOG(\"flush failed\");\n\n            reply.error = -ret;\n\n        }\n\n\n\n        if (nbd_do_send_reply(csock, &reply, NULL, 0) < 0)\n\n            return -1;\n\n        break;\n\n    case NBD_CMD_TRIM:\n\n        TRACE(\"Request type is TRIM\");\n\n        ret = bdrv_discard(bs, (request.from + dev_offset) / 512,\n\n                           request.len / 512);\n\n        if (ret < 0) {\n\n            LOG(\"discard failed\");\n\n            reply.error = -ret;\n\n        }\n\n        if (nbd_do_send_reply(csock, &reply, NULL, 0) < 0)\n\n            return -1;\n\n        break;\n\n    default:\n\n        LOG(\"invalid request type (%u) received\", request.type);\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    TRACE(\"Request/Reply complete\");\n\n\n\n    return 0;\n\n}\n", "idx": 25687, "_split": "valid", "_hash": "3985e1aa535bf8ec91a3ee4492392e4f"}
{"project": "qemu", "commit_id": "428c3ece97179557f2753071fb0ca97a03437267", "target": 0, "func": "static bool msi_is_masked(const PCIDevice *dev, unsigned int vector)\n\n{\n\n    uint16_t flags = pci_get_word(dev->config + msi_flags_off(dev));\n\n    uint32_t mask;\n\n    assert(vector < PCI_MSI_VECTORS_MAX);\n\n\n\n    if (!(flags & PCI_MSI_FLAGS_MASKBIT)) {\n\n        return false;\n\n    }\n\n\n\n    mask = pci_get_long(dev->config +\n\n                        msi_mask_off(dev, flags & PCI_MSI_FLAGS_64BIT));\n\n    return mask & (1U << vector);\n\n}\n", "idx": 25706, "_split": "valid", "_hash": "be0b6d6efeca01e78c1af25c31ff29d0"}
{"project": "qemu", "commit_id": "9359a58b122187964d7465d48165680eadbf69d3", "target": 0, "func": "static void ehci_opreg_write(void *ptr, hwaddr addr,\n\n                             uint64_t val, unsigned size)\n\n{\n\n    EHCIState *s = ptr;\n\n    uint32_t *mmio = s->opreg + (addr >> 2);\n\n    uint32_t old = *mmio;\n\n    int i;\n\n\n\n    trace_usb_ehci_opreg_write(addr + s->opregbase, addr2str(addr), val);\n\n\n\n    switch (addr) {\n\n    case USBCMD:\n\n        if (val & USBCMD_HCRESET) {\n\n            ehci_reset(s);\n\n            val = s->usbcmd;\n\n            break;\n\n        }\n\n\n\n        /* not supporting dynamic frame list size at the moment */\n\n        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {\n\n            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",\n\n                    (int)val & USBCMD_FLS);\n\n            val &= ~USBCMD_FLS;\n\n        }\n\n\n\n        if (val & USBCMD_IAAD) {\n\n            /*\n\n             * Process IAAD immediately, otherwise the Linux IAAD watchdog may\n\n             * trigger and re-use a qh without us seeing the unlink.\n\n             */\n\n            s->async_stepdown = 0;\n\n            qemu_bh_schedule(s->async_bh);\n\n            trace_usb_ehci_doorbell_ring();\n\n        }\n\n\n\n        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=\n\n            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {\n\n            if (s->pstate == EST_INACTIVE) {\n\n                SET_LAST_RUN_CLOCK(s);\n\n            }\n\n            s->usbcmd = val; /* Set usbcmd for ehci_update_halt() */\n\n            ehci_update_halt(s);\n\n            s->async_stepdown = 0;\n\n            qemu_bh_schedule(s->async_bh);\n\n        }\n\n        break;\n\n\n\n    case USBSTS:\n\n        val &= USBSTS_RO_MASK;              // bits 6 through 31 are RO\n\n        ehci_clear_usbsts(s, val);          // bits 0 through 5 are R/WC\n\n        val = s->usbsts;\n\n        ehci_update_irq(s);\n\n        break;\n\n\n\n    case USBINTR:\n\n        val &= USBINTR_MASK;\n\n        if (ehci_enabled(s) && (USBSTS_FLR & val)) {\n\n            qemu_bh_schedule(s->async_bh);\n\n        }\n\n        break;\n\n\n\n    case FRINDEX:\n\n        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */\n\n        break;\n\n\n\n    case CONFIGFLAG:\n\n        val &= 0x1;\n\n        if (val) {\n\n            for(i = 0; i < NB_PORTS; i++)\n\n                handle_port_owner_write(s, i, 0);\n\n        }\n\n        break;\n\n\n\n    case PERIODICLISTBASE:\n\n        if (ehci_periodic_enabled(s)) {\n\n            fprintf(stderr,\n\n              \"ehci: PERIODIC list base register set while periodic schedule\\n\"\n\n              \"      is enabled and HC is enabled\\n\");\n\n        }\n\n        break;\n\n\n\n    case ASYNCLISTADDR:\n\n        if (ehci_async_enabled(s)) {\n\n            fprintf(stderr,\n\n              \"ehci: ASYNC list address register set while async schedule\\n\"\n\n              \"      is enabled and HC is enabled\\n\");\n\n        }\n\n        break;\n\n    }\n\n\n\n    *mmio = val;\n\n    trace_usb_ehci_opreg_change(addr + s->opregbase, addr2str(addr),\n\n                                *mmio, old);\n\n}\n", "idx": 25710, "_split": "valid", "_hash": "646043fbba2d756608c66d89643f6be9"}
{"project": "qemu", "commit_id": "ba5e6bfa1aee29a8f72c5538c565dfb9889cf273", "target": 0, "func": "static void vfio_bar_quirk_teardown(VFIOPCIDevice *vdev, int nr)\n\n{\n\n    VFIOBAR *bar = &vdev->bars[nr];\n\n\n\n    while (!QLIST_EMPTY(&bar->quirks)) {\n\n        VFIOQuirk *quirk = QLIST_FIRST(&bar->quirks);\n\n        memory_region_del_subregion(&bar->region.mem, &quirk->mem);\n\n        object_unparent(OBJECT(&quirk->mem));\n\n        QLIST_REMOVE(quirk, next);\n\n        g_free(quirk);\n\n    }\n\n}\n", "idx": 25713, "_split": "valid", "_hash": "c32eb885d28064fa7703576d1660e717"}
{"project": "qemu", "commit_id": "eaf944a43835399f12808aebd0d0a1db6249ed07", "target": 1, "func": "static int blkdebug_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    const char *config;\n\n    uint64_t align;\n\n    int ret;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    /* Read rules from config file or command line options */\n\n    config = qemu_opt_get(opts, \"config\");\n\n    ret = read_config(s, config, options, errp);\n\n    if (ret) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Set initial state */\n\n    s->state = 1;\n\n\n\n    /* Open the backing file */\n\n    ret = bdrv_open_image(&bs->file, qemu_opt_get(opts, \"x-image\"), options, \"image\",\n\n                          flags, true, false, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\n    /* Set request alignment */\n\n    align = qemu_opt_get_size(opts, \"align\", bs->request_alignment);\n\n    if (align > 0 && align < INT_MAX && !(align & (align - 1))) {\n\n        bs->request_alignment = align;\n\n    } else {\n\n        error_setg(errp, \"Invalid alignment\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n    qemu_opts_del(opts);\n\n    return ret;\n\n}\n", "idx": 25714, "_split": "valid", "_hash": "b3ba176635d17c1268e90e5ebdcd67fd"}
{"project": "qemu", "commit_id": "baf35cb90204d75404892aa4e52628ae7a00669b", "target": 1, "func": "void qemu_aio_init(void)\n\n{\n\n    struct sigaction act;\n\n\n\n    aio_initialized = 1;\n\n\n\n    sigfillset(&act.sa_mask);\n\n    act.sa_flags = 0; /* do not restart syscalls to interrupt select() */\n\n    act.sa_handler = aio_signal_handler;\n\n    sigaction(aio_sig_num, &act, NULL);\n\n\n\n#if defined(__GLIBC__) && defined(__linux__)\n\n    {\n\n        /* XXX: aio thread exit seems to hang on RedHat 9 and this init\n\n           seems to fix the problem. */\n\n        struct aioinit ai;\n\n        memset(&ai, 0, sizeof(ai));\n\n        ai.aio_threads = 1;\n\n        ai.aio_num = 1;\n\n        ai.aio_idle_time = 365 * 100000;\n\n        aio_init(&ai);\n\n    }\n\n#endif\n\n}\n", "idx": 25717, "_split": "valid", "_hash": "c4f27b5e9d397f3f84949ee1f3df98ea"}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void zynq_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    ObjectClass *cpu_oc;\n\n    ARMCPU *cpu;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ext_ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ocm_ram = g_new(MemoryRegion, 1);\n\n    DeviceState *dev;\n\n    SysBusDevice *busdev;\n\n    qemu_irq pic[64];\n\n    Error *err = NULL;\n\n    int n;\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"cortex-a9\";\n\n    }\n\n    cpu_oc = cpu_class_by_name(TYPE_ARM_CPU, cpu_model);\n\n\n\n    cpu = ARM_CPU(object_new(object_class_get_name(cpu_oc)));\n\n\n\n    /* By default A9 CPUs have EL3 enabled.  This board does not\n\n     * currently support EL3 so the CPU EL3 property is disabled before\n\n     * realization.\n\n     */\n\n    if (object_property_find(OBJECT(cpu), \"has_el3\", NULL)) {\n\n        object_property_set_bool(OBJECT(cpu), false, \"has_el3\", &err);\n\n        if (err) {\n\n            error_report_err(err);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    object_property_set_int(OBJECT(cpu), ZYNQ_BOARD_MIDR, \"midr\", &err);\n\n    if (err) {\n\n        error_report_err(err);\n\n        exit(1);\n\n    }\n\n\n\n    object_property_set_int(OBJECT(cpu), MPCORE_PERIPHBASE, \"reset-cbar\", &err);\n\n    if (err) {\n\n        error_report_err(err);\n\n        exit(1);\n\n    }\n\n    object_property_set_bool(OBJECT(cpu), true, \"realized\", &err);\n\n    if (err) {\n\n        error_report_err(err);\n\n        exit(1);\n\n    }\n\n\n\n    /* max 2GB ram */\n\n    if (ram_size > 0x80000000) {\n\n        ram_size = 0x80000000;\n\n    }\n\n\n\n    /* DDR remapped to address zero.  */\n\n    memory_region_allocate_system_memory(ext_ram, NULL, \"zynq.ext_ram\",\n\n                                         ram_size);\n\n    memory_region_add_subregion(address_space_mem, 0, ext_ram);\n\n\n\n    /* 256K of on-chip memory */\n\n    memory_region_init_ram(ocm_ram, NULL, \"zynq.ocm_ram\", 256 << 10,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(ocm_ram);\n\n    memory_region_add_subregion(address_space_mem, 0xFFFC0000, ocm_ram);\n\n\n\n    DriveInfo *dinfo = drive_get(IF_PFLASH, 0, 0);\n\n\n\n    /* AMD */\n\n    pflash_cfi02_register(0xe2000000, NULL, \"zynq.pflash\", FLASH_SIZE,\n\n                          dinfo ? blk_by_legacy_dinfo(dinfo) : NULL,\n\n                          FLASH_SECTOR_SIZE,\n\n                          FLASH_SIZE/FLASH_SECTOR_SIZE, 1,\n\n                          1, 0x0066, 0x0022, 0x0000, 0x0000, 0x0555, 0x2aa,\n\n                              0);\n\n\n\n    dev = qdev_create(NULL, \"xilinx,zynq_slcr\");\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xF8000000);\n\n\n\n    dev = qdev_create(NULL, \"a9mpcore_priv\");\n\n    qdev_prop_set_uint32(dev, \"num-cpu\", 1);\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, MPCORE_PERIPHBASE);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ));\n\n\n\n    for (n = 0; n < 64; n++) {\n\n        pic[n] = qdev_get_gpio_in(dev, n);\n\n    }\n\n\n\n    zynq_init_spi_flashes(0xE0006000, pic[58-IRQ_OFFSET], false);\n\n    zynq_init_spi_flashes(0xE0007000, pic[81-IRQ_OFFSET], false);\n\n    zynq_init_spi_flashes(0xE000D000, pic[51-IRQ_OFFSET], true);\n\n\n\n    sysbus_create_simple(\"xlnx,ps7-usb\", 0xE0002000, pic[53-IRQ_OFFSET]);\n\n    sysbus_create_simple(\"xlnx,ps7-usb\", 0xE0003000, pic[76-IRQ_OFFSET]);\n\n\n\n    sysbus_create_simple(\"cadence_uart\", 0xE0000000, pic[59-IRQ_OFFSET]);\n\n    sysbus_create_simple(\"cadence_uart\", 0xE0001000, pic[82-IRQ_OFFSET]);\n\n\n\n    sysbus_create_varargs(\"cadence_ttc\", 0xF8001000,\n\n            pic[42-IRQ_OFFSET], pic[43-IRQ_OFFSET], pic[44-IRQ_OFFSET], NULL);\n\n    sysbus_create_varargs(\"cadence_ttc\", 0xF8002000,\n\n            pic[69-IRQ_OFFSET], pic[70-IRQ_OFFSET], pic[71-IRQ_OFFSET], NULL);\n\n\n\n    gem_init(&nd_table[0], 0xE000B000, pic[54-IRQ_OFFSET]);\n\n    gem_init(&nd_table[1], 0xE000C000, pic[77-IRQ_OFFSET]);\n\n\n\n    dev = qdev_create(NULL, \"generic-sdhci\");\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xE0100000);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[56-IRQ_OFFSET]);\n\n\n\n    dev = qdev_create(NULL, \"generic-sdhci\");\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xE0101000);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[79-IRQ_OFFSET]);\n\n\n\n    dev = qdev_create(NULL, \"pl330\");\n\n    qdev_prop_set_uint8(dev, \"num_chnls\",  8);\n\n    qdev_prop_set_uint8(dev, \"num_periph_req\",  4);\n\n    qdev_prop_set_uint8(dev, \"num_events\",  16);\n\n\n\n    qdev_prop_set_uint8(dev, \"data_width\",  64);\n\n    qdev_prop_set_uint8(dev, \"wr_cap\",  8);\n\n    qdev_prop_set_uint8(dev, \"wr_q_dep\",  16);\n\n    qdev_prop_set_uint8(dev, \"rd_cap\",  8);\n\n    qdev_prop_set_uint8(dev, \"rd_q_dep\",  16);\n\n    qdev_prop_set_uint16(dev, \"data_buffer_dep\",  256);\n\n\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, 0xF8003000);\n\n    sysbus_connect_irq(busdev, 0, pic[45-IRQ_OFFSET]); /* abort irq line */\n\n    for (n = 0; n < 8; ++n) { /* event irqs */\n\n        sysbus_connect_irq(busdev, n + 1, pic[dma_irqs[n] - IRQ_OFFSET]);\n\n    }\n\n\n\n    zynq_binfo.ram_size = ram_size;\n\n    zynq_binfo.kernel_filename = kernel_filename;\n\n    zynq_binfo.kernel_cmdline = kernel_cmdline;\n\n    zynq_binfo.initrd_filename = initrd_filename;\n\n    zynq_binfo.nb_cpus = 1;\n\n    zynq_binfo.board_id = 0xd32;\n\n    zynq_binfo.loader_start = 0;\n\n    arm_load_kernel(ARM_CPU(first_cpu), &zynq_binfo);\n\n}\n", "idx": 25724, "_split": "valid", "_hash": "46a9ada51a22801f77c2bf3769068365"}
{"project": "qemu", "commit_id": "a005b3ef50439b5bc6b2eb0b5bda8e8c7c2368bf", "target": 1, "func": "static void spapr_phb_realize(DeviceState *dev, Error **errp)\n\n{\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_machine());\n\n    SysBusDevice *s = SYS_BUS_DEVICE(dev);\n\n    sPAPRPHBState *sphb = SPAPR_PCI_HOST_BRIDGE(s);\n\n    PCIHostState *phb = PCI_HOST_BRIDGE(s);\n\n    sPAPRPHBClass *info = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(s);\n\n    char *namebuf;\n\n    int i;\n\n    PCIBus *bus;\n\n    uint64_t msi_window_size = 4096;\n\n\n\n    if (sphb->index != (uint32_t)-1) {\n\n        hwaddr windows_base;\n\n\n\n        if ((sphb->buid != (uint64_t)-1) || (sphb->dma_liobn != (uint32_t)-1)\n\n            || (sphb->mem_win_addr != (hwaddr)-1)\n\n            || (sphb->io_win_addr != (hwaddr)-1)) {\n\n            error_setg(errp, \"Either \\\"index\\\" or other parameters must\"\n\n                       \" be specified for PAPR PHB, not both\");\n\n            return;\n\n        }\n\n\n\n        if (sphb->index > SPAPR_PCI_MAX_INDEX) {\n\n            error_setg(errp, \"\\\"index\\\" for PAPR PHB is too large (max %u)\",\n\n                       SPAPR_PCI_MAX_INDEX);\n\n            return;\n\n        }\n\n\n\n        sphb->buid = SPAPR_PCI_BASE_BUID + sphb->index;\n\n        sphb->dma_liobn = SPAPR_PCI_LIOBN(sphb->index, 0);\n\n\n\n        windows_base = SPAPR_PCI_WINDOW_BASE\n\n            + sphb->index * SPAPR_PCI_WINDOW_SPACING;\n\n        sphb->mem_win_addr = windows_base + SPAPR_PCI_MMIO_WIN_OFF;\n\n        sphb->io_win_addr = windows_base + SPAPR_PCI_IO_WIN_OFF;\n\n    }\n\n\n\n    if (sphb->buid == (uint64_t)-1) {\n\n        error_setg(errp, \"BUID not specified for PHB\");\n\n        return;\n\n    }\n\n\n\n    if (sphb->dma_liobn == (uint32_t)-1) {\n\n        error_setg(errp, \"LIOBN not specified for PHB\");\n\n        return;\n\n    }\n\n\n\n    if (sphb->mem_win_addr == (hwaddr)-1) {\n\n        error_setg(errp, \"Memory window address not specified for PHB\");\n\n        return;\n\n    }\n\n\n\n    if (sphb->io_win_addr == (hwaddr)-1) {\n\n        error_setg(errp, \"IO window address not specified for PHB\");\n\n        return;\n\n    }\n\n\n\n    if (spapr_pci_find_phb(spapr, sphb->buid)) {\n\n        error_setg(errp, \"PCI host bridges must have unique BUIDs\");\n\n        return;\n\n    }\n\n\n\n    sphb->dtbusname = g_strdup_printf(\"pci@%\" PRIx64, sphb->buid);\n\n\n\n    namebuf = alloca(strlen(sphb->dtbusname) + 32);\n\n\n\n    /* Initialize memory regions */\n\n    sprintf(namebuf, \"%s.mmio\", sphb->dtbusname);\n\n    memory_region_init(&sphb->memspace, OBJECT(sphb), namebuf, UINT64_MAX);\n\n\n\n    sprintf(namebuf, \"%s.mmio-alias\", sphb->dtbusname);\n\n    memory_region_init_alias(&sphb->memwindow, OBJECT(sphb),\n\n                             namebuf, &sphb->memspace,\n\n                             SPAPR_PCI_MEM_WIN_BUS_OFFSET, sphb->mem_win_size);\n\n    memory_region_add_subregion(get_system_memory(), sphb->mem_win_addr,\n\n                                &sphb->memwindow);\n\n\n\n    /* Initialize IO regions */\n\n    sprintf(namebuf, \"%s.io\", sphb->dtbusname);\n\n    memory_region_init(&sphb->iospace, OBJECT(sphb),\n\n                       namebuf, SPAPR_PCI_IO_WIN_SIZE);\n\n\n\n    sprintf(namebuf, \"%s.io-alias\", sphb->dtbusname);\n\n    memory_region_init_alias(&sphb->iowindow, OBJECT(sphb), namebuf,\n\n                             &sphb->iospace, 0, SPAPR_PCI_IO_WIN_SIZE);\n\n    memory_region_add_subregion(get_system_memory(), sphb->io_win_addr,\n\n                                &sphb->iowindow);\n\n\n\n    bus = pci_register_bus(dev, NULL,\n\n                           pci_spapr_set_irq, pci_spapr_map_irq, sphb,\n\n                           &sphb->memspace, &sphb->iospace,\n\n                           PCI_DEVFN(0, 0), PCI_NUM_PINS, TYPE_PCI_BUS);\n\n    phb->bus = bus;\n\n    qbus_set_hotplug_handler(BUS(phb->bus), DEVICE(sphb), NULL);\n\n\n\n    /*\n\n     * Initialize PHB address space.\n\n     * By default there will be at least one subregion for default\n\n     * 32bit DMA window.\n\n     * Later the guest might want to create another DMA window\n\n     * which will become another memory subregion.\n\n     */\n\n    sprintf(namebuf, \"%s.iommu-root\", sphb->dtbusname);\n\n\n\n    memory_region_init(&sphb->iommu_root, OBJECT(sphb),\n\n                       namebuf, UINT64_MAX);\n\n    address_space_init(&sphb->iommu_as, &sphb->iommu_root,\n\n                       sphb->dtbusname);\n\n\n\n    /*\n\n     * As MSI/MSIX interrupts trigger by writing at MSI/MSIX vectors,\n\n     * we need to allocate some memory to catch those writes coming\n\n     * from msi_notify()/msix_notify().\n\n     * As MSIMessage:addr is going to be the same and MSIMessage:data\n\n     * is going to be a VIRQ number, 4 bytes of the MSI MR will only\n\n     * be used.\n\n     *\n\n     * For KVM we want to ensure that this memory is a full page so that\n\n     * our memory slot is of page size granularity.\n\n     */\n\n#ifdef CONFIG_KVM\n\n    if (kvm_enabled()) {\n\n        msi_window_size = getpagesize();\n\n    }\n\n#endif\n\n\n\n    memory_region_init_io(&sphb->msiwindow, NULL, &spapr_msi_ops, spapr,\n\n                          \"msi\", msi_window_size);\n\n    memory_region_add_subregion(&sphb->iommu_root, SPAPR_PCI_MSI_WINDOW,\n\n                                &sphb->msiwindow);\n\n\n\n    pci_setup_iommu(bus, spapr_pci_dma_iommu, sphb);\n\n\n\n    pci_bus_set_route_irq_fn(bus, spapr_route_intx_pin_to_irq);\n\n\n\n    QLIST_INSERT_HEAD(&spapr->phbs, sphb, list);\n\n\n\n    /* Initialize the LSI table */\n\n    for (i = 0; i < PCI_NUM_PINS; i++) {\n\n        uint32_t irq;\n\n\n\n        irq = xics_alloc_block(spapr->icp, 0, 1, true, false);\n\n        if (!irq) {\n\n            error_setg(errp, \"spapr_allocate_lsi failed\");\n\n            return;\n\n        }\n\n\n\n        sphb->lsi_table[i].irq = irq;\n\n    }\n\n\n\n    /* allocate connectors for child PCI devices */\n\n    if (sphb->dr_enabled) {\n\n        for (i = 0; i < PCI_SLOT_MAX * 8; i++) {\n\n            spapr_dr_connector_new(OBJECT(phb),\n\n                                   SPAPR_DR_CONNECTOR_TYPE_PCI,\n\n                                   (sphb->index << 16) | i);\n\n        }\n\n    }\n\n\n\n    if (!info->finish_realize) {\n\n        error_setg(errp, \"finish_realize not defined\");\n\n        return;\n\n    }\n\n\n\n    info->finish_realize(sphb, errp);\n\n\n\n    sphb->msi = g_hash_table_new_full(g_int_hash, g_int_equal, g_free, g_free);\n\n}\n", "idx": 25726, "_split": "valid", "_hash": "f1d1a70f89def4a8d2552e89581c59f1"}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_input_type_any(Visitor *v, const char *name, QObject **obj,\n\n                               Error **errp)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qmp_input_get_object(qiv, name, true, errp);\n\n\n\n    *obj = NULL;\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n\n\n    qobject_incref(qobj);\n\n    *obj = qobj;\n\n}\n", "idx": 25769, "_split": "valid", "_hash": "f9f5c99aed07c32bbdea7d627194534d"}
{"project": "qemu", "commit_id": "9d7a4c6690ef9962a3b20034f65008f1ea15c1d6", "target": 1, "func": "void *g_try_malloc(size_t n_bytes)\n\n{\n\n    __coverity_negative_sink__(n_bytes);\n\n    return malloc(n_bytes == 0 ? 1 : n_bytes);\n\n}\n", "idx": 25775, "_split": "valid", "_hash": "f22017ef32cf04342b35573c36d958ca"}
{"project": "qemu", "commit_id": "17eb587aeb492fe68f8130b027154ff0921fc0b4", "target": 1, "func": "static int tftp_session_allocate(Slirp *slirp, struct sockaddr_storage *srcsas,\n\n                                 struct tftp_t *tp)\n\n{\n\n  struct tftp_session *spt;\n\n  int k;\n\n\n\n  for (k = 0; k < TFTP_SESSIONS_MAX; k++) {\n\n    spt = &slirp->tftp_sessions[k];\n\n\n\n    if (!tftp_session_in_use(spt))\n\n        goto found;\n\n\n\n    /* sessions time out after 5 inactive seconds */\n\n    if ((int)(curtime - spt->timestamp) > 5000) {\n\n        tftp_session_terminate(spt);\n\n        goto found;\n\n    }\n\n  }\n\n\n\n  return -1;\n\n\n\n found:\n\n  memset(spt, 0, sizeof(*spt));\n\n  spt->client_addr = *srcsas;\n\n  spt->fd = -1;\n\n  spt->block_size = 512;\n\n  spt->client_port = tp->udp.uh_sport;\n\n  spt->slirp = slirp;\n\n\n\n  tftp_session_update(spt);\n\n\n\n  return k;\n\n}\n", "idx": 25785, "_split": "valid", "_hash": "e8782d528f574f64dbebffbd70acd7f4"}
{"project": "qemu", "commit_id": "e53f27b9d9df73461308618151fa6e6392aebd85", "target": 1, "func": "static int tcp_get_msgfd(CharDriverState *chr)\n\n{\n\n    TCPCharDriver *s = chr->opaque;\n\n\n\n    return s->msgfd;\n\n}\n", "idx": 25839, "_split": "valid", "_hash": "47f5c27b6bd72a4762672f4963447569"}
{"project": "qemu", "commit_id": "0e3b800e71cb7759d099eabbd8ad4c4fe848e381", "target": 1, "func": "static void lan9118_eeprom_cmd(lan9118_state *s, int cmd, int addr)\n\n{\n\n    s->e2p_cmd = (s->e2p_cmd & 0x10) | (cmd << 28) | addr;\n\n    switch (cmd) {\n\n    case 0:\n\n        s->e2p_data = s->eeprom[addr];\n\n        DPRINTF(\"EEPROM Read %d = 0x%02x\\n\", addr, s->e2p_data);\n\n\n    case 1:\n\n        s->eeprom_writable = 0;\n\n        DPRINTF(\"EEPROM Write Disable\\n\");\n\n\n    case 2: /* EWEN */\n\n        s->eeprom_writable = 1;\n\n        DPRINTF(\"EEPROM Write Enable\\n\");\n\n\n    case 3: /* WRITE */\n\n        if (s->eeprom_writable) {\n\n            s->eeprom[addr] &= s->e2p_data;\n\n            DPRINTF(\"EEPROM Write %d = 0x%02x\\n\", addr, s->e2p_data);\n\n        } else {\n\n            DPRINTF(\"EEPROM Write %d (ignored)\\n\", addr);\n\n        }\n\n\n    case 4: /* WRAL */\n\n        if (s->eeprom_writable) {\n\n            for (addr = 0; addr < 128; addr++) {\n\n                s->eeprom[addr] &= s->e2p_data;\n\n            }\n\n            DPRINTF(\"EEPROM Write All 0x%02x\\n\", s->e2p_data);\n\n        } else {\n\n            DPRINTF(\"EEPROM Write All (ignored)\\n\");\n\n        }\n\n\n    case 5: /* ERASE */\n\n        if (s->eeprom_writable) {\n\n            s->eeprom[addr] = 0xff;\n\n            DPRINTF(\"EEPROM Erase %d\\n\", addr);\n\n        } else {\n\n            DPRINTF(\"EEPROM Erase %d (ignored)\\n\", addr);\n\n        }\n\n\n    case 6: /* ERAL */\n\n        if (s->eeprom_writable) {\n\n            memset(s->eeprom, 0xff, 128);\n\n            DPRINTF(\"EEPROM Erase All\\n\");\n\n        } else {\n\n            DPRINTF(\"EEPROM Erase All (ignored)\\n\");\n\n        }\n\n\n    case 7: /* RELOAD */\n\n        lan9118_reload_eeprom(s);\n\n\n    }\n\n}", "idx": 25913, "_split": "valid", "_hash": "70ccfa6cdcbfa9b2caaeb7f6ba02f369"}
{"project": "qemu", "commit_id": "74b4c74d5efb0a489bdf0acc5b5d0197167e7649", "target": 0, "func": "static void sigp_store_status_at_address(CPUState *cs, run_on_cpu_data arg)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    SigpInfo *si = arg.host_ptr;\n\n    uint32_t address = si->param & 0x7ffffe00u;\n\n\n\n    /* cpu has to be stopped */\n\n    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {\n\n        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);\n\n        return;\n\n    }\n\n\n\n    cpu_synchronize_state(cs);\n\n\n\n    if (s390_store_status(cpu, address, false)) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);\n\n        return;\n\n    }\n\n    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n}\n", "idx": 25921, "_split": "valid", "_hash": "3d9e63e350bb9ec3fa1e564337ae8ea6"}
{"project": "qemu", "commit_id": "5039d6e23586fe6bbedc5e4fe302b48a66890ade", "target": 0, "func": "static void ppc_prep_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    const char *boot_device = machine->boot_order;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    PowerPCCPU *cpu = NULL;\n\n    CPUPPCState *env = NULL;\n\n    Nvram *m48t59;\n\n#if 0\n\n    MemoryRegion *xcsr = g_new(MemoryRegion, 1);\n\n#endif\n\n    int linux_boot, i, nb_nics1;\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    uint32_t kernel_base, initrd_base;\n\n    long kernel_size, initrd_size;\n\n    DeviceState *dev;\n\n    PCIHostState *pcihost;\n\n    PCIBus *pci_bus;\n\n    PCIDevice *pci;\n\n    ISABus *isa_bus;\n\n    ISADevice *isa;\n\n    int ppc_boot_device;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n\n\n    sysctrl = g_malloc0(sizeof(sysctrl_t));\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (machine->cpu_model == NULL)\n\n        machine->cpu_model = \"602\";\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(machine->cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n\n\n        if (env->flags & POWERPC_FLAG_RTC_CLK) {\n\n            /* POWER / PowerPC 601 RTC clock frequency is 7.8125 MHz */\n\n            cpu_ppc_tb_init(env, 7812500UL);\n\n        } else {\n\n            /* Set time-base frequency to 100 Mhz */\n\n            cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n        }\n\n        qemu_register_reset(ppc_prep_reset, cpu);\n\n    }\n\n\n\n    /* allocate RAM */\n\n    memory_region_allocate_system_memory(ram, NULL, \"ppc_prep.ram\", ram_size);\n\n    memory_region_add_subregion(sysmem, 0, ram);\n\n\n\n    if (linux_boot) {\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* now we can load the kernel */\n\n        kernel_size = load_image_targphys(kernel_filename, kernel_base,\n\n                                          ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            hw_error(\"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                hw_error(\"qemu: could not load initial ram disk '%s'\\n\",\n\n                          initrd_filename);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        ppc_boot_device = '\\0';\n\n        /* For now, OHW cannot boot from the network. */\n\n        for (i = 0; boot_device[i] != '\\0'; i++) {\n\n            if (boot_device[i] >= 'a' && boot_device[i] <= 'f') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n        }\n\n        if (ppc_boot_device == '\\0') {\n\n            fprintf(stderr, \"No valid boot device for Mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) {\n\n        hw_error(\"Only 6xx bus is supported on PREP machine\\n\");\n\n    }\n\n\n\n    dev = qdev_create(NULL, \"raven-pcihost\");\n\n    if (bios_name == NULL) {\n\n        bios_name = BIOS_FILENAME;\n\n    }\n\n    qdev_prop_set_string(dev, \"bios-name\", bios_name);\n\n    qdev_prop_set_uint32(dev, \"elf-machine\", ELF_MACHINE);\n\n    pcihost = PCI_HOST_BRIDGE(dev);\n\n    object_property_add_child(qdev_get_machine(), \"raven\", OBJECT(dev), NULL);\n\n    qdev_init_nofail(dev);\n\n    pci_bus = (PCIBus *)qdev_get_child_bus(dev, \"pci.0\");\n\n    if (pci_bus == NULL) {\n\n        fprintf(stderr, \"Couldn't create PCI host controller.\\n\");\n\n        exit(1);\n\n    }\n\n    sysctrl->contiguous_map_irq = qdev_get_gpio_in(dev, 0);\n\n\n\n    /* PCI -> ISA bridge */\n\n    pci = pci_create_simple(pci_bus, PCI_DEVFN(1, 0), \"i82378\");\n\n    cpu = POWERPC_CPU(first_cpu);\n\n    qdev_connect_gpio_out(&pci->qdev, 0,\n\n                          cpu->env.irq_inputs[PPC6xx_INPUT_INT]);\n\n    qdev_connect_gpio_out(&pci->qdev, 1,\n\n                          qemu_allocate_irq(cpu_request_exit, NULL, 0));\n\n    sysbus_connect_irq(&pcihost->busdev, 0, qdev_get_gpio_in(&pci->qdev, 9));\n\n    sysbus_connect_irq(&pcihost->busdev, 1, qdev_get_gpio_in(&pci->qdev, 11));\n\n    sysbus_connect_irq(&pcihost->busdev, 2, qdev_get_gpio_in(&pci->qdev, 9));\n\n    sysbus_connect_irq(&pcihost->busdev, 3, qdev_get_gpio_in(&pci->qdev, 11));\n\n    isa_bus = ISA_BUS(qdev_get_child_bus(DEVICE(pci), \"isa.0\"));\n\n\n\n    /* Super I/O (parallel + serial ports) */\n\n    isa = isa_create(isa_bus, TYPE_PC87312);\n\n    dev = DEVICE(isa);\n\n    qdev_prop_set_uint8(dev, \"config\", 13); /* fdc, ser0, ser1, par0 */\n\n    qdev_init_nofail(dev);\n\n\n\n    /* init basic PC hardware */\n\n    pci_vga_init(pci_bus);\n\n\n\n    nb_nics1 = nb_nics;\n\n    if (nb_nics1 > NE2000_NB_MAX)\n\n        nb_nics1 = NE2000_NB_MAX;\n\n    for(i = 0; i < nb_nics1; i++) {\n\n        if (nd_table[i].model == NULL) {\n\n\t    nd_table[i].model = g_strdup(\"ne2k_isa\");\n\n        }\n\n        if (strcmp(nd_table[i].model, \"ne2k_isa\") == 0) {\n\n            isa_ne2000_init(isa_bus, ne2000_io[i], ne2000_irq[i],\n\n                            &nd_table[i]);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], pci_bus, \"ne2k_pci\", NULL);\n\n        }\n\n    }\n\n\n\n    ide_drive_get(hd, ARRAY_SIZE(hd));\n\n    for(i = 0; i < MAX_IDE_BUS; i++) {\n\n        isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i], ide_irq[i],\n\n                     hd[2 * i],\n\n\t\t     hd[2 * i + 1]);\n\n    }\n\n    isa_create_simple(isa_bus, \"i8042\");\n\n\n\n    cpu = POWERPC_CPU(first_cpu);\n\n    sysctrl->reset_irq = cpu->env.irq_inputs[PPC6xx_INPUT_HRESET];\n\n\n\n    portio_list_init(&prep_port_list, NULL, prep_portio_list, sysctrl, \"prep\");\n\n    portio_list_add(&prep_port_list, isa_address_space_io(isa), 0x0);\n\n\n\n    /* PowerPC control and status register group */\n\n#if 0\n\n    memory_region_init_io(xcsr, NULL, &PPC_XCSR_ops, NULL, \"ppc-xcsr\", 0x1000);\n\n    memory_region_add_subregion(sysmem, 0xFEFF0000, xcsr);\n\n#endif\n\n\n\n    if (usb_enabled()) {\n\n        pci_create_simple(pci_bus, -1, \"pci-ohci\");\n\n    }\n\n\n\n    m48t59 = m48t59_init_isa(isa_bus, 0x0074, NVRAM_SIZE, 2000, 59);\n\n    if (m48t59 == NULL)\n\n        return;\n\n    sysctrl->nvram = m48t59;\n\n\n\n    /* Initialise NVRAM */\n\n    PPC_NVRAM_set_params(m48t59, NVRAM_SIZE, \"PREP\", ram_size,\n\n                         ppc_boot_device,\n\n                         kernel_base, kernel_size,\n\n                         kernel_cmdline,\n\n                         initrd_base, initrd_size,\n\n                         /* XXX: need an option to load a NVRAM image */\n\n                         0,\n\n                         graphic_width, graphic_height, graphic_depth);\n\n}\n", "idx": 25934, "_split": "valid", "_hash": "28a0d67ead958de50b4d3f398233c828"}
{"project": "qemu", "commit_id": "791230d8bbd5c09d80845755a54074cd2d8b5a22", "target": 1, "func": "int qcow2_check_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n                          BdrvCheckMode fix)\n{\n    BDRVQcowState *s = bs->opaque;\n    BdrvCheckResult pre_compare_res;\n    int64_t size, highest_cluster, nb_clusters;\n    uint16_t *refcount_table = NULL;\n    bool rebuild = false;\n    int ret;\n    size = bdrv_getlength(bs->file);\n    if (size < 0) {\n        res->check_errors++;\n        return size;\n    nb_clusters = size_to_clusters(s, size);\n    if (nb_clusters > INT_MAX) {\n        res->check_errors++;\n        return -EFBIG;\n    res->bfi.total_clusters =\n        size_to_clusters(s, bs->total_sectors * BDRV_SECTOR_SIZE);\n    ret = calculate_refcounts(bs, res, fix, &rebuild, &refcount_table,\n    /* In case we don't need to rebuild the refcount structure (but want to fix\n     * something), this function is immediately called again, in which case the\n     * result should be ignored */\n    pre_compare_res = *res;\n    compare_refcounts(bs, res, 0, &rebuild, &highest_cluster, refcount_table,\n                      nb_clusters);\n    if (rebuild && (fix & BDRV_FIX_ERRORS)) {\n        fprintf(stderr, \"Rebuilding refcount structure\\n\");\n        ret = rebuild_refcount_structure(bs, res, &refcount_table,\n    } else if (fix) {\n            fprintf(stderr, \"ERROR need to rebuild refcount structures\\n\");\n            res->check_errors++;\n            ret = -EIO;\n        if (res->leaks || res->corruptions) {\n            *res = pre_compare_res;\n            compare_refcounts(bs, res, fix, &rebuild, &highest_cluster,\n                              refcount_table, nb_clusters);\n    /* check OFLAG_COPIED */\n    ret = check_oflag_copied(bs, res, fix);\n    res->image_end_offset = (highest_cluster + 1) * s->cluster_size;\n    ret = 0;\nfail:\n    g_free(refcount_table);\n    return ret;", "idx": 25944, "_split": "valid", "_hash": "57414b4471357e4cfbc3dc84c14b2d2e"}
{"project": "qemu", "commit_id": "97225170f6ee6d0ad8653916c7a5e4508cbffc18", "target": 1, "func": "static void pmac_ide_atapi_transfer_cb(void *opaque, int ret)\n\n{\n\n    DBDMA_io *io = opaque;\n\n    MACIOIDEState *m = io->opaque;\n\n    IDEState *s = idebus_active_if(&m->bus);\n\n    int64_t offset;\n\n\n\n    MACIO_DPRINTF(\"pmac_ide_atapi_transfer_cb\\n\");\n\n\n\n    if (ret < 0) {\n\n        MACIO_DPRINTF(\"DMA error: %d\\n\", ret);\n\n        ide_atapi_io_error(s, ret);\n\n        goto done;\n\n    }\n\n\n\n    if (!m->dma_active) {\n\n        MACIO_DPRINTF(\"waiting for data (%#x - %#x - %x)\\n\",\n\n                      s->nsector, io->len, s->status);\n\n        /* data not ready yet, wait for the channel to get restarted */\n\n        io->processing = false;\n\n        return;\n\n    }\n\n\n\n    if (s->io_buffer_size <= 0) {\n\n        MACIO_DPRINTF(\"End of IDE transfer\\n\");\n\n        ide_atapi_cmd_ok(s);\n\n        m->dma_active = false;\n\n        goto done;\n\n    }\n\n\n\n    if (io->len == 0) {\n\n        MACIO_DPRINTF(\"End of DMA transfer\\n\");\n\n        goto done;\n\n    }\n\n\n\n    if (s->lba == -1) {\n\n        /* Non-block ATAPI transfer - just copy to RAM */\n\n        s->io_buffer_size = MIN(s->io_buffer_size, io->len);\n\n        cpu_physical_memory_write(io->addr, s->io_buffer, s->io_buffer_size);\n\n        ide_atapi_cmd_ok(s);\n\n        m->dma_active = false;\n\n        goto done;\n\n    }\n\n\n\n    /* Calculate current offset */\n\n    offset = (int64_t)(s->lba << 11) + s->io_buffer_index;\n\n\n\n    pmac_dma_read(s->blk, offset, io->len, pmac_ide_atapi_transfer_cb, io);\n\n    return;\n\n\n\ndone:\n\n    if (ret < 0) {\n\n        block_acct_failed(blk_get_stats(s->blk), &s->acct);\n\n    } else {\n\n        block_acct_done(blk_get_stats(s->blk), &s->acct);\n\n    }\n\n    io->dma_end(opaque);\n\n}\n", "idx": 25951, "_split": "valid", "_hash": "fc41c639cbc672f6c670de6959d3f74d"}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static void qemu_chr_parse_spice_port(QemuOpts *opts, ChardevBackend *backend,\n\n                                      Error **errp)\n\n{\n\n    const char *name = qemu_opt_get(opts, \"name\");\n\n    ChardevSpicePort *spiceport;\n\n\n\n    if (name == NULL) {\n\n        error_setg(errp, \"chardev: spice port: no name given\");\n\n        return;\n\n    }\n\n    spiceport = backend->u.spiceport = g_new0(ChardevSpicePort, 1);\n\n    qemu_chr_parse_common(opts, qapi_ChardevSpicePort_base(spiceport));\n\n    spiceport->fqdn = g_strdup(name);\n\n}\n", "idx": 25962, "_split": "valid", "_hash": "9878828b3e6fb8126ba044c69e972263"}
{"project": "qemu", "commit_id": "4c8d0d27676778febad3802a95218d5ceaca171e", "target": 0, "func": "void qemu_fd_register(int fd)\n\n{\n\n    WSAEventSelect(fd, qemu_event_handle, FD_READ | FD_ACCEPT | FD_CLOSE |\n\n                   FD_CONNECT | FD_WRITE | FD_OOB);\n\n}\n", "idx": 25975, "_split": "valid", "_hash": "f9b95b2fd2b25397ec658c4699868e58"}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "static struct pxa2xx_i2s_s *pxa2xx_i2s_init(target_phys_addr_t base,\n\n                qemu_irq irq, struct pxa2xx_dma_state_s *dma)\n\n{\n\n    int iomemtype;\n\n    struct pxa2xx_i2s_s *s = (struct pxa2xx_i2s_s *)\n\n            qemu_mallocz(sizeof(struct pxa2xx_i2s_s));\n\n\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->dma = dma;\n\n    s->data_req = pxa2xx_i2s_data_req;\n\n\n\n    pxa2xx_i2s_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_i2s_readfn,\n\n                    pxa2xx_i2s_writefn, s);\n\n    cpu_register_physical_memory(s->base & 0xfff00000, 0xfffff, iomemtype);\n\n\n\n    register_savevm(\"pxa2xx_i2s\", base, 0,\n\n                    pxa2xx_i2s_save, pxa2xx_i2s_load, s);\n\n\n\n    return s;\n\n}\n", "idx": 25980, "_split": "valid", "_hash": "9b02c4c94d087e86d884bfc79640f14b"}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void perf_nesting(void)\n\n{\n\n    unsigned int i, maxcycles, maxnesting;\n\n    double duration;\n\n\n\n    maxcycles = 10000;\n\n    maxnesting = 1000;\n\n    Coroutine *root;\n\n\n\n    g_test_timer_start();\n\n    for (i = 0; i < maxcycles; i++) {\n\n        NestData nd = {\n\n            .n_enter  = 0,\n\n            .n_return = 0,\n\n            .max      = maxnesting,\n\n        };\n\n        root = qemu_coroutine_create(nest);\n\n        qemu_coroutine_enter(root, &nd);\n\n    }\n\n    duration = g_test_timer_elapsed();\n\n\n\n    g_test_message(\"Nesting %u iterations of %u depth each: %f s\\n\",\n\n        maxcycles, maxnesting, duration);\n\n}\n", "idx": 25982, "_split": "valid", "_hash": "ad6656e79575bc66d102e0635aae2daa"}
{"project": "qemu", "commit_id": "27bb0b2d6f80f058bdb6fcc8fcdfa69b0c8a6d71", "target": 1, "func": "void hpet_init(qemu_irq *irq) {\n\n    int i, iomemtype;\n\n    HPETState *s;\n\n\n\n    DPRINTF (\"hpet_init\\n\");\n\n\n\n    s = qemu_mallocz(sizeof(HPETState));\n\n    hpet_statep = s;\n\n    s->irqs = irq;\n\n    for (i=0; i<HPET_NUM_TIMERS; i++) {\n\n        HPETTimer *timer = &s->timer[i];\n\n        timer->qemu_timer = qemu_new_timer(vm_clock, hpet_timer, timer);\n\n    }\n\n    vmstate_register(-1, &vmstate_hpet, s);\n\n    qemu_register_reset(hpet_reset, s);\n\n    /* HPET Area */\n\n    iomemtype = cpu_register_io_memory(hpet_ram_read,\n\n                                       hpet_ram_write, s);\n\n    cpu_register_physical_memory(HPET_BASE, 0x400, iomemtype);\n\n}\n", "idx": 25986, "_split": "valid", "_hash": "7ef768dcee621b2809af84667817eb88"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void slavio_serial_ms_kbd_init(target_phys_addr_t base, qemu_irq irq,\n\n                               int disabled, int clock, int it_shift)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"escc\");\n\n    qdev_prop_set_uint32(dev, \"disabled\", disabled);\n\n    qdev_prop_set_uint32(dev, \"frequency\", clock);\n\n    qdev_prop_set_uint32(dev, \"it_shift\", it_shift);\n\n    qdev_prop_set_chr(dev, \"chrB\", NULL);\n\n    qdev_prop_set_chr(dev, \"chrA\", NULL);\n\n    qdev_prop_set_uint32(dev, \"chnBtype\", mouse);\n\n    qdev_prop_set_uint32(dev, \"chnAtype\", kbd);\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_connect_irq(s, 1, irq);\n\n    sysbus_mmio_map(s, 0, base);\n\n}\n", "idx": 26007, "_split": "valid", "_hash": "3fd49f425fed121039e8e9f752f31914"}
{"project": "qemu", "commit_id": "bf328399da57450feaeaa24c2539a351e41713db", "target": 0, "func": "static int list_pci(ClpReqRspListPci *rrb, uint8_t *cc)\n\n{\n\n    S390PCIBusDevice *pbdev;\n\n    uint32_t res_code, initial_l2, g_l2, finish;\n\n    int rc, idx;\n\n    uint64_t resume_token;\n\n\n\n    rc = 0;\n\n    if (lduw_p(&rrb->request.hdr.len) != 32) {\n\n        res_code = CLP_RC_LEN;\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    if ((ldl_p(&rrb->request.fmt) & CLP_MASK_FMT) != 0) {\n\n        res_code = CLP_RC_FMT;\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    if ((ldl_p(&rrb->request.fmt) & ~CLP_MASK_FMT) != 0 ||\n\n        ldq_p(&rrb->request.reserved1) != 0 ||\n\n        ldq_p(&rrb->request.reserved2) != 0) {\n\n        res_code = CLP_RC_RESNOT0;\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    resume_token = ldq_p(&rrb->request.resume_token);\n\n\n\n    if (resume_token) {\n\n        pbdev = s390_pci_find_dev_by_idx(resume_token);\n\n        if (!pbdev) {\n\n            res_code = CLP_RC_LISTPCI_BADRT;\n\n            rc = -EINVAL;\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    if (lduw_p(&rrb->response.hdr.len) < 48) {\n\n        res_code = CLP_RC_8K;\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    initial_l2 = lduw_p(&rrb->response.hdr.len);\n\n    if ((initial_l2 - LIST_PCI_HDR_LEN) % sizeof(ClpFhListEntry)\n\n        != 0) {\n\n        res_code = CLP_RC_LEN;\n\n        rc = -EINVAL;\n\n        *cc = 3;\n\n        goto out;\n\n    }\n\n\n\n    stl_p(&rrb->response.fmt, 0);\n\n    stq_p(&rrb->response.reserved1, 0);\n\n    stq_p(&rrb->response.reserved2, 0);\n\n    stl_p(&rrb->response.mdd, FH_MASK_SHM);\n\n    stw_p(&rrb->response.max_fn, PCI_MAX_FUNCTIONS);\n\n    rrb->response.entry_size = sizeof(ClpFhListEntry);\n\n    finish = 0;\n\n    idx = resume_token;\n\n    g_l2 = LIST_PCI_HDR_LEN;\n\n    do {\n\n        pbdev = s390_pci_find_dev_by_idx(idx);\n\n        if (!pbdev) {\n\n            finish = 1;\n\n            break;\n\n        }\n\n        stw_p(&rrb->response.fh_list[idx - resume_token].device_id,\n\n            pci_get_word(pbdev->pdev->config + PCI_DEVICE_ID));\n\n        stw_p(&rrb->response.fh_list[idx - resume_token].vendor_id,\n\n            pci_get_word(pbdev->pdev->config + PCI_VENDOR_ID));\n\n        /* Ignore RESERVED devices. */\n\n        stl_p(&rrb->response.fh_list[idx - resume_token].config,\n\n            pbdev->state == ZPCI_FS_STANDBY ? 0 : 1 << 31);\n\n        stl_p(&rrb->response.fh_list[idx - resume_token].fid, pbdev->fid);\n\n        stl_p(&rrb->response.fh_list[idx - resume_token].fh, pbdev->fh);\n\n\n\n        g_l2 += sizeof(ClpFhListEntry);\n\n        /* Add endian check for DPRINTF? */\n\n        DPRINTF(\"g_l2 %d vendor id 0x%x device id 0x%x fid 0x%x fh 0x%x\\n\",\n\n            g_l2,\n\n            lduw_p(&rrb->response.fh_list[idx - resume_token].vendor_id),\n\n            lduw_p(&rrb->response.fh_list[idx - resume_token].device_id),\n\n            ldl_p(&rrb->response.fh_list[idx - resume_token].fid),\n\n            ldl_p(&rrb->response.fh_list[idx - resume_token].fh));\n\n        idx++;\n\n    } while (g_l2 < initial_l2);\n\n\n\n    if (finish == 1) {\n\n        resume_token = 0;\n\n    } else {\n\n        resume_token = idx;\n\n    }\n\n    stq_p(&rrb->response.resume_token, resume_token);\n\n    stw_p(&rrb->response.hdr.len, g_l2);\n\n    stw_p(&rrb->response.hdr.rsp, CLP_RC_OK);\n\nout:\n\n    if (rc) {\n\n        DPRINTF(\"list pci failed rc 0x%x\\n\", rc);\n\n        stw_p(&rrb->response.hdr.rsp, res_code);\n\n    }\n\n    return rc;\n\n}\n", "idx": 26018, "_split": "valid", "_hash": "aa79db6eb85051f6a287fa8fc782a974"}
{"project": "qemu", "commit_id": "9eeb8306d56e8fd831bbbac6e3cfe69a40312a33", "target": 0, "func": "abi_long do_sigaltstack(abi_ulong uss_addr, abi_ulong uoss_addr, abi_ulong sp)\n\n{\n\n    int ret;\n\n    struct target_sigaltstack oss;\n\n\n\n    /* XXX: test errors */\n\n    if(uoss_addr)\n\n    {\n\n        __put_user(target_sigaltstack_used.ss_sp, &oss.ss_sp);\n\n        __put_user(target_sigaltstack_used.ss_size, &oss.ss_size);\n\n        __put_user(sas_ss_flags(sp), &oss.ss_flags);\n\n    }\n\n\n\n    if(uss_addr)\n\n    {\n\n        struct target_sigaltstack *uss;\n\n        struct target_sigaltstack ss;\n\n\n\n\tret = -TARGET_EFAULT;\n\n        if (!lock_user_struct(VERIFY_READ, uss, uss_addr, 1)\n\n\t    || __get_user(ss.ss_sp, &uss->ss_sp)\n\n\t    || __get_user(ss.ss_size, &uss->ss_size)\n\n\t    || __get_user(ss.ss_flags, &uss->ss_flags))\n\n            goto out;\n\n        unlock_user_struct(uss, uss_addr, 0);\n\n\n\n\tret = -TARGET_EPERM;\n\n\tif (on_sig_stack(sp))\n\n            goto out;\n\n\n\n\tret = -TARGET_EINVAL;\n\n\tif (ss.ss_flags != TARGET_SS_DISABLE\n\n            && ss.ss_flags != TARGET_SS_ONSTACK\n\n            && ss.ss_flags != 0)\n\n            goto out;\n\n\n\n\tif (ss.ss_flags == TARGET_SS_DISABLE) {\n\n            ss.ss_size = 0;\n\n            ss.ss_sp = 0;\n\n\t} else {\n\n            ret = -TARGET_ENOMEM;\n\n            if (ss.ss_size < MINSIGSTKSZ)\n\n                goto out;\n\n\t}\n\n\n\n        target_sigaltstack_used.ss_sp = ss.ss_sp;\n\n        target_sigaltstack_used.ss_size = ss.ss_size;\n\n    }\n\n\n\n    if (uoss_addr) {\n\n        ret = -TARGET_EFAULT;\n\n        if (copy_to_user(uoss_addr, &oss, sizeof(oss)))\n\n            goto out;\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    return ret;\n\n}\n", "idx": 26027, "_split": "valid", "_hash": "925d214a6de29562175cf1a07b990f85"}
{"project": "qemu", "commit_id": "a1abf40d6be2fc4b40d90ae3b46442f4a671776b", "target": 1, "func": "void laio_cleanup(void *s_)\n{\n    struct qemu_laio_state *s = s_;\n    event_notifier_cleanup(&s->e);\n    g_free(s);", "idx": 26049, "_split": "valid", "_hash": "f0c22d8febbb0592d0d8d78be8bc86ba"}
{"project": "qemu", "commit_id": "7bb5d6ade6d8afbcad72a871f712370ffae457c6", "target": 0, "func": "static void pc_dimm_init(Object *obj)\n\n{\n\n    PCDIMMDevice *dimm = PC_DIMM(obj);\n\n\n\n    object_property_add(obj, PC_DIMM_SIZE_PROP, \"int\", pc_dimm_get_size,\n\n                        NULL, NULL, NULL, &error_abort);\n\n    object_property_add_link(obj, PC_DIMM_MEMDEV_PROP, TYPE_MEMORY_BACKEND,\n\n                             (Object **)&dimm->hostmem,\n\n                             qdev_prop_allow_set_link_before_realize,\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE,\n\n                             &error_abort);\n\n}\n", "idx": 26118, "_split": "valid", "_hash": "9eccf89ef41420c89b14661c3b32ceb1"}
{"project": "qemu", "commit_id": "b227a8e9aa5f27d29f77ba90d5eb9d0662a1175e", "target": 0, "func": "static always_inline int find_pte (CPUState *env, mmu_ctx_t *ctx,\n\n                                   int h, int rw)\n\n{\n\n#if defined(TARGET_PPC64)\n\n    if (env->mmu_model == POWERPC_MMU_64B)\n\n        return find_pte64(ctx, h, rw);\n\n#endif\n\n\n\n    return find_pte32(ctx, h, rw);\n\n}\n", "idx": 26122, "_split": "valid", "_hash": "a9608f80634fa1fae219f92c88d08f8a"}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "static void tcp_chr_accept(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    TCPCharDriver *s = chr->opaque;\n\n    struct sockaddr_in saddr;\n\n#ifndef _WIN32\n\n    struct sockaddr_un uaddr;\n\n#endif\n\n    struct sockaddr *addr;\n\n    socklen_t len;\n\n    int fd;\n\n\n\n    for(;;) {\n\n#ifndef _WIN32\n\n\tif (s->is_unix) {\n\n\t    len = sizeof(uaddr);\n\n\t    addr = (struct sockaddr *)&uaddr;\n\n\t} else\n\n#endif\n\n\t{\n\n\t    len = sizeof(saddr);\n\n\t    addr = (struct sockaddr *)&saddr;\n\n\t}\n\n        fd = accept(s->listen_fd, addr, &len);\n\n        if (fd < 0 && errno != EINTR) {\n\n            return;\n\n        } else if (fd >= 0) {\n\n            if (s->do_telnetopt)\n\n                tcp_chr_telnet_init(fd);\n\n            break;\n\n        }\n\n    }\n\n    socket_set_nonblock(fd);\n\n    if (s->do_nodelay)\n\n        socket_set_nodelay(fd);\n\n    s->fd = fd;\n\n    qemu_set_fd_handler(s->listen_fd, NULL, NULL, NULL);\n\n    tcp_chr_connect(chr);\n\n}\n", "idx": 26141, "_split": "valid", "_hash": "7f10efbbe17b1ff97b1a35680bbb32ec"}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_native_list_int8(TestOutputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_S8);\n\n}\n", "idx": 26149, "_split": "valid", "_hash": "d63bb91317f438649ca99bf08ea3290f"}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_reg_alloc_mov(TCGContext *s, const TCGOpDef *def,\n\n                              const TCGArg *args, uint16_t dead_args,\n\n                              uint8_t sync_args)\n\n{\n\n    TCGRegSet allocated_regs;\n\n    TCGTemp *ts, *ots;\n\n    TCGType otype, itype;\n\n\n\n    tcg_regset_set(allocated_regs, s->reserved_regs);\n\n    ots = &s->temps[args[0]];\n\n    ts = &s->temps[args[1]];\n\n\n\n    /* Note that otype != itype for no-op truncation.  */\n\n    otype = ots->type;\n\n    itype = ts->type;\n\n\n\n    /* If the source value is not in a register, and we're going to be\n\n       forced to have it in a register in order to perform the copy,\n\n       then copy the SOURCE value into its own register first.  That way\n\n       we don't have to reload SOURCE the next time it is used. */\n\n    if (((NEED_SYNC_ARG(0) || ots->fixed_reg) && ts->val_type != TEMP_VAL_REG)\n\n        || ts->val_type == TEMP_VAL_MEM) {\n\n        temp_load(s, ts, tcg_target_available_regs[itype], allocated_regs);\n\n    }\n\n\n\n    if (IS_DEAD_ARG(0) && !ots->fixed_reg) {\n\n        /* mov to a non-saved dead register makes no sense (even with\n\n           liveness analysis disabled). */\n\n        assert(NEED_SYNC_ARG(0));\n\n        /* The code above should have moved the temp to a register. */\n\n        assert(ts->val_type == TEMP_VAL_REG);\n\n        if (!ots->mem_allocated) {\n\n            temp_allocate_frame(s, args[0]);\n\n        }\n\n        if (ots->indirect_reg) {\n\n            tcg_regset_set_reg(allocated_regs, ts->reg);\n\n            temp_load(s, ots->mem_base,\n\n                      tcg_target_available_regs[TCG_TYPE_PTR],\n\n                      allocated_regs);\n\n        }\n\n        tcg_out_st(s, otype, ts->reg, ots->mem_base->reg, ots->mem_offset);\n\n        if (IS_DEAD_ARG(1)) {\n\n            temp_dead(s, ts);\n\n        }\n\n        temp_dead(s, ots);\n\n    } else if (ts->val_type == TEMP_VAL_CONST) {\n\n        /* propagate constant */\n\n        if (ots->val_type == TEMP_VAL_REG) {\n\n            s->reg_to_temp[ots->reg] = NULL;\n\n        }\n\n        ots->val_type = TEMP_VAL_CONST;\n\n        ots->val = ts->val;\n\n        if (IS_DEAD_ARG(1)) {\n\n            temp_dead(s, ts);\n\n        }\n\n    } else {\n\n        /* The code in the first if block should have moved the\n\n           temp to a register. */\n\n        assert(ts->val_type == TEMP_VAL_REG);\n\n        if (IS_DEAD_ARG(1) && !ts->fixed_reg && !ots->fixed_reg) {\n\n            /* the mov can be suppressed */\n\n            if (ots->val_type == TEMP_VAL_REG) {\n\n                s->reg_to_temp[ots->reg] = NULL;\n\n            }\n\n            ots->reg = ts->reg;\n\n            temp_dead(s, ts);\n\n        } else {\n\n            if (ots->val_type != TEMP_VAL_REG) {\n\n                /* When allocating a new register, make sure to not spill the\n\n                   input one. */\n\n                tcg_regset_set_reg(allocated_regs, ts->reg);\n\n                ots->reg = tcg_reg_alloc(s, tcg_target_available_regs[otype],\n\n                                         allocated_regs, ots->indirect_base);\n\n            }\n\n            tcg_out_mov(s, otype, ots->reg, ts->reg);\n\n        }\n\n        ots->val_type = TEMP_VAL_REG;\n\n        ots->mem_coherent = 0;\n\n        s->reg_to_temp[ots->reg] = ots;\n\n        if (NEED_SYNC_ARG(0)) {\n\n            tcg_reg_sync(s, ots->reg, allocated_regs);\n\n        }\n\n    }\n\n}\n", "idx": 26156, "_split": "valid", "_hash": "344f5bb058f5db5bf54ea2de728afe70"}
{"project": "qemu", "commit_id": "f186d64d8fda4bb22c15beb8e45b7814fbd8b51e", "target": 0, "func": "void replay_finish_event(void)\n\n{\n\n    replay_has_unread_data = 0;\n\n    replay_fetch_data_kind();\n\n}\n", "idx": 26199, "_split": "valid", "_hash": "a0350f605f5bebf3b2e67a64fc53d1c5"}
{"project": "qemu", "commit_id": "b25b387fa5928e516cb2c9e7fde68e958bd7e50a", "target": 0, "func": "static int64_t coroutine_fn qcow2_co_get_block_status(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *pnum, BlockDriverState **file)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t cluster_offset;\n\n    int index_in_cluster, ret;\n\n    unsigned int bytes;\n\n    int64_t status = 0;\n\n\n\n    bytes = MIN(INT_MAX, nb_sectors * BDRV_SECTOR_SIZE);\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = qcow2_get_cluster_offset(bs, sector_num << 9, &bytes,\n\n                                   &cluster_offset);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    *pnum = bytes >> BDRV_SECTOR_BITS;\n\n\n\n    if (cluster_offset != 0 && ret != QCOW2_CLUSTER_COMPRESSED &&\n\n        !s->cipher) {\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        cluster_offset |= (index_in_cluster << BDRV_SECTOR_BITS);\n\n        *file = bs->file->bs;\n\n        status |= BDRV_BLOCK_OFFSET_VALID | cluster_offset;\n\n    }\n\n    if (ret == QCOW2_CLUSTER_ZERO_PLAIN || ret == QCOW2_CLUSTER_ZERO_ALLOC) {\n\n        status |= BDRV_BLOCK_ZERO;\n\n    } else if (ret != QCOW2_CLUSTER_UNALLOCATED) {\n\n        status |= BDRV_BLOCK_DATA;\n\n    }\n\n    return status;\n\n}\n", "idx": 26202, "_split": "valid", "_hash": "f4bc27ee29c3d935a90e82bee0dd071c"}
{"project": "qemu", "commit_id": "cdb3081269347fd9271fd1b7a9df312e2953bdd9", "target": 0, "func": "static void vfio_iommu_map_notify(Notifier *n, void *data)\n\n{\n\n    VFIOGuestIOMMU *giommu = container_of(n, VFIOGuestIOMMU, n);\n\n    VFIOContainer *container = giommu->container;\n\n    IOMMUTLBEntry *iotlb = data;\n\n    hwaddr iova = iotlb->iova + giommu->iommu_offset;\n\n    MemoryRegion *mr;\n\n    hwaddr xlat;\n\n    hwaddr len = iotlb->addr_mask + 1;\n\n    void *vaddr;\n\n    int ret;\n\n\n\n    trace_vfio_iommu_map_notify(iova, iova + iotlb->addr_mask);\n\n\n\n    if (iotlb->target_as != &address_space_memory) {\n\n        error_report(\"Wrong target AS \\\"%s\\\", only system memory is allowed\",\n\n                     iotlb->target_as->name ? iotlb->target_as->name : \"none\");\n\n        return;\n\n    }\n\n\n\n    /*\n\n     * The IOMMU TLB entry we have just covers translation through\n\n     * this IOMMU to its immediate target.  We need to translate\n\n     * it the rest of the way through to memory.\n\n     */\n\n    rcu_read_lock();\n\n    mr = address_space_translate(&address_space_memory,\n\n                                 iotlb->translated_addr,\n\n                                 &xlat, &len, iotlb->perm & IOMMU_WO);\n\n    if (!memory_region_is_ram(mr)) {\n\n        error_report(\"iommu map to non memory area %\"HWADDR_PRIx\"\",\n\n                     xlat);\n\n        goto out;\n\n    }\n\n    /*\n\n     * Translation truncates length to the IOMMU page size,\n\n     * check that it did not truncate too much.\n\n     */\n\n    if (len & iotlb->addr_mask) {\n\n        error_report(\"iommu has granularity incompatible with target AS\");\n\n        goto out;\n\n    }\n\n\n\n    if ((iotlb->perm & IOMMU_RW) != IOMMU_NONE) {\n\n        vaddr = memory_region_get_ram_ptr(mr) + xlat;\n\n        ret = vfio_dma_map(container, iova,\n\n                           iotlb->addr_mask + 1, vaddr,\n\n                           !(iotlb->perm & IOMMU_WO) || mr->readonly);\n\n        if (ret) {\n\n            error_report(\"vfio_dma_map(%p, 0x%\"HWADDR_PRIx\", \"\n\n                         \"0x%\"HWADDR_PRIx\", %p) = %d (%m)\",\n\n                         container, iova,\n\n                         iotlb->addr_mask + 1, vaddr, ret);\n\n        }\n\n    } else {\n\n        ret = vfio_dma_unmap(container, iova, iotlb->addr_mask + 1);\n\n        if (ret) {\n\n            error_report(\"vfio_dma_unmap(%p, 0x%\"HWADDR_PRIx\", \"\n\n                         \"0x%\"HWADDR_PRIx\") = %d (%m)\",\n\n                         container, iova,\n\n                         iotlb->addr_mask + 1, ret);\n\n        }\n\n    }\n\nout:\n\n    rcu_read_unlock();\n\n}\n", "idx": 26203, "_split": "valid", "_hash": "5cb4d47d54d12ec5108ad87ab286d085"}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)\n\n{\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    return truncate(rpath(ctx, path, buffer), size);\n\n}\n", "idx": 26223, "_split": "valid", "_hash": "318db5d74fbb0ff3cac787c8af8c2158"}
{"project": "qemu", "commit_id": "298a1665a2800f7264e483c2dd1f551574243a2f", "target": 0, "func": "static bool is_zero_sectors(BlockDriverState *bs, int64_t start,\n\n                            uint32_t count)\n\n{\n\n    int nr;\n\n    BlockDriverState *file;\n\n    int64_t res;\n\n\n\n    if (start + count > bs->total_sectors) {\n\n        count = bs->total_sectors - start;\n\n    }\n\n\n\n    if (!count) {\n\n        return true;\n\n    }\n\n    res = bdrv_get_block_status_above(bs, NULL, start, count,\n\n                                      &nr, &file);\n\n    return res >= 0 && (res & BDRV_BLOCK_ZERO) && nr == count;\n\n}\n", "idx": 26227, "_split": "valid", "_hash": "58a8b9607978b949a298e4add79135ef"}
{"project": "qemu", "commit_id": "5dd7a535b71a0f2f8e7af75c5d694174359ce323", "target": 1, "func": "static void iscsi_nop_timed_event(void *opaque)\n\n{\n\n    IscsiLun *iscsilun = opaque;\n\n\n\n    if (iscsi_get_nops_in_flight(iscsilun->iscsi) > MAX_NOP_FAILURES) {\n\n        error_report(\"iSCSI: NOP timeout. Reconnecting...\");\n\n        iscsi_reconnect(iscsilun->iscsi);\n\n    }\n\n\n\n    if (iscsi_nop_out_async(iscsilun->iscsi, NULL, NULL, 0, NULL) != 0) {\n\n        error_report(\"iSCSI: failed to sent NOP-Out. Disabling NOP messages.\");\n\n        return;\n\n    }\n\n\n\n    timer_mod(iscsilun->nop_timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + NOP_INTERVAL);\n\n    iscsi_set_events(iscsilun);\n\n}\n", "idx": 26237, "_split": "valid", "_hash": "2fee6eca1cd72c5c45fd6d79b8dad0ac"}
{"project": "qemu", "commit_id": "1a28cac3161f8a85ee0256776068eaed2da025e5", "target": 0, "func": "void qemu_mutex_lock_iothread(void)\n\n{\n\n    if (kvm_enabled()) {\n\n        qemu_mutex_lock(&qemu_fair_mutex);\n\n        qemu_mutex_lock(&qemu_global_mutex);\n\n        qemu_mutex_unlock(&qemu_fair_mutex);\n\n    } else\n\n        qemu_signal_lock(100);\n\n}\n", "idx": 26275, "_split": "valid", "_hash": "9eaaa7c5f9e1c91691b76cd2624c7b02"}
{"project": "qemu", "commit_id": "83f7f32901c630f4fc01acd0d9082da466b17102", "target": 1, "func": "static bool is_special_wait_psw(CPUState *cs)\n\n{\n\n    /* signal quiesce */\n\n    return cs->kvm_run->psw_addr == 0xfffUL;\n\n}\n", "idx": 26296, "_split": "valid", "_hash": "d8d9ee190835abd4e105671a60ceb97d"}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "int inet_connect_opts(QemuOpts *opts)\n\n{\n\n    struct addrinfo ai,*res,*e;\n\n    const char *addr;\n\n    const char *port;\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int sock,rc;\n\n\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;\n\n    ai.ai_family = PF_UNSPEC;\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    addr = qemu_opt_get(opts, \"host\");\n\n    port = qemu_opt_get(opts, \"port\");\n\n    if (addr == NULL || port == NULL) {\n\n        fprintf(stderr, \"inet_connect: host and/or port not specified\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"ipv4\", 0))\n\n        ai.ai_family = PF_INET;\n\n    if (qemu_opt_get_bool(opts, \"ipv6\", 0))\n\n        ai.ai_family = PF_INET6;\n\n\n\n    /* lookup */\n\n    if (0 != (rc = getaddrinfo(addr, port, &ai, &res))) {\n\n        fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port,\n\n                gai_strerror(rc));\n\n\treturn -1;\n\n    }\n\n    if (sockets_debug)\n\n        inet_print_addrinfo(__FUNCTION__, res);\n\n\n\n    for (e = res; e != NULL; e = e->ai_next) {\n\n        if (getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,\n\n                            uaddr,INET6_ADDRSTRLEN,uport,32,\n\n                            NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n            fprintf(stderr,\"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n            continue;\n\n        }\n\n        sock = socket(e->ai_family, e->ai_socktype, e->ai_protocol);\n\n        if (sock < 0) {\n\n            fprintf(stderr,\"%s: socket(%s): %s\\n\", __FUNCTION__,\n\n            inet_strfamily(e->ai_family), strerror(errno));\n\n            continue;\n\n        }\n\n        setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on));\n\n\n\n        /* connect to peer */\n\n        if (connect(sock,e->ai_addr,e->ai_addrlen) < 0) {\n\n            if (sockets_debug || NULL == e->ai_next)\n\n                fprintf(stderr, \"%s: connect(%s,%s,%s,%s): %s\\n\", __FUNCTION__,\n\n                        inet_strfamily(e->ai_family),\n\n                        e->ai_canonname, uaddr, uport, strerror(errno));\n\n            closesocket(sock);\n\n            continue;\n\n        }\n\n        if (sockets_debug)\n\n            fprintf(stderr, \"%s: connect(%s,%s,%s,%s): OK\\n\", __FUNCTION__,\n\n                    inet_strfamily(e->ai_family),\n\n                    e->ai_canonname, uaddr, uport);\n\n        freeaddrinfo(res);\n\n        return sock;\n\n    }\n\n    freeaddrinfo(res);\n\n    return -1;\n\n}\n", "idx": 26321, "_split": "valid", "_hash": "e8ccfbb1e1c257a9bf8aec6666ece6c5"}
{"project": "qemu", "commit_id": "af60314291af3cabda18d27f928b0e0ff899cc76", "target": 1, "func": "static void vhost_commit(MemoryListener *listener)\n\n{\n\n}\n", "idx": 26331, "_split": "valid", "_hash": "1b6f2d1aeb9a0a2e94bb6c8dd6d66133"}
{"project": "qemu", "commit_id": "7a95434e0ca8a037fd8aa1a2e2461f92585eb77b", "target": 1, "func": "static struct dirent *local_readdir(FsContext *ctx, V9fsFidOpenState *fs)\n\n{\n\n    struct dirent *entry;\n\n\n\nagain:\n\n    entry = readdir(fs->dir.stream);\n\n    if (!entry) {\n\n        return NULL;\n\n    }\n\n\n\n    if (ctx->export_flags & V9FS_SM_MAPPED) {\n\n        entry->d_type = DT_UNKNOWN;\n\n    } else if (ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        if (!strcmp(entry->d_name, VIRTFS_META_DIR)) {\n\n            /* skp the meta data directory */\n\n            goto again;\n\n        }\n\n        entry->d_type = DT_UNKNOWN;\n\n    }\n\n\n\n    return entry;\n\n}\n", "idx": 26346, "_split": "valid", "_hash": "c6bb7da9d59c6a7b59c76b1e62769190"}
{"project": "qemu", "commit_id": "49cffbc6079c27432b4635d5d03ce14a249d86e2", "target": 1, "func": "void virtio_blk_submit_multireq(BlockBackend *blk, MultiReqBuffer *mrb)\n\n{\n\n    int i = 0, start = 0, num_reqs = 0, niov = 0, nb_sectors = 0;\n\n    int max_xfer_len = 0;\n\n    int64_t sector_num = 0;\n\n\n\n    if (mrb->num_reqs == 1) {\n\n        submit_requests(blk, mrb, 0, 1, -1);\n\n        mrb->num_reqs = 0;\n\n        return;\n\n    }\n\n\n\n    max_xfer_len = blk_get_max_transfer_length(mrb->reqs[0]->dev->blk);\n\n    max_xfer_len = MIN_NON_ZERO(max_xfer_len, BDRV_REQUEST_MAX_SECTORS);\n\n\n\n    qsort(mrb->reqs, mrb->num_reqs, sizeof(*mrb->reqs),\n\n          &multireq_compare);\n\n\n\n    for (i = 0; i < mrb->num_reqs; i++) {\n\n        VirtIOBlockReq *req = mrb->reqs[i];\n\n        if (num_reqs > 0) {\n\n            bool merge = true;\n\n\n\n            /* merge would exceed maximum number of IOVs */\n\n            if (niov + req->qiov.niov > IOV_MAX) {\n\n                merge = false;\n\n            }\n\n\n\n            /* merge would exceed maximum transfer length of backend device */\n\n            if (req->qiov.size / BDRV_SECTOR_SIZE + nb_sectors > max_xfer_len) {\n\n                merge = false;\n\n            }\n\n\n\n            /* requests are not sequential */\n\n            if (sector_num + nb_sectors != req->sector_num) {\n\n                merge = false;\n\n            }\n\n\n\n            if (!merge) {\n\n                submit_requests(blk, mrb, start, num_reqs, niov);\n\n                num_reqs = 0;\n\n            }\n\n        }\n\n\n\n        if (num_reqs == 0) {\n\n            sector_num = req->sector_num;\n\n            nb_sectors = niov = 0;\n\n            start = i;\n\n        }\n\n\n\n        nb_sectors += req->qiov.size / BDRV_SECTOR_SIZE;\n\n        niov += req->qiov.niov;\n\n        num_reqs++;\n\n    }\n\n\n\n    submit_requests(blk, mrb, start, num_reqs, niov);\n\n    mrb->num_reqs = 0;\n\n}\n", "idx": 26368, "_split": "valid", "_hash": "60296fb7d8fd2cde4ddb4fe52b49e127"}
{"project": "qemu", "commit_id": "14cec170ea4724e6881ba2febb20e88a942e52d3", "target": 1, "func": "static int xen_pt_bar_reg_read(XenPCIPassthroughState *s, XenPTReg *cfg_entry,\n\n                               uint32_t *value, uint32_t valid_mask)\n\n{\n\n    XenPTRegInfo *reg = cfg_entry->reg;\n\n    uint32_t valid_emu_mask = 0;\n\n    uint32_t bar_emu_mask = 0;\n\n    int index;\n\n\n\n    /* get BAR index */\n\n    index = xen_pt_bar_offset_to_index(reg->offset);\n\n    if (index < 0 || index >= PCI_NUM_REGIONS) {\n\n        XEN_PT_ERR(&s->dev, \"Internal error: Invalid BAR index [%d].\\n\", index);\n\n        return -1;\n\n    }\n\n\n\n    /* use fixed-up value from kernel sysfs */\n\n    *value = base_address_with_flags(&s->real_device.io_regions[index]);\n\n\n\n    /* set emulate mask depend on BAR flag */\n\n    switch (s->bases[index].bar_flag) {\n\n    case XEN_PT_BAR_FLAG_MEM:\n\n        bar_emu_mask = XEN_PT_BAR_MEM_EMU_MASK;\n\n        break;\n\n    case XEN_PT_BAR_FLAG_IO:\n\n        bar_emu_mask = XEN_PT_BAR_IO_EMU_MASK;\n\n        break;\n\n    case XEN_PT_BAR_FLAG_UPPER:\n\n        bar_emu_mask = XEN_PT_BAR_ALLF;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* emulate BAR */\n\n    valid_emu_mask = bar_emu_mask & valid_mask;\n\n    *value = XEN_PT_MERGE_VALUE(*value, cfg_entry->data, ~valid_emu_mask);\n\n\n\n    return 0;\n\n}\n", "idx": 26372, "_split": "valid", "_hash": "5389965cf4785faa2505cf9d474d1778"}
{"project": "qemu", "commit_id": "cdd5cc12ba8cf0c068da319370bdd3ba45eaf7ac", "target": 0, "func": "static int virtio_net_can_receive(VLANClientState *vc)\n\n{\n\n    VirtIONet *n = vc->opaque;\n\n\n\n    return do_virtio_net_can_receive(n, VIRTIO_NET_MAX_BUFSIZE);\n\n}\n", "idx": 26394, "_split": "valid", "_hash": "27b3bfcab6f99624327ee32cc08c1435"}
{"project": "qemu", "commit_id": "544a3731591f5d53e15f22de00ce5ac758d490b3", "target": 1, "func": "bool visit_start_union(Visitor *v, bool data_present, Error **errp)\n\n{\n\n    if (v->start_union) {\n\n        return v->start_union(v, data_present, errp);\n\n    }\n\n    return true;\n\n}\n", "idx": 26426, "_split": "valid", "_hash": "80244e5449883e489d251899e8fc3ec8"}
{"project": "qemu", "commit_id": "062ba099e01ff1474be98c0a4f3da351efab5d9d", "target": 1, "func": "static bool arm_cpu_has_work(CPUState *cs)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n\n\n    return !cpu->powered_off\n\n        && cs->interrupt_request &\n\n        (CPU_INTERRUPT_FIQ | CPU_INTERRUPT_HARD\n\n         | CPU_INTERRUPT_VFIQ | CPU_INTERRUPT_VIRQ\n\n         | CPU_INTERRUPT_EXITTB);\n\n}\n", "idx": 26445, "_split": "valid", "_hash": "8f61d7e89afdec4df8938a8c14987fe8"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "exynos4210_combiner_read(void *opaque, target_phys_addr_t offset, unsigned size)\n\n{\n\n    struct Exynos4210CombinerState *s =\n\n            (struct Exynos4210CombinerState *)opaque;\n\n    uint32_t req_quad_base_n;    /* Base of registers quad. Multiply it by 4 and\n\n                                   get a start of corresponding group quad */\n\n    uint32_t grp_quad_base_n;    /* Base of group quad */\n\n    uint32_t reg_n;              /* Register number inside the quad */\n\n    uint32_t val;\n\n\n\n    req_quad_base_n = offset >> 4;\n\n    grp_quad_base_n = req_quad_base_n << 2;\n\n    reg_n = (offset - (req_quad_base_n << 4)) >> 2;\n\n\n\n    if (req_quad_base_n >= IIC_NGRP) {\n\n        /* Read of ICIPSR register */\n\n        return s->icipsr[reg_n];\n\n    }\n\n\n\n    val = 0;\n\n\n\n    switch (reg_n) {\n\n    /* IISTR */\n\n    case 2:\n\n        val |= s->group[grp_quad_base_n].src_pending;\n\n        val |= s->group[grp_quad_base_n + 1].src_pending << 8;\n\n        val |= s->group[grp_quad_base_n + 2].src_pending << 16;\n\n        val |= s->group[grp_quad_base_n + 3].src_pending << 24;\n\n        break;\n\n    /* IIMSR */\n\n    case 3:\n\n        val |= s->group[grp_quad_base_n].src_mask &\n\n        s->group[grp_quad_base_n].src_pending;\n\n        val |= (s->group[grp_quad_base_n + 1].src_mask &\n\n                s->group[grp_quad_base_n + 1].src_pending) << 8;\n\n        val |= (s->group[grp_quad_base_n + 2].src_mask &\n\n                s->group[grp_quad_base_n + 2].src_pending) << 16;\n\n        val |= (s->group[grp_quad_base_n + 3].src_mask &\n\n                s->group[grp_quad_base_n + 3].src_pending) << 24;\n\n        break;\n\n    default:\n\n        if (offset >> 2 >= IIC_REGSET_SIZE) {\n\n            hw_error(\"exynos4210.combiner: overflow of reg_set by 0x\"\n\n                    TARGET_FMT_plx \"offset\\n\", offset);\n\n        }\n\n        val = s->reg_set[offset >> 2];\n\n        return 0;\n\n    }\n\n    return val;\n\n}\n", "idx": 26452, "_split": "valid", "_hash": "d8695e9a09ef94e8e3e09a30e5dbad23"}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static inline void gen_movcf_d (DisasContext *ctx, int fs, int fd, int cc, int tf)\n\n{\n\n    int cond;\n\n    TCGv_i32 t0 = tcg_temp_new_i32();\n\n    TCGv_i64 fp0;\n\n    int l1 = gen_new_label();\n\n\n\n    if (tf)\n\n        cond = TCG_COND_EQ;\n\n    else\n\n        cond = TCG_COND_NE;\n\n\n\n    tcg_gen_andi_i32(t0, fpu_fcr31, 1 << get_fp_bit(cc));\n\n    tcg_gen_brcondi_i32(cond, t0, 0, l1);\n\n    tcg_temp_free_i32(t0);\n\n    fp0 = tcg_temp_new_i64();\n\n    gen_load_fpr64(ctx, fp0, fs);\n\n    gen_store_fpr64(ctx, fp0, fd);\n\n    tcg_temp_free_i64(fp0);\n\n    gen_set_label(l1);\n\n}\n", "idx": 26463, "_split": "valid", "_hash": "39b6bd7f8a47ae46b541c61839c1bf10"}
{"project": "qemu", "commit_id": "b131c74a0e485b084ddaffc8214c8a19af492be7", "target": 0, "func": "int kvm_irqchip_remove_irqfd(KVMState *s, int fd, int virq)\n\n{\n\n    return -ENOSYS;\n\n}\n", "idx": 26464, "_split": "valid", "_hash": "8007ff21c222b5a0b58bec9fb6e02b84"}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static void noop_conv (st_sample_t *dst, const void *src,\n\n                       int samples, volume_t *vol)\n\n{\n\n    (void) src;\n\n    (void) dst;\n\n    (void) samples;\n\n    (void) vol;\n\n}\n", "idx": 26465, "_split": "valid", "_hash": "cb461adf282eeb525c8b1e6067a9508f"}
{"project": "qemu", "commit_id": "9bb34eac8b89f624776ce6604c22d7c3097a1e24", "target": 0, "func": "static void vga_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    CirrusVGAState *s = opaque;\n\n    int index;\n\n\n\n    /* check port range access depending on color/monochrome mode */\n\n    if ((addr >= 0x3b0 && addr <= 0x3bf && (s->msr & MSR_COLOR_EMULATION))\n\n\t|| (addr >= 0x3d0 && addr <= 0x3df\n\n\t    && !(s->msr & MSR_COLOR_EMULATION)))\n\n\treturn;\n\n\n\n#ifdef DEBUG_VGA\n\n    printf(\"VGA: write addr=0x%04x data=0x%02x\\n\", addr, val);\n\n#endif\n\n\n\n    switch (addr) {\n\n    case 0x3c0:\n\n\tif (s->ar_flip_flop == 0) {\n\n\t    val &= 0x3f;\n\n\t    s->ar_index = val;\n\n\t} else {\n\n\t    index = s->ar_index & 0x1f;\n\n\t    switch (index) {\n\n\t    case 0x00 ... 0x0f:\n\n\t\ts->ar[index] = val & 0x3f;\n\n\t\tbreak;\n\n\t    case 0x10:\n\n\t\ts->ar[index] = val & ~0x10;\n\n\t\tbreak;\n\n\t    case 0x11:\n\n\t\ts->ar[index] = val;\n\n\t\tbreak;\n\n\t    case 0x12:\n\n\t\ts->ar[index] = val & ~0xc0;\n\n\t\tbreak;\n\n\t    case 0x13:\n\n\t\ts->ar[index] = val & ~0xf0;\n\n\t\tbreak;\n\n\t    case 0x14:\n\n\t\ts->ar[index] = val & ~0xf0;\n\n\t\tbreak;\n\n\t    default:\n\n\t\tbreak;\n\n\t    }\n\n\t}\n\n\ts->ar_flip_flop ^= 1;\n\n\tbreak;\n\n    case 0x3c2:\n\n\ts->msr = val & ~0x10;\n\n\tbreak;\n\n    case 0x3c4:\n\n\ts->sr_index = val;\n\n\tbreak;\n\n    case 0x3c5:\n\n\tif (cirrus_hook_write_sr(s, s->sr_index, val))\n\n\t    break;\n\n#ifdef DEBUG_VGA_REG\n\n\tprintf(\"vga: write SR%x = 0x%02x\\n\", s->sr_index, val);\n\n#endif\n\n\ts->sr[s->sr_index] = val & sr_mask[s->sr_index];\n\n\tbreak;\n\n    case 0x3c6:\n\n\tcirrus_write_hidden_dac(s, val);\n\n\tbreak;\n\n    case 0x3c7:\n\n\ts->dac_read_index = val;\n\n\ts->dac_sub_index = 0;\n\n\ts->dac_state = 3;\n\n\tbreak;\n\n    case 0x3c8:\n\n\ts->dac_write_index = val;\n\n\ts->dac_sub_index = 0;\n\n\ts->dac_state = 0;\n\n\tbreak;\n\n    case 0x3c9:\n\n\tif (cirrus_hook_write_palette(s, val))\n\n\t    break;\n\n\ts->dac_cache[s->dac_sub_index] = val;\n\n\tif (++s->dac_sub_index == 3) {\n\n\t    memcpy(&s->palette[s->dac_write_index * 3], s->dac_cache, 3);\n\n\t    s->dac_sub_index = 0;\n\n\t    s->dac_write_index++;\n\n\t}\n\n\tbreak;\n\n    case 0x3ce:\n\n\ts->gr_index = val;\n\n\tbreak;\n\n    case 0x3cf:\n\n\tif (cirrus_hook_write_gr(s, s->gr_index, val))\n\n\t    break;\n\n#ifdef DEBUG_VGA_REG\n\n\tprintf(\"vga: write GR%x = 0x%02x\\n\", s->gr_index, val);\n\n#endif\n\n\ts->gr[s->gr_index] = val & gr_mask[s->gr_index];\n\n\tbreak;\n\n    case 0x3b4:\n\n    case 0x3d4:\n\n\ts->cr_index = val;\n\n\tbreak;\n\n    case 0x3b5:\n\n    case 0x3d5:\n\n\tif (cirrus_hook_write_cr(s, s->cr_index, val))\n\n\t    break;\n\n#ifdef DEBUG_VGA_REG\n\n\tprintf(\"vga: write CR%x = 0x%02x\\n\", s->cr_index, val);\n\n#endif\n\n\t/* handle CR0-7 protection */\n\n\tif ((s->cr[11] & 0x80) && s->cr_index <= 7) {\n\n\t    /* can always write bit 4 of CR7 */\n\n\t    if (s->cr_index == 7)\n\n\t\ts->cr[7] = (s->cr[7] & ~0x10) | (val & 0x10);\n\n\t    return;\n\n\t}\n\n\tswitch (s->cr_index) {\n\n\tcase 0x01:\t\t/* horizontal display end */\n\n\tcase 0x07:\n\n\tcase 0x09:\n\n\tcase 0x0c:\n\n\tcase 0x0d:\n\n\tcase 0x12:\t\t/* veritcal display end */\n\n\t    s->cr[s->cr_index] = val;\n\n\t    break;\n\n\n\n\tdefault:\n\n\t    s->cr[s->cr_index] = val;\n\n\t    break;\n\n\t}\n\n\tbreak;\n\n    case 0x3ba:\n\n    case 0x3da:\n\n\ts->fcr = val & 0x10;\n\n\tbreak;\n\n    }\n\n}\n", "idx": 26479, "_split": "valid", "_hash": "92bdfc41e9f3391f1a58251e70a7f055"}
{"project": "qemu", "commit_id": "81b23ef82cd1be29ca3d69ab7e98b5b5e55926ce", "target": 1, "func": "static int xen_pt_cmd_reg_read(XenPCIPassthroughState *s, XenPTReg *cfg_entry,\n\n                               uint16_t *value, uint16_t valid_mask)\n\n{\n\n    XenPTRegInfo *reg = cfg_entry->reg;\n\n    uint16_t valid_emu_mask = 0;\n\n    uint16_t emu_mask = reg->emu_mask;\n\n\n\n    if (s->is_virtfn) {\n\n        emu_mask |= PCI_COMMAND_MEMORY;\n\n    }\n\n\n\n    /* emulate word register */\n\n    valid_emu_mask = emu_mask & valid_mask;\n\n    *value = XEN_PT_MERGE_VALUE(*value, cfg_entry->data, ~valid_emu_mask);\n\n\n\n    return 0;\n\n}\n", "idx": 26509, "_split": "valid", "_hash": "b917122ae4e3dd749075ded7b902a584"}
{"project": "qemu", "commit_id": "06b1297017415ae6a07a0e97ad7d8e90b2d95823", "target": 1, "func": "static int virtio_net_has_buffers(VirtIONet *n, int bufsize)\n\n{\n\n    if (virtio_queue_empty(n->rx_vq) ||\n\n        (n->mergeable_rx_bufs &&\n\n         !virtqueue_avail_bytes(n->rx_vq, bufsize, 0))) {\n\n        virtio_queue_set_notification(n->rx_vq, 1);\n\n        return 0;\n\n    }\n\n\n\n    virtio_queue_set_notification(n->rx_vq, 0);\n\n    return 1;\n\n}\n", "idx": 26516, "_split": "valid", "_hash": "4cdaf8075825536547054e0864271c06"}
{"project": "qemu", "commit_id": "9561fda8d90e176bef598ba87c42a1bd6ad03ef7", "target": 1, "func": "static void qbus_initfn(Object *obj)\n\n{\n\n    BusState *bus = BUS(obj);\n\n\n\n    QTAILQ_INIT(&bus->children);\n\n    object_property_add_link(obj, QDEV_HOTPLUG_HANDLER_PROPERTY,\n\n                             TYPE_HOTPLUG_HANDLER,\n\n                             (Object **)&bus->hotplug_handler, NULL);\n\n    object_property_add_bool(obj, \"realized\",\n\n                             bus_get_realized, bus_set_realized, NULL);\n\n}\n", "idx": 26522, "_split": "valid", "_hash": "7e74edf4dad4a37177eee4f264ccb71a"}
{"project": "qemu", "commit_id": "3af9187fc6caaf415ab9c0c6d92c9678f65cb17f", "target": 1, "func": "static ssize_t mipsnet_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n\n{\n\n    MIPSnetState *s = qemu_get_nic_opaque(nc);\n\n\n\n    trace_mipsnet_receive(size);\n\n    if (!mipsnet_can_receive(nc))\n\n\n\n\n\n\n\n    s->busy = 1;\n\n\n\n    /* Just accept everything. */\n\n\n\n    /* Write packet data. */\n\n    memcpy(s->rx_buffer, buf, size);\n\n\n\n    s->rx_count = size;\n\n    s->rx_read = 0;\n\n\n\n    /* Now we can signal we have received something. */\n\n    s->intctl |= MIPSNET_INTCTL_RXDONE;\n\n    mipsnet_update_irq(s);\n\n\n\n    return size;\n", "idx": 26527, "_split": "valid", "_hash": "90915fbe0e9c3cbf77343816798d5729"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_tipb_bridge_s *omap_tipb_bridge_init(\n\n    MemoryRegion *memory, target_phys_addr_t base,\n\n    qemu_irq abort_irq, omap_clk clk)\n\n{\n\n    struct omap_tipb_bridge_s *s = (struct omap_tipb_bridge_s *)\n\n            g_malloc0(sizeof(struct omap_tipb_bridge_s));\n\n\n\n    s->abort = abort_irq;\n\n    omap_tipb_bridge_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_tipb_bridge_ops, s,\n\n                          \"omap-tipb-bridge\", 0x100);\n\n    memory_region_add_subregion(memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 26566, "_split": "valid", "_hash": "2882b7274860a988f19214c58e1142f8"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void thread_pool_submit(ThreadPool *pool, ThreadPoolFunc *func, void *arg)\n\n{\n\n    thread_pool_submit_aio(pool, func, arg, NULL, NULL);\n\n}\n", "idx": 26569, "_split": "valid", "_hash": "083bae8df2f66b9b029baa9114628a78"}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_writev_vmstate(BlockDriverState *bs, QEMUIOVector *qiov, int64_t pos)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    } else if (drv->bdrv_save_vmstate) {\n\n        return drv->bdrv_save_vmstate(bs, qiov, pos);\n\n    } else if (bs->file) {\n\n        return bdrv_writev_vmstate(bs->file, qiov, pos);\n\n    }\n\n\n\n    return -ENOTSUP;\n\n}\n", "idx": 26573, "_split": "valid", "_hash": "c27fe351deae46f39c107fdebe350c8e"}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_statfs(FsContext *s, V9fsPath *fs_path, struct statfs *stbuf)\n\n{\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    return statfs(rpath(s, path, buffer), stbuf);\n\n}\n", "idx": 26576, "_split": "valid", "_hash": "abadcabad7e1a3dbe00c4169808669ac"}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static int kvm_get_msr(CPUState *env, struct kvm_msr_entry *msrs, int n)\n\n{\n\n    struct kvm_msrs *kmsrs = qemu_malloc(sizeof *kmsrs + n * sizeof *msrs);\n\n    int r;\n\n\n\n    kmsrs->nmsrs = n;\n\n    memcpy(kmsrs->entries, msrs, n * sizeof *msrs);\n\n    r = kvm_vcpu_ioctl(env, KVM_GET_MSRS, kmsrs);\n\n    memcpy(msrs, kmsrs->entries, n * sizeof *msrs);\n\n    free(kmsrs);\n\n    return r;\n\n}\n", "idx": 26600, "_split": "valid", "_hash": "efe554e6f2241524482ab7f2d11496c8"}
{"project": "qemu", "commit_id": "cfdf2c40577ed99bb19cdc05d0537e2808d77a78", "target": 0, "func": "static void do_balloon(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    int value = qdict_get_int(qdict, \"value\");\n\n    ram_addr_t target = value;\n\n    qemu_balloon(target << 20);\n\n}\n", "idx": 26606, "_split": "valid", "_hash": "0b1b0912ba5c9a4fe6e4db078c2e842d"}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "FWCfgState *pc_memory_init(PCMachineState *pcms,\n\n                           MemoryRegion *system_memory,\n\n                           MemoryRegion *rom_memory,\n\n                           MemoryRegion **ram_memory,\n\n                           PcGuestInfo *guest_info)\n\n{\n\n    int linux_boot, i;\n\n    MemoryRegion *ram, *option_rom_mr;\n\n    MemoryRegion *ram_below_4g, *ram_above_4g;\n\n    FWCfgState *fw_cfg;\n\n    MachineState *machine = MACHINE(pcms);\n\n\n\n    assert(machine->ram_size == pcms->below_4g_mem_size +\n\n                                pcms->above_4g_mem_size);\n\n\n\n    linux_boot = (machine->kernel_filename != NULL);\n\n\n\n    /* Allocate RAM.  We allocate it as a single memory region and use\n\n     * aliases to address portions of it, mostly for backwards compatibility\n\n     * with older qemus that used qemu_ram_alloc().\n\n     */\n\n    ram = g_malloc(sizeof(*ram));\n\n    memory_region_allocate_system_memory(ram, NULL, \"pc.ram\",\n\n                                         machine->ram_size);\n\n    *ram_memory = ram;\n\n    ram_below_4g = g_malloc(sizeof(*ram_below_4g));\n\n    memory_region_init_alias(ram_below_4g, NULL, \"ram-below-4g\", ram,\n\n                             0, pcms->below_4g_mem_size);\n\n    memory_region_add_subregion(system_memory, 0, ram_below_4g);\n\n    e820_add_entry(0, pcms->below_4g_mem_size, E820_RAM);\n\n    if (pcms->above_4g_mem_size > 0) {\n\n        ram_above_4g = g_malloc(sizeof(*ram_above_4g));\n\n        memory_region_init_alias(ram_above_4g, NULL, \"ram-above-4g\", ram,\n\n                                 pcms->below_4g_mem_size,\n\n                                 pcms->above_4g_mem_size);\n\n        memory_region_add_subregion(system_memory, 0x100000000ULL,\n\n                                    ram_above_4g);\n\n        e820_add_entry(0x100000000ULL, pcms->above_4g_mem_size, E820_RAM);\n\n    }\n\n\n\n    if (!guest_info->has_reserved_memory &&\n\n        (machine->ram_slots ||\n\n         (machine->maxram_size > machine->ram_size))) {\n\n        MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n\n\n        error_report(\"\\\"-memory 'slots|maxmem'\\\" is not supported by: %s\",\n\n                     mc->name);\n\n        exit(EXIT_FAILURE);\n\n    }\n\n\n\n    /* initialize hotplug memory address space */\n\n    if (guest_info->has_reserved_memory &&\n\n        (machine->ram_size < machine->maxram_size)) {\n\n        ram_addr_t hotplug_mem_size =\n\n            machine->maxram_size - machine->ram_size;\n\n\n\n        if (machine->ram_slots > ACPI_MAX_RAM_SLOTS) {\n\n            error_report(\"unsupported amount of memory slots: %\"PRIu64,\n\n                         machine->ram_slots);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n\n\n        if (QEMU_ALIGN_UP(machine->maxram_size,\n\n                          TARGET_PAGE_SIZE) != machine->maxram_size) {\n\n            error_report(\"maximum memory size must by aligned to multiple of \"\n\n                         \"%d bytes\", TARGET_PAGE_SIZE);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n\n\n        pcms->hotplug_memory.base =\n\n            ROUND_UP(0x100000000ULL + pcms->above_4g_mem_size, 1ULL << 30);\n\n\n\n        if (pcms->enforce_aligned_dimm) {\n\n            /* size hotplug region assuming 1G page max alignment per slot */\n\n            hotplug_mem_size += (1ULL << 30) * machine->ram_slots;\n\n        }\n\n\n\n        if ((pcms->hotplug_memory.base + hotplug_mem_size) <\n\n            hotplug_mem_size) {\n\n            error_report(\"unsupported amount of maximum memory: \" RAM_ADDR_FMT,\n\n                         machine->maxram_size);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n\n\n        memory_region_init(&pcms->hotplug_memory.mr, OBJECT(pcms),\n\n                           \"hotplug-memory\", hotplug_mem_size);\n\n        memory_region_add_subregion(system_memory, pcms->hotplug_memory.base,\n\n                                    &pcms->hotplug_memory.mr);\n\n    }\n\n\n\n    /* Initialize PC system firmware */\n\n    pc_system_firmware_init(rom_memory, guest_info->isapc_ram_fw);\n\n\n\n    option_rom_mr = g_malloc(sizeof(*option_rom_mr));\n\n    memory_region_init_ram(option_rom_mr, NULL, \"pc.rom\", PC_ROM_SIZE,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(option_rom_mr);\n\n    memory_region_add_subregion_overlap(rom_memory,\n\n                                        PC_ROM_MIN_VGA,\n\n                                        option_rom_mr,\n\n                                        1);\n\n\n\n    fw_cfg = bochs_bios_init();\n\n    rom_set_fw(fw_cfg);\n\n\n\n    if (guest_info->has_reserved_memory && pcms->hotplug_memory.base) {\n\n        uint64_t *val = g_malloc(sizeof(*val));\n\n        PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(pcms);\n\n        uint64_t res_mem_end = pcms->hotplug_memory.base;\n\n\n\n        if (!pcmc->broken_reserved_end) {\n\n            res_mem_end += memory_region_size(&pcms->hotplug_memory.mr);\n\n        }\n\n        *val = cpu_to_le64(ROUND_UP(res_mem_end, 0x1ULL << 30));\n\n        fw_cfg_add_file(fw_cfg, \"etc/reserved-memory-end\", val, sizeof(*val));\n\n    }\n\n\n\n    if (linux_boot) {\n\n        load_linux(pcms, fw_cfg);\n\n    }\n\n\n\n    for (i = 0; i < nb_option_roms; i++) {\n\n        rom_add_option(option_rom[i].name, option_rom[i].bootindex);\n\n    }\n\n    guest_info->fw_cfg = fw_cfg;\n\n    return fw_cfg;\n\n}\n", "idx": 26616, "_split": "valid", "_hash": "f85ebd27874b06d478b7352b52425a19"}
{"project": "qemu", "commit_id": "1d2acc3162d9c7772510c973f446353fbdd1f9a8", "target": 1, "func": "static void migrate_fd_cancel(MigrationState *s)\n{\n    int old_state ;\n    QEMUFile *f = migrate_get_current()->to_dst_file;\n    trace_migrate_fd_cancel();\n    if (s->rp_state.from_dst_file) {\n        /* shutdown the rp socket, so causing the rp thread to shutdown */\n        qemu_file_shutdown(s->rp_state.from_dst_file);\n    do {\n        old_state = s->state;\n        if (!migration_is_setup_or_active(old_state)) {\n            break;\n        migrate_set_state(&s->state, old_state, MIGRATION_STATUS_CANCELLING);\n    } while (s->state != MIGRATION_STATUS_CANCELLING);\n    /*\n     * If we're unlucky the migration code might be stuck somewhere in a\n     * send/write while the network has failed and is waiting to timeout;\n     * if we've got shutdown(2) available then we can force it to quit.\n     * The outgoing qemu file gets closed in migrate_fd_cleanup that is\n     * called in a bh, so there is no race against this cancel.\n     */\n    if (s->state == MIGRATION_STATUS_CANCELLING && f) {\n        qemu_file_shutdown(f);", "idx": 26619, "_split": "valid", "_hash": "c4ac4bb92a4326527dd28146fa9122c9"}
{"project": "qemu", "commit_id": "bf55b7afce53718ef96f4e6616da62c0ccac37dd", "target": 0, "func": "static IOMMUTLBEntry vtd_iommu_translate(MemoryRegion *iommu, hwaddr addr,\n\n                                         bool is_write)\n\n{\n\n    VTDAddressSpace *vtd_as = container_of(iommu, VTDAddressSpace, iommu);\n\n    IntelIOMMUState *s = vtd_as->iommu_state;\n\n    IOMMUTLBEntry ret = {\n\n        .target_as = &address_space_memory,\n\n        .iova = addr,\n\n        .translated_addr = 0,\n\n        .addr_mask = ~(hwaddr)0,\n\n        .perm = IOMMU_NONE,\n\n    };\n\n\n\n    if (!s->dmar_enabled) {\n\n        /* DMAR disabled, passthrough, use 4k-page*/\n\n        ret.iova = addr & VTD_PAGE_MASK_4K;\n\n        ret.translated_addr = addr & VTD_PAGE_MASK_4K;\n\n        ret.addr_mask = ~VTD_PAGE_MASK_4K;\n\n        ret.perm = IOMMU_RW;\n\n        return ret;\n\n    }\n\n\n\n    vtd_do_iommu_translate(vtd_as, vtd_as->bus, vtd_as->devfn, addr,\n\n                           is_write, &ret);\n\n    VTD_DPRINTF(MMU,\n\n                \"bus %\"PRIu8 \" slot %\"PRIu8 \" func %\"PRIu8 \" devfn %\"PRIu8\n\n                \" iova 0x%\"PRIx64 \" hpa 0x%\"PRIx64, pci_bus_num(vtd_as->bus),\n\n                VTD_PCI_SLOT(vtd_as->devfn), VTD_PCI_FUNC(vtd_as->devfn),\n\n                vtd_as->devfn, addr, ret.translated_addr);\n\n    return ret;\n\n}\n", "idx": 26646, "_split": "valid", "_hash": "a0465c37fd7797bf0527ee92241231f7"}
{"project": "qemu", "commit_id": "d185c094b404b4ff392b77d1244c0233da7d53bd", "target": 0, "func": "static gboolean io_watch_poll_check(GSource *source)\n\n{\n\n    IOWatchPoll *iwp = io_watch_poll_from_source(source);\n\n\n\n    if (iwp->max_size == 0) {\n\n        return FALSE;\n\n    }\n\n\n\n    return g_io_watch_funcs.check(source);\n\n}\n", "idx": 26647, "_split": "valid", "_hash": "ef7ead95b2e6ed9a3421584a050119f4"}
{"project": "qemu", "commit_id": "240f64b6dc3346d044d7beb7cc3a53668ce47384", "target": 0, "func": "void qmp_object_add(const char *type, const char *id,\n\n                    bool has_props, QObject *props, Error **errp)\n\n{\n\n    const QDict *pdict = NULL;\n\n    QmpInputVisitor *qiv;\n\n    Object *obj;\n\n\n\n    if (props) {\n\n        pdict = qobject_to_qdict(props);\n\n        if (!pdict) {\n\n            error_setg(errp, QERR_INVALID_PARAMETER_TYPE, \"props\", \"dict\");\n\n            return;\n\n        }\n\n    }\n\n\n\n    qiv = qmp_input_visitor_new(props, false);\n\n    obj = user_creatable_add_type(type, id, pdict,\n\n                                  qmp_input_get_visitor(qiv), errp);\n\n    qmp_input_visitor_cleanup(qiv);\n\n    if (obj) {\n\n        object_unref(obj);\n\n    }\n\n}\n", "idx": 26676, "_split": "valid", "_hash": "9c6606cfb5364db0b03970e06924d1e6"}
{"project": "qemu", "commit_id": "f6bb84d53110398f4899c19dab4e0fe9908ec060", "target": 1, "func": "static inline TranslationBlock *tb_find(CPUState *cpu,\n\n                                        TranslationBlock *last_tb,\n\n                                        int tb_exit)\n\n{\n\n    CPUArchState *env = (CPUArchState *)cpu->env_ptr;\n\n    TranslationBlock *tb;\n\n    target_ulong cs_base, pc;\n\n    uint32_t flags;\n\n    bool acquired_tb_lock = false;\n\n\n\n    /* we record a subset of the CPU state. It will\n\n       always be the same before a given translated block\n\n       is executed. */\n\n    cpu_get_tb_cpu_state(env, &pc, &cs_base, &flags);\n\n    tb = atomic_rcu_read(&cpu->tb_jmp_cache[tb_jmp_cache_hash_func(pc)]);\n\n    if (unlikely(!tb || tb->pc != pc || tb->cs_base != cs_base ||\n\n                 tb->flags != flags ||\n\n                 tb->trace_vcpu_dstate != *cpu->trace_dstate)) {\n\n        tb = tb_htable_lookup(cpu, pc, cs_base, flags);\n\n        if (!tb) {\n\n\n\n            /* mmap_lock is needed by tb_gen_code, and mmap_lock must be\n\n             * taken outside tb_lock. As system emulation is currently\n\n             * single threaded the locks are NOPs.\n\n             */\n\n            mmap_lock();\n\n            tb_lock();\n\n            acquired_tb_lock = true;\n\n\n\n            /* There's a chance that our desired tb has been translated while\n\n             * taking the locks so we check again inside the lock.\n\n             */\n\n            tb = tb_htable_lookup(cpu, pc, cs_base, flags);\n\n            if (!tb) {\n\n                /* if no translated code available, then translate it now */\n\n                tb = tb_gen_code(cpu, pc, cs_base, flags, 0);\n\n            }\n\n\n\n            mmap_unlock();\n\n        }\n\n\n\n        /* We add the TB in the virtual pc hash table for the fast lookup */\n\n        atomic_set(&cpu->tb_jmp_cache[tb_jmp_cache_hash_func(pc)], tb);\n\n    }\n\n#ifndef CONFIG_USER_ONLY\n\n    /* We don't take care of direct jumps when address mapping changes in\n\n     * system emulation. So it's not safe to make a direct jump to a TB\n\n     * spanning two pages because the mapping for the second page can change.\n\n     */\n\n    if (tb->page_addr[1] != -1) {\n\n        last_tb = NULL;\n\n    }\n\n#endif\n\n    /* See if we can patch the calling TB. */\n\n    if (last_tb && !qemu_loglevel_mask(CPU_LOG_TB_NOCHAIN)) {\n\n        if (!acquired_tb_lock) {\n\n            tb_lock();\n\n            acquired_tb_lock = true;\n\n        }\n\n        if (!tb->invalid) {\n\n            tb_add_jump(last_tb, tb_exit, tb);\n\n        }\n\n    }\n\n    if (acquired_tb_lock) {\n\n        tb_unlock();\n\n    }\n\n    return tb;\n\n}\n", "idx": 26715, "_split": "valid", "_hash": "14ba9f69b9f1261fdb0dd43c62bfb2bb"}
{"project": "qemu", "commit_id": "73479c5c87bf431c6344a80ab01456ed979447f1", "target": 1, "func": "void superh_cpu_do_interrupt(CPUState *cs)\n\n{\n\n    SuperHCPU *cpu = SUPERH_CPU(cs);\n\n    CPUSH4State *env = &cpu->env;\n\n    int do_irq = cs->interrupt_request & CPU_INTERRUPT_HARD;\n\n    int do_exp, irq_vector = cs->exception_index;\n\n\n\n    /* prioritize exceptions over interrupts */\n\n\n\n    do_exp = cs->exception_index != -1;\n\n    do_irq = do_irq && (cs->exception_index == -1);\n\n\n\n    if (env->sr & (1u << SR_BL)) {\n\n        if (do_exp && cs->exception_index != 0x1e0) {\n\n            cs->exception_index = 0x000; /* masked exception -> reset */\n\n        }\n\n        if (do_irq && !env->in_sleep) {\n\n            return; /* masked */\n\n        }\n\n    }\n\n    env->in_sleep = 0;\n\n\n\n    if (do_irq) {\n\n        irq_vector = sh_intc_get_pending_vector(env->intc_handle,\n\n\t\t\t\t\t\t(env->sr >> 4) & 0xf);\n\n        if (irq_vector == -1) {\n\n            return; /* masked */\n\n\t}\n\n    }\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_INT)) {\n\n\tconst char *expname;\n\n        switch (cs->exception_index) {\n\n\tcase 0x0e0:\n\n\t    expname = \"addr_error\";\n\n\t    break;\n\n\tcase 0x040:\n\n\t    expname = \"tlb_miss\";\n\n\t    break;\n\n\tcase 0x0a0:\n\n\t    expname = \"tlb_violation\";\n\n\t    break;\n\n\tcase 0x180:\n\n\t    expname = \"illegal_instruction\";\n\n\t    break;\n\n\tcase 0x1a0:\n\n\t    expname = \"slot_illegal_instruction\";\n\n\t    break;\n\n\tcase 0x800:\n\n\t    expname = \"fpu_disable\";\n\n\t    break;\n\n\tcase 0x820:\n\n\t    expname = \"slot_fpu\";\n\n\t    break;\n\n\tcase 0x100:\n\n\t    expname = \"data_write\";\n\n\t    break;\n\n\tcase 0x060:\n\n\t    expname = \"dtlb_miss_write\";\n\n\t    break;\n\n\tcase 0x0c0:\n\n\t    expname = \"dtlb_violation_write\";\n\n\t    break;\n\n\tcase 0x120:\n\n\t    expname = \"fpu_exception\";\n\n\t    break;\n\n\tcase 0x080:\n\n\t    expname = \"initial_page_write\";\n\n\t    break;\n\n\tcase 0x160:\n\n\t    expname = \"trapa\";\n\n\t    break;\n\n\tdefault:\n\n            expname = do_irq ? \"interrupt\" : \"???\";\n\n            break;\n\n\t}\n\n\tqemu_log(\"exception 0x%03x [%s] raised\\n\",\n\n\t\t  irq_vector, expname);\n\n        log_cpu_state(cs, 0);\n\n    }\n\n\n\n    env->ssr = cpu_read_sr(env);\n\n    env->spc = env->pc;\n\n    env->sgr = env->gregs[15];\n\n    env->sr |= (1u << SR_BL) | (1u << SR_MD) | (1u << SR_RB);\n\n\n\n    if (env->flags & (DELAY_SLOT | DELAY_SLOT_CONDITIONAL)) {\n\n        /* Branch instruction should be executed again before delay slot. */\n\n\tenv->spc -= 2;\n\n\t/* Clear flags for exception/interrupt routine. */\n\n        env->flags &= ~(DELAY_SLOT | DELAY_SLOT_CONDITIONAL);\n\n    }\n\n\n\n    if (do_exp) {\n\n        env->expevt = cs->exception_index;\n\n        switch (cs->exception_index) {\n\n        case 0x000:\n\n        case 0x020:\n\n        case 0x140:\n\n            env->sr &= ~(1u << SR_FD);\n\n            env->sr |= 0xf << 4; /* IMASK */\n\n            env->pc = 0xa0000000;\n\n            break;\n\n        case 0x040:\n\n        case 0x060:\n\n            env->pc = env->vbr + 0x400;\n\n            break;\n\n        case 0x160:\n\n            env->spc += 2; /* special case for TRAPA */\n\n            /* fall through */\n\n        default:\n\n            env->pc = env->vbr + 0x100;\n\n            break;\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (do_irq) {\n\n        env->intevt = irq_vector;\n\n        env->pc = env->vbr + 0x600;\n\n        return;\n\n    }\n\n}\n", "idx": 26739, "_split": "valid", "_hash": "3059c2ba57e83ebc4550afae12f7a31c"}
{"project": "qemu", "commit_id": "f332e830e38b3ff3953ef02ac04e409ae53769c5", "target": 1, "func": "static void parse_type_size(Visitor *v, const char *name, uint64_t *obj,\n\n                            Error **errp)\n\n{\n\n    StringInputVisitor *siv = to_siv(v);\n\n    Error *err = NULL;\n\n    uint64_t val;\n\n\n\n    if (siv->string) {\n\n        parse_option_size(name, siv->string, &val, &err);\n\n    } else {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"size\");\n\n        return;\n\n    }\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    *obj = val;\n\n}\n", "idx": 26754, "_split": "valid", "_hash": "51ddbde95c855a38524ad10602ba322f"}
{"project": "qemu", "commit_id": "da98c8eb4c35225049cad8cf767647eb39788b5d", "target": 0, "func": "void acpi_pm1_cnt_init(ACPIREGS *ar, qemu_irq cmos_s3)\n\n{\n\n    ar->pm1.cnt.cmos_s3 = cmos_s3;\n\n}\n", "idx": 26791, "_split": "valid", "_hash": "9a5179fee7a82e622c02db454c9a527a"}
{"project": "qemu", "commit_id": "4083733db5e4120939acee57019ff52db1f45b9d", "target": 0, "func": "static void console_refresh(QemuConsole *s)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s);\n\n    TextCell *c;\n\n    int x, y, y1;\n\n\n\n    if (s->ds->have_text) {\n\n        s->text_x[0] = 0;\n\n        s->text_y[0] = 0;\n\n        s->text_x[1] = s->width - 1;\n\n        s->text_y[1] = s->height - 1;\n\n        s->cursor_invalidate = 1;\n\n    }\n\n\n\n    vga_fill_rect(s, 0, 0, surface_width(surface), surface_height(surface),\n\n                  color_table_rgb[0][COLOR_BLACK]);\n\n    y1 = s->y_displayed;\n\n    for (y = 0; y < s->height; y++) {\n\n        c = s->cells + y1 * s->width;\n\n        for (x = 0; x < s->width; x++) {\n\n            vga_putcharxy(s, x, y, c->ch,\n\n                          &(c->t_attrib));\n\n            c++;\n\n        }\n\n        if (++y1 == s->total_height) {\n\n            y1 = 0;\n\n        }\n\n    }\n\n    console_show_cursor(s, 1);\n\n    dpy_gfx_update(s, 0, 0,\n\n                   surface_width(surface), surface_height(surface));\n\n}\n", "idx": 26807, "_split": "valid", "_hash": "f125700d78909ec1e50167c8df587dab"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void qemu_init_child_watch(void)\n\n{\n\n    struct sigaction act;\n\n    sigchld_bh = qemu_bh_new(sigchld_bh_handler, NULL);\n\n\n\n    memset(&act, 0, sizeof(act));\n\n    act.sa_handler = sigchld_handler;\n\n    act.sa_flags = SA_NOCLDSTOP;\n\n    sigaction(SIGCHLD, &act, NULL);\n\n}\n", "idx": 26808, "_split": "valid", "_hash": "fc03f102be0e311e60ba8c857de44d01"}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "int vnc_tls_client_setup(VncState *vs,\n\n                         int needX509Creds) {\n\n    VNC_DEBUG(\"Do TLS setup\\n\");\n\n    if (vnc_tls_initialize() < 0) {\n\n        VNC_DEBUG(\"Failed to init TLS\\n\");\n\n        vnc_client_error(vs);\n\n        return -1;\n\n    }\n\n    if (vs->tls.session == NULL) {\n\n        if (gnutls_init(&vs->tls.session, GNUTLS_SERVER) < 0) {\n\n            vnc_client_error(vs);\n\n            return -1;\n\n        }\n\n\n\n        if (gnutls_set_default_priority(vs->tls.session) < 0) {\n\n            gnutls_deinit(vs->tls.session);\n\n            vs->tls.session = NULL;\n\n            vnc_client_error(vs);\n\n            return -1;\n\n        }\n\n\n\n        if (vnc_set_gnutls_priority(vs->tls.session, needX509Creds) < 0) {\n\n            gnutls_deinit(vs->tls.session);\n\n            vs->tls.session = NULL;\n\n            vnc_client_error(vs);\n\n            return -1;\n\n        }\n\n\n\n        if (needX509Creds) {\n\n            gnutls_certificate_server_credentials x509_cred =\n\n                vnc_tls_initialize_x509_cred(vs->vd);\n\n            if (!x509_cred) {\n\n                gnutls_deinit(vs->tls.session);\n\n                vs->tls.session = NULL;\n\n                vnc_client_error(vs);\n\n                return -1;\n\n            }\n\n            if (gnutls_credentials_set(vs->tls.session,\n\n                                       GNUTLS_CRD_CERTIFICATE, x509_cred) < 0) {\n\n                gnutls_deinit(vs->tls.session);\n\n                vs->tls.session = NULL;\n\n                gnutls_certificate_free_credentials(x509_cred);\n\n                vnc_client_error(vs);\n\n                return -1;\n\n            }\n\n            if (vs->vd->tls.x509verify) {\n\n                VNC_DEBUG(\"Requesting a client certificate\\n\");\n\n                gnutls_certificate_server_set_request(vs->tls.session,\n\n                                                      GNUTLS_CERT_REQUEST);\n\n            }\n\n\n\n        } else {\n\n            gnutls_anon_server_credentials_t anon_cred =\n\n                vnc_tls_initialize_anon_cred();\n\n            if (!anon_cred) {\n\n                gnutls_deinit(vs->tls.session);\n\n                vs->tls.session = NULL;\n\n                vnc_client_error(vs);\n\n                return -1;\n\n            }\n\n            if (gnutls_credentials_set(vs->tls.session,\n\n                                       GNUTLS_CRD_ANON, anon_cred) < 0) {\n\n                gnutls_deinit(vs->tls.session);\n\n                vs->tls.session = NULL;\n\n                gnutls_anon_free_server_credentials(anon_cred);\n\n                vnc_client_error(vs);\n\n                return -1;\n\n            }\n\n        }\n\n\n\n        gnutls_transport_set_ptr(vs->tls.session, (gnutls_transport_ptr_t)vs);\n\n        gnutls_transport_set_push_function(vs->tls.session, vnc_tls_push);\n\n        gnutls_transport_set_pull_function(vs->tls.session, vnc_tls_pull);\n\n    }\n\n    return 0;\n\n}\n", "idx": 26856, "_split": "valid", "_hash": "42a9b90c4d963e75d60833b5c15b20af"}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static inline void bt_hci_lmp_acl_data(struct bt_hci_s *hci, uint16_t handle,\n\n                const uint8_t *data, int start, int len)\n\n{\n\n    struct hci_acl_hdr *pkt = (void *) hci->acl_buf;\n\n\n\n    /* TODO: packet flags */\n\n    /* TODO: avoid memcpy'ing */\n\n\n\n    if (len + HCI_ACL_HDR_SIZE > sizeof(hci->acl_buf)) {\n\n        fprintf(stderr, \"%s: can't take ACL packets %i bytes long\\n\",\n\n                        __FUNCTION__, len);\n\n        return;\n\n    }\n\n    memcpy(hci->acl_buf + HCI_ACL_HDR_SIZE, data, len);\n\n\n\n    pkt->handle = cpu_to_le16(\n\n                    acl_handle_pack(handle, start ? ACL_START : ACL_CONT));\n\n    pkt->dlen = cpu_to_le16(len);\n\n    hci->info.acl_recv(hci->info.opaque,\n\n                    hci->acl_buf, len + HCI_ACL_HDR_SIZE);\n\n}\n", "idx": 26875, "_split": "valid", "_hash": "2b3a27e39f1f7ddfce7cd0c049e30d02"}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "static void xilinx_enet_init(Object *obj)\n\n{\n\n    XilinxAXIEnet *s = XILINX_AXI_ENET(obj);\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);\n\n    Error *errp = NULL;\n\n\n\n    object_property_add_link(obj, \"axistream-connected\", TYPE_STREAM_SLAVE,\n\n                             (Object **) &s->tx_dev, &errp);\n\n    assert_no_error(errp);\n\n\n\n    object_initialize(&s->rx_data_dev, TYPE_XILINX_AXI_ENET_DATA_STREAM);\n\n    object_property_add_child(OBJECT(s), \"axistream-connected-target\",\n\n                              (Object *)&s->rx_data_dev, &errp);\n\n    assert_no_error(errp);\n\n\n\n    sysbus_init_irq(sbd, &s->irq);\n\n\n\n    memory_region_init_io(&s->iomem, &enet_ops, s, \"enet\", 0x40000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n}\n", "idx": 26892, "_split": "valid", "_hash": "ed8b6579c3edb619dff8ee01010ceaf9"}
{"project": "qemu", "commit_id": "23326164ae6fe8d94b7eff123e03f97ca6978d33", "target": 0, "func": "bool address_space_rw(AddressSpace *as, hwaddr addr, uint8_t *buf,\n\n                      int len, bool is_write)\n\n{\n\n    hwaddr l;\n\n    uint8_t *ptr;\n\n    uint64_t val;\n\n    hwaddr addr1;\n\n    MemoryRegion *mr;\n\n    bool error = false;\n\n\n\n    while (len > 0) {\n\n        l = len;\n\n        mr = address_space_translate(as, addr, &addr1, &l, is_write);\n\n\n\n        if (is_write) {\n\n            if (!memory_access_is_direct(mr, is_write)) {\n\n                l = memory_access_size(mr, l, addr1);\n\n                /* XXX: could force current_cpu to NULL to avoid\n\n                   potential bugs */\n\n                if (l == 4) {\n\n                    /* 32 bit write access */\n\n                    val = ldl_p(buf);\n\n                    error |= io_mem_write(mr, addr1, val, 4);\n\n                } else if (l == 2) {\n\n                    /* 16 bit write access */\n\n                    val = lduw_p(buf);\n\n                    error |= io_mem_write(mr, addr1, val, 2);\n\n                } else {\n\n                    /* 8 bit write access */\n\n                    val = ldub_p(buf);\n\n                    error |= io_mem_write(mr, addr1, val, 1);\n\n                }\n\n            } else {\n\n                addr1 += memory_region_get_ram_addr(mr);\n\n                /* RAM case */\n\n                ptr = qemu_get_ram_ptr(addr1);\n\n                memcpy(ptr, buf, l);\n\n                invalidate_and_set_dirty(addr1, l);\n\n            }\n\n        } else {\n\n            if (!memory_access_is_direct(mr, is_write)) {\n\n                /* I/O case */\n\n                l = memory_access_size(mr, l, addr1);\n\n                if (l == 4) {\n\n                    /* 32 bit read access */\n\n                    error |= io_mem_read(mr, addr1, &val, 4);\n\n                    stl_p(buf, val);\n\n                } else if (l == 2) {\n\n                    /* 16 bit read access */\n\n                    error |= io_mem_read(mr, addr1, &val, 2);\n\n                    stw_p(buf, val);\n\n                } else {\n\n                    /* 8 bit read access */\n\n                    error |= io_mem_read(mr, addr1, &val, 1);\n\n                    stb_p(buf, val);\n\n                }\n\n            } else {\n\n                /* RAM case */\n\n                ptr = qemu_get_ram_ptr(mr->ram_addr + addr1);\n\n                memcpy(buf, ptr, l);\n\n            }\n\n        }\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n    }\n\n\n\n    return error;\n\n}\n", "idx": 26893, "_split": "valid", "_hash": "6beed9485167aa460e2ce5908c0cf3ae"}
{"project": "qemu", "commit_id": "5c55ff99fa88158871d5b9f619c485deae5f3d5b", "target": 0, "func": "static int create_ppc_opcodes (CPUPPCState *env, const ppc_def_t *def)\n\n{\n\n    opcode_t *opc, *start, *end;\n\n\n\n    fill_new_table(env->opcodes, 0x40);\n\n    if (&opc_start < &opc_end) {\n\n        start = &opc_start;\n\n        end = &opc_end;\n\n    } else {\n\n        start = &opc_end;\n\n        end = &opc_start;\n\n    }\n\n    for (opc = start + 1; opc != end; opc++) {\n\n        if ((opc->handler.type & def->insns_flags) != 0) {\n\n            if (register_insn(env->opcodes, opc) < 0) {\n\n                printf(\"*** ERROR initializing PowerPC instruction \"\n\n                       \"0x%02x 0x%02x 0x%02x\\n\", opc->opc1, opc->opc2,\n\n                       opc->opc3);\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n    fix_opcode_tables(env->opcodes);\n\n    fflush(stdout);\n\n    fflush(stderr);\n\n\n\n    return 0;\n\n}\n", "idx": 26906, "_split": "valid", "_hash": "3f39522daf8064ae35bdf1fe3b73a6fb"}
{"project": "qemu", "commit_id": "b7f43fe46029d8fd0594cd599fa2599dcce0f553", "target": 1, "func": "Object *object_dynamic_cast_assert(Object *obj, const char *typename)\n\n{\n\n    Object *inst;\n\n\n\n    inst = object_dynamic_cast(obj, typename);\n\n\n\n    if (!inst) {\n\n        fprintf(stderr, \"Object %p is not an instance of type %s\\n\",\n\n                obj, typename);\n\n        abort();\n\n    }\n\n\n\n    return inst;\n\n}\n", "idx": 26933, "_split": "valid", "_hash": "f69a962d8f588570654ce3a3000841b1"}
{"project": "qemu", "commit_id": "6658ffb81ee56a510d7d77025872a508a9adce3a", "target": 1, "func": "static inline int gen_intermediate_code_internal(CPUState *env, \n\n                                                 TranslationBlock *tb, \n\n                                                 int search_pc)\n\n{\n\n    DisasContext dc1, *dc = &dc1;\n\n    uint16_t *gen_opc_end;\n\n    int j, lj;\n\n    target_ulong pc_start;\n\n    uint32_t next_page_start;\n\n    \n\n    /* generate intermediate code */\n\n    pc_start = tb->pc;\n\n       \n\n    dc->tb = tb;\n\n\n\n    gen_opc_ptr = gen_opc_buf;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    gen_opparam_ptr = gen_opparam_buf;\n\n\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->pc = pc_start;\n\n    dc->singlestep_enabled = env->singlestep_enabled;\n\n    dc->condjmp = 0;\n\n    dc->thumb = env->thumb;\n\n\n#if !defined(CONFIG_USER_ONLY)\n\n    dc->user = (env->uncached_cpsr & 0x1f) == ARM_CPU_MODE_USR;\n\n#endif\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    nb_gen_labels = 0;\n\n    lj = -1;\n\n    do {\n\n        if (env->nb_breakpoints > 0) {\n\n            for(j = 0; j < env->nb_breakpoints; j++) {\n\n                if (env->breakpoints[j] == dc->pc) {\n\n                    gen_op_movl_T0_im((long)dc->pc);\n\n                    gen_op_movl_reg_TN[0][15]();\n\n                    gen_op_debug();\n\n                    dc->is_jmp = DISAS_JUMP;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (search_pc) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n            }\n\n            gen_opc_pc[lj] = dc->pc;\n\n            gen_opc_instr_start[lj] = 1;\n\n        }\n\n\n\n        if (env->thumb)\n\n          disas_thumb_insn(dc);\n\n        else\n\n          disas_arm_insn(env, dc);\n\n\n\n        if (dc->condjmp && !dc->is_jmp) {\n\n            gen_set_label(dc->condlabel);\n\n            dc->condjmp = 0;\n\n        }\n\n        /* Terminate the TB on memory ops if watchpoints are present.  */\n\n        /* FIXME: This should be replacd by the deterministic execution\n\n         * IRQ raising bits.  */\n\n        if (dc->is_mem && env->nb_watchpoints)\n\n            break;\n\n\n\n        /* Translation stops when a conditional branch is enoutered.\n\n         * Otherwise the subsequent code could get translated several times.\n\n         * Also stop translation when a page boundary is reached.  This\n\n         * ensures prefech aborts occur at the right place.  */\n\n    } while (!dc->is_jmp && gen_opc_ptr < gen_opc_end &&\n\n             !env->singlestep_enabled &&\n\n             dc->pc < next_page_start);\n\n    /* At this stage dc->condjmp will only be set when the skipped\n\n     * instruction was a conditional branch, and the PC has already been\n\n     * written.  */\n\n    if (__builtin_expect(env->singlestep_enabled, 0)) {\n\n        /* Make sure the pc is updated, and raise a debug exception.  */\n\n        if (dc->condjmp) {\n\n            gen_op_debug();\n\n            gen_set_label(dc->condlabel);\n\n        }\n\n        if (dc->condjmp || !dc->is_jmp) {\n\n            gen_op_movl_T0_im((long)dc->pc);\n\n            gen_op_movl_reg_TN[0][15]();\n\n            dc->condjmp = 0;\n\n        }\n\n        gen_op_debug();\n\n    } else {\n\n        switch(dc->is_jmp) {\n\n        case DISAS_NEXT:\n\n            gen_goto_tb(dc, 1, dc->pc);\n\n            break;\n\n        default:\n\n        case DISAS_JUMP:\n\n        case DISAS_UPDATE:\n\n            /* indicate that the hash table must be used to find the next TB */\n\n            gen_op_movl_T0_0();\n\n            gen_op_exit_tb();\n\n            break;\n\n        case DISAS_TB_JUMP:\n\n            /* nothing more to generate */\n\n            break;\n\n        }\n\n        if (dc->condjmp) {\n\n            gen_set_label(dc->condlabel);\n\n            gen_goto_tb(dc, 1, dc->pc);\n\n            dc->condjmp = 0;\n\n        }\n\n    }\n\n    *gen_opc_ptr = INDEX_op_end;\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n        fprintf(logfile, \"----------------\\n\");\n\n        fprintf(logfile, \"IN: %s\\n\", lookup_symbol(pc_start));\n\n        target_disas(logfile, pc_start, dc->pc - pc_start, env->thumb);\n\n        fprintf(logfile, \"\\n\");\n\n        if (loglevel & (CPU_LOG_TB_OP)) {\n\n            fprintf(logfile, \"OP:\\n\");\n\n            dump_ops(gen_opc_buf, gen_opparam_buf);\n\n            fprintf(logfile, \"\\n\");\n\n        }\n\n    }\n\n#endif\n\n    if (search_pc) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n        tb->size = 0;\n\n    } else {\n\n        tb->size = dc->pc - pc_start;\n\n    }\n\n    return 0;\n\n}", "idx": 26934, "_split": "valid", "_hash": "2e7727076a358fa3e2b9f2b5c270948c"}
{"project": "qemu", "commit_id": "1c46efaa0a175e468772405385ca26a1e35dd94c", "target": 0, "func": "static void qcow_aio_read_cb(void *opaque, int ret)\n\n{\n\n    QCowAIOCB *acb = opaque;\n\n    BlockDriverState *bs = acb->common.bs;\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster, n1;\n\n\n\n    acb->hd_aiocb = NULL;\n\n    if (ret < 0)\n\n        goto done;\n\n\n\n    /* post process the read buffer */\n\n    if (!acb->cluster_offset) {\n\n        /* nothing to do */\n\n    } else if (acb->cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n        /* nothing to do */\n\n    } else {\n\n        if (s->crypt_method) {\n\n            qcow2_encrypt_sectors(s, acb->sector_num, acb->buf, acb->buf,\n\n                            acb->cur_nr_sectors, 0,\n\n                            &s->aes_decrypt_key);\n\n        }\n\n    }\n\n\n\n    acb->remaining_sectors -= acb->cur_nr_sectors;\n\n    acb->sector_num += acb->cur_nr_sectors;\n\n    acb->buf += acb->cur_nr_sectors * 512;\n\n\n\n    if (acb->remaining_sectors == 0) {\n\n        /* request completed */\n\n        ret = 0;\n\n        goto done;\n\n    }\n\n\n\n    /* prepare next AIO request */\n\n    acb->cur_nr_sectors = acb->remaining_sectors;\n\n    acb->cluster_offset = qcow2_get_cluster_offset(bs, acb->sector_num << 9,\n\n                                                   &acb->cur_nr_sectors);\n\n    index_in_cluster = acb->sector_num & (s->cluster_sectors - 1);\n\n\n\n    if (!acb->cluster_offset) {\n\n        if (bs->backing_hd) {\n\n            /* read from the base image */\n\n            n1 = qcow2_backing_read1(bs->backing_hd, acb->sector_num,\n\n                               acb->buf, acb->cur_nr_sectors);\n\n            if (n1 > 0) {\n\n                acb->hd_iov.iov_base = (void *)acb->buf;\n\n                acb->hd_iov.iov_len = acb->cur_nr_sectors * 512;\n\n                qemu_iovec_init_external(&acb->hd_qiov, &acb->hd_iov, 1);\n\n                BLKDBG_EVENT(bs->file, BLKDBG_READ_BACKING_AIO);\n\n                acb->hd_aiocb = bdrv_aio_readv(bs->backing_hd, acb->sector_num,\n\n                                    &acb->hd_qiov, acb->cur_nr_sectors,\n\n\t\t\t\t    qcow_aio_read_cb, acb);\n\n                if (acb->hd_aiocb == NULL)\n\n                    goto done;\n\n            } else {\n\n                ret = qcow_schedule_bh(qcow_aio_read_bh, acb);\n\n                if (ret < 0)\n\n                    goto done;\n\n            }\n\n        } else {\n\n            /* Note: in this case, no need to wait */\n\n            memset(acb->buf, 0, 512 * acb->cur_nr_sectors);\n\n            ret = qcow_schedule_bh(qcow_aio_read_bh, acb);\n\n            if (ret < 0)\n\n                goto done;\n\n        }\n\n    } else if (acb->cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n        /* add AIO support for compressed blocks ? */\n\n        if (qcow2_decompress_cluster(bs, acb->cluster_offset) < 0)\n\n            goto done;\n\n        memcpy(acb->buf, s->cluster_cache + index_in_cluster * 512,\n\n               512 * acb->cur_nr_sectors);\n\n        ret = qcow_schedule_bh(qcow_aio_read_bh, acb);\n\n        if (ret < 0)\n\n            goto done;\n\n    } else {\n\n        if ((acb->cluster_offset & 511) != 0) {\n\n            ret = -EIO;\n\n            goto done;\n\n        }\n\n\n\n        acb->hd_iov.iov_base = (void *)acb->buf;\n\n        acb->hd_iov.iov_len = acb->cur_nr_sectors * 512;\n\n        qemu_iovec_init_external(&acb->hd_qiov, &acb->hd_iov, 1);\n\n        BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n        acb->hd_aiocb = bdrv_aio_readv(bs->file,\n\n                            (acb->cluster_offset >> 9) + index_in_cluster,\n\n                            &acb->hd_qiov, acb->cur_nr_sectors,\n\n                            qcow_aio_read_cb, acb);\n\n        if (acb->hd_aiocb == NULL) {\n\n            ret = -EIO;\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    return;\n\ndone:\n\n    if (acb->qiov->niov > 1) {\n\n        qemu_iovec_from_buffer(acb->qiov, acb->orig_buf, acb->qiov->size);\n\n        qemu_vfree(acb->orig_buf);\n\n    }\n\n    acb->common.cb(acb->common.opaque, ret);\n\n    qemu_aio_release(acb);\n\n}\n", "idx": 26953, "_split": "valid", "_hash": "a5bc9feebba9f70bba5f83e952993c2e"}
{"project": "qemu", "commit_id": "d8754f40acb2d30e4735cdcd21a16e7ac29264a3", "target": 0, "func": "opts_end_list(Visitor *v, Error **errp)\n\n{\n\n    OptsVisitor *ov = DO_UPCAST(OptsVisitor, visitor, v);\n\n\n\n    assert(ov->list_mode == LM_STARTED || ov->list_mode == LM_IN_PROGRESS);\n\n    ov->repeated_opts = NULL;\n\n    ov->list_mode = LM_NONE;\n\n}\n", "idx": 26965, "_split": "valid", "_hash": "78c4552ba41f7d0610c22db159813599"}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static CaptureVoiceOut *audio_pcm_capture_find_specific (\n\n    AudioState *s,\n\n    audsettings_t *as\n\n    )\n\n{\n\n    CaptureVoiceOut *cap;\n\n\n\n    for (cap = s->cap_head.lh_first; cap; cap = cap->entries.le_next) {\n\n        if (audio_pcm_info_eq (&cap->hw.info, as)) {\n\n            return cap;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "idx": 26969, "_split": "valid", "_hash": "62b84af9deb752fa2dda82cc3d660100"}
{"project": "qemu", "commit_id": "c599d4d6d6e9bfdb64e54c33a22cb26e3496b96d", "target": 1, "func": "static void QEMU_NORETURN force_sig(int target_sig)\n\n{\n\n    CPUState *cpu = thread_cpu;\n\n    CPUArchState *env = cpu->env_ptr;\n\n    TaskState *ts = (TaskState *)cpu->opaque;\n\n    int host_sig, core_dumped = 0;\n\n    struct sigaction act;\n\n\n\n    host_sig = target_to_host_signal(target_sig);\n\n    trace_user_force_sig(env, target_sig, host_sig);\n\n    gdb_signalled(env, target_sig);\n\n\n\n    /* dump core if supported by target binary format */\n\n    if (core_dump_signal(target_sig) && (ts->bprm->core_dump != NULL)) {\n\n        stop_all_tasks();\n\n        core_dumped =\n\n            ((*ts->bprm->core_dump)(target_sig, env) == 0);\n\n    }\n\n    if (core_dumped) {\n\n        /* we already dumped the core of target process, we don't want\n\n         * a coredump of qemu itself */\n\n        struct rlimit nodump;\n\n        getrlimit(RLIMIT_CORE, &nodump);\n\n        nodump.rlim_cur=0;\n\n        setrlimit(RLIMIT_CORE, &nodump);\n\n        (void) fprintf(stderr, \"qemu: uncaught target signal %d (%s) - %s\\n\",\n\n            target_sig, strsignal(host_sig), \"core dumped\" );\n\n    }\n\n\n\n    /* The proper exit code for dying from an uncaught signal is\n\n     * -<signal>.  The kernel doesn't allow exit() or _exit() to pass\n\n     * a negative value.  To get the proper exit code we need to\n\n     * actually die from an uncaught signal.  Here the default signal\n\n     * handler is installed, we send ourself a signal and we wait for\n\n     * it to arrive. */\n\n    sigfillset(&act.sa_mask);\n\n    act.sa_handler = SIG_DFL;\n\n    act.sa_flags = 0;\n\n    sigaction(host_sig, &act, NULL);\n\n\n\n    /* For some reason raise(host_sig) doesn't send the signal when\n\n     * statically linked on x86-64. */\n\n    kill(getpid(), host_sig);\n\n\n\n    /* Make sure the signal isn't masked (just reuse the mask inside\n\n    of act) */\n\n    sigdelset(&act.sa_mask, host_sig);\n\n    sigsuspend(&act.sa_mask);\n\n\n\n    /* unreachable */\n\n    abort();\n\n}\n", "idx": 26984, "_split": "valid", "_hash": "f0af6d47bbd8f1c56d7da3a0a050fc5b"}
{"project": "qemu", "commit_id": "8dfbaa6ac450c4ec2646b1ca08a4017052a90c1d", "target": 0, "func": "static int virtio_ccw_hcall_notify(const uint64_t *args)\n\n{\n\n    uint64_t subch_id = args[0];\n\n    uint64_t queue = args[1];\n\n    SubchDev *sch;\n\n    int cssid, ssid, schid, m;\n\n\n\n    if (ioinst_disassemble_sch_ident(subch_id, &m, &cssid, &ssid, &schid)) {\n\n        return -EINVAL;\n\n    }\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (!sch || !css_subch_visible(sch)) {\n\n        return -EINVAL;\n\n    }\n\n    if (queue >= VIRTIO_PCI_QUEUE_MAX) {\n\n        return -EINVAL;\n\n    }\n\n    virtio_queue_notify(virtio_ccw_get_vdev(sch), queue);\n\n    return 0;\n\n\n\n}\n", "idx": 27008, "_split": "valid", "_hash": "33f5119fc503e1adc30f43ce4c21c4bb"}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline void cris_fidx_i(unsigned int x)\n\n{\n\n\tregister unsigned int v asm(\"$r10\") = x;\n\n\tasm (\"fidxi\\t[%0]\\n\" : : \"r\" (v) );\n\n}\n", "idx": 27036, "_split": "valid", "_hash": "2d83a48fc8c552bc5082111b78b115d7"}
{"project": "qemu", "commit_id": "b6fcf32d9b851a83dedcb609091236b97cc4a985", "target": 0, "func": "static void test_nested_struct_list(gconstpointer opaque)\n\n{\n\n    TestArgs *args = (TestArgs *) opaque;\n\n    const SerializeOps *ops = args->ops;\n\n    UserDefNestedList *listp = NULL, *tmp, *tmp_copy, *listp_copy = NULL;\n\n    Error *err = NULL;\n\n    void *serialize_data;\n\n    int i = 0;\n\n\n\n    for (i = 0; i < 8; i++) {\n\n        tmp = g_malloc0(sizeof(UserDefNestedList));\n\n        tmp->value = nested_struct_create();\n\n        tmp->next = listp;\n\n        listp = tmp;\n\n    }\n\n    \n\n    ops->serialize(listp, &serialize_data, visit_nested_struct_list, &err);\n\n    ops->deserialize((void **)&listp_copy, serialize_data,\n\n                     visit_nested_struct_list, &err); \n\n\n\n    g_assert(err == NULL);\n\n\n\n    tmp = listp;\n\n    tmp_copy = listp_copy;\n\n    while (listp_copy) {\n\n        g_assert(listp);\n\n        nested_struct_compare(listp->value, listp_copy->value);\n\n        listp = listp->next;\n\n        listp_copy = listp_copy->next;\n\n    }\n\n\n\n    qapi_free_UserDefNestedList(tmp);\n\n    qapi_free_UserDefNestedList(tmp_copy);\n\n\n\n    ops->cleanup(serialize_data);\n\n    g_free(args);\n\n}\n", "idx": 27060, "_split": "valid", "_hash": "9aeb42e5b6d5d13b54077ff2bd64efaf"}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "int qemu_cpu_is_self(void *env)\n\n{\n\n    return 1;\n\n}\n", "idx": 27069, "_split": "valid", "_hash": "1aa3500b7c4bb7c421ffd185e96ec70b"}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num,\n                                  QEMUIOVector *iov, int nb_sectors,\n                                  BlockDriverCompletionFunc *cb, void *opaque)\n{\n    return bdrv_aio_rw_vector(bs, sector_num, iov, nb_sectors,\n                              cb, opaque, 1);\n}", "idx": 27072, "_split": "valid", "_hash": "846152e7093cb1f6ea230f57b8db492f"}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_mcbsp_writeh(void *opaque, target_phys_addr_t addr,\n\n                uint32_t value)\n\n{\n\n    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* DRR2 */\n\n    case 0x02:\t/* DRR1 */\n\n        OMAP_RO_REG(addr);\n\n        return;\n\n\n\n    case 0x04:\t/* DXR2 */\n\n        if (((s->xcr[0] >> 5) & 7) < 3)\t\t\t/* XWDLEN1 */\n\n            return;\n\n        /* Fall through.  */\n\n    case 0x06:\t/* DXR1 */\n\n        if (s->tx_req > 1) {\n\n            s->tx_req -= 2;\n\n            if (s->codec && s->codec->cts) {\n\n                s->codec->out.fifo[s->codec->out.len ++] = (value >> 8) & 0xff;\n\n                s->codec->out.fifo[s->codec->out.len ++] = (value >> 0) & 0xff;\n\n            }\n\n            if (s->tx_req < 2)\n\n                omap_mcbsp_tx_done(s);\n\n        } else\n\n            printf(\"%s: Tx FIFO overrun\\n\", __FUNCTION__);\n\n        return;\n\n\n\n    case 0x08:\t/* SPCR2 */\n\n        s->spcr[1] &= 0x0002;\n\n        s->spcr[1] |= 0x03f9 & value;\n\n        s->spcr[1] |= 0x0004 & (value << 2);\t\t/* XEMPTY := XRST */\n\n        if (~value & 1)\t\t\t\t\t/* XRST */\n\n            s->spcr[1] &= ~6;\n\n        omap_mcbsp_req_update(s);\n\n        return;\n\n    case 0x0a:\t/* SPCR1 */\n\n        s->spcr[0] &= 0x0006;\n\n        s->spcr[0] |= 0xf8f9 & value;\n\n        if (value & (1 << 15))\t\t\t\t/* DLB */\n\n            printf(\"%s: Digital Loopback mode enable attempt\\n\", __FUNCTION__);\n\n        if (~value & 1) {\t\t\t\t/* RRST */\n\n            s->spcr[0] &= ~6;\n\n            s->rx_req = 0;\n\n            omap_mcbsp_rx_done(s);\n\n        }\n\n        omap_mcbsp_req_update(s);\n\n        return;\n\n\n\n    case 0x0c:\t/* RCR2 */\n\n        s->rcr[1] = value & 0xffff;\n\n        return;\n\n    case 0x0e:\t/* RCR1 */\n\n        s->rcr[0] = value & 0x7fe0;\n\n        return;\n\n    case 0x10:\t/* XCR2 */\n\n        s->xcr[1] = value & 0xffff;\n\n        return;\n\n    case 0x12:\t/* XCR1 */\n\n        s->xcr[0] = value & 0x7fe0;\n\n        return;\n\n    case 0x14:\t/* SRGR2 */\n\n        s->srgr[1] = value & 0xffff;\n\n        omap_mcbsp_req_update(s);\n\n        return;\n\n    case 0x16:\t/* SRGR1 */\n\n        s->srgr[0] = value & 0xffff;\n\n        omap_mcbsp_req_update(s);\n\n        return;\n\n    case 0x18:\t/* MCR2 */\n\n        s->mcr[1] = value & 0x03e3;\n\n        if (value & 3)\t\t\t\t\t/* XMCM */\n\n            printf(\"%s: Tx channel selection mode enable attempt\\n\",\n\n                            __FUNCTION__);\n\n        return;\n\n    case 0x1a:\t/* MCR1 */\n\n        s->mcr[0] = value & 0x03e1;\n\n        if (value & 1)\t\t\t\t\t/* RMCM */\n\n            printf(\"%s: Rx channel selection mode enable attempt\\n\",\n\n                            __FUNCTION__);\n\n        return;\n\n    case 0x1c:\t/* RCERA */\n\n        s->rcer[0] = value & 0xffff;\n\n        return;\n\n    case 0x1e:\t/* RCERB */\n\n        s->rcer[1] = value & 0xffff;\n\n        return;\n\n    case 0x20:\t/* XCERA */\n\n        s->xcer[0] = value & 0xffff;\n\n        return;\n\n    case 0x22:\t/* XCERB */\n\n        s->xcer[1] = value & 0xffff;\n\n        return;\n\n    case 0x24:\t/* PCR0 */\n\n        s->pcr = value & 0x7faf;\n\n        return;\n\n    case 0x26:\t/* RCERC */\n\n        s->rcer[2] = value & 0xffff;\n\n        return;\n\n    case 0x28:\t/* RCERD */\n\n        s->rcer[3] = value & 0xffff;\n\n        return;\n\n    case 0x2a:\t/* XCERC */\n\n        s->xcer[2] = value & 0xffff;\n\n        return;\n\n    case 0x2c:\t/* XCERD */\n\n        s->xcer[3] = value & 0xffff;\n\n        return;\n\n    case 0x2e:\t/* RCERE */\n\n        s->rcer[4] = value & 0xffff;\n\n        return;\n\n    case 0x30:\t/* RCERF */\n\n        s->rcer[5] = value & 0xffff;\n\n        return;\n\n    case 0x32:\t/* XCERE */\n\n        s->xcer[4] = value & 0xffff;\n\n        return;\n\n    case 0x34:\t/* XCERF */\n\n        s->xcer[5] = value & 0xffff;\n\n        return;\n\n    case 0x36:\t/* RCERG */\n\n        s->rcer[6] = value & 0xffff;\n\n        return;\n\n    case 0x38:\t/* RCERH */\n\n        s->rcer[7] = value & 0xffff;\n\n        return;\n\n    case 0x3a:\t/* XCERG */\n\n        s->xcer[6] = value & 0xffff;\n\n        return;\n\n    case 0x3c:\t/* XCERH */\n\n        s->xcer[7] = value & 0xffff;\n\n        return;\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n}\n", "idx": 27095, "_split": "valid", "_hash": "850f65493898fa8eea1459df25777427"}
{"project": "qemu", "commit_id": "ec9c10d29c6bb5613a680af62f5825d3bb2d31d4", "target": 1, "func": "static DriveInfo *blockdev_init(QDict *bs_opts,\n\n                                BlockInterfaceType type,\n\n                                Error **errp)\n\n{\n\n    const char *buf;\n\n    const char *file = NULL;\n\n    const char *serial;\n\n    int ro = 0;\n\n    int bdrv_flags = 0;\n\n    int on_read_error, on_write_error;\n\n    DriveInfo *dinfo;\n\n    ThrottleConfig cfg;\n\n    int snapshot = 0;\n\n    bool copy_on_read;\n\n    int ret;\n\n    Error *error = NULL;\n\n    QemuOpts *opts;\n\n    const char *id;\n\n    bool has_driver_specific_opts;\n\n    BlockDriver *drv = NULL;\n\n\n\n    /* Check common options by copying from bs_opts to opts, all other options\n\n     * stay in bs_opts for processing by bdrv_open(). */\n\n    id = qdict_get_try_str(bs_opts, \"id\");\n\n    opts = qemu_opts_create(&qemu_common_drive_opts, id, 1, &error);\n\n    if (error_is_set(&error)) {\n\n        error_propagate(errp, error);\n\n        return NULL;\n\n    }\n\n\n\n    qemu_opts_absorb_qdict(opts, bs_opts, &error);\n\n    if (error_is_set(&error)) {\n\n        error_propagate(errp, error);\n\n        return NULL;\n\n    }\n\n\n\n    if (id) {\n\n        qdict_del(bs_opts, \"id\");\n\n    }\n\n\n\n    has_driver_specific_opts = !!qdict_size(bs_opts);\n\n\n\n    /* extract parameters */\n\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n    ro = qemu_opt_get_bool(opts, \"read-only\", 0);\n\n    copy_on_read = qemu_opt_get_bool(opts, \"copy-on-read\", false);\n\n\n\n    file = qemu_opt_get(opts, \"file\");\n\n    serial = qemu_opt_get(opts, \"serial\");\n\n\n\n    if ((buf = qemu_opt_get(opts, \"discard\")) != NULL) {\n\n        if (bdrv_parse_discard_flags(buf, &bdrv_flags) != 0) {\n\n            error_setg(errp, \"invalid discard option\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"cache.writeback\", true)) {\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    }\n\n    if (qemu_opt_get_bool(opts, \"cache.direct\", false)) {\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    }\n\n    if (qemu_opt_get_bool(opts, \"cache.no-flush\", false)) {\n\n        bdrv_flags |= BDRV_O_NO_FLUSH;\n\n    }\n\n\n\n#ifdef CONFIG_LINUX_AIO\n\n    if ((buf = qemu_opt_get(opts, \"aio\")) != NULL) {\n\n        if (!strcmp(buf, \"native\")) {\n\n            bdrv_flags |= BDRV_O_NATIVE_AIO;\n\n        } else if (!strcmp(buf, \"threads\")) {\n\n            /* this is the default */\n\n        } else {\n\n           error_setg(errp, \"invalid aio option\");\n\n           return NULL;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n\n        if (is_help_option(buf)) {\n\n            error_printf(\"Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            error_printf(\"\\n\");\n\n            return NULL;\n\n        }\n\n\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            error_setg(errp, \"'%s' invalid format\", buf);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* disk I/O throttling */\n\n    memset(&cfg, 0, sizeof(cfg));\n\n    cfg.buckets[THROTTLE_BPS_TOTAL].avg =\n\n        qemu_opt_get_number(opts, \"throttling.bps-total\", 0);\n\n    cfg.buckets[THROTTLE_BPS_READ].avg  =\n\n        qemu_opt_get_number(opts, \"throttling.bps-read\", 0);\n\n    cfg.buckets[THROTTLE_BPS_WRITE].avg =\n\n        qemu_opt_get_number(opts, \"throttling.bps-write\", 0);\n\n    cfg.buckets[THROTTLE_OPS_TOTAL].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-total\", 0);\n\n    cfg.buckets[THROTTLE_OPS_READ].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-read\", 0);\n\n    cfg.buckets[THROTTLE_OPS_WRITE].avg =\n\n        qemu_opt_get_number(opts, \"throttling.iops-write\", 0);\n\n\n\n    cfg.buckets[THROTTLE_BPS_TOTAL].max =\n\n        qemu_opt_get_number(opts, \"throttling.bps-total-max\", 0);\n\n    cfg.buckets[THROTTLE_BPS_READ].max  =\n\n        qemu_opt_get_number(opts, \"throttling.bps-read-max\", 0);\n\n    cfg.buckets[THROTTLE_BPS_WRITE].max =\n\n        qemu_opt_get_number(opts, \"throttling.bps-write-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_TOTAL].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-total-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_READ].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-read-max\", 0);\n\n    cfg.buckets[THROTTLE_OPS_WRITE].max =\n\n        qemu_opt_get_number(opts, \"throttling.iops-write-max\", 0);\n\n\n\n    cfg.op_size = qemu_opt_get_number(opts, \"throttling.iops-size\", 0);\n\n\n\n    if (!check_throttle_config(&cfg, &error)) {\n\n        error_propagate(errp, error);\n\n        return NULL;\n\n    }\n\n\n\n    on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;\n\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO && type != IF_NONE) {\n\n            error_setg(errp, \"werror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_write_error = parse_block_error_action(buf, 0, &error);\n\n        if (error_is_set(&error)) {\n\n            error_propagate(errp, error);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    on_read_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI && type != IF_NONE) {\n\n            error_report(\"rerror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_read_error = parse_block_error_action(buf, 1, &error);\n\n        if (error_is_set(&error)) {\n\n            error_propagate(errp, error);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* init */\n\n    dinfo = g_malloc0(sizeof(*dinfo));\n\n    dinfo->id = g_strdup(qemu_opts_id(opts));\n\n    dinfo->bdrv = bdrv_new(dinfo->id);\n\n    dinfo->bdrv->open_flags = snapshot ? BDRV_O_SNAPSHOT : 0;\n\n    dinfo->bdrv->read_only = ro;\n\n    dinfo->type = type;\n\n    dinfo->refcount = 1;\n\n    if (serial != NULL) {\n\n        dinfo->serial = g_strdup(serial);\n\n    }\n\n    QTAILQ_INSERT_TAIL(&drives, dinfo, next);\n\n\n\n    bdrv_set_on_error(dinfo->bdrv, on_read_error, on_write_error);\n\n\n\n    /* disk I/O throttling */\n\n    if (throttle_enabled(&cfg)) {\n\n        bdrv_io_limits_enable(dinfo->bdrv);\n\n        bdrv_set_io_limits(dinfo->bdrv, &cfg);\n\n    }\n\n\n\n    if (!file || !*file) {\n\n        if (has_driver_specific_opts) {\n\n            file = NULL;\n\n        } else {\n\n            return dinfo;\n\n        }\n\n    }\n\n    if (snapshot) {\n\n        /* always use cache=unsafe with snapshot */\n\n        bdrv_flags &= ~BDRV_O_CACHE_MASK;\n\n        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB|BDRV_O_NO_FLUSH);\n\n    }\n\n\n\n    if (copy_on_read) {\n\n        bdrv_flags |= BDRV_O_COPY_ON_READ;\n\n    }\n\n\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n\n        bdrv_flags |= BDRV_O_INCOMING;\n\n    }\n\n\n\n    bdrv_flags |= ro ? 0 : BDRV_O_RDWR;\n\n\n\n    QINCREF(bs_opts);\n\n    ret = bdrv_open(dinfo->bdrv, file, bs_opts, bdrv_flags, drv, &error);\n\n\n\n    if (ret < 0) {\n\n        error_setg(errp, \"could not open disk image %s: %s\",\n\n                   file ?: dinfo->id, error_get_pretty(error));\n\n        error_free(error);\n\n        goto err;\n\n    }\n\n\n\n    if (bdrv_key_required(dinfo->bdrv))\n\n        autostart = 0;\n\n\n\n    QDECREF(bs_opts);\n\n    qemu_opts_del(opts);\n\n\n\n    return dinfo;\n\n\n\nerr:\n\n    qemu_opts_del(opts);\n\n    QDECREF(bs_opts);\n\n    bdrv_unref(dinfo->bdrv);\n\n    g_free(dinfo->id);\n\n    QTAILQ_REMOVE(&drives, dinfo, next);\n\n    g_free(dinfo);\n\n    return NULL;\n\n}\n", "idx": 27115, "_split": "valid", "_hash": "1170315e699960f76015a4243a04cb66"}
{"project": "qemu", "commit_id": "7e84c2498f0ff3999937d18d1e9abaa030400000", "target": 0, "func": "static inline int load_segment(uint32_t *e1_ptr, uint32_t *e2_ptr,\n\n                               int selector)\n\n{\n\n    SegmentCache *dt;\n\n    int index;\n\n    uint8_t *ptr;\n\n\n\n    if (selector & 0x4)\n\n        dt = &env->ldt;\n\n    else\n\n        dt = &env->gdt;\n\n    index = selector & ~7;\n\n    if ((index + 7) > dt->limit)\n\n        return -1;\n\n    ptr = dt->base + index;\n\n    *e1_ptr = ldl_kernel(ptr);\n\n    *e2_ptr = ldl_kernel(ptr + 4);\n\n    return 0;\n\n}\n", "idx": 27187, "_split": "valid", "_hash": "f6529e9383a602f12697225194123de0"}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_bh_schedule_oneshot(AioContext *ctx, QEMUBHFunc *cb, void *opaque)\n\n{\n\n    QEMUBH *bh;\n\n    bh = g_new(QEMUBH, 1);\n\n    *bh = (QEMUBH){\n\n        .ctx = ctx,\n\n        .cb = cb,\n\n        .opaque = opaque,\n\n    };\n\n    qemu_lockcnt_lock(&ctx->list_lock);\n\n    bh->next = ctx->first_bh;\n\n    bh->scheduled = 1;\n\n    bh->deleted = 1;\n\n    /* Make sure that the members are ready before putting bh into list */\n\n    smp_wmb();\n\n    ctx->first_bh = bh;\n\n    qemu_lockcnt_unlock(&ctx->list_lock);\n\n    aio_notify(ctx);\n\n}\n", "idx": 27242, "_split": "valid", "_hash": "0a4855c1bef680d20b2d96a835e7036a"}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static int32_t virtio_net_flush_tx(VirtIONetQueue *q)\n\n{\n\n    VirtIONet *n = q->n;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n    VirtQueueElement elem;\n\n    int32_t num_packets = 0;\n\n    int queue_index = vq2q(virtio_get_queue_index(q->tx_vq));\n\n    if (!(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK)) {\n\n        return num_packets;\n\n    }\n\n\n\n    if (q->async_tx.elem.out_num) {\n\n        virtio_queue_set_notification(q->tx_vq, 0);\n\n        return num_packets;\n\n    }\n\n\n\n    while (virtqueue_pop(q->tx_vq, &elem)) {\n\n        ssize_t ret;\n\n        unsigned int out_num = elem.out_num;\n\n        struct iovec *out_sg = &elem.out_sg[0];\n\n        struct iovec sg[VIRTQUEUE_MAX_SIZE], sg2[VIRTQUEUE_MAX_SIZE + 1];\n\n        struct virtio_net_hdr_mrg_rxbuf mhdr;\n\n\n\n        if (out_num < 1) {\n\n            error_report(\"virtio-net header not in first element\");\n\n            exit(1);\n\n        }\n\n\n\n        if (n->has_vnet_hdr) {\n\n            if (iov_to_buf(out_sg, out_num, 0, &mhdr, n->guest_hdr_len) <\n\n                n->guest_hdr_len) {\n\n                error_report(\"virtio-net header incorrect\");\n\n                exit(1);\n\n            }\n\n            if (virtio_needs_swap(vdev)) {\n\n                virtio_net_hdr_swap(vdev, (void *) &mhdr);\n\n                sg2[0].iov_base = &mhdr;\n\n                sg2[0].iov_len = n->guest_hdr_len;\n\n                out_num = iov_copy(&sg2[1], ARRAY_SIZE(sg2) - 1,\n\n                                   out_sg, out_num,\n\n                                   n->guest_hdr_len, -1);\n\n                if (out_num == VIRTQUEUE_MAX_SIZE) {\n\n                    goto drop;\n\n\t\t}\n\n                out_num += 1;\n\n                out_sg = sg2;\n\n\t    }\n\n        }\n\n        /*\n\n         * If host wants to see the guest header as is, we can\n\n         * pass it on unchanged. Otherwise, copy just the parts\n\n         * that host is interested in.\n\n         */\n\n        assert(n->host_hdr_len <= n->guest_hdr_len);\n\n        if (n->host_hdr_len != n->guest_hdr_len) {\n\n            unsigned sg_num = iov_copy(sg, ARRAY_SIZE(sg),\n\n                                       out_sg, out_num,\n\n                                       0, n->host_hdr_len);\n\n            sg_num += iov_copy(sg + sg_num, ARRAY_SIZE(sg) - sg_num,\n\n                             out_sg, out_num,\n\n                             n->guest_hdr_len, -1);\n\n            out_num = sg_num;\n\n            out_sg = sg;\n\n        }\n\n\n\n        ret = qemu_sendv_packet_async(qemu_get_subqueue(n->nic, queue_index),\n\n                                      out_sg, out_num, virtio_net_tx_complete);\n\n        if (ret == 0) {\n\n            virtio_queue_set_notification(q->tx_vq, 0);\n\n            q->async_tx.elem = elem;\n\n            return -EBUSY;\n\n        }\n\n\n\ndrop:\n\n        virtqueue_push(q->tx_vq, &elem, 0);\n\n        virtio_notify(vdev, q->tx_vq);\n\n\n\n        if (++num_packets >= n->tx_burst) {\n\n            break;\n\n        }\n\n    }\n\n    return num_packets;\n\n}\n", "idx": 27247, "_split": "valid", "_hash": "99c75169b11e4b72b65c3416f7f57a28"}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "static void sdhci_data_transfer(void *opaque)\n\n{\n\n    SDHCIState *s = (SDHCIState *)opaque;\n\n\n\n    if (s->trnmod & SDHC_TRNS_DMA) {\n\n        switch (SDHC_DMA_TYPE(s->hostctl)) {\n\n        case SDHC_CTRL_SDMA:\n\n            if ((s->blkcnt == 1) || !(s->trnmod & SDHC_TRNS_MULTI)) {\n\n                sdhci_sdma_transfer_single_block(s);\n\n            } else {\n\n                sdhci_sdma_transfer_multi_blocks(s);\n\n            }\n\n\n\n            break;\n\n        case SDHC_CTRL_ADMA1_32:\n\n            if (!(s->capareg & SDHC_CAN_DO_ADMA1)) {\n\n                ERRPRINT(\"ADMA1 not supported\\n\");\n\n                break;\n\n            }\n\n\n\n            sdhci_do_adma(s);\n\n            break;\n\n        case SDHC_CTRL_ADMA2_32:\n\n            if (!(s->capareg & SDHC_CAN_DO_ADMA2)) {\n\n                ERRPRINT(\"ADMA2 not supported\\n\");\n\n                break;\n\n            }\n\n\n\n            sdhci_do_adma(s);\n\n            break;\n\n        case SDHC_CTRL_ADMA2_64:\n\n            if (!(s->capareg & SDHC_CAN_DO_ADMA2) ||\n\n                    !(s->capareg & SDHC_64_BIT_BUS_SUPPORT)) {\n\n                ERRPRINT(\"64 bit ADMA not supported\\n\");\n\n                break;\n\n            }\n\n\n\n            sdhci_do_adma(s);\n\n            break;\n\n        default:\n\n            ERRPRINT(\"Unsupported DMA type\\n\");\n\n            break;\n\n        }\n\n    } else {\n\n        if ((s->trnmod & SDHC_TRNS_READ) && sdbus_data_ready(&s->sdbus)) {\n\n            s->prnsts |= SDHC_DOING_READ | SDHC_DATA_INHIBIT |\n\n                    SDHC_DAT_LINE_ACTIVE;\n\n            sdhci_read_block_from_card(s);\n\n        } else {\n\n            s->prnsts |= SDHC_DOING_WRITE | SDHC_DAT_LINE_ACTIVE |\n\n                    SDHC_SPACE_AVAILABLE | SDHC_DATA_INHIBIT;\n\n            sdhci_write_block_to_card(s);\n\n        }\n\n    }\n\n}\n", "idx": 27259, "_split": "valid", "_hash": "c05f715549352075d686017241cf73e4"}
{"project": "qemu", "commit_id": "2637c754ccdb286890ed2a8d0d1da775dbd062af", "target": 0, "func": "void cpu_dump_state(CPUState *env, FILE *f,\n\n                    int (*cpu_fprintf)(FILE *f, const char *fmt, ...),\n\n                    int flags)\n\n{\n\n    int eflags, i, nb;\n\n    char cc_op_name[32];\n\n    static const char *seg_name[6] = { \"ES\", \"CS\", \"SS\", \"DS\", \"FS\", \"GS\" };\n\n\n\n    if (kvm_enabled())\n\n        kvm_arch_get_registers(env);\n\n\n\n    eflags = env->eflags;\n\n#ifdef TARGET_X86_64\n\n    if (env->hflags & HF_CS64_MASK) {\n\n        cpu_fprintf(f,\n\n                    \"RAX=%016\" PRIx64 \" RBX=%016\" PRIx64 \" RCX=%016\" PRIx64 \" RDX=%016\" PRIx64 \"\\n\"\n\n                    \"RSI=%016\" PRIx64 \" RDI=%016\" PRIx64 \" RBP=%016\" PRIx64 \" RSP=%016\" PRIx64 \"\\n\"\n\n                    \"R8 =%016\" PRIx64 \" R9 =%016\" PRIx64 \" R10=%016\" PRIx64 \" R11=%016\" PRIx64 \"\\n\"\n\n                    \"R12=%016\" PRIx64 \" R13=%016\" PRIx64 \" R14=%016\" PRIx64 \" R15=%016\" PRIx64 \"\\n\"\n\n                    \"RIP=%016\" PRIx64 \" RFL=%08x [%c%c%c%c%c%c%c] CPL=%d II=%d A20=%d SMM=%d HLT=%d\\n\",\n\n                    env->regs[R_EAX],\n\n                    env->regs[R_EBX],\n\n                    env->regs[R_ECX],\n\n                    env->regs[R_EDX],\n\n                    env->regs[R_ESI],\n\n                    env->regs[R_EDI],\n\n                    env->regs[R_EBP],\n\n                    env->regs[R_ESP],\n\n                    env->regs[8],\n\n                    env->regs[9],\n\n                    env->regs[10],\n\n                    env->regs[11],\n\n                    env->regs[12],\n\n                    env->regs[13],\n\n                    env->regs[14],\n\n                    env->regs[15],\n\n                    env->eip, eflags,\n\n                    eflags & DF_MASK ? 'D' : '-',\n\n                    eflags & CC_O ? 'O' : '-',\n\n                    eflags & CC_S ? 'S' : '-',\n\n                    eflags & CC_Z ? 'Z' : '-',\n\n                    eflags & CC_A ? 'A' : '-',\n\n                    eflags & CC_P ? 'P' : '-',\n\n                    eflags & CC_C ? 'C' : '-',\n\n                    env->hflags & HF_CPL_MASK,\n\n                    (env->hflags >> HF_INHIBIT_IRQ_SHIFT) & 1,\n\n                    (int)(env->a20_mask >> 20) & 1,\n\n                    (env->hflags >> HF_SMM_SHIFT) & 1,\n\n                    env->halted);\n\n    } else\n\n#endif\n\n    {\n\n        cpu_fprintf(f, \"EAX=%08x EBX=%08x ECX=%08x EDX=%08x\\n\"\n\n                    \"ESI=%08x EDI=%08x EBP=%08x ESP=%08x\\n\"\n\n                    \"EIP=%08x EFL=%08x [%c%c%c%c%c%c%c] CPL=%d II=%d A20=%d SMM=%d HLT=%d\\n\",\n\n                    (uint32_t)env->regs[R_EAX],\n\n                    (uint32_t)env->regs[R_EBX],\n\n                    (uint32_t)env->regs[R_ECX],\n\n                    (uint32_t)env->regs[R_EDX],\n\n                    (uint32_t)env->regs[R_ESI],\n\n                    (uint32_t)env->regs[R_EDI],\n\n                    (uint32_t)env->regs[R_EBP],\n\n                    (uint32_t)env->regs[R_ESP],\n\n                    (uint32_t)env->eip, eflags,\n\n                    eflags & DF_MASK ? 'D' : '-',\n\n                    eflags & CC_O ? 'O' : '-',\n\n                    eflags & CC_S ? 'S' : '-',\n\n                    eflags & CC_Z ? 'Z' : '-',\n\n                    eflags & CC_A ? 'A' : '-',\n\n                    eflags & CC_P ? 'P' : '-',\n\n                    eflags & CC_C ? 'C' : '-',\n\n                    env->hflags & HF_CPL_MASK,\n\n                    (env->hflags >> HF_INHIBIT_IRQ_SHIFT) & 1,\n\n                    (int)(env->a20_mask >> 20) & 1,\n\n                    (env->hflags >> HF_SMM_SHIFT) & 1,\n\n                    env->halted);\n\n    }\n\n\n\n    for(i = 0; i < 6; i++) {\n\n        cpu_x86_dump_seg_cache(env, f, cpu_fprintf, seg_name[i],\n\n                               &env->segs[i]);\n\n    }\n\n    cpu_x86_dump_seg_cache(env, f, cpu_fprintf, \"LDT\", &env->ldt);\n\n    cpu_x86_dump_seg_cache(env, f, cpu_fprintf, \"TR\", &env->tr);\n\n\n\n#ifdef TARGET_X86_64\n\n    if (env->hflags & HF_LMA_MASK) {\n\n        cpu_fprintf(f, \"GDT=     %016\" PRIx64 \" %08x\\n\",\n\n                    env->gdt.base, env->gdt.limit);\n\n        cpu_fprintf(f, \"IDT=     %016\" PRIx64 \" %08x\\n\",\n\n                    env->idt.base, env->idt.limit);\n\n        cpu_fprintf(f, \"CR0=%08x CR2=%016\" PRIx64 \" CR3=%016\" PRIx64 \" CR4=%08x\\n\",\n\n                    (uint32_t)env->cr[0],\n\n                    env->cr[2],\n\n                    env->cr[3],\n\n                    (uint32_t)env->cr[4]);\n\n        for(i = 0; i < 4; i++)\n\n            cpu_fprintf(f, \"DR%d=%016\" PRIx64 \" \", i, env->dr[i]);\n\n        cpu_fprintf(f, \"\\nDR6=%016\" PRIx64 \" DR7=%016\" PRIx64 \"\\n\",\n\n                    env->dr[6], env->dr[7]);\n\n    } else\n\n#endif\n\n    {\n\n        cpu_fprintf(f, \"GDT=     %08x %08x\\n\",\n\n                    (uint32_t)env->gdt.base, env->gdt.limit);\n\n        cpu_fprintf(f, \"IDT=     %08x %08x\\n\",\n\n                    (uint32_t)env->idt.base, env->idt.limit);\n\n        cpu_fprintf(f, \"CR0=%08x CR2=%08x CR3=%08x CR4=%08x\\n\",\n\n                    (uint32_t)env->cr[0],\n\n                    (uint32_t)env->cr[2],\n\n                    (uint32_t)env->cr[3],\n\n                    (uint32_t)env->cr[4]);\n\n        for(i = 0; i < 4; i++)\n\n            cpu_fprintf(f, \"DR%d=%08x \", i, env->dr[i]);\n\n        cpu_fprintf(f, \"\\nDR6=%08x DR7=%08x\\n\", env->dr[6], env->dr[7]);\n\n    }\n\n    if (flags & X86_DUMP_CCOP) {\n\n        if ((unsigned)env->cc_op < CC_OP_NB)\n\n            snprintf(cc_op_name, sizeof(cc_op_name), \"%s\", cc_op_str[env->cc_op]);\n\n        else\n\n            snprintf(cc_op_name, sizeof(cc_op_name), \"[%d]\", env->cc_op);\n\n#ifdef TARGET_X86_64\n\n        if (env->hflags & HF_CS64_MASK) {\n\n            cpu_fprintf(f, \"CCS=%016\" PRIx64 \" CCD=%016\" PRIx64 \" CCO=%-8s\\n\",\n\n                        env->cc_src, env->cc_dst,\n\n                        cc_op_name);\n\n        } else\n\n#endif\n\n        {\n\n            cpu_fprintf(f, \"CCS=%08x CCD=%08x CCO=%-8s\\n\",\n\n                        (uint32_t)env->cc_src, (uint32_t)env->cc_dst,\n\n                        cc_op_name);\n\n        }\n\n    }\n\n    if (flags & X86_DUMP_FPU) {\n\n        int fptag;\n\n        fptag = 0;\n\n        for(i = 0; i < 8; i++) {\n\n            fptag |= ((!env->fptags[i]) << i);\n\n        }\n\n        cpu_fprintf(f, \"FCW=%04x FSW=%04x [ST=%d] FTW=%02x MXCSR=%08x\\n\",\n\n                    env->fpuc,\n\n                    (env->fpus & ~0x3800) | (env->fpstt & 0x7) << 11,\n\n                    env->fpstt,\n\n                    fptag,\n\n                    env->mxcsr);\n\n        for(i=0;i<8;i++) {\n\n#if defined(USE_X86LDOUBLE)\n\n            union {\n\n                long double d;\n\n                struct {\n\n                    uint64_t lower;\n\n                    uint16_t upper;\n\n                } l;\n\n            } tmp;\n\n            tmp.d = env->fpregs[i].d;\n\n            cpu_fprintf(f, \"FPR%d=%016\" PRIx64 \" %04x\",\n\n                        i, tmp.l.lower, tmp.l.upper);\n\n#else\n\n            cpu_fprintf(f, \"FPR%d=%016\" PRIx64,\n\n                        i, env->fpregs[i].mmx.q);\n\n#endif\n\n            if ((i & 1) == 1)\n\n                cpu_fprintf(f, \"\\n\");\n\n            else\n\n                cpu_fprintf(f, \" \");\n\n        }\n\n        if (env->hflags & HF_CS64_MASK)\n\n            nb = 16;\n\n        else\n\n            nb = 8;\n\n        for(i=0;i<nb;i++) {\n\n            cpu_fprintf(f, \"XMM%02d=%08x%08x%08x%08x\",\n\n                        i,\n\n                        env->xmm_regs[i].XMM_L(3),\n\n                        env->xmm_regs[i].XMM_L(2),\n\n                        env->xmm_regs[i].XMM_L(1),\n\n                        env->xmm_regs[i].XMM_L(0));\n\n            if ((i & 1) == 1)\n\n                cpu_fprintf(f, \"\\n\");\n\n            else\n\n                cpu_fprintf(f, \" \");\n\n        }\n\n    }\n\n}\n", "idx": 27264, "_split": "valid", "_hash": "8b8c48a0f22c515179e11adec0ab15b6"}
{"project": "qemu", "commit_id": "9012a53f067a78022947e18050b145c34a3dc599", "target": 0, "func": "static void rtas_start_cpu(PowerPCCPU *cpu_, sPAPRMachineState *spapr,\n\n                           uint32_t token, uint32_t nargs,\n\n                           target_ulong args,\n\n                           uint32_t nret, target_ulong rets)\n\n{\n\n    target_ulong id, start, r3;\n\n    PowerPCCPU *cpu;\n\n\n\n    if (nargs != 3 || nret != 1) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    id = rtas_ld(args, 0);\n\n    start = rtas_ld(args, 1);\n\n    r3 = rtas_ld(args, 2);\n\n\n\n    cpu = spapr_find_cpu(id);\n\n    if (cpu != NULL) {\n\n        CPUState *cs = CPU(cpu);\n\n        CPUPPCState *env = &cpu->env;\n\n        PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);\n\n        Error *local_err = NULL;\n\n\n\n        if (!cs->halted) {\n\n            rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n            return;\n\n        }\n\n\n\n        /* This will make sure qemu state is up to date with kvm, and\n\n         * mark it dirty so our changes get flushed back before the\n\n         * new cpu enters */\n\n        kvm_cpu_synchronize_state(cs);\n\n\n\n        /* Set compatibility mode to match existing cpus */\n\n        ppc_set_compat(cpu, POWERPC_CPU(first_cpu)->compat_pvr, &local_err);\n\n        if (local_err) {\n\n            error_report_err(local_err);\n\n            rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n            return;\n\n        }\n\n\n\n        env->msr = (1ULL << MSR_SF) | (1ULL << MSR_ME);\n\n\n\n        /* Enable Power-saving mode Exit Cause exceptions for the new CPU */\n\n        env->spr[SPR_LPCR] |= pcc->lpcr_pm;\n\n\n\n        env->nip = start;\n\n        env->gpr[3] = r3;\n\n        cs->halted = 0;\n\n        spapr_cpu_set_endianness(cpu);\n\n        spapr_cpu_update_tb_offset(cpu);\n\n\n\n        qemu_cpu_kick(cs);\n\n\n\n        rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n        return;\n\n    }\n\n\n\n    /* Didn't find a matching cpu */\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 27269, "_split": "valid", "_hash": "37079ed08717a0aa7cfec72754b71eb3"}
{"project": "qemu", "commit_id": "ad196a9d0c14f681f010bb4b979030ec125ba976", "target": 0, "func": "void net_slirp_redir(Monitor *mon, const char *redir_str, const char *redir_opt2)\n\n{\n\n    struct slirp_config_str *config;\n\n\n\n    if (!slirp_inited) {\n\n        if (mon) {\n\n            monitor_printf(mon, \"user mode network stack not in use\\n\");\n\n        } else {\n\n            config = qemu_malloc(sizeof(*config));\n\n            config->str = redir_str;\n\n            config->next = slirp_redirs;\n\n            slirp_redirs = config;\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (!strcmp(redir_str, \"remove\")) {\n\n        net_slirp_redir_rm(mon, redir_opt2);\n\n        return;\n\n    }\n\n\n\n    slirp_redirection(mon, redir_str);\n\n}\n", "idx": 27275, "_split": "valid", "_hash": "1d26a0abbe8c862d2b19b4363491505b"}
{"project": "qemu", "commit_id": "a6152b52bc50c5cf1cd118a74b483dd3f0748ebd", "target": 0, "func": "int ppc_hash64_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr,\n\n                                int rwx, int mmu_idx)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUPPCState *env = &cpu->env;\n\n    ppc_slb_t *slb;\n\n    unsigned apshift;\n\n    hwaddr ptex;\n\n    ppc_hash_pte64_t pte;\n\n    int pp_prot, amr_prot, prot;\n\n    uint64_t new_pte1, dsisr;\n\n    const int need_prot[] = {PAGE_READ, PAGE_WRITE, PAGE_EXEC};\n\n    hwaddr raddr;\n\n\n\n    assert((rwx == 0) || (rwx == 1) || (rwx == 2));\n\n\n\n    /* Note on LPCR usage: 970 uses HID4, but our special variant\n\n     * of store_spr copies relevant fields into env->spr[SPR_LPCR].\n\n     * Similarily we filter unimplemented bits when storing into\n\n     * LPCR depending on the MMU version. This code can thus just\n\n     * use the LPCR \"as-is\".\n\n     */\n\n\n\n    /* 1. Handle real mode accesses */\n\n    if (((rwx == 2) && (msr_ir == 0)) || ((rwx != 2) && (msr_dr == 0))) {\n\n        /* Translation is supposedly \"off\"  */\n\n        /* In real mode the top 4 effective address bits are (mostly) ignored */\n\n        raddr = eaddr & 0x0FFFFFFFFFFFFFFFULL;\n\n\n\n        /* In HV mode, add HRMOR if top EA bit is clear */\n\n        if (msr_hv || !env->has_hv_mode) {\n\n            if (!(eaddr >> 63)) {\n\n                raddr |= env->spr[SPR_HRMOR];\n\n            }\n\n        } else {\n\n            /* Otherwise, check VPM for RMA vs VRMA */\n\n            if (env->spr[SPR_LPCR] & LPCR_VPM0) {\n\n                slb = &env->vrma_slb;\n\n                if (slb->sps) {\n\n                    goto skip_slb_search;\n\n                }\n\n                /* Not much else to do here */\n\n                cs->exception_index = POWERPC_EXCP_MCHECK;\n\n                env->error_code = 0;\n\n                return 1;\n\n            } else if (raddr < env->rmls) {\n\n                /* RMA. Check bounds in RMLS */\n\n                raddr |= env->spr[SPR_RMOR];\n\n            } else {\n\n                /* The access failed, generate the approriate interrupt */\n\n                if (rwx == 2) {\n\n                    ppc_hash64_set_isi(cs, env, 0x08000000);\n\n                } else {\n\n                    dsisr = 0x08000000;\n\n                    if (rwx == 1) {\n\n                        dsisr |= 0x02000000;\n\n                    }\n\n                    ppc_hash64_set_dsi(cs, env, eaddr, dsisr);\n\n                }\n\n                return 1;\n\n            }\n\n        }\n\n        tlb_set_page(cs, eaddr & TARGET_PAGE_MASK, raddr & TARGET_PAGE_MASK,\n\n                     PAGE_READ | PAGE_WRITE | PAGE_EXEC, mmu_idx,\n\n                     TARGET_PAGE_SIZE);\n\n        return 0;\n\n    }\n\n\n\n    /* 2. Translation is on, so look up the SLB */\n\n    slb = slb_lookup(cpu, eaddr);\n\n    if (!slb) {\n\n        /* No entry found, check if in-memory segment tables are in use */\n\n        if ((env->mmu_model & POWERPC_MMU_V3) && ppc64_use_proc_tbl(cpu)) {\n\n            /* TODO - Unsupported */\n\n            error_report(\"Segment Table Support Unimplemented\");\n\n            exit(1);\n\n        }\n\n        /* Segment still not found, generate the appropriate interrupt */\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISEG;\n\n            env->error_code = 0;\n\n        } else {\n\n            cs->exception_index = POWERPC_EXCP_DSEG;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n        }\n\n        return 1;\n\n    }\n\n\n\nskip_slb_search:\n\n\n\n    /* 3. Check for segment level no-execute violation */\n\n    if ((rwx == 2) && (slb->vsid & SLB_VSID_N)) {\n\n        ppc_hash64_set_isi(cs, env, 0x10000000);\n\n        return 1;\n\n    }\n\n\n\n    /* 4. Locate the PTE in the hash table */\n\n    ptex = ppc_hash64_htab_lookup(cpu, slb, eaddr, &pte, &apshift);\n\n    if (ptex == -1) {\n\n        dsisr = 0x40000000;\n\n        if (rwx == 2) {\n\n            ppc_hash64_set_isi(cs, env, dsisr);\n\n        } else {\n\n            if (rwx == 1) {\n\n                dsisr |= 0x02000000;\n\n            }\n\n            ppc_hash64_set_dsi(cs, env, eaddr, dsisr);\n\n        }\n\n        return 1;\n\n    }\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n                  \"found PTE at index %08\" HWADDR_PRIx \"\\n\", ptex);\n\n\n\n    /* 5. Check access permissions */\n\n\n\n    pp_prot = ppc_hash64_pte_prot(cpu, slb, pte);\n\n    amr_prot = ppc_hash64_amr_prot(cpu, pte);\n\n    prot = pp_prot & amr_prot;\n\n\n\n    if ((need_prot[rwx] & ~prot) != 0) {\n\n        /* Access right violation */\n\n        qemu_log_mask(CPU_LOG_MMU, \"PTE access rejected\\n\");\n\n        if (rwx == 2) {\n\n            ppc_hash64_set_isi(cs, env, 0x08000000);\n\n        } else {\n\n            dsisr = 0;\n\n            if (need_prot[rwx] & ~pp_prot) {\n\n                dsisr |= 0x08000000;\n\n            }\n\n            if (rwx == 1) {\n\n                dsisr |= 0x02000000;\n\n            }\n\n            if (need_prot[rwx] & ~amr_prot) {\n\n                dsisr |= 0x00200000;\n\n            }\n\n            ppc_hash64_set_dsi(cs, env, eaddr, dsisr);\n\n        }\n\n        return 1;\n\n    }\n\n\n\n    qemu_log_mask(CPU_LOG_MMU, \"PTE access granted !\\n\");\n\n\n\n    /* 6. Update PTE referenced and changed bits if necessary */\n\n\n\n    new_pte1 = pte.pte1 | HPTE64_R_R; /* set referenced bit */\n\n    if (rwx == 1) {\n\n        new_pte1 |= HPTE64_R_C; /* set changed (dirty) bit */\n\n    } else {\n\n        /* Treat the page as read-only for now, so that a later write\n\n         * will pass through this function again to set the C bit */\n\n        prot &= ~PAGE_WRITE;\n\n    }\n\n\n\n    if (new_pte1 != pte.pte1) {\n\n        ppc_hash64_store_hpte(cpu, ptex, pte.pte0, new_pte1);\n\n    }\n\n\n\n    /* 7. Determine the real address from the PTE */\n\n\n\n    raddr = deposit64(pte.pte1 & HPTE64_R_RPN, 0, apshift, eaddr);\n\n\n\n    tlb_set_page(cs, eaddr & TARGET_PAGE_MASK, raddr & TARGET_PAGE_MASK,\n\n                 prot, mmu_idx, 1ULL << apshift);\n\n\n\n    return 0;\n\n}\n", "idx": 27276, "_split": "valid", "_hash": "432d91d2084158468ff143880ea0cd4a"}
{"project": "qemu", "commit_id": "196a778428989217b82de042725dc8eb29c8f8d8", "target": 1, "func": "static void qxl_reset_surfaces(PCIQXLDevice *d)\n\n{\n\n    dprint(d, 1, \"%s:\\n\", __FUNCTION__);\n\n    d->mode = QXL_MODE_UNDEFINED;\n\n    qemu_mutex_unlock_iothread();\n\n    d->ssd.worker->destroy_surfaces(d->ssd.worker);\n\n    qemu_mutex_lock_iothread();\n\n    memset(&d->guest_surfaces.cmds, 0, sizeof(d->guest_surfaces.cmds));\n\n}\n", "idx": 27290, "_split": "valid", "_hash": "11de3041d7a75f421917d53c13240cf6"}
